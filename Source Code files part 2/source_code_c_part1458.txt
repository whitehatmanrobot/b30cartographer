ionTrigger(
                                              (unsigned char*) lpvBuffer,
                                              *lpdwDataType ) );
        break;

    //
    //  These are private services
    //

    //
    //  Descrption:
    //    Following is a list of options that only work in-process
    //    and are mostly backdoor hand-off of pointers to ill-behaved
    //    applications! A big hack!
    //
    //  Input:
    //    lpvBuffer - pointer to location that will contain the returned value
    //    lpdwSize - pointer to DWORD containing size (UnUsed)
    //    lpdwDataType - pointer to Data type value (Unused)
    //
    //  Return:
    //    *lpvBuffer  contains the value
    //
    //  Notes:
    //   Works In-Process
    //   Fails gracefully Out-Of-Process

    case HSE_PRIV_REQ_TSVCINFO:
    case HSE_PRIV_REQ_HTTP_REQUEST:
    case HSE_PRIV_REQ_VROOT_TABLE:
    case HSE_PRIV_REQ_TSVC_CACHE: {

        if( !pWamExecInfo->QueryPWam()->FInProcess() ) {
            fNotSupportedOOP = TRUE;
            break;
        }

        if ( lpvBuffer == NULL ) {

            DBG_ASSERT( FALSE );

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        DoRevertHack( &hCurrentUser );

        fReturn = BoolFromHresult( pIWamRequest->GetPrivatePtr( dwHSERequest, (unsigned char **) &lpvBuffer ) );

        UndoRevertHack( &hCurrentUser );
        break;
    } // case HSE_PRIV_REQ_TSVCINFO: et al



    default: {
        SetLastError( ERROR_INVALID_PARAMETER );
        fReturn = FALSE;
        break;
    } // case default:



    } // switch ( dwHSERequest )



    if (fNotSupportedOOP) {
        SetLastError( ERROR_INVALID_FUNCTION );
        fReturn = FALSE;
    }


LExit:

    //
    //  Release isa context
    //  Balances GetISAContext at top of this function
    //

    ReleaseISAContext(
        &pecb
        , &pWamExecInfo
        , &pIWamRequest
    );


    return ( fReturn );

} // ServerSupportFunction()




BOOL
WINAPI
GetServerVariable(
    HCONN    hConn,
    LPSTR    szVarName,
    LPVOID   lpvBuffer,
    LPDWORD  lpdwSize
    )
{
    BOOL fReturn = FALSE;

    EXTENSION_CONTROL_BLOCK *   pecb = NULL;
    WAM_EXEC_INFO *             pWamExecInfo = NULL;
    IWamRequest *               pIWamRequest = NULL;

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "GetServerVariable:\n\t"
                    "hConn = (%08x)\t"
                    "szVarName = %s\t"
                    "lpvBuffer = (%08x)\t"
                    "*lpdwSize = %d\t"
                    "\n"
                    ,
                    hConn,
                    szVarName,
                    lpvBuffer,
                    lpdwSize ? *lpdwSize : -1
                    ));

    }


    //
    //  Validate ISA-supplied input parameters
    //

    if ( szVarName == NULL || lpdwSize == NULL ) {

        DBG_ASSERT( FALSE );

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }


    //
    //  Get ISA context from connection handle - bail if bogus
    //  - if this succeeds, we have usable WAM_EXEC_INFO and IWamRequest ptrs
    //  - if this fails, GetISAContext calls SetLastError so we don't need to
    //

    if( !GetISAContext( hConn,
                        &pecb,
                        &pWamExecInfo,
                        &pIWamRequest ) ) {
        return FALSE;
    }

    fReturn = BoolFromHresult( pWamExecInfo->GetInfoForName(
                                            pIWamRequest,
                                            (unsigned char *) szVarName,
                                            (unsigned char *) lpvBuffer,
                                            *lpdwSize,
                                            lpdwSize ) );
    
    //
    //  Release isa context
    //  Balances GetISAContext at top of this function
    //

    ReleaseISAContext(
        &pecb
        , &pWamExecInfo
        , &pIWamRequest
    );


    return ( fReturn );

} // GetServerVariable()




/*-----------------------------------------------------------------------------*
WriteClient

Routine Description:
    Writes to the http client on behalf of the ISA

Arguments:
    hConn - Connection context (pointer to WAM_EXEC_INFO)
    Buffer - pointer to the buffer containing the data to be sent to the client
    lpdwBytes - pointer to DWORD that contains the size of data to be
               sent out to client when this function is called.
              On return, if this is a synchronous write, then this location
              will contain the number of bytes actually sent out.
    dwReserved - Reserved set of flags
      For now,
        HSE_IO_ASYNC - indicates that Async Write should be done
        HSE_IO_SYNC  - (default) indicates that Sync. Write should be done.

Return Value:
    TRUE on success, FALSE on failure
    See GetLastError() for error code

Note:
    Atmost one async IO operation is permitted at a given time.
    
    Atmost one sync IO operation should be made. Multiple sync IO operations
    may result in unpredictable result.
    
    Enforcing one sync IO operation would make every single ISAPI to pay a
    penalty for a very few insane ones. So we don't do it.
    
*/
BOOL
WINAPI
WriteClient(
    HCONN    hConn,
    LPVOID   Buffer,
    LPDWORD  lpdwBytes,
    DWORD    dwReserved
    )
{
    BOOL                        fReturn = FALSE;
    EXTENSION_CONTROL_BLOCK *   pecb = NULL;
    WAM_EXEC_INFO *             pWamExecInfo = NULL;
    IWamRequest *               pIWamRequest = NULL;
    HANDLE                      hCurrentUser = NULL;

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WriteClient:\n\t"
                    "hConn = (%08x)\t"
                    "Buffer = (%08x)\t"
                    "*lpdwBytes = %d\t"
                    "\n"
                    ,
                    hConn,
                    Buffer,
                    lpdwBytes ? *lpdwBytes : -1
                    ));

    }

    //
    //  Return failure when invalid Buffer is supplied
    //
    //  NOTE we do this before validating ecb
    //
    if ( (NULL == Buffer) || (NULL == lpdwBytes) ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    //  Ignore zero length sends
    //
    //  NOTE we do this before validating ecb
    //  so we don't need to release iwamreq ptr
    //

    if ( *lpdwBytes == 0 ) {
        return TRUE;
    }

    //
    //  Get ISA context from connection handle - bail if bogus
    //  - if this succeeds, we have usable WAM_EXEC_INFO and IWamRequest ptrs
    //  - if this fails, GetISAContext calls SetLastError so we don't need to
    //

    if( !GetISAContext( hConn,
                        &pecb,
                        &pWamExecInfo,
                        &pIWamRequest ) ) {
        return FALSE;
    }

    if ( !pWamExecInfo->QueryPWam()->FInProcess() )
    {
        hCurrentUser = INVALID_HANDLE_VALUE;
    }

    //
    // Branch based on Async IO or Synchronous IO operation
    //
    
    if ( (dwReserved & HSE_IO_ASYNC) ) {
    
        //
        // Check for error condition in the AsyncIO callback path
        //
        if ((pWamExecInfo->_AsyncIoInfo._pfnHseIO == NULL) ||
            (pWamExecInfo->_AsyncIoInfo._dwOutstandingIO) 
           ) {
           
            DBGPRINTF(( DBG_CONTEXT, 
                        "%08x::Async WriteClient() requested when IO in progress"
                        " or when Context not supplied.\n",
                        pWamExecInfo));

            //
            // Set error code and fall-through 
            //  - so that we will properly release pWamExecInfo 
            //    and WamRequest pointers
            //
            SetLastError( ERROR_INVALID_PARAMETER);
            fReturn = (FALSE);
        
        } else {

            //
            //  1. Set Request state to be async IO from ISAPI client
            //  2. Submit Async IOP
            //  3. Return to the ISAPI application
            //

            pWamExecInfo->InitAsyncIO( ASYNC_IO_TYPE_WRITE );
            
            pWamExecInfo->_AsyncIoInfo._cbLastAsyncIO = *lpdwBytes;
    
            DoRevertHack( &hCurrentUser );

            fReturn = BoolFromHresult(
                        pIWamRequest->AsyncWriteClient(
#ifdef _WIN64
                            (UINT64) pWamExecInfo, 
#else
                            (ULONG_PTR) pWamExecInfo, 
#endif
                            (unsigned char *) Buffer,
                            *lpdwBytes,
                            dwReserved
                        ) );

            UndoRevertHack( &hCurrentUser );
    
            if ( !fReturn ) {

                pWamExecInfo->UninitAsyncIO();
            }
        }

} else {

    //
    // Submit synchronous IO operation
    //
    DWORD   cbToWrite = *lpdwBytes;

    DoRevertHack( &hCurrentUser );
    
    fReturn = BoolFromHresult( pIWamRequest->
                                   SyncWriteClient( cbToWrite,
                                                    (unsigned char *) Buffer,
                                                    lpdwBytes,
                                                    dwReserved ) );
    UndoRevertHack( &hCurrentUser );
}

//
//  Release isa context
//  Balances GetISAContext at top of this function
//

ReleaseISAContext(
    &pecb
    , &pWamExecInfo
    , &pIWamRequest
    );


return ( fReturn );

} // WriteClient()




BOOL
WINAPI
ReadClient(
    HCONN    hConn,
    LPVOID   Buffer,
    LPDWORD  lpdwBytes
    )
{
    BOOL    fReturn = FALSE;

    EXTENSION_CONTROL_BLOCK *   pecb = NULL;
    WAM_EXEC_INFO *             pWamExecInfo = NULL;
    IWamRequest *               pIWamRequest = NULL;
    HANDLE                      hCurrentUser = NULL;

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "ReadClient:\n\t"
                    "hConn = (%08x)\t"
                    "Buffer = (%08x)\t"
                    "*lpdwBytes = %d\t"
                    "\n"
                    ,
                    hConn,
                    Buffer,
                    lpdwBytes ? *lpdwBytes : -1
                    ));

    }


    //
    //  Return failure when invalid Buffer is supplied
    //
    //  NOTE we do this before validating ecb
    //
    if ( (NULL == Buffer) || (NULL == lpdwBytes) ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    //  Get ISA context from connection handle - bail if bogus
    //  - if this succeeds, we have usable WAM_EXEC_INFO and IWamRequest ptrs
    //  - if this fails, GetISAContext calls SetLastError so we don't need to
    //

    if( !GetISAContext(   hConn,
                        &pecb,
                        &pWamExecInfo,
                        &pIWamRequest ) ) {
        return FALSE;
    }

    if ( !pWamExecInfo->QueryPWam()->FInProcess() )
    {
        hCurrentUser = INVALID_HANDLE_VALUE;
    }

    DoRevertHack( &hCurrentUser );

    fReturn = BoolFromHresult( pIWamRequest->SyncReadClient(
                                (unsigned char *) Buffer,
                                *lpdwBytes,
                                lpdwBytes) );

    UndoRevertHack( &hCurrentUser );

    //
    //  Release isa context
    //  Balances GetISAContext at top of this function
    //

    ReleaseISAContext(
        &pecb
        , &pWamExecInfo
        , &pIWamRequest
        );


    return ( fReturn );

} // ReadClient()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\wamccf.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
       wamccf.cxx

   Abstract:
       This module implements the WAM Custom Class Factory
       which creates WAM objects regardless of passed class id

   Author:
       Dmitry Robsman   ( dmitryr )     07-Apr-1997

   Environment:
       User Mode - Win32

   Project:
       Wam DLL

--*/

/************************************************************
 *     Include Headers
 ************************************************************/
#include <isapip.hxx>
#include "setable.hxx"
#include "wamobj.hxx"
#include "wamccf.hxx"

/************************************************************
 *     W A M  C C F   
 ************************************************************/

WAM_CCF::WAM_CCF()
/*++

Routine Description:
    WAM_CCF Constructor

Arguments:

Return Value:

--*/
    : 
    m_cRef(0),
    m_pcfAtl(NULL)
    {

    // Query ATL's class factory for WAM

    _Module.GetClassObject
        (
        CLSID_Wam,
        IID_IClassFactory,
        (void **)(&m_pcfAtl)
        );
    }

/*----------------------------------------------------------*/
    
WAM_CCF::~WAM_CCF()
/*++

Routine Description:
    WAM_CCF Destructor

Arguments:

Return Value:

--*/
    {
    if (m_pcfAtl)
        m_pcfAtl->Release();
    }

/*----------------------------------------------------------*/

STDMETHODIMP 
WAM_CCF::QueryInterface
(
REFIID riid,
LPVOID *ppv
)
/*++

Routine Description:
    WAM_CCF implementation of IUnknown::QueryInterface

Arguments:
    REFIID riid     interface id
    LPVOID *ppv     [out]

Return Value:
    HRESULT

--*/
    {
    if (!ppv)
        return E_POINTER;

    if (!m_pcfAtl)  // must have original CF to create WAMs
        return E_NOINTERFACE;
        
    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IClassFactory == riid)
        *ppv = this;

    if (*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
    }

/*----------------------------------------------------------*/
    
STDMETHODIMP_(ULONG) 
WAM_CCF::AddRef()
/*++

Routine Description:
    WAM_CCF implementation of IUnknown::AddRef

Arguments:

Return Value:
    ref count

--*/
    {
    return (ULONG)InterlockedIncrement((LPLONG)(&m_cRef));
    }
    
/*----------------------------------------------------------*/

STDMETHODIMP_(ULONG) 
WAM_CCF::Release()
/*++

Routine Description:
    WAM_CCF implementation of IUnknown::Release

Arguments:

Return Value:
    ref count

--*/
    {
    ULONG cRef = (ULONG)InterlockedDecrement((LPLONG)(&m_cRef));
    if (cRef > 0)
        return cRef;

    delete this;
    return 0;
    }
    
/*----------------------------------------------------------*/

STDMETHODIMP
WAM_CCF::CreateInstance
(
LPUNKNOWN pUnkOuter,
REFIID    riid, 
LPVOID    *ppvObj
)
/*++

Routine Description:
    WAM_CCF implementation of IClassFactory::CreateInstance
    Delegate to default ATL CF

Arguments:
    LPUNKNOWN pUnkOuter     outer object
    REFIID    riid          interface id to query
    LPVOID   *ppvObj        [out]

Return Value:
    HRESULT

--*/
    {
    if (!m_pcfAtl)
        return E_UNEXPECTED;

    return m_pcfAtl->CreateInstance(pUnkOuter, riid, ppvObj);
    }
    
/*----------------------------------------------------------*/

STDMETHODIMP
WAM_CCF::LockServer
(
BOOL fLock
)
/*++

Routine Description:
    WAM_CCF implementation of IClassFactory::LockServer
    Delegate to default ATL CF

Arguments:
    BOOL fLock      flag (lock/unlock)

Return Value:
    HRESULT

--*/
    {
    if (!m_pcfAtl)
        return E_UNEXPECTED;
        
    m_pcfAtl->LockServer(fLock);
	return NOERROR;
    }


/************************************************************
 *     W A M  C C F  M O D U L E
 ************************************************************/

WAM_CCF_MODULE::WAM_CCF_MODULE()
/*++

Routine Description:
    WAM_CCF_MODULE Constructor

Arguments:

Return Value:

--*/
    : 
    m_pCF(NULL)
    {
    }

/*----------------------------------------------------------*/

WAM_CCF_MODULE::~WAM_CCF_MODULE()
/*++

Routine Description:
    WAM_CCF_MODULE Destructor

Arguments:

Return Value:

--*/
    {
    }
    
/*----------------------------------------------------------*/

HRESULT 
WAM_CCF_MODULE::Init()
/*++

Routine Description:
    Initialize WAM_CCF_MODULE. Create Custom Class Factory.

Arguments:

Return Value:
    HRESULT

--*/
    {
    m_pCF = new WAM_CCF;
    if (!m_pCF)
        return E_OUTOFMEMORY;
        
    m_pCF->AddRef(); // keep AddRef()'d
    return NOERROR;
    }

/*----------------------------------------------------------*/
        
HRESULT 
WAM_CCF_MODULE::Term()
/*++

Routine Description:
    UnInitialize WAM_CCF_MODULE. Remove Custom Class Factory.

Arguments:

Return Value:
    HRESULT

--*/
    {
    if (m_pCF)
        {
        m_pCF->Release();
        m_pCF = NULL;
        }

    return NOERROR;
    }

/*----------------------------------------------------------*/

HRESULT 
WAM_CCF_MODULE::GetClassObject
(
REFCLSID rclsid,
REFIID riid,
LPVOID *ppv
)
/*++

Routine Description:
    Gives out to the called an addref'd Custom Class Library

Arguments:
    REFCLSID rclsid     Class Id (ignored)
    REFIID   riid       QI CCF for this
    LPVOID  *ppv        [out] returned CCF pointer

Return Value:
    HRESULT

--*/
    {
    if (!m_pCF)
        return CLASS_E_CLASSNOTAVAILABLE;

    // CONSIDER: verify rclsid somehow
    
    return m_pCF->QueryInterface(riid, ppv);
    }

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\setable.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       setable.cxx

   Abstract:
       This module declares the SE_TABLE object which consists
       of all the extensions for W3 service

   Author:

       Murali R. Krishnan    ( MuraliK )     18-July-1996

   Environment:

       User Mode - Win32

   Project:

       W3 Services DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <isapip.hxx>

# include "isapidll.hxx"
# include "setable.hxx"

# include <issched.hxx>

/************************************************************
 *     Global Data
 ************************************************************/

PSE_TABLE  g_psextensions;      // all extensions
static BOOL g_fExtInitialized = FALSE;




/**************************************************
 *   Member functions of SESD_LIST
 **************************************************/


SESD_LIST::SESD_LIST(VOID)
    : m_idWorkItem( 0)
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock);
    InitializeListHead( &m_Head);
    
} // SESD_LIST::SESD_LIST()


SESD_LIST::~SESD_LIST(VOID)
{
    // Should be all done
    DBG_ASSERT( 0 == m_idWorkItem);
    DBG_ASSERT( IsListEmpty( &m_Head));
    
    DeleteCriticalSection( &m_csLock);

}  // SESD_LIST::~SESD_LIST()



VOID
SESD_LIST::ScheduleExtensionForDeletion(
    IN PHSE psExt
    )
{
    Lock();

    // add to the list
    InsertHeadList( &m_Head, &psExt->m_ListEntry);

    if ( 0 == m_idWorkItem) {
        // schedule the work item if not scheduled one already
        m_idWorkItem = ScheduleWorkItem( SchedulerCallback, this, 0);
        DBG_ASSERT( 0 != m_idWorkItem);
    }

    Unlock();

    return;
} // SESD_LIST::ScheduleExtensionForDeletion()



VOID
SESD_LIST::WaitTillFinished(VOID)
{
    Lock();

    // wait until nothing is scheduled
    
    while ( 0 != m_idWorkItem) {

        // let it drain itself while in the unlocked state
        Unlock();
        Sleep( 200 );
        Lock();
    }

    Unlock();

    return;
} // SESD_LIST::WaitTillFinished()



VOID
WINAPI
SESD_LIST::SchedulerCallback(
    void *pvContext
    )
{
    DBG_ASSERT( NULL != pvContext);

    ((SESD_LIST *)pvContext)->DeleteScheduledExtensions();

    return;
} // SESD_LIST::SchedulerCallback()


VOID
SESD_LIST::DeleteScheduledExtensions(VOID)
{
    PHSE  psExt;
    
    Lock();

    // If it is scheduled there better be a reason why
    DBG_ASSERT( 0 != m_idWorkItem);

    while ( !IsListEmpty( &m_Head)) {

        // extract extension from the list and delete it
        
        psExt = CONTAINING_RECORD( m_Head.Flink,
                                   HSE_BASE,
                                   m_ListEntry );

        RemoveEntryList( &psExt->m_ListEntry );
        InitializeListHead( &psExt->m_ListEntry);

        delete psExt;
        
    } // while
    

    // reset to 0 to indicate that we are done
    m_idWorkItem = 0;

    Unlock();

    return;
} // SESD_LIST::DeleteScheduledExtensions()



/**************************************************
 *   Member functions of SE_TABLE
 **************************************************/


SE_TABLE::SE_TABLE(VOID)
    : m_cRefWams ( 0)
{
    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "Constructing SE_TABLE(%08x)\n", this));
    }

    INITIALIZE_CRITICAL_SECTION( &m_csLock);
    InitializeListHead( &m_ExtensionHead);

} // SE_TABLE::SE_TABLE()


SE_TABLE::~SE_TABLE(VOID)
{
    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "Deleteing SE_TABLE(%08x) cWamRef=%d\n",
                    this, m_cRefWams));
    }

    // unload all the extensions if not already done
    DBG_REQUIRE( UnloadExtensions());

    // No WAM should be holding ref to the SE_TABLE
    DBG_ASSERT( 0 == m_cRefWams);

    DeleteCriticalSection( &m_csLock);
    DBG_ASSERT( IsListEmpty( &m_ExtensionHead));

} // SE_TABLE::~SE_TABLE()




VOID
SE_TABLE::Print(VOID)
{
    PLIST_ENTRY  pEntry;
    int i = 0;

    // NYI: I need to write code to print out data here.
    DBGPRINTF(( DBG_CONTEXT,
                " SE_TABLE(%08x) ListHead=%08x  [%08x:%08x] cRefWams=%d\n",
                this, &m_ExtensionHead,
                m_ExtensionHead.Flink, m_ExtensionHead.Blink,
                m_cRefWams
                ));

    Lock();

    for ( pEntry  = m_ExtensionHead.Flink;
          (pEntry != &m_ExtensionHead);
          pEntry  = pEntry->Flink, i++ )
    {
        HSE_BASE *
            pExtension = CONTAINING_RECORD( pEntry, HSE_BASE, m_ListEntry );

        DBGPRINTF(( DBG_CONTEXT,
                    " Dll(%d): HSE_BASE = %08x [%08x:%08x]; Module=%s\n",
                    i, pExtension,
                    pExtension->m_ListEntry.Flink,
                    pExtension->m_ListEntry.Blink,
                    pExtension->QueryModuleName()));
    } // for all entries in table

    Unlock();

    return;
} // SE_TABLE::Print()


BOOL
SE_TABLE::GetExtension(
    IN const CHAR *  pchModuleName,
    IN HANDLE        hImpersonation,
    IN BOOL          fCacheImpersonation,
    IN BOOL          fCache,
    OUT PHSE   *     ppsExt
    )
/*++

Routine Description:

    Retrieves an extension's DLL entry point

    The appropriate user should be impersonated before calling this function

Arguments:

    pchModuleName - Extension DLL module name
    hImpersonation - Impersonation token of user making this call
    fCacheImpersonation - if TRUE, the hImpersonation can be cached
    fCache - TRUE if this item should be cached, FALSE otherwise
    ppsExt - pointer to the Extensions handler object

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    LIST_ENTRY *            pEntry;
    HSE_BASE   *            pExtension = NULL;
    BOOL                    fRet = FALSE;

    IF_DEBUG( BGI ) {

        DBGPRINTF(( DBG_CONTEXT, "[GetEntryPoint] Looking for module %s\n",
                    pchModuleName ));

    }

    //
    //  NYI: Optimize the locked section here - reduce time spent inside
    //      the locked block.
    //  Check cache to see if DLL is already loaded
    //

    DWORD cchModuleName = strlen( pchModuleName);

    Lock();

    for ( pEntry  = m_ExtensionHead.Flink;
          pEntry != &m_ExtensionHead;
          pEntry  = pEntry->Flink )
    {
        pExtension = CONTAINING_RECORD( pEntry, HSE_BASE, m_ListEntry );

        if ( pExtension->IsMatch( pchModuleName, cchModuleName)) {
            //
            //  Already Loaded, return the extension object after access check
            //

            fRet = TRUE;
            break;
        } // a match
    } // for all entries in table

    IF_DEBUG( BGI ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "[GetEntryPoint] Lookup module %s => fRet =%d\n",
                    pchModuleName, fRet ));
    }

    if ( !fRet) {

        //
        // The module is not loaded. Load the module now.
        // The module name refers to an ISAPI application.
        // Try ISAPI app loader now...
        pExtension = HSE_APPDLL::LoadModule( pchModuleName,
                                             hImpersonation,
                                             fCache);

        fRet = (pExtension != NULL);
        if (fRet) {
            if ( !fCache) {

                // Temporarily the ref count will drop to 0, but the code below
                //  will bump this up to 1.

                pExtension->Dereference();
            } else {
                // add this extension to the list of cached extensions
                InsertIntoListWithLock( pExtension);
            }
        } else {
            DBGPRINTF((DBG_CONTEXT,
                "LoadModule failed with %x\n",GetLastError()));
        }
    }

    if ( fRet ) {

        if ( pExtension->AccessCheck( hImpersonation, fCacheImpersonation)) {

            DBG_ASSERT( pExtension != NULL);

            if ( ppsExt != NULL) {
                // ref the object before giving ptr away
                pExtension->Reference();
                *ppsExt = pExtension;
            }
        } else {
            fRet = FALSE;
        }
    }

    Unlock();

    return fRet;
} // SE_TABLE::GetExtension()




BOOL
SE_TABLE::RefreshAcl(
            IN const CHAR * pchDLL
            )
/*++

Routine Description:

    This function reloads the ACL on an ISAPI Application .dll after that
    .dll has already been loaded.

Arguments:

    pchDLL - pointer to the ISAPI DLL for which ACL has to be refreshed.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY *   pEntry;
    PHSE           pExtension;
    BOOL           fRet = FALSE;
    BOOL           fFound = FALSE;

    IF_DEBUG( BGI )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[RefreshISAPIAcl] Rereading ACL for %s\n",
                    pchDLL ));

    }

    //
    //  Check cache to see if the DLL is loaded
    //
    DWORD cchDll = strlen( pchDLL);

    Lock();

    for ( pEntry  = m_ExtensionHead.Flink;
          pEntry != &m_ExtensionHead;
          pEntry  = pEntry->Flink )
    {
        pExtension = CONTAINING_RECORD( pEntry, HSE_BASE, m_ListEntry );

        if ( pExtension->IsMatch( pchDLL, cchDll) )
        {
            //
            //  Force an access check on the next request with the new ACL
            //

            fRet = pExtension->LoadAcl();
            fFound = TRUE;
            break;
        }
    }

    Unlock();

    if ( !fFound) { SetLastError( ERROR_FILE_NOT_FOUND ); }

    return (fRet);
} // SE_TABLE::RefreshAcl()



BOOL
SE_TABLE::RefreshAcl(
                      IN DWORD dwId
                      )
/*++

Routine Description:

    This function reloads the ACL on an ISAPI Application .dll after that
    .dll has already been loaded.

Arguments:

    pchDLL - pointer to the ISAPI DLL for which ACL has to be refreshed.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY *  pEntry;
    PHSE          pExtension;
    BOOL          fRet = FALSE;
    BOOL          fFound = FALSE;

    IF_DEBUG( BGI )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[RefreshISAPIAcl] Rereading ACL for %d\n",
                    dwId ));

    }

    //
    //  Check cache to see if the DLL is loaded
    //

    Lock();

    for ( pEntry  = m_ExtensionHead.Flink;
          pEntry != &m_ExtensionHead;
          pEntry  = pEntry->Flink )
    {
        pExtension = CONTAINING_RECORD( pEntry, HSE_BASE, m_ListEntry );

        if ( pExtension->GetDirMonitorId() == dwId )
        {
            //
            //  Force an access check on the next request with the new ACL
            //

            fRet = pExtension->LoadAcl();
            fFound = TRUE;
            break;
        }
    }

    Unlock();

    if ( !fFound) { SetLastError( ERROR_FILE_NOT_FOUND ); }

    return (fRet);
} // SE_TABLE::RefreshAcl()



BOOL
SE_TABLE::FlushAccessToken(
                      IN HANDLE hAccTok
                      )
/*++

Routine Description:

    Reset last successfull user it same as hAccTok

Arguments:

    hAccTok - access token to remove from cache

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY *            pEntry;
    HSE_APPDLL   *            pExtension;
    BOOL                    fRet = FALSE;
    BOOL         fFound = FALSE;

    IF_DEBUG( BGI )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[FlushAccessToken] removing handle %x from cache\n",
                    hAccTok ));

    }

    //
    //  Check cache for access token
    //

    Lock();

    for ( pEntry  = m_ExtensionHead.Flink;
          pEntry != &m_ExtensionHead;
          pEntry  = pEntry->Flink )
    {
        pExtension = CONTAINING_RECORD( pEntry, HSE_APPDLL, m_ListEntry );

        if ( pExtension->QueryLastSuccessfulUser() == hAccTok )
        {
            //
            //  Force an access check on the next request for this token
            //

            pExtension->SetLastSuccessfulUser( NULL );
        }
    }

    Unlock();

    return TRUE;
} // SE_TABLE::RefreshAcl()



BOOL
SE_TABLE::UnloadExtensions(VOID)
{
    PHSE  psExt;

    DBG_ASSERT( m_cRefWams == 0);

    Lock();

    while ( !IsListEmpty( &m_ExtensionHead )) {

        psExt = CONTAINING_RECORD( m_ExtensionHead.Flink,
                                  HSE_BASE,
                                  m_ListEntry );

        //
        // Move from the current list to the UnloadList
        //

        RemoveEntryList( &psExt->m_ListEntry );
        InitializeListHead( &psExt->m_ListEntry); // Cleanup

        IF_DEBUG( INIT_CLEAN) {
            DBGPRINTF(( DBG_CONTEXT,
                        "Deref of HSE_APPDLL(%08x) = %s. Ref=%d\n",
                        psExt, psExt->QueryModuleName(), psExt->RefCount()));
        }

        //
        // Cause an Unload of the ISAPI DLL
        // Ugly cast should be cleaned up post-beta2
        //

        DBG_REQUIRE( ((HSE_APPDLL * )psExt)->Unload() == NO_ERROR);

        // Decrement the life reference count of the ISAPI DLL structure
        if ( !psExt->Dereference()) {

            delete psExt;
        }
    } // while

    Unlock();

    // Drain the list of non-cached extensions scheduled for deletion
    m_sesdExtensions.WaitTillFinished();

    return (TRUE);
} // SE_TABLE::UnloadExtensions()


VOID
SE_TABLE::PrintRequestCounts(VOID)
/*++
  Description:
    Prints a summary of all the ISAPI Dlls loaded and the # requests
      pending in each of them primarily for debugging purposes.

  Arguments:
    None

  Return:
    None
--*/
{
    PHSE  psExt;
    PLIST_ENTRY pEntry;

    Lock();
    
    if( m_ExtensionHead.Flink != &m_ExtensionHead ) {
    	DBGPRINTF( (DBG_CONTEXT, "SE_TABLE::Printing refs for all loaded ISAPI\n") );

	    for ( pEntry  = m_ExtensionHead.Flink;
    	      pEntry != &m_ExtensionHead;
        	  pEntry  = pEntry->Flink )
	    {

    	    psExt = CONTAINING_RECORD( pEntry, HSE_BASE, m_ListEntry );

        	RemoveEntryList( &psExt->m_ListEntry );

	        DBGPRINTF( (DBG_CONTEXT,
	        		" \'%s\') has RefCount = %d\n",
    	            psExt->QueryModuleName(),
        	        psExt->RefCount()
            	    ) );
	    } // for
    	DBGPRINTF( (DBG_CONTEXT, "-------------------------------\n") );
	} // if    

    Unlock();

    return;
} // SE_TABLE::PrintRequestCounts()



VOID
SE_TABLE::ReleaseExtension( IN PHSE psExt)
{
    // decrement ref count and remove from table if needed
    if ( !psExt->Dereference()) {

        if ( psExt->IsCached()) 
        {
            RemoveFromList( psExt);
            delete psExt;
        }
        else {
        
            // non cached ISAPIs should be deleted (TerminateExtension
            // call should be called) from a different thread because
            // this thread could be an ISAPI thread (in case of pended
            // ISAPI this could be the DONE_WITH_SESSION thread)

            m_sesdExtensions.ScheduleExtensionForDeletion( psExt);
        }
    }

    return;
} // SE_TABLE::ReleaseExtension()



APIERR
InitializeHseExtensions(
    VOID
    )
/*++

Routine Description:

    Initializes the extension list cache


Return Value:

    0 on success, win32 error on failure

--*/
{
    DBGPRINTF(( DBG_CONTEXT, " InitExtensions() entered \n"));

	DWORD err = NO_ERROR;
	
    // UNDONE needs to move into wam.dll DllInit
    if ( err == NO_ERROR ) {

        // initialize other objects
        g_psextensions = new SE_TABLE();

        if ( (g_psextensions == NULL) ) {

            err = (ERROR_NOT_ENOUGH_MEMORY);
            if ( g_psextensions != NULL ) {
                delete (g_psextensions);
                g_psextensions = NULL;
            }

        } else {
            g_fExtInitialized = TRUE;
        }
    }

    DBGPRINTF(( DBG_CONTEXT, " Leaving  InitExtensions().\n" ));

    return ( err);

} // InitializeHseExtensions()



VOID
CleanupHseExtensions(
    VOID
    )
/*++

Routine Description:

    Walks list and unloads each extension.  No clients should be in an
    extension at this point

--*/
{
    DWORD        i;

    DBGPRINTF(( DBG_CONTEXT, " TerminateExtensions() called \n"
                ));


    if ( !g_fExtInitialized )
        return;

    DBG_ASSERT( g_psextensions != NULL);

    delete g_psextensions;

    return;
} // CleanupHseExtensions()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\wam.cpp ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       wam.cpp

   Abstract:
       This module implements the exported routines for WAM object

   Author:
       David Kaplan    ( DaveK )     26-Feb-1997

   Environment:
       User Mode - Win32

   Project:
       Wam DLL

--*/

//
// Following are the notes from the original MSDEV generated file
// Note: Proxy/Stub Information
//        To merge the proxy/stub code into the object DLL, add the file
//        dlldatax.c to the project.  Make sure precompiled headers
//        are turned off for this file, and add _MERGE_PROXYSTUB to the
//        defines for the project.
//
//        If you are not running WinNT4.0 or Win95 with DCOM, then you
//        need to remove the following define from dlldatax.c
//        #define _WIN32_WINNT 0x0400
//
//        Further, if you are running MIDL without /Oicf switch, you also
//        need to remove the following define from dlldatax.c.
//        #define USE_STUBLESS_PROXY
//
//        Modify the custom build rule for Wam.idl by adding the following
//        files to the Outputs.
//            Wam_p.c
//            dlldata.c
//        To build a separate proxy/stub DLL,
//        run nmake -f Wamps.mk in the project directory.

// BEGIN mods
// Post-wizard mods appear within BEGIN mods ... END mods
// END mods

#include <isapip.hxx>
#include "pudebug.h"

#include "resource.h"
#include "initguid.h"

#include "wamobj.hxx"
#include "Wam_i.c"

// BEGIN mods
#include <irtldbg.h>
#include "setable.hxx"
#include "wamccf.hxx"

#include <ooptoken.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
// END mods

/************************************************************
 *  Global Variables
 ************************************************************/

const CHAR g_pszModuleName[] = "WAM";
const CHAR g_pszWamRegLocation[] =
  "System\\CurrentControlSet\\Services\\W3Svc\\WAM";

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CWamModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Wam, WAM)
END_OBJECT_MAP()

// BEGIN mods
WAM_CCF_MODULE _WAMCCFModule;   // Custom Class Factory Module

DECLARE_PLATFORM_TYPE();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisWamObjectGuid, 
0x784d8909, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();
BOOL g_fGlobalInitDone = FALSE;
CRITICAL_SECTION g_csGlobalLock;

BOOL g_fEnableTryExcept = TRUE;


// WAM needs to ensure that IISRTL is fully initialized.  This happens
// automatically in infocomm when running in-process, but the following
// hack is needed for OOP apps.  InitializeIISRTL and TerminateIISRTL
// use an internal refcount, so tying the initialization/termination to
// _Module.GetLockCount works.

LONG CWamModule::Lock()
{
    IF_DEBUG( WAM_REFCOUNTS)
        DBGPRINTF((DBG_CONTEXT, "WamModule::Lock(%d)\n", GetLockCount()));
    InitializeIISRTL();
    AtqInitialize(0);
    return CComModule::Lock();
}

LONG CWamModule::Unlock()
{
    IF_DEBUG( WAM_REFCOUNTS)
        DBGPRINTF((DBG_CONTEXT, "WamModule::Unlock(%d)\n", GetLockCount()));
    AtqTerminate();
    TerminateIISRTL();
    return CComModule::Unlock();
}


/************************************************************
 * Local Functions
 ************************************************************/

static void
WAMLoadNTApis(VOID);

static void
WAMUnloadNTApis(VOID);

PFN_INTERLOCKED_COMPARE_EXCHANGE  g_pfnInterlockedCompareExchange = NULL;

// END mods

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    DWORD dwErr = NO_ERROR;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif

    if (dwReason == DLL_PROCESS_ATTACH) {

        //
        // BEGIN mods
        //
    
#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( g_pszModuleName);
#else
        CREATE_DEBUG_PRINT_OBJECT( g_pszModuleName, IisWamObjectGuid);
#endif
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            return ( FALSE);
        }

        (VOID)IISGetPlatformType();
#ifdef _NO_TRACING_
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWamRegLocation,
                                      (DEBUG_ERROR | DEBUG_IID) );
#endif

        INITIALIZE_PLATFORM_TYPE();
        DBG_ASSERT( IISIsValidPlatform());

        INITIALIZE_CRITICAL_SECTION( &g_csGlobalLock);
        WAMLoadNTApis();

        DBG_REQUIRE( WAM_EXEC_INFO::InitClass());

        dwErr = InitializeHseExtensions();

        if ( NOERROR == dwErr ) {

            IF_DEBUG( INIT_CLEAN) {
                DBGPRINTF((DBG_CONTEXT,
                           " InitializeHseExtensions succeeded.\n" ) );
            }

            // From ATL generated
            _Module.Init(ObjectMap, hInstance);
            DisableThreadLibraryCalls(hInstance);
            // End of ATL generated

            _WAMCCFModule.Init(); // must be after _Module.Init()
        }
        else {
            dwErr = GetLastError();
            IF_DEBUG( ERROR ) {
                DBGPRINTF((DBG_CONTEXT,
                           " InitializeHseExtensions failed. Error=%d.\n",
                           dwErr) );
            }
        }

        // END mods

    } else if (dwReason == DLL_PROCESS_DETACH) {

        DBGPRINTF( (DBG_CONTEXT, 
                   " Termination of WAM.dll called with lpvReserved=%08x\n",
                   lpReserved) );
        
        if ( NULL != lpReserved ) {
            
            //
            // Only cleanup if there is a FreeLibrary() call
            //
         
            return ( TRUE);
        }

        // BEGIN mods
        _WAMCCFModule.Term(); // must be before _Module.Term()
        // END mods

        _Module.Term();

        // BEGIN mods

        CleanupHseExtensions();

        WAM_EXEC_INFO::CleanupClass();

        DoGlobalCleanup();

        DeleteCriticalSection( &g_csGlobalLock);

        WAMUnloadNTApis();

        DELETE_DEBUG_PRINT_OBJECT();
        // END mods
    }

    return (dwErr == NO_ERROR);
} // DllMain()



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (ppv == NULL) {
       return ( NULL);
    }
    *ppv = NULL;    // reset the value before getting inside.

    IF_DEBUG( IID)
        {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetClassObject( " GUID_FORMAT "," GUID_FORMAT ", %08x)\n",
                    GUID_EXPAND( &rclsid),
                    GUID_EXPAND( &riid),
                    ppv));
        }

    if (ppv == NULL) {
        return ( E_POINTER);
    }
    *ppv = NULL;   // set the incoming value to be invalid entry

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif

    hr = _Module.GetClassObject(rclsid, riid, ppv);

    // BEGIN mods
    if (hr == CLASS_E_CLASSNOTAVAILABLE) {
        // If request for standard CF failed -> try custom
        IF_DEBUG( IID){
            DBGPRINTF(( DBG_CONTEXT, "Trying Custom CF GetClassObject()\n"));
        }

#ifdef USE_DEFAULT_CF
        hr = _Module.GetClassObject(CLSID_Wam, riid, ppv);
#else
        hr = _WAMCCFModule.GetClassObject(rclsid, riid, ppv);
#endif
    }

    IF_DEBUG( IID)
        {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetClassObject() returns %08x. (*ppv=%08x)\n",
                    hr, *ppv));
        }

    // END mods

    return ( hr);

} // DllGetClassObject()



/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}



/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;
}



/************************************************************
 *  Global Init/Cleanup functions
 ************************************************************/
HRESULT
DoGlobalInitializations(IN BOOL fInProc, IN BOOL fEnableTryExcept)
/*++
  Description:
    This function is used to initialize the global state of various
    variable in use. RPC runtime runs into deadlocks with respect to the
    NT DLL loader lock. Eventlog for one uses RPC to establish the connections.
    Hence, we use this separate global initialize function to setup state
    outside the NT DLL loader lock boundary (outside the DllMain())

  Arguments:
    fInProc - Is this WAM instance running InProc?
    fEnableTryExcept - Catch exceptions in ISAPIs?

  Returns:
    HRESULT - NOERROR means success; otherwise returns custom error.

--*/
{
    HRESULT hr = NOERROR;

    //
    // Use Locks to ensure that only one guy is initializing the data
    //
    EnterCriticalSection( &g_csGlobalLock);

    if ( !g_fGlobalInitDone) {

        // remember fEnableTryExcept flag
        g_fEnableTryExcept = fEnableTryExcept;

        if( !fInProc )
        {
            hr = CWamOopTokenInfo::Create();
            DBG_ASSERT( SUCCEEDED(hr) );

            if( WAM_EXEC_INFO::sm_pSVCacheMap == NULL )
            {
                WAM_EXEC_INFO::sm_pSVCacheMap = new SV_CACHE_MAP();
                DBG_ASSERT( WAM_EXEC_INFO::sm_pSVCacheMap != NULL );

                if( WAM_EXEC_INFO::sm_pSVCacheMap != NULL )
                {
                    DBG_REQUIRE( WAM_EXEC_INFO::sm_pSVCacheMap->Initialize() );
                }
            }
        }

#ifndef _NO_TRACING_
        CREATE_INITIALIZE_DEBUG();
#endif

        g_fGlobalInitDone = TRUE;
    }

    LeaveCriticalSection( &g_csGlobalLock);

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT,
                    " DoGlobalInitializations() returns hr = %08x\n",
                    hr));
    }

    return ( hr);
} // DoGlobalInitializations()


HRESULT DoGlobalCleanup(VOID)
{
    HRESULT hr = NOERROR;

    if ( !g_fGlobalInitDone) {
        return ( hr);
    }

    EnterCriticalSection( &g_csGlobalLock);

        if( CWamOopTokenInfo::HasInstance() )
        {
            CWamOopTokenInfo::Destroy();
        }

        delete WAM_EXEC_INFO::sm_pSVCacheMap;
        WAM_EXEC_INFO::sm_pSVCacheMap = NULL;

        g_fGlobalInitDone = FALSE;

    LeaveCriticalSection( &g_csGlobalLock);

    return ( hr);

} // DoGlobalCleanup()



/************************************************************
 *  Thunks for Fake NT APIs
 ************************************************************/

CRITICAL_SECTION g_csNonNTAPIs;

LONG
FakeInterlockedCompareExchange(
    LONG *Destination,
    LONG Exchange,
    LONG Comperand
   )
/*++
Description:
  This function fakes the interlocked compare exchange operation for non NT platforms
  See WAMLoadNTApis() for details

Returns:
   returns the old value at Destination
--*/
{
    LONG    oldValue;

    EnterCriticalSection( &g_csNonNTAPIs);

    oldValue = *Destination;

    if ( oldValue == Comperand ) {
        *Destination = Exchange;
    }

    LeaveCriticalSection( &g_csNonNTAPIs);

    return( oldValue);
} // FakeInterlockedCompareExchange()


static VOID
WAMLoadNTApis(VOID)
/*++
Description:
  This function loads the entry point for functions from
  Kernel32.dll. If the entry point is missing, the function
  pointer will point to a fake routine which does nothing. Otherwise,
  it will point to the real function.

  It dynamically loads the kernel32.dll to find the entry ponit and then
  unloads it after getting the address. For the resulting function
  pointer to work correctly one has to ensure that the kernel32.dll is
  linked with the dll/exe which links to this file.
--*/
{
    // Initialize the critical section for non NT API support, in case if we need this
    INITIALIZE_CRITICAL_SECTION( &g_csNonNTAPIs);

    if ( g_pfnInterlockedCompareExchange == NULL ) {

        HINSTANCE tmpInstance;

        //
        // load kernel32 and get NT specific entry points
        //

        tmpInstance = LoadLibrary("kernel32.dll");
        if ( tmpInstance != NULL ) {

            // For some reason the original function is _InterlockedCompareExchange!
            g_pfnInterlockedCompareExchange = (PFN_INTERLOCKED_COMPARE_EXCHANGE )
                GetProcAddress( tmpInstance, "InterlockedCompareExchange");

            if ( g_pfnInterlockedCompareExchange == NULL ) {
                // the function is not available
                //  Just thunk it.
                g_pfnInterlockedCompareExchange = FakeInterlockedCompareExchange;
            }

            //
            // We can free this because we are statically linked to it
            //

            FreeLibrary(tmpInstance);
        }
    }

    return;
} // WAMLoadNTApis()

static void
WAMUnloadNTApis(VOID)
{
    DeleteCriticalSection( &g_csNonNTAPIs);

    return;
} // WAMUnloadNTApis()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\proxy\iwr_i_stub.c ===
#include "iwr_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\proxy\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\proxy\iwr_p_stub.c ===
#include "iwr_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\proxy\wam_i_stub.c ===
#include "wam_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\wamxbase.cxx ===
/*=====================================================================*

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
      wamxbase.cxx

   Abstract:
      Declaration of WAM_EXEC_BASE Object

   Author:

       David L. Kaplan    ( DaveK )    26-June-1997

   Environment:
       User Mode - Win32

   Project:

       WAM and ASP DLLs

   Revision History:

======================================================================*/


# include "isapip.hxx"
# include "wamxbase.hxx"
# include "gip.h"
// MIDL-generated
# include "iwr.h"



/*---------------------------------------------------------------------*
WAM_EXEC_BASE::WAM_EXEC_BASE

    Constructor

*/
WAM_EXEC_BASE::WAM_EXEC_BASE(
)
:
    m_dwThreadIdIIS     ( 0 )       // threadid 0 can't happen in IIS
    , m_dwThreadIdISA   ( 0 )       // threadid 0 can't happen in IIS
    , m_pIWamReqIIS     ( NULL )
    , m_pIWamReqInproc  ( NULL )
    , m_pIWamReqSmartISA( NULL )
    , m_gipIWamRequest  ( 0 )
    , _dwIsaKeepConn	( KEEPCONN_OLD_ISAPI ) 	// per fix to #117107 
{

    IF_DEBUG( WAM_IWAMREQ_REFS ) {

        //
        //  NOTE when WAM_IWAMREQ_REFS flag is set, we use
        //  m_dwSignature as a ref count for gip get/release
        //  (rather than add another debug-only member)
        //

        m_dwSignature = 0;
    }

}



/*---------------------------------------------------------------------*
WAM_EXEC_BASE::InitWamExecBase

    Inits this structure by setting interface ptr members
    based on whether we are in-proc or oop.

*/
HRESULT
WAM_EXEC_BASE::InitWamExecBase(
    IWamRequest *   pIWamRequest
)
{

    HRESULT hr = NOERROR;


    //
    //  cache pointer passed to us by IIS
    //  and thread id on which IIS called us
    //
    //  NOTE we don't addref the ptr because we may not
    //  actually use it.  If we decide to use the ptr
    //  (e.g. in-proc, or oop-smart-ISA on IIS thread),
    //  we will addref then.
    //

    m_pIWamReqIIS = pIWamRequest;
    m_dwThreadIdIIS = GetCurrentThreadId();


    if ( m_fInProcess ) {

        //
        //  In-Proc
        //
        //  Cache and addref wamreq, since we will use its ptr
        //

        m_pIWamReqInproc = pIWamRequest;
        m_pIWamReqInproc->AddRef();

        //  Remember wamreq in m_pIWamReqSmartISA as well to make
        //  wamreq available in all cases for smart (caching)
        //  ISAPIs like ASP simply by referring to m_pIWamReqSmartISA

        m_pIWamReqSmartISA = m_pIWamReqInproc;

    } else {

        //
        //  Out-Proc
        //
        //  Register wamreq with gip-master
        //
        //  NOTE gip.Register addref's implicitly
        //

        hr = RegisterIWamRequest( pIWamRequest );

    }


    return hr;

}   // WAM_EXEC_BASE::InitWamExecBase



/*---------------------------------------------------------------------*
WAM_EXEC_BASE::CleanupWamExecBase

    Cleans up this structure by setting interface ptr members
    based on whether we are in-proc or oop.

*/
VOID
WAM_EXEC_BASE::CleanupWamExecBase(
)
{

    if ( m_fInProcess ) {

        //
        //  In-proc
        //
        //  Release the member wamreq ptr we cached at init
        //

        DBG_ASSERT( AssertInpValid() );

        m_pIWamReqInproc->Release();

        m_pIWamReqInproc = NULL;
        m_pIWamReqSmartISA = NULL;
        

    } else {

        //
        //  Out-proc
        //
        //  Revoke the gip cookie
        //

        DBG_ASSERT( AssertOopValid() );

        RevokeIWamRequest();

    }

    return;

}   // WAM_EXEC_BASE::CleanupWamExecBase



/*---------------------------------------------------------------------*
WAM_EXEC_BASE::RegisterIWamRequest
    For oop use only.
    Registers our W3-thread IWamRequest ptr with gip-master.

    Arguments:
        None

    Returns:
        HRESULT
*/
HRESULT
WAM_EXEC_BASE::RegisterIWamRequest(
    IWamRequest *   pIWamRequest
)
{

    HRESULT hr = NOERROR;


    DBG_ASSERT ( !m_fInProcess );
    DBG_ASSERT( pIWamRequest );


    //
    //  Register iwamreq ptr with gip-master
    //

    if ( FAILED( hr = g_GIPAPI.Register(
                        pIWamRequest
                        , IID_IWamRequest
                        , &m_gipIWamRequest 
                      ))) {

        DBGPRINTF((
            DBG_CONTEXT
            , "g_GIPAPI.Register failed "
              "hr(%08x) "
              "m_gipIWamRequest(%08x) "
              "\n"
            , hr
            , m_gipIWamRequest
        ));

    } else {

        DBG_ASSERT( AssertOopValid() );

    }


    return hr;

}


    
/*---------------------------------------------------------------------*
WAM_EXEC_BASE::RevokeIWamRequest
    If oop, revokes our gip-cookie.

    Arguments:
        None

    Returns:
        Nothing

*/
VOID
WAM_EXEC_BASE::RevokeIWamRequest(
)
{

    DBG_ASSERT( AssertOopValid() );

    //
    //  Revoke the gip-cookie we got from gip-master at init
    //

    g_GIPAPI.Revoke( m_gipIWamRequest );


    return;
    
}



/*---------------------------------------------------------------------*
WAM_EXEC_BASE::GetInterfaceForThread
    Caches a current-thread-valid IWamRequest ptr in m_pIWamReqSmartISA

    Arguments:
        None

    Returns:
        HRESULT
*/
HRESULT
WAM_EXEC_BASE::GetInterfaceForThread(
)
{

    HRESULT hr = NOERROR;

    DBG_ASSERT( m_pIWamReqSmartISA == NULL );
    DBG_ASSERT( m_dwThreadIdISA == 0 );
    DBG_ASSERT( AssertOopValid() );


    m_dwThreadIdISA = GetCurrentThreadId();


    IF_DEBUG( WAM_THREADID ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_BASE(%08x)::GetInterfaceForThread "
              "m_dwThreadIdIIS(%d) "
              "m_dwThreadIdISA(%d) "
              "\n"
            , this
            , m_dwThreadIdIIS
            , m_dwThreadIdISA
        ));

    }


    if ( m_dwThreadIdISA == m_dwThreadIdIIS ) {

        //
        //  ISA called us on mainline (IIS) thread
        //  so we can simply use cached ptr passed in by IIS.
        //

        m_pIWamReqSmartISA = m_pIWamReqIIS;


        //
        //  addref the ptr since we are using it.
        //

        m_pIWamReqSmartISA->AddRef();

    } else {

        //
        //  ISA called us on its own thread
        //  so we must get a ptr from gip.
        //

        hr = GetInterfaceFromGip( &m_pIWamReqSmartISA );

        IF_DEBUG( WAM_THREADID ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "GetInterfaceFromGip returned %d"
                  "\n"
                , hr
            ));

            DBGPRINTF((
                DBG_CONTEXT
                , "m_dwThreadIdISA(%d)"
                  "\n"
                , m_dwThreadIdISA
            ));

        }

    }


    return hr;

}   // WAM_EXEC_BASE::GetInterfaceForThread



/*---------------------------------------------------------------------*
WAM_EXEC_BASE::ReleaseInterfaceForThread
    Releases the IWamRequest ptr cached in m_pIWamReqSmartISA

    Arguments:
        None

    Returns:
        HRESULT
*/
HRESULT
WAM_EXEC_BASE::ReleaseInterfaceForThread(
)
{

    DBG_ASSERT( AssertOopValid() );

    if ( m_pIWamReqSmartISA == NULL ) {

        //
        //  In some races, ISA-thread ptr was already released.
        //  This is harmless, so we no-op.
        //

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_BASE(%08x)::ReleaseInterfaceForThread\n"
              "\t Cached ISA-thread ptr already released\n"
              "\t m_dwThreadIdISA(%d)\n"
              "\t Current thread id(%d)\n"
              "\t m_pIWamReqSmartISA(%d)\n"
            , this
            , m_dwThreadIdISA
            , GetCurrentThreadId()
            , m_pIWamReqSmartISA
        ));

        return NOERROR;

    }


    DBG_ASSERT( AssertSmartISAValid() );

    if ( m_dwThreadIdISA != GetCurrentThreadId() ) {

        //
        //  If thread id's don't match, we can't release
        //

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_BASE(%08x)::ReleaseInterfaceForThread\n"
              "\t Wrong thread error\n"
              "\t m_dwThreadIdISA(%d)\n"
              "\t Current thread id(%d)\n"
              "\t m_pIWamReqSmartISA(%d)\n"
            , this
            , m_dwThreadIdISA
            , GetCurrentThreadId()
            , m_pIWamReqSmartISA
        ));


        //
        //  Aha! If COM can return this, so can we ...
        //

        return RPC_E_WRONG_THREAD;

    }


    m_pIWamReqSmartISA->Release();
    m_pIWamReqSmartISA = NULL;
    m_dwThreadIdISA = 0;

    return NOERROR;

}



/*---------------------------------------------------------------------*
WAM_EXEC_BASE::GetIWamRequest
    Returns a thread-valid IWamRequest ptr.

    Arguments:
        ppIWamRequest   - returned ptr

    Returns:
        HRESULT
*/
HRESULT
WAM_EXEC_BASE::GetIWamRequest(
    IWamRequest **  ppIWamRequest
)
{

    HRESULT hrRet = NOERROR;


    IF_DEBUG( WAM_IWAMREQ_REFS ) {

        //
        //  NOTE when WAM_IWAMREQ_REFS flag is set, we use
        //  m_dwSignature as a ref count for gip get/release
        //  (rather than add another debug-only member)
        //

        m_dwSignature++;

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_BASE(%08x)::GetIWamRequest"
              " %d -> %d"
              "\n"
            , this
            , m_dwSignature - 1
            , m_dwSignature
        ));
    }


    if ( m_fInProcess ) {

        //
        //  In-Proc: simply return our cached W3-thread ptr
        //

        DBG_ASSERT( AssertInpValid() );

        *ppIWamRequest = m_pIWamReqInproc;

        IF_DEBUG( WAM_REFCOUNTS ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "WAM_EXEC_BASE(%08x)::GetIWamRequest"
                  "\tIn-proc m_pIWamReqInproc(%08x)"
                  "\n"
                , this
                , m_pIWamReqInproc
            ));
        
        }

    } else {

        //
        //  Out-of-Proc:
        //      If we are dealing with a 'smart ISA', use ISA-thread ptr
        //
        //      Else if we are on 'IIS thread', use 'IIS ptr'
        //
        //      Else, get a ptr from gip-master
        //  
        //

        DBG_ASSERT( AssertOopValid() );


        if ( m_pIWamReqSmartISA ) {

            //
            //  FAST
            //
            //  'Smart ISA' ==> use ISA-thread ptr
            //

            DBG_ASSERT( AssertSmartISAValid() );

            *ppIWamRequest = m_pIWamReqSmartISA;

            IF_DEBUG( WAM_REFCOUNTS ) {

                DBGPRINTF((
                    DBG_CONTEXT
                    , "WAM_EXEC_BASE(%08x)::GetIWamRequest"
                      "\tOut-of-proc optimized  - smart ISA: "
                      "m_pIWamReqSmartISA(%08x)"
                      "\n"
                    , this
                    , m_pIWamReqSmartISA
                ));
            }

        } else if ( GetCurrentThreadId() == m_dwThreadIdIIS ) {

            //
            //  FAST
            //
            //  We are on 'IIS thread' ==> use 'IIS ptr'
            //  NOTE we addref it as a precaution
            //

            *ppIWamRequest = m_pIWamReqIIS;
            m_pIWamReqIIS->AddRef();

            IF_DEBUG( WAM_REFCOUNTS ) {

                DBGPRINTF((
                    DBG_CONTEXT
                    , "WAM_EXEC_BASE(%08x)::GetIWamRequest"
                      "\tOut-of-proc optimized - IIS thread: "
                      "m_pIWamReqIIS(%08x)"
                      "\n"
                    , this
                    , m_pIWamReqIIS
                ));
            }

        } else {

            //
            //  SLOW :-(
            //
            //  ISA is not smart and we are not on IIS thread
            //      ==> must get a ptr from gip
            //

            hrRet = GetInterfaceFromGip( ppIWamRequest );

            IF_DEBUG( WAM_REFCOUNTS ) {

                DBGPRINTF((
                    DBG_CONTEXT
                    , "WAM_EXEC_BASE(%08x)::GetIWamRequest"
                      "\tOut-of-proc NOT optimized: *ppIWamRequest(%08x)"
                      "\n"
                    , this
                    , *ppIWamRequest
                ));
            }

        }

    } // ( m_fInProcess )


    return hrRet;

}   // WAM_EXEC_BASE::GetIWamRequest



/*---------------------------------------------------------------------*
WAM_EXEC_BASE::ReleaseIWamRequest
    Releases an IWamRequest ptr, covering whether in-proc or out-proc.

    Arguments:
        pIWamRequest    - ptr to release

    Returns:
        Nothing

*/
VOID
WAM_EXEC_BASE::ReleaseIWamRequest(
    IWamRequest *   pIWamRequest
)
{

    IF_DEBUG( WAM_IWAMREQ_REFS ) {

        //
        //  NOTE when WAM_IWAMREQ_REFS flag is set, we use
        //  m_dwSignature as a ref count for gip get/release
        //  (rather than add another debug-only member)
        //

        m_dwSignature--;

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_BASE(%08x)::ReleaseIWamRequest"
              " %d -> %d"
              "\n"
            , this
            , m_dwSignature + 1
            , m_dwSignature
        ));
    }


    if ( m_fInProcess ) {

        DBG_ASSERT( AssertInpValid() );
        
        //
        //  In-Proc: no-op
        //

        return;
    }


    if ( m_pIWamReqSmartISA && (pIWamRequest == m_pIWamReqSmartISA) ) {
    
        DBG_ASSERT( AssertSmartISAValid() );

        //
        //  'Smart ISA': no-op
        //

        return;
    }


    //
    //  Out-Proc: release ptr
    //
    //  NOTE the ptr is either our cached 'IIS ptr' (if we are on
    //  mainline thread) or the one we got from gip-master
    //  (if we are on another thread).
    //
    //  Either way, we simply release it.
    //

    DBG_ASSERT( AssertOopValid() );

    IF_DEBUG( WAM_REFCOUNTS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_BASE(%08x)::ReleaseIWamRequest  ptr %08x\n"
            , this
            , pIWamRequest
        ));
    }

    pIWamRequest->Release();
    return;

}   // WAM_EXEC_BASE::ReleaseIWamRequest



/*---------------------------------------------------------------------*
WAM_EXEC_BASE::GetInterfaceFromGip


*/
HRESULT
WAM_EXEC_BASE::GetInterfaceFromGip(
    IWamRequest **  ppIWamRequest
)
{

    HRESULT hrRet = NOERROR;


    if ( m_gipIWamRequest == 0 ) {

        //
        //  In low-memory, etc cases we may not have a gip cookie
        //  (see bug 86872)
        //
        //  We quote verbatim from raid:
        //
        /*  
            this was the bug:
            - the call from WAM::ProcessRequest to InitWamExecInfo fails due to oom when 
            calling GetCoreState (probably due to the allocation in the COM marshaler)
            - thus, _gipIWamRequest remains 0
            - we jump to failure code in WAM::ProcessRequest and call WAM_EXEC_INFO::
            PrepCleanupAndRelease
            - PrepCleanupAndRelease assert-failed because _gipIWamRequest == 0
            - after the asertion fialure we crash trying to call PrepCleanupWamRequest on 
            a null ptr

            this is the fix:
            - in WAM_EXEC_INFO::PrepCleanupAndRelease we no longer assert, and now 
            proactively avoid the cross-process call if _gipIWamRequest == 0

            additional robust-ification, related to the fix:
            - added fail-fast code to GetIWamRequest for the case _gipIWamRequest == 0 (
            replaces the assert stanley saw, above)
            - many more DBGPRINTFs in InitWamExecInfo and elsewhere
        */

        hrRet = E_FAIL;

    } else {

        DBG_ASSERT( AssertOopValid() );

        IF_DEBUG( WAM_THREADID ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "WAM_EXEC_BASE(%08x)::GetInterfaceFromGip before gip.Get"
                  "m_dwThreadIdISA(%d)"
                  "\n"
                , this
                , m_dwThreadIdISA
            ));

        }


        //
        //  Get a thread-valid ptr from gip-master
        //

        hrRet = g_GIPAPI.Get(
                    m_gipIWamRequest
                    , IID_IWamRequest
                    , (void **) ppIWamRequest
                );


        IF_DEBUG( WAM_THREADID ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "WAM_EXEC_BASE(%08x)::GetInterfaceFromGip after gip.Get "
                  "m_dwThreadIdISA(%d)"
                  "\n"
                , this
                , m_dwThreadIdISA
            ));

            if ( m_dwThreadIdISA == 0 ) { 

                m_dwThreadIdISA = GetCurrentThreadId();

                DBGPRINTF((
                    DBG_CONTEXT
                    , "WAM_EXEC_BASE(%08x)::GetInterfaceFromGip "
                      "after hokey debug refresh "
                      "m_dwThreadIdISA(%d)"
                      "\n"
                    , this
                    , m_dwThreadIdISA
                ));

            }

        }



        IF_DEBUG( WAM_THREADID ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "WAM_EXEC_BASE(%08x)::GetInterfaceFromGip after CoUninitialize "
                  "m_dwThreadIdISA(%d)"
                  "\n"
                , this
                , m_dwThreadIdISA
            ));
        }


        IF_DEBUG( WAM_REFCOUNTS ) {
            if ( hrRet == NOERROR ) {

                DBGPRINTF((
                    DBG_CONTEXT
                    , "WAM_EXEC_BASE(%08x)::GetIWamRequest"
                      "gets ptr %08x"
                      "\n"
                    , this
                    , *ppIWamRequest
                ));

            } else {

                DBGPRINTF((
                    DBG_CONTEXT
                    , "WAM_EXEC_BASE(%08x)::GetIWamRequest failed "
                      "hrRet(%08x) "
                      "\n"
                    , this
                    , hrRet
                ));

            }
        }

    }

    return hrRet;

}



BOOL
WAM_EXEC_BASE::AssertSmartISAValid()
{

    IF_DEBUG( WAM_THREADID ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_BASE(%08x)::AssertSmartISAValid"
              "\n\t"
              "m_fInProcess(%d) "
              "m_pIWamReqInproc(%d) "
              "m_gipIWamRequest(%d) "
              "m_pIWamReqSmartISA(%d) "
              "\n\t"
              "m_dwThreadIdISA(%d) "
              "Current thread id(%d) "
              "\n"
            , this
            , m_fInProcess
            , m_pIWamReqInproc
            , m_gipIWamRequest
            , m_pIWamReqSmartISA
            , m_dwThreadIdISA
            , GetCurrentThreadId()
        ));

    }

    return(
               AssertOopValid()
            && m_pIWamReqSmartISA
            && m_dwThreadIdISA
    );
}



/************************ End of File *********************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\proxy\wam_p_stub.c ===
#include "wam_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\wamxcf.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       wamxcf.cxx

   Abstract:
       WAM Exception Filter and stack walking code from MTS

   Author:

       Andrei Kozlov    ( AKozlov )     23-Sep-98

   Environment:

       User Mode - Win32

   Project:

       WAM DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <isapip.hxx>
#include <imagehlp.h>
# include "wamxinfo.hxx"
# include "WReqCore.hxx"
# include "setable.hxx"
# include "gip.h"
# include "WamW3.hxx"

// MIDL-generated
# include "iwr.h"


// ===================================================================
// Stack trace classes by Don McCrady of MTS

class Symbol {
	friend class StackWalker;

private:
	Symbol(const char* moduleName, const char* symbolName, UINT_PTR displacement);
	void Append(Symbol*);
	

public:
	~Symbol();

	const char* moduleName() const { return _moduleName; }
	const char* symbolName() const { return _symbolName; }
	UINT_PTR displacement() const { return _displacement; }
	void AppendDisplacement(char * sz)
	{
		char szDisp[16];
		wsprintfA(szDisp, " + 0x%X", _displacement);
		lstrcatA(sz, szDisp);
	}

	Symbol* next() const { return _next; }

private:
	char*	    _moduleName;
	char*	    _symbolName;
	UINT_PTR	_displacement;

	Symbol*	    _next;
};


class StackWalker {
public:
	StackWalker(HANDLE hProcess);
	~StackWalker();

	Symbol* ResolveAddress(UINT_PTR addr);
	Symbol* CreateStackTrace(CONTEXT*);
	BOOL GetCallStack(Symbol * symbol, int nChars, char * sz);
	int GetCallStackSize(Symbol* symbol);

private:
	static UINT_PTR __stdcall GetModuleBase(HANDLE hProcess, UINT_PTR address);
	static UINT_PTR LoadModule(HANDLE hProcess, UINT_PTR address);

private:
	typedef BOOL (__stdcall *SymGetModuleInfoFunc)(HANDLE hProcess,
												   UINT_PTR dwAddr,
												   PIMAGEHLP_MODULE ModuleInfo);
	typedef BOOL (__stdcall *SymGetSymFromAddrFunc)(HANDLE hProcess,
													UINT_PTR dwAddr,
													UINT_PTR * pdwDisplacement,
													PIMAGEHLP_SYMBOL Symbol);
	typedef UINT_PTR (__stdcall *SymLoadModuleFunc)(HANDLE hProcess,
												 HANDLE hFile,
												 PSTR ImageName,
												 PSTR ModuleName,
												 UINT_PTR BaseOfDll,
												 UINT_PTR SizeOfDll);
	typedef BOOL (__stdcall *StackWalkFunc)(DWORD MachineType,
											HANDLE hProcess,
											HANDLE hThread,
											LPSTACKFRAME StackFrame,
											LPVOID ContextRecord,
											PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
											PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
											PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
											PTRANSLATE_ADDRESS_ROUTINE TranslateAddress);
	typedef BOOL (__stdcall *UndecorateSymbolNameFunc)(LPSTR DecName,
												 LPSTR UnDecName,
												 DWORD UnDecNameLength,
												 DWORD Flags);

private:
	HMODULE							_imageHlpDLL;
	HANDLE							_hProcess;
	EXCEPTION_POINTERS				m_exceptionpts;

	static SymGetModuleInfoFunc				_SymGetModuleInfo;
	static SymGetSymFromAddrFunc			_SymGetSymFromAddr;
	static SymLoadModuleFunc				_SymLoadModule;
	static StackWalkFunc					_StackWalk;
	static UndecorateSymbolNameFunc			_UndecorateSymbolName;
	static PFUNCTION_TABLE_ACCESS_ROUTINE	_SymFunctionTableAccess;
};



// ======================================================================
// Exception handling and stack traces
// ======================================================================

char * mystrdup(const char * sz)
{
	int nLen = lstrlenA(sz) + 1;
	char * tmp = (char *)malloc(nLen);

	if (tmp)
    {
        lstrcpyA(tmp, sz);
    }

    return tmp;
}


StackWalker::SymGetModuleInfoFunc		StackWalker::_SymGetModuleInfo;
StackWalker::SymGetSymFromAddrFunc		StackWalker::_SymGetSymFromAddr;
StackWalker::SymLoadModuleFunc			StackWalker::_SymLoadModule;
StackWalker::StackWalkFunc				StackWalker::_StackWalk;
StackWalker::UndecorateSymbolNameFunc	StackWalker::_UndecorateSymbolName;
PFUNCTION_TABLE_ACCESS_ROUTINE				StackWalker::_SymFunctionTableAccess;

StackWalker::StackWalker(HANDLE hProcess)
	: _imageHlpDLL(NULL),
	  _hProcess(hProcess)
{
	_imageHlpDLL = LoadLibrary("imagehlp.dll");
	if (_imageHlpDLL != NULL) {
		// Get commonly used Sym* functions.
		if (_StackWalk == NULL) {
			// If one of them are null, assume
			// they all are.  Benign race here.

			_StackWalk = (StackWalkFunc)GetProcAddress(_imageHlpDLL, "StackWalk");
			if (_StackWalk == NULL)
				return;
			_SymGetModuleInfo = (SymGetModuleInfoFunc)GetProcAddress(_imageHlpDLL,
																	 "SymGetModuleInfo");
			if (_SymGetModuleInfo == NULL)
				return;
			_SymGetSymFromAddr = (SymGetSymFromAddrFunc)GetProcAddress(_imageHlpDLL,
																	   "SymGetSymFromAddr");
			if (_SymGetSymFromAddr == NULL)
				return;
			_SymLoadModule = (SymLoadModuleFunc)GetProcAddress(_imageHlpDLL,
															   "SymLoadModule");
			if (_SymLoadModule == NULL)
				return;
			_UndecorateSymbolName = (UndecorateSymbolNameFunc)GetProcAddress(_imageHlpDLL,
																			 "UnDecorateSymbolName");
			if (_UndecorateSymbolName == NULL)
				return;
			_SymFunctionTableAccess = (PFUNCTION_TABLE_ACCESS_ROUTINE)GetProcAddress(_imageHlpDLL,
																						 "SymFunctionTableAccess");
			if (_SymFunctionTableAccess == NULL)
				return;
		}

		// Sym* functions that we're only going to use locally.
		typedef BOOL (__stdcall *SymInitializeFunc)(HANDLE hProcess,
													LPSTR path,
													BOOL invadeProcess);
		typedef DWORD (__stdcall *SymSetOptionsFunc)(DWORD);

		SymInitializeFunc SymInitialize = (SymInitializeFunc)GetProcAddress(_imageHlpDLL,
																			"SymInitialize");
		if (SymInitialize == NULL)
			return;
		SymSetOptionsFunc SymSetOptions = (SymSetOptionsFunc)GetProcAddress(_imageHlpDLL,
																			"SymSetOptions");
		if (SymSetOptions == NULL)
			return;

		if (SymInitialize(hProcess, NULL, FALSE))
			SymSetOptions(0);
	}
}


StackWalker::~StackWalker() {
	if (_imageHlpDLL != NULL) {
		typedef BOOL (__stdcall *SymCleanupFunc)(HANDLE hProcess);

		SymCleanupFunc SymCleanup = (SymCleanupFunc)GetProcAddress(_imageHlpDLL,
																   "SymCleanup");
		if (SymCleanup != NULL)
			SymCleanup(_hProcess);

		FreeLibrary(_imageHlpDLL);
	}
}

UINT_PTR StackWalker::LoadModule(HANDLE hProcess, UINT_PTR address) {
    MEMORY_BASIC_INFORMATION mbi;

    if (VirtualQueryEx(hProcess, (void*)address, &mbi, sizeof mbi)) {
        if (mbi.Type & MEM_IMAGE) {
            char module[MAX_PATH];
            DWORD cch = GetModuleFileNameA((HINSTANCE)mbi.AllocationBase,
                                           module,
                                           MAX_PATH);

            // Ignore the return code since we can't do anything with it.
            (void)_SymLoadModule(hProcess,
                                 NULL,
                                 ((cch) ? module : NULL),
                                 NULL,
                                 (ULONG_PTR)mbi.AllocationBase,
                                 0);
            return (UINT_PTR)mbi.AllocationBase;
        }
    }

    return 0;
}

Symbol* StackWalker::ResolveAddress(UINT_PTR addr) {
	if (_imageHlpDLL == NULL)
		return NULL;

	// Find out what module the address lies in.
	char* module = NULL;
	IMAGEHLP_MODULE moduleInfo;
	moduleInfo.SizeOfStruct = sizeof moduleInfo;

	if (_SymGetModuleInfo(_hProcess, addr, &moduleInfo)) {
		module = moduleInfo.ModuleName;
	}
	else {
		// First attempt failed, load the module info.
		LoadModule(_hProcess, addr);
		if (_SymGetModuleInfo(_hProcess, addr, &moduleInfo))
			module = moduleInfo.ModuleName;
	}

	char* symbolName = NULL;
    char undecoratedName[512];
	IMAGEHLP_SYMBOL* symbolInfo = (IMAGEHLP_SYMBOL*)_alloca(sizeof(IMAGEHLP_SYMBOL) + 512);
	symbolInfo->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL) + 512;
	symbolInfo->MaxNameLength = 512;
	UINT_PTR displacement = 0;
	if (_SymGetSymFromAddr(_hProcess, addr, &displacement, symbolInfo)) {
		DWORD flags = UNDNAME_NO_MS_KEYWORDS
			| UNDNAME_NO_ACCESS_SPECIFIERS
			| UNDNAME_NO_FUNCTION_RETURNS
			| UNDNAME_NO_MEMBER_TYPE;
		if (_UndecorateSymbolName(symbolInfo->Name, undecoratedName, 512, flags))
			symbolName = undecoratedName;
		else
			symbolName = symbolInfo->Name;
	}
	else {
		displacement = addr - moduleInfo.BaseOfImage;
	}

	return new Symbol(module, symbolName, displacement);
}



UINT_PTR __stdcall StackWalker::GetModuleBase(HANDLE hProcess, UINT_PTR address) {
    IMAGEHLP_MODULE moduleInfo;
	moduleInfo.SizeOfStruct = sizeof moduleInfo;
	
    if (_SymGetModuleInfo(hProcess, address, &moduleInfo))
        return moduleInfo.BaseOfImage;
    else
		return LoadModule(hProcess, address);

}

Symbol* StackWalker::CreateStackTrace(CONTEXT* context) {
	if (_imageHlpDLL == NULL)
		return NULL;

	HANDLE hThread = GetCurrentThread();

	DWORD dwMachineType;
	STACKFRAME frame = {0};
	frame.AddrPC.Mode = AddrModeFlat;
#if defined(_M_IX86)
	dwMachineType          = IMAGE_FILE_MACHINE_I386;
	frame.AddrPC.Offset    = context->Eip;  // Program Counter
	
	frame.AddrStack.Offset = context->Esp;  // Stack Pointer
	frame.AddrStack.Mode   = AddrModeFlat;
	frame.AddrFrame.Offset = context->Ebp;  // Frame Pointer
#elif defined(_M_AMD64)
	dwMachineType          = IMAGE_FILE_MACHINE_AMD64;
	frame.AddrPC.Offset    = context->Rip;  // Program Counter
#elif defined(_M_IA64)	
    dwMachineType          = IMAGE_FILE_MACHINE_IA64;
    frame.AddrPC.Offset    = CONTEXT_TO_PROGRAM_COUNTER(context);

#elif
#error("Unknown Target Machine");
#endif
	
	// Walk the stack...
	Symbol* prev = NULL;
	Symbol* head = NULL;
	for (;;) {
		if (!_StackWalk(dwMachineType,
						_hProcess,
						hThread,
						&frame,
						&context,
						NULL,
						(PFUNCTION_TABLE_ACCESS_ROUTINE)_SymFunctionTableAccess,
						(PGET_MODULE_BASE_ROUTINE)GetModuleBase,
						NULL))
			break;
		if (frame.AddrPC.Offset == 0)
			break;

		Symbol* sym = ResolveAddress(frame.AddrPC.Offset);
		if (sym == NULL)
			break;

		// Append this symbol to the previous one, if any.
		if (prev == NULL) {
			prev = sym;
			head = sym;
		}
		else {
			prev->Append(sym);
			prev = sym;
		}
	}

	return head;
}

int StackWalker::GetCallStackSize(Symbol* symbol)
{
	int nSize = 2; // Start with a "\r\n".
	const char* module = NULL;
	const char* symbolName = NULL;	
	Symbol * sym = symbol;
	while (sym != NULL)
	{
		module = sym->moduleName();
		symbolName = sym->symbolName();	
		nSize += lstrlenA(module);
 		nSize += lstrlenA(symbolName);
		nSize += 32; // displacement, spaces, etc.
		sym = sym -> next();
	}

	return nSize;
}
BOOL StackWalker::GetCallStack(Symbol * symbol, int nChars, char * sz)
{
	if (!symbol || !nChars)
		return FALSE;

	Symbol* sym = symbol;
	
	const char* module = NULL;
	const char* symbolName = NULL;	
	ZeroMemory(sz, nChars);
	lstrcpy(sz, "\r\n"); // Start with a CR-LF.
	Symbol* tmp  = NULL;
	while (sym != NULL)
	{	
		module = sym->moduleName();
		symbolName = sym->symbolName();			
		if (module != NULL)
		{
			strcat(sz, module);
			if (symbolName != NULL)
				strcat(sz, "!");
		}

		if (symbolName != NULL)
			strcat(sz, symbolName);

		sym->AppendDisplacement(sz);

		lstrcat(sz, "\r\n");
		tmp = sym;
		sym = sym->next();
		delete tmp;
	}

	return TRUE;
}



Symbol::Symbol(const char* moduleName, const char* symbolName, UINT_PTR displacement)
	: _moduleName(NULL),
	  _symbolName(NULL),
	  _displacement(displacement),
	  _next(NULL)
{
	if (moduleName != NULL)
		_moduleName = mystrdup(moduleName);
	if (symbolName != NULL)
		_symbolName = mystrdup(symbolName);
}

Symbol::~Symbol() {
	free(_moduleName);
	free(_symbolName);
}

void Symbol::Append(Symbol* sym) {
	_next = sym;
}



//
// WAM Exception Filter -- walk the stack and log event
//
DWORD WAMExceptionFilter(
    EXCEPTION_POINTERS *xp,
    DWORD dwEventId,
    WAM_EXEC_INFO *pWamExecInfo
)
{

	CHAR * pszStack = NULL;

	//
	// Don't handle breakpoints
	//
	if (xp->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT)
		return EXCEPTION_CONTINUE_SEARCH;

	
	StackWalker walker( GetCurrentProcess() );
	Symbol* symbol = walker.CreateStackTrace( xp->ContextRecord );
	if( symbol ) {
		if (symbol != NULL) {
			int stackBufLen = walker.GetCallStackSize(symbol);
			pszStack = (TCHAR*)_alloca(stackBufLen * sizeof pszStack[0]);
			walker.GetCallStack(symbol, stackBufLen, pszStack);
		}
	}

    pWamExecInfo->LogEvent( dwEventId, (unsigned char *) pszStack );

	return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\wamobj.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       wamobj.cxx

   Abstract:
       This module implements the WAM (web application manager) object

   Author:
       David Kaplan    ( DaveK )     26-Feb-1997

   Environment:
       User Mode - Win32

   Project:
       Wam DLL

--*/

/************************************************************
 *     Include Headers
 ************************************************************/
#include <isapip.hxx>
#include "setable.hxx"

# include "isapi.hxx"
# include "WamW3.hxx"

#include "wamobj.hxx"
#include "iwr.h"
#include "iwr_i.c"
# include "timer.h"

#include <irtlmisc.h>

#include <ooptoken.h>

// UNDONE where do these belong?
extern    PSE_TABLE    g_psextensions;


class CComContextHelper
/*++

Class description:

    Stack based helper class to enable calls to CoInitialize inside
    ISAPI. 
    
    Replaces member functions PrepareCom/UnprepareCom in WAM_EXEC_INFO. 
    These had to be replaced because WAM_EXEC_INFO will persist beyond
    the initial ISAPI call in the async case and keeping the call context
    in member data would leak and overrelease under certain conditions.


Public Interface:

    PrepareCom          : For OOP get the call context and use our
                          private interface to enable coinit calls.
    UnprepareCom        : Release the call context.

--*/
{
public:
    
    CComContextHelper( BOOL fInProcess )
        : m_fInProcess( fInProcess ),
          m_pComContext( NULL ),
          m_pComInitsCookie( NULL )
    {
    }

    ~CComContextHelper( void )
    {
        UnprepareCom();
    }

    HRESULT PrepareCom()
    /*++
    Routine Description:

        Prepare com before call into ISAPI. For OOP get the call context
        and use our private interface to enable coinit calls.

    --*/
    {
        HRESULT hr = NOERROR;

        // Never call twice.
        DBG_ASSERT( NULL == m_pComInitsCookie );
        DBG_ASSERT( NULL == m_pComContext );
   
        if( !m_fInProcess )
        {    
            // Save COM Call Context in MTS case       
            hr = CoGetCallContext( IID_IComDispatchInfo, (void **)&m_pComContext );
            if( SUCCEEDED(hr) ) 
            {
                hr = m_pComContext->EnableComInits( &m_pComInitsCookie );
            }
        }
        return hr;
    }

    void UnprepareCom()
    /*++
    Routine Description:

        Restores com state after call into ISAPI. Release call context.

    --*/
    {
        // Restore COM Call Context
        if( m_pComContext ) 
        {
            DBG_ASSERT( !m_fInProcess );
            DBG_ASSERT( m_pComInitsCookie );

            m_pComContext->DisableComInits( m_pComInitsCookie );
            m_pComContext->Release();

            m_pComContext = NULL;
            m_pComInitsCookie = NULL;
        }
    }

private:
    //NO-OP
    CComContextHelper() {}
    CComContextHelper( const CComContextHelper & ref ) {}

private:

    BOOL                    m_fInProcess;
    IComDispatchInfo *      m_pComContext;
    void *                  m_pComInitsCookie;

};


/*---------------------------------------------------------------------*
WAM::InitWam

Routine Description:
    Initializes this WAM.

Arguments:
    See below

Return Value:
    HRESULT

*/
STDMETHODIMP
WAM::InitWam
(
BOOL    fInProcess,         // are we in-proc or out-of-proc?
BOOL    fInPool,            // !Isolated
BOOL    fEnableTryExcept,   // catch exceptions in ISAPI calls?
int     pt,             // PLATFORM_TYPE - are we running on Win95?
DWORD   *pPID           // Process Id of the process the wam was created in
)
{
    HRESULT    hr = NOERROR;


    IF_DEBUG( INIT_CLEAN ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "\n ********** WAM(%08x)::InitWam() *****\n",
                    this));
    }

    INITIALIZE_CRITICAL_SECTION( &m_csWamExecInfoList );
    InitializeListHead( &m_WamExecInfoListHead );

    m_fInProcess = fInProcess;
    m_fInPool = fInPool;

    DBG_ASSERT( pt != PtInvalid );
    m_pt = (PLATFORM_TYPE) pt;

    // Get the process id of the current process so we can return it to w3svc
    *pPID = GetCurrentProcessId();

    // Acquire a reference to the SE_TABLE object
    DBG_REQUIRE( g_psextensions->AddRefWam() > 0);

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "\n************Leaving WAM::InitWam ...\n" ));
        }

    DBG_ASSERT( SUCCEEDED(hr));

    //
    // UNDONE: See the DoGlobalInitializations() for details.
    //
    hr = DoGlobalInitializations( fInProcess, fEnableTryExcept);

    return (hr);
} // WAM::InitWam()




/*---------------------------------------------------------------------*
WAM::StartShutdown

Routine Description:
    Phase 1 of shutdown process.
    Set the shutdown flag on the WAM object
    Loop for small duration checking if all WAM_EXEC_INFO's have drained.
    At the end of loop initiate the first phase of TerminateExtension()

    NOTE: TerminateExtension() - currently have been tested only for the
    MUST_UNLOAD option => there is no two-phase operation there.
    So, we will rely on calling it once only.

Arguments:
    None

Return Value:
    HRESULT

*/
STDMETHODIMP
WAM::StartShutdown(
)
{
    DWORD i;

    IF_DEBUG( WAM ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "WAM(%08x)::StartShutdown() %d Active Requests\n",
                    this, QueryWamStats().QueryCurrentWamRequests() ));
    }

    // Set the Shutting down flag to true now
    DBG_REQUIRE( FALSE ==
                 InterlockedExchange((LPLONG)&m_fShuttingDown, (LONG)TRUE)
                 );

    for ( i = 0;
          ( (i < 10) &&
            (QueryWamStats().QueryCurrentWamRequests())
            );
          i++ )
    {
# ifndef SHUTOFF_AFTER_BETA
        DBGPRINTF(  (
            DBG_CONTEXT,
            "[%d] WAM(%08x) has %d requests waiting for cleanup\n",
            GetCurrentThreadId(),
            this, QueryWamStats().QueryCurrentWamRequests()
            ) );
# endif // SHUTOFF_AFTER_BETA

        Sleep( 200 );  // sleep for a while before restarting the check again
    } // for

    // Release the reference to the SE_TABLE object
    g_psextensions->ReleaseRefWam();

    return NOERROR;
} // WAM::StartShutdown()




/*---------------------------------------------------------------------*
WAM::UninitWam

Routine Description:
    Phase 2 of shutdown process.

Arguments:
    None

Return Value:
    HRESULT
        NOERROR on success
        E_FAIL if there are any pending items to be deleted still

*/
STDMETHODIMP
WAM::UninitWam()
{
    //
    //  If there are any pending requests being processed, wait for them
    //   to be drained off from this WAM
    //

    IF_DEBUG( WAM ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "WAM(%08x)::UninitWam() %d Active Requests\n",
                    this, QueryWamStats().QueryCurrentWamRequests() ));
    }

    if ( QueryWamStats().QueryCurrentWamRequests() != 0 )
    {
        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                        "WAM(%08x)::UninitWam() Error - "
                        " Failed with active requests! (%d active)\n",
                        this,
                        QueryWamStats().QueryCurrentWamRequests() ));
        }

        //
        // Enumerate and dump information on all requests that are hanging
        //  and the associated ISAPI DLLs
        //
# ifndef SHUTOFF_AFTER_BETA
        while ( QueryWamStats().QueryCurrentWamRequests() > 0) {

            DBGPRINTF(
                ( DBG_CONTEXT,
                  "\n\n[Thd %d]WAM(%08x) has %d requests waiting ... \n",
                  GetCurrentThreadId(),
                  this, QueryWamStats().QueryCurrentWamRequests()
                ) );

            g_psextensions->PrintRequestCounts();

            // sleep for a while before restarting the check again
            Sleep( 1000 );
        } // while

# endif // SHUTOFF_AFTER_BETA


        // return failure, since we failed to shutdown gracefully!
        // NYI: Should I ignore the fact that some long-hanging connections
        //  are okay?
        // Shouldn't I be forcing the exit now?
        DBG_ASSERT( QueryWamStats().QueryCurrentWamRequests() == 0);
        // return ( E_FAIL);
    }

    DeleteCriticalSection( &m_csWamExecInfoList );

    return NOERROR;
} // WAM::UninitWam()


/*-----------------------------------------------------------------------------*
WAM::ProcessAsyncIO
    Completes an async i/o process for a given wam request.

Arguments:

Return Value:
    HRESULT

*/
STDMETHODIMP
WAM::ProcessAsyncIO
(
#ifdef _WIN64
UINT64    pWamExecInfoIn,  // WAM_EXEC_INFO *
#else
DWORD_PTR pWamExecInfoIn,  // WAM_EXEC_INFO *
#endif
DWORD   dwStatus,
DWORD   cbWritten
)
{
    return ProcessAsyncIOImpl( pWamExecInfoIn,
                               dwStatus,
                               cbWritten
                               );

} // WAM::ProcessAsyncIO

STDMETHODIMP
WAM::ProcessAsyncReadOop
(
#ifdef _WIN64
    UINT64          pWamExecInfoIn,
#else
    DWORD_PTR       pWamExecInfoIn,
#endif
    DWORD           dwStatus,
    DWORD           cbRead,
    unsigned char * lpDataRead
)
/*++
    Routine Description:
        
        Handle callback for out of process AsyncRead

    Arguments:

        pWamExecInfoIn  - The smuggled pointer to the WAM_EXEC_INFO
        dwStatus        - IO status
        cbRead          - Number of bytes read
        lpDataRead      - Marshalled data read

    Return Value:

    Notes:

        The initial design for AsyncRead was inadequate when the isapi is 
        running out of process. The problem was that the data buffer was
        marshalled over to inetinfo and back during the AsyncRead call.
        Since the completion will happen on another thread the ISAPI could
        get the completion before the data was completely marshalled back
        or the address in inetinfo could be invalidated before the read was
        complete. The solution is to add a separate path for oop async reads
        and marshall the data on the io completion and copy it into the
        client's buffer then.

--*/
{
    DBG_ASSERT( lpDataRead != NULL );
    DBG_ASSERT( !m_fInProcess );

    return ProcessAsyncIOImpl( pWamExecInfoIn,
                               dwStatus,
                               cbRead,
                               lpDataRead
                               );
}

HRESULT         
WAM::ProcessAsyncIOImpl
(
#ifdef _WIN64
    UINT64          pWamExecInfoIn,
#else
    DWORD_PTR       pWamExecInfoIn,
#endif
    DWORD           dwStatus,
    DWORD           cb,
    LPBYTE          lpDataRead // = NULL
)
{
    HRESULT             hrRet;
    CComContextHelper   callContext( m_fInProcess );

    WAM_EXEC_INFO * pWamExecInfo =
        reinterpret_cast<WAM_EXEC_INFO *>(pWamExecInfoIn);

    //
    //  NOTE we assert because we believe the pointer can never be null
    //  AND we fail gracefully if it is null because there is a long
    //  code path across many threads between setting the pointer
    //  and here, and you never know ...
    //

    DBG_ASSERT ( pWamExecInfo != NULL );

    if ( pWamExecInfo == NULL ) {

        return HRESULT_FROM_WIN32( E_POINTER );
    }

    //
    // Note: The AddRef/Release calls may not be necessary anymore.
    // 
    // Make sure that UnprepareCom has valid WamInfo
    //

    pWamExecInfo->AddRef();

    callContext.PrepareCom();

    if( lpDataRead == NULL )
    {
        // Doing an out of process async read

        hrRet = HresultFromBool(
                            pWamExecInfo->ProcessAsyncIO(
                            dwStatus,
                            cb
                            ) );
    }
    else
    {
        // All other async io completions

        hrRet = HresultFromBool(
                            pWamExecInfo->ProcessAsyncReadOop(
                            dwStatus,
                            cb,
                            lpDataRead
                            ) );
    }

    callContext.UnprepareCom();
	
    //
    // Balance AddRef() above
    //

    pWamExecInfo->Release();

    return hrRet;
}


/*-----------------------------------------------------------------------------*
WAM::ProcessRequest
    Processes a WAM request.

Arguments:
    pIWamRequest - pointer to IWamRequest interface
    cbWrcStrings - Count of bytes for wamreq core strings
    pfHandled    - Indicates we handled this request
    pfFinished   - Indicates no further processing is required

Return Value:
    HRESULT

*/
STDMETHODIMP
WAM::ProcessRequest
(
IWamRequest *       pIWamRequest,
DWORD               cbWrcStrings,
OOP_CORE_STATE *    pOopCoreState,
BOOL *              pfHandled
)
{
    HRESULT             hrRet = NOERROR;    // this function's return value
    HRESULT                             hr;
    int                 iretInvokeExt;      // return value from InvokeExtension
    BOOL                fFreeContext = TRUE;// do we need to free up wamex-info?
    WAM_EXEC_INFO *     pWamExecInfo = NULL;
    BOOL                fImpersonated = FALSE;
    BYTE *              pbEntityBody = NULL;
    DWORD               cbEntityBody = 0;
    CComContextHelper   callContext( m_fInProcess );


    DBG_ASSERT( pIWamRequest );
    IF_DEBUG( WAM) {
        DBGPRINTF(( DBG_CONTEXT,
                    "WAM(%08x)::ProcessRequest(%08x, %08x, ... )\n",
                    this, pIWamRequest ));
    }


    if ( m_fShuttingDown ) {

        IF_DEBUG( WAM) {

            DBGPRINTF((
                DBG_CONTEXT
                , "WAM(%08x) shutting down.  "
                  "Request(%08x) will be aborted.\n"
                , this
                , pIWamRequest
            ));
        }

        // UNDONE something besides E_FAIL?
        return E_FAIL;

    }


    // create, init the wamexec-info and add it to list
    pWamExecInfo = new WAM_EXEC_INFO( this );
    if( NULL == pWamExecInfo )
        {
        hrRet = E_OUTOFMEMORY;
        goto LError;
        }

    //
    //  Update the statistics counters
    //

    m_WamStats.IncrWamRequests();


    if ( FAILED( hrRet = pWamExecInfo->InitWamExecInfo( pIWamRequest,
                                                        cbWrcStrings,
                                                        pOopCoreState
                                                        ) ) )
    {
         goto LError;
    }

    if( !m_fInProcess )
    {
        //
        // This test shouldn't really be necessary. In the case where com plus 
        // activates us in process even if we are marked to run in the
        // surrogate, we will fail the app creation.
        //
        DBG_ASSERT( CWamOopTokenInfo::HasInstance() );
        if( CWamOopTokenInfo::HasInstance() )
        {
            hrRet = CWamOopTokenInfo::QueryInstance()->ModifyTokenForOop
                        (
                        WRC_GET_FIX.m_hUserToken 
                        );

            if( FAILED(hrRet) )
            {
                goto LError;
            }
        }
    }

    this->InsertIntoList( &pWamExecInfo->_ListEntry);


    DBG_WAMREQ_REFCOUNTS(( "WAM::ProcessRequest right after wrc construction ...", pWamExecInfo ));

    if ( !FWin95() )
    {
        if ( !ImpersonateLoggedOnUser( WRC_GET_FIX.m_hUserToken ) )
        {
            IF_DEBUG( ERROR ) {
                DBGPRINTF((DBG_CONTEXT,
                           "WAM(%08x) ImpersonateLoggedOnUser(%08x)"
                           "failed[err %d]\n",
                           this, WRC_GET_FIX.m_hUserToken, GetLastError()));
            }

            hrRet = HresultFromGetLastError();
            goto LError;
        }
        fImpersonated = TRUE;
    }

    pWamExecInfo->_psExtension = NULL;

    if ( ! g_psextensions->GetExtension(  WRC_GET_SZ( WRC_I_ISADLLPATH ),
                                          WRC_GET_FIX.m_hUserToken,
                                          WRC_GET_FIX.m_fAnonymous,
                                          WRC_GET_FIX.m_fCacheISAPIApps,
                                          &(pWamExecInfo->_psExtension ) ) )
        {

        hrRet = HresultFromGetLastError( );
        goto LError;

        }

    // Add a reference to ensure that wamexec is valid until we hit the
    // cleanup code. Don't put any goto LError after this or the wamexec
    // will leak.
    pWamExecInfo->AddRef();

    // Invoke the server extension
    callContext.PrepareCom();
    iretInvokeExt = InvokeExtension( pWamExecInfo->_psExtension,
                                     WRC_GET_SZ( WRC_I_ISADLLPATH ),
                                     pWamExecInfo );
    callContext.UnprepareCom();

    if ( fImpersonated ) {
       ::RevertToSelf( );
       fImpersonated = FALSE;
    }

    pWamExecInfo->_dwFlags &= ~SE_PRIV_FLAG_IN_CALLBACK;

    switch ( iretInvokeExt )
    {

    case HSE_STATUS_PENDING: {

        IF_DEBUG( WAM_EXEC ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "WAM(%08x)::ProcessRequest case HSE_STATUS_PENDING\n"
                , this
            ));
        }

        IF_DEBUG( WAM_REFCOUNTS ) {

            DBG_WAMREQ_REFCOUNTS((
                "WAM::ProcessRequest case HSE_STATUS_PENDING ",
                pWamExecInfo
            ));
        }

        //
        //  Figure out whether this mainline thread or callback thread
        //  hit its cleanup code first
        //
        //  This protects us against isapis that disobey the async rules.
        //  The isapi should be in one of two modes:
        //
        //  1. It return HSE_STATUS_PENDING in the mainline thread and 
        //  always calls HSE_DONE_WITH_SESSION.
        //
        //  2. It returns any other status code from the mainline and
        //  NEVER calls HSE_DONE_WITH_SESSION.
        //
        //  Unfortunately isapi writers frequently do bad things to good
        //  servers.
        //
        //  NOTE return value of INTERLOCKED_COMPARE_EXCHANGE
        //  is initial value of the destination
        //

        LONG FirstThread = INTERLOCKED_COMPARE_EXCHANGE(
                                (LONG *) &pWamExecInfo->_FirstThread
                                , (LONG) FT_MAINLINE
                                , (LONG) FT_NULL
                            );

        if( FirstThread == (LONG) FT_CALLBACK ) {

            //
            //  If we made it here, then we need to do cleanup, meaning:
            //  - SSF HSE_REQ_DONE_WITH_SESSION callback has already run
            //  - we set fFreeContext TRUE to trigger cleanup below
            //

            fFreeContext = TRUE;

            IF_DEBUG( WAM_EXEC ) {

                DBGPRINTF((
                    DBG_CONTEXT
                    , "\tSession done.\n"
                ));
            }

        } else {

            DBG_ASSERT( FirstThread == (LONG) FT_NULL );

            //
            //  If we made it here, then we can't cleanup yet, meaning:
            //  - SSF HSE_REQ_DONE_WITH_SESSION callback will cleanup
            //    when it runs
            //  - we set fFreeContext FALSE to avoid cleanup below
            //
            fFreeContext = FALSE;

            IF_DEBUG( WAM_EXEC ) {

                DBGPRINTF((
                    DBG_CONTEXT
                    , "\tSession NOT done.\n"
                ));
            }
        }

        //
        //  If fFreeContext is FALSE at this point, we may not use
        //  pWamExecInfo from this point on - callback thread can
        //  invalidate it at any time.
        //

        break;
    } // case HSE_STATUS_PENDING


    case HSE_STATUS_ERROR:
    case HSE_STATUS_SUCCESS:

        //
        //  in error and success cases we no-op
        //

        break;

    case HSE_STATUS_SUCCESS_AND_KEEP_CONN:

        //
        //  remember that ISA asked us to set keep-conn
        //

        pWamExecInfo->_dwIsaKeepConn = KEEPCONN_TRUE;
        break;

    default:

        break;
    } // switch()

    // Release the ref held by this call
    pWamExecInfo->Release();

    if ( fFreeContext ) {

        DBG_ASSERT( pWamExecInfo != NULL);

        DBG_WAMREQ_REFCOUNTS(( "WAM::ProcessRequest fFreeContext ...",
                            pWamExecInfo));



        pWamExecInfo->CleanupAndRelease( TRUE );

        pWamExecInfo = NULL;

    } // if ( fFreeContext);

    *pfHandled = TRUE;
    DBG_ASSERT( hrRet == NOERROR );


LExit:

    if ( fImpersonated ) {

        ::RevertToSelf( );
        fImpersonated = FALSE;
    }

    return hrRet;


LError:

    //
    // release pWamExecInfo on failure case
    // NOTE we separate this from normal exit code because wamexecinfo
    // must hang around in many non-error cases (status-pending, async i/o)
    //

    if ( pWamExecInfo != NULL) {

        pWamExecInfo->CleanupAndRelease( FALSE );

        pWamExecInfo = NULL;
    }


    goto LExit;

} // WAM::ProcessRequest()



STDMETHODIMP
WAM::GetStatistics(
                   /*[in]*/     DWORD       dwLevel,
                   /*[out, switch_is(Level)]*/
                   LPWAM_STATISTICS_INFO pWamStatsInfo
                  )
/*++
  Description:
    Obtains the statistics for the given instance of WAM for specified level.

  Arguments:
    dwLevel - specifies the information level. (Currently level 0 is supported)
    pWamStatsInfo - pointer to the WAM STATISTICS INFO object that will
                  receive the statistics.

  Returns:
    HRESULT - NOERROR on success and E_FAIL on failure.
--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( pWamStatsInfo != NULL);

    IF_DEBUG( API_ENTRY) {
        DBGPRINTF(( DBG_CONTEXT, "WAM(%08x)::GetStatistics(%d, %08x)\n",
                    this, dwLevel, pWamStatsInfo));
    }

    switch ( dwLevel) {
    case 0: {
        // copy values out of the statistics structure
        m_WamStats.CopyToStatsBuffer( &pWamStatsInfo->WamStats0);
        break;
    }

    default:
        DBG_ASSERT( FALSE);
        hr = E_FAIL;
        break;

    } // switch()

    return (hr);

} // WAM::GetStatistics()



/*++
WAM::InvokeExtension

Routine Description:

    Invokes a server extension.
    NOTE without this cover function, we get a compile error
        error C2712: Cannot use __try in functions that require object unwinding

Arguments:

    psExt            -    pointer to server extension
    szISADllPath    -    Fully qualified path to Module (DLL name)
    pWamExecInfo    -   ptr to wamexec info

Return Value:

    DWORD    -    HSE_STATUS_ code

--*/
DWORD
WAM::InvokeExtension
(
IN PHSE         psExt,
const char *    szISADllPath,
WAM_EXEC_INFO * pWamExecInfo
)
    {

    DWORD               ret;

    //
    //  Protect the call to the server extension so we don't hose the
    //  server
    //

    __try
        {
        ret = psExt->ExecuteRequest( pWamExecInfo );
        }
    __except ( g_fEnableTryExcept ?
                WAMExceptionFilter( GetExceptionInformation(),
                                    WAM_EVENT_EXTENSION_EXCEPTION,
                                    pWamExecInfo ) :
                EXCEPTION_CONTINUE_SEARCH )
        {

        //
        // exception caused us to to leave HSE_APPDLL::ExecuteRequest
        // with unbalanced AddRef()
        //

        pWamExecInfo->Release();

        ret = HSE_STATUS_ERROR;
        }

    return ret;
    }    // WAM::InvokeExtension


/*++
WAM::HseReleaseExtension

Routine Description:

    Releases a server extension.

Arguments:

    psExt  - pointer to server extension.

Return Value:

    None

--*/
VOID
WAM::HseReleaseExtension
(
IN PHSE psExt
)
    {
    g_psextensions->ReleaseExtension( psExt);
    } // HseReleaseExtension()





/************************************************************
 *    Member Functions of WAM_STATISTICS
 ************************************************************/


WAM_STATISTICS::WAM_STATISTICS( VOID)
/*++
     Initializes statistics information for server.
--*/
{
    INITIALIZE_CRITICAL_SECTION( & m_csStatsLock);
    ClearStatistics();

} // WAM_STATISTICS::WAM_STATISTICS();


VOID
WAM_STATISTICS::ClearStatistics( VOID)
/*++

    Clears the counters used for statistics information

--*/
{
    LockStatistics();

    memset( &m_WamStats, 0, sizeof(WAM_STATISTICS_0) );
    m_WamStats.TimeOfLastClear       = GetCurrentTimeInSeconds();

    UnlockStatistics();

} // WAM_STATISTICS::ClearStatistics()



DWORD
WAM_STATISTICS::CopyToStatsBuffer( PWAM_STATISTICS_0 pStat0)
/*++
    Description:
        copies the statistics data from the server statistcs structure
        to the WAM_STATISTICS_0 structure for RPC access.

    Arugments:
        pStat0  pointer to WAM_STATISTICS_0 object which contains the
                data on successful return

    Returns:
        Win32 error codes. NO_ERROR on success.

--*/
{

    DBG_ASSERT( pStat0 != NULL);

    LockStatistics();

    CopyMemory( pStat0, &m_WamStats, sizeof(WAM_STATISTICS_0) );

    UnlockStatistics();

    return ( NO_ERROR);

} // WAM_STATISTICS::CopyToStatsBuffer()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\wamxinfo.cxx ===
/*---------------------------------------------------------------------*

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      wamxinfo.cxx (formerly seinfo.cxx)

   Abstract:

      Implementation of WAM_EXEC_INFO object.

   Authors:

       Murali R. Krishnan    ( MuraliK )     18-July-1996
       David Kaplan          ( DaveK )       10-July-1997

   Environment:

       User Mode - Win32

   Project:

       Wam DLL
--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include <isapip.hxx>
# include "wamxinfo.hxx"
# include "WReqCore.hxx"
# include "setable.hxx"
# include "gip.h"
# include "WamW3.hxx"

// MIDL-generated
# include "iwr.h"

// allocation cache for the WAM_EXEC_INFO objects
ALLOC_CACHE_HANDLER * WAM_EXEC_INFO::sm_pachExecInfo;
# define WAM_EXEC_INFO_CACHE_THRESHOLD  (400) // UNDONE: Empirically vary

#if DBG
PTRACE_LOG            WAM_EXEC_INFO::sm_pDbgRefTraceLog;
#endif

SV_CACHE_MAP * WAM_EXEC_INFO::sm_pSVCacheMap = NULL;

//
// Ref count trace log sizes for per-request log and global log
// (used for debugging ref count problems)
//
// NOTE these are large because WAM_EXEC_INFO can have a lot of
// ref/deref activity
//

#define C_REFTRACES_PER_REQUEST 128
#define C_REFTRACES_GLOBAL      4096


/************************************************************
 *    Functions
 ************************************************************/



/*---------------------------------------------------------------------*
WAM_EXEC_INFO::WAM_EXEC_INFO
    Constructor

Arguments:
    pWam        -   ptr to wam

Returns:
    Nothing

*/
WAM_EXEC_INFO::WAM_EXEC_INFO(
    PWAM pWam
)
{
    _cRefs = 1;
    m_pWam= pWam;
    _psExtension = NULL;
    _FirstThread = FT_NULL;
    m_dwSignature = WAM_EXEC_INFO_SIGNATURE;

    DBG_ASSERT( m_pWam );

    m_fInProcess = m_pWam->FInProcess();
    m_fInPool = m_pWam->FInPool();
    
    m_fDisconnected = FALSE;

    InitializeListHead( &_ListEntry);

    IF_DEBUG( WAM_EXEC ) {

        DBGPRINTF(( DBG_CONTEXT, "WAM_EXEC_INFO(%p) Ctor   : %d -> %d\n",
                this, _cRefs-1, _cRefs ));

    }

#if DBG
    // create ref trace log
    m_pDbgRefTraceLog = CreateRefTraceLog( C_REFTRACES_PER_REQUEST, 0 );
#endif

} // WAM_EXEC_INFO::WAM_EXEC_INFO


/*---------------------------------------------------------------------*
WAM_EXEC_INFO::~WAM_EXEC_INFO
    Destructor

Arguments:
    None

Returns:
    Nothing

*/
WAM_EXEC_INFO::~WAM_EXEC_INFO(
)
{

    IF_DEBUG( WAM_EXEC ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p) Dtor \n"
            , this
        ));
    }

    m_dwSignature = WAM_EXEC_INFO_SIGNATURE_FREE;

#if DBG
    // write thread id into second dword of this object's memory
    // (alloc cache stores next-ptr in 1st dword, so we use 2nd slot)
    *( (DWORD *)this + 1 ) = GetCurrentThreadId();

    // destroy ref trace log
    if( m_pDbgRefTraceLog != NULL ) {
        DestroyRefTraceLog( m_pDbgRefTraceLog );
    }

#endif

} // WAM_EXEC_INFO::~WAM_EXEC_INFO



#define WRC_F   _WamReqCore.m_WamReqCoreFixed
/*---------------------------------------------------------------------*
WAM_EXEC_INFO::InitWamExecInfo
    Initializes the wamexec info

Arguments:
    cbWrcStrings   -   number of bytes required by strings buffer
    dwChildFlags   -   flags for child execution (HSE_EXEC_???)

Returns:
    HRESULT

*/
HRESULT
WAM_EXEC_INFO::InitWamExecInfo
(
IWamRequest *       pIWamRequest,
DWORD               cbWrcStrings,
OOP_CORE_STATE *    pOopCoreState
)
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( pIWamRequest );

    IF_DEBUG( WAM_EXEC ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p)::InitWamExecInfo "
              "pIWamRequest(%p) "
              "cbWrcStrings(%d) "
              "m_fInProcess(%d) "
              "\n"
            , this
            , pIWamRequest
            , cbWrcStrings
            , m_fInProcess
        ));

    }


    if ( FAILED( hr = InitWamExecBase( pIWamRequest ) ) ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "InitWamExecBase failed "
              "hr(%x) "
              "\n"
            , hr
        ));

        goto LExit;
    }



    //
    //  Init wamreq core - contains stuff needed by ecb
    //

    if ( FAILED( hr = _WamReqCore.InitWamReqCore(
                            cbWrcStrings
                            ,  pIWamRequest
                            ,  pOopCoreState
                            ,  m_fInProcess
                        ) ) ) 
    {

        DBGPRINTF((
            DBG_CONTEXT
            , "InitWamReqCore failed "
              "hr(%x) "
              "\n"
            , hr
        ));

        goto LExit;
    }

    //
    //  If this is a child ISA, set appropriate flags
    //

    _dwChildExecFlags = _WamReqCore.m_WamReqCoreFixed.m_dwChildExecFlags;


    IF_DEBUG( WAM_EXEC ) {

        Print();
    }

    //
    //  begin Reset_Code
    //  [the following code was formerly WAM_EXEC_INFO::Reset]
    //

    _dwFlags                        = SE_PRIV_FLAG_IN_CALLBACK;
    _AsyncIoInfo._pfnHseIO          = NULL;
    _AsyncIoInfo._pvHseIOContext    = NULL;
    _AsyncIoInfo._dwOutstandingIO   = ASYNC_IO_TYPE_NONE;
    _AsyncIoInfo._cbLastAsyncIO     = 0;
    _AsyncIoInfo._pvAsyncReadBuffer = NULL;

    // we are either inproc-valid or oop-valid, not both
    DBG_ASSERT(
        ( m_fInProcess && AssertInpValid()  && !AssertOopValid() )
    ||
        (!m_fInProcess && !AssertInpValid() && AssertOopValid() )
    );

    ecb.cbSize           = sizeof(EXTENSION_CONTROL_BLOCK);

    //
    // dwVersion is hardcoded because the iisext.h file that defines
    // HSE_VERSION_MAJOR and HSE_VERSION_MINOR is shipped as a part of
    // the SDK, and the compiler variable that distinguishes 5.1 from
    // 6.0 builds is internal.  The #if directive wouldn't make sense
    // in a file exposed to the public.
    //

    ecb.dwVersion        = MAKELONG( 1, 5 );

// keep in sync with HT_OK in basereq.hxx
#define HT_OK   200

    ecb.dwHttpStatusCode = HT_OK;
    ecb.lpszLogData[0]   = '\0';
    
    //
    // note that function pointers are set in isplocal.cxx before
    // executing the request using ECB 
    //

    ecb.ConnID           = (HCONN) this;
    ecb.lpszMethod       = _WamReqCore.GetSz( WRC_I_METHOD );
    ecb.lpszQueryString  = _WamReqCore.GetSz( WRC_I_QUERY );
    ecb.lpszPathInfo     = _WamReqCore.GetSz( WRC_I_PATHINFO );
    ecb.lpszContentType  = _WamReqCore.GetSz( WRC_I_CONTENTTYPE );
    ecb.lpszPathTranslated = _WamReqCore.GetSz( WRC_I_PATHTRANS );
    ecb.cbTotalBytes     = WRC_F.m_cbClientContent;

    //
    //  Clients can send more bytes then are indicated in their
    //  Content-Length header.  Adjust byte counts so they match
    //

    ecb.cbAvailable =   (WRC_F.m_cbEntityBody > WRC_F.m_cbClientContent)
                        ? WRC_F.m_cbClientContent
                        : WRC_F.m_cbEntityBody
                        ;

    ecb.lpbData = _WamReqCore.m_pbEntityBody;

    //
    //  end Reset_Code
    //  [the preceding code was formerly WAM_EXEC_INFO::Reset]
    //


LExit:
    return hr;

}   // WAM_EXEC_INFO::InitWamExecInfo

HRESULT 
WAM_EXEC_INFO::GetInfoForName
(
    IWamRequest *           pIWamRequest,
    const unsigned char *   szVarName,
    unsigned char *         pchBuffer,
    DWORD                   cchBuffer,
    DWORD *                 pcchRequired
)
{
    HRESULT     hr = NOERROR;
    BOOL        fCacheHit = FALSE;

    if( !m_fInProcess )
    {
        // Lookup server variable in the cache.
       
        DBG_ASSERT( sm_pSVCacheMap );
        
        LPCSTR  szTempVarName = (LPSTR)szVarName;
        DWORD   dwOrdinal;
        
        if( sm_pSVCacheMap->FindOrdinal( szTempVarName, 
                                         strlen(szTempVarName),
                                         &dwOrdinal
                                         ) )
        {
            DBG_ASSERT( dwOrdinal < SVID_COUNT );

            DWORD dwOffset = _WamReqCore.m_rgSVOffsets[dwOrdinal];

            if( dwOffset != SV_DATA_INVALID_OFFSET )
            {
                DBG_ASSERT( _WamReqCore.m_pbSVData );

                // We have a value cached.
                fCacheHit = TRUE;

                if( SUCCEEDED(dwOffset) )
                {
                    // The offset is an actual offset into our data buffer iff
                    // the high bit isn't set.
                    LPSTR   szValue = (LPSTR)(_WamReqCore.m_pbSVData + dwOffset);
                    DWORD   cchValue = strlen( szValue ) + 1;

                    if( cchValue > cchBuffer || pchBuffer == NULL )
                    {
                        // Insufficient buffer
                        SetLastError( ERROR_INSUFFICIENT_BUFFER );
                        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    }
                    else
                    {
                        CopyMemory( pchBuffer, szValue, cchValue );
                    }
                    *pcchRequired = cchValue;
                }
                else
                {
                    //
                    // In the event that HTTP_REQUEST::GetInfoForName
                    // failed because of missing data the error code
                    // returned is stored in dwOffset.
                    //
                    DBG_ASSERT( FAILED(dwOffset) );
                    
                    // Rely on BoolFromHresult to do the SetLastError...
                    hr = dwOffset;
                }
            }
        }
    }

    if( !fCacheHit )
    {   
        // Moved from isplocal.cxx - GetServerVariable()

        HANDLE hCurrentUser = NULL;
        
        if( !m_fInProcess )
        {
            hCurrentUser = INVALID_HANDLE_VALUE;
        }

        DoRevertHack( &hCurrentUser );

        hr = pIWamRequest->GetInfoForName( szVarName,
                                           pchBuffer,
                                           cchBuffer,
                                           pcchRequired 
                                           );

        UndoRevertHack( &hCurrentUser );
    }

    return hr;
}


/*---------------------------------------------------------------------*
WAM_EXEC_INFO::TransmitFile

  This function transmits the file contents as specified in the
   pHseTfi. It also sets up the call back functions for
   processing the request when it completes.

  Arguments:
   pHseTfi - pointer to Server Extension Transmit File information

  Returns:
   TRUE on success and FALSE on failure

*/
BOOL
WAM_EXEC_INFO::TransmitFile(
    IN LPHSE_TF_INFO  pHseTfi
)
{

    BOOL            fReturn = FALSE;
    IWamRequest *   pIWamRequest = NULL;


    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p)::TransmitFile "
              "pHseTfi(%p) "
              "\n"
            , this
            , pHseTfi
        ));

    }


    //
    // It is unlikely that ISAPI applications will post
    //  multiple outstanding IOs. However we have the state
    //  pAsyncIoInfo->_fOutstandingIO to secure ourselves against this.
    // I have not used any critical sections to protect against
    //  multiple threads for performance reasons.
    // Today we support only Async IO transfers
    //

    if ( pHseTfi == NULL
         || _AsyncIoInfo._dwOutstandingIO
         || ((pHseTfi->dwFlags & HSE_IO_ASYNC) == 0) ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return ( FALSE );
    }


    if ( pHseTfi->hFile == INVALID_HANDLE_VALUE) {

        SetLastError( ERROR_INVALID_HANDLE );
        return ( FALSE );
    }

    //
    // If there is no file being transfered, then having a non-zero
    // offset or BytesToWrite will be bad.
    //
    if( (pHseTfi->hFile == NULL) && 
        (pHseTfi->BytesToWrite != 0 || pHseTfi->Offset != 0) )
    {
        // Consider: We could just set these to 0, ie ignore them
        // if the hFile is NULL.

        SetLastError( ERROR_INVALID_PARAMETER );
        return ( FALSE );
    }


    //
    //  Record the number of bytes to complete the IO with
    //

    if ( pHseTfi->BytesToWrite > 0 ) {

        DBG_ASSERT( pHseTfi->hFile );

        _AsyncIoInfo._cbLastAsyncIO = pHseTfi->BytesToWrite;

    } else {

        //
        //  If a zero-size was passed in, get size from file
        //

        if( pHseTfi->hFile )
        {

            BY_HANDLE_FILE_INFORMATION hfi;

            if ( !GetFileInformationByHandle( pHseTfi->hFile, &hfi )) {

                // CONSIDER something besides ERROR_INVALID_HANDLE???
                SetLastError( ERROR_INVALID_HANDLE );
                return ( FALSE );
            }

            if ( hfi.nFileSizeHigh ) {

                SetLastError( ERROR_NOT_SUPPORTED );
                return ( FALSE );
            }

            _AsyncIoInfo._cbLastAsyncIO = hfi.nFileSizeLow;
        }
        else
        {
            // We want to allow TransmitFile without a file handle
            _AsyncIoInfo._cbLastAsyncIO = 0;
        }

    }


    //
    // Set the callback function. Override old one
    //

    if ( pHseTfi->pfnHseIO != NULL) {

        _AsyncIoInfo._pfnHseIO = pHseTfi->pfnHseIO;
    }


    if ( NULL == _AsyncIoInfo._pfnHseIO) {

        // No callback specified. return error
        SetLastError( ERROR_INVALID_PARAMETER );
        return ( FALSE );
    }


    if ( pHseTfi->pContext != NULL) {

        // Override the old context
        _AsyncIoInfo._pvHseIOContext = pHseTfi->pContext;
    }


    if ( FAILED( GetIWamRequest( &pIWamRequest ) ) ) {

        // CONSIDER something besides ERROR_INVALID_FUNCTION???
        SetLastError( ERROR_INVALID_FUNCTION );
        return FALSE;
    }

    DBG_ASSERT( pIWamRequest );


    //
    //  Finally, call appropriate transmit-file version
    //  based on in-proc vs. oop.
    //
    //  First, we init async i/o processing.  In normal (success) case,
    //  i/o completion thread will call balancing uninit.  In failure
    //  case, we call it below.
    //

    InitAsyncIO( ASYNC_IO_TYPE_WRITE );


    if ( m_fInProcess ) {

        //
        //  call in-proc interface (fastest)
        //

        fReturn = BoolFromHresult(
                    pIWamRequest->TransmitFileInProc(
#ifdef _WIN64
                        (UINT64) this
#else
                        (ULONG_PTR) this
#endif
                        , (unsigned char *) pHseTfi
                    ) );

    } else {

        //
        //  call out-of-proc interface
        //

        unsigned char * pszStatusCode = NULL;
        DWORD           cbStatusCode = 0;

        //
        //  if send-headers flag is set, get status code from struct
        //

        if ( pHseTfi->dwFlags & HSE_IO_SEND_HEADERS ) {

            DBG_ASSERT( pHseTfi->pszStatusCode );

            pszStatusCode = (unsigned char *) pHseTfi->pszStatusCode;
            cbStatusCode = lstrlen( pHseTfi->pszStatusCode ) + 1;
        }

        HANDLE hCurrentUser = INVALID_HANDLE_VALUE;
        DoRevertHack( &hCurrentUser );

        fReturn = BoolFromHresult(
                    pIWamRequest->TransmitFileOutProc(
#ifdef _WIN64
                        (UINT64)            this
                        , (UINT64)          pHseTfi->hFile
#else
                        (ULONG_PTR)         this
                        , (ULONG_PTR)       pHseTfi->hFile
#endif
                        ,                   pszStatusCode
                        ,                   cbStatusCode
                        ,                   pHseTfi->BytesToWrite
                        ,                   pHseTfi->Offset
                        , (unsigned char *) pHseTfi->pHead
                        ,                   pHseTfi->HeadLength
                        , (unsigned char *) pHseTfi->pTail
                        ,                   pHseTfi->TailLength
                        ,                   pHseTfi->dwFlags
                    ) );
        
        UndoRevertHack( &hCurrentUser );

    }


    if ( !fReturn ) {

        UninitAsyncIO();
    }


    ReleaseIWamRequest( pIWamRequest );


    return fReturn;

} // WAM_EXEC_INFO::TransmitFile()




/*---------------------------------------------------------------------*
WAM_EXEC_INFO::AsyncReadClient

Description:

    This function performs an async read of client (browser) data
    on behalf of the ISA

Arguments:

    pvBuff - Data buffer to read into
    pcbToRead - Number of bytes to read, set to number of bytes read if
        request is not Async
    dwFlags - Receive flags

Notes:
    
    The initial design for AsyncRead was inadequate when the isapi is 
    running out of process. The problem was that the data buffer was
    marshalled over to inetinfo and back during the AsyncRead call.
    Since the completion will happen on another thread the ISAPI could
    get the completion before the data was completely marshalled back
    or the address in inetinfo could be invalidated before the read was
    complete. The solution is to add a separate path for oop async reads
    and marshall the data on the io completion and copy it into the
    client's buffer then.
    
Returns:

   TRUE on success and FALSE on failure

*/
BOOL
WAM_EXEC_INFO::AsyncReadClient(
    IN OUT PVOID    pvBuff
    , IN OUT DWORD *pcbToRead
    , IN DWORD      dwFlags
)
{
    BOOL    fReturn = FALSE;

    DBG_ASSERT( pvBuff );
    DBG_ASSERT( pcbToRead );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p)::AsyncReadClient\t"
              "Bytes to read = %d\n"
            , this
            , *pcbToRead
        ));
    }


    DBG_ASSERT( dwFlags & HSE_IO_ASYNC );

    //
    // It is unlikely that ISAPI applications will post
    //  multiple outstanding IOs. However we have the state
    //  _AsyncIoInfo._dwOutstandingIO to secure ourselves against such cases.
    // I have not used any critical sections to protect against
    //  multiple threads for performance reasons.
    // Today we support only Async IO transfers
    //


    if ( _AsyncIoInfo._dwOutstandingIO ||
         ((dwFlags & HSE_IO_ASYNC) == 0) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    if ( NULL == _AsyncIoInfo._pfnHseIO) {

        // No callback specified. return error
        SetLastError( ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // Setup stage for and execute AsyncReadClient operation
    //

    //
    // If callback function exists and flags indicate Async IO, do it.
    // Also there should be no outstanding Async IO operation.
    //

    if ( dwFlags & HSE_IO_ASYNC) {

        //
        //  1. Set Request state to be async IO from ISAPI client
        //  2. Submit Async IOP
        //  3. return to the ISAPI application
        //

        IWamRequest *  pIWamRequest = NULL;

        if ( FAILED( GetIWamRequest( &pIWamRequest ) ) ) {

            return FALSE;
        }


        InitAsyncIO( ASYNC_IO_TYPE_READ );

        if( m_fInProcess )
        {
            fReturn = BoolFromHresult( pIWamRequest->AsyncReadClientExt(
#ifdef _WIN64
                           (UINT64) this                 
#else
                           (ULONG_PTR) this                 
#endif
                           , (unsigned char *) pvBuff
                           , *pcbToRead
                       ) );
        }
        else
        {
            DBG_ASSERT( _AsyncIoInfo._pvAsyncReadBuffer == NULL );
            _AsyncIoInfo._pvAsyncReadBuffer = pvBuff;

            fReturn = BoolFromHresult( pIWamRequest->AsyncReadClientOop(
#ifdef _WIN64
                           (UINT64) this                 
#else
                           (ULONG_PTR) this                 
#endif
                           , *pcbToRead
                       ) );
            if( !fReturn )
            {
                _AsyncIoInfo._pvAsyncReadBuffer = NULL;
            }
        }

        ReleaseIWamRequest( pIWamRequest );


        if ( !fReturn ) {
            UninitAsyncIO();
        }

    } else {

        DBG_ASSERT( FALSE );

    }

    return ( fReturn);
} // WAM_EXEC_INFO::AsyncReadClient()




/*---------------------------------------------------------------------*
WAM_EXEC_INFO::ProcessAsyncIO

Description:

    Completes an async i/o by calling the ISA's i/o completion callback

Arguments:

Returns:
    BOOL

*/
BOOL
WAM_EXEC_INFO::ProcessAsyncIO(
    DWORD   dwStatus
    , DWORD   cbWritten
)
{

    DBG_ASSERT( _AsyncIoInfo._pfnHseIO );
    DBG_ASSERT( _AsyncIoInfo._dwOutstandingIO );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_EXEC_INFO[%p]::ProcessAsyncIO(IOStatus=%d, %d bytes)\n"
            , this, dwStatus, cbWritten
        ));
    }


    BOOL    fRet = TRUE;
    BOOL    fImpersonated = FALSE;
    DWORD   dwIOType = ASYNC_IO_TYPE_NONE;

    //
    // 1.
    //  We are in the return from an async io completion.
    //  We will be making a call into the ISAPI DLL to notify that
    //   the IO operation completed. 
    //  This callback has to occur within the bounds of ref/deref
    //   of the WAM_EXEC_INFO otherwise following race condition can occur:
    //  - isapi's completion function calls done-with-session;
    //    if that release got rid of last ref, this WAM_EXEC_INFO
    //    gets destroyed
    //  - isapi's completion function continues doing other work
    //  - an unrelated shutdown command comes in asynchronously
    //  - if isapi has no TerminateExtension (or a non-robust one),
    //    isapi gets summarily unloaded
    //  - any of a number of terrible things can happen
    //
    //  If you HAVE temptations to optimize this, 
    //    please first talk to MuraliK
    //
    AddRef();
    
    //
    // 2.
    //  Un-init async i/o - balances init we did before requesting i/o
    //
    //  NOTE we do this before calling the isapi's completion function
    //  Reasons:
    //    WAM_EXEC_INFO maintians state that an async IO operation is going on
    //    UninitAsyncIO resets this state and other associated ref-counts.
    //    This way we ensure that any further async IO callbacks made during
    //     the call to the ISAPI DLL will be honored properly.
    //

    // Only call this in success case.
    if (dwStatus == 0)
        {
        dwIOType = _AsyncIoInfo._dwOutstandingIO;
        UninitAsyncIO();
        }

    //
    // 3. 
    //  Impersonate before making ISAPI callback
    //
    
    if ( !m_pWam->FWin95() )
    {
        HANDLE hToken = _WamReqCore.m_WamReqCoreFixed.m_hUserToken;

        if ( !( fImpersonated = ImpersonateLoggedOnUser( hToken ) ) )
        {

            DBGPRINTF((DBG_CONTEXT,
                       "WAM_EXEC_INFO(%p) ImpersonateLoggedOnUser(%x)"
                       "failed[err %d]\n",
                       this, hToken, GetLastError()));

            fRet = FALSE;
        }

    }

    //
    //  4.
    //  call isapi if we are successful so far
    //

    if ( fRet ) {

        __try {

            //
            //  Adjust bytes written for async writes -
            //  otherwise filter adjusted bytes show up
            //  which confuses some ISAPI Applications
            //

            if ( dwIOType == ASYNC_IO_TYPE_WRITE
                 && dwStatus == ERROR_SUCCESS ) {

                cbWritten = _AsyncIoInfo._cbLastAsyncIO;

                _AsyncIoInfo._cbLastAsyncIO = 0;
            }


            //
            //  Make the ISAPI callback to indicate that the I/O completed
            //

            (*_AsyncIoInfo._pfnHseIO)(
                &ecb,
                _AsyncIoInfo._pvHseIOContext,
                cbWritten,
                dwStatus
            );

        }
        __except ( g_fEnableTryExcept ? 
                    WAMExceptionFilter( GetExceptionInformation(), 
                                        WAM_EVENT_EXTENSION_EXCEPTION,
                                        this ) :
                    EXCEPTION_CONTINUE_SEARCH )
        {
            fRet = FALSE;
        }

    }


    //
    // 5.
    //  Revert back if we were impersonated before making ISAPI DLL callback
    //

    if ( fImpersonated )
        {
        ::RevertToSelf( );
        fImpersonated = FALSE;
        }

    if (dwStatus != 0)
        {
        UninitAsyncIO();
        }
    //
    // Complimentary release for the AddRef() done in Step (1) above
    //
    Release();


    return fRet;

} // ProcessAsyncIO()

BOOL    
WAM_EXEC_INFO::ProcessAsyncReadOop
( 
    DWORD dwStatus, 
    DWORD cbRead,
    unsigned char * lpDataRead
)
/*++
    Routine Description:
        
        Handle callback for out of process AsyncRead

    Arguments:

        dwStatus    - IO status
        cbRead      - Number of bytes read
        lpDataRead  - Marshalled data read

    Return Value:

    Notes:

        The initial design for AsyncRead was inadequate when the isapi is 
        running out of process. The problem was that the data buffer was
        marshalled over to inetinfo and back during the AsyncRead call.
        Since the completion will happen on another thread the ISAPI could
        get the completion before the data was completely marshalled back
        or the address in inetinfo could be invalidated before the read was
        complete. The solution is to add a separate path for oop async reads
        and marshall the data on the io completion and copy it into the
        client's buffer then.

--*/
{
    DBG_ASSERT( !m_fInProcess );
    DBG_ASSERT( _AsyncIoInfo._pvAsyncReadBuffer != NULL );

    // Copy the marshalled data into the client's buffer.
    
    if( dwStatus == STATUS_SUCCESS )
    {
        //
        // Is there more we can do to protect this?
        //
        // We'd have problems anyway if the client's buffer wasn't large
        // enough to hold the data and cbRead should always be <= than the
        // size the client specified.
        //
        CopyMemory( _AsyncIoInfo._pvAsyncReadBuffer, lpDataRead, cbRead );
    }

    _AsyncIoInfo._pvAsyncReadBuffer = NULL;
    return ProcessAsyncIO( dwStatus, cbRead );
}



/*---------------------------------------------------------------------*
WAM_EXEC_INFO::InitAsyncIO
    Initilializes members before requesting async i/o

Arguments:
    None

Returns:
    Nothing

*/
VOID
WAM_EXEC_INFO::InitAsyncIO( DWORD dwIOType )
{

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p)::InitAsyncIO "
              "\n"
            , this
        ));

    }

    DBG_ASSERT( dwIOType == ASYNC_IO_TYPE_READ || dwIOType == ASYNC_IO_TYPE_WRITE );
    DBG_ASSERT( _AsyncIoInfo._dwOutstandingIO == ASYNC_IO_TYPE_NONE );
    DBG_ASSERT( _AsyncIoInfo._pfnHseIO != NULL);
    DBG_ASSERT( _AsyncIoInfo._pvAsyncReadBuffer == NULL );


    AddRef();
    _AsyncIoInfo._dwOutstandingIO = dwIOType;
}




/*---------------------------------------------------------------------*
WAM_EXEC_INFO::UninitAsyncIO
    Un-initilializes members before completing async i/o

Arguments:
    None

Returns:
    Nothing

*/
VOID
WAM_EXEC_INFO::UninitAsyncIO()
{

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p)::UninitAsyncIO "
              "\n"
            , this
        ));

    }


    _AsyncIoInfo._dwOutstandingIO = ASYNC_IO_TYPE_NONE;
    Release();

}


/*---------------------------------------------------------------------*
WAM_EXEC_INFO::IsValid
    Is this a valid object?
    
Arguments:
    None

Returns:
    BOOL
    
*/
BOOL
WAM_EXEC_INFO::IsValid( )
{
    //
    // CONSIDER more thorough error checking
    //
    return (m_dwSignature == WAM_EXEC_INFO_SIGNATURE);    
}


/*---------------------------------------------------------------------*
WAM_EXEC_INFO::AddRef
    Add refs

Arguments:
    None

Returns:
    Ref count

*/
ULONG
WAM_EXEC_INFO::AddRef( )
{

    IF_DEBUG( WAM_REFCOUNTS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p) AddRef : %d -> %d\n"
            ,  this
            , _cRefs
            , _cRefs + 1
        ));
    }


    LONG cRefs = InterlockedIncrement( &_cRefs );


#if DBG

    //
    // Write to both this request's trace log and global trace log
    //

    if( m_pDbgRefTraceLog != NULL ) {

        WriteRefTraceLog(
            m_pDbgRefTraceLog
            , cRefs
            , (PVOID) this
        );
    }

    if( sm_pDbgRefTraceLog != NULL ) {

        WriteRefTraceLog(
            sm_pDbgRefTraceLog
            , cRefs
            , (PVOID) this
        );
    }

#endif

    return cRefs;

}




/*---------------------------------------------------------------------*
WAM_EXEC_INFO::CleanupAndRelease

Description:
    Calls wamreq's (prep)cleanup, then releases this wamexecinfo.

Arguments:
    None

Returns:
    Nothing

*/
void
WAM_EXEC_INFO::CleanupAndRelease(
    BOOL    fFullCleanup
)
{

    //
    //  Prep wamreq's cleanup
    //
    //  This method should only be called from the IIS thread
    //

    DBG_ASSERT( m_dwThreadIdIIS == GetCurrentThreadId() );

    //
    //  While on IIS thread m_pIWamReqIIS must be a valid pointer
    //

    DBG_ASSERT( m_pIWamReqIIS );

    //
    //  The skip wamreq cleanup is only set by ASP after returning
    //  a status pending
    //

    //
    //  init hr's to failure - these will drive cleanup logic below,
    //  but only if calls are successful
    //

    HRESULT         hrCoInitEx = E_FAIL;
    HRESULT         hrGetIWamReq = E_FAIL;
    IWamRequest *   pIWamRequest = NULL;


    if ( m_fInProcess ) {

        //
        //  inproc case, use our cached ptr.

        pIWamRequest = m_pIWamReqIIS;

    } else {


        //
        //  in oop case,
        //  an isapi might have changed the thread's mode on us
        //  (for example, by coinit'ing single-threaded).
        //  if so, we need to get an interface pointer from gip,
        //  since our cached ptr will no longer be valid.
        //
        //  NOTE we test this by calling coinit, which is cheap.
        //  if this succeeds, we plough ahead with our cached ptr.
        //  else if mode changed, we get an interface ptr from gip.
        //

        hrCoInitEx = CoInitializeEx(NULL, COINIT_MULTITHREADED);


        if ( hrCoInitEx == RPC_E_CHANGED_MODE ) {

            hrGetIWamReq = GetIWamRequest( &pIWamRequest );

        } else {

            //
            //  NOTE in most cases we are here because we succeeded
            //  in others we forge ahead and hope for the best ...
            //  at any rate, we cannot be worse off than before
            //  we added the above co-init call
            //

            pIWamRequest = m_pIWamReqIIS;

        }


    }



    if ( pIWamRequest != NULL ) {

        HANDLE hCurrentUser = m_fInProcess ? NULL : INVALID_HANDLE_VALUE;
        DoRevertHack( &hCurrentUser );

        if ( fFullCleanup ) {

            //
            //  we are doing full cleanup
            //

            pIWamRequest->CleanupWamRequest(
                (unsigned char*) ecb.lpszLogData
                , lstrlen( ecb.lpszLogData ) + 1
                , ecb.dwHttpStatusCode
                , _dwIsaKeepConn
            );

        } else {

            //
            //  we are not doing full cleanup, so call 'Prep' only
            //

            pIWamRequest->PrepCleanupWamRequest(
                (unsigned char*) ecb.lpszLogData
                , lstrlen( ecb.lpszLogData ) + 1
                , ecb.dwHttpStatusCode
                , _dwIsaKeepConn
            );

        }

        UndoRevertHack( &hCurrentUser );
    }


    //
    //  if we got a ptr from gip, release it
    //

    if ( SUCCEEDED( hrGetIWamReq ) ) {
    
        ReleaseIWamRequest( pIWamRequest );
    }
        

    //
    //  if we co-init'ed, co-uninit
    //

    if ( hrCoInitEx == S_OK ) {
    
        CoUninitialize( );
    }
        

    //
    //  Release this
    //

    Release( );


    return;

} // CleanupAndRelease




/*---------------------------------------------------------------------*
WAM_EXEC_INFO::Release
    Releases

Arguments:
    None

Returns:
    Ref count

*/
ULONG
WAM_EXEC_INFO::Release(
)

{

    IF_DEBUG( WAM_REFCOUNTS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p) Release: %d -> %d\n"
            , this
            , _cRefs
            , _cRefs-1
        ));

    }


    //
    // Write the trace log BEFORE the decrement operation :(
    // If we write it after the decrement, we will run into potential
    // race conditions in this object getting freed up accidentally
    // by another thread
    //

#if DBG

    //
    // Write to both this request's trace log and global trace log
    //

    if( m_pDbgRefTraceLog != NULL ) {

        WriteRefTraceLog(
            m_pDbgRefTraceLog
            , _cRefs - 1   // ref count AFTER decrement happens
            , (PVOID) this
        );
    }

    if( sm_pDbgRefTraceLog != NULL ) {

        WriteRefTraceLog(
            sm_pDbgRefTraceLog
            , _cRefs - 1   // ref count AFTER decrement happens
            , (PVOID) this
        );
    }

#endif


    LONG cRefs = InterlockedDecrement( &_cRefs );


    if( cRefs == 0) {

        IF_DEBUG( WAM_REFCOUNTS ) {

            DBGPRINTF(( DBG_CONTEXT, "... dying ...\n\n" ));
        }


        CleanupWamExecInfo( );

        //
        //  Finally, delete ourselves.
        //

        delete this;
        return 0;

    }

    return cRefs;
}




/*---------------------------------------------------------------------*
WAM_EXEC_INFO::CleanupWamExecInfo
    Cleans up this object prior to its destruction

Arguments:
    None

Returns:
    Nothing

*/
VOID
WAM_EXEC_INFO::CleanupWamExecInfo(
)

{

    //
    // remove this from its list
    //

    m_pWam->RemoveFromList( &_ListEntry);


    if ( !m_fInProcess & !(m_pWam->FWin95()) ) {

        //
        //  If oop, close the impersonation token
        //  (dup'ed in w3svc!HGetOopImpersonationToken)
        //
        //  NOTE ignore if in-proc or win95 because we never dup'ed
        //  handle in the first place
        //

        DBG_ASSERT( _WamReqCore.m_WamReqCoreFixed.m_hUserToken
                    != (HANDLE)0 );

        CloseHandle( _WamReqCore.m_WamReqCoreFixed.m_hUserToken );
        _WamReqCore.m_WamReqCoreFixed.m_hUserToken = (HANDLE)0;
    }

    if ( _psExtension != NULL) {
        // release the extension object
        g_psextensions->ReleaseExtension( _psExtension);
        _psExtension = NULL;
    }


    DBG_ASSERT( QueryPWam());
    QueryPWam()->QueryWamStats().DecrCurrentWamRequests();


    CleanupWamExecBase();


    return;

} // WAM_EXEC_INFO::CleanupWamExecInfo




/*---------------------------------------------------------------------*
WAM_EXEC_INFO::ISAThreadNotify
    Notifies WAM_EXEC_BASE that an ISAPI thread is about to
    start/stop using it. Allows to cache IWamRequest* in the
    OOP case.

    NOTE this method is on WAM_EXEC_INFO (rather than WAM_EXEC_BASE)
    because it must addref and release.

Arguments:
    fStart      thread start (TRUE) / thread end (FALSE)

Returns:
    HRESULT

*/
HRESULT
WAM_EXEC_INFO::ISAThreadNotify(
    BOOL fStart
)
{

    if ( m_fInProcess ) {

        //
        //  In-proc: no-op
        //

        return NOERROR;

    }

    IF_DEBUG( WAM_THREADID ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p)::ISAThreadNotify(%d) Thread(%d)\n"
            , this
            , fStart
            , GetCurrentThreadId()
        ));
    }

    HRESULT hr = NOERROR;

    if ( fStart ) {

        //
        //  Out-of-proc: when starting the ISA's single-thread
        //  sequence, cache ISA-thread ptr we get from gip-master.
        //

        if ( SUCCEEDED( hr = GetInterfaceForThread( ) ) ) {

            AddRef();
        }

        DBG_ASSERT( AssertSmartISAValid() || (hr != NOERROR) );


    } else {

        //
        //  Out-of-proc: when ending the ISA's single-thread
        //  sequence, release ISA-thread ptr
        //

        hr = ReleaseInterfaceForThread( );

        Release();

    }

    return hr;

} // WAM_EXEC_INFO::ISAThreadNotify


/*---------------------------------------------------------------------*
    Debug methods

*/

#if DBG

VOID
WAM_EXEC_INFO::Print( VOID) const
{

    DBGPRINTF((
        DBG_CONTEXT
        , "WAM_EXEC_INFO(%p): Method: %s; Query: %s;\n"
          "PathInfo: %s; PathTrans: %s; ContentType: %s;\n"
          "URL: %s; ISA DLL path: %s;\n"
          "In-Proc = %d; m_pIWamReqInproc = %p; "
          "m_gipIWamRequest = %p; m_pIWamReqSmartISA = %p\n"
          "Flags = %x; ChildExecFlags = %x; RefCount = %d\n"
          "Extension = %p; OutstandingIO = %d; "
          "IoCompletion() = %p; IoContext = %p\n"
        , this
        , _WamReqCore.GetSz( WRC_I_METHOD )
        , _WamReqCore.GetSz( WRC_I_QUERY )
        , _WamReqCore.GetSz( WRC_I_PATHINFO )
        , _WamReqCore.GetSz( WRC_I_PATHTRANS )
        , _WamReqCore.GetSz( WRC_I_CONTENTTYPE )
        , _WamReqCore.GetSz( WRC_I_URL )
        , _WamReqCore.GetSz( WRC_I_ISADLLPATH )
        , m_fInProcess
        , m_pIWamReqInproc
        , m_gipIWamRequest
        , m_pIWamReqSmartISA
        , _dwFlags
        , _dwChildExecFlags
        , _cRefs
        , _psExtension
        , _AsyncIoInfo._dwOutstandingIO
        , _AsyncIoInfo._pfnHseIO
        , _AsyncIoInfo._pvHseIOContext
    ));

    return;
} // WAM_EXEC_INFO::Print()

#else

VOID    WAM_EXEC_INFO::Print( VOID) const   {   }

#endif  //DBG



#if DBG

void
DbgWamreqRefcounts
(
char*                   szPrefix,
WAM_EXEC_INFO *         pWamExecInfo,
long                    cRefsWamRequest,
long                    cRefsWamReqContext
)
{

    IWamRequest *   pIWamRequest = NULL;
    pWamExecInfo->GetIWamRequest( &pIWamRequest );
    DBG_ASSERT( pIWamRequest );

    IF_DEBUG( WAM_REFCOUNTS ) {
        DBGPRINTF(( DBG_CONTEXT, szPrefix ));
        DBGPRINTF(( DBG_CONTEXT, "\n" ));
    }

    HANDLE hCurrentUser = pWamExecInfo->FInProcess() ? NULL : INVALID_HANDLE_VALUE;
    DoRevertHack( &hCurrentUser );
    
    if( cRefsWamRequest != -1) {

        DBG_ASSERT( cRefsWamRequest
                    == (long) pIWamRequest->DbgRefCount() );
    }

    if( cRefsWamReqContext != -1) {
        DBG_ASSERT( cRefsWamReqContext
                    == (long) pWamExecInfo->DbgRefCount() );
    }

    IF_DEBUG( WAM_REFCOUNTS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "IWamRequest(%p): RefCount = %d\n"
            , pIWamRequest
            , pIWamRequest->DbgRefCount()
        ));

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_EXEC_INFO(%p): RefCount = %d\n"
            , pWamExecInfo, pWamExecInfo->DbgRefCount()
        ));

    }

    UndoRevertHack( &hCurrentUser );

    pWamExecInfo->ReleaseIWamRequest( pIWamRequest );

}   // WAM_EXEC_INFO::DbgWamreqRefcounts
#endif  // DBG


/************************************************************
 *  Static Member Functions of WAM_EXEC_INFO
 ************************************************************/


BOOL
WAM_EXEC_INFO::InitClass( VOID)
{
    HRESULT hr;
    
    ALLOC_CACHE_CONFIGURATION acConfig = {
        1
        , WAM_EXEC_INFO_CACHE_THRESHOLD
        , sizeof(WAM_EXEC_INFO)
    };

    if ( NULL != sm_pachExecInfo) {

        // already initialized
        return ( TRUE );
    }

    hr = g_GIPAPI.Init();
    if( FAILED( hr ) ) {
        DBGPRINTF( (DBG_CONTEXT, "GIPAPI::Init Failed: %8.8x\n", hr) );
        return ( FALSE );
    }

    sm_pachExecInfo = new ALLOC_CACHE_HANDLER( "WamExecInfo",
                                                 &acConfig);

#if DBG
    sm_pDbgRefTraceLog = CreateRefTraceLog( C_REFTRACES_GLOBAL, 0 );
#endif

    return ( NULL != sm_pachExecInfo);
} // WAM_EXEC_INFO::InitClass()


VOID
WAM_EXEC_INFO::CleanupClass( VOID)
{
    HRESULT hr;

    hr = g_GIPAPI.UnInit();
    
    if( FAILED( hr ) ) {
        DBGPRINTF( (DBG_CONTEXT, "GIPAPI::UnInit returned %8.8x\n", hr ) );
    }

    if ( NULL != sm_pachExecInfo) {

        delete sm_pachExecInfo;
        sm_pachExecInfo = NULL;
    }

#if DBG
    DestroyRefTraceLog( sm_pDbgRefTraceLog );
#endif

    return;
} // WAM_EXEC_INFO::CleanupClass()


void *
WAM_EXEC_INFO::operator new( size_t s)
{
    DBG_ASSERT( s == sizeof( WAM_EXEC_INFO));

    // allocate from allocation cache.
    DBG_ASSERT( NULL != sm_pachExecInfo);
    return (sm_pachExecInfo->Alloc());
} // WAM_EXEC_INFO::operator new()

void
WAM_EXEC_INFO::operator delete( void * psi)
{
    DBG_ASSERT( NULL != psi);

    // free to the allocation pool
    DBG_ASSERT( NULL != sm_pachExecInfo);
    DBG_REQUIRE( sm_pachExecInfo->Free(psi));

    return;
} // WAM_EXEC_INFO::operator delete()



/************************ End of File *********************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\wreqcore.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
      WReqCore.cxx

   Abstract:
      Wamreq core implementation

   Author:
       David Kaplan    ( DaveK )    1-Apr-1997 (no kidding)

   Environment:
       User Mode - Win32

   Projects:
       W3svc DLL, Wam DLL

   Revision History:

--*/

/************************************************************
 *     Include Headers
 ************************************************************/
# include "isapip.hxx"
# include "WReqCore.hxx"
// MIDL-generated
# include "iwr.h"

#include <svmap.h>



/*-----------------------------------------------------------------------------*
WAM_REQ_CORE::WAM_REQ_CORE
    Constructor

Arguments:
    None    

Returns:
    Nothing

*/
WAM_REQ_CORE::WAM_REQ_CORE( )
:
  m_pbWrcData       ( NULL ),
  m_rgcbOffsets     ( NULL ),
  m_rgcchStrings    ( NULL ),
  m_pbEntityBody    ( NULL ),
  m_pbSVData        ( NULL ),
  m_rgSVOffsets     ( NULL )
{
}


/*-----------------------------------------------------------------------------*
WAM_REQ_CORE::~WAM_REQ_CORE
    Destructor

Arguments:
    None    

Returns:
    Nothing

*/
WAM_REQ_CORE::~WAM_REQ_CORE()
{

    if ( m_pbWrcData != m_pbWrcDataInit ) {

        //
        //  if we allocated, now delete
        //

        delete [] m_pbWrcData;
    }

    // Temporarily use a separate buffer.
    delete [] m_pbSVData;
    delete [] m_rgSVOffsets;

}


/*-----------------------------------------------------------------------------*
WAM_REQ_CORE::InitWamReqCore
    Initializes WAM_REQ_CORE structure

Arguments:
    

Returns:
    HRESULT

*/
HRESULT
WAM_REQ_CORE::InitWamReqCore
(
DWORD               cbWrcStrings,
IWamRequest *       pIWamRequest,
OOP_CORE_STATE *    pOopCoreState,
BOOL                fInProcess
)
    {
    HRESULT hr = NOERROR;


    DBG_ASSERT( cbWrcStrings > 0 );
    DBG_ASSERT( pIWamRequest );

    // One of these had better be true
    DBG_ASSERT( fInProcess || pOopCoreState );

    // Allocate our internal buffer if necessary
    if ( cbWrcStrings <= CB_WRC_STRINGS_INIT ) {

        //
        //  if pre-allocated array is large enough, use it
        //

        m_pbWrcData = m_pbWrcDataInit;

        IF_DEBUG( WAM_FILENAMES ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "Pre-allocated array is large enough: cbWrcStrings(%d)\n"
                , cbWrcStrings
            ));

        }

    } else {

        IF_DEBUG( WAM_FILENAMES ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "Pre-allocated array is too small: cbWrcStrings(%d)\n"
                , cbWrcStrings
            ));

        }

        //
        //  if pre-allocated array is too small, allocate
        //

        m_pbWrcData = new unsigned char[
                            WRC_CB_FIXED_ARRAYS + cbWrcStrings
                        ];

        if ( m_pbWrcData == NULL ) {

            hr = E_OUTOFMEMORY;
            goto LExit;
        }

    }

    // Allocate our server variable cache
    if( !fInProcess )
    {
        m_rgSVOffsets = new DWORD[ SVID_COUNT ];
        if( !m_rgSVOffsets )
        {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }

        FillMemory( m_rgSVOffsets, 
                    SVID_COUNT * sizeof(DWORD), 
                    SV_DATA_INVALID_OFFSET 
                    );
    }

    // Get the core state data into our internal buffers
    
    if( !fInProcess && pOopCoreState )
    {
        DBG_ASSERT( pOopCoreState != NULL );
        DBG_ASSERT( (WRC_CB_FIXED_ARRAYS + cbWrcStrings) == pOopCoreState->cbCoreState );
        
        // Out of process, the core state is pushed so pOopCoreState
        // contains the data. We just need to take ownership

        CopyMemory( m_pbWrcData, 
                    pOopCoreState->pbCoreState, 
                    pOopCoreState->cbCoreState 
                    );

        DBG_ASSERT( sizeof( WAM_REQ_CORE_FIXED ) == pOopCoreState->cbFixedCore );
        CopyMemory( &m_WamReqCoreFixed,
                    pOopCoreState->pbFixedCore,
                    sizeof( WAM_REQ_CORE_FIXED )
                    );

        // Now init the server variable cache
        
        if( pOopCoreState->cbServerVarData )
        {
            m_pbSVData = new unsigned char[ pOopCoreState->cbServerVarData ];

            if( m_pbSVData == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto LExit;
            }

            CopyMemory( m_pbSVData,
                        pOopCoreState->pbServerVarData,
                        pOopCoreState->cbServerVarData
                        );
            
            DBG_ASSERT( pOopCoreState->pbServerVarCache != NULL );
            DBG_ASSERT( pOopCoreState->cbServerVars > 0 );

            DWORD cServerVars = pOopCoreState->cbServerVars / 
                                sizeof( SV_CACHE_LIST::BUFFER_ITEM );

            DBG_ASSERT( cServerVars > 0 );
            
            SV_CACHE_LIST::BUFFER_ITEM * pBufferItems = 
                    ( SV_CACHE_LIST::BUFFER_ITEM * )pOopCoreState->pbServerVarCache;


            for( DWORD i = 0; i < cServerVars; ++i )
            {
                m_rgSVOffsets[pBufferItems[i].svid] = pBufferItems[i].dwOffset;
            }
        }

    }
    else
    {
        DBG_ASSERT( fInProcess );
        DBG_ASSERT( pOopCoreState == NULL );

        IF_DEBUG( BGI )
            {
            DBGPRINTF(( DBG_CONTEXT, "About to make a call to %08x::GetCoreState( %d, %08x, %d, %08x)\n"
                                     "In-proc: %d \n",
                                                pIWamRequest,
                                                WRC_CB_FIXED_ARRAYS + cbWrcStrings,
                                                m_pbWrcData,
                                                sizeof( WAM_REQ_CORE_FIXED ),
                           (unsigned char *)    &m_WamReqCoreFixed,
                                                fInProcess ));
            }

        /*  
            Get core state from wamreq
            NOTE wamreq allocates space for 2 fixed-length dword arrays plus strings
            sync WRC_DATA_LAYOUT

        */

        if( FAILED( hr = pIWamRequest->GetCoreState(
                                WRC_CB_FIXED_ARRAYS + cbWrcStrings,
                                m_pbWrcData,
                                sizeof( WAM_REQ_CORE_FIXED ),
                                (unsigned char *) &m_WamReqCoreFixed
                                ) ) )
            {
            goto LExit;
            }

        IF_DEBUG( BGI )
            {
            DBGPRINTF(( DBG_CONTEXT, "Just got back from GetCoreState ... it musta worked ... \n" ));
            }

    }

    // NOTE offsets to strings are stored at start of data buffer
    // NOTE string lengths are stored immediately after offsets in data buffer

    /* sync WRC_DATA_LAYOUT */
    m_rgcbOffsets = (DWORD *) m_pbWrcData;
    m_rgcchStrings = ((DWORD *) (m_pbWrcData)) + WRC_C_STRINGS;

    if( m_WamReqCoreFixed.m_cbEntityBody > 0 )
        {

        if( fInProcess )
            {
            // in-proc we set entity-body ptr directly from wamreq
            if( FAILED( hr = pIWamRequest->QueryEntityBody( &m_pbEntityBody ) ) )
                {
                goto LExit;;
                }
            }
        else
            {
            // out-of-proc we already got entity-body in our strings array
            m_pbEntityBody = (BYTE *) GetSz( WRC_I_ENTITYBODY );
            }

        DBG_ASSERT( m_pbEntityBody );
        
        }

LExit:
    return hr;

    }



/*-----------------------------------------------------------------------------*
WAM_REQ_CORE::GetSz
    Returns a ptr to the requested string

Arguments:
    iString -   index of requested string

Returns:
    ptr to requested string

*/
char *
WAM_REQ_CORE::GetSz( DWORD iString ) const
    {
    DBG_ASSERT( iString < WRC_C_STRINGS );
    DBG_ASSERT( m_pbWrcData );
    DBG_ASSERT( m_rgcbOffsets );
    
    return (char *) ( m_pbWrcData + m_rgcbOffsets[ iString ] );
    }



/*-----------------------------------------------------------------------------*
WAM_REQ_CORE::GetCch
    Returns length of the requested string

Arguments:
    iString -   index of requested string

Returns:
    length of requested string

*/
DWORD
WAM_REQ_CORE::GetCch( DWORD iString ) const
    {
    DBG_ASSERT( iString < WRC_C_STRINGS );
    DBG_ASSERT( m_pbWrcData );
    DBG_ASSERT( m_rgcchStrings );

    return (DWORD) ( m_rgcchStrings[ iString ] );
    }



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\clients\main.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Main module

Author:

    Stanle Tam (stanleyt)   4-June 1997
    
Revision History:
  
--*/
# include   <windows.h>
# include   <stdio.h>

BOOL    
ParseArguments(INT argc, 
               char *argv[], 
               UINT *TestType);

BOOL    
ProcessArguments(const UINT TestType);

void    
ShowUsage();

extern BOOL    
StartClients();

extern void    
TerminateClients();


BOOL __cdecl main(int argc,char *argv[])
{
    UINT TestType = 0;
    BOOL fReturn = TRUE;

    if (FALSE == ParseArguments(argc, argv, &TestType)) {
        ShowUsage();
        fReturn = FALSE;

    } else if (FALSE == ProcessArguments(TestType)) {
        fReturn = FALSE;
    
    } else if (FALSE == StartClients()) {
        fReturn = FALSE;
    }

    TerminateClients();

    return fReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\bfwrite\bfwrite.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bfwrite.c

Abstract:

    A simple file transfer ISAPI application using the WriteClient() callback.
    
    Query string contains the number of bytes that will be sent. 10K bytes is
    by default if no query string is specified.

Author:

    Stanley Tam ( stanleyt)   12-May-1997

Revision History:
--*/

#include <windows.h>
#include <iisext.h>
#include <stdlib.h>

const DWORD DEFAULT_BYTES_SEND = 10 * 1024;    // 10K


DWORD
SendHeaderToClient(IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg);

DWORD
SendByteToClient(IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszByteSend);

DWORD
SendByteOver(IN EXTENSION_CONTROL_BLOCK  * pecb, IN DWORD * BufferLength);


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason) {

    case DLL_PROCESS_ATTACH:
      {
          OutputDebugString("Initializing the global data\n");

          //
          // Initialize various data and modules.
          //
          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return (fReturn);
}  /* DllLibMain() */




DWORD WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    DWORD hseStatus;

    hseStatus = SendByteToClient(pecb, pecb->lpszQueryString);
    
    return (hseStatus);
    
} // HttpExtensionProc()




BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
           "File Transfer using WriteClient" );
    
    return TRUE;
}




DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg)
{
    
    CHAR buff[600];
    
    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //
    
    wsprintf(buff,
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Simple File Transfer (Write) </title></head>\n"
             "<body><h1>%s</h1>\n"
             ,
             pszErrorMsg);
    
    if (!pecb->ServerSupportFunction( pecb->ConnID,
                                      HSE_REQ_SEND_RESPONSE_HEADER,
                                      "200 OK",
                                      NULL,
                                      (LPDWORD) buff )
        ) {
        
        return HSE_STATUS_ERROR;
    }
    
    return (HSE_STATUS_SUCCESS);
} // SendHeaderToClient()
    

#define MAX_BUFFER_SIZE (1024)

DWORD
SendByteToClient(IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszByteSend)
{
    CHAR    pchBuffer[MAX_BUFFER_SIZE] = "";
    DWORD   Counter = 0;
    DWORD   TotalBytesSent = 0;
    DWORD   BufferLength = 0;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;


    hseStatus = SendHeaderToClient(pecb, pchBuffer);

    if (hseStatus == HSE_STATUS_SUCCESS) { 

	if (0 == strcmp(pszByteSend, "")) {
            BufferLength = DEFAULT_BYTES_SEND;
        } else {
            BufferLength = atoi(pszByteSend);
        }
   
        //
        // On enter, expected length of buffer is sent
        // On exit, actual length of buffer is returned
        //
        
        hseStatus = SendByteOver(pecb, &BufferLength);
            
        if (hseStatus != HSE_STATUS_SUCCESS) {

            //
            // Error in transmitting the file. Send error message.
            //
                    
            wsprintfA(pchBuffer, 
                "WriteClient failed to send %s byte(s). Actually sent %d byte(s): Error (%d).\n",
                pszByteSend,
                BufferLength, 
                GetLastError());
                    
            SendHeaderToClient(pecb, pchBuffer);
        }
    }
         
    return (hseStatus);

} // SendFileToClient()





DWORD
SendByteOver(IN EXTENSION_CONTROL_BLOCK  * pecb, IN DWORD *BufferLength)
{
    BYTE    *SendBuffer;
    DWORD   TotalBytesSent = 0;
    DWORD   TotalLength = *BufferLength;
    DWORD   ChunkLength = TotalLength;
    DWORD   Counter = 0;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    DWORD   i, j, SendNum;

    const DWORD MAX_CHUNK_SIZE = 900000;

    SendBuffer = LocalAlloc(0, TotalLength);

    if (NULL == SendBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        hseStatus = HSE_STATUS_ERROR;
    }

    //
    // If the BufferLength is bigger than the maximum number of bytes
    // can be sent at once (in-proc max is 900000, out-of-proc max is 999999)
    // the whole buffer is split up into chunks and each chunk is sent 
    // one at a time.
    //
    
    SendNum = (TotalLength % MAX_CHUNK_SIZE) + 1;

    if (SendNum > 0 && TotalLength >= MAX_CHUNK_SIZE) {
        ChunkLength = MAX_CHUNK_SIZE;
    } 

    for (i=0; i<SendNum; i++) {
        
        for (j=0; j<ChunkLength; j++) {
            SendBuffer[j] = ((BYTE) (Counter % 10)) + '0';
            Counter ++;
        }

        if (!pecb->WriteClient(pecb->ConnID, SendBuffer, &ChunkLength, HSE_IO_SYNC)) {
            hseStatus = HSE_STATUS_ERROR;
        }

        TotalBytesSent += ChunkLength;
        ChunkLength = TotalLength - TotalBytesSent ;
    } 

    // 
    // return actual number of bytes sent
    //

    *BufferLength = TotalLength;

    LocalFree(SendBuffer);
    
    return (hseStatus);

} // SendByteOver()




BOOL WINAPI
TerminateExtension( IN DWORD dwFlags)
/*++
  TerminateExtension()
  o  Standard Entry point called by IIS as the last function.
      It is called to request the unload of the ISAPI dll.
      
  Arugments:
    dwFlags - DWORD flags indicating the state of the unload.

  Returns:
    TRUE on success -> means that the DLL can be unloaded
    and FALSE if the DLL should not be unloaded yet.
--*/
{

    return ( TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\clients\client.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    client.h

Abstract:

    Client for pumping bytes

Author:

    Stanle Tam (stanleyt)   4-June 1997
    
Revision History:
  
--*/
#ifndef     _CLIENT_H_
#define     _CLIENT_H_

# include   <windows.h>
# include   <stdio.h>
# include   <stdlib.h>
# include   <tchar.h>
# include   <wininet.h>
# include   <assert.h>

#define     MAX_DATA_LENGTH         1024
#define     MAX_THREADS             10

static      DWORD dwDefaultFlag =   INTERNET_FLAG_RELOAD| \
                                    INTERNET_FLAG_IGNORE_CERT_CN_INVALID| \
                                    INTERNET_FLAG_NO_CACHE_WRITE;

//
//          Test app stuff
//
BOOL        g_fEatMemory = FALSE;
DWORD       g_nThread = 0;              
DWORD       g_cLoop =   1;              // default = 1
TCHAR       g_szTestType[256] = {0};
HANDLE      g_rghThreads[MAX_THREADS];


//
//          Read/Write Client's variables
//
TCHAR       g_szByteCount[100] = {0};
DWORD       g_cbSendRequestLength = 0;

//
//          wininet stuff
//
TCHAR       g_szVerb[10]=_T("GET");
TCHAR       g_szObject[INTERNET_MAX_URL_LENGTH + 1] = {0}; 
TCHAR       g_szVrPath[INTERNET_MAX_PATH_LENGTH + 1] = {0};
TCHAR	    g_szServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1] = {0};
TCHAR       g_szFileName[256] = {0};
TCHAR       g_szRequestString[1000] = {0};
BYTE        g_szSendRequestData[MAX_DATA_LENGTH] = {0};

typedef     enum { 
                    // Sync calls         
            RC,     // Sync ReadClient
            WC,     // Sync WriteClient
                    // Async calls
            ARC,    // Async ReadClient
            AWC,    // Async WriteClient        
            TF,     // TransmitFile
            SSF,    // ServerSupportFunction

            BAD
} TESTTYPE;	    // probably more ..

static      TCHAR *rgTestType[] = {
            "RC",        
            "WC",
            "ARC",        
            "AWC",
            "TF",
            "SSF",
            
            "bad_type"
};


//      client.c
BOOL    WINAPI SendData(UINT uThreadID);
BOOL    SendRequest(UINT uThreadID);
BOOL    StartClients(void);
void    TerminateClients(void);
BOOL    CreateReadInternetFile(const UINT  uThreadID,const char* szReadFileBuf,const DWORD cbReadFileByte);
void    FixFileName(char *argv);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\areadcli\areadcli.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    AReadCli.c

Abstract:

    This module demonstrates using asynchronous ReadClient call
    to read data sent from client. On return, this sends the 
    followings back to client:
    
    1) the number of bytes intended to send
    2) the number of bytes actually read.
    3) data content 

Author:

    Stanley Tam (stanleyt)   4-June 1997
    
Revision History:
  
--*/
#include <windows.h>
//#include <httpext.h>
#include <stdio.h>
#include <iisext.h>


#define MAX_BUF_SIZE        (49152)                 // Max number of bytes for each read - 48K
#define MEM_ALLOC_THRESHOLD (1024 * 1024)           // Default heap size is 1M


typedef struct _IO_WORK_ITEM {

    PBYTE                       pbDATAFromClient;   // Grand read data holder
    DWORD                       cbReadSoFar;        // Number of bytes read so far, 
                                                    // and is used as index for pbDATAFromClient
    EXTENSION_CONTROL_BLOCK *   pecb;

}  IO_WORK_ITEM, * PIOWI;


//
//  Sample Form for doing a POST method
//

static CHAR             g_szPostForm[] =
                        "<h2>Asychronous ReadClient Sample Post Form</h2><p>\r\n\r\n"
                        "This demonstrates a post request being sent by this form to the sample ISAPI - AReadCli.dll<p>\r\n\r\n"
                        "AReadCli.dll reads data posted by this form and send it back to the browser.<p>\r\n"
                        "<h3>Post Form</h3>\r\n"
                        "Please enter data below:<br>\r\n"
                        "<form method=POST action=\"areadcli.dll\">\r\n"
                        "<textarea name=\"Data\" cols=48 rows=4></textarea>\r\n\r\n"
                        "<input type=submit> <input type=reset>\r\n"
                        "</form>";

//
//  Report read data
//

static CHAR             g_szReport[] = 
                        "Bytes count including \"Data=\"  \r\n"
                        "ECB Total Bytes:    %d.\r\n"
                        "Actual Read Bytes:  %d.\r\n";
                
DWORD
DoInit(IN OUT PIOWI piowi);

VOID
DoCleanUp(IN PIOWI piowi);

DWORD
DoAsyncReadClient(IN PIOWI piowi);
             
VOID WINAPI
AsyncReadClientIoCompletion(IN LPEXTENSION_CONTROL_BLOCK pecb, 
                            IN PVOID pContext,
                            IN DWORD cbIO,
                            IN DWORD dwError);

DWORD
SendMSGToClient(IN LPEXTENSION_CONTROL_BLOCK pecb, 
                IN LPCSTR pszErrorMsg);

LPVOID 
AR_Allocate(IN LPEXTENSION_CONTROL_BLOCK pecb, IN DWORD dwSize);

BOOL 
AR_Free(IN LPEXTENSION_CONTROL_BLOCK pecb, IN LPVOID pvData);



DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 fReturn Value:

    fReturns TRUE if successful; otherwise FALSE is fReturned.

--*/
{
  BOOL    fReturn = TRUE;


  switch ( fdwReason) {

    case DLL_PROCESS_ATTACH:
      {
          OutputDebugString( "Initializing the global data for areadcli.dll\n");

          //
          // Prevent the system from calling DllMain
          // when threads are created or destroyed.
          //

          DisableThreadLibraryCalls( hinstDll);

          //
          // Initialize various data and modules.
          //

          break;

      } // case DLL_PROCESS_ATTACH

    case DLL_PROCESS_DETACH:
      {

          if ( lpvContext != NULL) { }

          break;
      } // case DLL_PROCESS_DETACH

    default:
      break;
  }   // switch

  return (fReturn);
}  // DllLibMain()




BOOL WINAPI
GetExtensionVersion(HSE_VERSION_INFO * Version)
/*++

Routine Description:

    Sets the ISAPI extension version information.

Arguments:

    Version     pointer to HSE_VERSION_INFO structure

Return Value:

    TRUE

--*/
{
    Version->dwExtensionVersion = 
    MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    strcpy(Version->lpszExtensionDesc, "Asynchronous Read Client Sample ISAPI DLL");

    return TRUE;
}




DWORD WINAPI
HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pecb)
/*++

Routine Description:

    This is the main routine for any ISAPI application. Inside DoASyncReadClient,
    proper action will be performed to read data from client asynchronously. Any data 
    read from client will be sent back to the client by using synchronous WriteClient.

Arguments:

    pecb        pointer to ECB containing parameters related to the request.

Return Value:

    HSE_STATUS_SUCCESS  or
    HSE_STATUS_PENDING  or 
    HSE_STATUS_ERROR

--*/
{
    PIOWI   piowi;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    
    //
    // The string length of textarea name "Data=" is 5. 
    // Available bytes <= 5 indicates that no user-
    // entered data has been sent, and the post form 
    // is shown.
    //

    if ( pecb->cbAvailable <= 5) {  

        hseStatus = SendMSGToClient(pecb, g_szPostForm);
    
    } else {

        piowi  = (PIOWI ) LocalAlloc( LMEM_FIXED, sizeof( IO_WORK_ITEM));

        if ( NULL == piowi) {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            return (HSE_STATUS_ERROR);
        }

        piowi->pecb = pecb;

        //
        // Init Grand data holder, assign the first chunk(read-ahead chunk)
        // and update the index (cbRreadSoFar) of the grand data holder.
        //

        hseStatus = DoInit( piowi);
        
        if ( HSE_STATUS_ERROR != hseStatus) {
            
            //
            // Now we are ready to do asynchronous readclient here
            //

            hseStatus = DoAsyncReadClient( piowi);
        
            if (hseStatus != HSE_STATUS_PENDING) {

                //
                //  When IO finishes, tell IIS we will end the
                //  session. Also clean up other resources here
                //

                DoCleanUp( piowi);

            }
        
        }

    }
       
    return (hseStatus);
}




BOOL WINAPI
TerminateExtension(DWORD dwFlags)
/*++

Routine Description:

	This function is called when the WWW service is shutdown

Arguments:

	dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE

--*/
{
    return TRUE;
}




DWORD
SendMSGToClient(IN LPEXTENSION_CONTROL_BLOCK  pecb, IN LPCSTR pszMsg)
/*++

Routine Description:

    Prepare header, SendHeaderExInfo struct and write whatever
    message is intended to send to the client.

Arguments:

    pecb        - pointer to ECB containing parameters related to the request.
    pszMsg      - pointer to the body of the message that is sent to the content.

Return Value:

    HSE_STATUS_SUCCESS  or HSE_STATUS_ERROR

--*/
{
    HSE_SEND_HEADER_EX_INFO	SHEI;

    BOOL    fReturn;
    DWORD   cbText;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    CHAR    *pszText = NULL;
    
    CHAR    szStatus[] = "200 OK";
    CHAR    szHeaderBase[] = "Content-type: text/html\r\n\r\n";
    
    //
    //  Populate SendHeaderExInfo struct
    //
    //  NOTE we must send Content-Length header with correct 
    //  byte count in order for keep-alive to work.
    //
    //

    SHEI.pszStatus = szStatus;
    SHEI.pszHeader = szHeaderBase;
    SHEI.cchStatus = lstrlen(szStatus);
    SHEI.cchHeader = lstrlen(szHeaderBase);
    SHEI.fKeepConn = FALSE;
    
    //
    //  Build page 
    //
    
    cbText = strlen("<head><title>Simple Async Read Client Sample</title></head>\n<body></body>\n")
             + strlen(pszMsg)
             + 1;

    pszText = (PCHAR) AR_Allocate(pecb, cbText);

    if ( NULL == pszText) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (HSE_STATUS_ERROR);
    }
    
    strcpy(pszText, "<head><title>Simple Async Read Client Sample</title></head>\n");
    strcat(pszText, "<body>");
    strcat(pszText, pszMsg);
    strcat(pszText, "</body>\n");
    cbText = (DWORD)strlen(pszText); 
        
    //
    // Send header and body text to client
    //

    fReturn = 
    pecb->ServerSupportFunction( pecb->ConnID,
                                 HSE_REQ_SEND_RESPONSE_HEADER_EX,  
                                 &SHEI,
                                 NULL,
                                 NULL) 
                                            
                                 &&

    pecb->WriteClient( pecb->ConnID,
                       pszText,
                       &cbText,
                       0 );

    if ( !fReturn)  {
        hseStatus = HSE_STATUS_ERROR;
    }

    
    AR_Free( pecb, pszText);
    
    return ( hseStatus);
} 




DWORD
DoAsyncReadClient(IN PIOWI piowi)
/*++

Routine Description:

    The caller of the asynchrnous read client.

Arguments:

    piowi       pointer to the work item
    
Return Value:

    HSE_STATUS_SUCCESS  or
    HSE_STATUS_PENDING  or 
    HSE_STATUS_ERROR

--*/
{   
    BOOL    fReturn;
    BYTE    *pbData = NULL;
    CHAR    szTmp[MAX_BUF_SIZE];
    DWORD   dwFlags;
    DWORD   cbTotalToRead = MAX_BUF_SIZE;
    DWORD   hseStatus =  HSE_STATUS_PENDING;
    
    //
    // Check if cbTotalBytes == cbAvailable
    // if so lpbData contains all the data sent by 
    // the client, and complete the session. 
    //

    if (piowi->pecb->cbTotalBytes == piowi->pecb->cbAvailable) {
        
        //
        // Construct the report and write it to client
        //

        pbData = (PBYTE) AR_Allocate(piowi->pecb, piowi->pecb->cbAvailable + MAX_BUF_SIZE);
            
        if ( NULL == pbData) {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            return (HSE_STATUS_ERROR);
        }

        wsprintf ( pbData,
                   g_szReport,
                   piowi->pecb->cbTotalBytes,
                   piowi->pecb->cbAvailable );
                    
        // strcat( pbData, piowi->pecb->lpbData);  -stanleyt: no need to write content to client

        hseStatus = SendMSGToClient( piowi->pecb, pbData);


        AR_Free( piowi->pecb, pbData);
        // DoCleanUp( piowi);		-stanleyt 10-27-97 BUG
        
        return ( hseStatus); // HSE_STATUS_SUCCESS or HSE_STATUS_ERROR;
    }

    //
    //  More to read...
    //

    //
    //  Set a call back function and context that will 
    //  be used for handling asynchrnous IO operations.
    //  This only needs to set up once.
    //

    fReturn =
    piowi->pecb->ServerSupportFunction(
                    piowi->pecb->ConnID,
                    HSE_REQ_IO_COMPLETION,
                    AsyncReadClientIoCompletion,
                    0,
                    (LPDWORD)piowi );  
    
    if ( !fReturn) {

        wsprintf ( szTmp, "Problem occurred at ServerSupportFunction() sending HSE_REQ_IO_COMPLETION request.");
        SendMSGToClient( piowi->pecb, szTmp);
        
        return ( HSE_STATUS_ERROR);
    }
    

    //
    //  Fire off the call to perform an asynchronus read from the client. 
    //
    
    // 
    // We need to first check if the size of the remaining chunk 
    // is less than MAX_BUF_SIZE, if so just read what is available, 
    // otherwise read MAX_BUF_SIZE bytes of data.
    // 

    cbTotalToRead = piowi->pecb->cbTotalBytes - piowi->cbReadSoFar;
    if ( cbTotalToRead > MAX_BUF_SIZE )  {

        cbTotalToRead = MAX_BUF_SIZE;
    }

    dwFlags = HSE_IO_ASYNC;
    fReturn = 
    piowi->pecb->ServerSupportFunction(
                        piowi->pecb->ConnID
                      , HSE_REQ_ASYNC_READ_CLIENT
                      , piowi->pbDATAFromClient + // append the new chunk to buffer, cbReadSoFar indexes
                        piowi->cbReadSoFar        // the byte right after the last written byte in the buffer
                      , &cbTotalToRead
                      , &dwFlags);

    if (!fReturn) {
        
        wsprintf ( szTmp, "Problem occurred at ServerSupportFunction() sending HSE_REQ_ASYNC_READ_CLIENT request.");
        SendMSGToClient( piowi->pecb, szTmp);
        
        hseStatus = HSE_STATUS_ERROR;
    }

    return ( hseStatus); // HSE_STATUS_PENDING or HSE_STATUS_ERROR;
    
}

 


VOID WINAPI
AsyncReadClientIoCompletion(
            IN LPEXTENSION_CONTROL_BLOCK pECB,
            IN PVOID pContext,
            IN DWORD cbIO,
            IN DWORD dwError)
/*++

Routine Description:

    This is the callback function for handling completions of asynchronous ReadClient.
    This function resubmits additional IO to read the next chunk of data from the 
    client. If there is no more data to read or problem during operation, this function 
    will inform IIS that it is about to end the request session.
    

Arguments:

    pecb        - extension control block
    pContext    - this is a IO_WORK_ITEM
    cbIO        - bytes just read
    dwError     - Win32 error status code

fReturn Value:

    None

--*/
{
    BOOL    fReturn;
    BYTE    *pbData = NULL;
    CHAR    szTmp[MAX_BUF_SIZE];
    DWORD   dwFlags;
    DWORD   cbTotalToRead;
    
    PIOWI   piowi = ( PIOWI) pContext;
    EXTENSION_CONTROL_BLOCK   * pecb = piowi->pecb;
    

    if (ERROR_SUCCESS == dwError) {

        //
        // Read successfully, so update current 
        // total bytes read (aka index of grand data holder)
        //

        piowi->cbReadSoFar += cbIO;     
                               
        //
        // If they are equal, we finish reading all bytes from client
        //
        
        if ( piowi->cbReadSoFar == pecb->cbTotalBytes ) { 

            //
            // Construct the report and write it to client
            //

            pbData = (PBYTE) AR_Allocate( pecb, piowi->cbReadSoFar + MAX_BUF_SIZE);
                
            if ( NULL == pbData) {

                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
                wsprintf ( szTmp, "Failed to allocate memory inside AsyncReadClientIoCompletion().");
                SendMSGToClient( pecb, szTmp);
                
                DoCleanUp( piowi);
 
                return;
            }
            
            wsprintf ( pbData, g_szReport, pecb->cbTotalBytes, piowi->cbReadSoFar );
            piowi->pbDATAFromClient[piowi->cbReadSoFar] = 0; 
            // strcat( pbData, piowi->pbDATAFromClient); -stanleyt: no need to write content to client
            SendMSGToClient( pecb, pbData);
            

            AR_Free( piowi->pecb, pbData);
            DoCleanUp( piowi);
            
            return;
            
        } else {

            // 
            // Still have more data to read... 
            // 
            // We need to first check if the size of the remaining chunk 
            // is less than MAX_BUF_SIZE, if so just read what is available, 
            // otherwise read MAX_BUF_SIZE bytes of data.
            // 

            cbTotalToRead = pecb->cbTotalBytes - piowi->cbReadSoFar;
            if ( cbTotalToRead > MAX_BUF_SIZE )  {

                cbTotalToRead = MAX_BUF_SIZE;
            }
            
            // 
            // Fire off another call to perform an asynchronus read from the client. 
            //

            dwFlags = HSE_IO_ASYNC;
            fReturn = 
            pecb->ServerSupportFunction(
                          pecb->ConnID
                        , HSE_REQ_ASYNC_READ_CLIENT
                        , piowi->pbDATAFromClient + // append the new chunk to buffer, cbReadSoFar indexes
                          piowi->cbReadSoFar        // the byte right after the last written byte in the buffer
                        , &cbTotalToRead
                        , &dwFlags);

            if ( !fReturn) {
                wsprintf ( szTmp, "Problem occurred at ServerSupportFunction() sending HSE_REQ_ASYNC_READ_CLIENT request.");
                SendMSGToClient( pecb, szTmp);

                DoCleanUp( piowi);
                
                return;
            }

        }
    
    } else {

        //
        // Error on read
        //

        SetLastError(dwError);
        
        DoCleanUp( piowi);
    }
        
    return;
        
} // AsyncReadClientIoCompletion




DWORD
DoInit(IN OUT PIOWI piowi)
/*++

Routine Description:

    Initialize the  Grand data holder, assign the first chunk(read-ahead chunk)
    and update the index (cbRreadSoFar) of the grand data holder.
    
Arguments:

    piowi       pointer to the work item

fReturn Value:

    HSE_STATUS_SUCCESS or HSE_STATUS_ERROR

--*/
{

    piowi->pbDATAFromClient = 
    (PBYTE) AR_Allocate( piowi->pecb, piowi->pecb->cbTotalBytes + MAX_BUF_SIZE);
    
    if ( NULL == piowi->pbDATAFromClient) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (HSE_STATUS_ERROR);
    }

    //
    // The first chunk (read-ahead chunk) has arrived.  
    //
    
    strcpy ( piowi->pbDATAFromClient, piowi->pecb->lpbData);
    piowi->cbReadSoFar = piowi->pecb->cbAvailable;

    return (HSE_STATUS_SUCCESS);
}




VOID
DoCleanUp(IN PIOWI piowi)
/*++

Routine Description:

    End the session with IIS and clean up other previous allocated resources.
    
Arguments:

    piowi       pointer to the work item

fReturn Value:

    None

--*/
{
    
    
    if ( piowi->pbDATAFromClient != NULL) {

        AR_Free( piowi->pecb, piowi->pbDATAFromClient);

    }

    piowi->pecb->ServerSupportFunction( piowi->pecb->ConnID,
                                        HSE_REQ_DONE_WITH_SESSION,
                                        NULL,
                                        NULL,
                                        NULL);

    LocalFree( piowi);

    return;

}




LPVOID 
AR_Allocate(IN LPEXTENSION_CONTROL_BLOCK pecb, IN DWORD dwSize)
/*++

Routine Description:

    Memory allocation routine. Two different Win32 API's to allocate
    bytes in memory, which is based on the number of bytes coming from 
    the client. If the size is greater than 1 M bytes VirtualAllocate is 
    used, otherwise HeapAllocate is used.
    
Arguments:

    pecb        - pointer to ECB containing parameters related to the request.
    dwSize      - number of bytes to allocate

fReturn Value:

    Pointer to void

--*/
{
    LPVOID pvData = NULL;
    

    if ( pecb->cbTotalBytes > MEM_ALLOC_THRESHOLD) {

        pvData = 
        VirtualAlloc( NULL, 
                      dwSize,
                      MEM_RESERVE | MEM_COMMIT, 
                      PAGE_READWRITE);

    } else {

        pvData = 
        HeapAlloc( GetProcessHeap(), 
                   HEAP_ZERO_MEMORY,
                   dwSize);
                           
    }

    return ( pvData);

}




BOOL
AR_Free( IN LPEXTENSION_CONTROL_BLOCK pecb, IN LPVOID pvData)
/*++

Routine Description:

    Freeing memory routine, a complementary routine to AR_Allocate. 
    Two different Win32 API's will be used to free up bytes in memory,
    which is based on the number of bytes coming from the client. If 
    the size is greater than 1 M bytes VirtualFree is used. Otherwise, 
    HeapFree is used.
    
Arguments:

    pecb        - pointer to ECB containing parameters related to the request.
    pvData      - pointer to the data to be freed.

fReturn Value:

    TRUE or FALSE

--*/
{
    BOOL fReturn = FALSE;


    if ( pecb->cbTotalBytes > MEM_ALLOC_THRESHOLD) {
        
        fReturn = VirtualFree( pvData, 0, MEM_RELEASE);

    } else {

        fReturn = HeapFree( GetProcessHeap(), 0, pvData);
    }

    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\clients\client.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    client.c

Abstract:

    Simple client app to pump new bytes to server.
        Format : 0123456789012345678....

Author:

    Stanle Tam (stanleyt)   4-June 1997
    
Revision History:
  
--*/
#include "client.h"

BOOL StartClients()
{
    DWORD   rgdwThreadId[MAX_THREADS];
    TCHAR   szMsg[MAX_PATH] = _T("");
    BOOL    fReturn = FALSE;
    UINT    i;

    for (i = 0; i < g_nThread ; i++) {	

        g_rghThreads[i] = 
        CreateThread( NULL, 
                      0,
                      (LPTHREAD_START_ROUTINE)&SendData,
                      (LPVOID)i, // local thread id
                      0,
                      &rgdwThreadId[i] );

        if (INVALID_HANDLE_VALUE == g_rghThreads[i]) {
            
            wsprintf(szMsg, "Failed to start Client [%2d] ! Error =%d\n", i, GetLastError());
            printf(szMsg);
            return fReturn;
           
        } else {

            wsprintf(szMsg, "Client [%d] started to run ....\n", i);
            printf(szMsg);
        }
    }
    fReturn = TRUE;

    return fReturn ;
}



void TerminateClients()
{
    UINT    i;
    TCHAR   szMsg[MAX_PATH] = _T("");

    if ( WAIT_FAILED == WaitForMultipleObjects( g_nThread , 
                                                g_rghThreads, 
                                                TRUE, 
                                                INFINITE) ) {
        wsprintf(szMsg, "WaitForMultipleObjects Failed. Error = %d\n", GetLastError() );
    }

    for (i = 0; i < g_nThread ; ++i) {

        CloseHandle(g_rghThreads[i]);
        wsprintf(szMsg, "Terminating Client [%d].. \n", i);
        printf(szMsg);
    }
    
    wsprintf(szMsg, "%d Client(s) are closed\n", g_nThread );
    printf(szMsg);
    
    return;
}



BOOL WINAPI SendData(UINT uThreadID)	
{
    BOOL  fReturn = TRUE;   
    DWORD cLoop = g_cLoop;
    DWORD cTimes = 0;
    //
    // ToDo : Need to rewrite this routine to make it stop
    // itself automically based on the number of minutes to run
    //

    assert (uThreadID < MAX_THREADS);

    while ( cLoop--) {
        
        fReturn = SendRequest( uThreadID);
        if (FALSE == fReturn)
            break;
        
        printf("Client [%d] finish %d time(s)..\n\n", uThreadID, ++cTimes);
    }
    
    return fReturn;
}



BOOL SendRequest(UINT uThreadID)
{
    HINTERNET   hOpen, hConnect, hRequest;
    DWORD       cbQueryReturnByte = MAX_DATA_LENGTH;
    CHAR        szQueryBuf[MAX_DATA_LENGTH] = {0};
    TCHAR       szMsg[MAX_DATA_LENGTH] = _T("");
    LPBYTE      pbSendRequestData;
    BOOL        fReturn = FALSE;
    
    UINT i;
    __try {
        if (g_cbSendRequestLength)  {
            pbSendRequestData = (LPBYTE)LocalAlloc(0, g_cbSendRequestLength);

            if (NULL == pbSendRequestData ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                printf("Not Enough Memory. Can't send Request..");
                __leave;
     
            } else {
                //
                // Stuff bytes - format : 0123456789012345678....
                //
                for (i = 0; i < g_cbSendRequestLength; i++) 
                    pbSendRequestData[i] = i % 10 + '0';
            }
        }
     
        hOpen = 
        InternetOpen(g_szTestType,
                     INTERNET_OPEN_TYPE_DIRECT,
                     NULL,
                     NULL,
                     0);
	
	    if (NULL == hOpen) {
		    wsprintf(szMsg, "Failed on InternetOpen returns %d\n", GetLastError());
		    printf(szMsg);
		    __leave;
	    }
	
	    hConnect = 
        InternetConnect(hOpen,
                        g_szServerName,
                        INTERNET_DEFAULT_HTTP_PORT,
                        NULL,
                        NULL,
                        INTERNET_SERVICE_HTTP,
                        0,
                        0);

	    if (NULL == hConnect) {
		    wsprintf(szMsg, "Failed on InternetConnect returns %d\n", GetLastError());
		    printf(szMsg);
		    __leave;
	    }

        hRequest = 
        HttpOpenRequest(hConnect,
                        g_szVerb,
                        g_szObject,
                        NULL,
                        NULL,
                        NULL,
                        dwDefaultFlag,
                        0);

	    if (NULL == hRequest) {
		    wsprintf(szMsg, "Failed on HttpOpenRequest returns %d\n", GetLastError());
		    printf(szMsg);
		    __leave;
	    }
	
	    fReturn = 
        HttpAddRequestHeaders(  hRequest,
                                g_szRequestString,
                                //strlen(g_szRequestString), // -1L,
                                -1L, 
                                0);
	
	    if (FALSE == fReturn) {
            wsprintf(szMsg, "Failed on HttpAddRequestHeaders returns %d\n", GetLastError());
            printf(szMsg);
            __leave;
            }
	
        fReturn = 
        HttpSendRequest(hRequest,
                        NULL,
                        0,
                        pbSendRequestData,
                        g_cbSendRequestLength);

        if (FALSE == fReturn) {
            wsprintf(szMsg, "Failed on HttpSendRequest returns %d\n", GetLastError());
            printf(szMsg);
            __leave;
        }

        fReturn = 
        HttpQueryInfo(  hRequest,
                        HTTP_QUERY_RAW_HEADERS_CRLF,
                        szQueryBuf,
                        &cbQueryReturnByte,
                        NULL);
    
        if (FALSE == fReturn) {
            wsprintf(szMsg, "Failed on HttpQueryInfo returns %d\n", GetLastError());
            printf(szMsg);
            __leave;
        }
	
        wsprintf(szMsg, "HttpQueryInfo returns buffer .. %s\n", szQueryBuf);
        printf(szMsg);
	
	    if (!_tcsicmp(g_szTestType, "TF")   ||
            !_tcsicmp(g_szTestType, "WC")   ||
            !_tcsicmp(g_szTestType, "RC")   ||
            !_tcsicmp(g_szTestType, "AWC")  ||
            !_tcsicmp(g_szTestType, "ARC")  ||
            !_tcsicmp(g_szTestType, "SSF")) {

            //
            // Length will be whatever specified in the query string for
            // write client and transmit file, MAX_DATA_LENGTH for now.
            //
            CHAR szReadFileBuf[MAX_DATA_LENGTH] = {0};  
            DWORD cbReadFileByte = MAX_DATA_LENGTH;     
            DWORD cbReadFileReturnByte = 0;
	    
            fReturn = 
            InternetReadFile(hRequest,
                            szReadFileBuf,
                            cbReadFileByte,
                            &cbReadFileReturnByte);

            if (FALSE == fReturn) {
                wsprintf(szMsg, "Failed on InternetReadFile returns %d\n", GetLastError());
                printf(szMsg);
                __leave;
            }       
        
            // 
            // Create a file to store the body sent from Server. Output file is
            // placed under the TEMP directory with a file name ISAPI<index>.cmp
            // where <index> represents the thread number it belongs.
            // Also output the body to the screen.
            //
            wsprintf(szMsg, "InternetReadFile returns :\n%s\n", szReadFileBuf);
            printf(szMsg);
        
            if ( FALSE == CreateReadInternetFile(uThreadID, szReadFileBuf, cbReadFileReturnByte)) {
                __leave;
            }
        }
        fReturn = TRUE;
     }
     __finally {

         if ( hOpen != NULL) {
             InternetCloseHandle(hOpen);
             hOpen = NULL;
         }

         if ( ! g_fEatMemory)
             LocalFree(pbSendRequestData); 
     }

	 return fReturn;
}



BOOL ParseArguments(INT argc, char *argv[], UINT *TestType)
{
    PCHAR   pChar = NULL;
    BOOL    fRet = TRUE;

    if ((argc == 1))  {									  
        return (FALSE);
    }

    while (--argc) 
    {
        pChar = *++argv;
        if (*pChar == '-' || *pChar == '/') {
            
            while (*++pChar) {
                switch (tolower(*pChar)) {
                    
				case 's':   // server name
                        if (--argc == 0)  
                            return (FALSE);
                        argv++;
                        _tcscpy(g_szServerName, *argv);
                        break;

				case 't':   // test type
                        if (--argc == 0)  
                            return (FALSE);
                        argv++;
                        _tcscpy(g_szTestType, *argv);
                        break;

                case 'p':   // Virtual Path
                        if (--argc == 0)  
                            return (FALSE);
                        argv++;
                        _tcscpy(g_szVrPath, *argv);
                        /*FixFileName(*argv);*/
                        break;

                case 'h':   // thread number
                        if (--argc == 0)  
                            return (FALSE);
                        argv++;
                        g_nThread = atoi(*argv);
                        if (g_nThread < 1)
                            g_nThread = 1;
                        break;

                case 'b': // Send Byte Count
                        if (--argc == 0)
                            return FALSE;
                        argv++;
                        _tcscpy(g_szByteCount, *argv);
                        break;

                case 'c': // Loop count per thread
                        if (--argc == 0)
                            return FALSE;
                        argv++;
                        g_cLoop = atoi(*argv);
                        break;

                case 'e': // Eat memory on purpose
                        if (--argc == 0)
                            return FALSE;
                        argv++;
                        g_fEatMemory = ( atoi(*argv) == 0 ? FALSE : TRUE);
                        break;

                case 'k': // Keep Connection Alive
                        if (--argc == 0)
                            return FALSE;
                        argv++;
                        if ( atoi(*argv) == 1 )
                            dwDefaultFlag |= INTERNET_FLAG_KEEP_CONNECTION ;
                        break;
                default:
                        return (FALSE);
				}
			}
		
        } else {
        
            return (FALSE);
		 }
	}
     
    if (!_tcscmp(g_szServerName, "")    || 
        !_tcscmp(g_szTestType, "")      ||
        !_tcscmp(g_szVrPath, "")    )    
        return (FALSE);

    //
    // determine request string
    //

    *TestType = 0;
    while (_tcscmp(rgTestType[*TestType], "bad_type") || *TestType < BAD) {
        
        if (!_tcsicmp(rgTestType[*TestType], g_szTestType))
            break;

        (*TestType)++;
    }

    return (*TestType == BAD ? FALSE : TRUE);
}



BOOL ProcessArguments(const UINT TestType)
{
    BOOL    fReturn = TRUE;

    switch (TestType) 
    {
    case TF:
    // add TransmitFile test               
        break;

    case RC:
        // Async ReadClient()
        if ( _tcscmp(g_szByteCount, "")) {

            g_cbSendRequestLength = (DWORD)atol(g_szByteCount);
            wsprintf(g_szObject, "%s?SYNC", g_szVrPath);
            wsprintf(g_szRequestString, "Content-Length: %s\r\n\r\n", g_szByteCount);
            break;
        } else 
            fReturn = FALSE;
        break;
    
    case WC:
    // add WriteClient test        
        break;
    
    case AWC:
    // add Async WriteClient test        
        break;

    case ARC:
        // Async ReadClient()
        if ( _tcscmp(g_szByteCount, "")) {

            g_cbSendRequestLength = (DWORD)atol(g_szByteCount);
            wsprintf(g_szObject, "%s?ASYNC", g_szVrPath);
            wsprintf(g_szRequestString, "Content-Length: %s\r\n\r\n", g_szByteCount);
            break;
        } else { 
            fReturn = FALSE;
            break;
        }

    case SSF:
        // ServerSupportFunction()
        wsprintf(g_szObject, "%s?Keep_Alive", g_szVrPath);
        strcat(g_szRequestString, "\r\n\r\n");
        break;
                
    default: // bad_type
        fReturn = FALSE;
    }

    return fReturn;
}



void FixFileName(char *argv)
{
    UINT    uS = 0, 
            uD = 0, 
            uLen = strlen(argv);

    while (uS < uLen)
    {
        if (argv[uS] == '\\')
            g_szFileName[uD++] = '\\';

        g_szFileName[uD++] = argv[uS++];
    }
    g_szFileName[uD] = '\0';
}



BOOL CreateReadInternetFile(const UINT uThreadID, 
                            const char* szReadFileBuf, 
                            const DWORD cbReadFileByte)
{
    BOOL    fReturn = FALSE;
    HANDLE  g_hLogFile = INVALID_HANDLE_VALUE;
    CHAR    szFileIndx[10] = {0};
    CHAR    szFileName[100] = "c:\\temp\\ISAPI";
    
    _itoa (uThreadID, szFileIndx, 10);
    _tcscat(szFileName, szFileIndx);
    _tcscat(szFileName, ".cmp");    // extension cmp for comparion

    __try {
        BOOL    fOK;
        DWORD   cbWritten = 0;

        g_hLogFile = 
        CreateFile( (LPCTSTR)szFileName,
                    GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    CREATE_ALWAYS,
                    0,
                    NULL);
              
        if ( INVALID_HANDLE_VALUE == g_hLogFile) {
            __leave;
        }
        
        if ( 0xFFFFFFFF == SetFilePointer( g_hLogFile, 0, NULL, FILE_END) ) {
            __leave;
        }

        fOK = WriteFile( g_hLogFile, 
                         szReadFileBuf, 
                         cbReadFileByte, 
                         &cbWritten, 
                         NULL);
        if (!fOK || 0 == cbWritten) {
            __leave;
        }

        fReturn = TRUE;
    }
    __finally { // clean up
        if ( g_hLogFile !=  INVALID_HANDLE_VALUE) {
            CloseHandle( g_hLogFile);
            g_hLogFile =  INVALID_HANDLE_VALUE;
        }
    }
    
    return fReturn;
}



void ShowUsage()
{
    TCHAR szUsage[3000] = "";
    strcat (szUsage, 
        "\nUsage: Client[options]                   \n"
        "                                           \n"
        "   Options:    -s Server Name	            \n"
        "               -t Test Type                \n"
        "               -k Keep Connection Alive    \n"
        "               -p Virtual Path             \n"
		"               -b Number of Bytes          \n"
        "               -h Thread Numbers           \n"
        "               -c Loop per Thread          \n"
        "               -e Eatup Memory on Purpose  \n"
        "                                           \n"
        "   Test Types:                             \n"
        "                                           \n"
        "       RC - Sync ReadClient                \n"
        //"       WC - Async WriteClient            \n"
        //"       SWC - Sync WriteClient            \n"
        "       ARC - Async ReadClient              \n"
        //"       TF  - TransmitFile                \n
        "       SSF  - ServerSupportFunction        \n"
        "                                           \n"
        "   Examples:   -s stan1_s -t ARC -p \\scripts\\UReadCli.dll -b 1000 -h 2 -c 1      \n"
        "               -s stan1_s -t RC  -p \\INP\\UReadCli.dll -b 1000 -h 10 -c 100 -E 1  \n"
        "               -s stan1_s -t SSF  -p \\INP\\W3test.dll -h 10 -c 100 -k 1           \n"
        "                                           \n");
        
    printf (szUsage);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\isagen\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000


//
// Following macros are useful for formatting and printing out GUIDs
//

# define GUID_FORMAT   "{%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"

# define GUID_EXPAND(pg) \
  (((GUID *) (pg))->Data1), (((GUID *) (pg))->Data2), (((GUID *) (pg))->Data3), \
  (((GUID *) (pg))->Data4[0]),   (((GUID *) (pg))->Data4[1]), \
  (((GUID *) (pg))->Data4[2]),   (((GUID *) (pg))->Data4[3]), \
  (((GUID *) (pg))->Data4[4]),   (((GUID *) (pg))->Data4[5]), \
  (((GUID *) (pg))->Data4[6]),   (((GUID *) (pg))->Data4[7])

    // Usage:  DBGPRINTF(( DBG_CONTEXT, " My Guid: " GUID_FORMAT " \n", 
    //                     GUID_EXPAND( pMyGuid)));


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\hello\hello.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    hello.c

Abstract:

    This is a simple ISAPI module that just sends "Hello" to the client.
    The purpose is to provide a very simple ISAPI application that can be
    used for measuring WAM performance.

Usage:

    no parameters required

Author:

    Tony Godfrey (tonygod) 8-Aug-1997

Revision History:


--*/

#include <windows.h>
#include <httpext.h>
#include <stdio.h>

// Prototypes

BOOL GetExtensionVersion( HSE_VERSION_INFO *Version )
/*++

Routine Description:

    Sets the ISAPI extension version information.

Arguments:

    Version     pointer to HSE_VERSION_INFO structure

Return Value:

    TRUE

--*/
{
    Version->dwExtensionVersion = MAKELONG(
        HSE_VERSION_MINOR, 
        HSE_VERSION_MAJOR
        );
    strcpy( Version->lpszExtensionDesc, "ISAPI Hello" );
    return TRUE;
}


DWORD HttpExtensionProc( LPEXTENSION_CONTROL_BLOCK pec )
/*++

Routine Description:

    This is the main routine for any ISAPI application, called by WAM.  
    We just do a WriteClient to send the "Hello" message and return.

Arguments:

    pec           pointer to ECB containing parameters related to the request.

Return Value:

    Success: HSE_STATUS_SUCCESS
    Failure: HSE_STATUS_ERROR

--*/
{
    BOOL bResult;
    DWORD dwBytesWritten;

    bResult = pec->ServerSupportFunction(
        pec->ConnID,
        HSE_REQ_SEND_RESPONSE_HEADER,
        "200 OK",
        NULL,
        (LPDWORD) TEXT("Content-Type: text/html\r\n\r\n")
        );
    if ( !bResult ) {
        return HSE_STATUS_ERROR;
    }

    dwBytesWritten = 5;
    bResult = pec->WriteClient(
        pec->ConnID,
        "Hello",
        &dwBytesWritten,
        0
        );
    if ( !bResult ) {
        return HSE_STATUS_ERROR;
    }
    return( HSE_STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\crash\crash.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    crash.c

Abstract:

    This module simulates an access violation, in various scenarios
    based on the query string.

Usage:
    crash.dll[?<async|test>[&exit]]

    where ?async causes an access violation after returning HSE_STATUS_PENDING
          ?test returns usage and verifies the dll is functioning
          exit causes the DLL to perform ExitProcess instead of access violation
          no query string results in a synchronous crash

Author:

    Tony Godfrey (tonygod) 14-Apr-1997

Revision History:

    Tony Godfrey (tonygod) 28-Jul-1997 - added asynchronous crash

--*/

#include <windows.h>
#include <httpext.h>
#include <stdio.h>

#define BUFFER_LEN 10000

// Prototypes
VOID Crash( DWORD dwCrashType );
VOID HseIoCompletion(
    IN EXTENSION_CONTROL_BLOCK * pECB,
    IN PVOID pContext,
    IN DWORD cbIO,
    IN DWORD dwError
    );

BOOL GetExtensionVersion( HSE_VERSION_INFO *Version )
/*++

Routine Description:

    Sets the ISAPI extension version information.

Arguments:

    Version     pointer to HSE_VERSION_INFO structure

Return Value:

    TRUE

--*/
{
    Version->dwExtensionVersion = MAKELONG(
        HSE_VERSION_MINOR, 
        HSE_VERSION_MAJOR
        );
    strcpy( Version->lpszExtensionDesc, "ISAPI Crash Tester" );
    return TRUE;
}


DWORD HttpExtensionProc( LPEXTENSION_CONTROL_BLOCK pec )
/*++

Routine Description:

    This is the main routine for any ISAPI application, called by WAM.  
    We determine the type of crash to simulate by examining the query 
    string.

Arguments:

    pec           pointer to ECB containing parameters related to the request.

Return Value:

    Either HSE_STATUS_SUCCESS or HSE_STATUS_PENDING, depending on query
    string

--*/
{
    BOOL bResult;
    DWORD dwBytesWritten;
    DWORD dwCrashType;
    CHAR szBuffer[BUFFER_LEN];

    bResult = pec->ServerSupportFunction(
        pec->ConnID,
        HSE_REQ_SEND_RESPONSE_HEADER,
        "200 OK",
        NULL,
        (LPDWORD) TEXT("Content-Type: text/html\r\n\r\n")
        );
    if ( !bResult ) {
        return HSE_STATUS_ERROR;
    }

    dwCrashType = 1;
    if ( strstr( pec->lpszQueryString, "exit" ) != NULL ) {
        dwCrashType = 2;
    }

    if ( strstr( pec->lpszQueryString, "async" ) != NULL ) {
        bResult = pec->ServerSupportFunction(
            pec->ConnID,
            HSE_REQ_IO_COMPLETION,
            HseIoCompletion,
            NULL,
            (DWORD *) dwCrashType
            );
            // NOTE hokey cast of dwCrashType to (DWORD *) but SSF simply treats
            // this parameter as pass-through
        if ( !bResult ) {
            return HSE_STATUS_ERROR;
        }

        dwBytesWritten = wsprintf(
            szBuffer,
            "Crashing asynchronously..."
            );
        bResult = pec->WriteClient(
            pec->ConnID,
            szBuffer,
            &dwBytesWritten,
            HSE_IO_ASYNC
            );
        if ( !bResult ) {
            return HSE_STATUS_ERROR;
        }

        return( HSE_STATUS_PENDING );
    }

    if ( strstr( pec->lpszQueryString, "test" ) != NULL ) {
	dwBytesWritten = wsprintf(
            szBuffer,
            "<h1>ISAPI Crash DLL</h1>\r\n\r\n"
            "Usage: crash.dll[?&lt;async|test&gt;[&exit]]<p>\r\n\r\n"
            "lpszQueryString = %s<br>\r\n"
            "dwCrashType = %ld",
            pec->lpszQueryString,
            dwCrashType
            );
        bResult = pec->WriteClient(
            pec->ConnID,
            szBuffer,
            &dwBytesWritten,
            0
            );
        if ( !bResult ) {
            return HSE_STATUS_ERROR;
        }
        return( HSE_STATUS_SUCCESS );
    }

    Crash( dwCrashType );

    return( HSE_STATUS_SUCCESS );
}


VOID HseIoCompletion(
    IN EXTENSION_CONTROL_BLOCK * pECB,
    IN PVOID pContext,
    IN DWORD cbIO,
    IN DWORD dwError
    )
/*++

Routine Description:

    This is the callback function for handling asynchronous operations.
    In this sample, we simply call the Crash() function, to simulate a
    crash during during an asynchronous operation.

Arguments:

    pECB          pointer to ECB containing parameters related to the request.
    pContext      context information supplied with the asynchronous IO call.
    cbIO          count of bytes of IO in the last call.
    dwError       Error if any, for the last IO operation.

Return Value:

    None

--*/
{
    // NOTE re-cast our "context ptr"  back to the DWORD we 
    // originally passed to SSF
    Crash( (DWORD) pContext );
}


VOID Crash( DWORD dwCrashType )
/*++

Routine Description:

    This routine causes an access violation by overwriting a buffer.


Arguments:

    dwCrashType    1 = access violation, 2 = ExitProcess

Return Value:

    None (should never return)

--*/
{
    int i;
    CHAR szCrash[1];

    switch( dwCrashType ) {
        case 1:
            i = 0;
            while ( TRUE ) {
                szCrash[i++] = '0';
            }
            break;
        case 2:
            ExitProcess( 0 );
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\common\apitimer.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    apitimer.cxx

Abstract:

    API Timer class

Author:

    Stanley Tam (stanleyt)   18-May-1997

Revision History:
--*/


#include <windows.h>
#include <limits.h>
#include "apitimer.hxx"


CAPITimer::CAPITimer()
{
    FInit();
}





CAPITimer::~CAPITimer()
{
}
 




void CAPITimer::FInit()   
{
    __int64 iFreq;
    
    m_fPerfCounterExists = QueryPerformanceFrequency( (LARGE_INTEGER*)&iFreq );

    if (m_fPerfCounterExists) {
        m_dblTicksToSecs = 1.0 / iFreq;
    } else {
        m_dblTicksToSecs = 0.0;
    }

    m_dblElapsedInSecs = 0.0;
}




void CAPITimer::Start()
{
    // 
    // Save the current performance counter, i.e start time
    //

    if (m_fPerfCounterExists) {
        
        QueryPerformanceCounter((LARGE_INTEGER*)&m_iStartTime);

    } else {
        
        m_iStartTime = GetTickCount();

    }
}




void CAPITimer::End()
{
    __int64 iDiffTime;
    double  dblElapsedInSecs = 0.0;

    if (m_fPerfCounterExists) {
        QueryPerformanceCounter((LARGE_INTEGER*)&m_iEndTime);
        iDiffTime = m_iEndTime - m_iStartTime;
        m_dblElapsedInSecs = (double)iDiffTime * m_dblTicksToSecs;
    } else {
        iDiffTime = (__int64)GetTickCount() - m_iStartTime;
        
        //
        // Convert microseconds to seconds
        //

        m_dblElapsedInSecs = (double)iDiffTime / SECOND_TO_MILLISECOND;
    }
}




double CAPITimer::GetElapsedInSecs()
{
   return (m_dblElapsedInSecs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\coinit\coinit.cxx ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: CoInit.cpp

Owner: DaveK

Sample (and simple!) ISAPI app
===================================================================*/
#include "wtypes.h"
#include "windef.h"
#include "winbase.h"
#include "winuser.h"
#include "stdlib.h"
#include "iisext.h"
#include "objbase.h"

// Globals
char				g_szExtensionDesc[] = "CoInit ISAPI test 1.0";

char				g_szCoInitSez[] = "\
<FONT SIZE=3>\
Of all God's creatures there is only one that <BR>\
cannot be made the slave of the lash. That one is the cat. <BR>\
If man could be crossed with a cat it would improve man, <BR>\
but it would deteriorate the cat. <BR><PRE>\
- Mark CoInit (1835-1910), American author. <BR>\
</FONT>\
";

/*===================================================================
BOOL DllInit
Initialize the DLL

Returns:
	TRUE on successful initialization

Side effects:
	NONE
===================================================================*/
BOOL DllInit( void )
	{
	OutputDebugString( "CoInit DLL initialized\n" );
	return TRUE;
	}

/*===================================================================
void DllUnInit
UnInitialize the DLL

Returns:
	NONE

Side effects:
	NONE
===================================================================*/
void DllUnInit( void )
	{
	OutputDebugString( "CoInit DLL un-initialized\n" );
	}

/*===================================================================
GetExtensionVersion

Mandatory server extension call which returns the version number of
the ISAPI spec that we were built with.

Returns:
	TRUE on success

Side effects:
	None.
===================================================================*/
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO *pextver)
{
	// Init the DLL
	if ( !DllInit() )
		{
			return FALSE;
		}

    if (FAILED( CoInitializeEx(NULL, COINIT_APARTMENTTHREADED) ))
		{
			return FALSE;
		}
 

	OutputDebugString( "CoInit DLL: CoInitializeEx(NULL, COINIT_APARTMENTTHREADED) call succeeded\n" );

	pextver->dwExtensionVersion =
			MAKELONG(HSE_VERSION_MAJOR, HSE_VERSION_MINOR);
	lstrcpy(pextver->lpszExtensionDesc, g_szExtensionDesc);
	return TRUE;
}

/*===================================================================
SendHeaderToClient


Returns:
	TRUE if success

Side effects:
	None.
===================================================================*/
BOOL
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pECB, IN LPCSTR szMessage)
{
	char *	szStatus = "200 OK";
    char	szHeader[600];

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( szHeader,
             "Content-Type: text/html"
			 "\r\n"
             "\r\n"	// end of header
             "<head><title>Mark CoInit's DLL </title></head>\n"
             "<body><h1>%s</h1>\n"
             ,
             szMessage );

    if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_SEND_RESPONSE_HEADER,
                                      szStatus,
                                      NULL,
                                      (LPDWORD) szHeader )
        ) {

        return FALSE;
    }

    return TRUE;
} // SendHeaderToClient()


/*===================================================================
WriteSz

Writes a string to the browser.

Returns:
	TRUE if success

Side effects:
	None.
===================================================================*/
BOOL WriteSz ( EXTENSION_CONTROL_BLOCK * pECB, LPSTR sz )
	{
	DWORD	cch = lstrlen( sz );
	
	if ( !pECB->WriteClient( pECB->ConnID, sz, &cch, 0 ) )
		{
		return FALSE;
		}
	
	return TRUE;
	}


/*===================================================================
HttpExtensionProc

Main entry point into the Isapi DLL.

Returns:
	DWord indicating status of request.  
	HSE_STATUS_PENDING for normal return
		(This indicates that we will process the request, but havent yet.)

Side effects:
	None.
===================================================================*/
DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK * pECB )
	{
	DWORD	dwPID;
	DWORD	dwRet = HSE_STATUS_ERROR;
	char *	szPath = NULL;
	char	szPID[ 10 ];
	char	szTemp[ 10 ];
	HSE_URL_MAPEX_INFO	urlmap;

	if ( !SendHeaderToClient( pECB, "" ) ) {

		goto LExit;
	}

	if ( !WriteSz( pECB, "<HTML>" ) )
		goto LExit;

	if ( !WriteSz( pECB,	"<BR> Hello, from your pal CoInit.dll!" ) )
		goto LExit;


    if (FAILED( CoInitializeEx(NULL, COINIT_APARTMENTTHREADED) ))
		{
		goto LExit;
		}
 

	OutputDebugString( "CoInit DLL: CoInitializeEx(NULL, COINIT_APARTMENTTHREADED) call succeeded\n" );

	dwRet = HSE_STATUS_SUCCESS;

LExit:
	delete szPath;
	return dwRet;
	}

/*===================================================================
DllMain

Main entry point into the DLL.  Called by system on DLL load
and unload.

Returns:
	TRUE on success

Side effects:
	None.
===================================================================*/
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	return TRUE;
}

/*===================================================================
DllCanUnloadNow

Tells OLE if we can unload now.

I dont believe this is ever called.

Returns:
	S_OK

Side effects:
	None.
===================================================================*/
STDAPI DllCanUnloadNow()
	{
	return(S_OK);
	}

/*===================================================================
TerminateExtension

IIS is supposed to call this entry point to unload ISAPI DLLs.

Returns:
	NONE

Side effects:
	Uninitializes the Denali ISAPI DLL if asked to.
===================================================================*/
BOOL WINAPI TerminateExtension( DWORD dwFlag )
	{
	
    CoUninitialize();

    OutputDebugString( "CoInit DLL: called CoUninitialize()\n" );

    return TRUE;

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\lottery\lottery.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

This program is released into the public domain for any purpose.

Module Name:

    lottery.c

Abstract:

    This module is an example of an effective multi-threaded ISAPI Application.

Revision History:

--*/

#include <windows.h>
#include <httpext.h>

#include "worker.h"

//
//  Constants
//

//
//  This is the maximum number of threads we'll allow in the pool
//

#define MAX_THREADS                 2

//
//  This is the number of threads per processor to create.  If the threads
//  are heavily IO bound (waiting on network connections for example), a higher
//  number might be appropriate.  If the threads are CPU bound, a lower number
//  would be appropriate.
//

#define THREADS_PER_PROCESSOR       2

//
//  This is the maximum number of items we'll allow on the work queue.  If
//  this number is exceeded we send a message to the client indicating
//  there are too many users currently and they should try again later.
//

#define MAX_WORK_QUEUE_ITEMS        4

//
//  The text to display when there are too many outstanding work items
//

#define SERVER_TOO_BUSY_TEXT        "<head><title>Server too busy</title></head>" \
                                    "<body><h2>The server is too busy to give" \
                                    "your lucky lottery number right now."     \
                                    "Please try again later.\n</body>"

//
//  Must be the external .dll name of this module
//

#define MODULE_NAME                 "LOTTERY.DLL"

//
//  Definitions
//

//
//  This is the structure of a work queue item
//

typedef struct _WORK_QUEUE_ITEM
{
    LIST_ENTRY                ListEntry;
    HANDLE                    hImpersonationToken;
    EXTENSION_CONTROL_BLOCK * pecb;
} WORK_QUEUE_ITEM;

//
//  Globals
//

//
//  Protects the work queue and free queue
//

CRITICAL_SECTION csQueueLock;

//
//  List of work items in a doubly linked circular list
//

LIST_ENTRY WorkQueueList;

//
//  List of free WORK_QUEUE_ITEM structures
//

LIST_ENTRY FreeQueueList;

//
//  Number of items on the work queue
//

DWORD cQueueItems = 0;

//
//  Use a semaphore to indicate there's work to be performed.  We use a
//  semaphore rather then an event because a semaphore tracks how many times
//  it has been signalled
//

HANDLE hWorkSem = NULL;

//
//  Prototypes
//

DWORD
WINAPI
PoolThread(
    LPDWORD lpParams
    );

WORK_QUEUE_ITEM *
AllocateWorkItem(
    VOID
    );

VOID
FreeWorkItem(
    WORK_QUEUE_ITEM * pwqi
    );

BOOL
SendError(
    EXTENSION_CONTROL_BLOCK * pecb,
    CHAR *                    pszStatus,
    CHAR *                    pszMessage
    );

//
// Functions
//

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     )
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.
--*/
{
    BOOL        fReturn = TRUE;
    SYSTEM_INFO si;
    DWORD       i;
    DWORD       dwThreadId;

    switch (fdwReason )
    {
    case DLL_PROCESS_ATTACH:

        //
        // Initialize various data and modules.
        //

        if ( !InitializeLottery() )
        {
            fReturn = FALSE;
            break;
        }

        WorkQueueList.Flink = WorkQueueList.Blink = &WorkQueueList;
        FreeQueueList.Flink = FreeQueueList.Blink = &FreeQueueList;

        hWorkSem = CreateSemaphore( NULL,
                                    0,          // Not signalled initially
                                    0x7fffffff, // Max reference count
                                    NULL );

        if ( !hWorkSem )
        {
            return FALSE;
        }

        InitializeCriticalSection( &csQueueLock );

        //
        //  We don't care about thread attach/detach notifications
        //

        DisableThreadLibraryCalls( hinstDll );

        //
        //  Do an extra LoadLibrary on ourselves so we get terminated when
        //  the process gets terminated (avoids worrying about thread cleanup
        //  issues on dll detach).
        //

        LoadLibrary( MODULE_NAME );

        //
        //  Create our thread pool, two times the number of processors
        //

        GetSystemInfo( &si );

        for ( i = 0;
              i < THREADS_PER_PROCESSOR * si.dwNumberOfProcessors &&
              i < MAX_THREADS;
              i++ )
        {
            HANDLE hThread;

            hThread = CreateThread( NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE) PoolThread,
                                    NULL,
                                    0,
                                    &dwThreadId );

            if ( !hThread )
            {
                CloseHandle( hWorkSem );
                DeleteCriticalSection( &csQueueLock );
                return FALSE;
            }

			//
			//  We don't use the thread handle so close it
			//

            CloseHandle( hThread );
        }
        break;

    case DLL_PROCESS_DETACH:
        {

            //
            //  Note we should never get called because we did an extra
            //  LoadLibrary in our initialization
            //

            if ( lpvContext != NULL)
            {
                TerminateLottery();
                DeleteCriticalSection( &csQueueLock );
                CloseHandle( hWorkSem );
            }

            break;
        } /* case DLL_PROCESS_DETACH */

    default:
        break;
    }   /* switch */

    return ( fReturn);
}  /* DllLibMain() */



BOOL WINAPI
GetExtensionVersion (
    HSE_VERSION_INFO * pver
    )
/*++

Routine Description:
    This is the first function that is called when this ISAPI DLL is loaded.
    We should fill in the version information in the structure passed in.

Arguments:
    pVer - pointer to Server Extension Version Information structure.

Returns:
    TRUE for success and FALSE for failure.
    On success the valid version information is stored in *pVer.
--*/
{
    pver->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    strcpy( pver->lpszExtensionDesc,
            "Multi-threaded ISAPI Application example, v 1.0" );

    return TRUE;
}

DWORD
WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
/*++

Routine Description:
    This is the main function that is called for this ISAPI Extension.
    This function processes the request and sends out appropriate response.

Arguments:
    pecb  - pointer to EXTENSION_CONTROL_BLOCK, which contains most of the
            required variables for the extension called. In addition,
    it contains the various callbacks as appropriate.

Returns:
    HSE_STATUS code indicating the success/failure of this call.
--*/
{
    WORK_QUEUE_ITEM * pwqi;
    DWORD             cb;
    BOOL              fRet;
    HANDLE            hImpersonationToken = NULL;

    //
    //  Is the list too long?  If so, tell the user to come back later
    //

    if ( cQueueItems + 1 > MAX_WORK_QUEUE_ITEMS )
    {
        //
        //  Send a message back to client indicating we're too busy, they
        //  should try again later.
        //

        fRet = SendError( pecb,
                          "503 Server too busy",
                          SERVER_TOO_BUSY_TEXT );

        pecb->dwHttpStatusCode = 503;

        return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
    }

    //
    //  Capture the current impersonation token so we can impersonate this
    //  user in the other thread
    //
#if 0

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_READ | TOKEN_IMPERSONATE,
                           TRUE,            // Open in unimpersonated context
                           &hImpersonationToken ))
    {
#if _DEBUG
	
		LPVOID lpMsgBuf;
 
		FormatMessage( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			GetLastError(),
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf,
			0,
			NULL	 
		);

		// Display the string.
		MessageBox( NULL, lpMsgBuf, "GetLastError", MB_OK|MB_ICONINFORMATION );

		// Free the buffer.
		LocalFree( lpMsgBuf );

#endif


		fRet = SendError( pecb,
                          "500 Failed to open thread token",
                          "Failed to open thread token" );

        pecb->dwHttpStatusCode = 500;

        return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
    }
#endif


    //
    //  Take the queue lock, get a queue item and put it on the queue
    //

    EnterCriticalSection( &csQueueLock );

    pwqi = AllocateWorkItem();

    if ( !pwqi )
    {
        fRet = SendError( pecb,
                          "500 Not enough memory",
                          "Failed to allocate work queue item" );

        pecb->dwHttpStatusCode = 500;

        LeaveCriticalSection( &csQueueLock );
        CloseHandle( hImpersonationToken );
        return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
    }

    //
    //  Initialize the work queue item and put it at the end of the list
    //

    pwqi->pecb = pecb;
//  pwqi->hImpersonationToken = hImpersonationToken;

    pwqi->ListEntry.Flink = &WorkQueueList;
    pwqi->ListEntry.Blink = WorkQueueList.Blink;

    WorkQueueList.Blink->Flink = &pwqi->ListEntry;
    WorkQueueList.Blink        = &pwqi->ListEntry;

    cQueueItems++;

    LeaveCriticalSection( &csQueueLock );

    //
    //  Signal the pool threads there is work to be done
    //

    ReleaseSemaphore( hWorkSem, 1, NULL );

    return HSE_STATUS_PENDING;
}

DWORD
WINAPI
PoolThread(
    LPDWORD lpParams
    )
/*++

Routine Description:

    This is an ISAPI pool thread

--*/
{
    WORK_QUEUE_ITEM * pwqi;
    DWORD             res;

    while ( TRUE )
    {
        res = WaitForSingleObject( hWorkSem, INFINITE );

        if ( res == WAIT_OBJECT_0 )
        {
            //
            //  There's work to do, grab the queue lock and get the next
            //  work item
            //

            EnterCriticalSection( &csQueueLock );

            if ( WorkQueueList.Flink != &WorkQueueList )
            {
                pwqi = CONTAINING_RECORD( WorkQueueList.Flink,
                                          WORK_QUEUE_ITEM,
                                          ListEntry );

                // WorkQList let go this item, even though the 
				// flink & blink of this item still points to WorkQList
				
				pwqi->ListEntry.Flink->Blink = &WorkQueueList;
                WorkQueueList.Flink          = pwqi->ListEntry.Flink;

                cQueueItems--;
            }
            else
            {
                pwqi = NULL;
            }

            LeaveCriticalSection( &csQueueLock );

            if ( !pwqi )
                continue;

            //
            //  Impersonate the specified user so security is maintained
            //  accessing system resources
            //

//          ImpersonateLoggedOnUser( pwqi->hImpersonationToken );

            SendLotteryNumber( pwqi->pecb );

//          RevertToSelf();

            //
            //  Cleanup this work item
            //

            pwqi->pecb->ServerSupportFunction( pwqi->pecb->ConnID,
                                               HSE_REQ_DONE_WITH_SESSION,
                                               NULL,
                                               NULL,
                                               NULL );

            CloseHandle( pwqi->hImpersonationToken );
            FreeWorkItem( pwqi );
        }
    }

    return 0;
}

BOOL
SendError(
    EXTENSION_CONTROL_BLOCK * pecb,
    CHAR *                    pszStatus,
    CHAR *                    pszMessage
    )
/*++

Routine Description:

    Sends the specified error to the client

Arguments:

    pecb  - pointer to EXTENSION_CONTROL_BLOCK
    pszStatus - Status line of response ("501 Server busy")
    pszMessage - HTML message explaining the failure

Returns:

    TRUE on success, FALSE on failure
--*/
{
    BOOL  fRet;
    DWORD cb;

    //
    //  Send the headers
    //

    fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                        HSE_REQ_SEND_RESPONSE_HEADER,
                                        pszStatus,
                                        NULL,
                                        (LPDWORD) "Content-Type: text/html\r\n\r\n" );

    //
    //  If that succeeded, send the message
    //

    if ( fRet )
    {
        cb = strlen( pszMessage );

        fRet = pecb->WriteClient( pecb->ConnID,
                                  pszMessage,
                                  &cb,
                                  0 );
    }

    return fRet;
}

WORK_QUEUE_ITEM *
AllocateWorkItem(
    VOID
    )
/*++

Routine Description:

    Allocates a work queue item by either retrieving one from the free list
    or allocating it from the heap.

    Note: THE QUEUE LOCK MUST BE TAKEN BEFORE CALLING THIS ROUTINE!

Returns:

    Work queue item on success, NULL on failure
--*/
{
    WORK_QUEUE_ITEM * pwqi;

    //
    //  If the list is not empty, take a work item off the list
    //

    if ( FreeQueueList.Flink != &FreeQueueList )
    {
        pwqi = CONTAINING_RECORD( FreeQueueList.Flink,
                                  WORK_QUEUE_ITEM,
                                  ListEntry );

        pwqi->ListEntry.Flink->Blink = &FreeQueueList;
        FreeQueueList.Flink          = pwqi->ListEntry.Flink;
    }
    else
    {
        pwqi = LocalAlloc( LPTR, sizeof( WORK_QUEUE_ITEM ));
    }

    return pwqi;
}

VOID
FreeWorkItem(
    WORK_QUEUE_ITEM * pwqi
    )
/*++

Routine Description:

    Frees the passed work queue item to the free list

    Note: This routine takes the queue lock.

Arguments:

    pwqi - Work queue item to free

--*/
{
    //
    //  Take the queue lock and put on the free list
    //

    EnterCriticalSection( &csQueueLock );

    pwqi->ListEntry.Flink = FreeQueueList.Flink;
    pwqi->ListEntry.Blink = &FreeQueueList;

    FreeQueueList.Flink->Blink = &pwqi->ListEntry;
    FreeQueueList.Flink        = &pwqi->ListEntry;

    LeaveCriticalSection( &csQueueLock );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\isagen\isagen.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       isagen.cxx

   Abstract:
      This module defines the DLL main and additional functions 
       for the ISAPI DLL that does the general ISAPI tests

   Author:

       Murali R. Krishnan  7-May-1997

   Environment:
       Win32 

   Project:
       Internet Application Server
--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include <windows.h>
#include <iisext.h>
# include "dofunc.hxx"

# include "dbgutil.h"



/************************************************************
 *     Variable Declarations
 ************************************************************/

DECLARE_DEBUG_PRINTS_OBJECT();                  
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisIsAGenGuid, 
0x784d8921, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif

# define MODULE_NAME "isagen.dll"



/************************************************************
 *     Functions
 ************************************************************/


BOOL
ParseAndDispatch( IN EXTENSION_CONTROL_BLOCK * pecb);




BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
      {
          OutputDebugString( " Initializing the global data\n");

          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //


          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return ( fReturn);
}  /* DllLibMain() */




DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    char buff[2048];
    BOOL fReturn;

    
    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( buff,
              "Content-Type: text/html\r\n"
              "\r\n"
              "<head><title>IIS ISAPI Test Application</title></head>\n"
              "<body> This page contains ISAPI test information </body>"
              "<p>"
              "<p>"
              );

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_SEND_RESPONSE_HEADER,
                                       "200 OK",
                                       NULL,
                                       (LPDWORD) buff )
         ) {
        return HSE_STATUS_ERROR;
    }

    fReturn = ParseAndDispatch( pecb);

    // add to this list when we add more probes here

    return (fReturn ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR);
    
} // HttpExtensionProc()





BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    //
    // Initialize various data and modules.
    //
#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( MODULE_NAME, IisIsAGenGuid);
#else
    CREATE_DEBUG_PRINT_OBJECT( MODULE_NAME);
#endif
    if ( !VALID_DEBUG_PRINT_OBJECT()) { 
        return ( FALSE);
    }
#ifdef _NO_TRACING_
    SET_DEBUG_FLAGS( DEBUG_ERROR);
#endif
    
    pver->dwExtensionVersion = MAKELONG( HSE_VERSION_MAJOR, 
                                         HSE_VERSION_MINOR);
    strcpy( pver->lpszExtensionDesc,
           "ISAPI: Get Server Variable Tester" );
    
    return TRUE;
} // GetExtensionVersion()



extern "C"
BOOL WINAPI
TerminateExtension( IN DWORD dwFlags)
/*++
  TerminateExtension()
  o  Standard Entry point called by IIS as the last function.
      It is called to request the unload of the ISAPI dll.
      
  Arugments:
    dwFlags - DWORD flags indicating the state of the unload.

  Returns:
    TRUE on success -> means that the DLL can be unloaded
    and FALSE if the DLL should not be unloaded yet.
--*/
{
    DBGPRINTF(( DBG_CONTEXT, "TerminateExtension (%08x)\n", dwFlags));

    DELETE_DEBUG_PRINT_OBJECT();
    return ( TRUE);
} // TerminateExtension()





BOOL
SendAllInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    return ( SendVariableInfo( pecb)
             );
} // SendAllInfo()



const char * g_pszUsage = 
" <TITLE> IIS ISAPI Tester </TITLE> "
" <HTML> <h2> List of options </h2> "
" <UL> "
" <LI> <A HREF=\"" MODULE_NAME "?Usage\"> Usage Information </A>"
" <LI> <A HREF=\"" MODULE_NAME "?All\"> Send All Information </A>"
" <LI> <A HREF=\"" MODULE_NAME "?gsv\"> Get Server Variables </A>"
" </UL>"
" </HTML>"
;

BOOL
SendUsage( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    DWORD cbBuff = strlen( g_pszUsage);

    return ( pecb->WriteClient( pecb->ConnID, (PVOID ) g_pszUsage,
                                &cbBuff, 0)
             );
} // SendUsage()



BOOL
ParseAndDispatch( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    BOOL fReturn = FALSE;

    if ( pecb == NULL) { 
        return ( FALSE);
    }
    
    if ( (pecb->lpszQueryString == NULL) || (*pecb->lpszQueryString == '\0')) {

        return ( SendUsage( pecb));
    }

    switch ( *pecb->lpszQueryString ) {

    case 'a': case 'A': 
        if ( _stricmp( pecb->lpszQueryString, "All") == 0) {
            fReturn = SendAllInfo( pecb);
        }

        break;

    case 'g': case 'G':
        if ( _stricmp( pecb->lpszQueryString, "gsv") == 0) {
            fReturn = SendVariableInfo( pecb);
        }

        break;

    case 'u': case 'U': 
    default:
        if ( _stricmp( pecb->lpszQueryString, "Usage") == 0) {
            fReturn = SendUsage( pecb);
        } 

        break;
    } // switch()

    return ( fReturn);
} // ParseAndDispatch()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\lottery\worker.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

This program is released into the public domain for any purpose.

Module Name:

    worker.h

Abstract:

    This module is a simple work item for the Multi-Threaded ISAPI example

Revision History:

--*/

BOOL
InitializeLottery(
    VOID
    );

BOOL
SendLotteryNumber(
   EXTENSION_CONTROL_BLOCK  * pecb
   );

VOID
TerminateLottery(
    VOID
    );




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\lottery\worker.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

This program is released into the public domain for any purpose.

Module Name:

    worker.c

Abstract:

    This module is a simple work item for the Multi-Threaded ISAPI example

Revision History:

--*/

#include <windows.h>
#include <httpext.h>

#include "worker.h"
#include <time.h>
#include <stdlib.h>

//
//  Constants
//

//
//  The set of response headers we want to include with the servers.  Note
//  this includes the header terminator
//

#define RESPONSE_HEADERS        "Content-Type: text/html\r\n\r\n"

//
//  Globals
//

//
//  This global variable maintains the current state about the
//  the lottery number generated.
//
//  The lottery number is generated using a combination
//  of the sequence number and a random number generated on the fly.
//

DWORD g_dwLotteryNumberSequence = 0;

//
//  Critical section to protect the global counter.
//

CRITICAL_SECTION  g_csGlobal;

//
//  Prototypes
//

VOID
GenerateLotteryNumber(
    LPDWORD pLotNum1,
    LPDWORD pLotNum2
    );

//
//  Functions
//

BOOL
InitializeLottery(
    VOID
    )
/*++

Routine Description:

    Sets up the initial state for the lottery number generator

Returns:

  TRUE on success, FALSE on failure

--*/
{
    time_t pTime;

    //
    //  Seed the random number generator
    //

    srand(time(&pTime));
    g_dwLotteryNumberSequence = rand();

    InitializeCriticalSection( &g_csGlobal );

    return TRUE;
}

BOOL
SendLotteryNumber(
   EXTENSION_CONTROL_BLOCK  * pecb
   )
/*++

  Routine Description:

    This function sends a randomly generated lottery number back to the client

  Arguments:

    pecb  - pointer to EXTENSION_CONTROL_BLOCK for this request

  Returns:
    TRUE on success, FALSE on failure

--*/
{
    BOOL fRet;
    char rgBuff[2048];

    //
    //  Send the response headers and status code
    //

    fRet = pecb->ServerSupportFunction(
               pecb->ConnID,                 /* ConnID */
               HSE_REQ_SEND_RESPONSE_HEADER, /* dwHSERRequest */
               "200 OK",                     /* lpvBuffer */
               NULL,                         /* lpdwSize. NULL=> send string */
               (LPDWORD ) RESPONSE_HEADERS); /* header contents */

    if ( fRet )
    {
        CHAR  rgchLuckyNumber[40];
        DWORD dwLotNum1, dwLotNum2;
        DWORD cb;

        CHAR  rgchClientHost[200] = "LT";
        DWORD cbClientHost = 200;

        if ( !pecb->GetServerVariable(pecb->ConnID,
                                      "REMOTE_HOST",
                                      rgchClientHost,
                                      &cbClientHost))
        {
            // No host name is available.
            // Make up one

            strcpy(rgchClientHost, "RH");
        }
        else
        {

            // terminate with just two characters
            rgchClientHost[2] = '\0';
        }

        //
        // Generate a lottery number, generate the contents of body and
        //   send the body to client.
        //

        GenerateLotteryNumber( &dwLotNum1, &dwLotNum2);

        //  Lottery Number format is:  Number-2letters-Number.

        wsprintf( rgchLuckyNumber, "%03d-%s-%05d",
                  dwLotNum1,
                  rgchClientHost,
                  dwLotNum2);

        //
        // Body of the message sent back.
        //

        cb = wsprintf( rgBuff,
                      "<head><title>Lucky Number</title></head>\n"
                      "<body><center><h1>Lucky Corner </h1></center><hr>"
                      "<h2>Your lottery number is: "
                      " <i> %s </i></h2>\n"
                      "<p><hr></body>",
                      rgchLuckyNumber);

        fRet = pecb->WriteClient (pecb->ConnID,        /* ConnID */
                                 (LPVOID ) rgBuff,    /* message */
                                 &cb,                 /* lpdwBytes */
                                 0 );                 /* reserved */
    }


    return ( fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR);

} /* SendLotteryNumber */

VOID
TerminateLottery(
    VOID
    )
{
    DeleteCriticalSection( &g_csGlobal );
}

VOID
GenerateLotteryNumber(
    LPDWORD pLotNum1,
    LPDWORD pLotNum2
    )
{
    DWORD dwLotteryNum;
    DWORD dwModulo;

    //
    // Obtain the current lottery number an increment the counter
    // To keep this multi-thread safe use critical section around it
    //

    EnterCriticalSection( &g_csGlobal);

    dwLotteryNum = g_dwLotteryNumberSequence++;

    LeaveCriticalSection( &g_csGlobal);

    // obtain a non-zero modulo value

    do {
        dwModulo = rand();
    } while ( dwModulo == 0);

    // split the lottery number into two parts.

    *pLotNum1 = (dwLotteryNum / dwModulo);
    *pLotNum2 = (dwLotteryNum % dwModulo);

    return;

} // GenerateLotteryNumber()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\rcasync\rcasync.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rasync.c

Abstract:

    This module tests the web server's server extension interface

Author:

    Stanle Tam (stanleyt)   4-June 1997
    
Revision History:
  
--*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <iisext.h>

#define MAX_BUF_SIZE    49152               // 48 K - max number of bytes for each read
#define PARC_IO_CTX     LPDWORD             // Context for Async ReadClient 

//
// Number of bytes read so far - pContext of the IO completion routine
//
PARC_IO_CTX             pByteReadSoFar;     

//
//  Buffer to store bytes each time that read from client
//
BYTE                    g_ReadBuffer[MAX_BUF_SIZE] = {0};

DWORD
SendHeaderToClient(IN LPEXTENSION_CONTROL_BLOCK pecb, 
                   IN LPCSTR pszErrorMsg);

DWORD
DoReadClient(IN LPEXTENSION_CONTROL_BLOCK pecb);
             
VOID WINAPI
AsyncReadClientIoCompletion(IN LPEXTENSION_CONTROL_BLOCK pecb, 
                            IN PVOID pContext,
                            IN DWORD cbIO,
                            IN DWORD dwError);

BOOL
ValidBytes (IN LPEXTENSION_CONTROL_BLOCK    pecb, 
            IN BYTE                       * pbSrc, 
            IN DWORD                        dwByteRead,
            OUT LPDWORD                     dwOffSet);

DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 fReturn Value:

    fReturns TRUE is successful; otherwise FALSE is fReturned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
      {
          //
          // Initialize various data and modules.
          //

          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          if ( lpvContext != NULL) {

          }

          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return (fReturn);
}  /* DllLibMain() */


BOOL WINAPI
GetExtensionVersion(HSE_VERSION_INFO * Version)
{
    Version->dwExtensionVersion = 
    MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    strcpy(Version->lpszExtensionDesc, "Async Read Client Test ISAPI DLL");

    return TRUE;
}


DWORD WINAPI
HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pecb)   
{
    DWORD hseStatus;
    DWORD cbExpectedByteRead;
    
    cbExpectedByteRead = (DWORD)atol(pecb->lpszQueryString);

    if (0 == strcmp(pecb->lpszQueryString, "")) {
                                                                                    
        hseStatus = SendHeaderToClient(
                        pecb, 
                        "Expected total number of bytes from client is not specified.");
    
    } else if ( (DWORD)atol(pecb->lpszQueryString) != pecb->cbTotalBytes ) {
    
        hseStatus = SendHeaderToClient(
                        pecb, 
                        "Expected total number of bytes from client \
                         does not match with pecb->cbTotalBytes.");
    } else {
        
        hseStatus = DoReadClient( pecb );
    }
   
    return (hseStatus);
}


BOOL WINAPI
TerminateExtension(DWORD dwFlags)
{
    return TRUE;
}


DWORD
SendHeaderToClient(IN LPEXTENSION_CONTROL_BLOCK  pecb, IN LPCSTR pszErrorMsg)
{
    CHAR szBuff[MAX_PATH] = "";

    //
    //  The HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf(szBuff,
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Simple Async Read Client</title></head>\n"
             "<body><h1>%s</h1>\n",
             pszErrorMsg );

    if ( !pecb->ServerSupportFunction(  pecb->ConnID,
                                        HSE_REQ_SEND_RESPONSE_HEADER,
                                        "200 OK",
                                        NULL,
                                        (LPDWORD) szBuff)
        ) {

        return (HSE_STATUS_ERROR);
    }

    return (HSE_STATUS_SUCCESS);
} 


DWORD
DoReadClient(IN LPEXTENSION_CONTROL_BLOCK pecb)
{
    char    szHeader[256] = "";
    BOOL    fReturn = TRUE;
    DWORD   dwFlags;
    DWORD   dwLocation;    
    DWORD   cbTotalToRead = MAX_BUF_SIZE;
    DWORD   hseStatus = HSE_STATUS_PENDING;
    
    //
    // Firstly, check if there is any corrupted byte in the 
    // first chunk (the first chunk could be the last chunk, ie
    // when cbAvailable==cbToTalBytes). Expecting the client to send 
    // bytes in the format of "0123456789012345678....".
    //
        
    dwLocation = 0;
    if ( ! ValidBytes ( pecb, 
                        pecb->lpbData,      // check these bytes 
                        pecb->cbAvailable,  // number of bytes read
                        &dwLocation)) {     // offset, 0 = starts from the first byte
        
        wsprintf( szHeader, "Bad data at location %d.", dwLocation);
        hseStatus = SendHeaderToClient(pecb, szHeader);
        fReturn =
        pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_DONE_WITH_SESSION,
            &hseStatus,
            NULL,
            NULL);

            return (HSE_STATUS_ERROR);
    }
             
    //
    // Check if cbTotalBytes == cbAvailable
    // if so lpbData contains all the data sent by 
    // the client, and complete the session. Very likely..
    //

    if (pecb->cbTotalBytes == pecb->cbAvailable) {

        wsprintf (szHeader, 
                        "ECB Total Bytes: %d. Actual Read Bytes: %d", 
                        pecb->cbTotalBytes, 
                        pecb->cbAvailable );

        hseStatus = SendHeaderToClient(pecb, szHeader);

        fReturn =
        pecb->ServerSupportFunction(
                pecb->ConnID,
                HSE_REQ_DONE_WITH_SESSION,
                &hseStatus,
                NULL,
                NULL);
        
        if (!fReturn || hseStatus == HSE_STATUS_ERROR) {
            hseStatus = HSE_STATUS_ERROR;
        } else {
            hseStatus = HSE_STATUS_SUCCESS;
        }

        return (hseStatus);
    }
    
    //
    // Initialize the context for ReadClient
    //
    
    pByteReadSoFar = &(pecb->cbAvailable);
    
    fReturn =
    pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_IO_COMPLETION,
            AsyncReadClientIoCompletion,
            0,
            pByteReadSoFar);
    
    if (!fReturn) {
        hseStatus = HSE_STATUS_ERROR;
    }
    
    dwFlags = HSE_IO_ASYNC;
    fReturn = 
    pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_ASYNC_READ_CLIENT,
            g_ReadBuffer,
            &cbTotalToRead,
            &dwFlags);

    if (!fReturn) {
        hseStatus = HSE_STATUS_ERROR;
    }

    return (hseStatus);
}


VOID WINAPI
AsyncReadClientIoCompletion(
            IN LPEXTENSION_CONTROL_BLOCK pecb,
            IN PVOID pContext,
            IN DWORD cbIO,
            IN DWORD dwError)
/*++

Routine Description:

    This is the io completion routine for ReadClient

Arguments:

    pecb        - extension control block
    pContext    - Context for Async ReadClient 
    cbIO        - bytes read
    dwError     - error on read

fReturn Value:

    None

--*/
{
    BOOL    fReturn;
    DWORD   dwFlags;
    DWORD   dwOffSet;
    DWORD   cbTotalToRead = MAX_BUF_SIZE;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    LPDWORD pcbTotalReadSoFar = (LPDWORD) pContext;
    
     if (ERROR_SUCCESS == dwError) {
        
        char szHeader[100] = "";

        dwOffSet = *pcbTotalReadSoFar;      // where it left off last time
        *pcbTotalReadSoFar += cbIO;         // update current total bytes read
        
        if ( ! ValidBytes ( pecb, 
                            g_ReadBuffer,   // check these bytes 
                            cbIO,           // number of bytes read 
                            &dwOffSet   
                           )) {
            wsprintf( szHeader, "Bad data at location %d.", dwOffSet );
            hseStatus = SendHeaderToClient(pecb, szHeader);
            fReturn =
            pecb->ServerSupportFunction(
                    pecb->ConnID,
                    HSE_REQ_DONE_WITH_SESSION,
                    &hseStatus,
                    NULL,
                    NULL);
        }
         
        //
        // if they are equal, ie all bytes are read
        //
        
        if (*pcbTotalReadSoFar  >= pecb->cbTotalBytes ) { 
            
            wsprintf (szHeader, 
                        "ECB Total Bytes: %d. Actual Read Bytes: %d", 
                        pecb->cbTotalBytes, 
                        *pcbTotalReadSoFar );

            hseStatus = SendHeaderToClient(pecb, szHeader);

            fReturn =
            pecb->ServerSupportFunction(
                pecb->ConnID,
                HSE_REQ_DONE_WITH_SESSION,
                &hseStatus,
                NULL,
                NULL);

            if (!fReturn) {
                hseStatus = HSE_STATUS_ERROR;
            }
        //
        // Read remaining bytes
        //
        } else {
  
            dwFlags = HSE_IO_ASYNC;
            fReturn = 
            pecb->ServerSupportFunction(
                pecb->ConnID,
                HSE_REQ_ASYNC_READ_CLIENT,
                g_ReadBuffer,
                &cbTotalToRead,
                &dwFlags);
        }
    //
    // Error on read
    //
    } else {

        hseStatus = dwError;
    }

    if (hseStatus != HSE_STATUS_SUCCESS) {
        
        fReturn =
        pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_DONE_WITH_SESSION,
            &hseStatus,
            NULL,
            NULL);
    }
}


/*++

 Routine Description:

   This function checks if any byte in the buffer is corrupted.
    
 Arguments:

   pecb         ECB
   pbSrc        The source buffer
   dwByteRead   Number of bytes read
   dwOffSet     [IN]  Start from where it left out in last read
                [OUT] Return the location of the first invalid byte
                      only if this returns FALSE

 fReturn Value:

    TRUE - All bytes are valid
    FALSE -  Discovered bad byte and return its location
    

--*/
BOOL
ValidBytes (IN  LPEXTENSION_CONTROL_BLOCK pecb, 
            IN  BYTE * pbSrc, 
            IN  DWORD dwBytesRead, 
            OUT LPDWORD pbOffSet)
{
    DWORD   i;
    BOOL    fValidByte = TRUE;
    
     for (i = 0; i < dwBytesRead; i++) {

        if (pbSrc[i] != ((*pbOffSet + i) % 10) + '0') {
            if ( ((i + *pbOffSet) == pecb->cbTotalBytes) && 
                 (pbSrc[i] == 0x0d) &&
                 (pbSrc[i+1] == 0x0a)) {
       
                break;  // ALL good bytes

            } else {    

                fValidByte = FALSE;
                *pbOffSet = i;
                
                break;  // First bad byte
            } 
        } 
     } 

     return (fValidByte);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\isagen\dofunc.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
     dofunc.cxx

   Abstract:
     This module contains the support functions for 
      Internet Server Application test object.

   Author:

       Murali R. Krishnan    ( MuraliK )     05-Dec-1996 

   Environment:
       User Mode - Win32
       
   Project:

       Internet Application Server Test DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "windows.h"
# include "dofunc.hxx"


/************************************************************
 *    Functions 
 ************************************************************/

# define DefunVariable( a)  { #a , sizeof(#a) }

struct _VAR_INFO {
    char * pszName;
    int    cbSize;
} sg_rgVarInfo[] = {

    {"<hr> <h3> Various Variables </h3> <DL>", 0 },
    {" <br> <DT> <b> Generic Objects </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunVariable( ALL_HTTP),
    DefunVariable( ALL_RAW),
    DefunVariable( APPL_MD_PATH),
    DefunVariable( APPL_PHYSICAL_PATH),
    DefunVariable( AUTH_TYPE),
    DefunVariable( AUTH_USER),
    DefunVariable( AUTH_PASSWORD),
    
    DefunVariable( CONTENT_LENGTH),
    DefunVariable( CONTENT_TYPE),

    DefunVariable( CERT_SUBJECT),
    DefunVariable( CERT_ISSUER),
    DefunVariable( CERT_FLAGS),
    DefunVariable( CERT_SERIALNUMBER),
    DefunVariable( CERT_COOKIE),
    DefunVariable( CERT_KEYSIZE),
    DefunVariable( CERT_SECRETKEYSIZE),
    DefunVariable( CERT_SERVER_SUBJECT),
    DefunVariable( CERT_SERVER_ISSUER),
    
    DefunVariable( HTTP_REQ_REALM),
    DefunVariable( HTTP_REQ_PWD_EXPIRE),
    DefunVariable( HTTP_CFG_ENC_CAPS),

    DefunVariable( HTTP_ACCEPT),
    DefunVariable( HTTP_URL),
    DefunVariable( HTTP_COOKIE),
    DefunVariable( HTTP_USER_AGENT),
    
    DefunVariable( HTTPS),
    DefunVariable( HTTPS_SUBJECT),
    DefunVariable( HTTPS_ISSUER),
    DefunVariable( HTTPS_FLAGS),
    DefunVariable( HTTPS_SERIALNUMBER),
    DefunVariable( HTTPS_COOKIE),
    DefunVariable( HTTPS_KEYSIZE),
    DefunVariable( HTTPS_SECRETKEYSIZE),
    DefunVariable( HTTPS_SERVER_SUBJECT),
    DefunVariable( HTTPS_SERVER_ISSUER),

    DefunVariable( GATEWAY_INTERFACE),

    DefunVariable( INSTANCE_ID),
    DefunVariable( INSTANCE_META_PATH),

    DefunVariable( LOCAL_ADDR),
    DefunVariable( LOGON_USER),
    
    DefunVariable( PATH_INFO),
    DefunVariable( PATH_TRANSLATED),

    DefunVariable( QUERY_STRING),
    
    DefunVariable( REQUEST_METHOD),
    DefunVariable( REMOTE_HOST),
    DefunVariable( REMOTE_ADDR),
    DefunVariable( REMOTE_USER),

    DefunVariable( SCRIPT_NAME),
    DefunVariable( SERVER_NAME),
    DefunVariable( SERVER_PROTOCOL),
    DefunVariable( SERVER_PORT),
    DefunVariable( SERVER_PORT_SECURE),
    DefunVariable( SERVER_SOFTWARE),
    
    DefunVariable( UNMAPPED_REMOTE_USER),
    DefunVariable( URL),
    
    {"</TABLE>", 0}
}; // sg_rgVariables[]

# define MAX_NUM_VARIABLES (sizeof(sg_rgVarInfo) /sizeof(sg_rgVarInfo[0]))



BOOL
SendVariableInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    char buff[MAX_NUM_VARIABLES * 500];
    int  i;
    DWORD cb = 0;

    for( i = 0; (i < MAX_NUM_VARIABLES) && (cb < sizeof(buff)); i++) {

        if ( sg_rgVarInfo[i].cbSize == 0) {
            // special control formatting - echo the pszName plainly.
            cb += wsprintf( buff + cb, sg_rgVarInfo[i].pszName);
        } else {
            
            //
            // Get the server Variable and print it out.
            //

            DWORD cbVar;
            cb += wsprintf( buff + cb, 
                            "<TR> <TD> %s</TD> <TD>",
                            sg_rgVarInfo[i].pszName
                            );
            
            //
            // do a GetServerVariable()
            //
            
            cbVar = sizeof( buff) - 100 - cb;
            if (pecb->GetServerVariable( pecb->ConnID, 
                                         sg_rgVarInfo[i].pszName,
                                         buff + cb,
                                         &cbVar)
                ) {
                
                //
                // print out the trailing part of the variable
                //
                cb += cbVar - 1; // adjust for trailing '\0'
                cb += wsprintf( buff + cb,
                                "</TD> </TR>");
            } else {

                cb += wsprintf( buff + cb,
                                "Error = %d </TD> </TR>", GetLastError());
                
            }
        }
    } // for

    return ( pecb->WriteClient( pecb->ConnID, buff, &cb, 0));
} // SendVariableInfo()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\cofact.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\readcli\readcli.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    readcli.c

Abstract:

    This module absorbs input from the client.

Author:

    Tony Godfrey (tonygod)   20-Mar-1997

Revision History:
--*/

#include <windows.h>
#include <httpext.h>
#include <stdio.h>
#include <stdlib.h>

BOOL g_bWriteToFile;

BOOL WriteToFile( CHAR *szFileName, CHAR *szBuffer );

BOOL GetExtensionVersion( HSE_VERSION_INFO *Version )
{
    Version->dwExtensionVersion = 
    MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    strcpy(Version->lpszExtensionDesc, "BGI null extension");

    return TRUE;
}

DWORD HttpExtensionProc( LPEXTENSION_CONTROL_BLOCK pec )
{
    DWORD TotalSize;
    DWORD BytesRead;
    DWORD BytesWritten;
    DWORD TotalRead;
    DWORD TotalWritten;
    DWORD dwContentLength;
    DWORD dwBufferSize;
    BOOL ValidData = TRUE;
    BOOL bResult;
    CHAR *TmpPtr;
    char InvalidReason[80] = "";
    CHAR *Buffer;
    CHAR TmpBuf[4096];
    DWORD i;
    BOOL Return;
    CHAR szTemp[4096];
    CHAR szStatusFile[255];
    CHAR szOutputFile[255];

    dwBufferSize = sizeof( TmpBuf );
    pec->GetServerVariable(
        pec->ConnID,
        "CONTENT_LENGTH",
        TmpBuf,
        &dwBufferSize
        );
    dwContentLength = atol( TmpBuf );

    Buffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwContentLength + 5 );

    TmpPtr = pec->lpbData;
    if ( pec->cbAvailable == 0 ) {
        pec->ServerSupportFunction(
            pec->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER,
            "200 OK",
            NULL,
            (LPDWORD) TEXT("Content-type: text/html\r\n\r\n")
        );
        BytesWritten = wsprintf( 
            szTemp, 
            "<h3>Error: Your request did not contain any data</h3><p>\r\n\r\n"
            "Usage: readcli.dll/&lt;outputpath&gt;<p>\r\n\r\n"
            "Request must be a POST request, with extra data<p>\r\n"
            "Output path will contain OUTPUT.TXT and STATUS.TXT<p>\r\n"
            "lpszPathInfo = %s<br>\r\n"
            "lpszPathTranslated = %s<p><hr>\r\n"
            "<h2>Sample Form</h2>\r\n"
            "Enter data below:<br>\r\n"
            "<form method=POST action=\"%s/readcli.dll%s\">\r\n"
            "<input type=text name=test size=80><br>\r\n"
            "<input type=submit>\r\n",
            pec->lpszPathInfo,
            pec->lpszPathTranslated,
            pec->lpszPathInfo,
            pec->lpszPathInfo
            );
        bResult = pec->WriteClient(
            pec->ConnID,
            szTemp,
            &BytesWritten,
            0
            );
        HeapFree( GetProcessHeap(), 0, Buffer );
        if ( !bResult ) {
            return( HSE_STATUS_ERROR );
        }
        return( HSE_STATUS_SUCCESS );
    }

    if ( !pec->lpszPathInfo[0] ) {
        g_bWriteToFile = FALSE;
    } else {
        g_bWriteToFile = TRUE;
    }

/********************************************** DEAD CODE
        pec->ServerSupportFunction(
            pec->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER,
            "200 OK",
            NULL,
            (LPDWORD) TEXT("Content-type: text/html\r\n\r\n")
        );
        BytesWritten = wsprintf( szTemp, 
                                 "<h3>Error: Your request did not contain an output path</h3><p>\r\n\r\n"
                                 "Usage: readcli.dll/&lt;outputpath&gt;<p>\r\n\r\n"
                                 "Request must be a POST request, with extra data<p>\r\n\r\n"
                                 "Output path will contain OUTPUT.TXT and STATUS.TXT<p>\r\n"
                                 "lpszPathInfo = %s<br>\r\n"
                                 "lpszPathTranslated = %s\r\n",
                                 pec->lpszPathInfo,
                                 pec->lpszPathTranslated
                                 );
        bResult = pec->WriteClient(
            pec->ConnID,
            szTemp,
            &BytesWritten,
            0
            );
        HeapFree( GetProcessHeap(), 0, Buffer );
        if ( !bResult ) {
            return( HSE_STATUS_ERROR );
        }
        return (HSE_STATUS_SUCCESS);
    }
**************************************************************/
    if ( g_bWriteToFile ) {
        wsprintf( szStatusFile, "%s\\status.txt", pec->lpszPathTranslated );
        wsprintf( szOutputFile, "%s\\output.txt", pec->lpszPathTranslated );
        wsprintf( szTemp, "pec->cbAvailable = %d\r\n", pec->cbAvailable );
        WriteToFile( szStatusFile, szTemp );
    }

    TotalWritten = 0;
    lstrcpyn( Buffer, TmpPtr, pec->cbAvailable );
    Buffer[pec->cbAvailable] = 0;

    TotalRead = pec->cbAvailable;

    while ( TotalRead < pec->cbTotalBytes ) {
        BytesRead = sizeof( TmpBuf );
        Return = pec->ReadClient(
            pec->ConnID,
            TmpBuf,
            &BytesRead);
        if (!Return) {
            if ( g_bWriteToFile ) {
                wsprintf( szTemp, "ReadClient failed: %ld\r\n\r\n", GetLastError() );
                WriteToFile( szStatusFile, szTemp );
            }
            HeapFree( GetProcessHeap(), 0, Buffer );
            lstrcpy( InvalidReason, "FALSE returned from ReadClient" );
            return( HSE_STATUS_ERROR );
        }
        TmpBuf[BytesRead] = 0;

        if (BytesRead != 0) {
            lstrcat( Buffer, TmpBuf );
        }
        TotalRead += BytesRead;
        if ( g_bWriteToFile ) {
            wsprintf( szTemp, "BytesRead = %ld\r\n", BytesRead );
            WriteToFile( szStatusFile, szTemp );
            wsprintf( szTemp, "TotalRead = %ld\r\n\r\n", TotalRead );
            WriteToFile( szStatusFile, szTemp );
        }
    }

    if ( g_bWriteToFile && (TotalRead != dwContentLength) ) {
        wsprintf( 
            szTemp, 
            "ERROR: TotalRead = %ld, dwContentLength = %ld\r\n\r\n",
            TotalRead,
            dwContentLength
            );
        WriteToFile( szStatusFile, szTemp );
    }
    pec->ServerSupportFunction(
        pec->ConnID,
        HSE_REQ_SEND_RESPONSE_HEADER,
        "200 OK",
        NULL,
        (LPDWORD) TEXT("Content-type: text/html\r\n\r\n")
        );
    BytesWritten = TotalRead;
    bResult = pec->WriteClient(
        pec->ConnID,
        Buffer,
        &BytesWritten,
        0
        );
    if ( !bResult ) {
        if ( g_bWriteToFile ) {
            wsprintf( szTemp, "WriteClient failed: %ld\r\n\r\n", GetLastError() );
            WriteToFile( szStatusFile, szTemp );
        }
        HeapFree( GetProcessHeap(), 0, Buffer );
        lstrcpy( InvalidReason, "FALSE returned from WriteClient" );
        return( HSE_STATUS_ERROR );
    }
    if ( g_bWriteToFile ) {
        bResult = WriteToFile( szOutputFile, Buffer );
        if ( !bResult ) {
            wsprintf( 
                szTemp, 
                "ERROR: WriteToFile(%s) failed: %ld\r\n\r\n", 
                szOutputFile, 
                GetLastError() 
                );
            WriteToFile( szStatusFile, szTemp );
        }
        wsprintf( szTemp, "BytesWritten = %ld\r\n\r\n", BytesWritten );
        WriteToFile( szStatusFile, szTemp );
        if ( BytesWritten != TotalRead ) {
            wsprintf( 
                szTemp, 
                "ERROR: BytesWritten = %ld, TotalRead = %ld\r\n\r\n",
                BytesWritten,
                TotalRead
                );
            WriteToFile( szStatusFile, szTemp );
        }
    }
    HeapFree( GetProcessHeap(), 0, Buffer );
    return (HSE_STATUS_SUCCESS);
}



BOOL WriteToFile( CHAR *szFileName, CHAR *szBuffer )
{
	HANDLE hFile;
	DWORD dwBytesWritten;

	hFile = CreateFile(
		szFileName,
		GENERIC_WRITE,
		FILE_SHARE_READ,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
	if ( hFile == INVALID_HANDLE_VALUE ) {
		return FALSE;
	}

	SetFilePointer(
		hFile,
		0,
		NULL,
		FILE_END
		);

	WriteFile(
		hFile,
		szBuffer,
		lstrlen( szBuffer ),
		&dwBytesWritten,
		NULL
		);
	
	CloseHandle( hFile );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\auxfunc.h ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: Auxfunc.h

    supporting functions header file.

Owner: LeiJin

Note:

===================================================================*/

#ifndef _WAMREG_AUXFUNC_H
#define _WAMREG_AUXFUNC_H

#include "iadmw.h"
#include "comadmin.h"
#include "wmrgexp.h"
#include "dbgutil.h"
#include "iwamreg.h"
#include "iiscnfg.h"

// EMD_SET        an action to set the corresponding metabase identifier in metabase.
// EMD_DELETE   an action to delete the corresponding metabase identifier in metabase.
// EMD_NONE        an NO-OP action.
#define    EMD_SET       1
#define    EMD_DELETE    2
#define    EMD_NONE      0

// MDPropItem
// Used in WamRegMetabaseConfig, usually created an array of MDPropItem where each elment represents
// one WAMREG application property. 
// 
struct MDPropItem
{
    DWORD    dwMDIdentifier;    // Metabase Indetitifer
    DWORD    dwType;            // Metabase data type
    union
        {
        DWORD    dwVal;        // used if dwType is a METADATA_DWORD type.
        WCHAR*    pwstrVal;    // used if dwType is a METADATA_STRING type.
        };

    DWORD    dwAction;        // EMD_SET / EMD_DELETE / EMD_NONE
    
    HRESULT    hrStatus;
};

//
// Index to Wam Metabase Property
// Each one represents one WAMREG application related metabase property.
//
#define IWMDP_ROOT                0
#define IWMDP_ISOLATED            1
#define IWMDP_WAMCLSID            2
#define IWMDP_PACKAGEID           3
#define IWMDP_PACKAGE_NAME        4
#define IWMDP_LAST_OUTPROC_PID    5
#define IWMDP_FRIENDLY_NAME       6
#define IWMDP_APPSTATE            7
#define IWMDP_OOP_RECOVERLIMIT    8
#define IWMDP_OOP_APP_APPPOOL_ID  9
// Max of the above property.
#define IWMDP_MAX                 10

//
// WamAdmLock is used to create an "Critical Section" when perserve the order of App Create/Delete/etc.
// requests.
//
class WamAdmLock
{
public:
    WamAdmLock();
    BOOL Init();                // Init the WamAdmLock data member.
    BOOL UnInit();                // Uninit the WamAdmLock data member

    VOID AcquireWriteLock();    // Acquire the Lock
    VOID ReleaseWriteLock();    // Release the Lock.

private:

    DWORD    GetNextServiceToken();    
    VOID    Lock();                // Internal CS lock.
    VOID    UnLock();            // Internal CS unlock.

    // Data    
    DWORD                m_dwServiceToken;
    DWORD                m_dwServiceNum;
    HANDLE                m_hWriteLock;
    CRITICAL_SECTION    m_csLock;
};

inline VOID WamAdmLock::Lock()
{
    EnterCriticalSection(&m_csLock);
}

inline VOID WamAdmLock::UnLock()
{
    LeaveCriticalSection(&m_csLock);
}


//
//    WamRegGlobal
//    Contains some default global constant.
//    Contains a WamAdmLock memeber for DCOM level request locking.
//
class WamRegGlobal
{
public:
    WamRegGlobal()    {};
    ~WamRegGlobal()    {};
    BOOL    Init();
    BOOL    UnInit();
    
    VOID    AcquireAdmWriteLock(VOID);
    VOID    ReleaseAdmWriteLock(VOID);

    HRESULT CreatePooledApp
                    ( 
                    IN LPCWSTR szMetabasePath,
                    IN BOOL fInProc,
                    IN BOOL fRecover = FALSE 
                    );
                    
    HRESULT CreateOutProcApp
                    ( 
                    IN LPCWSTR szMetabasePath,
                    IN BOOL fRecover = FALSE,
                    IN BOOL fSaveMB = TRUE 
                    );

    HRESULT CreateOutProcAppReplica
                    (
                    IN LPCWSTR szMetabasePath,
                    IN LPCWSTR szAppName,
                    IN LPCWSTR szWamClsid,
                    IN LPCWSTR szAppId
                    );
                    
    HRESULT DeleteApp
                    (
                    IN LPCWSTR szMetabasePath,
                    IN BOOL fRecoverable,
                    IN BOOL fRemoveAppPool
                    );

    HRESULT RecoverApp
                    (
                    IN LPCWSTR szMetabasePath,
                    IN BOOL fForceRecover
                    );
                    
    HRESULT    SzWamProgID    
                    (
                    IN LPCWSTR pwszMetabasePath,
                    OUT LPWSTR *ppszWamProgID
                    );

    HRESULT W3ServiceUtil
                    (
                    IN LPCWSTR szMDPath,
                    IN DWORD    dwCommand,
                    OUT DWORD*    dwCallBackResult
                    );

    HRESULT ConstructFullPath
                    (
                    IN LPCWSTR pwszMetabasePathPrefix,
                    IN DWORD dwcPrefix,
                    IN LPCWSTR pwszPartialPath,
                    OUT LPWSTR* ppwszResult
                    );

    BOOL    FAppPathAllowConfig
                    (
                    IN LPCWSTR    wszMetabasePath
                    );

	BOOL	FIsW3SVCRoot
					(
					IN LPCWSTR	wszMetabasePath
					);

private:
    HRESULT    GetNewSzGUID
                    (
                    OUT LPWSTR *ppszGUID
                    );    

    HRESULT    GetViperPackageName    
                    (
                    IN LPCWSTR      wszMetabasePath,
                    OUT LPWSTR*     pwszViperPackageName
                    );    

public:

    //Global Constant, self explained.
    static    const WCHAR g_szIISInProcPackageName[/*sizeof(DEFAULT_PACKAGENAME)/sizeof(WCHAR)*/];
    static    const WCHAR g_szIISInProcPackageID[];
    static    const WCHAR g_szInProcWAMCLSID[];
    static    const WCHAR g_szInProcWAMProgID[];
    
    static    const WCHAR g_szIISOOPPoolPackageName[];   
    static    const WCHAR g_szIISOOPPoolPackageID[];
    static    const WCHAR g_szOOPPoolWAMCLSID[];
    static    const WCHAR g_szOOPPoolWAMProgID[];

    static    const WCHAR g_szMDAppPathPrefix[];
    static    const DWORD g_cchMDAppPathPrefix;
    static	  const WCHAR g_szMDW3SVCRoot[];
    static	  const DWORD g_cchMDW3SVCRoot;
    
private:
    static    WamAdmLock    m_WamAdmLock;    // a lock for all DCOM level requests.
};

inline VOID WamRegGlobal::AcquireAdmWriteLock(VOID)
{
    m_WamAdmLock.AcquireWriteLock();
}

inline VOID WamRegGlobal::ReleaseAdmWriteLock(VOID)
{
    m_WamAdmLock.ReleaseWriteLock();
}

//
//    WamRegRegistryConfig
//    Contains functions that access the Reigstry.
//
class WamRegRegistryConfig
{
public:

    WamRegRegistryConfig()        {};
    ~WamRegRegistryConfig()        {};
    HRESULT RegisterCLSID
                        (    
                        IN LPCWSTR szCLSIDEntryIn,
                        IN LPCWSTR szProgIDIn,
                        IN BOOL    fSetVIProgID
                        );

    HRESULT UnRegisterCLSID
                        (
                        IN LPCWSTR wszCLSIDEntryIn, 
                        IN BOOL fDeleteVIProgID
                        );
                        
    HRESULT LoadWamDllPath(VOID);
private:
    
    HRESULT UnRegisterProgID
            (
            IN LPCWSTR szProgIDIn
            );

    static    const REGSAM    samDesired;
    static    CHAR    m_szWamDllPath[MAX_PATH];

};

//
//    WamRegPackageConfig
//    Contains functions that access the MTS Admin API.
//    Class defined to access MTS Admin interface.
//
class WamRegPackageConfig    
{
public:
    WamRegPackageConfig();
    ~WamRegPackageConfig();
    
    HRESULT     CreateCatalog(VOID);        //Create an MTS catalog object
    VOID        Cleanup( VOID);             // used for cleaning up state

    HRESULT     CreatePackage
                        (    
                        IN LPCWSTR    szPackageID,
                        IN LPCWSTR    szPackageName,
                        IN LPCWSTR    szIdentity,
                        IN LPCWSTR    szIdPassword,
                        IN BOOL        fInProc
                        );

    HRESULT     RemovePackage
                        (    
                        IN LPCWSTR    szPackageID
                        );
    
    HRESULT     AddComponentToPackage
                        (    
                        IN LPCWSTR    szPackageID,
                        IN LPCWSTR    szComponentCLSID
                        );

    HRESULT     RemoveComponentFromPackage
                        (    
                        IN LPCWSTR szPackageID,
                        IN LPCWSTR szComponentCLSID,
                        IN DWORD   dwAppIsolated
                        );

    BOOL        IsPackageInstalled
                        (
                        IN LPCWSTR szPackageID,
                        IN LPCWSTR szComponentCLSID
                        );

    HRESULT     GetSafeArrayOfCLSIDs    // Create an one element SafeArray object that contains szComponentCLSID
                        (
                        IN LPCWSTR    szComponentCLSID,
                        OUT SAFEARRAY**    pm_aCLSID
                        );
                        
    VOID    ReleaseAll(VOID);
private:

    enum TECatelogObject{eTPackage, eTComponent};

    HRESULT SetPackageProperties( IN LPCWSTR    * rgpszValues);
    HRESULT    SetPackageObjectProperty    
                        (
                        IN LPCWSTR    szPropertyName,
                        IN LPCWSTR    szPropertyValue
                        );

    HRESULT SetComponentObjectProperties(
                                         IN LPCWSTR    szComponentCLSID
                                         );
    HRESULT    SetComponentObjectProperty    
                        (
                        IN ICatalogObject * pComponent,
                        IN LPCWSTR          szPropertyName,
                        IN LPCWSTR          szPropertyValue,
                        BOOL                fPropertyValue = FALSE
                        );

    ICOMAdminCatalog*       m_pCatalog;
    ICatalogCollection*     m_pPkgCollection;
    ICatalogCollection*     m_pCompCollection;
    ICatalogObject*         m_pPackage;

};

//
//    WamRegMetabaseConfig
//    Class defined to access the metabase, read/write application properties from/to Metabase.
//
class WamRegMetabaseConfig
{
public:

    static HRESULT MetabaseInit
                    (
                    VOID
                    );

    static HRESULT MetabaseUnInit
                    (
                    VOID
                    );
    
    static BOOL Initialized( VOID )
    {
        return ( m_pMetabase != NULL );
    }

    HRESULT UpdateMD    
                    (
                    IN MDPropItem*      prgProp,
                    IN DWORD            dwMDAttributes,
                    IN LPCWSTR          wszMetabasePath,
                    IN BOOL             fSaveData = FALSE
                    );
                    
    HRESULT MDUpdateIISDefault
                    (    
                    IN LPCWSTR    szIISPackageName,
                    IN LPCWSTR    szIISPackageID,
                    IN LPCWSTR    szDefaultWAMCLSID
                    );

    HRESULT AbortUpdateMD
                    (
                    IN MDPropItem*     prgProp,
                    IN LPCWSTR        wszMetabasePath
                    );
                    
    HRESULT MDCreatePath
                    (
                    IN IMSAdminBase *pMetabaseIn,
                    IN LPCWSTR szMetabasePath
                    );

    BOOL    MDDoesPathExist
                    (
                    IN IMSAdminBase *pMetabaseIn,
                    IN LPCWSTR szMetabasePath
                    );

    HRESULT MDSetStringProperty
                    (
                    IN IMSAdminBase * pMetabaseIn,
                    IN LPCWSTR szMetabasePath,
                    IN DWORD szMetabaseProperty,
                    IN LPCWSTR szMetabaseValue,
                    IN DWORD dwMDUserType = IIS_MD_UT_WAM
                    );

    HRESULT MDSetKeyType
                    (
                    IN IMSAdminBase * pMetabaseIn,
                    IN LPCWSTR szMetabasePath,
                    IN LPCWSTR szKeyType
                    );

    HRESULT MDDeleteKey
                    (
                    IN IMSAdminBase * pMetabaseIn,
                    IN LPCWSTR szMetabasePath,
                    IN LPCWSTR szKey
                    );

    HRESULT MDGetDWORD
                    (
                    IN LPCWSTR szMetabasePath, 
                    IN DWORD dwMDIdentifier,
                    OUT DWORD *pdwData
                    );

    HRESULT MDSetAppState
                    (
                    IN LPCWSTR szMetabasePath, 
                    IN DWORD dwState
                    );

    HRESULT MDGetPropPaths
                    (
                    IN LPCWSTR     szMetabasePath,
                    IN DWORD    dwMDIdentifier,
                    OUT    WCHAR**    pBuffer,
                    OUT DWORD*    pdwBufferSize
                    );

    HRESULT MDGetWAMCLSID
                    (
                    IN LPCWSTR szMetabasePath,
                    IN OUT LPWSTR szWAMCLSID
                    );
                    
    HRESULT MDGetIdentity
                    (
                    IN LPWSTR szIdentity,
                    IN DWORD  cbIdentity,
                    IN LPWSTR szPwd,
                    IN DWORD  cbPwd
                    );

    HRESULT MDGetAppName
                    (
                    IN  LPCWSTR     szMetaPath,
                    OUT LPWSTR *    ppszAppName
                    );
    
    HRESULT MDGetStringAttribute
                    (
                    IN LPCWSTR szMetaPath,
                    DWORD dwMDIdentifier,
                    OUT LPWSTR * ppszBuffer
                    );

    HRESULT MDGetAllSiteRoots
                    (
                    OUT LPWSTR * ppszBuffer
                    );

    HRESULT GetSignatureOnPath
                    (
                    IN LPCWSTR pwszMetabasePath,
                    OUT DWORD* pdwSignature
                    );

                    
    HRESULT GetWebServerName
                    (
                    IN LPCWSTR wszMetabasePath, 
                    IN OUT LPWSTR wszWebServerName, 
                    IN UINT cBuffer
                    );

    HRESULT SaveData
                    (
                    VOID
                    );

    HRESULT MDGetLastOutProcPackageID
                    (
                    IN LPCWSTR szMetabasePath,
                    IN OUT LPWSTR szLastOutProcPackageID
                    );

    HRESULT MDRemoveProperty
                    (
                    IN LPCWSTR pwszMetabasePath,
                    DWORD dwIdentifier,
                    DWORD dwType
                    );

    HRESULT MDRemovePropertyByArray
                    (
                    IN MDPropItem*     prgProp
                    );

    VOID    InitPropItemData
                    (
                    IN OUT MDPropItem* pMDPropItem
                    );
                    
    HRESULT MDGetIDs
                    (
                    IN LPCWSTR  szMetabasePath,
                    OUT LPWSTR  szWAMCLSID,
                    OUT LPWSTR  szPackageID,
                    IN DWORD    dwAppMode
                    );

    VOID    MDSetPropItem
                    (
                    IN MDPropItem* prgProps,    
                    IN DWORD     iIndex, 
                    IN LPCWSTR    pwstrVal
                    );
                    
    VOID    MDSetPropItem
                    (
                    IN MDPropItem* prgProps,
                    IN DWORD     iIndex, 
                    IN DWORD    dwVal
                    );

    VOID    MDDeletePropItem
                    (
                    IN MDPropItem* prgProps,
                    IN DWORD     iIndex
                    );
    BOOL    HasAdminAccess
                    (
                    VOID
                    );

private:

    
    DWORD     WamRegChkSum
                    ( 
                    IN LPCWSTR pszKey, 
                    IN DWORD cchKey
                    );


    // Time out for metabase  = 5 seconds
    static const DWORD            m_dwMDDefaultTimeOut;    
    static const MDPropItem        m_rgMDPropTemplate[];

    //
    //  The global metabase pointer, 
    //   created at the WAMREG start up time, 
    //   deleted when WAMREG is shutdown.
    //
    static    IMSAdminBaseW*        m_pMetabase;
    

};

inline HRESULT WamRegMetabaseConfig::SaveData(VOID)
{
    DBG_ASSERT(m_pMetabase);
    return m_pMetabase->SaveData();
}

inline VOID    WamRegMetabaseConfig::MDSetPropItem
(
IN MDPropItem* prgProps,
IN DWORD     iIndex, 
IN LPCWSTR    pwstrVal
)
{
    DBG_ASSERT(prgProps && iIndex < IWMDP_MAX);
    prgProps[iIndex].dwAction = EMD_SET;
    prgProps[iIndex].pwstrVal = (LPWSTR)pwstrVal;
}

inline VOID    WamRegMetabaseConfig::MDSetPropItem
(
IN MDPropItem* prgProps,
IN DWORD     iIndex, 
IN DWORD    dwVal
)
{
    DBG_ASSERT(prgProps && iIndex < IWMDP_MAX);
    prgProps[iIndex].dwAction = EMD_SET;
    prgProps[iIndex].dwVal = dwVal;
}

inline VOID    WamRegMetabaseConfig::MDDeletePropItem
(
IN MDPropItem* prgProps,
IN DWORD     iIndex
)
{
    DBG_ASSERT(prgProps && iIndex < IWMDP_MAX);
    prgProps[iIndex].dwAction = EMD_DELETE;
}

extern    WamRegGlobal            g_WamRegGlobal;
extern    WamRegRegistryConfig    g_RegistryConfig;

#endif // _WAMREG_AUXFUNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\common.h ===
#ifndef _WAMREG_COMMON_H
#define _WAMREG_COMMON_H

#ifdef __cplusplus
	extern "C" {
#endif

	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
	#include <windows.h>

#ifdef __cplusplus
	};
#endif	// __cplusplus

#include "wmrgexp.h"
//==========================================================================
// Global Macro defines.
//
//==========================================================================
#define RELEASE(p) {if ( p ) { p->Release(); p = NULL; }}
#define FREEBSTR(p) {if (p) {SysFreeString( p ); p = NULL;}}
//
// 39 is the size of CLSID
//
#define	uSizeCLSID	39

//==========================================================================
// Global data defines
//
//==========================================================================
extern	DWORD				g_dwRefCount;
extern 	PFNServiceNotify 	g_pfnW3ServiceSink;
extern  HINSTANCE           g_hModule;


//==========================================================================
// function declarations
//
//==========================================================================



#endif // _WAMREG_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\comobj.h ===
// comobj.h: Definition of the WmRgSrv class
//
//////////////////////////////////////////////////////////////////////
#ifndef _WAMREG_COMOBJ_H
#define _WAMREG_COMOBJ_H


//#if !defined(AFX_COMOBJ_H__29822ABB_F302_11D0_9953_00C04FD919C1__INCLUDED_)
//#define AFX_COMOBJ_H__29822ABB_F302_11D0_9953_00C04FD919C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "common.h"
#include "resource.h"       // main symbols
#include "iadmw.h"
#include "iiscnfg.h"
#include "iadmext.h"

/////////////////////////////////////////////////////////////////////////////
// WmRgSrv

class CWmRgSrv : 
	public IADMEXT
{
public:
	CWmRgSrv();
	~CWmRgSrv();

//DECLARE_NOT_AGGREGATABLE(WmRgSrv) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

// IWmRgSrv
public:
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(Initialize)();
	STDMETHOD(EnumDcomCLSIDs)(/* [size_is][out] */CLSID *pclsidDcom, /* [in] */ DWORD dwEnumIndex);
	STDMETHOD(Terminate)();	

private:
	// Since wamreg has only one com object.  No need to use static members.
	DWORD				m_cSignature;
	LONG				m_cRef;
};

class CWmRgSrvFactory: 
	public IClassFactory 
{
public:
	CWmRgSrvFactory();
	~CWmRgSrvFactory();

	STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(CreateInstance)(IUnknown * pUnknownOuter, REFIID riid, void ** ppv);
	STDMETHOD(LockServer)(BOOL bLock);

	CWmRgSrv	*m_pWmRgServiceObj;

private:
	ULONG		m_cRef;
};


	
// Global data defines.
extern CWmRgSrvFactory* g_pWmRgSrvFactory; 
extern DWORD			g_dwRefCount;

#endif // _WAMREG_COMOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\comobj.cpp ===
// comobj.cpp : Implementation of CWamregApp and DLL registration.
#include "common.h"
#include "comobj.h"
#include "iwamreg.h"
#include "wamadm.h"

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include "auxfunc.h"
#include "dbgutil.h"

//==========================================================================
// Global variables
//
//==========================================================================
CWmRgSrvFactory* 	g_pWmRgSrvFactory = NULL;
DWORD				g_dwRefCount = 0;
DWORD				g_dwWamAdminRegister = 0;

//==========================================================================
// Static functions
//
//==========================================================================

/////////////////////////////////////////////////////////////////////////////
//

/*===================================================================
CWmRgSrv::CWmRgSrv

Constructor for CWmRgSrv. 

Parameter:		NONE
Return:			NONE

Side affect:	Init a Metabase pointer(via UNICODE DCOM interface), Create an Event.
===================================================================*/
CWmRgSrv::CWmRgSrv()
: 	m_cRef(1)
{
	InterlockedIncrement((long *)&g_dwRefCount);
}

/*===================================================================
CWmRgSrv::~CWmRgSrv

Destructor for CWmRgSrv. 

Parameter:		NONE
Return:			NONE

Side affect:	Release the Metabase pointer, and Destroy the internal event object.
===================================================================*/
CWmRgSrv::~CWmRgSrv()
{	
	InterlockedDecrement((long *)&g_dwRefCount);
	DBG_ASSERT(m_cRef == 0);
}

/*===================================================================
CWmRgSrv::QueryInterface

UNDONE

Parameter:
NONE.

Return:			HRESULT

Side affect:	.
===================================================================*/
STDMETHODIMP CWmRgSrv::QueryInterface(REFIID riid, void ** ppv)
{
	if (riid == IID_IUnknown || riid == IID_IADMEXT)
		{
		*ppv = static_cast<IADMEXT*>(this);
		}
	else
		{
		*ppv = NULL;
		return E_NOINTERFACE;
		}

	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CWmRgSrv::AddRef( )
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CWmRgSrv::Release( )
{
	if (InterlockedDecrement(&m_cRef) == 0)
		{
		delete this;
		return 0;
		}

	return m_cRef;
}


/*===================================================================
CWmRgSrv::Initialize

UNDONE

Parameter:
NONE.

Return:			HRESULT

Side affect:	.
===================================================================*/
STDMETHODIMP CWmRgSrv::Initialize( )
{
	HRESULT			hrReturn = NOERROR;
	CWamAdminFactory	*pWamAdminFactory = new CWamAdminFactory();

	if (pWamAdminFactory == NULL)
		{
		DBGPRINTF((DBG_CONTEXT, "WamRegSrv Init failed. error %08x\n",
					GetLastError()));
		hrReturn = E_OUTOFMEMORY;
		goto LExit;
		}

	hrReturn = g_RegistryConfig.LoadWamDllPath();
	
	if (SUCCEEDED(hrReturn))
		{
		hrReturn = WamRegMetabaseConfig::MetabaseInit();
		}

	if (SUCCEEDED(hrReturn))
		{
		hrReturn = CoRegisterClassObject(CLSID_WamAdmin,
										static_cast<IUnknown *>(pWamAdminFactory),
										CLSCTX_SERVER,
										REGCLS_MULTIPLEUSE,
										&g_dwWamAdminRegister);
		if (FAILED(hrReturn))
			{
			DBGPRINTF((DBG_CONTEXT, "WamRegSrv Init failed. error %08x\n",
						GetLastError()));
			}
		}

	if (FAILED(hrReturn))
		{
		if (g_dwWamAdminRegister)
			{
	        //
            // PREfix has a problem with this code because we're not checking
            // the return value of CoRevokeClassObject.  There's really
            // nothing different we could do in the event of failure, so
            // there's no point in checking.
            //

            /* INTRINSA suppress=all */

			CoRevokeClassObject(g_dwWamAdminRegister);
			g_dwWamAdminRegister = 0;
			}
		RELEASE(pWamAdminFactory);
		}

	if (FAILED(hrReturn))
		{
		WamRegMetabaseConfig::MetabaseUnInit();
		}

LExit:
	return hrReturn;
}

/*===================================================================
CWmRgSrv::Terminate

UNDONE

Parameter:
NONE.

Return:			HRESULT

Side affect:	.
===================================================================*/
HRESULT CWmRgSrv::EnumDcomCLSIDs
(
/* [size_is][out] */CLSID *pclsidDcom, 
/* [in] */ DWORD dwEnumIndex
)
{
	HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

	if (dwEnumIndex == 0)
		{
		*pclsidDcom = CLSID_WamAdmin;
		hr = S_OK;
		}

	return hr;
}

/*===================================================================
CWmRgSrv::Terminate

UNDONE

Parameter:
NONE.

Return:			HRESULT

Side affect:	.
===================================================================*/
STDMETHODIMP CWmRgSrv::Terminate( )
{
	//
    // PREfix has a problem with this code because we're not checking
    // the return value of CoRevokeClassObject.  There's really
    // nothing different we could do in the event of failure, so
    // there's no point in checking.
    //

    /* INTRINSA suppress=all */
    
    CoRevokeClassObject(g_dwWamAdminRegister);
	WamRegMetabaseConfig::MetabaseUnInit();
	
	return S_OK;
}


/*

CWmRgSrvFactory: 	Class Factory IUnknown Implementation

*/

CWmRgSrvFactory::CWmRgSrvFactory()
:	m_pWmRgServiceObj(NULL)
{
	m_cRef = 0;
	InterlockedIncrement((long *)&g_dwRefCount);
}

CWmRgSrvFactory::~CWmRgSrvFactory()
{
	InterlockedDecrement((long *)&g_dwRefCount);
	RELEASE(m_pWmRgServiceObj);
}

STDMETHODIMP CWmRgSrvFactory::QueryInterface(REFIID riid, void ** ppv)
{
	HRESULT hrReturn = S_OK;
	
	if (riid==IID_IUnknown || riid == IID_IClassFactory) 
		{
	    if (m_pWmRgServiceObj == NULL)
	    	{
	        *ppv = (IClassFactory *) this;
			AddRef();
			hrReturn = S_OK;
	    	}
	    else
	    	{
    		*ppv = (IClassFactory *) this;
			AddRef();
			hrReturn = S_OK;
		    }
		}
	else 
		{
    	hrReturn = E_NOINTERFACE;
		}
		
	return hrReturn;
}

STDMETHODIMP_(ULONG) CWmRgSrvFactory::AddRef( )
{
	DWORD dwRefCount;

	dwRefCount = InterlockedIncrement((long *)&m_cRef);
	return dwRefCount;

}

STDMETHODIMP_(ULONG) CWmRgSrvFactory::Release( )
{
	DWORD dwRefCount;

	dwRefCount = InterlockedDecrement((long *)&m_cRef);
	return dwRefCount;
}

STDMETHODIMP CWmRgSrvFactory::CreateInstance(IUnknown * pUnknownOuter, REFIID riid, void ** ppv)
{
	HRESULT hrReturn = NOERROR;
	
	if (pUnknownOuter != NULL) 
		{
    	hrReturn = CLASS_E_NOAGGREGATION;
		}

	if (m_pWmRgServiceObj == NULL)
		{
		m_pWmRgServiceObj = new CWmRgSrv();
		if (m_pWmRgServiceObj == NULL)
			{
			hrReturn = E_OUTOFMEMORY;
			}
		}

	if (m_pWmRgServiceObj)
		{
		if (FAILED(m_pWmRgServiceObj->QueryInterface(riid, ppv))) 
			{
	    	hrReturn = E_NOINTERFACE;
			}
		}
		
	return hrReturn;
}

STDMETHODIMP CWmRgSrvFactory::LockServer(BOOL fLock)
{
	if (fLock) 
		{
        InterlockedIncrement((long *)&g_dwRefCount);
    	}
    else 
    	{
        InterlockedDecrement((long *)&g_dwRefCount);
    	}
    	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\sendhdrx\sendhdrx.c ===
/***********************************************************************

SendHdrX.c

Sample ISAPI Extension demonstrating:

    ServerSupportFunction( HSE_REQ_SEND_RESPONSE_HEADER_EX )


***********************************************************************/


#include <windows.h>
#include <objbase.h>
#include <iisext.h>
#include <stdio.h>



/*---------------------------------------------------------------------*
GetExtensionVersion

IIS calls this entry point to load the ISAPI DLL.

Returns:
	TRUE on success

Side effects:
	None.
*/
BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO *pVer
)
{
	pVer->dwExtensionVersion =
	    MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

	lstrcpyn(
	    pVer->lpszExtensionDesc
	    , "ISAPI SendHeaderEx sample"
	    , HSE_MAX_EXT_DLL_NAME_LEN
    );

	return TRUE;
}



/*---------------------------------------------------------------------*
HttpExtensionProc

IIS calls this entry point to process a browser request.

Returns:
	TRUE on success

Side effects:
	None.
*/
DWORD WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK *pECB
)
{

	HSE_SEND_HEADER_EX_INFO	SendHeaderExInfo;

    DWORD cchStatus;
	DWORD cchHeader;
	DWORD cchContent;

    //
    //  NOTE we must send Content-Length header with correct byte count
    //  in order for keep-alive to work.
    //

	char szStatus[]     = "200 OK";
	char szContent[]    =   "<html>"
	                        "<br> Usage:"
	                        "<br> To keep connection alive: http://localhost/vdir/SendHdrX.dll?Keep-Alive"
	                        "<br> To close connection: http://localhost/vdir/SendHdrX.dll"
                            "</html>";
	char szHeaderBase[] = "Content-Length: %lu\r\nContent-type: text/html\r\n\r\n";
	char szHeader[4096];


	cchStatus = lstrlen(szStatus);
    cchHeader = lstrlen(szHeader);
	cchContent = lstrlen(szContent);

	
    //
    //  fill in byte count in Content-Length header
    //

	sprintf( szHeader, szHeaderBase, cchContent );


    //
    //  Populate SendHeaderExInfo struct
    //

    SendHeaderExInfo.pszStatus = szStatus;
    SendHeaderExInfo.pszHeader = szHeader;
    SendHeaderExInfo.cchStatus = cchStatus;
    SendHeaderExInfo.cchHeader = cchHeader;
    SendHeaderExInfo.fKeepConn = FALSE;

    if ( 0 == lstrcmpi( pECB->lpszQueryString , "Keep-Alive" ) ) {

        SendHeaderExInfo.fKeepConn = TRUE;
    }


    //
    //  Send header
    //

	if ( !pECB->ServerSupportFunction(
    			pECB->ConnID
    			, HSE_REQ_SEND_RESPONSE_HEADER_EX
    			, &SendHeaderExInfo
    			, NULL
    			, NULL
            ) ) {

    	return HSE_STATUS_ERROR;
	}
	

    //
    //  Send content
    //

	if( !pECB->WriteClient(pECB->ConnID, szContent, &cchContent, 0) ) {

    	return HSE_STATUS_ERROR;
	}
	
	return HSE_STATUS_SUCCESS;

}



/*---------------------------------------------------------------------*
DllMain

Main entry point into the DLL.  Called by system on DLL load
and unload.

Returns:
	TRUE on success

Side effects:
	None.
*/
BOOL WINAPI
DllMain(
    HINSTANCE hinstDLL
    , DWORD fdwReason
    , LPVOID lpvReserved
)
{
	return TRUE;
}



/*---------------------------------------------------------------------*
TerminateExtension

IIS calls this entry point to unload the ISAPI DLL.

Returns:
	NONE

Side effects:
	Uninitializes the ISAPI DLL.
*/
BOOL WINAPI
TerminateExtension(
    DWORD dwFlag
)
{
	return TRUE;
}



/***************************** End of File ****************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\tests\ureadcli\ureadcli.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    UReadCli.c

Abstract:

    This module tests the ReadClient for both Sync and Async calls

Author:

    Stanle Tam (stanleyt)   4-June 1997
    
Revision History:
  
--*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <iisext.h>

#define MAX_BUF_SIZE    49152               // 48 K - max number of bytes for each read
#define PARC_IO_CTX     LPDWORD             // Context for Async ReadClient 

//
// Number of bytes read so far - pContext of the IO completion routine
//
PARC_IO_CTX             pByteReadSoFar;     

//
//  Buffer to store bytes each time that read from client
//
BYTE                    g_ReadBuffer[MAX_BUF_SIZE] = {0};

DWORD
SendHeaderToClient(IN LPEXTENSION_CONTROL_BLOCK pecb, 
                   IN LPCSTR pszErrorMsg,
                   IN BOOL fKeepAlive);

DWORD
DoReadClient(IN LPEXTENSION_CONTROL_BLOCK pecb);

DWORD
DoSyncRC(IN LPEXTENSION_CONTROL_BLOCK pecb);

DWORD
DoAsyncRC(IN LPEXTENSION_CONTROL_BLOCK pecb);
             
VOID WINAPI
AsyncReadClientIoCompletion(IN LPEXTENSION_CONTROL_BLOCK pecb, 
                            IN PVOID pContext,
                            IN DWORD cbIO,
                            IN DWORD dwError);

BOOL
ValidBytes (IN LPEXTENSION_CONTROL_BLOCK    pecb, 
            IN BYTE                       * pbSrc, 
            IN DWORD                        dwByteRead,
            OUT LPDWORD                     dwOffSet);

DWORD
IsKeepAlive(IN LPEXTENSION_CONTROL_BLOCK pecb);

DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 fReturn Value:

    fReturns TRUE is successful; otherwise FALSE is fReturned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
      {
          //
          // Initialize various data and modules.
          //

          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          if ( lpvContext != NULL) {

          }

          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return (fReturn);
}  /* DllLibMain() */


BOOL WINAPI
GetExtensionVersion(HSE_VERSION_INFO * Version)
{
    Version->dwExtensionVersion = 
    MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    strcpy(Version->lpszExtensionDesc, "Universal Read Client Test ISAPI DLL");

    return TRUE;
}


DWORD WINAPI
HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pecb)   
{
    DWORD hseStatus;
            
    if ( 0 == strcmp(pecb->lpszQueryString, "") ||

        (0 == strspn(pecb->lpszQueryString, "SYNC" ) &&
         0 == strspn(pecb->lpszQueryString, "ASYNC")) )    {

        hseStatus = SendHeaderToClient(
                        pecb, 
                        "Expected to specify what kind of ReadClient to test.\r\n" \
                        "SYNC  - Sync  ReadClient\r\n" \
                        "ASYNC - Async ReadClient",
                        FALSE);
    
    } else {

        hseStatus = DoReadClient( pecb);
    }
   
    return (hseStatus);
}


BOOL WINAPI
TerminateExtension(DWORD dwFlags)
{
    return TRUE;
}


DWORD
SendHeaderToClient(IN LPEXTENSION_CONTROL_BLOCK  pecb, IN LPCSTR pszErrorMsg, IN BOOL fKeepAlive)
{
    BOOL    fReturn;
    CHAR    szText[MAX_PATH] = "";
    CHAR    szHeader[MAX_PATH] = "";
    DWORD   cbText;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    
    //
    //  The HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    cbText = wsprintf( szText,
                       "<head><title>Unified Read Client</title></head>\n"
                       "<body><h1>%s</h1>\n",
                       pszErrorMsg );

    if ( fKeepAlive) {
        wsprintf( szHeader,
                  "Content-type: text/html\r\n"
                  "Connection: keep-alive\r\n"
                  "Content-Length: %d\r\n"
                  "\r\n",
                  cbText);
        
        fReturn = 
        pecb->ServerSupportFunction( pecb->ConnID,
                                     HSE_REQ_SEND_RESPONSE_HEADER,
                                     "200 OK",
                                     NULL,
                                     (LPDWORD) szHeader) 
                                            
                                     &&

        pecb->WriteClient( pecb->ConnID,
                           szText,
                           &cbText,
                           0 );
    
    } else {
        
        wsprintf( szHeader,
                  "Content-Type: text/html\r\n"
                  "\r\n"
                  "<head><title>Unified Read Client</title></head>\n"
                  "<body><h1>%s</h1>\n",
                  pszErrorMsg );

        fReturn = 
        pecb->ServerSupportFunction( pecb->ConnID,
                                     HSE_REQ_SEND_RESPONSE_HEADER,
                                     "200 OK",
                                     NULL,
                                     (LPDWORD) szHeader); 
    }

    if ( !fReturn) {
        fReturn = HSE_STATUS_ERROR;
    }

    return (fReturn);
} 


DWORD
DoReadClient(IN LPEXTENSION_CONTROL_BLOCK pecb)
{   
    char    szHeader[256] = "";
    BOOL    fReturn = TRUE;
    BOOL    fKeepAlive = FALSE;
    DWORD   dwLocation;    
    DWORD   hseStatus =  HSE_STATUS_SUCCESS;
 
    //
    // Firstly, check if there is any corrupted byte in the 
    // first chunk (the first chunk could be the last chunk, ie
    // when cbAvailable==cbToTalBytes). Expecting the client to send 
    // bytes in the format of "0123456789012345678....".
    //
        
    dwLocation = 0;
    if ( ! ValidBytes ( pecb, 
                        pecb->lpbData,      // check these bytes 
                        pecb->cbAvailable,  // number of bytes read
                        &dwLocation)) {     // offset, 0 = starts from the first byte
        
        wsprintf( szHeader, "Bad data at location %d.", dwLocation);
        hseStatus = SendHeaderToClient(pecb, szHeader, FALSE);
        fReturn =
        pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_DONE_WITH_SESSION,
            &hseStatus,
            NULL,
            NULL);

            return (HSE_STATUS_ERROR);
    }
             
    //
    // Check if cbTotalBytes == cbAvailable
    // if so lpbData contains all the data sent by 
    // the client, and complete the session. Very likely..
    //

    if (pecb->cbTotalBytes == pecb->cbAvailable) {
        
        wsprintf ( szHeader, 
                   "ECB Total Bytes: %d. Actual Read Bytes: %d", 
                   pecb->cbTotalBytes, 
                   pecb->cbAvailable);

        if ( HSE_STATUS_SUCCESS_AND_KEEP_CONN == 
             (hseStatus = IsKeepAlive(pecb)) )  {
            
            SendHeaderToClient(pecb, szHeader, TRUE);
        
        } else {

            SendHeaderToClient(pecb, szHeader, FALSE);

            fReturn =
            pecb->ServerSupportFunction(
                    pecb->ConnID,
                    HSE_REQ_DONE_WITH_SESSION,
                    &hseStatus,
                    NULL,
                    NULL);
            if ( !fReturn)
                hseStatus = HSE_STATUS_ERROR;
        }
        
        return (hseStatus);
    }
    
    //
    // we already ensured the validity of the query string 
    // inside HttpExtensionProc, hence simple check here
    //
    if ( strspn(pecb->lpszQueryString, "SYNC" ) )
        return ( DoSyncRC(pecb));
    else 
        return ( DoAsyncRC(pecb));
}



DWORD
DoSyncRC(IN LPEXTENSION_CONTROL_BLOCK pecb)
{
    CHAR    szHeader[256] = "";
    BOOL    fReturn = TRUE;
    DWORD   cbReadSoFar;
    DWORD   dwOffSet;
    DWORD   cbCurrentRead = MAX_BUF_SIZE;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;

    cbReadSoFar = pecb->cbAvailable;

    while ( cbReadSoFar < pecb->cbTotalBytes) {

            if ((pecb->cbTotalBytes - cbReadSoFar) < sizeof(g_ReadBuffer))
                cbCurrentRead =  (pecb->cbTotalBytes - cbReadSoFar); 
            else
                cbCurrentRead = sizeof(g_ReadBuffer);

            fReturn =
            pecb->ReadClient(
                pecb->ConnID,
                g_ReadBuffer,
                &cbCurrentRead);
            
            if (!fReturn) {
                wsprintf( szHeader, "Problem on ReadClient()");
                hseStatus = SendHeaderToClient(pecb, szHeader, FALSE);
                fReturn =
                pecb->ServerSupportFunction(
                        pecb->ConnID,
                        HSE_REQ_DONE_WITH_SESSION,
                        &hseStatus,
                        NULL,
                        NULL);
             
                hseStatus = HSE_STATUS_ERROR;
                break;
            }

            dwOffSet = cbReadSoFar;             // where it left off last time
            if ( ! ValidBytes ( pecb, 
                                g_ReadBuffer,   // check these bytes 
                                cbCurrentRead,  // number of bytes read 
                                &dwOffSet   
                                )) {
                wsprintf( szHeader, "Bad data at location %d.", dwOffSet );
                hseStatus = SendHeaderToClient(pecb, szHeader, FALSE);
                fReturn =
                pecb->ServerSupportFunction(
                        pecb->ConnID,
                        HSE_REQ_DONE_WITH_SESSION,
                        &hseStatus,
                        NULL,
                        NULL);
             
                hseStatus = HSE_STATUS_ERROR;
                break;
            }
      
            cbReadSoFar += cbCurrentRead;   // update current total bytes read
    }
    //
    // if they are equal, ie all bytes are read
    //
    if (cbReadSoFar >= pecb->cbTotalBytes) {

        wsprintf ( szHeader, 
                   "ECB Total Bytes: %d. Actual Read Bytes: %d", 
                   pecb->cbTotalBytes, 
                   cbReadSoFar );

        if ( HSE_STATUS_SUCCESS_AND_KEEP_CONN == 
             (hseStatus = IsKeepAlive(pecb)) )  {
            
            SendHeaderToClient(pecb, szHeader, TRUE);
        
        } else {
    
            SendHeaderToClient(pecb, szHeader, FALSE);

            fReturn =
            pecb->ServerSupportFunction(
                    pecb->ConnID,
                    HSE_REQ_DONE_WITH_SESSION,
                    &hseStatus,
                    NULL,
                    NULL);
            if ( !fReturn)
                hseStatus = HSE_STATUS_ERROR;
        }
    }
     
    return (hseStatus); // default = HSE_STATUS_SUCCESS
}


 
DWORD
DoAsyncRC(IN LPEXTENSION_CONTROL_BLOCK pecb)
{
    char    szHeader[256] = "";
    BOOL    fReturn = TRUE;
    DWORD   dwFlags;
    DWORD   cbTotalToRead = MAX_BUF_SIZE;
    DWORD   hseStatus = HSE_STATUS_PENDING;
     
    //
    // Initialize the context for ReadClient
    //
    
    pByteReadSoFar = &(pecb->cbAvailable);
    
    fReturn =
    pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_IO_COMPLETION,
            AsyncReadClientIoCompletion,
            0,
            pByteReadSoFar);
    
    if (!fReturn) {
        hseStatus = HSE_STATUS_ERROR;
    }
    
    dwFlags = HSE_IO_ASYNC;
    fReturn = 
    pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_ASYNC_READ_CLIENT,
            g_ReadBuffer,
            &cbTotalToRead,
            &dwFlags);

    if (!fReturn) {
        hseStatus = HSE_STATUS_ERROR;
    }

    return (hseStatus);
}


VOID WINAPI
AsyncReadClientIoCompletion(
            IN LPEXTENSION_CONTROL_BLOCK pecb,
            IN PVOID pContext,
            IN DWORD cbIO,
            IN DWORD dwError)
/*++

Routine Description:

    This is the io completion routine for ReadClient

Arguments:

    pecb        - extension control block
    pContext    - this is a PASYNC_RC_O_STRUCTURE
    cbIO        - bytes read
    dwError     - error on read

fReturn Value:

    None

--*/
{
    BOOL    fReturn;
    DWORD   dwFlags;
    DWORD   dwOffSet;
    DWORD   cbTotalToRead = MAX_BUF_SIZE;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    LPDWORD pcbTotalReadSoFar = (LPDWORD) pContext;
    
    __try {
    
        if (ERROR_SUCCESS == dwError) {
        
            CHAR szHeader[100] = "";

            dwOffSet = *pcbTotalReadSoFar;      // where it left off last time
            *pcbTotalReadSoFar += cbIO;         // update current total bytes read
        
            if ( ! ValidBytes ( pecb, 
                                g_ReadBuffer,   // check these bytes 
                                cbIO,           // number of bytes read 
                                &dwOffSet   
                               )) {
                wsprintf( szHeader, "Bad data at location %d.", dwOffSet );
                SendHeaderToClient(pecb, szHeader, FALSE);
                hseStatus = HSE_STATUS_ERROR;
                __leave;
            }
         
            //
            // if they are equal, ie all bytes are read
            //
        
            if (*pcbTotalReadSoFar  >= pecb->cbTotalBytes ) { 
                            
                wsprintf (szHeader, 
                            "ECB Total Bytes: %d. Actual Read Bytes: %d", 
                            pecb->cbTotalBytes, 
                            *pcbTotalReadSoFar );

                if ( HSE_STATUS_SUCCESS_AND_KEEP_CONN == 
                    (hseStatus = IsKeepAlive(pecb)) )  {

                    SendHeaderToClient(pecb, szHeader, TRUE);
                
                } else {

                    SendHeaderToClient(pecb, szHeader, FALSE);
                    fReturn =
                    pecb->ServerSupportFunction(
                        pecb->ConnID,
                        HSE_REQ_DONE_WITH_SESSION,
                        &hseStatus,
                        NULL,
                        NULL);  

                    if (!fReturn) {
                        hseStatus = HSE_STATUS_ERROR;
                        __leave;
                    }
                }
            
            //
            // Read remaining bytes
            //
            } else {
  
                dwFlags = HSE_IO_ASYNC;
                fReturn = 
                pecb->ServerSupportFunction(
                    pecb->ConnID,
                    HSE_REQ_ASYNC_READ_CLIENT,
                    g_ReadBuffer,
                    &cbTotalToRead,
                    &dwFlags);

                if (!fReturn) {
                    hseStatus = HSE_STATUS_ERROR;
                    __leave;
                }
            }
        //
        // Error on read
        //
        } else {

            hseStatus = dwError;
            __leave;
        }
    
    } // __try

    __finally {
    
        if (hseStatus != HSE_STATUS_SUCCESS) {
        
                fReturn =
                pecb->ServerSupportFunction(
                    pecb->ConnID,
                    HSE_REQ_DONE_WITH_SESSION,
                    &hseStatus,
                    NULL,
                    NULL);
        }
    } // __finally
        
}
 

/*++

 Routine Description:

   This function checks if client issues Keep-Alive connection
    
 Arguments:

   pecb         ECB
   pfKeepAlive  KeepAlive flag
   
 fReturn Value:

    HSE Return Code -  either HSE_STATUS_SUCCESS or HSE_STATUS_ERROR
    pfKeepAlive - shows whether the client issues Keep-Alive

--*/
DWORD
IsKeepAlive( IN  LPEXTENSION_CONTROL_BLOCK pecb)
{
    CHAR    szBuff[256] = {0};
    DWORD   cbBuff = sizeof(szBuff);
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    BOOL    fReturn;

    fReturn = 
    pecb->GetServerVariable( pecb->ConnID,
                            "HTTP_CONNECTION",
                            szBuff,
                            &cbBuff );
    if ( ! fReturn) {
        wsprintf( szBuff, "Client does not specify keep-alive connection. No keep-alive.");
        SendHeaderToClient(pecb, szBuff, FALSE);
        fReturn = pecb->ServerSupportFunction(
                  	  pecb->ConnID,
	                  HSE_REQ_DONE_WITH_SESSION,
                          &hseStatus,
                          NULL,
                          NULL);  
        if ( !fReturn)
	    hseStatus = HSE_STATUS_ERROR;
    }
    //
    // in order to achieve keep-alive, client has
    // to ensure keep-alive as well
    //
    if ( !_strnicmp( szBuff, "Keep-Alive", 10 )) 
        hseStatus = HSE_STATUS_SUCCESS_AND_KEEP_CONN ;
             
    return ( hseStatus);
}


/*++

 Routine Description:

   This function checks if any byte in the buffer is corrupted.
    
 Arguments:

   pecb         ECB
   pbSrc        The source buffer
   dwByteRead   Number of bytes read
   dwOffSet     [IN]  Start from where it left out in last read
                [OUT] Return the location of the first invalid byte

 fReturn Value:

    TRUE -  Discovered bad byte and return its location
    FALSE - All bytes are valid

--*/
BOOL
ValidBytes (IN  LPEXTENSION_CONTROL_BLOCK pecb, 
            IN  BYTE * pbSrc, 
            IN  DWORD dwBytesRead, 
            OUT LPDWORD pbOffSet)
{
    DWORD   i;
    BOOL    fValidByte = TRUE;
    
    for (i = 0; i < dwBytesRead; i++) {

        if (pbSrc[i] != ((*pbOffSet + i) % 10) + '0') {
            if ( ((i + *pbOffSet) == pecb->cbTotalBytes) && 
                 (pbSrc[i] == 0x0d) &&
                 (pbSrc[i+1] == 0x0a)) {

                break;  // ALL good bytes

            } else {    

                fValidByte = FALSE;
                *pbOffSet = i;
                
                break;  // First bad byte
            } 
        } 
     } 

     return (fValidByte);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\auxfunc.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: Auxfunc.cpp

    implementation of supporting functions for WAMREG, including

    interface to Register and Unregister WAM CLSID in registry,
    interface to Create Package with MTS,

Owner: LeiJin

Note:

===================================================================*/
#include "common.h"
#include "auxfunc.h"
#include "iiscnfgp.h"
#include "dbgutil.h"
#include "iwamreg.h"
#include <inetinfo.h>

//==================================================================
//    Global data definitions
//
//==================================================================

//
// string contains the physical path of wamreg.dll, ie. c:\winnt\system32\inetsrv\wam.dll
//
CHAR    WamRegRegistryConfig::m_szWamDllPath[MAX_PATH];

//
// the permission to access the registry
//
const REGSAM    WamRegRegistryConfig::samDesired =    KEY_READ | KEY_WRITE;

//
//  A thread will first grab a token, and wait until the token matches the m_dwServiceNum,
//  In such way, the order of threads making the requests are perserved.
//  m_hWriteLock (Event) is used for the blocking other threads
//  m_csWAMREGLock is used for access the m_dwServiceToken and m_dwServiceNum
//
//  private global, static variables for WamAdmLock

WamAdmLock              WamRegGlobal::m_WamAdmLock;
WamRegGlobal            g_WamRegGlobal;

WamRegRegistryConfig    g_RegistryConfig;

// 
// Defined at /LM/W3SVC/
// Default package ID(IIS In-Process Application) and the default WAMCLSID(IISWAM.W3SVC).
//
const WCHAR   WamRegGlobal::g_szIISInProcPackageID[] =
                 W3_INPROC_PACKAGE_ID;
const WCHAR   WamRegGlobal::g_szInProcWAMCLSID[] = 
                 W3_INPROC_WAM_CLSID;
const WCHAR   WamRegGlobal::g_szInProcWAMProgID[] = L"IISWAM.W3SVC";

const WCHAR   WamRegGlobal::g_szIISOOPPoolPackageID[] =
                 W3_OOP_POOL_PACKAGE_ID;
const WCHAR   WamRegGlobal::g_szOOPPoolWAMCLSID[] =
                 W3_OOP_POOL_WAM_CLSID;
const WCHAR   WamRegGlobal::g_szOOPPoolWAMProgID[] = L"IISWAM.OutofProcessPool";

const WCHAR   WamRegGlobal::g_szIISInProcPackageName[] = DEFAULT_PACKAGENAME;
const WCHAR   WamRegGlobal::g_szIISOOPPoolPackageName[] = L"IIS Out-Of-Process Pooled Applications";
const WCHAR   WamRegGlobal::g_szMDAppPathPrefix[] = L"/LM/W3SVC/";
const DWORD   WamRegGlobal::g_cchMDAppPathPrefix = 
                 (sizeof(L"/LM/W3SVC/")/sizeof(WCHAR)) - 1;
const WCHAR   WamRegGlobal::g_szMDW3SVCRoot[] = L"/LM/W3SVC";
const DWORD   WamRegGlobal::g_cchMDW3SVCRoot = (sizeof(L"/LM/W3SVC")/sizeof(WCHAR)) - 1;

#ifndef DBGERROR
#define DBGERROR(args) ((void)0) /* Do Nothing */
#endif
//==================================================================
//  Local functions
//
//==================================================================

//===============================================================
// in line functions
//
//===============================================================
BOOL WamRegGlobal::Init(VOID)
{
    return m_WamAdmLock.Init();
}

BOOL WamRegGlobal::UnInit(VOID)
{
    return m_WamAdmLock.UnInit();
}

//===============================================================
// local functions
//
//===============================================================
WamAdmLock::WamAdmLock()
:   m_dwServiceToken(0),
    m_dwServiceNum(0),
    m_hWriteLock((HANDLE)NULL)
{

}
/*===================================================================
Init

Init certain variables for this supporting module of WAMREG.

Return:        NONE
===================================================================*/
BOOL WamAdmLock::Init()
{        
    BOOL fReturn = TRUE;
    
    INITIALIZE_CRITICAL_SECTION(&m_csLock);

    m_hWriteLock = IIS_CREATE_EVENT(
                       "WamAdmLock::m_hWriteLock",
                       &m_hWriteLock,
                       TRUE,
                       TRUE
                       );

    if (m_hWriteLock == NULL)
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to create m_hWriteLock(Event). error = %08x",
            GetLastError()));
        fReturn = FALSE;
        }
    return fReturn;

}

/*===================================================================
UnInit

Uninit certain variables for this supporting module of WAMREG.

Return:        NONE
===================================================================*/
BOOL WamAdmLock::UnInit()
{
    BOOL fReturn = TRUE;
    DeleteCriticalSection(&m_csLock);
    if (m_hWriteLock)
        {
        BOOL fTemp = CloseHandle(m_hWriteLock);
        if ( fTemp == FALSE)
            {
            DBGPRINTF((DBG_CONTEXT, "error in CloseHandle. errno = %d\n", GetLastError()));
            fReturn = FALSE;
            }
        m_hWriteLock = (HANDLE)0;
        }
    return fReturn;
}

/*===================================================================
GetNextServiceToken

Obtain the next service token when a thread enters WAMREG, if the token
obtained by the thread is not the same as m_dwServiceNum, the thread has
to wait until the token it owns is same as m_dwServiceNum.

The function returns a token value.

Return:        DWORD, Next Service Token
===================================================================*/
DWORD WamAdmLock::GetNextServiceToken( )
{
    DWORD dwToken;

    Lock();
    dwToken = m_dwServiceToken;
    m_dwServiceToken++;
    UnLock();

    return dwToken;
}

/*===================================================================
FAppPathAllowConfig

Test to see if we can make configuration changes(Delete/Create) on a path.  Currently,
this function is used to block changes to the default application/package.  The default
in proc package should not be deleted/altered at runtime.

Parameter:
pwszMetabasePath

Return:         BOOL

Side affect:    TRUE if we can configure the app on the app path.
===================================================================*/
BOOL WamRegGlobal::FAppPathAllowConfig
(
IN LPCWSTR pwszMetabasePath
)
{
    BOOL fReturn = TRUE;
    DWORD cchMDPath = 0;

    DBG_ASSERT(pwszMetabasePath);
    // Since szMDPath has a path that always starts with "/LM/W3SVC/", the input size must be
    // greater that length of "/LM/W3SVC/", This check is necessary to protect that the default
    // IIS (inproc) package being deleted by accident. 
    cchMDPath = wcslen(pwszMetabasePath);
    if (cchMDPath <= WamRegGlobal::g_cchMDAppPathPrefix)
        {
        fReturn = FALSE;
        }

    return fReturn;
}

/*===================================================================
FIsW3SVCRoot

Test to see the MetabasePath is same as L"/LM/W3SVC".

Parameter:
pwszMetabasePath

Return:         BOOL

Side affect:    TRUE if we can configure the app on the app path.
===================================================================*/
BOOL WamRegGlobal::FIsW3SVCRoot
(
IN LPCWSTR	wszMetabasePath
)
{
    INT iReturn;
    DBG_ASSERT(wszMetabasePath != NULL);
    
    iReturn = _wcsnicmp(wszMetabasePath, WamRegGlobal::g_szMDW3SVCRoot, WamRegGlobal::g_cchMDW3SVCRoot+1);
    return (iReturn == 0 ? TRUE : FALSE);
}

/*===================================================================
AcquireLock

Get a write lock, there can only be one thread doing work via DCOM interface, (i.e. has the write lock).
All other threads calling WamAdmin interfaces are blocked in this function.  After returning from
this call, the thread is guaranteed to be a "Critical Section".

A simple CriticalSection only solve half of the problem.  It guarantees the mutual exclusive condition.
But once a thread leaves the CS, the CS can not control which blocking threads can access CS next.

Parameter:
NONE.

Return:         HRESULT

Side affect:    Once returned, thread is in a "Critical Section".
===================================================================*/
VOID WamAdmLock::AcquireWriteLock( )
{
    DWORD     dwWaitReturn = WAIT_OBJECT_0;
    DWORD     dwMyToken = GetNextServiceToken();
    BOOL    fIsMyTurn = FALSE;  // Assume it is not my turn before we try to acquire the lock.
    
    DBG_ASSERT(m_hWriteLock);
    do    {
        dwWaitReturn = WaitForSingleObject(m_hWriteLock, INFINITE);

        //
        // Check for successful return.
        //
        if (dwWaitReturn == WAIT_OBJECT_0)        
            {
            Lock();
            if (dwMyToken == m_dwServiceNum)
                {
                fIsMyTurn = TRUE;
                }
            UnLock();
                
            }
        else
            {
            //
            // A failure down this code path might cause a busy loop...
            // However, such failure is very unlikely.  Attach a debugger can tell the story immediately.
            //
            DBGPRINTF((DBG_CONTEXT, "WaitForSingleObject failed, function returns %08x, errno = %08x\n",
                        dwWaitReturn,
                        GetLastError()));
            DBG_ASSERT(FALSE);
            }
    } while (FALSE == fIsMyTurn);
    
    ResetEvent(m_hWriteLock);
    IF_DEBUG(WAMREG_MTS)
        {
        DBGPRINTF((DBG_CONTEXT, "Thread %08x acquired the WriteLock of WAMREG, ServiceNum is %d.\n",
                    GetCurrentThreadId(),
                    dwMyToken));
        }
}

/*===================================================================
ReleaseLock

Release a write lock.  See comments in CWmRgSrv::AcquireLock.

Parameter:
NONE.

Return:         HRESULT

Side affect:    Leave "Critical Section".
===================================================================*/
VOID WamAdmLock::ReleaseWriteLock( )
{
    //CONSIDER: m_dwServerNum out-of-bound
    Lock();
    IF_DEBUG(WAMREG_MTS)
        {
        DBGPRINTF((DBG_CONTEXT, "Thread %08x released the WriteLock of WAMREG, ServiceNum is %d.\n",
            GetCurrentThreadId(),
            m_dwServiceNum));
        }
        
    m_dwServiceNum++;
    SetEvent(m_hWriteLock);
    UnLock();

}


/*===================================================================
RegisterCLSID

Register a WAM CLSID and a ProgID..After a successful registerCLSID call, you
should have

My Computer\HKEY_CLASSES_ROOT\CLSID\{szCLSIDEntryIn}
                                        \InProcServer32     "...physical location of wam.dll"
                                        \ProgID             szProgIDIn
                                        \VersionIndependentProgID   "IISWAM.W3SVC"

Parameter:
szCLSIDEntryIn:     CLSID for a WAM.
szProgIDIn:         ProgID for the WAM.
fSetVIProgID:       TRUE if this function needs to set the Version Independent ProgID.
                    FALSE, Otherwise.

Return:     HRESULT

NOTE: Registry API should use ANSI version, otherwise, it will cause trouble on Win95.

===================================================================*/
HRESULT WamRegRegistryConfig::RegisterCLSID
(
IN LPCWSTR szCLSIDEntryIn,
IN LPCWSTR szProgIDIn,
IN BOOL fSetVIProgID
)
{
    static const CHAR szWAMDLL[]            = "wam.dll";
    static const CHAR szClassDesc[]         = "Web Application Manager Object";
    static const CHAR szThreadingModel[]    = "ThreadingModel";
    static const CHAR szInprocServer32[]    = "InprocServer32";
    static const CHAR szTEXT_VIProgID[]     = "VersionIndependentProgID";
    static const CHAR szTEXT_ProgID[]       = "ProgID";
    static const CHAR szTEXT_Clsid[]        = "Clsid";
    static const CHAR szFreeThreaded[]      = "Free";
    static const CHAR szVIProgID[]          = "IISWAM.Application";

    HRESULT     hr = E_FAIL;
    HKEY        hkeyT = NULL, hkey2 = NULL;
    CHAR         szCLSIDPath[100] = "CLSID\\";   // CLSID\\{....} , less that 100.
    CHAR        szCLSIDEntry[uSizeCLSID];       // ANSI version of CLSID.
    CHAR*        szProgID = NULL;                // a pointer to ANSI version of ProgID.
    DWORD        dwSizeofProgID = 0;             // # of char of ProgID.
    DBG_ASSERT(szProgIDIn);
    DBG_ASSERT(szCLSIDEntryIn);
    
    //
    //    Make a clsid ID.
    //
    WideCharToMultiByte(CP_ACP, 0, szCLSIDEntryIn, -1, szCLSIDEntry, uSizeCLSID, NULL, NULL);
    strncat(szCLSIDPath, szCLSIDEntry, uSizeCLSID);
    
    //
    //  Make a Prog ID.
    //
    // *2 for DBCS enabling for App MD path
    dwSizeofProgID = wcslen(szProgIDIn)*2 + 1;
    szProgID = new CHAR[dwSizeofProgID];
    
    if (NULL == szProgID)
        {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
        }
    WideCharToMultiByte(CP_ACP, 0, szProgIDIn, -1, szProgID, dwSizeofProgID, NULL, NULL);
    
    // install the CLSID key
    // Setting the value of the description creates the key for the clsid
    //
    if ((RegSetValueA(HKEY_CLASSES_ROOT, szCLSIDPath, REG_SZ, szClassDesc,
        strlen(szClassDesc)) != ERROR_SUCCESS))
        goto LErrExit;
    //
    // Open the CLSID key so we can set values on it
    //
    if    (RegOpenKeyExA(HKEY_CLASSES_ROOT, szCLSIDPath, 0, samDesired, &hkeyT) != ERROR_SUCCESS)
            goto LErrExit;
    //
    // install the InprocServer32 key and open the sub-key to set the named value
    //
    if ((RegSetValueA(hkeyT, szInprocServer32, REG_SZ, m_szWamDllPath, strlen(m_szWamDllPath)) != ERROR_SUCCESS) ||
        (RegOpenKeyExA(hkeyT, szInprocServer32, 0, samDesired, &hkey2) != ERROR_SUCCESS))
        goto LErrExit;
    //
    // install the ProgID key and version independent ProgID key
    //
    if ((RegSetValueA(hkeyT, szTEXT_ProgID, REG_SZ, szProgID, strlen(szProgID)) != ERROR_SUCCESS) ||
        (RegSetValueA(hkeyT, szTEXT_VIProgID, REG_SZ, szVIProgID, strlen(szVIProgID)) != ERROR_SUCCESS))
        goto LErrExit;

    if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
            goto LErrExit;

    hkeyT = hkey2;
    hkey2 = NULL;
    //
    // install the ThreadingModel named value
    //
    if (RegSetValueExA(hkeyT, szThreadingModel, 0, REG_SZ, (const BYTE *)szFreeThreaded,
        strlen(szFreeThreaded)) != ERROR_SUCCESS)
        goto LErrExit;
    if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
        goto LErrExit;
    else
        hkeyT = NULL;

   // Set up ProgID key
    if ((RegSetValueA(HKEY_CLASSES_ROOT, szProgID, REG_SZ, szClassDesc,
        strlen(szClassDesc)) != ERROR_SUCCESS))
        goto LErrExit;

    if  (RegOpenKeyExA(HKEY_CLASSES_ROOT, szProgID, 0, samDesired, &hkeyT) != ERROR_SUCCESS)
        goto LErrExit;

    if ((RegSetValueA(hkeyT, szTEXT_Clsid, REG_SZ, szCLSIDEntry, strlen(szCLSIDEntry)) != ERROR_SUCCESS))
        goto LErrExit;

    if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
        goto LErrExit;
    else
        hkeyT = NULL;

    // Set up Version Independent key only at setup IIS default time
    if (fSetVIProgID)
        {
        if ((RegSetValueA(HKEY_CLASSES_ROOT, szVIProgID, REG_SZ, szClassDesc,
            strlen(szClassDesc)) != ERROR_SUCCESS))
            goto LErrExit;

        if  (RegOpenKeyExA(HKEY_CLASSES_ROOT, szVIProgID, 0, samDesired, &hkeyT) != ERROR_SUCCESS)
            goto LErrExit;

        if ((RegSetValueA(hkeyT, szTEXT_Clsid, REG_SZ, szCLSIDEntry, strlen(szCLSIDEntry)) != ERROR_SUCCESS))
            goto LErrExit;

        if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
            goto LErrExit;
        else
            hkeyT = NULL;
        }

    hr = NOERROR;


LErrExit:
    if (szProgID)
        {
        delete [] szProgID;
        szProgID = NULL;
        }

    if (hkeyT)
        {
        RegCloseKey(hkeyT);
        }
    if (hkey2)
        {
        RegCloseKey(hkey2);
        }

    return hr;
}

/*===================================================================
UnRegisterCLSID    

UnRegister a WAM CLSID & a corresponding WAM PROG ID.

Parameter:
szCLSIDEntryIn:    [in]     CLSID for a WAM.
fDeleteVIProgID:        TRUE, to delete the version independent prog id, FALSE, not touch VI progID.

Return:        HRESULT
===================================================================*/
HRESULT WamRegRegistryConfig::UnRegisterCLSID
(
IN LPCWSTR wszCLSIDEntryIn, 
IN BOOL fDeleteVIProgID
)
{
    HRESULT        hr = E_FAIL;
    HKEY        hkey = NULL;
    CHAR        szCLSIDEntry[uSizeCLSID];
    CHAR        szCLSIDPath[100] = "CLSID\\";
    WCHAR        *szProgID = NULL;
    CLSID       Clsid_WAM;
    static      const WCHAR szVIProgID[]    = L"IISWAM.Application";

    DBG_ASSERT(wszCLSIDEntryIn);
    //
    //    Make a clsid ID.
    //
    WideCharToMultiByte(CP_ACP, 0, wszCLSIDEntryIn, -1, szCLSIDEntry, uSizeCLSID, NULL, NULL);
    strncat(szCLSIDPath, szCLSIDEntry, uSizeCLSID);

    //
    // UnRegister ProgID and Version Independent Prog ID.
    //
    hr = CLSIDFromString((WCHAR *)wszCLSIDEntryIn, &Clsid_WAM);
    if (SUCCEEDED(hr))
        {
        hr = ProgIDFromCLSID(Clsid_WAM, &szProgID);    
        if (SUCCEEDED(hr))
            {
            hr = UnRegisterProgID(szProgID);
            CoTaskMemFree(szProgID);
            szProgID = NULL;
            }
        else
            {
            DBGPRINTF((DBG_CONTEXT, "error = %08x\n", hr));
            }
        }
    else
        {
        DBGPRINTF((DBG_CONTEXT, "error = %08x\n", hr));
        }


    if (fDeleteVIProgID)
        {
        hr = UnRegisterProgID(szVIProgID);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "error = %08x\n", hr));
            }
        }

    DWORD dwReg;
    //
    // Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
    //
    dwReg = RegOpenKeyExA(HKEY_CLASSES_ROOT, szCLSIDPath, 0, samDesired, &hkey);
    if    (dwReg == ERROR_SUCCESS)
        {    
        DWORD        iKey = 0;
        CHAR        szKeyName[MAX_PATH];  
        DWORD        cbKeyName;
        //
        // Enumerate all its subkeys, and delete them
        //    for (iKey=0;;iKey++) might not work with multiple sub keys, the last interation has iKey >
        // the actually number of subkeys left.  Set iKey = 0, so that we can always delete them all.
        //
        while(TRUE)
            {
            cbKeyName = sizeof(szKeyName);
            if (RegEnumKeyExA(hkey, iKey, szKeyName, &cbKeyName, 0, NULL, 0, NULL) != ERROR_SUCCESS)
                break;

            if (RegDeleteKeyA(hkey, szKeyName) != ERROR_SUCCESS)
                break;
            }

        // Close the key, and then delete it
        dwReg = RegCloseKey(hkey);
        if ( dwReg != ERROR_SUCCESS)
            {
            DBGPRINTF((DBG_CONTEXT, "error = %08x\n", HRESULT_FROM_WIN32(dwReg)));
            }
        }

    dwReg = RegDeleteKeyA(HKEY_CLASSES_ROOT, szCLSIDPath);
    if ( dwReg != ERROR_SUCCESS)
        {
        DBGPRINTF((DBG_CONTEXT, "error = %08x\n", HRESULT_FROM_WIN32(dwReg)));
        }

    //
    // Return hr Result
    //
    if (SUCCEEDED(hr))
        {
        if (dwReg != ERROR_SUCCESS)
            {
            hr = HRESULT_FROM_WIN32(dwReg);
            }
        }
    else
        {
        DBG_ASSERT((DBG_CONTEXT, "Failed to UnRegisterCLSID, %S, fDeleteVIProgID = %s\n",
            wszCLSIDEntryIn,
            (fDeleteVIProgID ? "TRUE" : "FALSE")));
        }
        
    return hr;
}

/*===================================================================
UnRegisterProgID

UnRegister a Prog ID.

Parameter:
szProgID:    [in]     Prog ID can be a version independent Prog ID.

Return:        HRESULT
===================================================================*/
HRESULT WamRegRegistryConfig::UnRegisterProgID
(
IN LPCWSTR szProgIDIn
)
{
    HKEY        hkey = NULL;
    DWORD        iKey;
    DWORD        cbKeyName;
    DWORD        dwSizeofProgID;
    CHAR        szKeyName[255];
    CHAR*        szProgID = NULL;
    HRESULT        hr = E_FAIL;

    DBG_ASSERT(szProgIDIn);
    //
    //  Make a Prog ID.
    //
    // DBCS enabling *2
    dwSizeofProgID = wcslen(szProgIDIn)*2 + 1;
    szProgID = new CHAR[dwSizeofProgID];
    
    if (NULL == szProgID)
        {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
        }
    WideCharToMultiByte(CP_ACP, 0, szProgIDIn, -1, szProgID, dwSizeofProgID, NULL, NULL);
    
    // Open the HKEY_CLASSES_ROOT\szProgID key so we can delete its subkeys
    if    (RegOpenKeyExA(HKEY_CLASSES_ROOT, szProgID, 0, samDesired, &hkey) != ERROR_SUCCESS)
        goto LErrExit;

    // Enumerate all its subkeys, and delete them
    for (iKey=0;;iKey++)
        {
        cbKeyName = sizeof(szKeyName);
        if (RegEnumKeyExA(hkey, iKey, szKeyName, &cbKeyName, 0, NULL, 0, NULL) != ERROR_SUCCESS)
            break;

        if (RegDeleteKeyA(hkey, szKeyName) != ERROR_SUCCESS)
            goto LErrExit;
        }

    // Close the key, and then delete it
    if (RegCloseKey(hkey) != ERROR_SUCCESS)
        goto LErrExit;
    else
        hkey = NULL;
        
    if (RegDeleteKeyA(HKEY_CLASSES_ROOT, szProgID) != ERROR_SUCCESS)
        goto LErrExit;

    hr = NOERROR;

LErrExit:
    if (szProgID)
        delete [] szProgID;

    if (hkey)
        RegCloseKey(hkey);
        
    return hr;
}


/*===================================================================
LoadWamDllPath    

Read Wam Dll Path from Registry.  This function is implemented in ANSI version
of Registry API(Win95 compatibility).

Parameter:

Return:     HRESULT
Side Affect:
    NONE.
===================================================================*/
HRESULT WamRegRegistryConfig::LoadWamDllPath
(
void
)
{
    LONG    lReg = 0;
    HKEY    hKey = NULL;
    HRESULT hr = NOERROR;

    m_szWamDllPath[0] = '\0';
    
    lReg = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                    "Software\\Microsoft\\InetStp",
                    0,
                    KEY_READ,
                    &hKey);

    if (lReg == ERROR_SUCCESS) 
        {
        LONG    lErr = 0;
        DWORD    dwType;
        CHAR    szWamDllName[] = "\\wam.dll";
        DWORD    cbData = (sizeof(m_szWamDllPath) - sizeof(szWamDllName));

        lErr = RegQueryValueExA(hKey,
                    "InstallPath",
                    0,
                    &dwType,
                    (LPBYTE)m_szWamDllPath,
                    &cbData);

        if (lErr == ERROR_SUCCESS)
            {
            if (dwType == REG_SZ) 
                {    
                strncat(m_szWamDllPath, szWamDllName, sizeof(szWamDllName));
                hr = NOERROR;
                }
            else
                {
                hr = E_UNEXPECTED;
                DBGPRINTF((DBG_CONTEXT, "Wrong Type for InstallPath registry key.dwType = %d\n",
                        dwType));
                }
            }
        else
            {
            hr = HRESULT_FROM_WIN32(lErr);
            }
        RegCloseKey(hKey);
        }
    else
        {
        hr = HRESULT_FROM_WIN32(lReg);
        }

    return hr;
}

/*===================================================================
SzWamProgID    

Make a WAM Prog ID, if the MetabasePath is null, assume it is the default,
that is WAM de
fault, so, it will be IISWAM.W3SVC.  Otherwise, the format is
IISWAM.__1__Application__Path where application path is \\LM\w3svc\1\
Application_path.

Parameter:
szMetabasePath:            [in] MetabasePath.

Return:        
TYPE:    LPWSTR, a string contains ProgID
        NULL, if failed.
        
Side Affect:
    Allocate memory for return result use new.  Caller needs to free szWamProgID 
use delete[].
===================================================================*/
HRESULT WamRegGlobal::SzWamProgID    
(
IN LPCWSTR pwszMetabasePath,
OUT LPWSTR* ppszWamProgID
)
{
    HRESULT            hr = NOERROR;
    static WCHAR    wszIISProgIDPreFix[]    = L"IISWAM.";   
    WCHAR            *pwszResult = NULL;
    WCHAR            *pwszApplicationPath = NULL;
    UINT             uPrefixLen = (sizeof(wszIISProgIDPreFix) / sizeof(WCHAR));


    DBG_ASSERT(pwszMetabasePath);
    *ppszWamProgID = NULL;

    //
    // Make a new WAM Prog ID based on pwszMetabasepath
    //
    WCHAR     *pStr, *pResult;
    UINT    uSize = 0;

    //
    // CONSIDER: use (sizeof(L"/LM/W3SVC/")/sizeof(WCHAR) - 1) for 10
    // CONSIDER: use global const for L"/LM/W3SVC/"
    // Since all paths start with /LM/W3SVC/, omit the prefix.
    //
    if (_wcsnicmp(pwszMetabasePath, L"\\LM\\W3SVC\\", 10) == 0 ||
        _wcsnicmp(pwszMetabasePath, L"/LM/W3SVC/", 10) == 0)
        {
        pwszApplicationPath = (WCHAR *)(pwszMetabasePath + 10);
        }
    else
        {
        *ppszWamProgID = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }

    if (SUCCEEDED(hr))
        {
        pStr = pwszApplicationPath;
        //
        // Calculate uSize for allocation
        //
        while(*pStr != NULL)
            {
            //
            // '/' or '\\' will be converted to '__', from 1 char to 2 chars.
            //
            if (*pStr == '\\' || *pStr == '/')
                uSize ++;
            pStr++;
            uSize++;
            }

        DBG_ASSERT(uSize > 0);
        uSize += uPrefixLen;
        
        // uSize takes the null terminator into count.
        pwszResult = new WCHAR[uSize];
        if (pwszResult != NULL)
            {
            wcsncpy(pwszResult, wszIISProgIDPreFix, uPrefixLen);
            pStr = pwszApplicationPath;
            pResult = pwszResult + uPrefixLen - 1;
            
            while(*pStr != NULL)
                {
                if (*pStr == '\\' || *pStr == '/')
                    {
                    *pResult++ = '_';
                    *pResult++ = '_';
                    pStr++;
                    }
                else
                    {
                    *pResult++ = *pStr++;
                    }
                }

            // NULL Terminating the result
            pwszResult[uSize-1] = '\0';
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }

    if (SUCCEEDED(hr))
        {
        *ppszWamProgID = pwszResult;
        }
        
    return hr;
}

/*===================================================================
GetViperPackageName    

Make a Package Name.  Follow the naming conversion, "IIS-{web site name/
application name}"

Parameter:
szMetabasePath:            [in] MetabasePath.

Return:        HRESULT
Side Affect:
    Allocate memory for return result use new.  Caller needs to free 
szPackageName using delete[].
===================================================================*/
HRESULT    WamRegGlobal::GetViperPackageName    
(
IN LPCWSTR    wszMetabasePath,
OUT LPWSTR*    ppszPackageNameOut
)
{
    static WCHAR    wszPackageNamePreFix[]        = L"IIS-{";
    static WCHAR    wszPackageNamePostFix[]        = L"}";
    WCHAR            wszServerName[500];

    WCHAR*            pwszPackageName;
    WCHAR            *wszResult = NULL;
    WCHAR             *pStr, *pResult;
    
    UINT            cPackageName = 0;
    UINT            cServerName = 0;
    UINT            uSize = 0;

    HRESULT         hr = NOERROR;
    WamRegMetabaseConfig    MDConfig;

    if ((_wcsnicmp(wszMetabasePath, WamRegGlobal::g_szMDAppPathPrefix, WamRegGlobal::g_cchMDAppPathPrefix) == 0) ||
        (_wcsnicmp(wszMetabasePath, WamRegGlobal::g_szMDAppPathPrefix, WamRegGlobal::g_cchMDAppPathPrefix) == 0))
        {
        hr = MDConfig.GetWebServerName(wszMetabasePath, wszServerName, sizeof(wszServerName));
        if (SUCCEEDED(hr))
            {
            cServerName = wcslen(wszServerName);
            }
        }
    else
        {
        hr = E_FAIL;
        DBGPRINTF((DBG_CONTEXT, "Unknown metabase path %S\n", wszMetabasePath));
        DBG_ASSERT(FALSE);    // Confused ??? MetabasePath has other format? not start with /LM/W3SVC/ ???
        }

    if (SUCCEEDED(hr))
        {
        pwszPackageName = (WCHAR *)(wszMetabasePath + 10);
        // Explanation: skip the 1 at /LM/W3SVC/1/, 1 is the virtual server, the 
        // naming conversion
        // will replace the number 1 with some nice name(from GetWebServerName call).
        while(*pwszPackageName != NULL)
            {
                if (*pwszPackageName == L'\\' || *pwszPackageName == L'/')
                    break;
                pwszPackageName++;
            }
        
        DBG_ASSERT(pwszPackageName != NULL);    // We must be able find '\\' or '/' before we scan the whole path.
        cPackageName = wcslen(pwszPackageName);

        pStr = pwszPackageName;
        // 8 = wcslen(TEXT("IIS-{")) + wcslen(TEXT("}")) + '/' + null terminator
        uSize = 8 + cPackageName + cServerName;

        wszResult = new WCHAR [uSize];
        if (wszResult != NULL)
            {
            //
            // IIS-{
            //
            pResult = wszResult;
            wcsncpy(wszResult, wszPackageNamePreFix, sizeof(wszPackageNamePreFix) / sizeof(WCHAR));
            pResult += sizeof(wszPackageNamePreFix) / sizeof(WCHAR) - 1;

            //
            // IIS-{ Web Sever Name
            //
            wcsncpy(pResult, wszServerName, cServerName + 1);
            pResult += cServerName;
            
            //
            // IIS-{  Web Server Name /
            //
            wcsncpy(pResult, L"/", sizeof(L"/"));
            pResult += 1;    // sizeof(TEXT("/")) == 2

            //
            // IIS-{  Web Server Name / PackageName(ApplicationName)
            //
            wcsncpy(pResult, pwszPackageName, cPackageName + 1);
            pResult += cPackageName;

            //
            // IIS-{  Web Server Name / PackageName(ApplicationName)  }  \n
            //
            wcsncpy(pResult, wszPackageNamePostFix, sizeof(wszPackageNamePostFix) / sizeof(WCHAR));
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }
        
    if (FAILED(hr))
        {
        if (wszResult)
            {
            free(wszResult);
            }
        *ppszPackageNameOut = NULL;
        }
    else
        {
        DBG_ASSERT(wszResult);
        *ppszPackageNameOut = wszResult;
        }
        
    return hr;
}

/*===================================================================
ConstructFullPath

When use GetDataPaths call, it only returns patial path relative to a metabase path.
(sub node of a metabase path).  This fuction will contruct the complete metabase path to
a sub node.

Parameter:
pwszMetabasePathPrefix:         [in] MetabasePath.
pwszPartialPath
ppwszResult                     result buffer
Return:     HRESULT
Side Affect:
    Allocate memory for return result use new.  Caller needs to free
*ppwszResult using delete[].
===================================================================*/
HRESULT WamRegGlobal::ConstructFullPath
(
IN LPCWSTR pwszMetabasePathPrefix,
IN DWORD dwcPrefix,
IN LPCWSTR pwszPartialPath,
OUT LPWSTR* ppwszResult
)
{
    HRESULT    hr = NOERROR;
    DWORD    cchPrefix = dwcPrefix;
    DWORD    cchPartialPath = 0;
    DWORD    cchFullPath = 0;
    WCHAR    *pResult = NULL;
    BOOL    fHasEndSlash = FALSE;

    DBG_ASSERT(pwszPartialPath != NULL);
    
    if (pwszMetabasePathPrefix[dwcPrefix-1] == L'\\' ||
        pwszMetabasePathPrefix[dwcPrefix-1] == L'/')
        {
        cchPrefix--;    
        }

    cchPartialPath = wcslen(pwszPartialPath);

    // Skip the ending '/' of pwszPartialPath if thereis any.
    
    if (cchPartialPath > 0 && 
       (pwszPartialPath[cchPartialPath-1] == L'/' 
       || pwszPartialPath[cchPartialPath-1] == L'\\'))
         {
         cchPartialPath--;
         fHasEndSlash=TRUE;
         }

    cchFullPath = cchPrefix + cchPartialPath + 1;

    pResult = new WCHAR [cchFullPath];

    if (pResult)
        {
        memcpy(pResult, pwszMetabasePathPrefix, cchPrefix*sizeof(WCHAR));
        memcpy(pResult+cchPrefix, pwszPartialPath, cchPartialPath*sizeof(WCHAR));
        pResult[cchFullPath-1] = L'\0';
        }
    else
        {
        hr = E_OUTOFMEMORY;
        }

    *ppwszResult = pResult;

    return hr;
}

/*===================================================================
GetNewSzGUID    

Generate a new GUID and put into *ppszGUID.

Parameter:
LPWSTR *ppszGUID    a pointer to an array, allocated in this function
                    and freed by caller.

Return:     HRESULT
===================================================================*/
HRESULT WamRegGlobal::GetNewSzGUID(OUT LPWSTR *ppszGUID)
{
    GUID    GUID_Temp;
    HRESULT hr;

    DBG_ASSERT(ppszGUID);
    
    // Create a new WAM CLSID
    hr = CoCreateGuid(&GUID_Temp);
    if (SUCCEEDED(hr))
        {
        hr = StringFromCLSID(GUID_Temp, ppszGUID);
        if (FAILED(hr))
            {
            *ppszGUID = NULL;
            }
        }
    return hr;
}

/*===================================================================
CreatePooledApp    

Register a WAM CLSID.

Parameter:
szMetabasePath:        [in]     MetabaseKey.

Return:        HRESULT
===================================================================*/
HRESULT WamRegGlobal::CreatePooledApp
( 
IN LPCWSTR szMetabasePath,
IN BOOL    fInProc,
IN BOOL    fRecover 
)
    {
    HRESULT         hr = NOERROR;
    WamRegMetabaseConfig   MDConfig;
    
    DBG_ASSERT(szMetabasePath);        
    if (SUCCEEDED(hr))
        {
        MDPropItem     rgProp[IWMDP_MAX];

        MDConfig.InitPropItemData(&rgProp[0]);

        // Update APPRoot
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_ROOT, szMetabasePath);

        //Update AppIsolated
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_ISOLATED, 
                                (fInProc) ? static_cast<DWORD>(eAppRunInProc) 
                                          : static_cast<DWORD>(eAppRunOutProcInDefaultPool));

        //
        // in case this is an recover operation, we do not remove App Friendly Name.
        //
        if (!fRecover)
            {
            MDConfig.MDSetPropItem(&rgProp[0], IWMDP_FRIENDLY_NAME, L"");
            }

        hr = MDConfig.UpdateMD( rgProp, METADATA_INHERIT, szMetabasePath );
        }
            
    if (FAILED(hr))
        {
        HRESULT hrT = NOERROR;

        DBGPRINTF((DBG_CONTEXT, "Failed to create in proc application. path = %S, error = %08x\n",
            szMetabasePath,
            hr));
        }

    return hr;
    }

/*===================================================================
CreateOutProcApp

Create an out prop application.

Parameter:
szMetabasePath:     [in]    MetabaseKey.
fRecover            [in]    if TRUE, we recover/recreate the application.
fSaveMB             [in]    if TRUE, save metabase immediately
Return:     HRESULT
===================================================================*/

HRESULT WamRegGlobal::CreateOutProcApp(
    IN LPCWSTR szMetabasePath,
    IN BOOL fRecover, /* = FALSE */
    IN BOOL fSaveMB   /* = TRUE */
    )
{
    WCHAR        *szWAMCLSID = NULL;
    WCHAR         *szPackageID = NULL; 
    WCHAR        *szNameForNewPackage = NULL;
    HRESULT        hr;
    HRESULT        hrRegister = E_FAIL;
    HRESULT        hrPackage = E_FAIL;
    HRESULT        hrMetabase = E_FAIL;
    WCHAR        szIdentity[MAX_PATH];
    WCHAR        szPwd[MAX_PATH];

    WamRegMetabaseConfig    MDConfig;
    WamRegPackageConfig     PackageConfig;
    
    DBG_ASSERT(szMetabasePath);        

    hr = GetNewSzGUID(&szWAMCLSID);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to create a new szGUID. error = %08x\n", hr));
        return hr;
        }
    else
        {
        WCHAR    *szProgID = NULL;
        // Do WAM CLSID registration
        //
        hr = SzWamProgID(szMetabasePath, &szProgID);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Create WAM ProgID, hr = %08x\n",
                hr));
            }
        else
            {
            hr = g_RegistryConfig.RegisterCLSID(szWAMCLSID, szProgID, FALSE);
            hrRegister = hr;
            delete [] szProgID;
            szProgID = NULL;
            if (FAILED(hrRegister)) 
                {
                DBGPRINTF((DBG_CONTEXT, "Failed to registerCLSID. error %08x\n", hr));
                }
            }
        }

    if (SUCCEEDED(hr))
        {
        WCHAR szLastOutProcPackageID[uSizeCLSID];

        // 
        // When an outproc package gets deleted, it might/might not removed from the MTS,
        // the next time, same app path marked as out-proc again, we try to reuse the outproc
        // package.  Therefore, we need to save the OutprogPackageID as LastOutProcPackageID.
        //
        szLastOutProcPackageID[0] = NULL;
            
        MDConfig.MDGetLastOutProcPackageID(szMetabasePath, szLastOutProcPackageID);        
        if (szLastOutProcPackageID[0] == NULL)
            {
            hr = GetNewSzGUID(&szPackageID);
            }
        else
            {
            szPackageID = (WCHAR *)CoTaskMemAlloc(uSizeCLSID*sizeof(WCHAR));
            if (szPackageID == NULL)
                {
                hr = E_OUTOFMEMORY;
                }
            else
                {
                wcsncpy(szPackageID, szLastOutProcPackageID, uSizeCLSID);
                }
            }
        }

    if (SUCCEEDED(hr))
        {
        hr = GetViperPackageName(szMetabasePath, &szNameForNewPackage);
        }

    if (SUCCEEDED(hr))
        {
        hr = MDConfig.MDGetIdentity(szIdentity, sizeof(szIdentity), szPwd, sizeof(szPwd));
        }

    if (SUCCEEDED(hr))
        {
        //
        // Create the catalog object etc for MTS configuration
        //
        hr = PackageConfig.CreateCatalog();

        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call MTS Admin API. error %08x\n", hr));
            }
        else
            {
            hr = PackageConfig.CreatePackage(
                                szPackageID,
                                szNameForNewPackage,
                                szIdentity,
                                szPwd,
                                FALSE);

            if (SUCCEEDED(hr))
                {
                hr  = PackageConfig.AddComponentToPackage(
                                                szPackageID,
                                                szWAMCLSID);
                if (FAILED(hr))
                    {
                    PackageConfig.RemovePackage(szPackageID);
                    }
                }
            }

        hrPackage = hr;
        }

    
    if (SUCCEEDED(hr))
        {
        MDPropItem     rgProp[IWMDP_MAX];

        MDConfig.InitPropItemData(&rgProp[0]);
        
        // Update WAMCLSID
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_WAMCLSID, szWAMCLSID);
            
        // Update APPRoot
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_ROOT, szMetabasePath);

        //Update AppIsolated
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_ISOLATED, 1);

        //Update AppPackageName
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_PACKAGE_NAME, szNameForNewPackage);

        //Update AppPackageID
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_PACKAGEID, szPackageID);
        
        //
        // in case this is an recover operation, we do not remove App Friendly Name.
        //
        if (!fRecover)
            {
            // It doesn't really make sense to set this on every isolated application.
            // This will be much easier to administer globally if we allow it to be set
            // at a higher level.

            // MDConfig.MDSetPropItem(&rgProp[0], IWMDP_OOP_RECOVERLIMIT, APP_OOP_RECOVER_LIMIT_DEFAULT);
            
            MDConfig.MDSetPropItem(&rgProp[0], IWMDP_FRIENDLY_NAME, L"");
            }
            
        // Attempt to Save the metabase changes immediately. We want to ensure
        // that the COM+ package is not orphaned.
        hr = MDConfig.UpdateMD(rgProp, METADATA_INHERIT, szMetabasePath, fSaveMB );
            
        if (FAILED(hr))
            {
            // Removed AbortUpdateMD call - we shouldn't wax the MB settings or
            // we will orphan the COM+ package.
            DBGPRINTF((
                DBG_CONTEXT, 
                "Failed to set metabase properties on (%S). error == %08x\n",
                szMetabasePath,
                hr
                ));
            }

        hrMetabase = hr;
        }

    if (FAILED(hr))
        {
        HRESULT hrT = NOERROR;

        DBGPRINTF((DBG_CONTEXT, "Failed to create out proc application. path = %S, error = %08x\n",
            szMetabasePath,
            hr));
            
        if (SUCCEEDED(hrPackage))
            {
            hrT = PackageConfig.RemovePackage( szPackageID);
            }
        if (SUCCEEDED(hrRegister))
            {
            hrT = g_RegistryConfig.UnRegisterCLSID(szWAMCLSID, FALSE);    
            if (FAILED(hrT))
                {
                DBGPRINTF((DBG_CONTEXT, "Rollback: Failed to UnRegisterCLSID. error = %08x\n", hr));
                }
            }
        }
    
    if (szWAMCLSID)
        {
        CoTaskMemFree(szWAMCLSID);
        szWAMCLSID = NULL;
        }

    if (szPackageID)
        {
        CoTaskMemFree(szPackageID);
        szWAMCLSID = NULL;
        }

    if (szNameForNewPackage)
        {
        delete [] szNameForNewPackage;
        szNameForNewPackage = NULL;
        }

    return hr;
}

HRESULT 
WamRegGlobal::CreateOutProcAppReplica(
    IN LPCWSTR szMetabasePath,
    IN LPCWSTR szAppName,
    IN LPCWSTR szWamClsid,
    IN LPCWSTR szAppId
    )
/*++
Function:

    Called by the DeSerialize replication method to create a
    new oop application.

Arguments:

    szMetabasePath  
    szAppName       
    szWamClsid      
    szAppId         

Return:

--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT(szMetabasePath);
    DBG_ASSERT(szWamClsid);
    DBG_ASSERT(szAppId);

    //
    // Register wam.dll as a new component
    //

    WCHAR * szProgID = NULL;
    BOOL    fRegisteredWam = FALSE;

    hr = SzWamProgID(szMetabasePath, &szProgID);
    if( SUCCEEDED(hr) )
    {
        DBG_ASSERT( szProgID != NULL );
        
        hr = g_RegistryConfig.RegisterCLSID( szWamClsid, 
                                             szProgID, 
                                             FALSE
                                             );
        if( SUCCEEDED(hr) )
        {
            fRegisteredWam = TRUE;
        }

        delete [] szProgID;
        szProgID = NULL;
    }

    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to register wam.dll. hr=%08x\n",
                    hr
                    ));
    }

    //
    // Get required application info
    //
    BOOL    fGetCOMAppInfo = FALSE;
    WCHAR   szIdentity[MAX_PATH];
    WCHAR   szPwd[MAX_PATH];

    WamRegMetabaseConfig    MDConfig;
    
    if( fRegisteredWam )
    {
        hr = MDConfig.MDGetIdentity( szIdentity, 
                                     sizeof(szIdentity), 
                                     szPwd, 
                                     sizeof(szPwd)
                                     );
        if( SUCCEEDED(hr) )
        {
            fGetCOMAppInfo = TRUE;
        }
        else
        {
            DBGERROR(( DBG_CONTEXT,
                       "Failed get required COM application info. hr=%08x\n",
                        hr
                        ));
        }
    }

    //
    // Create the COM+ application
    //

    if( fGetCOMAppInfo )
    {
        WamRegPackageConfig PackageConfig;
    
        hr = PackageConfig.CreateCatalog();

        if( SUCCEEDED(hr) )
        {
            hr = PackageConfig.CreatePackage(
                                szAppId,
                                szAppName,
                                szIdentity,
                                szPwd,
                                FALSE
                                );
            if( SUCCEEDED(hr) )
            {
                hr  = PackageConfig.AddComponentToPackage(
                            szAppId,
                            szWamClsid
                            );
            }

            // On failure we might want to cleanup, but I'm not sure
            // that really makes sense.
        }

        // At this point, we would normally set the metabase properties
        // but we will let the MB replication handle that for us.
        // Note: if the MB replication fails, we will be left with
        // a bunch of orphaned com applications

        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT,
                       "COM+ App creation failed. AppId(%S) Name(%S) "
                       "Clsid(%S) hr=%08x\n",
                       szAppId,
                       szAppName,
                       szWamClsid,
                       hr
                       ));
        }
    }

    return hr;
}

/*===================================================================
DeleteApp

Register a WAM CLSID.

Parameter:
szMetabasePath:     [in]    MetabaseKey.
fDeletePackage:     [in]    when uninstall, this flag is true, we delete all IIS created packages.
fRemoveAppPool      [in]    Should the AppPoolId Property be removed
Return:     HRESULT
===================================================================*/
HRESULT WamRegGlobal::DeleteApp
(
IN LPCWSTR szMetabasePath,
IN BOOL fRecover,
IN BOOL fRemoveAppPool
)
{
    WCHAR   szWAMCLSID[uSizeCLSID];
    WCHAR   szPackageID[uSizeCLSID];
    DWORD   dwAppMode = eAppRunInProc;
    DWORD   dwCallBack;
    HRESULT hr, hrRegistry;
    METADATA_HANDLE hMetabase = NULL;
    WamRegMetabaseConfig    MDConfig;
    
    hr = MDConfig.MDGetDWORD(szMetabasePath, MD_APP_ISOLATED, &dwAppMode);

    // return immediately, no application is defined, nothing to delete.
    if (hr == MD_ERROR_DATA_NOT_FOUND)
        {
        return NOERROR;
        }

    if (FAILED(hr))
        {
        return hr;
        }
        
    //
    //Set App State to be PAUSE/DISABLE, so that after we remove the application from
    //run time WAM_DICTATOR lookup table, new request won't trigger the application to
    //retstart.
    //WAM_DICTATOR has code to check for this state.
    //
    hr = MDConfig.MDSetAppState(szMetabasePath, APPSTATUS_PAUSE);
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "MDSetAppState Failed hr=%08x\n",
                    hr
                    ));
    }

    hr = W3ServiceUtil(szMetabasePath, APPCMD_DELETE, &dwCallBack);
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "W3ServiceUtil APPCMD_DELETE Failed on (%S) hr=%08x\n",
                    szMetabasePath,
                    hr
                    ));
    }

    if (dwAppMode == eAppRunOutProcIsolated)
        {
        // Get WAM_CLSID, and PackageID.
        hr = MDConfig.MDGetIDs(szMetabasePath, szWAMCLSID, szPackageID, dwAppMode);
        // Remove the WAM from the package.
        if (SUCCEEDED(hr))
            {
            WamRegPackageConfig     PackageConfig;
            HRESULT hrPackage;
            
            hr = PackageConfig.CreateCatalog();

            if ( FAILED( hr)) 
                {
                DBGPRINTF(( DBG_CONTEXT,
                            "Failed to Create MTS catalog hr=%08x\n",
                            hr));
                } 
            else 
                {            
                hr = PackageConfig.RemoveComponentFromPackage(szPackageID, 
                                               szWAMCLSID, 
                                               dwAppMode);
                if (FAILED(hr))    
                    {
                        DBGPRINTF((DBG_CONTEXT, "Failed to remove component from package, \npackageid = %S, wamclsid = %S, hr = %08x\n",
                                   szPackageID,
                                   szWAMCLSID,
                                   hr));
                    }
                }
            hrPackage = hr;
            }

        // Unregister WAM
        hr = g_RegistryConfig.UnRegisterCLSID(szWAMCLSID, FALSE);    
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to UnRegister WAMCLSID(%S), hr = %08x\n",
                szWAMCLSID,
                hr));
            hrRegistry = hr;
            }
        }
        
    if (SUCCEEDED(hr))
        {
        BOOL fChanged = FALSE;
        MDPropItem     rgProp[IWMDP_MAX];
        MDConfig.InitPropItemData(&rgProp[0]);
        if (dwAppMode == static_cast<DWORD>(eAppRunOutProcIsolated))
            {    
            // Delete AppPackageName.  (Inherited from W3SVC)
            // Delete AppPackageID. (Inherited from W3SVC)
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_PACKAGE_NAME);
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_PACKAGEID);

            // Delete WAMCLSID
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_WAMCLSID);
            
            if (TsIsNtServer() || TsIsNtWksta())
                {
                MDConfig.MDSetPropItem(&rgProp[0], IWMDP_LAST_OUTPROC_PID, szPackageID);
                }
            fChanged = TRUE;
            }
        // If this is DeleteRecoverable mode, we do not delete APP_ROOT, APP_ISOLATED,
        // OOP_RECOVERLIMIT and APP_STATE.
        if (!fRecover)
            {
            // Delete AppFriendlyName
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_FRIENDLY_NAME);
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_ROOT);
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_ISOLATED);
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_APPSTATE);
            if (fRemoveAppPool)
                {
                MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_OOP_APP_APPPOOL_ID);
                }

            if (dwAppMode == static_cast<DWORD>(eAppRunOutProcIsolated))
                {
                // This will only be set for older isolated applications.
                // Since we ignore the result of UpdateMD below, it is ok
                // for us to try to delete the property.
                MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_OOP_RECOVERLIMIT);
                }
            fChanged = TRUE;
            }

        // For DeleteRecover operation, and the app is not outproc isolated,
        // No property changes, therefore, no need to update metabase.
        if (fChanged)
            {
            MDConfig.UpdateMD(rgProp, METADATA_NO_ATTRIBUTES, szMetabasePath);
            }
        }
        
    return NOERROR;
}

/*===================================================================
RecoverApp

Recover an application based on MD_APP_ISOLATED property.

Parameter:
szMetabasePath:     [in]    MetabaseKey.

Return:     HRESULT
===================================================================*/
HRESULT WamRegGlobal::RecoverApp
(
IN LPCWSTR szMetabasePath,
IN BOOL fForceRecover
)
{
    HRESULT hr = NOERROR;
    DWORD    dwAppMode = 0;
    WamRegMetabaseConfig    MDConfig;

    hr = MDConfig.MDGetDWORD(szMetabasePath, MD_APP_ISOLATED, &dwAppMode);
    if (hr == MD_ERROR_DATA_NOT_FOUND)
        {
        hr = NOERROR;
        }
    else
        {
        if (SUCCEEDED(hr))
            {
            if (fForceRecover)
                {
    			if (dwAppMode == static_cast<DWORD>(eAppRunOutProcInDefaultPool))
    				{
    				hr = CreatePooledApp(szMetabasePath, FALSE);				
    				}
    			else if (dwAppMode == static_cast<DWORD>(eAppRunInProc))
                    {
                    hr = CreatePooledApp(szMetabasePath, TRUE);				
                    }
    			else
    				{
    				hr = CreateOutProcApp(szMetabasePath);
    				}
                }
                
            if (SUCCEEDED(hr))
                {
                HRESULT hrT = NOERROR;
                hrT = MDConfig.MDRemoveProperty(szMetabasePath, MD_APP_STATE, DWORD_METADATA);
                if (FAILED(hrT))
                    {
                    if (hrT != MD_ERROR_DATA_NOT_FOUND)
                        {
                        DBGPRINTF((DBG_CONTEXT, "Failed to remove MD_APP_STATE from path %S, hr = %08x\n",
                            szMetabasePath,
                            hrT));
                        }
                    }
                }
            }
        }
        
    return hr;
}
/*============================================================================
W3ServiceUtil

sink function that unload/shutdown/querystatus of an application currently in the runtime
table.

Parameter:
szMDPath            the application Path.
dwCommand           The command.
pdwCallBackResult   Contains the HRESULT from w3svc.dll.

==============================================================================*/
HRESULT WamRegGlobal::W3ServiceUtil
(
IN LPCWSTR  szMDPath,
IN DWORD    dwCommand,
OUT DWORD*    pdwCallBackResult
)
{
    HRESULT hr = NOERROR;

    if (g_pfnW3ServiceSink)
        {

#ifndef _IIS_6_0

        // DBCS enabling for IIS 5.1
        INT cSize = wcslen(szMDPath)*2 + 1;

        CHAR *szPathT = new CHAR[cSize];

        if (szPathT)
            {
            WideCharToMultiByte(0, 0, szMDPath, -1, szPathT, cSize, NULL, NULL);
            hr = g_pfnW3ServiceSink(szPathT,
                                    dwCommand,
                                    pdwCallBackResult);
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        
        delete [] szPathT;

#else
        //
        // IIS 6's implementation uses UNICODE directly, so
        // we'll avoid the WideCharToMultiByte nonsense and
        // just cast the path to fit the function arguments.
        //
        // We're not changing the function prototype purely
        // because we are minimizing code churn in this module.
        //
        
        
        // IIS 6 gets the unicode directly
        hr = g_pfnW3ServiceSink(reinterpret_cast<LPCSTR>(szMDPath),
                                dwCommand,
                                pdwCallBackResult);
#endif // _IIS_6_0
        }
    else
        {
        *pdwCallBackResult = APPSTATUS_NOW3SVC;
        hr = NOERROR;
        }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb )


// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants
//

// Use the default constants from pudebug.h

# define DEBUG_WAMREG_MTS                 0x00010000
# define DEBUG_WAMREG_REGISTRY            0x00020000
# define DEBUG_WAMREG_METABASE            0x00040000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__29822AB4_F302_11D0_9953_00C04FD919C1__INCLUDED_)
#define AFX_DLLDATAX_H__29822AB4_F302_11D0_9953_00C04FD919C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__29822AB4_F302_11D0_9953_00C04FD919C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wamreg.rc
//
#define IDS_PROJNAME                    100
#define IDR_WamAdmin                      101
#define IDR_WAMREP                      102
#define IDS_WMRGSRV_DESC                103
#define IDR_WmRgSrv                     104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\export.h ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
       export.h

   Abstract:
       Declarations used by export.cpp and other utility functions that
       support wamreg setup.

   Author:
       Taylor Weiss    ( TaylorW )     08-Mar-1999

   Environment:
       User Mode - Win32

   Project:
       iis\svcs\wam\wamreg

--*/

#ifndef _WAMREG_EXPORT_H_
#define _WAMREG_EXPORT_H_


// 0 = log errors only
// 1 = log errors and warnings
// 2 = log errors, warnings and program flow type statemtns
// 3 = log errors, warnings, program flow and basic trace activity
// 4 = log errors, warnings, program flow, basic trace activity and trace to win32 api calls.
#define LOG_TYPE_ERROR                  0
#define LOG_TYPE_WARN                   1
#define LOG_TYPE_PROGRAM_FLOW           2
#define LOG_TYPE_TRACE                  3
#define LOG_TYPE_TRACE_WIN32_API        4

typedef void (*IIS5LOG_FUNCTION)(int iLogType, WCHAR *pszfmt);

//
// Local Declarations supporting setup.
//
extern IIS5LOG_FUNCTION             g_pfnSetupWriteLog;

//
// Macros that collapse a debug and setup trace call. Note these will add code to
// fre builds, the setup tracing is always on.
// 
#if DBG

    #define SETUP_TRACE(args) \
        /*DBGINFO(args); */\
        if ( g_pfnSetupWriteLog != NULL ) { \
            LogSetupTrace args ; \
        } else {}

    #define SETUP_TRACE_ERROR(args) \
        /*DBGINFO(args); */\
        if ( g_pfnSetupWriteLog != NULL ) { \
            LogSetupTraceError args ; \
        } else {}

#ifdef _NO_TRACING_
    #define SETUP_TRACE_ASSERT( exp ) \
    if ( !(exp) ) { \
            if ( g_pfnSetupWriteLog != NULL ) { \
                 LogSetupTraceError( DBG_CONTEXT, "Assertion Failed: (%s)", #exp ); \
            } \
            /*PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL); */\
        } else {}
#else
    #define SETUP_TRACE_ASSERT( exp ) \
    if ( !(exp) ) { \
            if ( g_pfnSetupWriteLog != NULL ) { \
                 LogSetupTraceError( DBG_CONTEXT, "Assertion Failed: (%s)", #exp ); \
            } \
            /*PuDbgAssertFailed( DBG_CONTEXT, #exp); */\
        } else {}
#endif

#else   // No debug

    // Defining DBG_CONTEXT in fre build. Since the DBG macros do not 
    // disappear, DBG_CONTEXT needs to be defined.
#ifndef DBG_CONTEXT
    #define DBG_CONTEXT         NULL, __FILE__, __LINE__
#endif

    #define SETUP_TRACE(args) \
        if ( g_pfnSetupWriteLog != NULL ) { \
            LogSetupTrace args ; \
        } else {}

    #define SETUP_TRACE_ERROR(args) \
        if ( g_pfnSetupWriteLog != NULL ) { \
            LogSetupTraceError args ; \
        } else {}

    #define SETUP_TRACE_ASSERT( exp ) \
        if ( !(exp) ) { \
            if ( g_pfnSetupWriteLog != NULL ) { \
                 LogSetupTraceError( DBG_CONTEXT, "Assertion Failed: (%s)", #exp ); \
            } \
        } else {}

#endif

VOID
LogSetupTrace(
   IN LPDEBUG_PRINTS       pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...
   );

VOID
LogSetupTraceError(
   IN LPDEBUG_PRINTS       pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...
   );

#endif _WAMREG_EXPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__29822AAC_F302_11D0_9953_00C04FD919C1__INCLUDED_)
#define AFX_STDAFX_H__29822AAC_F302_11D0_9953_00C04FD919C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__29822AAC_F302_11D0_9953_00C04FD919C1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\mdconfig.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: mdconfig.cpp

	interface to update/query WAM related properties in metabase.

Owner: LeiJin

Note:

===================================================================*/
#include "common.h"
#include "auxfunc.h"
#include "iiscnfgp.h"
#include "dbgutil.h"
#include "multisz.hxx"

// Time out for metabase  = 5 seconds
const DWORD		WamRegMetabaseConfig::m_dwMDDefaultTimeOut = 5*1000;

IMSAdminBaseW*  WamRegMetabaseConfig::m_pMetabase = NULL;
//
// Please refer to MDPropItem for definition
// Application properties that might be updated by WAMREG
//
const MDPropItem	WamRegMetabaseConfig::m_rgMDPropTemplate[IWMDP_MAX] =
{
	{MD_APP_ROOT, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_ISOLATED, DWORD_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_WAM_CLSID, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_PACKAGE_ID, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_PACKAGE_NAME, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_LAST_OUTPROC_PID, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_FRIENDLY_NAME, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_STATE, DWORD_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_OOP_RECOVER_LIMIT, DWORD_METADATA, 0, EMD_NONE, E_FAIL},
        {MD_APP_APPPOOL_ID, STRING_METADATA, 0, EMD_NONE, E_FAIL}
};

/*===================================================================
InitPropItemData

Init a metabase item list, prepare for metabase update.

Parameter:
pMDPropItem:	pointer to MDPropItem which is set to the default values.

Return:		NONE
===================================================================*/
VOID WamRegMetabaseConfig::InitPropItemData(IN OUT MDPropItem* pMDPropItem)
{
    DBG_ASSERT(pMDPropItem != NULL);
	memcpy(pMDPropItem, (void *)m_rgMDPropTemplate, sizeof(m_rgMDPropTemplate));
	return;
}

/*===================================================================
MetabaseInit

Initialize Metabase, and obtain Metabase DCOM interface.

Parameter:
pMetabase:	[out] 	Metabase DCOM interface pointer.

Return:			HRESULT

Side affect:	Create a Metabase object, and get interface pointer.
===================================================================*/
HRESULT WamRegMetabaseConfig::MetabaseInit
(
)
{
	HRESULT hr = NOERROR;

	m_pMetabase = (IMSAdminBase *)NULL;

	hr = CoCreateInstance(CLSID_MSAdminBase
						, NULL
						, CLSCTX_SERVER
						, IID_IMSAdminBase
						, (void**)&(m_pMetabase));

	if (FAILED(hr))
		goto LErrExit;

	return hr;

LErrExit:

	RELEASE((m_pMetabase));
	return hr;
}

/*===================================================================
MetabaseUnInit

release a metabase interface.

Parameter:
pMetabase:	[in/out] 	Metabase DCOM interface pointer.

Return:			HRESULT

Side affect:	Destroy a metabase object.
===================================================================*/
HRESULT WamRegMetabaseConfig::MetabaseUnInit
(
VOID
)
{
	RELEASE((m_pMetabase));
	return NOERROR;
}

/*===================================================================
UpdateMD	

Update a WAM application property in metabase.

Parameter:
pMetabase   a metabase pointer

prgProp     contains the info of updating a WAM properties in metabase.
            refer to the structure definition for more info.

dwMDAttributes  allows caller specified INHERITABLE attribute.

fSaveData       perform a IMSAdminBase::SaveData, defaults to false

Return:			HRESULT

Side affect:	Release pMetabase.
			
===================================================================*/
HRESULT WamRegMetabaseConfig::UpdateMD
(
 IN MDPropItem* 	prgProp,
 IN DWORD	    dwMDAttributes,
 IN LPCWSTR      wszMetabasePath,
 IN BOOL         fSaveData
 )
{
    HRESULT hr = NOERROR;
    INT		iItem  = 0;
    METADATA_HANDLE hMetabase = NULL;
    
    DBG_ASSERT(m_pMetabase);
    DBG_ASSERT(prgProp);
    DBG_ASSERT(wszMetabasePath);
    
    //
    // Open Key
    //
    hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, wszMetabasePath,
        METADATA_PERMISSION_WRITE, m_dwMDDefaultTimeOut, &hMetabase);
    
    if (SUCCEEDED(hr))
    {
        METADATA_RECORD 	recMetaData;
        //
        // Update WAM Application Metabase Properties.
        //
        for (iItem = 0; iItem < IWMDP_MAX; iItem ++)
        {
            if (prgProp[iItem].dwAction == EMD_SET)
            {
                DWORD dwUserType = IIS_MD_UT_WAM;
                
                if (iItem == IWMDP_ROOT)
                {
                    dwUserType = IIS_MD_UT_FILE;
                }
                
                if (prgProp[iItem].dwType == STRING_METADATA)
                {
                    DBG_ASSERT(prgProp[iItem].pwstrVal);
                    MD_SET_DATA_RECORD(&recMetaData, 
                        prgProp[iItem].dwMDIdentifier, 
                        dwMDAttributes, 
                        dwUserType,
                        STRING_METADATA,  
                        (wcslen(prgProp[iItem].pwstrVal)+1)*sizeof(WCHAR), 
                        (unsigned char *)prgProp[iItem].pwstrVal);
                }
                else if (prgProp[iItem].dwType == DWORD_METADATA)
                {
                    MD_SET_DATA_RECORD(&recMetaData, 
                        prgProp[iItem].dwMDIdentifier, 
                        dwMDAttributes, 
                        dwUserType,
                        DWORD_METADATA,  
                        sizeof(DWORD), 
                        (unsigned char *)&(prgProp[iItem].dwVal));
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "Unsupported data type by WAMREG.\n"));
                    DBG_ASSERT(FALSE);
                }
                
                hr = m_pMetabase->SetData(hMetabase, NULL, &recMetaData);
                prgProp[iItem].hrStatus = hr;
                if (FAILED(hr))
                {
                    DBGPRINTF((DBG_CONTEXT, "Metabase SetData failed. Path = %S, id = %08x, error = %08x\n",
                        wszMetabasePath,
                        prgProp[iItem].dwMDIdentifier,
                        hr));
                    break;
                }
            }
            
            if (prgProp[iItem].dwAction == EMD_DELETE)
            {
                hr = m_pMetabase->DeleteData(hMetabase, NULL, prgProp[iItem].dwMDIdentifier, 
                    prgProp[iItem].dwType);
            }
        }
        
        m_pMetabase->CloseKey(hMetabase);
        if (SUCCEEDED(hr) && fSaveData == TRUE)
        {
            hr = m_pMetabase->SaveData();
            if (hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
            {
                hr = NOERROR;
            }
            if (FAILED(hr))
            {
                DBG_ASSERT((DBG_CONTEXT, "Failed to call metabase->SaveData, Application path = %S,"
                    "hr = %08x\n",
                    wszMetabasePath,
                    hr));
                DBG_ASSERT(SUCCEEDED(hr));
            }
        }
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT, "Failed to open metabase path %S, error = %08x\n",
            wszMetabasePath,
            hr));
    }
    
    return hr;
}

/*===================================================================
MDUpdateIISDefault	

Write the default IIS package info to metabase under key "/LM/W3SVC".
Including

IISPackageName
IISPackageID
WAMCLSID

Parameter:
szIISPackageName:	[in] 	The Default IIS Package Name.
szIISPackageID:		[in]	The IIS Package ID.
szDefaultWAMCLSID:	[in]	The Default WAM CLSID.

Return:			HRESULT

Side affect:	Release pMetabase.
			
===================================================================*/
HRESULT WamRegMetabaseConfig::MDUpdateIISDefault
(	
IN LPCWSTR	szIISPackageName,
IN LPCWSTR	szIISPackageID,
IN LPCWSTR	szDefaultWAMCLSID
)

{
    HRESULT			hr = NOERROR;

    MDPropItem 	rgProp[IWMDP_MAX];
    
    DBG_ASSERT(szIISPackageName);
    DBG_ASSERT(szIISPackageID);
    DBG_ASSERT(szDefaultWAMCLSID);
    DBG_ASSERT(m_pMetabase != NULL);
    
    InitPropItemData(&rgProp[0]);
    
    // Update Package Name
    MDSetPropItem(&rgProp[0], IWMDP_PACKAGE_NAME, szIISPackageName);
    // Update Package ID
    MDSetPropItem(&rgProp[0], IWMDP_PACKAGEID, szIISPackageID);
    
    // Update DefaultWAMCLSID
    MDSetPropItem(&rgProp[0], IWMDP_WAMCLSID, szDefaultWAMCLSID);
    
    // Update APPRoot
    MDSetPropItem(&rgProp[0], IWMDP_ROOT, WamRegGlobal::g_szMDW3SVCRoot);
    
    //Update AppIsolated
    MDSetPropItem(&rgProp[0], IWMDP_ISOLATED, (DWORD)0);
    
    MDSetPropItem(&rgProp[0], IWMDP_LAST_OUTPROC_PID, L"");
    
    MDSetPropItem(&rgProp[0], IWMDP_FRIENDLY_NAME, L"");
    
    //
    // The default WAM Application is not inherited.
    // Set Metadata attributes to METADATA_NO_ATTRIBUTES
    // The allows us to have a way to turn the approot off, since this is above the
    // level of the server, every root dir of every server is part of application,
    // and there is no way to turn this off.  Set the default application not inheritable,
    // we have a way to turn off the approot. People should have to mark an application in
    // order to run ASP & ISAPI.
    // UpdateMD at L"/LM/W3SVC/"
    //
    hr = UpdateMD(rgProp, METADATA_NO_ATTRIBUTES, WamRegGlobal::g_szMDAppPathPrefix, TRUE);

    // Removed AbortUpdateMD code. Why would we want to ensure that things
    // won't work now?
    
    return hr;
}

/*===================================================================
AbortUpdateMD	

Abort the last update to the metabase, based on the info embeded in prgProp.

Parameter:
pMetabase   a metabase pointer
prgProp     contains the info of updating a WAM properties in metabase.
            refer to the structure definition for more info.

Return:			HRESULT

Side affect:	Release pMetabase.
			
===================================================================*/
HRESULT WamRegMetabaseConfig::AbortUpdateMD
(
IN MDPropItem* 	prgProp,
IN LPCWSTR      wszMetabasePath
)
{
    HRESULT hr = NOERROR;
	INT		iItem  = 0;
	METADATA_HANDLE hMetabase = NULL;

	DBG_ASSERT(m_pMetabase);
	DBG_ASSERT(prgProp);
	
	DBGPRINTF((DBG_CONTEXT, "WAMREG Abort Update metabase.\n"));
				
	//
	// Open Key
	//
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, wszMetabasePath,
					METADATA_PERMISSION_WRITE, m_dwMDDefaultTimeOut, &hMetabase);

	if (SUCCEEDED(hr))
		{
		METADATA_RECORD 	recMetaData;

		//
		// Update WAM Application Metabase Properties.
		//
		for (iItem = 0; iItem < IWMDP_MAX; iItem ++)
			{
			if (prgProp[iItem].dwAction == EMD_SET)
				{
				if (prgProp[iItem].hrStatus == NOERROR)
					{
					hr = m_pMetabase->DeleteData(hMetabase, NULL, prgProp[iItem].dwMDIdentifier, 
							prgProp[iItem].dwType);
							
					if (FAILED(hr) && hr != MD_ERROR_DATA_NOT_FOUND)
						{
						DBGPRINTF((DBG_CONTEXT, "Metabase Delete failed. Path = %S, id = %08x, error = %08x\n",
							wszMetabasePath,
							prgProp[iItem].dwMDIdentifier,
							hr));
						}
					}
				}
			}

		m_pMetabase->CloseKey(hMetabase);
		if (SUCCEEDED(hr))
			{
			hr = m_pMetabase->SaveData();
			if (hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
                {
                hr = NOERROR;
                }
			}
		}
	else
		{
		DBGPRINTF((DBG_CONTEXT, "Failed to open metabase path %S, error = %08x\n",
			wszMetabasePath,
			hr));
		}

	return hr;

}

HRESULT WamRegMetabaseConfig::MDSetStringProperty
(
IN IMSAdminBase * pMetabaseIn,
IN LPCWSTR szMetabasePath,
IN DWORD dwMetabaseProperty,
IN LPCWSTR szMetabaseValue,
IN DWORD dwMDUserType /* = IIS_MD_UT_WAM */
)
/*===================================================================
MDSetProperty

Set a value of a property at the given path.

Parameters:

pMetabaseIn :           [in]    optional metabase interface
szMetabasePath	:	[in]    metabase key
dwMetabaseProperty  :   [in]    Property to set
szMetabaseValue :       [in]    Value to set on property
dwMDUserType :          [in, optional] UserType to set on property

Return:		BOOL

===================================================================*/
{
    HRESULT             hr = S_OK;
    IMSAdminBase*       pMetabase = NULL;
    METADATA_HANDLE     hMetabase = NULL;
    METADATA_RECORD     mdrData;
    ZeroMemory(&mdrData, sizeof(mdrData));

    DBG_ASSERT(szMetabasePath);

    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }

    DBG_ASSERT(pMetabase);

    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                            szMetabasePath,
                            METADATA_PERMISSION_WRITE,
                            m_dwMDDefaultTimeOut, 
                            &hMetabase); 
    if (FAILED(hr))
    {
        goto done;
    }

    MD_SET_DATA_RECORD(&mdrData,
                       dwMetabaseProperty,
                       METADATA_NO_ATTRIBUTES,
                       dwMDUserType,
                       STRING_METADATA,
                       (wcslen(szMetabaseValue)+1)*sizeof(WCHAR),
                       szMetabaseValue);

    hr = pMetabase->SetData(hMetabase,
                            L"/",
                            &mdrData);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = S_OK;
done:
    if (pMetabase && hMetabase)
    {
        pMetabase->CloseKey(hMetabase);
    }
    return hr;
}

HRESULT WamRegMetabaseConfig::MDSetKeyType
(
IN IMSAdminBase * pMetabaseIn,
IN LPCWSTR szMetabasePath,
IN LPCWSTR szKeyType
)
{
    HRESULT             hr = S_OK;
    IMSAdminBase*       pMetabase = NULL;
    METADATA_HANDLE     hMetabase = NULL;
    METADATA_RECORD     mdrData;
    ZeroMemory(&mdrData, sizeof(mdrData));

    DBG_ASSERT(szMetabasePath);

    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }

    DBG_ASSERT(pMetabase);

    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                            szMetabasePath,
                            METADATA_PERMISSION_WRITE,
                            m_dwMDDefaultTimeOut, 
                            &hMetabase); 
    if (FAILED(hr))
    {
        goto done;
    }

    MD_SET_DATA_RECORD(&mdrData,
                       MD_KEY_TYPE,
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       STRING_METADATA,
                       (wcslen(szKeyType)+1)*sizeof(WCHAR),
                       szKeyType);

    hr = pMetabase->SetData(hMetabase,
                            L"/",
                            &mdrData);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = S_OK;
done:
    if (pMetabase && hMetabase)
    {
        pMetabase->CloseKey(hMetabase);
    }
    return hr;
}

HRESULT WamRegMetabaseConfig::MDDeleteKey
(
IN IMSAdminBase * pMetabaseIn,
IN LPCWSTR szMetabasePath,
IN LPCWSTR szKey
)
{
    HRESULT             hr = S_OK;
    IMSAdminBase*       pMetabase = NULL;
    METADATA_HANDLE     hMetabase = NULL;

    DBG_ASSERT(szMetabasePath);
    DBG_ASSERT(szKey);

    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }

    DBG_ASSERT(pMetabase);

    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                            szMetabasePath,
                            METADATA_PERMISSION_WRITE,
                            m_dwMDDefaultTimeOut, 
                            &hMetabase); 
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pMetabase->DeleteKey(hMetabase,
                              szKey);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = S_OK;
done:
    if (pMetabase && hMetabase)
    {
        pMetabase->CloseKey(hMetabase);
    }
    return hr;
}

BOOL    WamRegMetabaseConfig::MDDoesPathExist
(
IN IMSAdminBase * pMetabaseIn,
IN LPCWSTR szMetabasePath
)

/*===================================================================
MDDoesPathExist

Determine if a given path exists in the metabase

Parameters:

pMetabaseIn :           [in]    optional metabase interface
szMetabasePath	:	[in]	metabase key

Return:		BOOL

===================================================================*/
{
    BOOL                fRet = FALSE;
    HRESULT             hr = S_OK;
    IMSAdminBase*       pMetabase = NULL;
    METADATA_HANDLE     hMetabase = NULL;

    DBG_ASSERT(szMetabasePath);

    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }

    DBG_ASSERT(pMetabase);

    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                            szMetabasePath,
                            METADATA_PERMISSION_READ,
                            m_dwMDDefaultTimeOut, 
                            &hMetabase); 

    if (SUCCEEDED(hr))
    {
        fRet = TRUE;
        pMetabase->CloseKey(hMetabase);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

/*===================================================================
MDCreatePath

Create a metabase path.(szMetabasePath)

Parameter:

szMetabasePath	:	[in]	metabase key

Return:		HRESULT

Note: fill in the pdwAppMode, memory buffer provided by the caller.
===================================================================*/
HRESULT WamRegMetabaseConfig::MDCreatePath
(
IN IMSAdminBase *pMetabaseIn,
IN LPCWSTR szMetabasePath
)
{
    HRESULT             hr;
    IMSAdminBase        *pMetabase = NULL;
    WCHAR               *pwszApplicationPath = NULL;
    METADATA_HANDLE     hMetabase = NULL;
    
    DBG_ASSERT(szMetabasePath);
    
    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }
    
    if (_wcsnicmp(szMetabasePath, L"\\LM\\W3SVC\\", 10) == 0 ||
        _wcsnicmp(szMetabasePath, WamRegGlobal::g_szMDAppPathPrefix, WamRegGlobal::g_cchMDAppPathPrefix) == 0)
    {
        pwszApplicationPath = (WCHAR *)(szMetabasePath + 10);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        return hr;
    }
    
    // Open Key
    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPCWSTR)WamRegGlobal::g_szMDAppPathPrefix,
        METADATA_PERMISSION_WRITE, m_dwMDDefaultTimeOut, &hMetabase); 
    
    if (FAILED(hr))
    {			
        DBGPRINTF((DBG_CONTEXT, "Failed to Open metabase key, path is /LM/W3SVC, hr = %08x\n",
            hr));
    }
    else
    {		
        hr = pMetabase->AddKey(hMetabase, (LPCWSTR)pwszApplicationPath);
        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed to AddKey to metabase, path is %S, hr = %08x\n",
                szMetabasePath, 
                hr));
        }
        pMetabase->CloseKey(hMetabase);
    }
    
    return hr;
}

/*===================================================================
MDGetDWORD

Get a DWORD type property from Metabase Key(szMetabasePath)

Parameter:

szMetabasePath	:	[in]	metabase key
dwMDIdentifier  :   [in]    indentifier

Return:		HRESULT

===================================================================*/
HRESULT WamRegMetabaseConfig::MDGetDWORD
(
IN LPCWSTR szMetabasePath, 
IN DWORD dwMDIdentifier,
OUT DWORD *pdwData
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;
	IMSAdminBase 	*pMetabase = NULL;
	
	DBG_ASSERT(pdwData);
	DBG_ASSERT(szMetabasePath);

	pMetabase = m_pMetabase;

	// Open Key
	hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPCWSTR)szMetabasePath,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);

	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, dwMDIdentifier, METADATA_NO_ATTRIBUTES, 
		IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), (unsigned char *)pdwData);

		hr = pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (FAILED(hr))
			{
			DBGPRINTF((DBG_CONTEXT, "Get MD_APP_ISOLATED failed on MD path %S, id %d, error = %08x\n",
					szMetabasePath,
					dwMDIdentifier,
					hr));
			}
			
		pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

/*===================================================================
MDSetAppState

Set an application state.  (i.e.  If APPSTATE_PAUSE is set, then, the runtime
W3SVC can not launch the application).

Parameter:

szMetabasePath	:	[in]	metabase key
dwState         :           App state to be set.	

Return:		HRESULT
===================================================================*/
HRESULT	WamRegMetabaseConfig::MDSetAppState
(	
IN LPCWSTR szMetabasePath, 
IN DWORD dwState
)
{
	METADATA_RECORD 	recMetaData;
	HRESULT				hr;
	METADATA_HANDLE		hMetabase;

    DBG_ASSERT(m_pMetabase);
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
					METADATA_PERMISSION_WRITE, m_dwMDDefaultTimeOut, &hMetabase);

	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, MD_APP_STATE, METADATA_INHERIT, IIS_MD_UT_WAM,
							DWORD_METADATA,  sizeof(DWORD), (unsigned char *)&dwState);
		hr = m_pMetabase->SetData(hMetabase, NULL, &recMetaData);

		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

HRESULT WamRegMetabaseConfig::MDGetWAMCLSID
(
IN LPCWSTR szMetabasePath,
IN OUT LPWSTR szWAMCLSID
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(szWAMCLSID);
	DBG_ASSERT(szMetabasePath);

	szWAMCLSID[0] = NULL;
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, MD_APP_WAM_CLSID, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  uSizeCLSID*sizeof(WCHAR), (unsigned char *)szWAMCLSID);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBG_ASSERT(FALSE);
			}
			
		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;

}

/*===================================================================
MDGetIdentity

Get pakcage Identity from Metabase Key(szMetabasePath) (WamUserName &
WamPassword)

Parameter:

szIdentity: a string buffer for WamUserName.
cbIdneity:  size of the string buffer for szIdentity.
szPwd:      a string buffer for WamPassword.
cbPwd:      size of the string buffer for szPwd.

Return:		HRESULT

===================================================================*/
HRESULT WamRegMetabaseConfig::MDGetIdentity
(
IN LPWSTR szIdentity,
IN DWORD  cbIdentity,
IN LPWSTR szPwd,
IN DWORD  cbPwd
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(szIdentity);

	szIdentity[0] = NULL;
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)WamRegGlobal::g_szMDAppPathPrefix,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		// Get WAM user name
		MD_SET_DATA_RECORD(	&recMetaData, MD_WAM_USER_NAME, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  cbIdentity, (unsigned char *)szIdentity);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBGPRINTF((DBG_CONTEXT, "Insufficient buffer for WAM user name. Required size is %d\n",
				dwRequiredLen));
			DBG_ASSERT(FALSE);
			}

        // Get WAM user password
		MD_SET_DATA_RECORD(	&recMetaData, MD_WAM_PWD, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  cbPwd, (unsigned char *)szPwd);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBGPRINTF((DBG_CONTEXT, "Insufficient buffer for WAM user password. Required size is %d\n",
				dwRequiredLen));
			DBG_ASSERT(FALSE);
			}

		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

HRESULT 
WamRegMetabaseConfig::MDGetAppName
(
    IN  LPCWSTR     szMetaPath,
    OUT LPWSTR *    ppszAppName
)
/*++
Function:

    Retrieve the MD_APP_PACKAGE_NAME from the metabase.

Parameters:

    ppszAppName - value of MD_APP_PACKAGE_NAME allocated
                  with new[] free with delete[]

Return:

	{MD_APP_PACKAGE_NAME, STRING_METADATA, 0, EMD_NONE, E_FAIL},


--*/
{
    return MDGetStringAttribute(szMetaPath, MD_APP_PACKAGE_NAME, ppszAppName);
}

HRESULT
WamRegMetabaseConfig::MDGetStringAttribute
(
    IN LPCWSTR szMetaPath,
    DWORD dwMDIdentifier,
    OUT LPWSTR * ppszBuffer
)
{
    DBG_ASSERT( ppszBuffer );
    DBG_ASSERT( m_pMetabase );
    
    HRESULT hr = NOERROR;
    WCHAR * pwcMetaData = NULL;
    DWORD   cbData = 0;
    
    METADATA_HANDLE hKey = NULL;
    METADATA_RECORD	mdr;
    
    *ppszBuffer = NULL;
    
    hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, 
                              szMetaPath,
                              METADATA_PERMISSION_READ, 
                              m_dwMDDefaultTimeOut, 
                              &hKey);
    
    if( SUCCEEDED(hr) )
    {
        MD_SET_DATA_RECORD( &mdr, 
                            dwMDIdentifier, 
                            METADATA_INHERIT, 
                            IIS_MD_UT_WAM,
                            STRING_METADATA,  
                            cbData, 
                            (LPBYTE)pwcMetaData
                           );
        
        hr = m_pMetabase->GetData( hKey, NULL, &mdr, &cbData );
        
        if( HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER )
        {
            pwcMetaData = new WCHAR[ cbData / sizeof(WCHAR) ];
            if( pwcMetaData != NULL )
            {
                mdr.pbMDData = (LPBYTE)pwcMetaData;
                mdr.dwMDDataLen = cbData;
                
                hr = m_pMetabase->GetData( hKey, NULL, &mdr, &cbData );
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        
        m_pMetabase->CloseKey( hKey ); 
    }
    
    //
    // Return AppName
    //
    if( SUCCEEDED(hr) )
    {
        DBG_ASSERT( pwcMetaData != NULL );
        *ppszBuffer = pwcMetaData;
    }
    else
    {
        DBG_ASSERT( *ppszBuffer == NULL );
        delete [] pwcMetaData;
    }
    
    return hr;
}

#ifdef _IIS_6_0

HRESULT
WamRegMetabaseConfig::MDGetAllSiteRoots
(
OUT LPWSTR * ppszBuffer
)
{
    DBG_ASSERT( m_pMetabase );
    DBG_ASSERT(ppszBuffer);
    *ppszBuffer = NULL;

    HRESULT         hr = S_OK;
    METADATA_HANDLE hKey = NULL;
    DWORD           dwEnumKeyIndex = 0;
    WCHAR           szMDName[METADATA_MAX_NAME_LEN] = {0};
    MULTISZ         mszSiteRoots;

    // Loop through all keys below /LM/W3SVC

    hr = m_pMetabase->EnumKeys(METADATA_MASTER_ROOT_HANDLE,
                               L"/LM/W3SVC/",
                               szMDName,
                               dwEnumKeyIndex
                              );
    while(SUCCEEDED(hr))
    {
        int i = _wtoi(szMDName);
        // if this is a site
        if(0 != i)
        {
            // have a valid site number
            WCHAR pTempBuf[METADATA_MAX_NAME_LEN] = {0};
            wcscpy(pTempBuf, L"/LM/W3SVC/");
            wcscat(pTempBuf, szMDName);
            wcscat(pTempBuf, L"/ROOT/");

            if (FALSE == mszSiteRoots.Append(pTempBuf))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }
            

        dwEnumKeyIndex++;
        hr = m_pMetabase->EnumKeys(METADATA_MASTER_ROOT_HANDLE,
                                   L"/LM/W3SVC/",
                                   szMDName,
                                   dwEnumKeyIndex
                                  );
    }

    // data is in MULTISZ move to out buffer
    {
        UINT                    cchMulti = 0;
        DWORD                   dwBufferSize = 0;
        
        cchMulti = mszSiteRoots.QueryCCH();

        *ppszBuffer = new WCHAR[cchMulti];
        if (NULL == *ppszBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        dwBufferSize = cchMulti;
        mszSiteRoots.CopyToBuffer(*ppszBuffer, &dwBufferSize);       
    }
    
    hr = S_OK;
done:
    return hr;
}

#endif //_IIS_6_0

/*===================================================================
MDGetIdentity

Get WAMCLSID, Wam PackageID, and fAppIsolated from a metabase path.

Parameter:
szMetabasepath  : get info from this path.
szWAMCLSID:     buffer for WAMCLSID(fixed length buffer).
szPackageID:    buffer for Wam PackageID(fixed length buffer).
fAppIsolated:   if InProc(TRUE), do not retrieve szPackageID.

Return:		HRESULT
===================================================================*/
HRESULT WamRegMetabaseConfig::MDGetIDs
(
IN LPCWSTR  szMetabasePath,
OUT LPWSTR  szWAMCLSID,
OUT LPWSTR  szPackageID,
IN DWORD    dwAppMode
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(m_pMetabase);
	DBG_ASSERT(szWAMCLSID);
	DBG_ASSERT(szPackageID);
	DBG_ASSERT(szMetabasePath);

	szPackageID[0] = NULL;
	szWAMCLSID[0] = NULL;
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, MD_APP_WAM_CLSID, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  uSizeCLSID*sizeof(WCHAR), (unsigned char *)szWAMCLSID);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBG_ASSERT(FALSE);
			}
			
		if (SUCCEEDED(hr))
			{
			if (dwAppMode == static_cast<DWORD>(eAppRunOutProcIsolated))
				{
				MD_SET_DATA_RECORD(	&recMetaData, MD_APP_PACKAGE_ID, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
									STRING_METADATA,  uSizeCLSID*sizeof(WCHAR), (unsigned char *)szPackageID);

				hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
				if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
					{
					DBG_ASSERT(FALSE);
					}
				}
			else if (dwAppMode == static_cast<DWORD>(eAppRunInProc))
				{
				wcsncpy(szPackageID, g_WamRegGlobal.g_szIISInProcPackageID, uSizeCLSID);
				}
		    else
		        {
                wcsncpy(szPackageID, g_WamRegGlobal.g_szIISOOPPoolPackageID, uSizeCLSID);				
		        }
			}
		m_pMetabase->CloseKey(hMetabase);
		}

	return hr;
}

/*===================================================================
MDRemoveProperty

Remove one MD property.

Parameter:

pwszMetabasePath    
dwIdentifier        the MD indentifier to be removed.
dwType              the MD indietifier data type.

Return:		HRESULT
===================================================================*/
HRESULT WamRegMetabaseConfig::MDRemoveProperty
(
IN LPCWSTR pwszMetabasePath,
DWORD dwIdentifier,
DWORD dwType
)
{
	METADATA_RECORD 	recMetaData;
	HRESULT				hr;
	METADATA_HANDLE		hMetabase;
	
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)pwszMetabasePath,
					METADATA_PERMISSION_WRITE, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		hr = m_pMetabase->DeleteData(hMetabase, NULL, dwIdentifier, dwType);
			
		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

/*===================================================================
MDGetLastOutProcPackageID

Get LastOutProcPackageID  from Metabase Key(szMetabasePath)

Parameter:
szMetabasePath	:	[in]		metabase key	
szLastOutProcPackageID	:		[in]		a pointer to LastOutProcPackageID buffer
Return:		HRESULT

Note: fill in the LastOutProcPackageID, memory buffer provided by the caller.
===================================================================*/
HRESULT WamRegMetabaseConfig::MDGetLastOutProcPackageID
(
IN LPCWSTR szMetabasePath,
IN OUT LPWSTR szLastOutProcPackageID
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(szLastOutProcPackageID);
	DBG_ASSERT(szMetabasePath);

	szLastOutProcPackageID[0] = NULL;
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, MD_APP_LAST_OUTPROC_PID, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  uSizeCLSID*sizeof(WCHAR), (unsigned char *)szLastOutProcPackageID);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBG_ASSERT(FALSE);
			}
			
		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

/*===================================================================
GetWebServerName

Look the WebServerName(ServerComment) property under the key (szMetabasePath).

Parameter:
None

Return:		HRESULT

Note: fill in the szWebServerName, memory buffer provided by the caller.
===================================================================*/
HRESULT WamRegMetabaseConfig::GetWebServerName
(
IN LPCWSTR wszMetabasePath, 
IN OUT LPWSTR wszWebServerName, 
IN UINT cBuffer
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(wszMetabasePath);
	DBG_ASSERT(wszWebServerName);

	// Open Key
	hr = m_pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE, 
                               wszMetabasePath,
					           METADATA_PERMISSION_READ, 
                               m_dwMDDefaultTimeOut, 
                               &hMetabase
                               );
	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, 
                            MD_SERVER_COMMENT, 
                            METADATA_INHERIT, 
                            IIS_MD_UT_SERVER,
							STRING_METADATA,  
                            cBuffer, 
                            (unsigned char *)wszWebServerName
                            );
						
		hr = m_pMetabase->GetData(hMetabase, L"", &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBGPRINTF((DBG_CONTEXT, "Insuffcient buffer for WebServerName. Path = %S\n",
				wszMetabasePath));
			DBG_ASSERT(FALSE);
			}

        //
        // If property MD_SERVER_COMMENT not found, null out the WebServerName.
        //
	    if (hr == MD_ERROR_DATA_NOT_FOUND)
	        {
            wszWebServerName[0] = L'\0';
            hr = NOERROR;
	        }
	        
		if (FAILED(hr))
			{
			DBGPRINTF((DBG_CONTEXT, "Failed to read Metabase for WebServerName. Path = %S, error = %08x\n",
				wszMetabasePath,
				hr));
			}
		
		m_pMetabase->CloseKey(hMetabase);
		}
	else
		{
		DBGPRINTF((DBG_CONTEXT, "Failed to read Metabase for WebServerName. Path = %S, error = %08x\n",
				wszMetabasePath,
				hr));
		}

	return hr;
}

/*===================================================================
GetSignatureOnPath

Get an application signature(AppRoot & AppIsolated) on a metabase path.

Parameter:
pwszMetabasePath
pdwSignature

Return:		HRESULT

Note: Signature is returned via pdwSignature.
===================================================================*/
HRESULT WamRegMetabaseConfig::GetSignatureOnPath
(
IN LPCWSTR pwszMetabasePath,
OUT DWORD* pdwSignature
)
{
	HRESULT hr = NOERROR;
	WCHAR szWAMCLSID[uSizeCLSID];
	WCHAR szPackageID[uSizeCLSID];
	DWORD dwResult = 0;
	DWORD cSize = 0;
	DWORD dwAppMode = 0;

	DBG_ASSERT(pwszMetabasePath);
	
	hr = MDGetDWORD(pwszMetabasePath, MD_APP_ISOLATED, &dwAppMode);
	if (SUCCEEDED(hr))
		{
		hr = MDGetIDs(pwszMetabasePath, szWAMCLSID, szPackageID, (BOOL)dwAppMode);

		if (SUCCEEDED(hr))
			{
			cSize = wcslen(pwszMetabasePath);
			dwResult = WamRegChkSum(pwszMetabasePath, cSize);

			dwResult ^= WamRegChkSum(szWAMCLSID, uSizeCLSID);
			if (dwAppMode == eAppRunOutProcIsolated)
				{
				dwResult ^= WamRegChkSum(szPackageID, uSizeCLSID);
				}
			}
		}

	if (SUCCEEDED(hr))
		{
		*pdwSignature = dwResult;
		}
	else
		{
		*pdwSignature = 0;
		}

	return NOERROR;
}

/*===================================================================
WamRegChkSum

Give a wchar string, calculate a chk sum.

Parameter:
pszKey		wchar string
cchKey		wcslen(of wchar ) string

Return:		ChkSum.

===================================================================*/
DWORD WamRegMetabaseConfig::WamRegChkSum
(
IN LPCWSTR pszKey, 
IN DWORD cchKey
)
{
    DWORD   hash = 0, g;

    while (*pszKey)
        {
        hash = (hash << 4) + *pszKey++;
        if (g = hash & 0xf0000000)
            {
            hash ^= g >> 24;
            }
        hash &= ~g;
        }
    return hash;
}


/*===================================================================
MDGetPropPaths	

Get an array of metabase paths that contains a specific property.

Parameter:
szMetabasePath
dwMDIdentifier
pBuffer			a pointer to a buffer
pdwBufferSize	contains actual buffer size allocated for pBuffer

Return:		
HRESULT
		
Side Affect:
	Allocate memory for return result use new.  Caller needs to free pBuffer
use delete[].
===================================================================*/
HRESULT	WamRegMetabaseConfig::MDGetPropPaths
(
IN LPCWSTR 	szMetabasePath,
IN DWORD	dwMDIdentifier,
OUT WCHAR**	pBuffer,
OUT DWORD*	pdwBufferSize
)
{
    HRESULT hr = NOERROR;
    METADATA_HANDLE	hMetabase = NULL;   // Metabase Handle
    WCHAR	wchTemp;	                // One char buffer, no real usage.
    WCHAR	*pTemp = &wchTemp;		// Start with some buffer, otherwise, 
    // will get RPC_X_NULL_REF_POINTER
    DWORD	dwMDBufferSize = 0;
    DWORD	dwMDRequiredBufferSize = 0;
    
    if (NULL != szMetabasePath)
    {
        // Open Key
        hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
            METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
    }
    else
    {
        hMetabase = METADATA_MASTER_ROOT_HANDLE;
    }
    
    if (SUCCEEDED(hr))
    {
        hr = m_pMetabase->GetDataPaths(hMetabase,
                                       NULL,
                                       dwMDIdentifier,
                                       ALL_METADATA,
                                       dwMDBufferSize,
                                       pTemp,
                                       &dwMDRequiredBufferSize);
        if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
        {
            if (dwMDRequiredBufferSize > 0)
            {
                pTemp = new WCHAR[dwMDRequiredBufferSize];
                if (pTemp == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    DBGPRINTF((DBG_CONTEXT, "Out of memory. \n"));
                }
                else
                {
                    dwMDBufferSize = dwMDRequiredBufferSize;
                    hr = m_pMetabase->GetDataPaths(hMetabase,
                                                   NULL,
                                                   dwMDIdentifier,
                                                   ALL_METADATA,
                                                   dwMDBufferSize,
                                                   (LPWSTR)pTemp,
                                                   &dwMDRequiredBufferSize);
                    if (FAILED(hr))
                    {
                        DBGPRINTF((DBG_CONTEXT, "GetDataPaths failed with identitifier %d, path %S, hr = %08x\n",
                            dwMDIdentifier,
                            szMetabasePath,
                            hr));
                    }
                    else
                    {
                        *pBuffer = pTemp;
                        *pdwBufferSize = dwMDBufferSize;
                    }
                }
            }
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "GetDataPaths failed with identitifier %d, path %S, hr = %08x\n",
                dwMDIdentifier,
                szMetabasePath,
                hr));
        }
        if (hMetabase)
        {
            m_pMetabase->CloseKey(hMetabase);
        }
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT, "Failed to open metabase path %S, hr = %08x\n",
            szMetabasePath,
            hr));
    }
    
    return hr;
}

/*===================================================================
HasAdminAccess	

Determine if the user has appropriate access to the metabase. We'll
use the same, somewhat hacky, method of determining this that the UI
uses. Basically we set a dummy property in the MB that only an admin
has access to. MB will use the call context to validate this.

Parameter:

Return:		
BOOL    - True if user has admin access to the MB
		
Side Affect:
===================================================================*/
BOOL WamRegMetabaseConfig::HasAdminAccess
(
VOID
)
{
    HRESULT         hr = NOERROR;
    METADATA_HANDLE	hMetabase = NULL;
    
    DBG_ASSERT(m_pMetabase);

    hr = m_pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE, 
                               WamRegGlobal::g_szMDW3SVCRoot, 
                               METADATA_PERMISSION_WRITE, 
                               m_dwMDDefaultTimeOut, 
                               &hMetabase );
    if( SUCCEEDED(hr) )
    {
        DWORD           dwDummyValue = 0x1234;
        METADATA_RECORD mdr;

        MD_SET_DATA_RECORD(	&mdr, 
                            MD_ISM_ACCESS_CHECK, 
                            METADATA_NO_ATTRIBUTES, 
                            IIS_MD_UT_FILE,
                            DWORD_METADATA,  
                            sizeof(DWORD), 
                            &dwDummyValue );

        hr = m_pMetabase->SetData( hMetabase, L"", &mdr );

        DBG_REQUIRE( SUCCEEDED(m_pMetabase->CloseKey( hMetabase )) );
    }

    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\export.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG    Wam Registration

File: export.cpp

Owner: LeiJin

Note:

WAMREG Export functions.
===================================================================*/

#define _WAMREG_DLL_
#include "common.h"
#include <stdio.h>

#include "objbase.h"
#include "dbgutil.h"
#include "wmrgexp.h"
#include "auxfunc.h"
#include "iiscnfg.h"
#include "export.h"

PFNServiceNotify g_pfnW3ServiceSink;

//
// Setup support
//
IIS5LOG_FUNCTION            g_pfnSetupWriteLog = NULL;

VOID
LogSetupTraceImpl
(
    LPCSTR      szPrefixFormat,
    LPCSTR      szFilePath,
    INT         nLineNum,
    INT         nTraceLevel,
    LPCSTR      szFormat,
    va_list     argptr
);

class CWamSetupManager
/*++

Class description:

    Collects those helper functions used exclusively by setup.
    Most of these methods were formerly in WamRegGlobal.

Public Interface:

--*/
{
public:

    CWamSetupManager()
        : m_hrCoInit( NOERROR )
    {
    }

    ~CWamSetupManager()
    {
    }

    HRESULT SetupInit( WamRegPackageConfig &refPackageConfig );

    VOID    SetupUnInit( WamRegPackageConfig &refPackageConfig )
    {
        refPackageConfig.Cleanup();
        WamRegMetabaseConfig::MetabaseUnInit();
        
        if( SUCCEEDED(m_hrCoInit) )
        {
            CoUninitialize();
        }
    }

    HRESULT UpgradeInProcApplications( VOID );

    HRESULT AppCleanupAll( VOID );

private:
    
    HRESULT DoGoryCoInitialize( VOID );

    HRESULT RemoveWAMCLSIDFromInProcApp( IN LPCWSTR pszMetabasePath );

private:

    HRESULT     m_hrCoInit;
};

#define MAX_SETUP_TRACE_OUTPUTSTR       1024


// This define sets up the internal trace logging.
// it needs to be turned off to use the iis5.log.
// #define WAMREG_DEBUG_SETUP_LOG

#ifdef WAMREG_DEBUG_SETUP_LOG

    HANDLE g_hFile = NULL;
    void DebugLogWrite(int iLogType, WCHAR *pszfmt)
    {
        DWORD   dwBytesWritten;
        CHAR    szOutput[MAX_SETUP_TRACE_OUTPUTSTR + 1];

        *szOutput = 0;

        WideCharToMultiByte(  CP_ACP,
                              0,
                              pszfmt,
                              -1,
                              szOutput,
                              MAX_SETUP_TRACE_OUTPUTSTR,
                              NULL,
                              NULL
                              );

        WriteFile(  g_hFile,
                    szOutput,
                    strlen( szOutput ),
                    &dwBytesWritten,
                    NULL
                    );
    }

    VOID SetLogFile(VOID)
    {
        // Create a file and a procedure to call to log to it.

        CHAR    szLogFilePath[MAX_PATH + 1];
        CHAR    szLogFileFullName[MAX_PATH + 1];
        CHAR    szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD   cbMachineName = MAX_COMPUTERNAME_LENGTH + 1;

        static CHAR szLogFileBaseName[] = "wamreg";
        static CHAR szLogFileSuffix[] = ".log";

        // Get dll path
        GetModuleFileNameA( g_hModule, szLogFilePath, sizeof( szLogFilePath ) );
        CHAR *psz = strrchr( szLogFilePath, '\\' );
        *(psz + 1)= 0;

        // Build file name
        GetComputerNameA(  szMachineName, &cbMachineName );

        strcpy( szLogFileFullName, szLogFileBaseName );
        strcat( szLogFileFullName, "_" );
        strcat( szLogFileFullName, szMachineName );
        strcat( szLogFileFullName, szLogFileSuffix );

        strcat( szLogFilePath, szLogFileFullName );

        g_hFile = CreateFile( szLogFilePath, 
                              GENERIC_WRITE, 
                              FILE_SHARE_READ,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL 
                              );

        if( g_hFile )
        {
            g_pfnSetupWriteLog = DebugLogWrite;
        }
    }

    VOID ClearLogFile(VOID)
    {
        if( g_hFile )
        {
            FlushFileBuffers( g_hFile );
            CloseHandle( g_hFile );
            g_hFile = NULL;
        }
    }

#endif // WAMREG_DEBUG_SETUP_LOG


HRESULT PACKMGR_LIBAPI
InstallWam
( 
    HMODULE hIIsSetupModule 
)
/*++
Routine Description:

    Setup entry point. The handle to iis.dll is passed in to allow us
    to log to the setup log.

Parameters

    hIIsSetupModule             -

Return Value

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;

    // Get the logging entry point from iis.dll
    
#ifdef WAMREG_DEBUG_SETUP_LOG
    SetLogFile();
#else
    g_pfnSetupWriteLog = (IIS5LOG_FUNCTION) GetProcAddress( hIIsSetupModule, "IIS5Log");
#endif
    
    hr = CreateIISPackage();

#ifdef WAMREG_DEBUG_SETUP_LOG
    ClearLogFile();
#endif

    g_pfnSetupWriteLog = NULL;

    return hr;
}

HRESULT PACKMGR_LIBAPI
UnInstallWam
( 
    HMODULE hIIsSetupModule 
)
/*++
Routine Description:

    Setup entry point. The handle to iis.dll is passed in to allow us
    to log to the setup log.

Parameters

    hIIsSetupModule             -

Return Value

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;

    // Get the logging entry point from iis.dll
    
#ifdef WAMREG_DEBUG_SETUP_LOG
    SetLogFile();
#else
    g_pfnSetupWriteLog = (IIS5LOG_FUNCTION) GetProcAddress( hIIsSetupModule, "IIS5Log");
#endif
    
    hr = DeleteIISPackage();

#ifdef WAMREG_DEBUG_SETUP_LOG
    ClearLogFile();
#endif

    g_pfnSetupWriteLog = NULL;

    return hr;
}

VOID
LogSetupTrace
(
   IN LPDEBUG_PRINTS       pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...
)
/*++
Routine Description:

    Called by SETUP_TRACE* logging macros. Passes va_list to LogSetupTraceImpl.

Parameters

   IN LPDEBUG_PRINTS       pDebugPrints     - from DBG_CONTEXT unused
   IN const char *         pszFilePath      - from DBG_CONTEXT unused
   IN int                  nLineNum         - from DBG_CONTEXT unused
   IN const char *         pszFormat        - format string

--*/
{
    DBG_ASSERT( pszFormat );

    va_list argsList; 

    va_start( argsList, pszFormat);

    LogSetupTraceImpl( 
        "[WAMTRACE - %14s : %05d]\t", 
        pszFilePath, 
        nLineNum, 
        LOG_TYPE_TRACE, 
        pszFormat, 
        argsList 
        );

    va_end( argsList);
}

VOID
LogSetupTraceError
(
   IN LPDEBUG_PRINTS       pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...
)
/*++
Routine Description:

   Called by SETUP_TRACE* logging macros. Passes va_list to LogSetupTraceImpl.

Parameters

   IN LPDEBUG_PRINTS       pDebugPrints     - from DBG_CONTEXT unused
   IN const char *         pszFilePath      - from DBG_CONTEXT unused
   IN int                  nLineNum         - from DBG_CONTEXT unused
   IN const char *         pszFormat        - format string

--*/
{
    DBG_ASSERT( pszFormat );

    va_list argsList; 

    va_start( argsList, pszFormat);

    LogSetupTraceImpl( 
        "[WAMERROR - %14s : %05d]\t", 
        pszFilePath, 
        nLineNum, 
        LOG_TYPE_ERROR, 
        pszFormat, 
        argsList 
        );

    va_end( argsList);
}

VOID
LogSetupTraceImpl
(
    LPCSTR      szPrefixFormat,
    LPCSTR      szFilePath,
    INT         nLineNum,
    INT         nTraceLevel,
    LPCSTR      szFormat,
    va_list     argptr
)
/*++
Routine Description:

    All the logging macros resolve to this function. Formats the
    message to be logged and logs it using g_pfnSetupWriteLog.

Parameters

    LPCSTR      szPrefixFormat  - 
    LPCSTR      szFilePath      - 
    INT         nLineNum        - 
    INT         nTraceLevel     - LOG_TYPE_ERROR, LOG_TYPE_TRACE
    LPCSTR      szFormat        - format string
    va_list     argptr          - arguments to format

--*/
{
    WCHAR   wszOutput[MAX_SETUP_TRACE_OUTPUTSTR + 1];
    CHAR    szOutput[MAX_SETUP_TRACE_OUTPUTSTR + 1];

    LPCSTR  szFileName = strrchr( szFilePath, '\\');
    szFileName++;
   
    int cchPrefix = wsprintf( szOutput, szPrefixFormat, szFileName, nLineNum );

    int cchOutputString = _vsnprintf( szOutput + cchPrefix, 
                                      MAX_SETUP_TRACE_OUTPUTSTR - cchPrefix,
                                      szFormat, 
                                      argptr 
                                      );

    if( -1 == cchOutputString ) 
    {
        // Terminate properly if too much data
        szOutput[MAX_SETUP_TRACE_OUTPUTSTR] = '\0';
    }

    if( MultiByteToWideChar( CP_ACP, 
                             0, 
                             szOutput, 
                             -1, 
                             wszOutput, 
                             MAX_SETUP_TRACE_OUTPUTSTR + 1 )
        )
    {
        if( g_pfnSetupWriteLog )
        {
            g_pfnSetupWriteLog( nTraceLevel, wszOutput );
        }
    }
}

#ifdef _IIS_6_0

HRESULT	
PACKMGR_LIBAPI	
CreateCOMPlusApplication( 
    LPCWSTR      szMDPath,
    LPCWSTR      szOOPPackageID,
    LPCWSTR      szOOPWAMCLSID,
    BOOL       * pfAppCreated 
    )
{
    HRESULT                 hr = S_OK;
    WamRegPackageConfig     PackageConfig;
    DWORD                   dwMDPathLen;                    

    *pfAppCreated = FALSE;

    //
    // Initilize COM+ catalog
    //

    hr = PackageConfig.CreateCatalog();
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( !PackageConfig.IsPackageInstalled( szOOPPackageID,
                                           szOOPWAMCLSID ) )
    {
        hr = g_WamRegGlobal.CreateOutProcApp( szMDPath, FALSE, FALSE );            
        if (FAILED(hr))
        {
            DBGPRINTF(( DBG_CONTEXT, 
                        "Failed to create new application on path %S, hr = 08x\n",
                        szMDPath,
                        hr ));
        }

        *pfAppCreated = TRUE;
    }

    return hr;
}

#endif // _IIS_6_0

/*===================================================================
CreateIISPackage

Called at IIS Setup time. 

This is a pseudo dll entry point. It shouldn't be called by setup directly. 
Setup calls InstallWam(). This entry still exists so there is a function 
that can be called by rundll32 that takes no parameters and provides 
equivalent functionality to setup.

rundll32 wamreg.dll,CreateIISPackage

This routine's logic has changed to do two ways. One, it won't
cleanup when it fails. The cleanup logic made it much more difficult
to determine what worked and what didn't. Two, it doesn't skip steps
when a failure happens. Some multistep actions may be cut short if 
there is a failure, but we won't bail and skip an unrelated action 
anymore.

Returns:
    HRESULT    - NOERROR on success

Side effects:

===================================================================*/
HRESULT PACKMGR_LIBAPI CreateIISPackage(void)
{
    CWamSetupManager        setupMgr;
    WamRegPackageConfig     PackageConfig;
    WamRegMetabaseConfig    MDConfig;

    HRESULT     hrReturn = NOERROR;
    HRESULT     hrCurrent = NOERROR;

    SETUP_TRACE(( DBG_CONTEXT, "CALL - CreateIISPackage\n" ));

    hrReturn = setupMgr.SetupInit( PackageConfig );
    if( SUCCEEDED(hrReturn) )
    {
        //
        // Determine what packages are currently installed. This will
        // drive the logic of the rest of the install.
        //
        SETUP_TRACE(( 
            DBG_CONTEXT, 
            "CreateIISPackage - Finding installed WAM packages.\n"
            ));

        BOOL fIPPackageInstalled = 
            PackageConfig.IsPackageInstalled(
                WamRegGlobal::g_szIISInProcPackageID,
                WamRegGlobal::g_szInProcWAMCLSID
                );

        BOOL fPOOPPackageInstalled = 
            PackageConfig.IsPackageInstalled(
                WamRegGlobal::g_szIISOOPPoolPackageID,
                WamRegGlobal::g_szOOPPoolWAMCLSID
                );

        SETUP_TRACE(( 
            DBG_CONTEXT, 
            "CreateIISPackage - IP Package exists (%x) POOL Package exists (%x).\n",
            fIPPackageInstalled,
            fPOOPPackageInstalled
            ));

        // Always re-register the clsids. This ensures that upgrades
        // from Win9x have the correct entries. And allows recovery
        // from lost registry entries.

        // We probably should bail if the clsid registration fails, but
        // for now we'll just continue.

        SETUP_TRACE(( 
            DBG_CONTEXT, 
            "CreateIISPackage - Registering WAM CLSIDs.\n"
            ));

        hrCurrent = g_RegistryConfig.RegisterCLSID(
                        WamRegGlobal::g_szInProcWAMCLSID, 
                        WamRegGlobal::g_szInProcWAMProgID, 
                        TRUE
                        );

        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR(( DBG_CONTEXT, 
                                "FAIL - RegisterCLSID IP(%S) - error=%08x\n",
                                WamRegGlobal::g_szInProcWAMCLSID,
                                hrReturn
                                ));
        }

        hrCurrent = g_RegistryConfig.RegisterCLSID(
                        WamRegGlobal::g_szOOPPoolWAMCLSID,
                        WamRegGlobal::g_szOOPPoolWAMProgID, 
                        TRUE
                        );

        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR(( DBG_CONTEXT, 
                                "FAIL - RegisterCLSID POOL(%S) - error=%08x\n",
                                WamRegGlobal::g_szOOPPoolWAMCLSID,
                                hrReturn
                                ));
        }


        //  If the IIS InProc Package is installed and IIS OOP pool package is not
        //  installed, then, we have a IIS version 4 installation.  We need to 
        //  Upgrade all inproc applications.
        if( fIPPackageInstalled && !fPOOPPackageInstalled )
        {
            // Update inproc applications by removing WAMCLSID from inproc 
            // applications.  This step does not change inproc application to a 
            // oop pool application.

            SETUP_TRACE(( 
                DBG_CONTEXT, 
                "CreateIISPackage - Upgrading existing IP applications.\n"
                ));

            hrCurrent = setupMgr.UpgradeInProcApplications();
            if( FAILED(hrCurrent) )
            {
                hrReturn = hrCurrent;
                SETUP_TRACE_ERROR(( 
                    DBG_CONTEXT, 
                    "FAIL - UpgradeInProcApplications - error=%08x\n",
                    hrReturn
                    ));
            }
        }

        if( !fIPPackageInstalled )
        {
            //
            // Create the IP package
            //
            SETUP_TRACE(( 
                DBG_CONTEXT, 
                "CreateIISPackage - Creating the WAM IP application.\n"
                ));

            hrCurrent = PackageConfig.CreatePackage(
                            WamRegGlobal::g_szIISInProcPackageID,
                            WamRegGlobal::g_szIISInProcPackageName,
                            NULL,
                            NULL,
                            TRUE
                            );
            if( FAILED(hrCurrent) )
            {
                hrReturn = hrCurrent;
                SETUP_TRACE_ERROR(( 
                    DBG_CONTEXT, 
                    "FAIL - CreatePackage IP(%S) - error=%08x\n",
                    WamRegGlobal::g_szIISInProcPackageID,
                    hrReturn
                    ));
            }
            else
            {
                // Successfully created the package. Add the component.
                hrCurrent = PackageConfig.AddComponentToPackage(
                                WamRegGlobal::g_szIISInProcPackageID,
                                WamRegGlobal::g_szInProcWAMCLSID
                                );
                if( FAILED(hrCurrent) )
                {
                    hrReturn = hrCurrent;
                    SETUP_TRACE_ERROR(( 
                        DBG_CONTEXT, 
                        "FAIL - AddComponentToPackage IP(%S) - error=%08x\n",
                        WamRegGlobal::g_szInProcWAMCLSID,
                        hrReturn
                        ));
                }
            }
        } // create IP package

        if( !fPOOPPackageInstalled )
        {
            //
            // Create the POOP package.
            //
            SETUP_TRACE(( 
                DBG_CONTEXT, 
                "CreateIISPackage - Creating the WAM POOL application.\n"
                ));
            
            // Get IWAM_* account information.
            WCHAR   szIdentity[MAX_PATH];
            WCHAR   szPwd[MAX_PATH];

            *szIdentity = *szPwd = 0;

            hrCurrent = MDConfig.MDGetIdentity( szIdentity, 
                                                sizeof(szIdentity), 
                                                szPwd, 
                                                sizeof(szPwd)
                                                );
            if( FAILED(hrCurrent) )
            {
                hrReturn = hrCurrent;
                SETUP_TRACE_ERROR(( 
                    DBG_CONTEXT, 
                    "FAIL - MDGetIdentity, Getting the IWAM_* account from the Metabase - error=%08x\n",
                    hrReturn
                    ));
            }
            else
            {
                // succeeded
                hrCurrent = PackageConfig.CreatePackage(
                                WamRegGlobal::g_szIISOOPPoolPackageID, 
                                WamRegGlobal::g_szIISOOPPoolPackageName,
                                szIdentity,
                                szPwd,
                                FALSE
                                );
                if( FAILED(hrCurrent) )
                {
                    hrReturn = hrCurrent;
                    SETUP_TRACE_ERROR(( 
                        DBG_CONTEXT, 
                        "FAIL - CreatePackage POOL(%S) - error=%08x\n",
                        WamRegGlobal::g_szIISOOPPoolPackageID,
                        hrReturn
                        ));
                }
                else
                {
                    hrCurrent = PackageConfig.AddComponentToPackage(
                                    WamRegGlobal::g_szIISOOPPoolPackageID,
                                    WamRegGlobal::g_szOOPPoolWAMCLSID
                                    );            
                    if( FAILED(hrCurrent) )
                    {
                        hrReturn = hrCurrent;
                        SETUP_TRACE_ERROR(( 
                            DBG_CONTEXT, 
                            "FAIL - AddComponentToPackage POOL(%S) - error=%08x\n",
                            WamRegGlobal::g_szOOPPoolWAMCLSID,
                            hrReturn
                            ));
                    }
                }
            }
        } // create POOL package

        // Update the default application /LM/W3SVC
        
        // Do this all the time. There are some conditions under which
        // an uninstall might fail and leave some com+ junk around. We
        // don't want to key the setting of the metabase defaults to
        // the state of com+ or things like DAV won't work.

        SETUP_TRACE(( 
            DBG_CONTEXT, 
            "CreateIISPackage - Updating metabase defaults.\n"
            ));
        
        hrCurrent = MDConfig.MDUpdateIISDefault( 
                        WamRegGlobal::g_szIISInProcPackageName,
                        WamRegGlobal::g_szIISInProcPackageID,
                        WamRegGlobal::g_szInProcWAMCLSID
                        );

        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR(( 
                DBG_CONTEXT, 
                "FAIL - MDUpdateIISDefault, Updating default application - error=%08x\n",
                hrReturn
                ));
        }

    } // init succeeded

    setupMgr.SetupUnInit( PackageConfig );

    SETUP_TRACE_ASSERT( SUCCEEDED(hrReturn) );
    SETUP_TRACE(( DBG_CONTEXT, "RETURN - CreateIISPackage, hr=%08x\n", hrReturn ));

    return hrReturn;
}

/*===================================================================
DeleteIISPackage

Delete IIS Package from ViperSpace, and unregister the default IIS
CLSID.


Returns:
    HRESULT    - NOERROR on success

Side effects:
    remove IIS default package from Viperspace.

Note:
  No need to delete the metabase entries.
  This function is called when IIS is uninstalled.
   In this case anyway Metabase will go away - so we don't clean it explicitly

===================================================================*/
HRESULT PACKMGR_LIBAPI DeleteIISPackage(void)
{
    HRESULT                 hrReturn = NOERROR;
    HRESULT                 hrCurrent = NOERROR;
    CWamSetupManager        setupMgr;
    WamRegPackageConfig     PackageConfig;
    
    SETUP_TRACE(( DBG_CONTEXT, "CALL - DeleteIISPackage\n" ));

    hrReturn = setupMgr.SetupInit( PackageConfig );
    if( SUCCEEDED(hrReturn) ) 
    {
        // Blow away all the applications.

        SETUP_TRACE(( 
            DBG_CONTEXT, 
            "DeleteIISPackage - Removing WAM Applications\n"
            ));

        hrCurrent = setupMgr.AppCleanupAll();
        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR(( 
                    DBG_CONTEXT,
                    "Failed to remove WAM Applications. Error %08x\n",
                    hrReturn
                    ));
        }

        // Remove the global packages

        SETUP_TRACE(( 
            DBG_CONTEXT, 
            "DeleteIISPackage - Removing WAM packages\n"
            ));

        hrCurrent = PackageConfig.RemovePackage( 
                        WamRegGlobal::g_szIISInProcPackageID
                        );
        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR(( 
                        DBG_CONTEXT,
                        "Failed to remove IP package (%S). Error %08x\n",
                        WamRegGlobal::g_szIISInProcPackageID,
                        hrReturn
                        ));
        }

        hrCurrent = PackageConfig.RemovePackage( 
                        WamRegGlobal::g_szIISOOPPoolPackageID
                        );
        if( FAILED(hrCurrent) ) 
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR(( 
                        DBG_CONTEXT,
                        "Failed to remove POOL package (%S). Error %08x\n",
                        WamRegGlobal::g_szIISOOPPoolPackageID,
                        hrReturn
                        ));
        }

        // Unregister the global WAM CLSIDs

        SETUP_TRACE(( 
            DBG_CONTEXT, 
            "DeleteIISPackage - Removing WAM CLSIDs from the registry\n"
            ));

        hrCurrent = g_RegistryConfig.UnRegisterCLSID(
                            WamRegGlobal::g_szInProcWAMCLSID, 
                            TRUE
                            );
        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR(( 
                        DBG_CONTEXT,
                        "Failed to remove registry entries (%S). Error %08x\n",
                        WamRegGlobal::g_szInProcWAMCLSID,
                        hrReturn
                        ));
        }

        hrCurrent = g_RegistryConfig.UnRegisterCLSID(
                        WamRegGlobal::g_szOOPPoolWAMCLSID, 
                        FALSE       // Already deleted VI Prog ID
                        );
        if( FAILED(hrCurrent) ) 
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR(( 
                        DBG_CONTEXT,
                        "Failed to remove registry entries (%S). Error %08x\n",
                        WamRegGlobal::g_szOOPPoolWAMCLSID,
                        hrReturn
                        ));
        }
    }

    setupMgr.SetupUnInit( PackageConfig );

    SETUP_TRACE(( DBG_CONTEXT, "RETURN - DeleteIISPackage, hr=%08x\n", hrReturn ));
    return hrReturn;
}

/*===================================================================
WamReg_RegisterSinkNotify

Register a function pointer(a back pointer) to Runtime WAM_Dictator.  So that
any changes in WAMREG will ssync with RunTime WAM_Dictator state.

Returns:
    HRESULT    - NOERROR on success

Side effects:
    register a function pointer.
===================================================================*/
HRESULT PACKMGR_LIBAPI WamReg_RegisterSinkNotify
(
PFNServiceNotify pfnW3ServiceSink
)
{
    g_pfnW3ServiceSink = pfnW3ServiceSink;
    return NOERROR;
}

/*===================================================================
WamReg_RegisterSinkNotify

Register a function pointer(a back pointer) to Runtime WAM_Dictator.  So that
any changes in WAMREG will ssync with RunTime WAM_Dictator state.

Returns:
    HRESULT    - NOERROR on success

Side effects:
    register a function pointer.
===================================================================*/
HRESULT PACKMGR_LIBAPI WamReg_UnRegisterSinkNotify
(
void
)
{
    g_pfnW3ServiceSink = NULL;
    return NOERROR;
}


HRESULT CWamSetupManager::SetupInit( WamRegPackageConfig &refPackageConfig )
{
    HRESULT hrReturn = NOERROR;
    HRESULT hrCurrent = NOERROR;
    
    SETUP_TRACE(( DBG_CONTEXT, "CALL - SetupInit\n" ));

    hrCurrent = g_RegistryConfig.LoadWamDllPath();
    if( FAILED(hrCurrent) )
    {
        hrReturn = hrCurrent;
        SETUP_TRACE_ERROR(( DBG_CONTEXT, 
                            "FAIL - LoadWamDllPath - error=%08x",
                            hrReturn
                            ));
    }

    hrCurrent = DoGoryCoInitialize();
    if( FAILED(hrCurrent) )
    {
        hrReturn = hrCurrent;
        SETUP_TRACE_ERROR(( DBG_CONTEXT, 
                            "FAIL - DoGoryCoInitialize - error=%08x",
                            hrReturn
                            ));
    }

    hrCurrent = refPackageConfig.CreateCatalog();
    if( FAILED(hrCurrent) )
    {
        hrReturn = hrCurrent;
        SETUP_TRACE_ERROR(( DBG_CONTEXT, 
                            "FAIL - CreateCatalog - error=%08x",
                            hrReturn
                            ));
    }

    hrCurrent = WamRegMetabaseConfig::MetabaseInit();
    if( FAILED(hrCurrent) )
    {
        hrReturn = hrCurrent;
        SETUP_TRACE_ERROR(( DBG_CONTEXT, 
                            "FAIL - MetabaseInit - error=%08x",
                            hrReturn
                            ));
    }

    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "RETURN - SetupInit. Error(%08x)\n", 
        hrReturn
        ));

    return hrReturn;
}


/*===================================================================
UpgradeInProcApplications

From iis v4 to v5, UpgradeInProcApplications removes WAMCLSID from all
inproc applications defined in IIS Version 4.  So, after the upgrade,
There is only one inproc WAMCLSID inside inproc package.

Parameter:
VOID

Return:     HRESULT
===================================================================*/
HRESULT CWamSetupManager::UpgradeInProcApplications( VOID )
{
    HRESULT hr = NOERROR;
    DWORD   dwBufferSizeTemp= 0;
    WCHAR*  pbBufferTemp = NULL;
    WamRegMetabaseConfig    MDConfig;
    
    SETUP_TRACE((DBG_CONTEXT, "CALL - UpgradeInProcApplications\n"));
    
    DWORD dwSizePrefix = g_WamRegGlobal.g_cchMDW3SVCRoot;
    
    hr = MDConfig.MDGetPropPaths( g_WamRegGlobal.g_szMDW3SVCRoot, 
                                  MD_APP_ISOLATED, 
                                  &pbBufferTemp, 
                                  &dwBufferSizeTemp
                                  );
    
    SETUP_TRACE_ASSERT(pbBufferTemp != NULL);
    
    if (SUCCEEDED(hr) && pbBufferTemp)
        {
        WCHAR*    pszString = NULL;
        WCHAR*  pszMetabasePath = NULL;
    
        for (pszString = (LPWSTR)pbBufferTemp;
                *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
                pszString += (wcslen(pszString) + 1)) 
            {
            //
            // MDGetPropPaths returns patial paths relative to /LM/W3SVC/, therefore, 
            // prepend the prefix string to the path
            //
            hr = g_WamRegGlobal.ConstructFullPath(
                        g_WamRegGlobal.g_szMDW3SVCRoot,
                        g_WamRegGlobal.g_cchMDW3SVCRoot,
                        pszString,
                        &pszMetabasePath
                        );

            if (SUCCEEDED(hr))
                {
                //
                // The default application under /LM/W3SVC is created differently with
                // normal application.  Therefore, it requires other code to remove the
                // the application.
                //
                if (!g_WamRegGlobal.FIsW3SVCRoot(pszMetabasePath))
                    {
                    hr = RemoveWAMCLSIDFromInProcApp(pszMetabasePath);
                    
                    if (FAILED(hr))
                        {
                        SETUP_TRACE_ERROR((
                            DBG_CONTEXT, 
                            "Failed to upgrade application %S, hr = %08x\n",
                            pszString,
                            hr
                            ));

                        delete [] pszMetabasePath;
                        pszMetabasePath = NULL;
                        break;
                        }
                    }
                    
                delete [] pszMetabasePath;
                pszMetabasePath = NULL;
                }
             else
                 {
                 SETUP_TRACE_ERROR((
                    DBG_CONTEXT, 
                    "ConstructFullPath failed, partial path (%S), hr = %08x\n",
                    pszString,
                    hr
                    ));
                }
            }
        }
    else
        {
        DBGPRINTF((
            DBG_CONTEXT, 
            "MDGetPropPaths failed hr = %08x\n", 
            hr
            ));
        }    
        
    if (pbBufferTemp != NULL)
        {
        delete [] pbBufferTemp;
        pbBufferTemp = NULL;
        }
        
    SETUP_TRACE((
        DBG_CONTEXT, 
        "RETURN - UpgradeInProcApplications. hr = %08x\n",
        hr
        ));

    return hr;
    
    }


/*===================================================================
RemoveWAMCLSIDFromInProcApp

Remove a WAMCLSID from a inproc application.(called only during update from
iis v4 to v5).  Remove the WAM component from IIS inproc package, unregister
the WAMCLSID and remove the WAMCLSID entry from the metabase.

Parameter:
Metabase path

Return:     HRESULT
===================================================================*/
HRESULT CWamSetupManager::RemoveWAMCLSIDFromInProcApp
(
IN LPCWSTR      szMetabasePath
)
    {
    WCHAR   szWAMCLSID[uSizeCLSID];
    WCHAR   szPackageID[uSizeCLSID];
    DWORD   dwAppMode = 0;
    DWORD   dwCallBack;
    HRESULT hr, hrRegistry;
    METADATA_HANDLE hMetabase = NULL;
    WamRegMetabaseConfig    MDConfig;
    
    hr = MDConfig.MDGetDWORD(szMetabasePath, MD_APP_ISOLATED, &dwAppMode);

    // return immediately, no application is defined, nothing to delete.
    if (hr == MD_ERROR_DATA_NOT_FOUND  || dwAppMode != 0)
        {
        return NOERROR;
        }

    if (FAILED(hr))
        {
        return hr;
        }

    // Get WAM_CLSID, and PackageID.
    hr = MDConfig.MDGetIDs(szMetabasePath, szWAMCLSID, szPackageID, dwAppMode);
    if( hr == MD_ERROR_DATA_NOT_FOUND )
        {
        SETUP_TRACE(( 
            DBG_CONTEXT, 
            "Application (%S) is not an IIS4 IP application.\n",
            szMetabasePath
            ));
        return NOERROR;
        }
    
    // Remove the WAM from the package.
    if (SUCCEEDED(hr))
        {
        WamRegPackageConfig     PackageConfig;
        HRESULT hrPackage;
        
        hr = PackageConfig.CreateCatalog();

        if ( FAILED( hr)) 
            {
            SETUP_TRACE_ERROR(( 
                DBG_CONTEXT,
                "Failed to Create MTS catalog hr=%08x\n",
                hr
                ));
            } 
        else 
            {            
            hr = PackageConfig.RemoveComponentFromPackage(szPackageID, 
                                           szWAMCLSID, 
                                           dwAppMode);
            if (FAILED(hr))    
                {
                SETUP_TRACE_ERROR((
                    DBG_CONTEXT, 
                    "Failed to remove component from package, \npackageid = %S, wamclsid = %S, hr = %08x\n",
                    szPackageID,
                    szWAMCLSID,
                    hr
                    ));
                }
            }
        hrPackage = hr;

        // Unregister WAM
        hr = g_RegistryConfig.UnRegisterCLSID(szWAMCLSID, FALSE);
        if (FAILED(hr))
            {
            SETUP_TRACE_ERROR((
                DBG_CONTEXT, 
                "Failed to UnRegister WAMCLSID(%S), hr = %08x\n",
                szWAMCLSID,
                hr
                ));
            
            DBG_ASSERT(FALSE);
            hrRegistry = hr;
            }
    
        }

    // Delete WAMCLSID
    MDPropItem     rgProp[IWMDP_MAX];
    MDConfig.InitPropItemData(&rgProp[0]);   
    MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_WAMCLSID);        
    MDConfig.UpdateMD(rgProp, METADATA_NO_ATTRIBUTES, szMetabasePath, TRUE);
        
    return NOERROR;
    }

/*===================================================================
AppCleanupAll

Parameter:
VOID

Return:     HRESULT(DON'T CARE)
===================================================================*/
HRESULT CWamSetupManager::AppCleanupAll(VOID)
{
    HRESULT hr = NOERROR;
    DWORD   dwBufferSizeTemp= 0;
    WCHAR*  pbBufferTemp = NULL;
    WamRegMetabaseConfig    MDConfig;
    
    SETUP_TRACE((DBG_CONTEXT, "CALL - AppCleanupAll\n"));
    
    DWORD dwSizePrefix = g_WamRegGlobal.g_cchMDW3SVCRoot;
    
    hr = MDConfig.MDGetPropPaths( g_WamRegGlobal.g_szMDW3SVCRoot, 
                                  MD_APP_ISOLATED, 
                                  &pbBufferTemp, 
                                  &dwBufferSizeTemp
                                  );
    
    if (SUCCEEDED(hr))
        {
        WCHAR*    pszString = NULL;
        WCHAR*  pszMetabasePath = NULL;

        DBG_ASSERT(pbBufferTemp != NULL);

        //
        // PREfix has a problem with the below code.  Specifically,
        // it has a problem with the fact that pbBufferTemp might be
        // NULL.  There is no supporting information in the PREfix
        // report that confirms that there's a possible code path
        // where MDGetPropPaths might succeed and yet yield a NULL
        // pbBufferTemp.  Further, we're asserting pbBufferTemp
        // immediately above, which is a sign that we don't expect
        // that pbBufferTemp can ever be NULL in this scenario.
        //
        
        /* INTRINSA suppress=null_pointers */

        for (pszString = (LPWSTR)pbBufferTemp;
                *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
                pszString += (wcslen(pszString) + 1)) 
            {
            //
            // MDGetPropPaths returns patial paths relative to /LM/W3SVC/, therefore, 
            // prepend the prefix string to the path
            //
            hr = g_WamRegGlobal.ConstructFullPath(
                        g_WamRegGlobal.g_szMDW3SVCRoot,
                        g_WamRegGlobal.g_cchMDW3SVCRoot,
                        pszString,
                        &pszMetabasePath
                        );
            if (SUCCEEDED(hr))
                {
                //
                // The default application under /LM/W3SVC is created differently with
                // normal application.  Therefore, it requires other code to remove the
                // the application.
                //
                if (!g_WamRegGlobal.FIsW3SVCRoot(pszMetabasePath))
                    {
                    hr = g_WamRegGlobal.DeleteApp(pszMetabasePath, FALSE, FALSE);
                    
                    SETUP_TRACE((
                        DBG_CONTEXT, 
                        "AppCleanupAll, found application (%S).\n",
                        pszMetabasePath
                        ));
                    
                    if (FAILED(hr))
                        {
                        SETUP_TRACE_ERROR((
                            DBG_CONTEXT, 
                            "AppCleanupAll, failed to delete application (%S), hr = %08x\n",
                            pszString,
                            hr
                            ));
                        delete [] pszMetabasePath;
                        pszMetabasePath = NULL;
                        break;
                        }
                    }
                    
                delete [] pszMetabasePath;
                pszMetabasePath = NULL;
                }
             else
                 {
                 SETUP_TRACE_ERROR((
                    DBG_CONTEXT, 
                    "AppCleanupAll, failed to construct full path, partial path (%S), hr = %08x\n",
                    pszString,
                    hr
                    ));
                }
            }
        }
    else
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "AppCleanupAll: GetPropPaths failed hr = %08x\n", 
            hr
            ));
        }    
        
        
    delete [] pbBufferTemp;
    pbBufferTemp = NULL;
        
    return hr;
}

/*===================================================================
DoGoryCoInitialize

  Description:
     CoInitialize() of COM is extremely funny function. It can fail
     and respond with S_FALSE which is to be ignored by the callers!
     On other error conditions it is possible that there is a threading
     mismatch. Rather than replicate the code in multiple places, here
     we try to consolidate the functionality in some rational manner.


  Arguments:
     None

  Returns:
     HRESULT = NOERROR on (S_OK & S_FALSE)
      other errors if any failure

Side effects:
    Create a Default IIS Package.  This package will exist until
    IIS is de-installed.
===================================================================*/
HRESULT
CWamSetupManager::DoGoryCoInitialize( VOID )
{
    // do the call to CoInitialize()
    m_hrCoInit = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    //
    // S_FALSE and S_OK are success.  Everything else is a failure and you don't need to call CoUninitialize.
    //
    if ( S_FALSE == m_hrCoInit ) 
    {
        //
        // It is okay to have failure (S_FALSE) in CoInitialize()
        // This error is to be ignored and balanced with CoUninitialize()
        //  We will reset the hr so that subsequent use is rational
        //
        SETUP_TRACE((
            DBG_CONTEXT,
            "DoGoryCoInitialize found duplicate CoInitialize.\n"
            ));
        m_hrCoInit = NOERROR;

    }
    else if( FAILED(m_hrCoInit) )
    {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT,
            "DoGoryCoInitialize() error %08x",
            m_hrCoInit
            ));
    }

    return m_hrCoInit;
} // DoGoryCoInitialize()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\sources.inc ===
#   sources
#   Author: Lei Jin(leijin)
#   Date:   07/03/1997
#
#   This file is used for compiling Proxy web server from code
#    for generic web server
#
#   Describes the macros used for building using NT 'build' command
#

MAJORCOMP=wamreg
MINORCOMP=wamreg

TARGETPATH=obj
TARGETTYPE=DYNLINK

MSC_WARNING_LEVEL=/W3 /WX

DLLDEF=..\wamreg.def

C_DEFINES=

DLLENTRY=_DllMainCRTStartup

USE_MSVCRT=1

RAW_TARGETLIBS=\
            $(SDK_LIB_PATH)\user32.lib    \
            $(SDK_LIB_PATH)\advapi32.lib    \
            $(SDK_LIB_PATH)\ole32.lib     \
            $(SDK_LIB_PATH)\oleaut32.lib     \
            $(SDK_LIB_PATH)\uuid.lib     \
            $(SDK_LIB_PATH)\kernel32.lib   \

TARGETLIBS=$(RAW_TARGETLIBS)

INCLUDES=..\.\;$(IISBASEDIR)\inc;$(IISBASEDIR)\inc\$(O);

SOURCES= ..\wmrgsv.idl \
         ..\wamreg.cpp \
         ..\wamadm.cpp \
         ..\comobj.cpp \
         ..\auxfunc.cpp \
         ..\export.cpp \
         ..\mdconfig.cpp \
         ..\mtsconfig.cpp \
         ..\wamreg.rc \

!IFDEF CAP_PROFILE
TARGETLIBS= $(TARGETLIBS)  $(CAP_LIBS)
!ENDIF

#
# ICAPHOOK.OBJ (ICECAP v3.6) allows user to set specific functions to profile
# without recompile the binary.
# NOTE: icaphook.obj is not available for ALPHA platform.
#
!IFDEF ICAP_PROFILE
TARGETLIBS= ..\..\..\..\libsupp\*\icaphook.obj $(TARGETLIBS) $(ICAP_LIBS)
!ENDIF

INCLUDES=.\;$(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\mtsconfig.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: mtsconfig.cpp

    implementation of supporting functions for WAMREG, including

    interface to Add/Remove Component from a MTS package,

History: LeiJin created on 9/24/1997

Note:

===================================================================*/
#include "common.h"
#include "auxfunc.h"
#include "comadmii.c"
#include "dbgutil.h"
#include "export.h"


/*===================================================================
  Define the global variables and types
======================================================================*/

//
// Following is a list of all the WAMREG/MTS properties for Package creation
//  Format:
//     (prop-symbolic-name, property-name-string)
//
//  WAMREG_MTS_PROPERTY()  -> means property for NT & Win9x
//  WAMREG_MTS_NTPROPERTY()  -> means property for NT only
//

# define ALL_WAMREG_MTS_PROPERTY()   \
  WAMREG_MTS_PROPERTY( WM_ID,          L"ID") \
  WAMREG_MTS_PROPERTY( WM_NAME,        L"Name") \
  WAMREG_MTS_PROPERTY( WM_CREATED_BY,  L"CreatedBy") \
  WAMREG_MTS_PROPERTY( WM_RUN_FOREVER, L"RunForever") \
  WAMREG_MTS_NTPROPERTY( WM_IDENTITY,  L"Identity") \
  WAMREG_MTS_NTPROPERTY( WM_PASSWORD,  L"Password") \
  WAMREG_MTS_PROPERTY( WM_ACTIVATION,  L"Activation") \
  WAMREG_MTS_PROPERTY( WM_CHANGEABLE,  L"Changeable") \
  WAMREG_MTS_PROPERTY( WM_DELETABLE,   L"Deleteable") \
  WAMREG_MTS_PROPERTY( WM_SECSUPP,     L"AccessChecksLevel") \


//
// Let us expand the macros here for defining the symbolic-name
//
//
# define WAMREG_MTS_PROPERTY( symName, pwsz)   symName, 
# define WAMREG_MTS_NTPROPERTY( symName, pwsz)   symName, 

enum WAMREG_MTS_PROP_NAMES {
  ALL_WAMREG_MTS_PROPERTY()  
  MAX_WAMREG_MTS_PROP_NAMES         // sentinel element
};

# undef WAMREG_MTS_PROPERTY
# undef WAMREG_MTS_NTPROPERTY


struct MtsProperty {
    LPCWSTR m_pszPropName;
    BOOL    m_fWinNTOnly;
};

//
// Let us expand the macros here for defining the property strings
//
//
# define WAMREG_MTS_PROPERTY( symName, pwsz)   { pwsz, FALSE },
# define WAMREG_MTS_NTPROPERTY( symName, pwsz)   { pwsz, TRUE },

static const MtsProperty g_rgWamRegMtsProperties[]= {
    ALL_WAMREG_MTS_PROPERTY()  
    { NULL, FALSE}           // sentinel element
};

# define NUM_WAMREG_MTS_PROPERTIES  \
   ((sizeof(g_rgWamRegMtsProperties)/sizeof(g_rgWamRegMtsProperties[0])) - 1)

# undef WAMREG_MTS_PROPERTY
# undef WAMREG_MTS_NTPROPERTY





/*===================================================================
WamRegPackageConfig    

Constructor.

Parameter:
NONE;
===================================================================*/
WamRegPackageConfig::WamRegPackageConfig()
:     m_pCatalog(NULL),
    m_pPkgCollection(NULL),
    m_pCompCollection(NULL),
    m_pPackage(NULL)
{

}

/*===================================================================
~WamRegPackageConfig    

Destructor. 
By the time the object gets destructed, all resources should be freed.
We do most of the cleanup inside WamReqPackageConfig::Cleanup() so
 that callers call that function separately to cleanup state
 especially if the caller also calls CoUninitialize().
WamRegPackageConfig should be cleaned up before CoUninitialize()

Parameter:
NONE;
===================================================================*/
WamRegPackageConfig::~WamRegPackageConfig()
{
    Cleanup();

    // insane checks to ensure everything is happy here
    DBG_ASSERT(m_pCatalog == NULL);
    DBG_ASSERT(m_pPkgCollection == NULL);
    DBG_ASSERT(m_pCompCollection == NULL);
    DBG_ASSERT(m_pPackage == NULL);
}

VOID
WamRegPackageConfig::Cleanup(VOID)
{
    if (m_pPackage != NULL ) {
        RELEASE( m_pPackage);
        m_pPackage = NULL;
    }
    
    if (m_pCompCollection != NULL) {
        RELEASE (m_pCompCollection);
        m_pCompCollection = NULL;
    }

    if (m_pPkgCollection != NULL ) {
        RELEASE(m_pPkgCollection);
        m_pPkgCollection = NULL;
    }

    if (m_pCatalog != NULL ) {
        RELEASE(m_pCatalog);
        m_pCatalog = NULL;
    }

} // WamPackageConfig::Cleanup()


/*===================================================================
ReleaseAll

Release all resources.

Parameter:
NONE;
===================================================================*/
VOID WamRegPackageConfig::ReleaseAll
(
)
{
    RELEASE(m_pPackage);
    RELEASE(m_pCompCollection);

    //
    // NOTE: I am not releasing m_pCatalog, m_pPkgCollection
    //  These will be released by the Cleanup().
    //
}

/*===================================================================
CreateCatalog

CoCreateObject of an MTS Catalog object if the Catalog object has not been
created.

Parameter:
NONE;
===================================================================*/
HRESULT WamRegPackageConfig::CreateCatalog
(
VOID
)
{
    HRESULT hr = NOERROR;

    DBG_ASSERT(m_pCatalog == NULL);
    DBG_ASSERT(m_pPkgCollection == NULL);

    // Create instance of the catalog object
    hr = CoCreateInstance(CLSID_COMAdminCatalog
                    , NULL
                    , CLSCTX_SERVER
                    , IID_ICOMAdminCatalog
                    , (void**)&m_pCatalog);

    if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT, 
                   "Failed to CoCreateInstance of Catalog Object.,hr = %08x\n",
                   hr));
    }
    else {
        DBG_ASSERT(m_pCatalog != NULL);

        BSTR  bstr;
        
        //
        // Get the Packages collection
        //
        bstr = SysAllocString(L"Applications");
        hr = m_pCatalog->GetCollection(bstr, (IDispatch**)&m_pPkgCollection);
        FREEBSTR(bstr);
        if (FAILED(hr)) {

            DBGPRINTF((DBG_CONTEXT, 
                       "m_pCatalog(%08x)->GetCollection() failed, hr = %08x\n",
                       m_pCatalog,
                       hr));
        } else {
            DBG_ASSERT( m_pPkgCollection != NULL);
        }
            
    }

    return hr;
} // WamRegPackageConfig::CreateCatalog()



/*===================================================================
SetCatalogObjectProperty    

Get a SafeArray contains one ComponentCLSID

Parameter:
szComponentCLSID    the CLSID need to be put in the safe array
paCLSIDs            pointer to a pointer of safe array(safe array provided by caller).

Return:        HRESULT
Side Affect:

Note:
===================================================================*/
HRESULT WamRegPackageConfig::GetSafeArrayOfCLSIDs
(
IN LPCWSTR    szComponentCLSID,
OUT SAFEARRAY**    paCLSIDs
)
{
    SAFEARRAY*          aCLSIDs = NULL;
    SAFEARRAYBOUND      rgsaBound[1];
    LONG                Indices[1];
    VARIANT                varT;
    HRESULT             hr = NOERROR;

    DBG_ASSERT(szComponentCLSID && paCLSIDs);
    DBG_ASSERT(*paCLSIDs == NULL);
    
    // PopulateByKey is expecting a SAFEARRAY parameter input,
    // Create a one element SAFEARRAY, the one element of the SAFEARRAY contains
    // the packageID.
    rgsaBound[0].cElements = 1;
    rgsaBound[0].lLbound = 0;
    aCLSIDs = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

    if (aCLSIDs)
        {
        Indices[0] = 0;

        VariantInit(&varT);
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(szComponentCLSID);
        hr = SafeArrayPutElement(aCLSIDs, Indices, &varT);
        VariantClear(&varT);

        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayPutElement, CLSID is %S, hr %08x\n",
                szComponentCLSID,
                hr));
       
            if (aCLSIDs != NULL)
                {
                HRESULT hrT = SafeArrayDestroy(aCLSIDs);
                if (FAILED(hrT))
                    {
                    DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
                        hr));
                    }
                aCLSIDs = NULL;
                }
            }
        }
    else
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayCreate, hr %08x\n",
                hr));
        }

    *paCLSIDs = aCLSIDs;
    return hr;
}



/*===================================================================
SetComponentObjectProperty    

Set component level property.

Parameter:
pComponent     - pointer to the ICatalogObject(MTS) used to update property
szPropertyName - Name of the property
szPropertyValue- Value of the property
fPropertyValue - If szPropertyValue is NULL, use fPropertyValue

Return:        HRESULT
Side Affect:

Note:
===================================================================*/
HRESULT    WamRegPackageConfig::SetComponentObjectProperty
(
IN ICatalogObject * pComponent,
IN LPCWSTR          szPropertyName,
IN LPCWSTR          szPropertyValue,
BOOL                fPropertyValue
)
{
    BSTR    bstr    = NULL;
    HRESULT hr      = NOERROR;
    VARIANT    varT;
    
    VariantInit(&varT);
    bstr = SysAllocString(szPropertyName);

    if (szPropertyValue != NULL)
        {
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(szPropertyValue);
        }
    else
        {
        //
        // COM+ regcongize -1 as TRUE, and 0 as FALSE.  I believe the root is from VB.
        //
        varT.vt = VT_BOOL;
        varT.boolVal = (fPropertyValue) ? -1 : 0;
        }
        
    hr = pComponent->put_Value(bstr, varT);
        
    FREEBSTR(bstr);
    VariantClear(&varT);

    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT,
                   "MTS-Component(%08x)::SetProperty(%S => %S) failed;"
                   " hr %08x\n",
                   pComponent, szPropertyName, szPropertyValue, hr));
        }        
    return hr;
}


/*===================================================================
WamRegPackageConfig::SetComponentObjectProperties()

Sets the componnet properties for newly created component that houses
the WAM unit

Parameter:
szComponentCLSID  -  CLSID for the component that is newly created

Return:        HRESULT

Side Affect:
  If there is a failure all the previously set values are not cleared.
  The caller should make sure that the proper cleanup of package happens
  on partial errors.

Note:
===================================================================*/
HRESULT
WamRegPackageConfig::SetComponentObjectProperties(
   IN LPCWSTR    szComponentCLSID
)
    {
    HRESULT         hr;
    SAFEARRAY*      aCLSIDs = NULL;
    long            lCompCount = 0;
    ICatalogObject* pComponent = NULL;
    BOOL            fFound;

    DBG_ASSERT( m_pCompCollection != NULL);

    //
    // Create the array containing the CLSIDs from the component name
    //  this will be used to find our object in MTS and set properties
    //   on the same
    //
    
    hr = GetSafeArrayOfCLSIDs(szComponentCLSID, &aCLSIDs);
    if (FAILED(hr)) 
        {
    
        DBGPRINTF((DBG_CONTEXT, 
                   "Failed in GetSafeArrayOfCLSIDs(%S). hr=%08x\n",
                   szComponentCLSID, hr));
        goto LErrExit;
        }
    
    hr = m_pCompCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr)) 
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
                   hr));
        goto LErrExit;
        }

    // Find our component in the list (should be the only one)
    hr = m_pCompCollection->get_Count(&lCompCount);
    if (FAILED(hr)) 
        {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed in CompCollection(%08x)::get_Count(). hr = %08x\n",
                   m_pCompCollection, hr));
        goto LErrExit;
        }

       
    //
    // Load the component object so that we can set properties
    //
    fFound = FALSE;
    if (SUCCEEDED(hr) && lCompCount == 1) 
        {
        hr = m_pCompCollection->get_Item(0, (IDispatch**)&pComponent);
        
        if (FAILED(hr)) 
            {
            
            DBGPRINTF((DBG_CONTEXT,
                       "Failed in CompCollection(%08x)::get component() hr=%08x\n",
                       m_pCompCollection, hr));
            goto LErrExit;
            } 
        else 
            {

            // Found it
            DBG_ASSERT(pComponent);
            fFound = TRUE;
            }
        }
        
    if (fFound) 
        {

        //
        // Component Properties       InProc            OutOfProc
        // ---------------------     --------           ----------
        // Synchronization              0               same
	    // Transaction              "Not Supported"     same
	    // JustInTimeActivation         N               same
	    // IISIntrinsics                N               same
	    // COMTIIntrinsics              N               same
	    // ComponentAccessChecksEnabled     0               same
        hr = SetComponentObjectProperty( pComponent, L"Synchronization", L"0");
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
        
        hr = SetComponentObjectProperty( pComponent, L"ComponentAccessChecksEnabled", L"0");
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
                
        hr = SetComponentObjectProperty( pComponent, L"Transaction", L"0");
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
        
        hr = SetComponentObjectProperty( pComponent, L"JustInTimeActivation",NULL,FALSE);
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }

        hr = SetComponentObjectProperty( pComponent, L"IISIntrinsics", NULL, FALSE);
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }

        hr = SetComponentObjectProperty( pComponent, L"COMTIIntrinsics", NULL, FALSE);
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
        
        hr = SetComponentObjectProperty(pComponent, L"EventTrackingEnabled", L"N");
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
        } 
    else 
        {

        DBGPRINTF((DBG_CONTEXT, 
                   "Unable to find newly create WAM component in package\n"));
        DBG_ASSERT(FALSE);
        }

LErrExit:    
    RELEASE(pComponent);
    
    if (aCLSIDs != NULL) {

        HRESULT hrT = SafeArrayDestroy(aCLSIDs);
        if (FAILED(hrT)) {
            
            DBGPRINTF((DBG_CONTEXT, 
                       "Failed to call SafeArrayDestroy(aCLSIDs=%08x),"
                       " hr = %08x\n",
                       aCLSIDs, hr));
        }
        aCLSIDs = NULL;
    }
    
    return ( hr);
} //  // WamRegPackageConfig::SetComponentObjectProperties()



/*===================================================================
SetPackageObjectProperty    

Set package level property.

Parameter:
szPropertyName  Name of the property
szPropertyValue Value of the property

Return:        HRESULT
Side Affect:

Note:
===================================================================*/
HRESULT    WamRegPackageConfig::SetPackageObjectProperty
(
IN LPCWSTR        szPropertyName,
IN LPCWSTR        szPropertyValue
)
{
    BSTR    bstr    = NULL;
    HRESULT hr      = NOERROR;
    VARIANT    varT;

    
    VariantInit(&varT);
    bstr = SysAllocString(szPropertyName);
    varT.vt = VT_BSTR;
    varT.bstrVal = SysAllocString(szPropertyValue);
    DBG_ASSERT(m_pPackage != NULL);
    hr = m_pPackage->put_Value(bstr, varT);
        
    FREEBSTR(bstr);
    VariantClear(&varT);

    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT,
                   "Set Catalog Object Property failed, "
                   "Component is %S, hr %08x\n",
                   szPropertyName,
                   hr));
        }        
    return hr;
} // WamRegPackageConfig::SetPackageObjectProperty()




/*===================================================================
WamRegPackageConfig::SetPackageProperties()

Sets package properties for all WAMREG properties.

Parameter:
rgpszValues:   An array containing pointers to string values to be used
               for setting up the WAMREG related properites for MTS catalog.

Return:        HRESULT
Side Affect:
  If there is a failure all the previously set values are not cleared.
  The caller should make sure that the proper cleanup of package happens
  on partial errors.

Note:
===================================================================*/
HRESULT    WamRegPackageConfig::SetPackageProperties
(
IN LPCWSTR    * rgpszValues
)
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( m_pPackage);

    //
    // Loop through all properties and set the values for these 
    //  properties using the passed in array of strings.
    // UGLY: MTS likes to have string properties which need to be 
    //   fed in as BSTRs => very inefficient.
    //

    for (DWORD i = 0; i < NUM_WAMREG_MTS_PROPERTIES; i++) {

        if ( (TsIsWindows95() && g_rgWamRegMtsProperties[i].m_fWinNTOnly) ||
             (rgpszValues[i] == NULL)
             ) {
            
            //
            // This parameter is for Win95 only
            // Or this parameter is required only for certain cases.
            // Skip this parameter.
            //

            continue;
        }

        DBG_ASSERT( rgpszValues[i] != NULL);

        IF_DEBUG( WAMREG_MTS) {
            DBGPRINTF(( DBG_CONTEXT, 
                        "In Package(%08x) setting property %S to value %S\n",
                        m_pPackage, 
                        g_rgWamRegMtsProperties[i].m_pszPropName,
                        rgpszValues[i]
                        ));
        }

        //
        // Now let us set up the property in the MTS package
        //

        hr = SetPackageObjectProperty(g_rgWamRegMtsProperties[i].m_pszPropName,
                                      rgpszValues[i]);
        if ( FAILED (hr)) {
            DBGPRINTF((DBG_CONTEXT, "Failed to set property %S, value is %S\n",
                g_rgWamRegMtsProperties[i].m_pszPropName,
                rgpszValues[i]));
            break;
        }
    } // for all properties

    return (hr);
} // WamRegPackageConfig::SetPackageProperties()


BOOL WamRegPackageConfig::IsPackageInstalled
(
IN LPCWSTR szPackageID,
IN LPCWSTR szComponentCLSID
)
/*++
Routine Description:

    Determine if the WAM package is installed and is valid. Currently this
    is only called by setup.

Parameters

    IN LPCWSTR szPackageID          - Package ID
    IN LPCWSTR szComponentCLSID     - Component CLSID

Return Value

    BOOL    - True if package contains the component. False otherwise.

--*/
{
    HRESULT     hr;
    SAFEARRAY*  aCLSIDs = NULL;
    SAFEARRAY*  aCLSIDsComponent = NULL;

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    long                    lPkgCount;
    BOOL                    fFound = FALSE;
    ICatalogCollection*     pCompCollection = NULL;
    
    // Only use the trace macro here, even for error conditions.
    // This routine may fail in a variety of ways, but we expect
    // to be able to fix any of them, only report an error if 
    // the failure is likely to impair the functionality of the
    // server.

    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "CALL - IsPackageInstalled, Package(%S) Component(%S)\n",
        szPackageID,
        szComponentCLSID
        ));

    //
    // Get the package
    //

    hr = GetSafeArrayOfCLSIDs(szPackageID, &aCLSIDs);
    if (FAILED(hr))
        {
        SETUP_TRACE((
            DBG_CONTEXT, 
            "Failed to GetSafeArrayOfCLSIDs for %S, hr = %08x\n",
            szPackageID,
            hr
            ));
        goto LErrExit;
        }

    hr = m_pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        SETUP_TRACE((
            DBG_CONTEXT, 
            "Failed in m_pPkgCollection(%p)->PopulateByKey(), hr = %08x\n",
            m_pPkgCollection,
            hr
            ));
        goto LErrExit;
        }
    
    hr = m_pPkgCollection->get_Count(&lPkgCount);
    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        // 
        // We found the package. Now verify that it contains our component.
        //
        SETUP_TRACE((
            DBG_CONTEXT, 
            "Successfully retrieved package (%S).\n",
            szPackageID
            ));

        VARIANT varKey;
        BSTR    bstrComponentCollection;

        VariantInit(&varKey);
        varKey.vt = VT_BSTR;
        varKey.bstrVal = SysAllocString(szPackageID);

        // Get the "ComponentsInPackage" collection.
        bstrComponentCollection = SysAllocString(L"Components");
        hr = m_pPkgCollection->GetCollection(
                    bstrComponentCollection, 
                    varKey, 
                    (IDispatch**)&pCompCollection
                    );
        
        FREEBSTR(bstrComponentCollection);
        VariantClear(&varKey);
        if (FAILED(hr))
            {
            SETUP_TRACE((
                DBG_CONTEXT, 
                "Failed in m_pPkgCollection(%p)->GetCollection(), hr = %08x\n",
                m_pPkgCollection,
                hr
                ));
            goto LErrExit;
            }

        hr = GetSafeArrayOfCLSIDs(szComponentCLSID, &aCLSIDsComponent);
        if (FAILED(hr))
            {
            SETUP_TRACE((
                DBG_CONTEXT, 
                "Failed to GetSafeArrayOfCLSIDs for %S, hr = %08x\n",
                szComponentCLSID,
                hr
                ));
            goto LErrExit;
            }

        hr = pCompCollection->PopulateByKey( aCLSIDsComponent );
        if( FAILED(hr) )
            {
            SETUP_TRACE((
                DBG_CONTEXT, 
                "Failed in pCompCollection(%p)->PopulateByKey, hr = %08x\n",
                pCompCollection,
                hr
                ));
            goto LErrExit;
            }

        hr = pCompCollection->get_Count( &lPkgCount );
        if( SUCCEEDED(hr) && lPkgCount == 1 )
            {
            // Success! We found the package and it contains the 
            // correct component.

            SETUP_TRACE((
                DBG_CONTEXT, 
                "Successfully retrieved component (%S) from package (%S).\n",
                szComponentCLSID,
                szPackageID
                ));

            fFound = TRUE;
            }
        }

LErrExit:
    if (aCLSIDs != NULL)
        {
        SafeArrayDestroy(aCLSIDs);        
        aCLSIDs = NULL;
        }

    if( aCLSIDsComponent != NULL )
        {
        SafeArrayDestroy(aCLSIDsComponent);
        aCLSIDsComponent = NULL;
        }
    
    RELEASE( pCompCollection );  

    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "RETURN - IsPackageInstalled, hr=%08x\n", 
        hr 
        ));
    return fFound;
}
/*===================================================================
RemovePackage    

Remove a Viper Package.

Parameter:
    szPackageID:    an MTS package ID.

Return:        HRESULT
Side Affect:

Note:
Remove an IIS package from MTS. So far, only been called from RemoveIISPackage.
RemoveComponentFromPackage() also removes a IIS package sometimes. 
Refer to that function header for info.
===================================================================*/
HRESULT WamRegPackageConfig::RemovePackage
(
IN LPCWSTR    szPackageID
)
{
    HRESULT                hr = NOERROR;
    long                lPkgCount = 0;
    long                lChanges;
    SAFEARRAY*          aCLSIDs = NULL;
    
    DBG_ASSERT(szPackageID);
    
    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    hr = GetSafeArrayOfCLSIDs(szPackageID, &aCLSIDs);        
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to get SafeArrayofCLSIDs, szPackageID is %S, hr %08x",
            szPackageID,
            hr));
        goto LErrExit;
        }
        
    //
    // Populate it
    //    
    hr = m_pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErrExit;
        }
        
    hr = m_pPkgCollection->get_Count(&lPkgCount);
    if (FAILED(hr))
        {
        IF_DEBUG(ERROR)
                {
                DBGPRINTF((DBG_CONTEXT, "pPkgCollection->Populate() failed, hr = %08x\n",
                    hr));
                }
        goto LErrExit;
        }
        
    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        hr = m_pPkgCollection->get_Item(0, (IDispatch**)&m_pPackage);
        if (FAILED(hr))
            {
            goto LErrExit;
            }
            
        // Found it - remove it and call Save Changes
        // First, Set Deleteable = Y property on package
        hr = SetPackageObjectProperty(L"Deleteable", L"Y");
        if (FAILED(hr))
            {
            goto LErrExit;
            }

        RELEASE(m_pPackage);
        
        // Let save the Deletable settings
        hr = m_pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Save the Deletable settings failed, hr = %08x\n",
                hr));
            goto LErrExit;
            }
            
        // Now we can delete
        hr = m_pPkgCollection->Remove(0);
        if (FAILED(hr))
            {                
            DBGPRINTF((DBG_CONTEXT, "Remove the Component from package failed, hr = %08x\n",
                hr));
            goto LErrExit;
            }

        // Aha, we should be able to delete now.
        hr = m_pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Save changes failed, hr = %08x\n",
                hr));
            goto LErrExit;
            }
        }

LErrExit:
    if (aCLSIDs != NULL)
        {
        HRESULT hrT = SafeArrayDestroy(aCLSIDs);
        if (FAILED(hrT))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
                hr));
            }
        aCLSIDs = NULL;
        }
        
    ReleaseAll();
        
    return hr;
}

/*===================================================================
CreatePackage    

Create a viper package.

Parameter:
szPackageID:            [in] Viper Package ID.
szPackageName:            [in] the name of the package.
szIdentity:                [in] Pakcage identity
szIdPassword:           [in] Package idneitty password
fInProc:                [in] Inproc or outproc package

Return:        HRESULT
Side Affect:
NONE.

===================================================================*/
HRESULT WamRegPackageConfig::CreatePackage
(    
IN LPCWSTR    szPackageID,
IN LPCWSTR    szPackageName,
IN LPCWSTR    szIdentity,
IN LPCWSTR    szIdPassword,
IN BOOL        fInProc
)
    {
    
    HRESULT     hr;
    SAFEARRAY*  aCLSIDs = NULL;

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    long lPkgCount;
    BOOL fFound = FALSE;

    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "CALL - CreatePackage ID(%S) Name(%S)\n",
        szPackageID,
        szPackageName
        ));
    
    //
    // Try to get the package.
    //
    SETUP_TRACE((
        DBG_CONTEXT, 
        "Checking to see if package ID(%S) Name(%S) exists.\n",
        szPackageID,
        szPackageName
        ));

    hr = GetSafeArrayOfCLSIDs(szPackageID, &aCLSIDs);
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed to GetSafeArrayOfCLSIDs for %S, hr = %08x\n",
            szPackageID,
            hr
            ));
        goto LErrExit;
        }

    hr = m_pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed in m_pPkgCollection(%p)->PopulateByKey(), hr = %08x\n",
            m_pPkgCollection,
            hr
            ));
        goto LErrExit;
        }
    
    hr = m_pPkgCollection->get_Count(&lPkgCount);
    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        //
        // Found the CLSID in PopulateByKey().
        //
        hr = m_pPkgCollection->get_Item(0, (IDispatch**)&m_pPackage);
        if (FAILED(hr))
            {
            SETUP_TRACE_ERROR((
                DBG_CONTEXT, 
                "Failed in m_pPkgCollection(%p)->get_Item(). Err=%08x\n",
                m_pPkgCollection, 
                hr
                ));
            goto LErrExit;
            }
        else
            {
            SETUP_TRACE(( 
                DBG_CONTEXT, 
                "CreatePackage - Package already exists, ID(%S), Name(%S)\n",
                szPackageID,
                szPackageName
                ));
            DBG_ASSERT(m_pPackage);
            fFound = TRUE;
            }
        }

    if ( SUCCEEDED(hr) )
    {

        if( !fFound )
        {
            SETUP_TRACE(( 
                DBG_CONTEXT, 
                "Package ID(%S) Name(%S) does not exist. Attempting to create it.\n",
                szPackageID,
                szPackageName
                ));
            //
            // The package does not already exist, we need to call Add() to 
            // add this package and then set it's properties.
            //
            hr = m_pPkgCollection->Add((IDispatch**)&m_pPackage);
            if ( FAILED(hr)) 
                {
                SETUP_TRACE_ERROR(( 
                    DBG_CONTEXT, 
                    "Failed in m_pPkgCollection(%p)->Add(). Err=%08x\n",
                    m_pPkgCollection, 
                    hr
                    ));
                goto LErrExit;
                }
        }
        
        DBG_ASSERT( SUCCEEDED( hr));
        DBG_ASSERT( m_pPackage != NULL);

        if( SUCCEEDED(hr) && m_pPackage != NULL )
        {
            //
            // Set the Package properties 
            //  first by initializing the array of values and then
            //  calling SetPackageProperties()
            //
        
            LPCWSTR rgpszValues[ MAX_WAMREG_MTS_PROP_NAMES];

            ZeroMemory( rgpszValues, sizeof( rgpszValues));

            if( fFound )
            {
                // For an existing package, we don't want to set the ID
                rgpszValues[ WM_ID]         = NULL;
            }
            else
            {
                rgpszValues[ WM_ID]         = szPackageID;
            }

            rgpszValues[ WM_NAME]       = szPackageName;
            rgpszValues[ WM_CREATED_BY] = 
                L"Microsoft Internet Information Services";

            rgpszValues[ WM_RUN_FOREVER] = L"Y";

            rgpszValues[ WM_IDENTITY]   = szIdentity;
            rgpszValues[ WM_PASSWORD]   = szIdPassword;
            rgpszValues[ WM_ACTIVATION] = 
                ((fInProc) ? L"InProc" : L"Local");
        
            rgpszValues[ WM_CHANGEABLE] = L"Y";
            rgpszValues[ WM_DELETABLE]  = L"N";
            rgpszValues[ WM_SECSUPP] = L"0";
        
            //
            // Now that we have the properties setup, let us
            //  now set the properties in the MTS using catalog
            //  object
            //
            hr = SetPackageProperties( rgpszValues);
            if ( FAILED( hr)) 
            {
                SETUP_TRACE_ERROR(( 
                    DBG_CONTEXT, 
                    "Failed to set properties for package %p. Err=%08x\n",
                    m_pPackage, 
                    hr
                    ));
                goto LErrExit;
            }

            long lChanges;
    
            hr = m_pPkgCollection->SaveChanges(&lChanges);
            if (FAILED(hr))
            {
                SETUP_TRACE_ERROR((
                    DBG_CONTEXT, 
                    "Failed in m_pPkgCollection(%p)->SaveChanges. error = %08x\n",
                    m_pPkgCollection,
                    hr
                    ));
                goto LErrExit;
            }
        } 
    }
    
LErrExit:

    if (aCLSIDs != NULL)
        {
        SafeArrayDestroy(aCLSIDs);        
        aCLSIDs = NULL;
        }
        
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed to Create Package. Package Name = %S, Package ID = %S, error = %08x\n",
            szPackageName,
            szPackageID,
            hr
            ));
        }
    
    SETUP_TRACE_ASSERT(SUCCEEDED(hr));

    ReleaseAll();
    
    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "RETURN - CreatePackage ID(%S) Name(%S)\n",
        szPackageID,
        szPackageName
        ));

    return hr;
    }

/*===================================================================
AddComponentFromPackage    

Add a Component (a WAM CLSID) from a Viper Package.  Assume the package
is already existed.

Parameter:
szPackageID:            [in] Viper Package ID.
szComponentCLSID:        [in] Component CLSID.
fInProc:                [in] if TRUE, we set certain property on the Component.

Return:        HRESULT
Side Affect:
NONE.

===================================================================*/
HRESULT    WamRegPackageConfig::AddComponentToPackage
(    
IN LPCWSTR    szPackageID,
IN LPCWSTR    szComponentCLSID
)
{
    HRESULT            hr;
    BSTR bstrGUID    = NULL;
    BSTR bstr = NULL;
    VARIANT         varKey;
    long            lChanges;
    BOOL            fFound;
    long            lPkgCount;
    BOOL            fImported = FALSE;
    
    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "CALL - AddComponentToPackage, Package(%S) Component(%S)\n",
        szPackageID,
        szComponentCLSID
        ));

    DBG_ASSERT(szPackageID);
    DBG_ASSERT(szComponentCLSID);
    
    VariantInit(&varKey);
    VariantClear(&varKey);

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    varKey.vt = VT_BSTR;
    varKey.bstrVal = SysAllocString(szPackageID);
    
    bstr = SysAllocString(szPackageID);
    bstrGUID = SysAllocString(szComponentCLSID);
    
    hr = m_pCatalog->ImportComponent(bstr, bstrGUID);
    FREEBSTR(bstr);
    FREEBSTR(bstrGUID);
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed in m_pCatalog(%p)->ImportComponent(). error %08x\n",
            m_pCatalog,
            hr
            ));
        goto LErrExit;
        }
    else
        {
        fImported = TRUE;
        }

    // Get the "ComponentsInPackage" collection.
    bstr = SysAllocString(L"Components");
    
    hr = m_pPkgCollection->GetCollection(bstr, varKey, (IDispatch**)&m_pCompCollection);
    FREEBSTR(bstr);
    VariantClear(&varKey);
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed in m_pPkgCollection(%p)->GetCollection(). error %08x\n",
            m_pPkgCollection,
            hr
            ));
        goto LErrExit;
        }    

    //
    // Find and Set properties on the component object
    //
    hr = SetComponentObjectProperties( szComponentCLSID);
    if ( FAILED(hr)) 
    {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed to SetComponentObjectProperties. error %08x\n",
            hr
            ));
        goto LErrExit;
    }
        
LErrExit:
        
    // Save changes
    if (SUCCEEDED(hr))
        {
        hr = m_pCompCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            SETUP_TRACE_ERROR((
                DBG_CONTEXT, 
                "Failed in m_pCompCollection(%p)->SaveChanges(), error = %08x\n",
                m_pCompCollection,
                hr
                ));
            }
        }
    else
        {
        // CODEWORK - This seems like a bad idea. The release should drop any
        // changes we made, so this cleanup code seems to be asking for trouble.

        // Need to remove component from the package
        if (fImported && m_pCompCollection )
            {
            SETUP_TRACE_ERROR((
                DBG_CONTEXT, 
                "Failed in AddComponentToPackage, removing the component, error = %08x\n",
                hr
                ));

            HRESULT hrT;
            long    lCompCount;

            // Find our component in the list (should be the only one)
            hrT = m_pCompCollection->get_Count(&lCompCount);
            if (SUCCEEDED(hrT))
                {
                fFound = FALSE;
                if (SUCCEEDED(hrT) && lCompCount == 1)
                    {
                    // Found it
                    fFound = TRUE;
                    hrT = m_pCompCollection->Remove(0);
                    if (SUCCEEDED(hrT))
                        {
                        hrT = m_pCompCollection->SaveChanges(&lChanges);
                        if (FAILED(hrT))
                            {
                            SETUP_TRACE_ERROR((
                                DBG_CONTEXT, 
                                "Failed in m_pCompCollection->SaveChanges() during cleanup, error = %08x\n",
                                hrT
                                ));
                            }

                        }
                    else
                        {
                        SETUP_TRACE_ERROR((
                            DBG_CONTEXT, 
                            "Failed in m_pCompCollection->Remove() during cleanup, hr = %08x\n", 
                            hrT
                            ));
                        }
                    }
                }
            }
        }
        
    FREEBSTR(bstr);
    VariantClear(&varKey);
    
    ReleaseAll();

    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "RETURN - AddComponentToPackage, Package(%S) Component(%S), hr=%08x\n",
        szPackageID,
        szComponentCLSID,
        hr
        ));
        
    return hr;
}

/*===================================================================
RemoveComponentFromPackage    

Remove a Component (a WAM CLSID) from a Viper Package.

Parameter:
szPackageID:            [in] Viper Package ID.
szComponentCLSID:        [in] Component CLSID.
fDeletePackage:            [in] if TRUE, we delete the package always. (be very careful, with in-proc
                             package).

Return:        HRESULT
Side Affect:
After remove the component from the package, if the component count in the
package is 0, then delete the whole package.

===================================================================*/
HRESULT    WamRegPackageConfig::RemoveComponentFromPackage
(
IN LPCWSTR szPackageID,
IN LPCWSTR szComponentCLSID,
IN DWORD   dwAppIsolated
)
{    
    HRESULT             hr;
    BSTR                bstr = NULL;
    BSTR                bstrGUID    = NULL;
    VARIANT             varKey;
    VARIANT             varT;
    SAFEARRAY*          aCLSIDs = NULL;
    LONG                Indices[1];
    long                lPkgCount, lCompCount, lChanges;
    long                lPkgIndex = 0;
    BOOL fFound;
    
    VariantInit(&varKey);
    VariantClear(&varKey);
    VariantInit(&varT);
    VariantClear(&varT);

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    hr = GetSafeArrayOfCLSIDs(szPackageID, &aCLSIDs);
    //
    // Populate it
    //    
    hr = m_pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErrExit;
        }

    // Find our component in the list (should be the only one)
    hr = m_pPkgCollection->get_Count(&lPkgCount);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call MTS Admin API. error %08x\n", hr));
        goto LErrExit;
        }

    fFound = FALSE;
    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        hr = m_pPkgCollection->get_Item(0, (IDispatch**)&m_pPackage);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call MTS Admin API. error %08x\n", hr));
            goto LErrExit;
            }
        
        hr = m_pPackage->get_Key(&varKey);
        if (SUCCEEDED(hr))
            {
            // Found it
            DBG_ASSERT(m_pPackage);
            fFound = TRUE;
            }
        }

    // Get the "Components" collection.
    bstr = SysAllocString(L"Components");
    hr = m_pPkgCollection->GetCollection(bstr, varKey, (IDispatch**)&m_pCompCollection);
    FREEBSTR(bstr);
    VariantClear(&varKey);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
        goto LErrExit;
        }
    
    // Repopulate the collection so we can find our object and set properties on it
    Indices[0] = 0;
    VariantInit(&varT);
    varT.vt = VT_BSTR;
    varT.bstrVal = SysAllocString(szComponentCLSID);
    hr = SafeArrayPutElement(aCLSIDs, Indices, &varT);
    VariantClear(&varT);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
            hr));
        }
    //
    // Populate it
    //    
    hr = m_pCompCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErrExit;
        }

    // Find our component in the list (should be the only one)
    hr = m_pCompCollection->get_Count(&lCompCount);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call MTS Admin API. error %08x\n", hr));
        goto LErrExit;
        }

    fFound = FALSE;
    if (SUCCEEDED(hr) && lCompCount == 1)
        {
        // Found it
        fFound = TRUE;
        hr = m_pCompCollection->Remove(0);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
            goto LErrExit;
            }
        }
        
    DBG_ASSERT(fFound);

    // Save changes
    hr = m_pCompCollection->SaveChanges(&lChanges);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
        goto LErrExit;
        }


    // 
    //  Need to populate again to get the Component count after remove the component from
    //  the package.  The populatebykey only populate 1 component a time.
    //  However, if this package is the default package hosting all in-proc WAM components,
    //  we know that there is at least one component W3SVC always in this package, therefore
    //  we skip the GetComponentCount call here.
    //  The component count for the default package must be at least one, 
    //

    // Set lCompCount = 1, so that the only case that lCompCount becomes 0 is the OutProc
    // Islated package has 0 components.
    lCompCount = 1;
    if (dwAppIsolated == static_cast<DWORD>(eAppRunOutProcIsolated))
        {
        hr = m_pCompCollection->Populate();
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
            goto LErrExit;
            }
            
        // Find our component in the list (should be the only one)
        hr = m_pCompCollection->get_Count(&lCompCount);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
            goto LErrExit;
            }

        // Component count is 0, remove the package.
        if (lCompCount == 0)
            {        
            // Found it - remove it and call Save Changes
            // First, Set Deleteable = Y property on package
            hr = SetPackageObjectProperty(L"Deleteable", L"Y");
            if (FAILED(hr))
                {
                goto LErrExit;
                }

            RELEASE(m_pPackage);
            // Let save the Deletable settings
            hr = m_pPkgCollection->SaveChanges(&lChanges);
            if (FAILED(hr))
                {
                DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
                goto LErrExit;
                }
                
            hr = m_pPkgCollection->Remove(0);
            if (FAILED(hr))
                {
                DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
                goto LErrExit;
                }
            }
        else
            {
            // Set Attribute Deleteable = "Y"
            hr = SetPackageObjectProperty(L"Deleteable", L"Y");
            if (FAILED(hr))
                {
                goto LErrExit;
                }

            // Set CreatedBy = ""
            hr = SetPackageObjectProperty(L"CreatedBy", L"");
            if (FAILED(hr))
                {
                goto LErrExit;
                }

            // Set Identity to Interactive User. MTS might use that package with "Interactive User"
            // as the indentity.
            hr = SetPackageObjectProperty(L"Identity", L"Interactive User");
            if (FAILED(hr))
                {
                DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
                goto LErrExit;
                }

            RELEASE(m_pPackage);
            }
            
        hr = m_pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
            goto LErrExit;
            }
        }
LErrExit:

    if (aCLSIDs != NULL)
        {
        HRESULT hrT;
        hrT = SafeArrayDestroy(aCLSIDs);

        if (FAILED(hrT))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
                hr));
            }

        aCLSIDs = NULL;
        }

    FREEBSTR(bstr);
    
    VariantClear(&varKey);
    VariantClear(&varT);

    ReleaseAll();
    return hr;

}

#if 0

// OBSOLETE - This fix (335422) was implemented in script but
// some of the code is general enough that it might be worth
// keeping around for a while.


HRESULT     
WamRegPackageConfig::ResetPackageActivation
(
    IN LPCWSTR  wszPackageID,
    IN LPCWSTR  wszIWamUser,
    IN LPCWSTR  wszIWamPass
)
/*+
Routine Description:

    Retrieve the specified package and reset its activation
    identity. 
    
    This is really a crummy method, but this whole class is
    not really designed to provide a wrapper for the com admin
    api, so it's much safer just to make this a specific method.

Arguments:

    IN LPCWSTR  wszPackageID    - the package to reset
    IN LPCWSTR  wszIWamUser     - IWAM_*
    IN LPCWSTR  wszIWamPass     - password for IWAM_*

Returns:
    HRESULT
-*/
{
    HRESULT     hr = NOERROR;
    LONG        nChanges = 0;

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);
    DBG_ASSERT( m_pPackage == NULL );

    hr = LoadPackage( wszPackageID );

    if( SUCCEEDED(hr) )
    {
        DBG_ASSERT( m_pPackage != NULL );

        LPCWSTR rgpszValues[ MAX_WAMREG_MTS_PROP_NAMES ];

        ZeroMemory( rgpszValues, sizeof(rgpszValues) );

        rgpszValues[WM_IDENTITY]   = wszIWamUser;
        rgpszValues[WM_PASSWORD]   = wszIWamPass;

        hr = SetPackageProperties( rgpszValues );

        if( SUCCEEDED(hr) )
        {
            hr = m_pPkgCollection->SaveChanges( &nChanges );
        }
    }

    ReleaseAll();
    
    return hr;
}

HRESULT 
WamRegPackageConfig::LoadPackage
(
    IN LPCWSTR  wszPackageID
)
/*+
Routine Description:

    Retrieve the specified package into m_pPackage

    TODO - Use this when creating as well. Need to add
    the necessary debug/setuplog traces.

Arguments:

    IN LPCWSTR  wszPackageID    - the package to load

Returns:
    HRESULT
-*/
{
    HRESULT hr = NOERROR;
    SAFEARRAY*  psaPackageClsid = NULL;

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);
    DBG_ASSERT( m_pPackage == NULL );

    hr = GetSafeArrayOfCLSIDs( wszPackageID, &psaPackageClsid );
    if( SUCCEEDED(hr) )
    {
        hr = m_pPkgCollection->PopulateByKey( psaPackageClsid );

        DBG_CODE(
            if( SUCCEEDED(hr) )
            {
                LONG nPackages;
                hr = m_pPkgCollection->get_Count( &nPackages );

                DBG_ASSERT( SUCCEEDED(hr) );
                DBG_ASSERT( nPackages == 1 );
            }
        );

        if( SUCCEEDED(hr) )
        {
            hr = m_pPkgCollection->get_Item( 0, (IDispatch **)&m_pPackage );
        }
    }

    if( psaPackageClsid ) SafeArrayDestroy( psaPackageClsid );

    return hr;
}

// OBSOLETE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\vptool\makefile.inc ===
#
# Supplemental rules for generating Type library.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\wamadm.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: WamAdm.cpp 

	Implementation of WamAdm object, including ClassFactory, IWamAdm,
	IMSAdminReplication

Owner: LeiJin

Note:

WamAdm implementation
===================================================================*/	
#include "common.h"
#include "iiscnfg.h"
#include "iwamreg.h"
#include "WamAdm.h"
#include "auxfunc.h"
#include "wmrgexp.h"
#include "dbgutil.h"
#include "mtxrepli.c"
#include "mtxrepl.h"

#ifdef _IIS_6_0
#include "string.hxx"
#include "multisz.hxx"
#include "w3ctrlps.h"
#include "iiscnfgp.h"
#endif // _IIS_6_0

#define ReleaseInterface(p) if (p) { p->Release(); p = NULL; } 

const LPCWSTR APPPOOLPATH = L"/LM/W3SVC/AppPools/";

#ifndef DBGERROR
#define DBGERROR(args) ((void)0) /* Do Nothing */
#endif
#ifndef DBGWARN
#define DBGWARN(args) ((void)0) /* Do Nothing */
#endif

/////////////////////////////////////////////////////////////////////////////
// CWamAdmin

/*===================================================================
CWamAdmin

Constructor

Parameter:
NONE.

Return:			
===================================================================*/
CWamAdmin::CWamAdmin()
:	m_cRef(1)
{		
    InterlockedIncrement((long *)&g_dwRefCount);
}

/*===================================================================
~CWamAdmin

Constructor

Parameter:
NONE.

Return:			
===================================================================*/
CWamAdmin::~CWamAdmin()
{
    InterlockedDecrement((long *)&g_dwRefCount);
}

/*===================================================================
CWamAdmin::QueryInterface

QueryInterface, CWamAdmin supports 2 interfaces, one is IID_IWamAdmin,
the other is IID_IMSAdminReplication.

Parameter:
riid	
ppv		pointer to Interface pointer


Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWamAdmin)
    {
        *ppv = static_cast<IWamAdmin*>(this);
    }
    else if (riid == IID_IWamAdmin2)
    {
        *ppv = static_cast<IWamAdmin2*>(this);
    }
    else if (riid == IID_IMSAdminReplication)
    {
        *ppv = static_cast<IMSAdminReplication*>(this);
    }
#ifdef _IIS_6_0
    else if (riid == IID_IIISApplicationAdmin)
    {
        *ppv = static_cast<IIISApplicationAdmin*>(this);
    }
#endif //_IIS_6_0
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return NOERROR;
}

/*===================================================================
CWamAdmin::AddRef


Parameter:
	NONE

Return:	HRESULT
===================================================================*/
STDMETHODIMP_(ULONG) CWamAdmin::AddRef( )
{
    return InterlockedIncrement(&m_cRef);
}

/*===================================================================
CWamAdmin::Release


Parameter:
	NONE

Return:	HRESULT
===================================================================*/
STDMETHODIMP_(ULONG) CWamAdmin::Release( )
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    
    return m_cRef;
}


/*===================================================================
CWamAdmin::AppCreate

Create an application on szMDPath.  The fInProc indicates whether the 
result application is in-proc or out-proc.  If There is already an application
existed on szMDPath, AppCreate will remove the old application if fInProc does not
match with existing application.  Otherwise, it is no-op.


Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fInProc		TRUE if wants to have an InProc application,
			FALSE if wants to have an outproc application.

Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppCreate(LPCWSTR szMDPath, BOOL fInProc)
{
    DWORD dwAppMode = (fInProc) ? 
                    eAppRunInProc : eAppRunOutProcIsolated;

    return AppCreate2(szMDPath, dwAppMode);    
}

/*===================================================================
CWamAdmin::AppDelete

Delete an application on a Metabase Path.  If there is no application existed 
before, it is no-op.


Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to delete applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppDelete(LPCWSTR szMDPath, BOOL fRecursive)
{
    return PrivateDeleteApplication(szMDPath,
                                    fRecursive,
                                    FALSE,   // Recoverable?
                                    FALSE);  // RemoveAppPool?
}

HRESULT
CWamAdmin::PrivateDeleteApplication
(
LPCWSTR szMDPath,
BOOL fRecursive,
BOOL fRecoverable,
BOOL fRemoveAppPool
)
{
    HRESULT hr = NOERROR;
    DWORD	dwAppMode;
    WamRegMetabaseConfig    MDConfig;  
    LPWSTR pwszFormattedPath = NULL;
    
    if (szMDPath == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    //
    // Refer to function comment of FormatMetabasePath.
    //
    hr = FormatMetabasePath(szMDPath, &pwszFormattedPath);
    if (FAILED(hr))
    {
        return hr;
    }
    
    if (!g_WamRegGlobal.FAppPathAllowConfig(pwszFormattedPath))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();
    
    if (!fRecursive)
    {
        hr = g_WamRegGlobal.DeleteApp(pwszFormattedPath, fRecoverable, fRemoveAppPool);
        
        if (hr == MD_ERROR_DATA_NOT_FOUND)
        {
            hr = NOERROR;
        }
        
        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed to Delete on path %S, hr = %08x\n",
                szMDPath,
                hr));
        }
        
    }
    else
    {
        HRESULT hrT = NOERROR;
        DWORD dwSizePrefix;
        WCHAR* pbBufferTemp = NULL;
        DWORD dwBufferSizeTemp = 0;
        
        dwSizePrefix = wcslen(pwszFormattedPath);
        
        hr = MDConfig.MDGetPropPaths(pwszFormattedPath, MD_APP_ISOLATED, &pbBufferTemp, &dwBufferSizeTemp);
        
        if (SUCCEEDED(hr) && pbBufferTemp)
        {
            WCHAR*	pszString = NULL;
            WCHAR*	pszMetabasePath = NULL;
            
            for (pszString = (LPWSTR)pbBufferTemp;
            *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
            pszString += (wcslen(pszString) + 1)) 
            {
                hr = g_WamRegGlobal.ConstructFullPath(pwszFormattedPath,
                    dwSizePrefix,
                    pszString,
                    &pszMetabasePath
                    );
                if (SUCCEEDED(hr))
                {
                    if (!g_WamRegGlobal.FIsW3SVCRoot(pszMetabasePath))
                    {					
                        hr = g_WamRegGlobal.DeleteApp(pszMetabasePath, fRecoverable, fRemoveAppPool);
                        
                        if (FAILED(hr))
                        {
                            DBGPRINTF((DBG_CONTEXT, "Failed to Delete on path %S, hr = %08x\n",
                                pszString,
                                hr));
                            break;
                        }
                    }
                    
                    delete [] pszMetabasePath;
                    pszMetabasePath = NULL;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "Failed to DeleteRecoverable, hr = %08x\n",
                        pszString,
                        hr));
                }
            }
            
            delete [] pbBufferTemp;
            pbBufferTemp = NULL;
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "Delete: GetPropPaths failed hr = %08x\n", hr));
        }	
    }
    
    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();
    
    if (pwszFormattedPath != szMDPath)
    {
        delete [] pwszFormattedPath;
        pwszFormattedPath = NULL;
    }
    
    return hr;
}

/*===================================================================
CWamAdmin::AppUnLoad

UnLoad an application on a Metabase Path.  If there is no application running
it returns NOERROR.

For non-administrators we prevent them from unloading applications
in the pool. If the recursive flag is set, we will silently 
ignore failures due to insufficient access.

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to unload applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppUnLoad(LPCWSTR szMDPath, BOOL fRecursive)
{
    HRESULT                 hr = NOERROR;
    DWORD                   dwCallBack = 0;
    WamRegMetabaseConfig    MDConfig;
    DWORD                   dwAppIsolated = 0;
    BOOL                    bIsAdmin = TRUE;
    
    if (szMDPath == NULL || *szMDPath == L'\0')
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    bIsAdmin = MDConfig.HasAdminAccess();
    
    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();
    
    if (fRecursive)
    {
        DWORD       dwSizePrefix = wcslen(szMDPath);;
        WCHAR*      pbBufferTemp = NULL;
        DWORD       dwBufferSizeTemp = 0;
        
        hr = MDConfig.MDGetPropPaths( szMDPath, 
            MD_APP_ISOLATED, 
            &pbBufferTemp, 
            &dwBufferSizeTemp);
        
        if (SUCCEEDED(hr))
        {
            WCHAR*	pszString = NULL;
            WCHAR*	pszMetabasePath = NULL;
            BOOL    bDoUnload;
            
            for( pszString = (LPWSTR)pbBufferTemp;
            *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
            pszString += (wcslen(pszString) + 1)) 
            {
                bDoUnload = TRUE;
                
                hr = g_WamRegGlobal.ConstructFullPath(szMDPath,
                    dwSizePrefix,
                    pszString,
                    &pszMetabasePath
                    );
                
                if( SUCCEEDED(hr) && !bIsAdmin )
                {
                    hr = MDConfig.MDGetDWORD( pszMetabasePath, 
                        MD_APP_ISOLATED, 
                        &dwAppIsolated );
                    
                    DBG_ASSERT( SUCCEEDED(hr) );
                    if( SUCCEEDED(hr) && eAppRunOutProcInDefaultPool == dwAppIsolated )
                    {
                        // Do not unload
                        bDoUnload = FALSE;
                        DBGPRINTF((DBG_CONTEXT, 
                            "Insufficient Access to unload Application %S, hr = %08x\n",
                            pszMetabasePath,
                            hr));
                    }
                }
                
                if( SUCCEEDED(hr) && bDoUnload )
                {					
                    hr = g_WamRegGlobal.W3ServiceUtil( pszMetabasePath, 
                        APPCMD_UNLOAD, 
                        &dwCallBack);
                }
                
                if( pszMetabasePath )
                {
                    delete [] pszMetabasePath;
                    pszMetabasePath = NULL;
                }
            } // for each application
        }
        if (pbBufferTemp != NULL)
        {
            delete [] pbBufferTemp;
            pbBufferTemp = NULL;
        }
    }
    else
    {
        if( !bIsAdmin )
        {
            // Non recursive
            hr = MDConfig.MDGetDWORD( szMDPath, 
                MD_APP_ISOLATED, 
                &dwAppIsolated );
            
            if( SUCCEEDED(hr) && eAppRunOutProcInDefaultPool == dwAppIsolated )
            {
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                DBGPRINTF((DBG_CONTEXT,
                    "Insufficient Access to unload Application %S, hr = %08x\n",
                    szMDPath,
                    hr));
            }
        }
        
        if( SUCCEEDED(hr) )
        {
            hr = g_WamRegGlobal.W3ServiceUtil(szMDPath, APPCMD_UNLOAD, &dwCallBack);
        }
    }
    
    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();
    
    return hr;
}

/*===================================================================
CWamAdmin::AppGetStatus

GetStatus an application on a Metabase Path.  If there is an application on the
metabase path, and the application is currently running, the dwStatus is set to
APPSTATUS_RUNNING, if the application is not running, the dwStatus is set to 
APPSTATUS_STOPPED, if there is no application defined on the metabase path, the
dwStatus is set to APPSTATUS_NOTDEFINED.

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
pdwAppStatus	pointer DWORD buffer contains status result.

Return:	HRESULT
NOERROR	if succeeded.
===================================================================*/
STDMETHODIMP CWamAdmin::AppGetStatus(LPCWSTR szMDPath, DWORD* pdwAppStatus)
{
    HRESULT hr = NOERROR;
    HRESULT hrT;
    DWORD	dwCallBack = 0;
    WamRegMetabaseConfig    MDConfig;
    
    if (szMDPath == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();
    
    hrT = g_WamRegGlobal.W3ServiceUtil(szMDPath, APPCMD_GETSTATUS, &dwCallBack);
    if (dwCallBack == APPSTATUS_Running)
    {
        *pdwAppStatus = APPSTATUS_RUNNING;
    }
    else if (dwCallBack ==  APPSTATUS_Stopped)
    {
        *pdwAppStatus = APPSTATUS_STOPPED;
    }
    else
    {
        DWORD dwAppMode;
        hr = MDConfig.MDGetDWORD(szMDPath, MD_APP_ISOLATED, &dwAppMode);
        if (hr == MD_ERROR_DATA_NOT_FOUND)
        {
            *pdwAppStatus = APPSTATUS_NOTDEFINED;
            hr = NOERROR;
        }
        else if (hr == NOERROR)
        {
            *pdwAppStatus = APPSTATUS_STOPPED;
            hr = NOERROR;
        }
    }
    
    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();
    
    return hr;
}


/*===================================================================
CWamAdmin::AppDeleteRecoverable

Delete an application on a Metabase Path.  If there is no application existed 
before, it is no-op.  It leaves AppIsolated untouched, because, this value is
needed in Recover operation.


Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to deleteRecoverable applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppDeleteRecoverable(LPCWSTR szMDPath, BOOL fRecursive)
{
    return PrivateDeleteApplication(szMDPath, 
                                    fRecursive, 
                                    TRUE,   // Recoverable?
                                    FALSE); // RemoveAppPool?
}

/*===================================================================
CWamAdmin::AppRecover

Recover an application on a Metabase Path.  Based on the AppIsolated value
on the metabase path, this function recreates an application.


Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to Recover applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::AppRecover(LPCWSTR szMDPath, BOOL fRecursive)
{
    HRESULT hr = NOERROR;
    WamRegMetabaseConfig    MDConfig;
    LPWSTR  pwszFormattedPath = NULL;
    
    if (szMDPath == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    // Refer to function comment.
    hr = FormatMetabasePath(szMDPath, &pwszFormattedPath);
    if (FAILED(hr))
    {
        return hr;
    }			
    //
    //	Grab the Lock
    //
    g_WamRegGlobal.AcquireAdmWriteLock();
    
    if (fRecursive)
    {
        DWORD dwSizePrefix;
        WCHAR*	pbBufferTemp = 0;
        DWORD	dwBufferSizeTemp;
        
        dwSizePrefix = wcslen(pwszFormattedPath);
        
        hr = MDConfig.MDGetPropPaths(pwszFormattedPath, MD_APP_ISOLATED, &pbBufferTemp, &dwBufferSizeTemp);
        if (SUCCEEDED(hr) && pbBufferTemp)
        {
            WCHAR *pszString = NULL;
            WCHAR *pszMetabasePath = NULL;
            
            for (pszString = (LPWSTR)pbBufferTemp;
            *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
            pszString += (wcslen(pszString) + 1)) 
            {
                hr = g_WamRegGlobal.ConstructFullPath(pwszFormattedPath,
                    dwSizePrefix,
                    pszString,
                    &pszMetabasePath
                    );
                if (SUCCEEDED(hr))
                {		
                    if (!g_WamRegGlobal.FIsW3SVCRoot(pszMetabasePath))
                    {
                        hr = g_WamRegGlobal.RecoverApp(pszMetabasePath, TRUE);
                        
                        if (FAILED(hr))
                        {
                            DBGPRINTF((DBG_CONTEXT, "Failed to Recover on path %S, hr = %08x\n",
                                pszMetabasePath,
                                hr));
                            break;
                        }
                    }
                    
                    delete [] pszMetabasePath;
                    pszMetabasePath = NULL;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "Failed to Recover, hr = %08x\n",
                        pszString,
                        hr));
                }
            }
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "Recover: GetPropPaths failed hr = %08x\n", hr));
        }	
        
        if (pbBufferTemp != NULL)
        {
            delete [] pbBufferTemp;
            pbBufferTemp = NULL;
        }
    }
    else
    {
       	hr = g_WamRegGlobal.RecoverApp(pwszFormattedPath, TRUE);
        
        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed to Recover on path %S, hr = %08x\n",
                szMDPath,
                hr));
        }
        
    }
    
    if (SUCCEEDED(hr))
    {
        MDConfig.SaveData();
    }
    //
    //	Release the Lock
    //
    g_WamRegGlobal.ReleaseAdmWriteLock();
    
    if (pwszFormattedPath != szMDPath)
    {
        delete [] pwszFormattedPath;
        pwszFormattedPath = NULL;
    }
    
    return hr;
}

/*==================================================================
CWamAdmin::AppCreate2

Create an application on szMDPath.  The dwAppMode indicates whether the 
result application is in-proc or out-proc in a default pool or out proc isolated.  
If the application exists with the desired mode, it will be a no op.  Otherwise,
registration is done.

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
dwAppMode	
Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppCreate2(LPCWSTR szMDPath, DWORD dwAppModeIn)
{

    HRESULT hr = NOERROR;
    DWORD	dwAppMode = 0;
    BOOL	fCreateNewApp = FALSE;
    BOOL	fDeleteOldApp = FALSE;
    WamRegMetabaseConfig    MDConfig;
    LPWSTR  pwszFormattedPath = NULL;
    
    if (szMDPath == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    //
    // See FormatMetabasePath comment
    //
    hr = FormatMetabasePath(szMDPath, &pwszFormattedPath);
    if (FAILED(hr))
    {
        return hr;
    }
    
    if (!g_WamRegGlobal.FAppPathAllowConfig(pwszFormattedPath))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();
    
    hr = MDConfig.MDGetDWORD(pwszFormattedPath, MD_APP_ISOLATED, &dwAppMode);
    if (hr == MD_ERROR_DATA_NOT_FOUND)
    {
        fCreateNewApp = TRUE;
        hr = NOERROR;
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    {
        hr = MDConfig.MDCreatePath(NULL, pwszFormattedPath);
        fCreateNewApp = TRUE;
        
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed to create metabase path %S, hr = %08x",
                szMDPath,
                hr));
        }	
    }
    else if (SUCCEEDED(hr))
    {
        //
        // if the input application mode is not the same as defined 
        // in the metabase, we need to delete the old application as 
        // defined in the metabase and create a new application as 
        // specified by dwAppModeIn, the in parameter.
        //
        if (dwAppMode != dwAppModeIn)
        {
            fDeleteOldApp = TRUE;
            fCreateNewApp = TRUE;
        }
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT, "Failed to get DWORD on metabase path %S, hr = %08x",
            szMDPath,
            hr));
    }				
    
    if (SUCCEEDED(hr))
    {
        if (fDeleteOldApp)
        {
            DBG_ASSERT(fCreateNewApp);
            hr = g_WamRegGlobal.DeleteApp(pwszFormattedPath, FALSE, FALSE); 
            if (FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failed to delete old application on path %S, hr = 08x\n",
                    szMDPath,
                    hr));
            }
        }
        
        if (fCreateNewApp)
        {		
            if (dwAppModeIn == eAppRunOutProcInDefaultPool)
            {
                hr = g_WamRegGlobal.CreatePooledApp(pwszFormattedPath, FALSE);				
            }
            else if (dwAppModeIn == eAppRunInProc)
            {
                hr = g_WamRegGlobal.CreatePooledApp(pwszFormattedPath, TRUE);				
            }
            else
            {
                hr = g_WamRegGlobal.CreateOutProcApp(pwszFormattedPath);
            }
            
            if (FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failed to create new application on path %S, hr = 08x\n",
                    szMDPath,
                    hr));
            }
        }
    }
    
    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();
    
    //
    // if pwszFormattedPath is not same as szMDPath
    // then FormatMetabasePath() did a memory allocation.
    //
    if (pwszFormattedPath != szMDPath)
    {
        delete [] pwszFormattedPath;
        pwszFormattedPath = NULL;
    }
    
    return hr;
}

//===============================================================================
//	Wam Admin Replication implementation
//
//===============================================================================

/*===================================================================
CWamAdmin::GetSignature

Get signature of application configurations.  A signature in WAMREG is a checksum from
all the metabase paths that define application.

Parameter:


Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::GetSignature
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
/* [out */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
)
{
	HRESULT hr = NOERROR;
	WCHAR	*pbBufferTemp = NULL;
	DWORD	dwBufferSizeTemp = 0;
	DWORD	dwSignature = 0;
	DWORD	dwRequiredSize = 0;
	WamRegMetabaseConfig    MDConfig;
	//
	//	Grab the Lock
	//
	g_WamRegGlobal.AcquireAdmWriteLock();

	hr = MDConfig.MDGetPropPaths(WamRegGlobal::g_szMDW3SVCRoot, MD_APP_ISOLATED, &pbBufferTemp, &dwBufferSizeTemp);
	if (SUCCEEDED(hr))
		{
		WCHAR *pszString = NULL;
		WCHAR *pszMetabasePath = NULL;
        DWORD dwSignatureofPath = 0;

        for (pszString = (LPWSTR)pbBufferTemp;
			*pszString != (WCHAR)'\0' && SUCCEEDED(hr);
            pszString += (wcslen(pszString) + 1)) 
        	{
            dwRequiredSize += sizeof(DWORD);

            if (dwRequiredSize <= dwBufferSize)
                {               
				hr = g_WamRegGlobal.ConstructFullPath(WamRegGlobal::g_szMDW3SVCRoot,
										WamRegGlobal::g_cchMDW3SVCRoot,
										pszString,
										&pszMetabasePath
										);
				if (SUCCEEDED(hr))
					{	
					dwSignatureofPath = 0;
		            hr = MDConfig.GetSignatureOnPath(pszMetabasePath, &dwSignatureofPath);	            
		            if (SUCCEEDED(hr))
		            	{
		            	// Add Signature
		            	*(DWORD*)pbBuffer = dwSignatureofPath;
		            	pbBuffer += sizeof(DWORD);
		            	
						DBGPRINTF((DBG_CONTEXT, "Get Signature on path %S, signature = %08x\n",
							pszMetabasePath,
							dwSignatureofPath));
		            	}
		            else
		            	{
		            	DBGPRINTF((DBG_CONTEXT, "Failed to get signature on path %S, hr = %08x\n",
		            		pszString,
		            		hr));
						DBG_ASSERT(hr);
		            	}
		            	
					delete [] pszMetabasePath;
					pszMetabasePath = NULL;
		            }
		        }
            }
       	
		if (dwRequiredSize > dwBufferSize)
			{
			*pdwMDRequiredBufferSize = dwRequiredSize;
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			}
		}
	else
		{
		DBGPRINTF((DBG_CONTEXT, "GetSignature: GetPropPaths failed hr = %08x\n", hr));
		}

	if (SUCCEEDED(hr))
		{
		*pdwMDRequiredBufferSize = dwRequiredSize;
		}

	if (pbBufferTemp != NULL)
		{
		delete [] pbBufferTemp;
		}
	//
	//	Release the Lock
	//
	g_WamRegGlobal.ReleaseAdmWriteLock();

	return hr;
}


/*===================================================================
CWamAdmin::Propagate

Unused in WAMREG. NOOP.

Parameter:


Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::Propagate
( 
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer
)
{
	return NOERROR;
}

/*===================================================================
CWamAdmin::Propagate2

This function is called after IIS replication, and triggers MTS to start
replication pakcages, it calls IISComputerToComputer.

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::Propagate2
( 
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer,
/* [in] */ DWORD dwSignatureMismatch
)
{
    //
    // IISComputerToComputer can not be called from inetinfo.exe, because IISComputerToComputer will
    // make cross-machine RPC call, and inetinfo is set to Local system, therefore, IISComputerToComputer
    // will fail at the authentication level.
    // move IISComputerToComputer to iissync.exe. Where iissync.exe has some user account & password.
    //
	return NOERROR;

}

/*===================================================================
CWamAdmin::Serialize

This function packs all neccessary infomation (path + WAMCLSID) for a target
machine to prepare replication(DeSerialize).

The only applications that we really care about are isolated applications.
We need the path + WAMCLSID + APPID.

CODEWORK

See NT Bug 378371

Replication of IIS COM+ applications has been broken for a long time
but the all of the fixes I considered have some serious drawbacks.

1. Don't use comrepl to move the IIS applications. Serialize/Deserialize
all the data needed to create the isolated applications and then delete
and recreate them on the target. The problem here is that the packages
may in fact be modified by the user and these modifications should be
preserved.

2. Use comrepl as it is and replicate the IWAM_* account. This seems like
a bad idea. The IWAM_ account should ideally never exist on multiple 
machines. Another issue is handling the password and account privileges.

3. Use a modified comrepl (or let comrepl fail and leave the package identity
as "interactive user"). Then do a fixup of the activation identity.
This doesn't work, because the Propogate/Propogate2 protocol is
essentially useless. Changing this protocol on the next release
is absolutely something that should be considered, although AppCenter
probably makes it a moot point.

The current implementation is option 1.

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::Serialize
( 
/* [in] */ DWORD dwBufferSize,
/* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
/* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
)
{
	HRESULT hr = NOERROR;
	WCHAR	*pbBufferTemp = NULL;
	DWORD	dwBufSizePath = 0;
	DWORD	dwSizeForReturn = sizeof(DWORD);
	WamRegMetabaseConfig    MDConfig;

	//
	//	Grab the Lock
	//
	g_WamRegGlobal.AcquireAdmWriteLock();

	hr = MDConfig.MDGetPropPaths( WamRegGlobal::g_szMDW3SVCRoot, 
                                  MD_APP_WAM_CLSID, 
                                  &pbBufferTemp, 
                                  &dwBufSizePath
                                  );
	if (SUCCEEDED(hr))
    {
        WCHAR   *pszString = NULL;
        WCHAR   *pszMetabasePath = NULL;
        WCHAR   *pszAppName = NULL;
        WCHAR   szWAMCLSID[uSizeCLSID];
        WCHAR   szAppId[uSizeCLSID];
        DWORD   dwSizeofRecord;
        DWORD   cSizeMetabasePath = 0;
        DWORD   cSizeAppName = 0;
        DWORD   dwAppIsolated;
        
        
		for( pszString = (LPWSTR)pbBufferTemp;
			 *pszString != (WCHAR)'\0';
             pszString += (wcslen(pszString) + 1)) 
        {			
            // Clean up allocations
            if( pszMetabasePath != NULL )
            {
                delete [] pszMetabasePath;
                pszMetabasePath = NULL;
            }

            if( pszAppName != NULL )
            {
                delete [] pszAppName;
                pszAppName = NULL;
            }
            
            hr = g_WamRegGlobal.ConstructFullPath(
                        WamRegGlobal::g_szMDW3SVCRoot,
                        WamRegGlobal::g_cchMDW3SVCRoot,
                        pszString,
                        &pszMetabasePath
                        );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT,
                           "ConstructFullPath failed for base (%S) "
                           "partial (%S) hr=%08x\n",
                           WamRegGlobal::g_szMDW3SVCRoot,
                           pszString,
                           hr
                           ));
                break;
            }

            if( g_WamRegGlobal.FIsW3SVCRoot( pszMetabasePath ) )
            {
                // Don't consider the root application
                continue;
            }

            hr = MDConfig.MDGetDWORD( pszMetabasePath,
                                      MD_APP_ISOLATED,
                                      &dwAppIsolated
                                      );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT,
                           "Failed to get MD_APP_ISOLATED, hr=%08x\n",
                           hr
                           ));
                break;
            }
            
            if( dwAppIsolated != eAppRunOutProcIsolated )
            {
                // Don't consider non-isolated applications
                continue;
            }
			
	        hr = MDConfig.MDGetIDs( pszMetabasePath, 
                                    szWAMCLSID, 
                                    szAppId,
                                    dwAppIsolated
                                    );
            if( FAILED(hr) )
            {
				DBGERROR(( DBG_CONTEXT, 
                           "Failed to get IDs for %S, hr = %08x\n",
					       pszMetabasePath,
					       hr
                           ));
				break;
            }

            hr = MDConfig.MDGetAppName( pszMetabasePath,
                                        &pszAppName
                                        );
            if( FAILED(hr) )
            {
				DBGERROR(( DBG_CONTEXT, 
                           "Failed to get AppName for %S, hr = %08x\n",
					       pszMetabasePath,
					       hr
                           ));
				break;
            }

            cSizeMetabasePath = wcslen(pszMetabasePath) + 1;
            cSizeAppName = wcslen(pszAppName) + 1;
            dwSizeofRecord = sizeof(DWORD) + 
                             ((2 * uSizeCLSID) * sizeof(WCHAR)) +
                             (cSizeMetabasePath * sizeof(WCHAR)) +
                             (cSizeAppName * sizeof(WCHAR));

            dwSizeForReturn += dwSizeofRecord;

            if (dwSizeForReturn <= dwBufferSize)
            {
                // Size
                *(DWORD *)pbBuffer = dwSizeofRecord;
                pbBuffer += sizeof(DWORD);
                
                // WAMCLSID
                memcpy( pbBuffer, szWAMCLSID, sizeof(WCHAR) * uSizeCLSID );
                pbBuffer += sizeof(WCHAR) * uSizeCLSID;
                
                // APPID
                memcpy( pbBuffer, szAppId, sizeof(WCHAR) * uSizeCLSID );
                pbBuffer += sizeof(WCHAR) * uSizeCLSID;

                // PATH
                memcpy( pbBuffer, pszMetabasePath, cSizeMetabasePath * sizeof(WCHAR) );
                pbBuffer += cSizeMetabasePath * sizeof(WCHAR);

                // APPNAME
                memcpy( pbBuffer, pszAppName, cSizeAppName * sizeof(WCHAR) );
                pbBuffer += cSizeAppName * sizeof(WCHAR);
            }
        }

        if (SUCCEEDED(hr))
        {
            if (dwSizeForReturn <= dwBufferSize)
            {
                *(DWORD*)pbBuffer = 0x0;    // Ending Signature
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            *pdwMDRequiredBufferSize = dwSizeForReturn;
		}

        // Clean up allocations
        if( pszMetabasePath != NULL )
        {
            delete [] pszMetabasePath;
            pszMetabasePath = NULL;
        }

        if( pszAppName != NULL )
        {
            delete [] pszAppName;
            pszAppName = NULL;
        }

    }
	else
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Serialize: GetPropPaths failed hr = %08x\n", 
                   hr
                   ));
    }

	//
	//	Release the Lock
	//
	g_WamRegGlobal.ReleaseAdmWriteLock();

	if (pbBufferTemp)
    {	
        delete [] pbBufferTemp;
    }
		
	return hr;
}


/*===================================================================
CWamAdmin::DeSerialize

This function unpacks all neccessary infomation (path + WAMCLSID) on a target
machine to prepare replication(DeSerialize).

The only applications that we really care about with replication are
isolated apps. This routine removes the existing out of process apps
and then recreates the applications that are sent over in pbBuffer.

CODEWORK - See comments in Serialize

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::DeSerialize
( 
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pbBuffer
)
{
	DWORD dwBufferSizeTemp= 0;
	WCHAR* pbBufferTemp = NULL;
	HRESULT hr = NOERROR;
    WamRegMetabaseConfig    MDConfig;

	g_WamRegGlobal.AcquireAdmWriteLock();

	hr = MDConfig.MDGetPropPaths( WamRegGlobal::g_szMDW3SVCRoot, 
                                  MD_APP_WAM_CLSID, 
                                  &pbBufferTemp, 
                                  &dwBufferSizeTemp
                                  );
	if (SUCCEEDED(hr))
    {
        //
        // Remove all the existing isolated applications.
        //

        WCHAR * pszString = NULL;
		WCHAR * pszMetabasePath = NULL;
        DWORD   dwAppIsolated;

		for (   pszString = (LPWSTR)pbBufferTemp;
				*pszString != (WCHAR)'\0';
                pszString += (wcslen(pszString) + 1))
        {
            if( pszMetabasePath != NULL )
            {
                delete [] pszMetabasePath;
                pszMetabasePath = NULL;
            }

            hr = g_WamRegGlobal.ConstructFullPath(
                    WamRegGlobal::g_szMDW3SVCRoot,
					WamRegGlobal::g_cchMDW3SVCRoot,
					pszString,
					&pszMetabasePath
					);

            if( FAILED(hr) )
            {
                // This failure is fatal
                DBGERROR(( DBG_CONTEXT,
                           "ConstructFullPath failed for base (%S) "
                           "partial (%S) hr=%08x\n",
                           WamRegGlobal::g_szMDW3SVCRoot,
                           pszString,
                           hr
                           ));
                break;
            }

			hr = MDConfig.MDGetDWORD( pszMetabasePath, 
                                      MD_APP_ISOLATED, 
                                      &dwAppIsolated 
                                      );
            if( FAILED(hr) )
            {
                DBGWARN(( DBG_CONTEXT,
                          "Failed to get MD_APP_ISOLATED at (%S) hr=%08x\n",
                          pszMetabasePath,
                          hr
                          ));
                
                hr = NOERROR;
                continue;
            }

            if( dwAppIsolated == eAppRunOutProcIsolated )
            {
			    hr = g_WamRegGlobal.DeleteApp( pszMetabasePath, FALSE, FALSE );
			    if (FAILED(hr))
                {
				    DBGWARN(( DBG_CONTEXT, 
                              "Unable to delete app at %S, hr = %08x\n",
					          pszMetabasePath,
                              hr
                              ));

                    hr = NOERROR;
                    continue;
                }
            }
        }
        if( pszMetabasePath != NULL )
        {
            delete [] pszMetabasePath;
            pszMetabasePath = NULL;
        }
    }

    //
    // Now go through the serialized data and create the
    // necessary new applications.
    //
    
    BYTE  * pbTemp = pbBuffer;
    DWORD   cTotalBytes = 0;
    DWORD   cRecBytes = 0;
    WCHAR * szWAMCLSID = NULL;
    WCHAR * szPath = NULL;
    WCHAR * szAppId = NULL;
    WCHAR * szAppName = NULL;

    DBGPRINTF(( DBG_CONTEXT, 
                "DeSerialize: buffer size %d, \n",
				dwBufferSize
                ));

    while( *((DWORD*)pbTemp) != 0x0 )
    {
		// SIZE
        cRecBytes = *((DWORD*)pbTemp);
		pbTemp += sizeof(DWORD);
		
		// CLSID
        szWAMCLSID = (WCHAR *)pbTemp;
		pbTemp += uSizeCLSID * sizeof(WCHAR);

        // APPID
        szAppId = (WCHAR *)pbTemp;
        pbTemp += uSizeCLSID * sizeof(WCHAR);
		
		// PATH
        szPath = (WCHAR *)pbTemp;
		pbTemp += (wcslen(szPath) + 1) * sizeof(WCHAR);

        // APPNAME
        szAppName = (WCHAR *)pbTemp;
        pbTemp += (wcslen(szAppName) + 1) * sizeof(WCHAR);

		// TODO - This should really be output based on a flag
        DBGPRINTF(( DBG_CONTEXT, 
                    "Deserialize path = %S, WAMCLSID = %S.\n",
					szPath,
					szWAMCLSID
                    ));

		// Should never serialize the w3svc root
        DBG_ASSERT( !g_WamRegGlobal.FIsW3SVCRoot(szPath) );


        hr = g_WamRegGlobal.CreateOutProcAppReplica( szPath,
                                                     szAppName,
                                                     szWAMCLSID,
                                                     szAppId
                                                     );
        
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT,
                       "Failed to create COM application. Path(%S) "
                       "Clsid(%S) AppId(%S). hr=%08x\n",
                       szPath,
                       szWAMCLSID,
                       szAppId,
                       hr
                       ));
            
            // ??? Should we be continuing here ???
            // Don't report an error if we are continuing
            hr = NOERROR;
        }
    }

	if (pbBufferTemp)
    {
        delete [] pbBufferTemp;
    }
		
	//
	//	Release the Lock
	//
	g_WamRegGlobal.ReleaseAdmWriteLock();

	return hr;
}

/*===================================================================
CWamAdmin::FormatMetabasePath

This function format the input metabase path.  If the metabase path has an
ending '/', this function will allocate a memory block and make a new string
without the ending '/'.  This function will return a pointer to newly allocated
memory block.  Otherwise, the function will return the pointer to
the input metabase path.

Parameter:
pwszMetabasePathIn   input metabase path
ppwszMetabasePathOut pointer to the resulting pointer that contains the formatted
                     metabase path.

Return:	HRESULT
NOERROR	if succeeds

NOTE: if ppwszMetabasePathOut == pwszMetabasePathIn, then no memory allocation.
      Otherwise, there is a memory allocation happened, and caller needs to free the
      memory block passed out in ppwszMetabasePathOut.
===================================================================*/
STDMETHODIMP CWamAdmin::FormatMetabasePath
(
/* [in] */ LPCWSTR pwszMetabasePathIn,
/* [out] */ LPWSTR *ppwszMetabasePathOut
)
{
    HRESULT hr = NOERROR;
    LPWSTR  pResult = NULL;

    DBG_ASSERT(pwszMetabasePathIn);
    DBG_ASSERT(ppwszMetabasePathOut);

    LONG    cch = wcslen(pwszMetabasePathIn);

    if (pwszMetabasePathIn[cch-1] == L'\\' ||
        pwszMetabasePathIn[cch-1] == L'/')
        {
        //
        //  Need to start up with a new string, can not do it with old string.
        //
        pResult = new WCHAR[cch];
        if (pResult != NULL)
            {
            wcsncpy(pResult, pwszMetabasePathIn, cch);
            pResult[cch-1] = L'\0';
            }
        else
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT, "FormatMetabasePath, failed to allocate memory. hr = %08x\n",
                hr));
            }

        if (pResult != NULL)
            {
            *ppwszMetabasePathOut = pResult;
            }
        }
    else
        {
        *ppwszMetabasePathOut = (LPWSTR)pwszMetabasePathIn;
        }

    return hr;
}

//===============================================================================
//
//	IIISApplicationAdmin implementation
//
//===============================================================================

#ifdef _IIS_6_0

/*===================================================================
DoesAppPoolExist

Determine whether the AppPool passed exists

Parameter:
szAppPoolId     a AppPoolId
pfRet           where to place whether or not the appPool exists

Return:	HRESULT
===================================================================*/
HRESULT           
DoesAppPoolExist
(
 LPCWSTR szAppPoolId,
 BOOL * pfRet
)
{
    DBG_ASSERT(pfRet);
    WamRegMetabaseConfig    MDConfig;

    HRESULT hr = E_FAIL;
    STACK_STRU(szPoolBuf, 64);
    
    hr = szPoolBuf.Append(APPPOOLPATH);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = szPoolBuf.Append(szAppPoolId);
    if (FAILED(hr))
    {
        goto done;
    }

    (*pfRet) = MDConfig.MDDoesPathExist(NULL, szPoolBuf.QueryStr());
    
    hr = S_OK;
done:
    return hr;
}

/*===================================================================
CWamAdmin::CreateApplication

Create an application on szMDPath, and add it to szAppPoolId AppPool.
Optionally create szAppPoolId

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
dwAppMode       mode to create application in
szAppPoolId     AppPool to setup app in.
fCreatePool     Whether or not to create the pool

Return:	HRESULT
===================================================================*/
STDMETHODIMP
CWamAdmin::CreateApplication
(
 LPCWSTR szMDPath,
 DWORD dwAppMode,
 LPCWSTR szAppPoolId,
 BOOL fCreatePool
)
{
    HRESULT                 hr = S_OK;
    WamRegMetabaseConfig    MDConfig;
    LPWSTR                  pwszFormattedPath = NULL;
    
    if (NULL == szMDPath)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto done;
    }
    
    //
    // See FormatMetabasePath comment
    //
    hr = FormatMetabasePath(szMDPath, &pwszFormattedPath);
    if (FAILED(hr))
    {
        goto done;
    }

    // BUGBUG: Do We need locking around all of this?  Why is locking present in other places?

    hr = AppCreate2(pwszFormattedPath, dwAppMode);
    if (FAILED(hr))
    {
        goto done;
    }

    if (FALSE == fCreatePool && NULL == szAppPoolId)
    {
        //
        // We weren't told to create an application pool
        // and NULL was passed as the application pool,
        // therefore do nothing wil the application pool
        //
        hr = S_OK;
        goto done;
    }

    if (TRUE == fCreatePool)
    {
        //
        // create the application pool that we were passed
        //

        hr = CreateApplicationPool(szAppPoolId);
        if (FAILED(hr) && 
            HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
        {
            goto done;
        }
    }
    else
    {
        //
        // We weren't told to create the application pool,
        // but one was passed in.  Verify that it exists.
        //
        DBG_ASSERT(NULL != szAppPoolId);

        BOOL fRet;

        hr = DoesAppPoolExist(szAppPoolId, &fRet);
        if (FAILED(hr))
        {
            goto done;
        }

        if (FALSE == fRet)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            goto done;
        }
    }

    hr = MDConfig.MDSetStringProperty(NULL, 
                                      pwszFormattedPath, 
                                      MD_APP_APPPOOL_ID, 
                                      szAppPoolId,
                                      IIS_MD_UT_SERVER);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    //
    // if pwszFormattedPath is not same as szMDPath
    // then FormatMetabasePath() did a memory allocation.
    //
    if (pwszFormattedPath != szMDPath)
    {
        delete [] pwszFormattedPath;
        pwszFormattedPath = NULL;
    }
    return hr;
}

/*===================================================================
CWamAdmin::DeleteApplication

Delete an application on a Metabase Path.  

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to deleteRecoverable applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
===================================================================*/
STDMETHODIMP
CWamAdmin::DeleteApplication
(
 LPCWSTR szMDPath,
 BOOL fRecursive
)
{
    return PrivateDeleteApplication(szMDPath, 
                                    fRecursive, 
                                    FALSE, // Recoverable?
                                    TRUE); // RemoveAppPool?
}

/*===================================================================
CWamAdmin::CreateApplicationPool

Delete an application on a Metabase Path.  If there is no application existed 
before, it is no-op.  It leaves AppIsolated untouched, because, this value is
needed in Recover operation.


Parameter:
szAppPool       Application Pool to create

Return:	HRESULT
===================================================================*/
STDMETHODIMP
CWamAdmin::CreateApplicationPool
(
 LPCWSTR szAppPool
)
{
    HRESULT                 hr = S_OK;
    WamRegMetabaseConfig    MDConfig;

    STACK_STRU(szBuf, 64);

    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();

    if (NULL == szAppPool)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // concatenate the path into a buffer
    hr = szBuf.Append(APPPOOLPATH);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = szBuf.Append(szAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = MDConfig.MDCreatePath(NULL, szBuf.QueryStr());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = MDConfig.MDSetKeyType(NULL, szBuf.QueryStr(), L"IIsApplicationPool");
    if (FAILED(hr))
    {
        goto done;
    }

done:
    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();

    return hr;
}

/*===================================================================
CWamAdmin::DeleteApplicationPool

Delete an application pool.  First check to see if ApplicationPool is empty.
If not, return ERROR_NOT_EMPTY.  Otherwise, remove apppool.


Parameter:
szAppPool   Application Pool to remove

Return:	HRESULT
===================================================================*/
STDMETHODIMP
CWamAdmin::DeleteApplicationPool
(
 LPCWSTR szAppPool
)
{
    HRESULT     hr = S_OK;
    UINT        cchBstr = 0;
    BOOL        fRet = FALSE;
    BSTR        bstr = NULL;

    WamRegMetabaseConfig    MDConfig;
    
    // BUGBUG: need locking around this?

    if (NULL == szAppPool)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = DoesAppPoolExist(szAppPool, &fRet);
    if (FAILED(hr))
    {
        goto done;
    }
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto done;
    }

    hr = EnumerateApplicationsInPool(szAppPool, &bstr);
    if (FAILED(hr))
    {
        goto done;
    }

    cchBstr = SysStringLen(bstr);

    // were there two terminating NULLs to be written into out buffer?
    if (!(cchBstr >= 2 && '\0' == bstr[0] && '\0' == bstr[1]))  
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_EMPTY);
        goto done;
    }

    hr = MDConfig.MDDeleteKey(NULL, APPPOOLPATH, szAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    if (bstr)
    {
        SysFreeString(bstr);
    }
    return hr;
}


/*===================================================================
DoesBeginWithLMW3SVCNRoot

Determine whether the string passed in starts with
/lm/w3svc/NNNN/root
where NNNN is greater than 0.


Parameter:
pszApp      an metabase application path
pdwCharsAfter   [OPTIONAL] - storage for the number of characters following /root

Return:	BOOL
===================================================================*/
const WCHAR MB_W3SVC[] = L"/lm/w3svc/";
const int LEN_MB_W3SVC = (sizeof(MB_W3SVC) / sizeof(WCHAR)) - 1;
const WCHAR MB_W3SVC_1_ROOT[] = L"/LM/W3SVC/1/ROOT";
const int LEN_MB_W3SVC_1_ROOT = (sizeof(MB_W3SVC_1_ROOT) / sizeof(WCHAR)) - 1;
const WCHAR MB_ROOT[] = L"/Root";
const int LEN_MB_ROOT = (sizeof(MB_ROOT) / sizeof(WCHAR)) - 1;

BOOL
DoesBeginWithLMW3SVCNRoot
(
 LPCWSTR pszApp,
 DWORD * pdwCharsAfter = NULL
)
{
    DBG_ASSERT(pszApp);

    BOOL fRet = FALSE;
    WCHAR pBuf[256] = {0};
    int iSite;

    // must have at least this many characters to have a chance
    if (wcslen(pszApp) < LEN_MB_W3SVC_1_ROOT)
    {
        goto done;
    }

    // Applications must have \lm\w3svc\ at the front
    if (0 != _wcsnicmp(MB_W3SVC, pszApp, LEN_MB_W3SVC))
    {
        goto done;
    }

    // Advance the pointer by enough characters
    pszApp += LEN_MB_W3SVC;

    // _wtoi returns as many characters as possible in a string before hitting a non-number or NULL
    // if there is no number, the return is 0.  
    iSite = _wtoi(pszApp);

    // Applications must then have a number that is >=1
    if (0 == iSite)
    {
        goto done;
    }
    
    // get the count of numbers read from the string
    _itow(iSite, pBuf, 10);

    // advance the pointer by enough characters.
    pszApp += wcslen(pBuf);

    // Applications must them have "/Root" 
    if (0 != _wcsnicmp(pszApp, MB_ROOT, LEN_MB_ROOT))
    {
        goto done;
    }

    // if caller wants a count of characters following /Root
    if (pdwCharsAfter)
    {
        // advance the pointer by enough characters
        pszApp += LEN_MB_ROOT;

        // get the remaining length
        *pdwCharsAfter = wcslen(pszApp);
    }

    fRet = TRUE;
done:
    return fRet;
}


/*===================================================================
IsRootApplication

Determine whether the string passed in is of the form:
/lm/w3svc/NNNN/root/
where NNNN is greater than 0.

And no additional characters following

Parameter:
pszApp      an metabase application path

Return:	BOOL
===================================================================*/
BOOL
IsRootApplication
(
 LPCWSTR pszApp
)
{
    DWORD dwCharsAfter = 0;
    
    // Root applications must begin with /lm/w3svc/nnn/root
    if (!DoesBeginWithLMW3SVCNRoot(pszApp, &dwCharsAfter))
    {
        return FALSE;
    }
    
    // we expect at most a trailing '/' after /lm/w3svc/nnn/root.
    // If there is more, this was not a root application
    if(1 < dwCharsAfter)
    {
        return FALSE;
    }

    return TRUE;
}

/*===================================================================
IsApplication

Determine whether the string passed in starts with
/lm/w3svc/NNNN/root
where NNNN is greater than 0.

With any additional characters following

Parameter:
pszApp      an metabase application path

Return:	BOOL
===================================================================*/
BOOL
IsApplication
(
 LPCWSTR pszApp
)
{
    return DoesBeginWithLMW3SVCNRoot(pszApp);
}

/*===================================================================
IsAppInAppPool

Determine whether the App is in Pool

Parameter:
pszApp      an metabase application path
pszPool     an applicationPool ID

Return:	BOOL
===================================================================*/
BOOL
IsAppInAppPool
(
 LPCWSTR pszApp,
 LPCWSTR pszPool
)
{
    DBG_ASSERT(pszApp);
    DBG_ASSERT(pszPool);
    HRESULT hr = E_FAIL;
    BOOL fRet = FALSE;
    LPWSTR pBuf = NULL;
    WamRegMetabaseConfig    MDConfig;

    hr = MDConfig.MDGetStringAttribute(pszApp, MD_APP_APPPOOL_ID, &pBuf); 
    if (FAILED(hr) || NULL == pBuf)
    {
        goto done;
    }

    if (0 == _wcsicmp(pBuf, pszPool))
    {
        fRet = TRUE;
    }

done:
    delete [] pBuf;
    return fRet;
}

/*===================================================================
CWamAdmin::EnumerateApplicationsInPool

Determine what applications are setup to point to the given pool.

Parameter:
szPool      Application Pool enumerate
pbstrBuffer Where to store the pointer to allocated memory for application paths

Return:	HRESULT
  S_OK if buffer filled with a MULTISZ - if empty, double NULL at beginning
===================================================================*/
STDMETHODIMP
CWamAdmin::EnumerateApplicationsInPool
(
 LPCWSTR szPool,
 BSTR*   pbstrBuffer
)
{
    HRESULT                 hr = E_FAIL;
    WamRegMetabaseConfig    MDConfig;
    MULTISZ                 mszApplicationsInPool;

    WCHAR *                 pBuffer = NULL;
    UINT                    cchMulti = 0;
    DWORD                   dwBufferSize = 0;

    if (NULL == szPool ||
        NULL == pbstrBuffer
       )
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pbstrBuffer = NULL;

    // First get all of the root applications
    {
        hr = MDConfig.MDGetAllSiteRoots(&pBuffer);
        if (FAILED(hr))
        {
            goto done;
        }

        const WCHAR * pTestBuf = pBuffer;

        while(pTestBuf && pTestBuf[0])
        {
            DBG_ASSERT(IsRootApplication(pTestBuf));
            if ( IsAppInAppPool(pTestBuf, szPool) )
            {
                if (FALSE == mszApplicationsInPool.Append(pTestBuf))
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }
            }

            // move pTestBuf beyond end of this string, including NULL terminator.
            pTestBuf += wcslen(pTestBuf) + 1;
        }

        delete [] pBuffer;
        pBuffer = NULL;
    }

    // now get any other applications that have APPISOLATED set
    {
        hr = MDConfig.MDGetPropPaths(NULL,
                                     MD_APP_ISOLATED,
                                     &pBuffer,
                                     &dwBufferSize
                                    );
        if (FAILED(hr))
        {
            goto done;
        }

        {
            const WCHAR * pTestBuf = pBuffer;
            
            while (pTestBuf && pTestBuf[0])
            {
                // root applications have already been added
                // the path needs to be an application
                // and the application needs to be in the app pool
                if ( !IsRootApplication(pTestBuf) &&
                     IsApplication(pTestBuf) && 
                     IsAppInAppPool(pTestBuf, szPool) )
                {
                    if (FALSE == mszApplicationsInPool.Append(pTestBuf))
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }
                }
                
                // move pTestBuf beyond end of this string, including NULL terminator.
                pTestBuf += wcslen(pTestBuf) + 1;
            }
        }
    }

    // have the data in a MULTISZ - move it to the outgoing BSTR
    cchMulti = mszApplicationsInPool.QueryCCH();
    *pbstrBuffer = SysAllocStringLen(NULL, cchMulti);
    if (NULL == *pbstrBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    dwBufferSize = cchMulti;
    mszApplicationsInPool.CopyToBuffer(*pbstrBuffer, &dwBufferSize);
    
    hr = S_OK;
done:
    delete [] pBuffer;
    pBuffer = NULL;

    return hr;
}

/*===================================================================
QueryW3SVCStatus

Using the ServiceControlManager, determine the current state of W3SVC

pfRunning   return bool value - TRUE if running, otherwise FALSE

Return:	HRESULT
S_OK if able to read status.  HRESULT_FROM_WIN32 error otherwise
===================================================================*/
HRESULT
QueryW3SVCStatus
(
 BOOL * pfRunning
)
{
    DBG_ASSERT(pfRunning);
    *pfRunning = FALSE;

    HRESULT         hr = E_FAIL;
    BOOL            fRet = FALSE;

    SC_HANDLE       hSCM = 0;
    SC_HANDLE       hService = 0;
    SERVICE_STATUS  ssStatus;
    ZeroMemory(&ssStatus, sizeof(ssStatus));

    // first, get the service control manager
    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (NULL == hSCM)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // now get the w3svc service
    hService = OpenService(hSCM, "W3SVC", SERVICE_QUERY_STATUS);
    if (NULL == hService)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // now ask for the status
    fRet = QueryServiceStatus(hService, &ssStatus);
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if (SERVICE_RUNNING == ssStatus.dwCurrentState)
    {
        *pfRunning = TRUE;
    }

    hr = S_OK;
done:
    if (0 != hService)
    {
        CloseServiceHandle(hService);
    }
    if (0 != hSCM)
    {
        CloseServiceHandle(hSCM);
    }

    return hr;
}

/*===================================================================
GetWASIfRunning

Get a pointer to WAS iff w3svc is already running.

ppiW3Control    where to store the addref'ed pointer if it can be gotten

Return:	HRESULT
S_OK if pointer retrieved
HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) if W3SVC is not up
+other error codes
===================================================================*/
HRESULT
GetWASIfRunning
(
 IW3Control ** ppiW3Control
)
{
    DBG_ASSERT(ppiW3Control);
    *ppiW3Control = NULL;

    HRESULT     hr = E_FAIL;
    BOOL        fRunning = FALSE;

    hr = QueryW3SVCStatus(&fRunning);
    if (FAILED(hr))
    {
        goto done;
    }

    if (FALSE == fRunning)
    {
        hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE);
        goto done;
    }
    
    hr = CoCreateInstance(CLSID_W3Control, 
                          NULL, 
                          CLSCTX_ALL, 
                          IID_IW3Control, 
                          reinterpret_cast<void**>(ppiW3Control));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

/*===================================================================
ValidateWriteAccessToMetabaseKey

Determine whether the caller has write access to the given metabase key

pPath - path to check write access on

Return:	HRESULT
S_OK if access allowed
otherwise failure
===================================================================*/
HRESULT
ValidateWriteAccessToMetabaseKey(LPCWSTR pPath)
{
    HRESULT hr = S_OK;
    IMSAdminBase * pIMSAdminBase = NULL;
    METADATA_HANDLE hMB = NULL;
    METADATA_RECORD mdr;
    DWORD dwTemp = 0x1234;

    hr = CoImpersonateClient();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance( 
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                ( VOID * * ) ( &pIMSAdminBase )     // returned interface
                );
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                    pPath,
                                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                    30000, // 30 seconds max
                                    &hMB );
    if (FAILED(hr))
    {
        goto done;
    }

    MD_SET_DATA_RECORD(&mdr, 
                       MD_ISM_ACCESS_CHECK,    // same identifier UI uses for this operation
                       METADATA_NO_ATTRIBUTES, 
                       IIS_MD_UT_FILE,
                       DWORD_METADATA,  
                       sizeof(DWORD), 
                       &dwTemp);

    hr = pIMSAdminBase->SetData(hMB,
                                NULL,
                                &mdr
                                );
    if (FAILED(hr))
    {
        goto done;
    }

    //
    // don't leave goo hanging around
    //
    hr = pIMSAdminBase->DeleteData(hMB,
                                   NULL,
                                   MD_ISM_ACCESS_CHECK,
                                   DWORD_METADATA
                                   );
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoRevertToSelf();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    if ( hMB )
    {
        DBG_ASSERT( NULL != pIMSAdminBase );
        DBG_REQUIRE( pIMSAdminBase->CloseKey( hMB ) == S_OK );
        hMB = NULL;
    }

    if (pIMSAdminBase)
    {
       pIMSAdminBase->Release();
       pIMSAdminBase = NULL;
    }

    return hr;
}


/*===================================================================
ValidateAccessToAppPool

Determine whether the caller has write access to the given apppool

szAppPool - AppPool to check access on

Return:	HRESULT
S_OK if access allowed
otherwise failure
===================================================================*/
HRESULT
ValidateAccessToAppPool(LPCWSTR pAppPool)
{
    HRESULT hr = S_OK;
    STACK_STRU( strPath, 128 );
    
    hr = strPath.Copy(L"\\LM\\W3SVC\\AppPools\\");
    if (FAILED(hr))
    {
        goto done;
    }

    hr = strPath.Append(pAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = ValidateWriteAccessToMetabaseKey(strPath.QueryStr());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


/*===================================================================
CWamAdmin::RecycleApplicationPool

Restart the given application pool

szAppPool - AppPool to restart.

Return:	HRESULT
S_OK if restarted
HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) if W3SVC is not up
+other error codes
===================================================================*/
STDMETHODIMP
CWamAdmin::RecycleApplicationPool
(
 LPCWSTR szAppPool
)
{
    HRESULT     hr = E_FAIL;
    IW3Control* piW3Control = NULL;

    if (NULL == szAppPool)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    hr = ValidateAccessToAppPool(szAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetWASIfRunning(&piW3Control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = piW3Control->RecycleAppPool(szAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    ReleaseInterface(piW3Control);
    return hr;
}

/*===================================================================
CWamAdmin::GetProcessMode

Retrieve the current process mode

pdwMode - where to store the mode

Return:	HRESULT
S_OK if retrieved
HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) if W3SVC is not up
+other error codes
===================================================================*/
STDMETHODIMP
CWamAdmin::GetProcessMode
(
 DWORD * pdwMode
)
{
    HRESULT     hr = E_FAIL;
    IW3Control* piW3Control = NULL;

    if (NULL == pdwMode)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = ValidateWriteAccessToMetabaseKey(L"\\LM\\W3SVC");
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetWASIfRunning(&piW3Control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = piW3Control->GetCurrentMode(pdwMode);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    ReleaseInterface(piW3Control);
    return hr;
}

#endif // _IIS_6_0

/*

CWamAdminFactory: 	Class Factory IUnknown Implementation

*/

/*===================================================================
CWamAdminFactory::CWamAdminFactory

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
CWamAdminFactory::CWamAdminFactory()
:	m_cRef(1)
{
	InterlockedIncrement((long *)&g_dwRefCount);
}

/*===================================================================
CWamAdminFactory::~CWamAdminFactory

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
CWamAdminFactory::~CWamAdminFactory()
{
	InterlockedDecrement((long *)&g_dwRefCount);
}

/*===================================================================
CWamAdminFactory::QueryInterface

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdminFactory::QueryInterface(REFIID riid, void ** ppv)
{
	if (riid==IID_IUnknown || riid == IID_IClassFactory) 
		{
        *ppv = static_cast<IClassFactory *>(this);
		AddRef();
		}
	else 
		{
		*ppv = NULL;
    	return E_NOINTERFACE;
		}

	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return NOERROR;
}

/*===================================================================
CWamAdminFactory::AddRef

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP_(ULONG) CWamAdminFactory::AddRef( )
{
	DWORD dwRefCount;

	dwRefCount = InterlockedIncrement((long *)&m_cRef);
	return dwRefCount;

}

/*===================================================================
CWamAdminFactory::Release

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP_(ULONG) CWamAdminFactory::Release( )
{
	DWORD dwRefCount;

	dwRefCount = InterlockedDecrement((long *)&m_cRef);
	return dwRefCount;
}

/*===================================================================
CWamAdminFactory::CreateInstance

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdminFactory::CreateInstance(IUnknown * pUnknownOuter, REFIID riid, void ** ppv)
{	
	if (pUnknownOuter != NULL) 
		{
    	return CLASS_E_NOAGGREGATION;
		}
	
	CWamAdmin *pWamAdmin = new CWamAdmin;
	if (pWamAdmin == NULL)
		{
		return E_OUTOFMEMORY;
		}

	HRESULT hrReturn = pWamAdmin->QueryInterface(riid, ppv);

	pWamAdmin->Release();
		
	return hrReturn;
}

/*===================================================================
CWamAdminFactory::LockServer

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdminFactory::LockServer(BOOL fLock)
{
	if (fLock) 
		{
        InterlockedIncrement((long *)&g_dwRefCount);
    	}
    else 
    	{
        InterlockedDecrement((long *)&g_dwRefCount);
    	}
	return NOERROR;
}

#if 0

// OBSOLETE - This fix (335422) was implemented in script but
// some of the code is general enough that it might be worth
// keeping around for a while.


STDMETHODIMP CWamAdmin::SynchWamAccountAll()
/*+
Routine Description:

    Updates all out of process packages with the current IWAM_ account
    values stored in the metabase.

    There are a number of ways that the IWAM_ account information can get
    out of sync between the metabase/sam/com+. The metabase contains code
    to repair the IWAM_ and IUSR_ accounts on startup if there is a disconnect
    with the SAM. If there is a disconnect with com+ calling this method will
    repair it.

    If the IWAM_ account does not match what is stored in the com catalog the
    following error's will happen:

    CoCreateInstance for WAM object returns CO_E_RUNAS_CREATEPROCESS_FAILURE

    Event Log - DCOM 10004 - "Logon error"

Arguments:
    None

Returns:
    HRESULT
-*/
{
    HRESULT hr = NOERROR;

    // Get WAM user info from the metabase

   	WamRegMetabaseConfig    mb;

    // These are way too big...
    WCHAR   wszIWamUser[MAX_PATH];
    WCHAR   wszIWamPass[MAX_PATH];

    hr = mb.MDGetIdentity( wszIWamUser, 
                           sizeof(wszIWamUser), 
                           wszIWamPass, 
                           sizeof(wszIWamPass) 
                           );
    if( FAILED(hr) ) return hr;

    // Init the com admin interface

    WamRegPackageConfig     comAdmin;

    hr = comAdmin.CreateCatalog();
    if( FAILED(hr) ) return hr;

    //
    // For each of the out of process applications,
    // get the package and reset the metabase identity.
    //

    // After this failures cause a goto exit, which will release the lock
    g_WamRegGlobal.AcquireAdmWriteLock();

    WCHAR * wszPropPaths        = NULL;
    DWORD   cbPropPaths         = 0;
    WCHAR * pwszPartialPath;
    WCHAR * wszFullPath         = NULL;
    DWORD   dwAppMode;
    WCHAR   wszWamClsid[uSizeCLSID];
    WCHAR   wszAppPackageId[uSizeCLSID];

    // Reset the properties for the pooled package

    hr = comAdmin.ResetPackageActivation( 
            g_WamRegGlobal.g_szIISOOPPoolPackageID, 
            wszIWamUser, 
            wszIWamPass 
            );
    
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT, 
                    "comAdmin.ResetPackageActivation FAILED(%08x) on (%S)\n",
                    hr,
                    g_WamRegGlobal.g_szIISOOPPoolPackageID
                    ));
        goto exit;
    }

    // Reset the properties for each isolated application

    hr = mb.MDGetPropPaths( g_WamRegGlobal.g_szMDW3SVCRoot, 
                            MD_APP_ISOLATED,
                            &wszPropPaths,
                            &cbPropPaths
                            );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT, 
                    "mb.MDGetPropPaths FAILED(%08x)\n",
                    hr
                    ));
        goto exit;
    }

    if( SUCCEEDED(hr) )
    {
        for( pwszPartialPath = wszPropPaths;
             *pwszPartialPath != L'\0';
             pwszPartialPath += ( wcslen( pwszPartialPath ) + 1 )
             )
        {
            if( wszFullPath )
            {
                delete [] wszFullPath;
                wszFullPath = NULL;
            }

            hr = g_WamRegGlobal.ConstructFullPath( 
                    WamRegGlobal::g_szMDW3SVCRoot,
                    WamRegGlobal::g_cchMDW3SVCRoot,
                    pwszPartialPath,
                    &wszFullPath
                    );
            if( FAILED(hr) ) goto exit;

            hr = mb.MDGetDWORD( wszFullPath, MD_APP_ISOLATED, &dwAppMode );
            if( FAILED(hr) ) goto exit;

            if( dwAppMode == eAppRunOutProcIsolated )
            {
                hr = mb.MDGetIDs( wszFullPath, wszWamClsid, wszAppPackageId, dwAppMode );
                if( FAILED(hr) )
                {
                    DBGPRINTF(( DBG_CONTEXT, 
                                "mb.MDGetIDs FAILED(%08x) on (%S)\n",
                                hr,
                                wszFullPath
                                ));
                    continue;
                }

                hr = comAdmin.ResetPackageActivation( wszAppPackageId, wszIWamUser, wszIWamPass );
                if( FAILED(hr) )
                {
                    DBGPRINTF(( DBG_CONTEXT, 
                                "comAdmin.ResetPackageActivation FAILED(%08x) on (%S)\n",
                                hr,
                                wszFullPath
                                ));
                    continue;
                }
            }
        }
    }

// goto exit on catastrophic failures, but if there is just
// an individual malformed application continue
exit:

    g_WamRegGlobal.ReleaseAdmWriteLock();
    
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT, 
                    "CWamAdmin::SynchWamAccountAll FAILED(%08x)\n",
                    hr
                    ));
    }

    if( wszPropPaths ) delete [] wszPropPaths;
    if( wszFullPath ) delete [] wszFullPath;

    return hr;
}

// OBSOLETE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\iis60\makefile.inc ===
#
#   makefil0
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt

IDL_FLAGS       = /I $(SDK_INC_PATH)
INCS            = -I.. -I$(SDK_INC_PATH)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)


#------------------------------------------------------------
# WAMREG DCOM Interface specification and compilation directives
#------------------------------------------------------------

WAMREG_IDL_FILE_NAME = wamreg

WAMREG_HEADER_FILE = ..\..\..\..\inc\$(O)\i$(WAMREG_IDL_FILE_NAME).h
WAMREG_IID_STUB    = $(O)\$(WAMREG_IDL_FILE_NAME)_i.c
WAMREG_PROXY_STUB  = $(O)\$(WAMREG_IDL_FILE_NAME)_p.c
WAMREG_DLL_DATA    = $(O)\dlldata.c
WAMREG_TLB         = $(O)\$(WAMREG_IDL_FILE_NAME).tlb

WAMREG_TARGETS     = $(WAMREG_IID_STUB) $(WAMREG_PROXY_STUB)  \
                     $(WAMREG_HEADER_FILE) $(WAMREG_DLL_DATA)


#------------------------------------------------------------
#  Define output and dependencies
#------------------------------------------------------------

all:    $(WAMREG_TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF clean: delsrc all

delsrc:
        -erase $(WAM_TARGETS) $(WR_TARGETS)


#
#  MIDL Compile stuff
#
$(WAMREG_TARGETS):  ..\$(WAMREG_IDL_FILE_NAME).idl
    midl -no_stamp -Oicf -error allocation -error ref $(IDL_FLAGS) $(CPP) $(INCS) /header $(WAMREG_HEADER_FILE) /iid $(WAMREG_IID_STUB) /dlldata $(WAMREG_DLL_DATA) /proxy $(WAMREG_PROXY_STUB) /tlb $(WAMREG_TLB)  ..\$(WAMREG_IDL_FILE_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\wamadm.h ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: WamAdm.h 

	Declaration of the CWamAdmin

Owner: LeiJin

Note:

WamAdm header file
===================================================================*/	


#ifndef __WAMADM_H_
#define __WAMADM_H_

#include "admex.h"
#include "common.h"

/////////////////////////////////////////////////////////////////////////////
// CWamAdmin
class CWamAdmin : 
    public IWamAdmin2,
    public IMSAdminReplication
#ifdef _IIS_6_0
    , public IIISApplicationAdmin
#endif // _IIS_6_0
{
public:
    CWamAdmin();
    ~CWamAdmin();
	

public:
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    //
    // IWamAdmin
    //
    
    STDMETHOD(AppRecover)
        (
        /*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fRecursive
        );
    
    STDMETHOD(AppDeleteRecoverable)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fRecursive
        );
    
    STDMETHOD(AppGetStatus)
        (/*[in, unique, string]*/ LPCWSTR szMDPath,
        /*[out]*/ DWORD *pdwAppStatus
        );
    
    STDMETHOD(AppUnLoad)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fRecursive
        );
    
    STDMETHOD(AppDelete)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fRecursive
        );
    
    STDMETHOD(AppCreate)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fInProc
        );
    
    //
    // IWamAdmin2
    //
    STDMETHOD(AppCreate2)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ DWORD dwAppMode
        );
    
    
    //
    //IMSAdminReplication
    //These interfaces are defined in admex.h, as part of Admin Extension.
    //
    STDMETHOD(GetSignature)
        (
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
        /* [out */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
        );
    
    STDMETHOD(Propagate)
        ( 
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer
        );
    
    STDMETHOD(Propagate2)
        ( 
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer,
        /* [in] */ DWORD dwSignatureMismatch
        );
    
    STDMETHOD(Serialize)
        ( 
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
        );
    
    STDMETHOD(DeSerialize)
        ( 
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][in] */ unsigned char __RPC_FAR *pbBuffer
        );

#ifdef _IIS_6_0
    //
    // IIISApplicationAdmin interface
    //
    STDMETHOD(CreateApplication)
        (
        LPCWSTR szMDPath,
        DWORD dwAppMode,
        LPCWSTR szAppPoolId,
        BOOL fCreatePool
        );
    
    STDMETHOD(DeleteApplication)
        (
        LPCWSTR szMDPath,
        BOOL fRecursive
        );
    
    STDMETHOD(CreateApplicationPool)
        (
        LPCWSTR szMDPath
        );
    
    STDMETHOD(DeleteApplicationPool)
        (
        LPCWSTR szMDPath
        );
        
    STDMETHOD(EnumerateApplicationsInPool)
        (
        LPCWSTR szMDPath,
        BSTR*   pbstrBuffer
        );

    STDMETHOD(RecycleApplicationPool)
        (
        LPCWSTR szMDPath
        );
    
    STDMETHOD(GetProcessMode)
        (
        DWORD * pdwMode
        );
#endif // _IIS_6_0

private:
    HRESULT PrivateDeleteApplication
        (
        LPCWSTR szMDPath,
        BOOL fRecursive,
        BOOL fRecoverable,
        BOOL fRemoveAppPool
        );

    STDMETHOD(FormatMetabasePath)
        (
        /* [in] */ LPCWSTR pwszMetabasePathIn,
        /* [out] */ LPWSTR *ppwszMetabasePathOut
        );
    
    long    m_cRef;
};

class CWamAdminFactory: 
	public IClassFactory 
{
public:
	CWamAdminFactory();
	~CWamAdminFactory();

	STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(CreateInstance)(IUnknown * pUnknownOuter, REFIID riid, void ** ppv);
	STDMETHOD(LockServer)(BOOL bLock);

private:
	long		m_cRef;
};


#endif //__WAMADM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamregps\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\wamreg.cpp ===
// wamreg.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for wamreg.idl by adding the following 
//		files to the Outputs.
//			wamreg_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f wamregps.mk in the project directory.

#include "common.h"

#include "objbase.h"
#include "initguid.h"
#include "iwamreg.h"
#include "iadmext.h"
#include "dlldatax.h"
#include "auxfunc.h"
#include "wmrgsv.h"

#include "WamAdm.h"
#include "comobj.h"

#include "dbgutil.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#define IIS_DEFAULT_PACKAGE	0

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisWamRegGuid, 
0x784d8917, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#ifdef _IIS_6_0
#include "w3ctrlps.h"
#endif // _IIS_6_0
#endif
DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

const CHAR 		g_pszModuleName[] = "WAMREG";

HINSTANCE g_hModule = NULL;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    
    BOOL fReturn = FALSE;
    
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        
        g_hModule = hInstance;
        
        INITIALIZE_PLATFORM_TYPE();
#ifdef _NO_TRACING_
        SET_DEBUG_FLAGS(DEBUG_ERROR);
        CREATE_DEBUG_PRINT_OBJECT( g_pszModuleName);
#else
//        CREATE_DEBUG_PRINT_OBJECT( g_pszModuleName);
#endif
/*
        if ( !VALID_DEBUG_PRINT_OBJECT()) 
        {
            fReturn = FALSE;
        }
        else
        {
*/
            g_pWmRgSrvFactory = new CWmRgSrvFactory();
            fReturn = g_WamRegGlobal.Init();
        //}
       	
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        g_WamRegGlobal.UnInit();
        delete g_pWmRgSrvFactory;
        DELETE_DEBUG_PRINT_OBJECT();	
    }
    
    fReturn = TRUE;    // ok
    return fReturn;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	if (g_dwRefCount == 0)
		{
		return S_OK;
		}
	else
		{
		return S_FALSE;
		}
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	HRESULT hrReturn = E_FAIL;
	
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif

	if (rclsid == CLSID_WmRgSrv) 
		{
		if (FAILED(g_pWmRgSrvFactory->QueryInterface(riid, ppv))) 
			{
	    	*ppv = NULL;
	   		hrReturn = E_INVALIDARG;
	   		}
	   	else
	   		{
	   		hrReturn = NOERROR;
	   		}
		}
	else
		{
		hrReturn = S_OK;
		}

	return hrReturn;
}


HRESULT WamReg_RegisterServer()
{
	HKEY 	hKeyCLSID, hKeyInproc32;
    HKEY 	hKeyIF, hKeyStub32;
    HKEY 	hKeyAppID, hKeyTemp;
    DWORD 	dwDisposition;
    BOOL	fIsWin95 = FALSE;
	char 	pszName[MAX_PATH+1 + sizeof("inetinfo.exe -e iisadmin")];


    //
    // if win95, then don't register as service
    //

    if ( IISGetPlatformType() == PtWindows95 ) {

        fIsWin95 = TRUE;
    }

    if (fIsWin95) {

        HMODULE hModule=GetModuleHandle(TEXT("WAMREG.DLL"));
        if (!hModule) {
                return E_UNEXPECTED;
                }

        WCHAR wchName[MAX_PATH + 1];
        if (GetModuleFileName(hModule, pszName, sizeof(pszName))==0) {
                return E_UNEXPECTED;
                }

        int i;

        //
        // Set pszName to the command to start the web server
        //

        for (i = strlen(pszName) -1; (i >= 0) && (pszName[i] != '/') & (pszName[i] != '\\'); i--) {
        }

        pszName[i + 1] = '\0';
        strcat(pszName, "inetinfo.exe -e iisadmin");
    }

    HRESULT hr;

    //
    //register AppID
    //CLSID_WamAdmin, 0x61738644, 0xF196, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1)
    //

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
				                       TEXT("AppID\\{61738644-F196-11D0-9953-00C04FD919C1}"),
				                       NULL, 
				                       TEXT(""), 
				                       REG_OPTION_NON_VOLATILE, 
				                       KEY_ALL_ACCESS, 
				                       NULL,
				                       &hKeyAppID, 
				                       &dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
    else
    	{
	    if (ERROR_SUCCESS != RegSetValueEx(hKeyAppID, 
	    								TEXT(""), 
	    								NULL, 
	    								REG_SZ, 
	    								(BYTE*) TEXT("IIS WAMREG admin Service"), 
	    								sizeof(TEXT("IIS WAMREG Admin Service")))) 
	    			{
	                RegCloseKey(hKeyAppID);
	                return E_UNEXPECTED;
	                }

	    if (!fIsWin95)
	    	{
	        if (ERROR_SUCCESS != RegSetValueEx(hKeyAppID, 
	        								TEXT("LocalService"), 
	        								NULL, 
	        								REG_SZ, 
	        								(BYTE *) TEXT("IISADMIN"), 
	        								sizeof(TEXT("IISADMIN")))) 
	        	{
	            RegCloseKey(hKeyAppID);
	            return E_UNEXPECTED;
	        	}
	        }
	        
    	RegCloseKey(hKeyAppID);
    	}
    	
    //
    // register CLSID
    //WamAdmin_CLSID

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
			                       TEXT("CLSID\\{61738644-F196-11D0-9953-00C04FD919C1}"),
			                       NULL, 
			                       TEXT(""), 
			                       REG_OPTION_NON_VOLATILE, 
			                       KEY_ALL_ACCESS, 
			                       NULL,
			                       &hKeyCLSID, 
			                       &dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
     else
     	{

	    if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
	    								TEXT(""), 
	    								NULL, 
	    								REG_SZ, 
	    								(BYTE*) TEXT("IIS WAMREG Admin"), 
	    								sizeof(TEXT("IIS WAMREG Admin"))))
			{
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }
            
	    if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
	    								TEXT("AppID"), 
	    								NULL, 
	    								REG_SZ, 
	    								(BYTE*) TEXT("{61738644-F196-11D0-9953-00C04FD919C1}"), 
	    								sizeof(TEXT("{61738644-F196-11D0-9953-00C04FD919C1}"))))
			{
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }
          

		if (fIsWin95) 
			{
        	if (ERROR_SUCCESS != RegCreateKeyEx(hKeyCLSID,
                           				TEXT("LocalServer32"),
                           				NULL, 
                           				TEXT(""), 
                           				REG_OPTION_NON_VOLATILE,
                           				KEY_ALL_ACCESS, 
                           				NULL,
                           				&hKeyTemp, 
                           				&dwDisposition)) 
	            {
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	        	}
	      	else
	      		{
	      		if (ERROR_SUCCESS != RegSetValueEx(hKeyTemp, 
	      										TEXT(""), 
	      										NULL, 
	      										REG_SZ, 
	      										(BYTE*) pszName,
	      										strlen(pszName) + 1)) 
	      			{
                    RegCloseKey(hKeyTemp);
                    RegCloseKey(hKeyCLSID);
                    return E_UNEXPECTED;
                    }

        		RegCloseKey(hKeyTemp);
                }
            }
    	else 
    		{
	        if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
	        								TEXT("LocalService"), 
	        								NULL, 
	        								REG_SZ, 
	        								(BYTE*) TEXT("IISADMIN"), 
	        								sizeof(TEXT("IISADMIN")))) 
	        	{
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	            }
	     	}
	   	RegCloseKey(hKeyCLSID);
    	}

    //
    // Main Interfaces
    //

    //
    // WAMREG Admin Interface
    //IID_IWamAdmin, 0x29822AB7, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{29822AB7-F302-11D0-9953-00C04FD919C1}"),
                       NULL, 
                       TEXT(""), 
                       REG_OPTION_NON_VOLATILE, 
                       KEY_ALL_ACCESS, 
                       NULL,
                       &hKeyCLSID, 
                       &dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
    else
    	{
		if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
										TEXT(""), 
										NULL, 
										REG_SZ, 
										(BYTE*) TEXT("PSFactoryBuffer"), 
										sizeof(TEXT("PSFactoryBuffer")))) 
			{
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    	if (ERROR_SUCCESS != RegCreateKeyEx(hKeyCLSID,
                       						"InprocServer32",
                       						NULL, 
                       						TEXT(""), 
                       						REG_OPTION_NON_VOLATILE, 
                       						KEY_ALL_ACCESS, 
                       						NULL,
                        					&hKeyInproc32, 
                        					&dwDisposition)) 
            {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }
		else
			{
			if (ERROR_SUCCESS != RegSetValueEx(hKeyInproc32, 
											TEXT(""), 
											NULL, 
											REG_SZ, 
											(BYTE*) "WAMREGPS.DLL", 
											sizeof(TEXT("WAMREGPS.DLL")))) 
				{
	            RegCloseKey(hKeyInproc32);
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	            }

	        if (ERROR_SUCCESS != RegSetValueEx(hKeyInproc32, 
	        								TEXT("ThreadingModel"), 
	        								NULL, 
	        								REG_SZ, 
	        								(BYTE*) "Both", 
	        								sizeof("Both")-1 )) 
	        	{
	            RegCloseKey(hKeyInproc32);
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	            }

    		RegCloseKey(hKeyInproc32);
    		}
    	RegCloseKey(hKeyCLSID);
    	}


    //
    // WAMREG Admin Interface
    //IID_IWamAdmin2, 0x29822AB8, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{29822AB8-F302-11D0-9953-00C04FD919C1}"),
                       NULL, 
                       TEXT(""), 
                       REG_OPTION_NON_VOLATILE, 
                       KEY_ALL_ACCESS, 
                       NULL,
                       &hKeyCLSID, 
                       &dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
    else
    	{
		if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
										TEXT(""), 
										NULL, 
										REG_SZ, 
										(BYTE*) TEXT("PSFactoryBuffer"), 
										sizeof(TEXT("PSFactoryBuffer")))) 
			{
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    	if (ERROR_SUCCESS != RegCreateKeyEx(hKeyCLSID,
                       						"InprocServer32",
                       						NULL, 
                       						TEXT(""), 
                       						REG_OPTION_NON_VOLATILE, 
                       						KEY_ALL_ACCESS, 
                       						NULL,
                        					&hKeyInproc32, 
                        					&dwDisposition)) 
            {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }
		else
			{
			if (ERROR_SUCCESS != RegSetValueEx(hKeyInproc32, 
											TEXT(""), 
											NULL, 
											REG_SZ, 
											(BYTE*) "WAMREGPS.DLL", 
											sizeof(TEXT("WAMREGPS.DLL")))) 
				{
	            RegCloseKey(hKeyInproc32);
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	            }

	        if (ERROR_SUCCESS != RegSetValueEx(hKeyInproc32, 
	        								TEXT("ThreadingModel"), 
	        								NULL, 
	        								REG_SZ, 
	        								(BYTE*) "Both", 
	        								sizeof("Both")-1 )) 
	        	{
	            RegCloseKey(hKeyInproc32);
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	            }

    		RegCloseKey(hKeyInproc32);
    		}
    	RegCloseKey(hKeyCLSID);
    	}

    //
    
   	//
    // register Interfaces
    //

    //
    // ANSI Main Interface
    // WamReg Admin Interface

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    			TEXT("Interface\\{29822AB7-F302-11D0-9953-00C04FD919C1}"),
                    			NULL, 
                    			TEXT(""), 
                    			REG_OPTION_NON_VOLATILE, 
                    			KEY_ALL_ACCESS, 
                    			NULL,
                    			&hKeyIF, 
                    			&dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
	else
		{
		if (ERROR_SUCCESS != RegSetValueEx(hKeyIF, 
										TEXT(""), 
										NULL, 
										REG_SZ, 
										(BYTE*) TEXT("IWamAdmin"), 
										sizeof(TEXT("IWamAdmin")))) 
			{
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

        if (ERROR_SUCCESS != RegCreateKeyEx(hKeyIF,
					                    "ProxyStubClsid32",
					                    NULL, 
					                    TEXT(""), 
					                    REG_OPTION_NON_VOLATILE, 
					                    KEY_ALL_ACCESS, 
					                    NULL,
					                    &hKeyStub32, 
					                    &dwDisposition)) 
	        {
	        RegCloseKey(hKeyIF);
	        return E_UNEXPECTED;
	        }
	    else
	    	{
			if (ERROR_SUCCESS != RegSetValueEx(hKeyStub32, 
												TEXT(""), 
												NULL, 
												REG_SZ, 
												(BYTE*)"{29822AB7-F302-11D0-9953-00C04FD919C1}", 
												sizeof("{29822AB7-F302-11D0-9953-00C04FD919C1}"))) 
				{
	            RegCloseKey(hKeyStub32);
	            RegCloseKey(hKeyIF);
	            return E_UNEXPECTED;
            	}

            RegCloseKey(hKeyStub32);
            }
    	RegCloseKey(hKeyIF);
    	}

    // WamReg Admin Interface
    // IID_IWamAdmin2
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    			TEXT("Interface\\{29822AB8-F302-11D0-9953-00C04FD919C1}"),
                    			NULL, 
                    			TEXT(""), 
                    			REG_OPTION_NON_VOLATILE, 
                    			KEY_ALL_ACCESS, 
                    			NULL,
                    			&hKeyIF, 
                    			&dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
	else
		{
		if (ERROR_SUCCESS != RegSetValueEx(hKeyIF, 
										TEXT(""), 
										NULL, 
										REG_SZ, 
										(BYTE*) TEXT("IWamAdmin2"), 
										sizeof(TEXT("IWamAdmin2")))) 
			{
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

        if (ERROR_SUCCESS != RegCreateKeyEx(hKeyIF,
					                    "ProxyStubClsid32",
					                    NULL, 
					                    TEXT(""), 
					                    REG_OPTION_NON_VOLATILE, 
					                    KEY_ALL_ACCESS, 
					                    NULL,
					                    &hKeyStub32, 
					                    &dwDisposition)) 
	        {
	        RegCloseKey(hKeyIF);
	        return E_UNEXPECTED;
	        }
	    else
	    	{
			if (ERROR_SUCCESS != RegSetValueEx(hKeyStub32, 
												TEXT(""), 
												NULL, 
												REG_SZ, 
												(BYTE*)"{29822AB8-F302-11D0-9953-00C04FD919C1}", 
												sizeof("{29822AB8-F302-11D0-9953-00C04FD919C1}"))) 
				{
	            RegCloseKey(hKeyStub32);
	            RegCloseKey(hKeyIF);
	            return E_UNEXPECTED;
            	}

            RegCloseKey(hKeyStub32);
            }
    	RegCloseKey(hKeyIF);
    	}

    return NOERROR;
}

STDAPI WamReg_UnRegisterServer(void) {

    BOOL fIsWin95 = FALSE;


    //
    // if win95, then don't register as service
    //

    if ( IISGetPlatformType() == PtWindows95 ) {

        fIsWin95 = TRUE;
    }

    //
    // register AppID
    //
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{61738644-F196-11D0-9953-00C04FD919C1}"));

    //RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{61738646-F196-11D0-9953-00C04FD919C1}"));

    //
    // register CLSID
    //

    if (fIsWin95) 
    	{
        RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{61738644-F196-11D0-9953-00C04FD919C1}\\LocalServer32"));
    	}

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{61738644-F196-11D0-9953-00C04FD919C1}"));

	/*
    if (fIsWin95) {
        RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{61738646-F196-11D0-9953-00C04FD919C1}\\LocalServer32"));
    }

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{61738646-F196-11D0-9953-00C04FD919C1}"));
	*/

    //
    // WAMREG Interfaces
    //

    //
    // Admin Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{29822AB7-F302-11D0-9953-00C04FD919C1}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{29822AB7-F302-11D0-9953-00C04FD919C1}"));

    //
    // Replication Interface
    //
	/*
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{29822AB8-F302-11D0-9953-00C04FD919C1}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{29822AB8-F302-11D0-9953-00C04FD919C1}"));
	*/

    //
    // deregister Interfaces
    //

    //
    // Admin Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{29822AB7-F302-11D0-9953-00C04FD919C1}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{29822AB7-F302-11D0-9953-00C04FD919C1}"));


	/*
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{29822AB8-F302-11D0-9953-00C04FD919C1}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{29822AB8-F302-11D0-9953-00C04FD919C1}"));
	*/
	
	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\{763A6C86-F30F-11D0-9953-00C04FD919C1}"),
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
                              
    if (dwReturn == ERROR_SUCCESS) 
    	{
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) TEXT("WAM REG COM LAYER"),
                                 sizeof(TEXT("WAM REG COM LAYER")));
                                 
        if (dwReturn == ERROR_SUCCESS) 
        	{
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                					  	"InprocServer32",
                						NULL,
                						TEXT(""),
                						REG_OPTION_NON_VOLATILE,
                						KEY_ALL_ACCESS, 
                						NULL,
                						&hKeyInproc32, 
                						&dwDisposition);

            if (dwReturn == ERROR_SUCCESS) 
            	{
                hModule=GetModuleHandle(TEXT("WAMREG.DLL"));
                if (!hModule) 
                	{
                    dwReturn = GetLastError();
                	}
                else 
                	{
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)) == NULL) 
						{
                        dwReturn = GetLastError();
                    	}
                    else 
                    	{
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                                                 
                        if (dwReturn == ERROR_SUCCESS) 
                        	{
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        	}
                    	}
                	}
                RegCloseKey(hKeyInproc32);
            	}
        	}
        RegCloseKey(hKeyCLSID);
    	}

	//
	// Register the COM object's CLSID under IISADMIN_EXTENSIONS_REG_KEY
	//
	if (dwReturn == ERROR_SUCCESS)
		{
		dwReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
								IISADMIN_EXTENSIONS_REG_KEY
									TEXT("\\{763A6C86-F30F-11D0-9953-00C04FD919C1}"),
								NULL,
								TEXT(""),
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKeyCLSID,
								&dwDisposition);
		if (dwReturn == ERROR_SUCCESS)
			{
			RegCloseKey(hKeyCLSID);
			}
		}

    if (dwReturn == ERROR_SUCCESS)	
    	{
    	HRESULT hr;
    	// registers object, typelib and all interfaces in typelib
    	hr = WamReg_RegisterServer();
		return hr;
		}
	else
		{
    	return RETURNCODETOHRESULT(dwReturn);
    	}
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwTemp;

#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif

    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{763A6C86-F30F-11D0-9953-00C04FD919C1}\\InprocServer32"));
	if (dwTemp != ERROR_SUCCESS)
		{
		dwReturn = dwTemp;
		}
		
	dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{763A6C86-F30F-11D0-9953-00C04FD919C1}"));
    if (dwTemp != ERROR_SUCCESS)
		{
		dwReturn = dwTemp;
		}

	dwTemp = RegDeleteKey(HKEY_LOCAL_MACHINE,
					IISADMIN_EXTENSIONS_REG_KEY
                    	TEXT("\\{763A6C86-F30F-11D0-9953-00C04FD919C1}"));
    if (dwTemp != ERROR_SUCCESS)
		{
		dwReturn = dwTemp;
		}

	if (SUCCEEDED(HRESULT_FROM_WIN32(dwReturn)))
		{
		HRESULT hr;

		hr = WamReg_UnRegisterServer();
		return hr;
		}
	else
		{
		return HRESULT_FROM_WIN32(dwReturn);
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\vptool\module.h ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: module.h

Owner: leijin

Note:
===================================================================*/

#ifndef _VPTOOL_MODULE_H_
#define _VPTOOL_MODULE_H_


#include <objbase.h>

#define SIZE_STRING_BUFFER	1024
#define uSizeCLSID			39

HRESULT	ModuleInitialize();
HRESULT ModuleUnInitialize();
void CreateInPool(CHAR* szPath, BOOL fInProc);
void CreateOutProc(CHAR* szPath);
void Delete(CHAR* szPath);
void UnLoad(CHAR* szPath);
void GetStatus(CHAR* szPath);
void DeleteRecoverable(CHAR* szPath);
void Recover(CHAR* szPath);
void GetSignature();
void Serialize();
void CREATE2();
void DELETE2();
void CREATEPOOL2();
void DELETEPOOL2();
void ENUMPOOL2();
void RECYCLEPOOL();
void GETMODE();
void TestConn();

extern	const BOOL	fLinkWithWamReg;

#endif //_VPTOOL_MODULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\vptool\main.cpp ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: main.cpp

Owner: leijin

Note:
===================================================================*/

#include <stdio.h>


#include "module.h"
#include "util.h"


int _cdecl main (int argc, char **argv)
{
    HRESULT hr = NOERROR;
    
    
    if (!ParseCommandLine(argc, argv))
    {
        return -1;
    }
    
    //
    // Do not do CoInitialize() in case of INSTALL or UNINSTALL
    //
    ModuleInitialize();
    
    switch(g_Command.eCmd)
    {
#ifdef _WAMREG_LINK_DIRECT
    case eCommand_INSTALL:
        hr = CreateIISPackage();
        if (SUCCEEDED(hr))	
        {
            printf("The default IIS Package has been installed on your machine.\n");
        }
        else
        {
            printf("Failed to create default IIS package, hr = %08x\n", hr);
        }
        
        break;
    case eCommand_UNINSTALL:
        hr = DeleteIISPackage();
        if (SUCCEEDED(hr))	
        {
            printf("The default IIS Package has been Uninstalled from your machine.\n");
        }
        else
        {
            printf("Failed to uninstall default IIS package, hr = %08x\n", hr);
        }
        break;
        
    case eCommand_UPGRADE:
        hr = UpgradePackages(VS_K2Beta2, VS_K2Beta3);
        if (SUCCEEDED(hr))
        {
            printf("The packages has been upgraded on your machine.\n");
        }
        else
        {
            printf("Fail to upgrade the packages. hr = %08x\n",hr);
        }
        break;
#endif
        
    case eCommand_CREATEINPROC:
        CreateInPool(g_Command.szMetabasePath, TRUE);
        break;
        
    case eCommand_CREATEINPOOL:
        CreateInPool(g_Command.szMetabasePath, FALSE);
        break;
        
    case eCommand_DELETE:
        Delete(g_Command.szMetabasePath);
        break;
        
    case eCommand_HELP:
        break;
        
    case eCommand_CREATEOUTPROC:
        CreateOutProc(g_Command.szMetabasePath);
        break;
        
    case eCommand_GETSTATUS:
        GetStatus(g_Command.szMetabasePath);
        break;
        
    case eCommand_UNLOAD:
        UnLoad(g_Command.szMetabasePath);
        break;
        
    case eCommand_DELETEREC:
        DeleteRecoverable(g_Command.szMetabasePath);
        break;
        
    case eCommand_RECOVER:
        Recover(g_Command.szMetabasePath);
        break;
        
    case eCommand_GETSIGNATURE:
        GetSignature();
        break;
        
    case eCommand_SERIALIZE:
        Serialize();
        break;
        
    case eCommand_2CREATE:
        CREATE2();
        break;
    case eCommand_2DELETE:
        DELETE2();
        break;
    case eCommand_2CREATEPOOL:
        CREATEPOOL2();
        break;
    case eCommand_2DELETEPOOL:
        DELETEPOOL2();
        break;
    case eCommand_2ENUMPOOL:
        ENUMPOOL2();
        break;
    case eCommand_2RECYCLEPOOL:
        RECYCLEPOOL();
        break;
    case eCommand_2GETMODE:
        GETMODE();
        break;
    case eCommand_2TestConn:
	TestConn();
        break;
    default:
        printf("This feature has not been implemented.\n");
        break;
    }
    
    ModuleUnInitialize();
    
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\vptool\util.cpp ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: util.cpp

Owner: leijin

Description:
Contains utility functions used by vptool.
    Including Debugging, timing, helping functions.

Note:
===================================================================*/

#include "util.h"
//
//  
//

//
//  Local Data Structures.
//

const CommandParam rgCommand[] =
{
    {eCommand_INSTALL, 		"-INSTALL", 		NULL,   FALSE},
    {eCommand_UNINSTALL, 	"-UNINSTALL", 		NULL,   FALSE},
    {eCommand_UPGRADE,		"-UPGRADE", 		NULL,   TRUE},
    {eCommand_CREATEINPROC,	"-CREATEINPROC", 	NULL,   TRUE},
    {eCommand_CREATEOUTPROC,"-CREATEOUTPROC", 	NULL,   TRUE},
    {eCommand_CREATEINPOOL, "-CREATEINPOOL",    NULL,   TRUE},
    {eCommand_DELETE,		"-DELETE", 			NULL,   TRUE},
    {eCommand_GETSTATUS,	"-GETSTATUS",	 	NULL,   TRUE},
    {eCommand_UNLOAD,		"-UNLOAD",	 		NULL,   TRUE},
    {eCommand_GETSIGNATURE,	"-GETSIGNATURE",	NULL,   FALSE},
    {eCommand_SERIALIZE,	"-SERIALIZE", 		NULL,   FALSE},
    {eCommand_DESERIALIZE,	"-GETSERIALIZE",	NULL,   FALSE},
    {eCommand_DELETEREC,	"-DELETEREC", 		NULL,   TRUE},
    {eCommand_RECOVER,		"-RECOVER",			NULL,   TRUE},

    {eCommand_2CREATE,          "-2CREATE",             NULL,   TRUE},
    {eCommand_2DELETE,          "-2DELETE",             NULL,   TRUE},
    {eCommand_2CREATEPOOL,      "-2CREATEPOOL",         NULL,   TRUE},
    {eCommand_2DELETEPOOL,      "-2DELETEPOOL",         NULL,   TRUE},
    {eCommand_2ENUMPOOL,        "-2ENUMPOOL",           NULL,   TRUE},
    {eCommand_2RECYCLEPOOL,     "-RECYCLEPOOL",         NULL,   TRUE},
    {eCommand_2GETMODE,         "-GETMODE",             NULL,   TRUE},
    {eCommand_2TestConn,        "-TESTCONN",            NULL,   TRUE}
};

const char* ppszHelpFile[] = 
{
	{"\n\n\t\t vptool (a simple WAMREG command line tool). \n\n"},
	{"Usage: vptool -Options -Command MetabasePath\n"},
	{"Command = CREATEINPROC | CREATEOUTPROC | DELETE | UNLOAD | GETSTATUS \n"},
	{"\n"},
	{"MetabasePath is required for all the commands \n\n"},
	{"CREATEINPROC\t - Create an in-proc application on the metabase path\n"},
	{"CREATEOUTPROC\t - Create an out-proc application on the metabase path\n"},
	{"CREATEINPOOL\t - Create an application in the out proc application pool on the metabase path\n"},
	{"DELETE\t\t - Delete the application on the metabase path if there is one\n"},
	{"UNLOAD\t\t - Unload an application on the metabase path from w3svc runtime lookup table.\n"},
	{"GETSTATUS\t - Get status of the application on the metabase path\n"},
	{"DELETEREC\t - Delete Recoverable on the metabase path\n"},
	{"RECOVER\t\t - Recover on the metabase path\n"},
	{"\n\nReplication testing only\n"},
	{"SERIALIZE\t -t Serialize application definitions\n"},
	{"DESERIALIZE\t -t DeSerialize application definitions\n"},
	{"GETSIGNATURE\t -t Get Signature of application definitions\n"}
};

const char* ppszAdvancedHelpFile[] =
{
	{"\t\t\tvptool (a simple WAMREG command line tool). \n"},
	{"Advanced features\n"},
	{"The follow commands are used for testing purpose of other functions\n"},
	{"supported by WAMREG.DLL\n"},
	{"Usage: vptool -Command\n"},
	{"Command = INSTALL | UNINSTALL | GETSIGNATURE | SERIALIZE | DESERIALIZE\n"},
	{"INSTALL : INSTALL IIS default package.  Test install function called by Setup\n"},
	{"CAUTION: This command will remove your old IIS default package first.\n"},
	{"\n"},
	{"UNINSTALL: Remove all user defined packages, including IIS default package\n"},
	{"\n"},
	{"GETSIGNATURE: UNDONE\n"},
	{"SERIALIZE: UNDONE\n"},
	{"DESERIALIZE: UNDONE\n"},
	{"\n"},
	{"\n"}
};



CommandParam    g_Command;
VP_Options      g_Options;
const UINT      rgComMax = sizeof(rgCommand) / sizeof(CommandParam);

//
//  Utility Functions
//
BOOL ParseCommandLine(int argc, char **argv)
{
    BOOL    fFound = FALSE;
    INT     iCurrentArg = 1;
    
    if (argc < 2)
    {
        g_Command.eCmd = eCommand_HELP;
        PrintHelp();
        return FALSE;
    }
    
    if ((0 == _strnicmp(argv[iCurrentArg], "-?", sizeof("-?"))) ||
        (0 == _strnicmp(argv[iCurrentArg], "/?", sizeof("/?"))))
    {
        g_Command.eCmd = eCommand_HELP;
        PrintHelp();
        return FALSE;
    }
    
    if ((0 == _strnicmp(argv[iCurrentArg], "-?a", sizeof("-?a"))) ||
        (0 == _strnicmp(argv[iCurrentArg], "/?a", sizeof("/?a"))))
    {
        g_Command.eCmd = eCommand_HELP;
        PrintHelp(TRUE);
        return FALSE;
    }
    
    // Options specifed.
    if (argc == 4 || argc == 3)
    {
        BOOL fHasOptions = FALSE;
        
        CHAR *pChar = argv[iCurrentArg];
        
        if (*pChar == '-')
        {
            pChar++;
        }
        else
        {
            PrintHelp();
            return FALSE;
        }
        
        while(*pChar != '\0')
        {
            if (*pChar == 't')
            {
                g_Options.fEnableTimer = TRUE;
                fHasOptions = TRUE;
            }
            pChar++;
        }
        
        if (fHasOptions)
        {
            iCurrentArg++;
        }
    }
    
    //
    // 1. Try to match with supported commands.
    //
    //
    BOOL fRequiredMDPath = TRUE;
    
    for (UINT iArg = 0; iArg < rgComMax; iArg++)
    {
        if (0 == _strnicmp(argv[iCurrentArg], rgCommand[iArg].szCommandLineSwitch, (strlen(rgCommand[iArg].szCommandLineSwitch) + 1)))
        {
            g_Command = rgCommand[iArg];
            fFound = TRUE;
            break;
        }
    }
    
    if (fFound == TRUE && g_Command.fRequireMDPath == TRUE)
    {
        iCurrentArg++;
        g_Command.szMetabasePath = argv[iCurrentArg];
        if (!g_Command.szMetabasePath)
        {
            fFound = FALSE;
        }
    }
    
    if (fFound != TRUE)
    {
        PrintHelp();
        return FALSE;
    }
    
    return TRUE;
}

VOID	Report_Time(double dElaspedSec)
{
    if  (g_Options.fEnableTimer)
    {
        printf("PERF[VP]:%f\n", dElaspedSec);
    }
    return;
}

void PrintHelp(BOOL fAdvanced)
{
    UINT	cLine = 0;
    UINT	i = 0;
    if (fAdvanced)
    {
        cLine = sizeof(ppszAdvancedHelpFile) / sizeof(char *);
        for (i = 0; i < cLine; i++)
        {
            printf("%s", ppszAdvancedHelpFile[i]);
        }
    }
    else
    {
        cLine = sizeof(ppszHelpFile) / sizeof(char *);
        for (i = 0; i < cLine; i++)
        {
            printf("%s", ppszHelpFile[i]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\vptool\module.cpp ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: module.cpp

Owner: leijin

Note:
===================================================================*/

#include <stdio.h>
#include <objbase.h>
#include <initguid.h>
#include "admex.h"
#include "iwamreg.h"

//
//#include "mtxadmii.c"
//#include "mtxadmin.h"

#include "module.h"
#include "util.h"


#ifdef _WAMREG_LINK_DIRECT
    #include "wmrgexp.h"
    const BOOL  fLinkWithWamReg = TRUE;
#else
    const BOOL  fLinkWithWamReg = FALSE;
#endif

HRESULT ModuleInitialize(VOID)
{
    HRESULT hr = NOERROR;
    if (!fLinkWithWamReg)
    {
        // do the call to CoInitialize()
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
    
    return hr;
}

HRESULT ModuleUnInitialize(VOID)
{
    HRESULT hr = NOERROR;
    
    if (!fLinkWithWamReg)
    {    	
        CoUninitialize();
    }
    
    return hr;    	
}

void CreateInPool(CHAR* szPath, BOOL fInProc)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin2*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    DWORD       dwAppMode;
    
    dwAppMode = (fInProc) ? eAppRunInProc : eAppRunOutProcInDefaultPool;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            Timer.Start();
            hr = pIWamAdmin->AppCreate2(wszMetabasePath, dwAppMode);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("%s : Create %s application on path %s failed, error = %08x.\n",
                    (fInProc) ? "CREATEINPROC" : "CREATEINPOOL",
                    (fInProc) ? "in-proc" : "out-proc pooled",
                    szPath,
                    hr);
            }
            else
            {
                printf("%s: Create %s, pooled application on path %s successfully.\n",
                    (fInProc) ? "CREATEINPROC" : "CREATEINPOOL",
                    (fInProc) ? "in-proc" : "out-proc pooled",
                    szPath);
            }
            
            Report_Time(Timer.GetElapsedSec());
            
        }
        else
        {
            printf("CREATEINPROC: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void CreateOutProc(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            Timer.Start();
            hr = pIWamAdmin->AppCreate(wszMetabasePath, FALSE);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("CREATEOUTPROC: Create out-proc application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                printf("CREATEOUTPROC: Create an out proc application on path %s successfully.\n",
                    szPath);
            }
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("CREATEOUTPROC: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void Delete(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {		
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            Timer.Start();
            hr = pIWamAdmin->AppDelete(wszMetabasePath, FALSE);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("DELETE: Delete application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }	
            else
            {
                printf("DELETE: Delete application on path %s successfully.\n",
                    szPath);
            }
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("DELETE: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void UnLoad(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            Timer.Start();
            hr = pIWamAdmin->AppUnLoad(wszMetabasePath, FALSE);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("UNLOAD: Unload application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                printf("UNLOAD: Unload application on path %s successfully.\n",
                    szPath);
            }
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("UNLOAD: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void GetStatus(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            DWORD dwStatus;
            
            Timer.Start();
            hr = pIWamAdmin->AppGetStatus(wszMetabasePath, &dwStatus);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("GETSTATUS: GetStatus of application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                if (dwStatus == APPSTATUS_NOTDEFINED)
                {
                    printf("Application on path %s is not defined. \n", szPath);
                }
                else if (dwStatus == APPSTATUS_STOPPED)
                {
                    printf("Application on path %s is stopped. \n", szPath);
                }
                else if (dwStatus == APPSTATUS_RUNNING)
                {
                    printf("Application on path %s is running. \n", szPath);
                }
                else
                {
                    printf("Application on path %s is in unknown state. \n", szPath);
                }
                
                Report_Time(Timer.GetElapsedSec());
            }	
        }
        else
        {
            printf("GETSTATUS: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void DeleteRecoverable(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            DWORD dwStatus;
            
            Timer.Start();
            hr = pIWamAdmin->AppDeleteRecoverable(wszMetabasePath, TRUE);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("DELETEREC: AppDeleteRecoverable of application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                printf("DeleteRecoverable call on path %s succeeded.\n", szPath, hr);
            }			
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("DELETEREC: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}


void Recover(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            DWORD dwStatus;
            
            Timer.Start();
            hr = pIWamAdmin->AppRecover(wszMetabasePath, TRUE);
            Timer.Stop();
            
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("Recover: Recover application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                printf("Recover call on path %s succeeded.\n", szPath, hr);
            }					
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("Recover: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void GetSignature()
{
    HRESULT		hr = NOERROR;
    IMSAdminReplication*	pIWamRep = NULL;
    DWORD		dwRequiredSize = 0;
    DWORD		dwBufferSize = sizeof(DWORD);
    DWORD		dwBuffer;
    
    CStopWatch  Timer;
    
    Timer.Reset();
    hr = CoCreateInstance(CLSID_WamAdmin,
        NULL,
        CLSCTX_SERVER,
        IID_IMSAdminReplication,
        (void **)&pIWamRep);
    if (SUCCEEDED(hr))
    {
        DWORD dwStatus;
        
        Timer.Start();
        hr = pIWamRep->GetSignature(dwBufferSize, (BYTE *)&dwBuffer, &dwRequiredSize);
        Timer.Stop();
        
        Report_Time(Timer.GetElapsedSec());
        
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            BYTE *pbBuffer = NULL;
            
            pbBuffer = new BYTE [dwRequiredSize];
            if (pbBuffer)
            {
                Timer.Reset();
                Timer.Start();
                hr = pIWamRep->GetSignature(dwRequiredSize, pbBuffer, &dwRequiredSize);
                Timer.Stop();
                
                Report_Time(Timer.GetElapsedSec());
                if (SUCCEEDED(hr))
                {
                    BYTE  *pbTemp = pbBuffer;
                    DWORD cTotalSize = 0;
                    
                    for (INT iSignature = 0; cTotalSize < dwRequiredSize; iSignature++)
                    {
                        printf("Signature buffer[%d]: Signature = %08x\n",
                            iSignature,
                            *(DWORD*)pbTemp);
                        
                        pbTemp += sizeof(DWORD);
                        cTotalSize += sizeof(DWORD);
                    }
                    
                    printf("TotalSize = %d, RequiredSize = %d \n", 
                        cTotalSize,
                        dwRequiredSize);
                }
                else
                {
                    printf("GetSignature failed, step 2, hr = %s\n",
                        hr);
                }
            }
            else
            {
                printf("GetSignature Out of memory.\n");
            }
        }
        
        pIWamRep->Release();
        if (FAILED(hr))
        {
            printf("GetSignature failed, hr = %08x\n",
                hr);
        }
        else
        {
            printf("GetSignature succeeded, signature is %08x\n", dwBuffer);
        }					
    }
    return;
}

void Serialize()
{
    HRESULT		hr = NOERROR;
    IMSAdminReplication*	pIWamRep = NULL;
    BYTE		bBufferTemp[4];
    DWORD		dwRequiredSize = 0;
    DWORD		dwBufferSize = 0;
    BYTE*		pbBuffer = NULL;
    CStopWatch  Timer;
    
    Timer.Reset();
    hr = CoCreateInstance(CLSID_WamAdmin,
        NULL,
        CLSCTX_SERVER,
        IID_IMSAdminReplication,
        (void **)&pIWamRep);
    if (SUCCEEDED(hr))
    {
        DWORD dwStatus;
        
        Timer.Start();
        
        hr = pIWamRep->Serialize(dwBufferSize, bBufferTemp, &dwRequiredSize);
        
        Timer.Stop();
        Report_Time(Timer.GetElapsedSec());
        
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            pbBuffer = new BYTE [dwRequiredSize];
            if (pbBuffer)
            {
                BYTE  *pbTemp = pbBuffer;
                DWORD cTotalBytes = 0;
                DWORD cRecBytes = 0;
                WCHAR *szProgID = NULL;
                WCHAR *szWAMCLSID = NULL;
                WCHAR *szPath = NULL;
                
                Timer.Start();
                hr = pIWamRep->Serialize(dwRequiredSize, pbBuffer, &dwRequiredSize);
                
                
                Timer.Stop();
                Report_Time(Timer.GetElapsedSec());
                
                if (SUCCEEDED(hr))
                {
                    pbTemp = pbBuffer;
                    
                    while (*(DWORD*)pbTemp != 0x0 && SUCCEEDED(hr))
                    {
                        cRecBytes = *(DWORD*)pbTemp;
                        pbTemp += sizeof(DWORD);
                        
                        szWAMCLSID = (WCHAR *)pbTemp;
                        pbTemp += uSizeCLSID*sizeof(WCHAR);
                        
                        szPath = (WCHAR *)pbTemp;
                        pbTemp += cRecBytes - uSizeCLSID*sizeof(WCHAR) - sizeof(DWORD);
                        
                        printf("Serialize: Path = %S, WAMCLSID = %S, \n",
                            szPath,
                            szWAMCLSID);
                    }
                }
                else
                {
                    printf("Serialize failed, step 2, hr = %s\n",
                        hr);
                }
                
                delete [] pbBuffer;
                pbBuffer = NULL;
            }
            else
            {
                printf("Serialize failed, out of memory.\n");
            }
            
        }
        pIWamRep->Release();				
    }
    return;
}

void HELPER2(IIISApplicationAdmin ** ppIAdmin, WCHAR * pwszMetabasePath)
{
    HRESULT		hr = NOERROR;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, g_Command.szMetabasePath, -1, pwszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IIISApplicationAdmin,
            (void **)ppIAdmin);
        if (FAILED(hr))
        {
            printf("CoCreateFailed, in HELPER2, hr = %08x\n", hr);
        }

    }
}

void CREATE2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;

    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->CreateApplication(wszMetabasePath, eAppRunOutProcIsolated, L"TestAppPool", TRUE);
    if (FAILED(hr))
    {
        printf("CreateApplication Failed, in CREATE2, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}


void DELETE2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->DeleteApplication(wszMetabasePath, FALSE);
    if (FAILED(hr))
    {
        printf("DeleteApplication Failed, in DELETE2, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}

void CREATEPOOL2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->CreateApplicationPool(wszMetabasePath);
    if (FAILED(hr))
    {
        printf("CreateApplicationPool Failed, in CREATEPOOL2, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}

void DELETEPOOL2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->DeleteApplicationPool(wszMetabasePath);
    if (FAILED(hr))
    {
        printf("DeleteApplicationPool Failed, in DELETEPOOL2, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}

void ENUMPOOL2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);
    
    BSTR bstr;
    hr = pIAdmin->EnumerateApplicationsInPool(wszMetabasePath, &bstr);
    if (FAILED(hr))
    {
        printf("EnumerateApplicationsInPool Failed, in second call, hr = %08x\n", hr);
    }

    pIAdmin->Release();

    const WCHAR * pTestBuf = bstr;
    
    while (pTestBuf[0])
    {
        printf("%S\nnext\n", pTestBuf);
        
        // move pTestBuf beyond end of this string, including NULL terminator.
        pTestBuf += wcslen(pTestBuf) + 1;
    }

    SysFreeString(bstr);

    Report_Time(Timer.GetElapsedSec());
    return;
}

void RECYCLEPOOL()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->RecycleApplicationPool(wszMetabasePath);
    if (FAILED(hr))
    {
        printf("RecycleApplicationPool Failed, in RECYCLEPOOL, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}

void GETMODE()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);

    DWORD dwMode = 0;

    hr = pIAdmin->GetProcessMode(&dwMode);
    if (FAILED(hr))
    {
        printf("GetProcessMode Failed, in GETMODE, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    printf("Mode is: %08x\n", dwMode);

    Report_Time(Timer.GetElapsedSec());
    return;
}

#include <iadmw.h>

void TestConn()
{
    HRESULT hr = S_OK;
    IMSAdminBase * pAdminBase = NULL;
    IConnectionPointContainer * pConnPointContainer = NULL;
    IConnectionPoint * pConnPoint = NULL;
    DWORD dwSinkNotifyCookie;

    hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
        IID_IMSAdminBase, (void**) &pAdminBase);
    if (FAILED(hr))
    {
        printf("couldn't cocreate\n");
        return;
    }
    
    hr = pAdminBase->QueryInterface(IID_IConnectionPointContainer,
        (void**) &pConnPointContainer);
    if (FAILED(hr))
    {
        printf("couldn't QI\n");
        return;
    }
    
    hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink,
        &pConnPoint);
    if (FAILED(hr))
    {
        printf("couldn't findconnpoint\n");
        return;
    }
    
    hr = pConnPoint->Advise(NULL, &dwSinkNotifyCookie);
    if (FAILED(hr))
    {
        printf("couldn't advise\n");
        return;
    }
    
    printf("advised ok\n");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamregps\wamreg_i_stub.c ===
#include "wamreg_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamregps\wamreg_p_stub.c ===
#include "wamreg_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamregps\wmrgsv_i_stub.c ===
#include "wmrgsv_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamregps\wmrgsv_p_stub.c ===
#include "wmrgsv_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\wamreg\vptool\util.h ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: util.cpp

Owner: leijin

Description:
Contains utility functions used by vptool.
    Including Debugging, timing, helping functions.

Note:
===================================================================*/

#ifndef _VPTOOL_UTIL_H_
#define _VPTOOL_UTIL_H_

#include <stdio.h>
#include <wtypes.h>

enum eCommand 
{ 
	eCommand_INSTALL = 1,
	eCommand_UNINSTALL,
	eCommand_UPGRADE,
	eCommand_CREATEINPROC,
	eCommand_CREATEOUTPROC,
	eCommand_CREATEINPOOL,
	eCommand_DELETE,
	eCommand_GETSTATUS,
	eCommand_UNLOAD,
	eCommand_DELETEREC,
	eCommand_RECOVER,
	eCommand_GETSIGNATURE,
	eCommand_SERIALIZE,
	eCommand_DESERIALIZE,
	eCommand_HELP,
        eCommand_2CREATE,
        eCommand_2DELETE,
        eCommand_2CREATEPOOL,
        eCommand_2DELETEPOOL,
        eCommand_2ENUMPOOL,
        eCommand_2RECYCLEPOOL,
        eCommand_2GETMODE,
        eCommand_2TestConn
};
		
struct CommandParam
{
	eCommand	eCmd;
	char		*szCommandLineSwitch;	
	char		*szMetabasePath;
	bool		fRequireMDPath;
};
typedef struct CommandParam CommandParam;

BOOL 	ParseCommandLine(int argc, char **argv);
void 	PrintHelp(BOOL fAdvanced = FALSE);

DWORD	Timer();
VOID	Report_Time(double ElaspedSec);

extern	const UINT rgComMax;
extern	CommandParam g_Command;

//
//
struct VP_Options
{
	BOOL	fEnableTimer;
};

extern	VP_Options	g_Options;


//-----------------------------------------------------------------------------
// CStopWatch
//-----------------------------------------------------------------------------

// This class implements a simple stopwatch timer.

class CStopWatch
{
public:
	CStopWatch()
	{
		Reset();
	}

	//~CStopWatch()
	//{ }

	void Start()
	{
		QueryPerformanceCounter( (LARGE_INTEGER *) &m_liBeg );
	}

	void Stop()
	{
		//LARGE_INTEGER liTmp;
		__int64 liEnd;
		QueryPerformanceCounter( (LARGE_INTEGER *) &liEnd );
		m_liTotal += liEnd - m_liBeg;
	}

	void Reset()
	{
		m_liBeg = m_liTotal = 0;
	}
	
	// Return time in seconds.
	double GetElapsedSec()
	{
		//LARGE_INTEGER liFreq;
		__int64 liFreq;
		QueryPerformanceFrequency( (LARGE_INTEGER *) &liFreq );	// Counts/sec
		if (liFreq == 0)
		{
			// Who knows?  Hardware does not support.
			// Maybe millisec?
			// This is rare; modern PC's return liFreq.
			liFreq = 1000;
		}
		return (double) m_liTotal / (double) liFreq;
	}

private:
	//LARGE_INTEGER m_liBeg;
	//LARGE_INTEGER m_liTotal;
	__int64 m_liBeg;
	__int64 m_liTotal;
};

#endif	// _VPTOOL_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	May 30, 1997
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      BasePage.cpp
//
//  Abstract:
//      Implementation of the CBasePropertyPage class.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "IISClEx4.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"
#include "PropList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePropertyPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBasePropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CBasePropertyPage)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(void)
{
    CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pmap            [IN] Control to help ID map.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN const CMapCtrlToHelpID * pmap
    )
    : m_dlghelp(pmap, 0)
{
    CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pmap            [IN] Control to help ID map.
//      nIDTemplate     [IN] Dialog template resource ID.
//      nIDCaption      [IN] Caption string resource ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN const CMapCtrlToHelpID * pmap,
    IN UINT                     nIDTemplate,
    IN UINT                     nIDCaption
    )
    : CPropertyPage(nIDTemplate, nIDCaption)
    , m_dlghelp(pmap, nIDTemplate)
{
    CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct(void)
{
    //{{AFX_DATA_INIT(CBasePropertyPage)
    //}}AFX_DATA_INIT

    m_peo = NULL;
    m_hpage = NULL;
    m_bBackPressed = FALSE;
	m_bDoDetach = FALSE;

    m_iddPropertyPage = NULL;
    m_iddWizardPage = NULL;
    m_idcPPTitle = NULL;
    m_idsCaption = NULL;

}  //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BInit(IN OUT CExtObject * peo)
{
    ASSERT(peo != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_peo = peo;

    // Don't display a help button.
    m_psp.dwFlags &= ~PSP_HASHELP;

    // Construct the property page.
    if (Peo()->BWizard())
    {
        ASSERT(IddWizardPage() != NULL);
        Construct(IddWizardPage(), IdsCaption());
        m_dlghelp.SetHelpMask(IddWizardPage());
    }  // if:  adding page to wizard
    else
    {
        ASSERT(IddPropertyPage() != NULL);
        Construct(IddPropertyPage(), IdsCaption());
        m_dlghelp.SetHelpMask(IddPropertyPage());
    }  // else:  adding page to property sheet

    // Read the properties private to this resource and parse them.
    {
        DWORD           dwStatus;
        CClusPropList   cpl;

        ASSERT(Peo() != NULL);
        ASSERT(Peo()->PrdResData() != NULL);
        ASSERT(Peo()->PrdResData()->m_hresource != NULL);

        // Read the properties.
        dwStatus = cpl.DwGetResourceProperties(
                                Peo()->PrdResData()->m_hresource,
                                CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                                );

        // Parse the properties.
        if (dwStatus == ERROR_SUCCESS)
        {
            // Parse the properties.
            try
            {
                dwStatus = DwParseProperties(cpl);
            }  // try
            catch (CMemoryException * pme)
            {
                dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                pme->Delete();
            }  // catch:  CMemoryException
        }  // if:  properties read successfully

        if (dwStatus != ERROR_SUCCESS)
        {
            return FALSE;
        }  // if:  error parsing getting or parsing properties
    }  // Read the properties private to this resource and parse them

    return TRUE;

}  //*** CBasePropertyPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwParseProperties
//
//  Routine Description:
//      Parse the properties of the resource.  This is in a separate function
//      from BInit so that the optimizer can do a better job.
//
//  Arguments:
//      rcpl            [IN] Cluster property list to parse.
//
//  Return Value:
//      ERROR_SUCCESS   Properties were parsed successfully.
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwParseProperties(IN const CClusPropList & rcpl)
{
    DWORD                           cProps;
    DWORD                           cprop;
    const CObjectProperty *         pprop;
    CLUSPROP_BUFFER_HELPER          props;
    CLUSPROP_PROPERTY_NAME const *  pName;

    ASSERT(rcpl.PbProplist() != NULL);

    props.pb = rcpl.PbProplist();

    // Loop through each property.
    for (cProps = *(props.pdw++) ; cProps > 0 ; cProps--)
    {
        pName = props.pName;
        ASSERT(pName->Syntax.dw == CLUSPROP_SYNTAX_NAME);
        props.pb += sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

        // Parse known properties.
        for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
        {
            if (lstrcmpiW(pName->sz, pprop->m_pwszName) == 0)
            {
                ASSERT(props.pSyntax->wFormat == pprop->m_propFormat);
                switch (pprop->m_propFormat)
                {
                    case CLUSPROP_FORMAT_SZ:
                        *pprop->m_value.pstr = props.pStringValue->sz;
                        *pprop->m_valuePrev.pstr = props.pStringValue->sz;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                        *pprop->m_value.pdw = props.pDwordValue->dw;
                        *pprop->m_valuePrev.pdw = props.pDwordValue->dw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        *pprop->m_value.ppb = props.pBinaryValue->rgb;
                        *pprop->m_value.pcb = props.pBinaryValue->cbLength;
                        *pprop->m_valuePrev.ppb = props.pBinaryValue->rgb;
                        *pprop->m_valuePrev.pcb = props.pBinaryValue->cbLength;
                        break;
                    default:
                        ASSERT(0);  // don't know how to deal with this type
                }  // switch:  property format

                // Exit the loop since we found the parameter.
                break;
            }  // if:  found a match
        }  // for:  each property

        // If the property wasn't known, ask the derived class to parse it.
        if (cprop == 0)
        {
            DWORD       dwStatus;

            dwStatus = DwParseUnknownProperty(pName->sz, props);
            if (dwStatus != ERROR_SUCCESS)
                return dwStatus;
        }  // if:  property not parsed

        // Advance the pointer.
        if ((props.pSyntax->wFormat == CLUSPROP_FORMAT_BINARY)
                || (props.pSyntax->wFormat == CLUSPROP_FORMAT_SZ)
                || (props.pSyntax->wFormat == CLUSPROP_FORMAT_MULTI_SZ))
            props.pb += sizeof(*props.pBinaryValue)
                        + ALIGN_CLUSPROP(props.pBinaryValue->cbLength)
                        + sizeof(*props.pSyntax); // endmark
        else if (props.pSyntax->wFormat == CLUSPROP_FORMAT_DWORD)
            props.pb += sizeof(*props.pDwordValue) + sizeof(*props.pSyntax);
        else
        {
            ASSERT(0); // Unknown property syntax
            break;
        }  // else:  unknown property format
    }  // for:  each property

    return ERROR_SUCCESS;

}  //*** CBasePropertyPage::DwParseProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCreate
//
//	Routine Description:
//		Handler for the WM_CREATE message.
//
//	Arguments:
//		lpCreateStruct	[IN OUT] Window create structure.
//
//	Return Value:
//		-1		Error.
//		0		Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Attach the window to the property page structure.
	// This has been done once already in the main application, since the
	// main application owns the property sheet.  It needs to be done here
	// so that the window handle can be found in the DLL's handle map.
	if (FromHandlePermanent(m_hWnd) == NULL) // is the window handle already in the handle map
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach(hWnd);
		m_bDoDetach = TRUE;
	} // if: is the window handle in the handle map

	return CPropertyPage::OnCreate(lpCreateStruct);

}  //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnDestroy
//
//	Routine Description:
//		Handler for the WM_DESTROY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Detach the window from the property page structure.
	// This will be done again by the main application, since it owns the
	// property sheet.  It needs to be done here so that the window handle
	// can be removed from the DLL's handle map.
	if (m_bDoDetach)
	{
		if (m_hWnd != NULL)
		{
			HWND hWnd = m_hWnd;

			Detach();
			m_hWnd = hWnd;
		} // if: do we have a window handle?
	} // if: do we need to balance the attach we did with a detach?

	CPropertyPage::OnDestroy();

}  //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange(CDataExchange * pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBasePropertyPage)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    DDX_Control(pDX, IDC_PP_ICON, m_staticIcon);
    DDX_Control(pDX, m_idcPPTitle, m_staticTitle);

    if (!pDX->m_bSaveAndValidate)
    {
        // Set the title.
        DDX_Text(pDX, m_idcPPTitle, m_strTitle);
    }  // if:  not saving data

}  //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog(void)
{
    ASSERT(Peo() != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Set the title string.
    m_strTitle = Peo()->RrdResData().m_strName;

    // Call the base class method.
    CPropertyPage::OnInitDialog();

    // Display an icon for the object.
    if (Peo()->Hicon() != NULL)
        m_staticIcon.SetIcon(Peo()->Hicon());

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive(void)
{
    HRESULT     hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Reread the data.
    hr = Peo()->HrGetObjectInfo();
    if (hr != NOERROR)
        return FALSE;

    // Set the title string.
    m_strTitle = Peo()->RrdResData().m_strName;

    m_bBackPressed = FALSE;
    return CPropertyPage::OnSetActive();

}  //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnApply
//
//  Routine Description:
//      Handler for the PSM_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply(void)
{
    ASSERT(!BWizard());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Update the data in the class from the page.
    UpdateData(/*bSaveAndValidate*/);

    if (!BApplyChanges())
        return FALSE;

    return CPropertyPage::OnApply();

}  //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardBack
//
//  Routine Description:
//      Handler for the PSN_WIZBACK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack(void)
{
    LRESULT     lResult;

    ASSERT(BWizard());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    lResult = CPropertyPage::OnWizardBack();
    if (lResult != -1)
        m_bBackPressed = TRUE;

    return lResult;

}  //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardNext
//
//  Routine Description:
//      Handler for the PSN_WIZNEXT message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext(void)
{
    ASSERT(BWizard());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Update the data in the class from the page.
    UpdateData(/*bSaveAndValidate*/);

    // Save the data in the sheet.
    if (!BApplyChanges())
        return -1;

    // Create the object.

    return CPropertyPage::OnWizardNext();

}  //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardFinish
//
//  Routine Description:
//      Handler for the PSN_WIZFINISH message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      FALSE   Don't change the page.
//      TRUE    Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish(void)
{
    ASSERT(BWizard());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Update the data in the class from the page.
    UpdateData(/*bSaveAndValidate*/);

    // Save the data in the sheet.
    if (!BApplyChanges())
        return FALSE;

    return CPropertyPage::OnWizardFinish();

}  //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnChangeCtrl
//
//  Routine Description:
//      Handler for the messages sent when a control is changed.  This
//      method can be specified in a message map if all that needs to be
//      done is enable the Apply button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SetModified(TRUE);

}  //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::EnableNext
//
//  Routine Description:
//      Enables or disables the NEXT or FINISH button.
//
//  Arguments:
//      bEnable     [IN] TRUE = enable the button, FALSE = disable the button.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext(IN BOOL bEnable /*TRUE*/)
{
    ASSERT(BWizard());
    ASSERT(PiWizardCallback());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    PiWizardCallback()->EnableNext((LONG *) Hpage(), bEnable);

}  //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD           dwStatus    = ERROR_SUCCESS;
    CClusPropList   cpl(BWizard() /*bAlwaysAddProp*/);

    // Save data.
    {
        // Build the property list.
        try
        {
            BuildPropList(cpl);
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        }  // catch:  CMemoryException

        // Set the data.
        if (dwStatus == ERROR_SUCCESS)
            dwStatus = DwSetPrivateProps(cpl);

        // Handle errors.
        if (dwStatus != ERROR_SUCCESS)
        {
            CString     strError;
            CString     strMsg;

            AFX_MANAGE_STATE(AfxGetStaticModuleState());

            FormatError(strError, dwStatus);
            if (dwStatus == ERROR_RESOURCE_PROPERTIES_STORED)
            {
                AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
                dwStatus = ERROR_SUCCESS;
            }  // if:  properties were stored
            else
            {
                strMsg.FormatMessage(IDS_APPLY_PARAM_CHANGES_ERROR, strError);
                AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
            }  // else:  error setting properties.
        }  // if:  error setting properties

        if (dwStatus == ERROR_SUCCESS)
        {
            // Save new values as previous values.
            try
            {
                DWORD                   cprop;
                const CObjectProperty * pprop;

                for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
                {
                    switch (pprop->m_propFormat)
                    {
                        case CLUSPROP_FORMAT_SZ:
                            ASSERT(pprop->m_value.pstr != NULL);
                            ASSERT(pprop->m_valuePrev.pstr != NULL);
                            *pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
                            break;
                        case CLUSPROP_FORMAT_DWORD:
                            ASSERT(pprop->m_value.pdw != NULL);
                            ASSERT(pprop->m_valuePrev.pdw != NULL);
                            *pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
                            break;
                        case CLUSPROP_FORMAT_BINARY:
                        case CLUSPROP_FORMAT_MULTI_SZ:
                            ASSERT(pprop->m_value.ppb != NULL);
                            ASSERT(*pprop->m_value.ppb != NULL);
                            ASSERT(pprop->m_value.pcb != NULL);
                            ASSERT(pprop->m_valuePrev.ppb != NULL);
                            ASSERT(*pprop->m_valuePrev.ppb != NULL);
                            ASSERT(pprop->m_valuePrev.pcb != NULL);
                            delete [] *pprop->m_valuePrev.ppb;
                            *pprop->m_valuePrev.ppb = new BYTE[*pprop->m_value.pcb];
                            CopyMemory(*pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb);
                            *pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
                            break;
                        default:
                            ASSERT(0);  // don't know how to deal with this type
                    }  // switch:  property format
                }  // for:  each property
            }  // try
            catch (CMemoryException * pme)
            {
                pme->ReportError();
                pme->Delete();
            }  // catch:  CMemoryException
        }  // if:  properties set successfully
    }  // Save data

    return TRUE;

}  //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BuildPropList
//
//  Routine Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::AddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::BuildPropList(
    IN OUT CClusPropList & rcpl
    )
{
    DWORD                   cprop;
    const CObjectProperty * pprop;

    for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
    {
        switch (pprop->m_propFormat)
        {
            case CLUSPROP_FORMAT_SZ:
                rcpl.AddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pstr,
                        *pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_DWORD:
                rcpl.AddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pdw,
                        *pprop->m_valuePrev.pdw
                        );
                break;
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_MULTI_SZ:
                rcpl.AddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.ppb,
                        *pprop->m_value.pcb,
                        *pprop->m_valuePrev.ppb,
                        *pprop->m_valuePrev.pcb
                        );
                break;
            default:
                ASSERT(0);  // don't know how to deal with this type
                return;
        }  // switch:  property format
    }  // for:  each property

}  //*** CBasePropertyPage::BuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwSetPrivateProps
//
//  Routine Description:
//      Set the private properties for this object.
//
//  Arguments:
//      rcpl        [IN] Property list to set on the object.
//
//  Return Value:
//      ERROR_SUCCESS   The operation was completed successfully.
//      !0              Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwSetPrivateProps(
    IN const CClusPropList &    rcpl
    )
{
    DWORD       dwStatus;
    DWORD       cbProps;

    ASSERT(Peo() != NULL);
    ASSERT(Peo()->PrdResData());
    ASSERT(Peo()->PrdResData()->m_hresource);

    if ((rcpl.PbProplist() != NULL) && (rcpl.CbProplist() > 0))
    {
        // Set private properties.
        dwStatus = ClusterResourceControl(
                        Peo()->PrdResData()->m_hresource,
                        NULL,   // hNode
                        CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                        rcpl.PbProplist(),
                        rcpl.CbProplist(),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
        dwStatus = ERROR_SUCCESS;

    return dwStatus;

}  //*** CBasePropertyPage::DwSetPrivateProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwReadValue
//
//  Routine Description:
//      Read a REG_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      rstrValue       [OUT] String in which to return the value.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwReadValue(
    IN LPCTSTR      pszValueName,
    OUT CString &   rstrValue,
    IN HKEY         hkey
    )
{
    DWORD       dwStatus;
    LPWSTR      pwszValue   = NULL;
    DWORD       dwValueLen;
    DWORD       dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(hkey != NULL);

    rstrValue.Empty();

    try
    {
        // Get the size of the value.
        dwValueLen = 0;
        dwStatus = ::ClusterRegQueryValue(
                        hkey,
                        pszValueName,
                        &dwValueType,
                        NULL,
                        &dwValueLen
                        );
        if ((dwStatus == ERROR_SUCCESS) || (dwStatus == ERROR_MORE_DATA))
        {
            ASSERT(dwValueType == REG_SZ);

            // Allocate enough space for the data.
            pwszValue = rstrValue.GetBuffer(dwValueLen / sizeof(WCHAR));
            ASSERT(pwszValue != NULL);
            dwValueLen += 1 * sizeof(WCHAR);    // Don't forget the final null-terminator.

            // Read the value.
            dwStatus = ::ClusterRegQueryValue(
                            hkey,
                            pszValueName,
                            &dwValueType,
                            (LPBYTE) pwszValue,
                            &dwValueLen
                            );
            if (dwStatus == ERROR_SUCCESS)
            {
                ASSERT(dwValueType == REG_SZ);
            }  // if:  value read successfully
            rstrValue.ReleaseBuffer();
        }  // if:  got the size successfully
    }  // try
    catch (CMemoryException * pme)
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    return dwStatus;

}  //*** CBasePropertyPage::DwReadValue(LPCTSTR, CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwReadValue
//
//  Routine Description:
//      Read a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pdwValue        [OUT] DWORD in which to return the value.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwReadValue(
    IN LPCTSTR      pszValueName,
    OUT DWORD *     pdwValue,
    IN HKEY         hkey
    )
{
    DWORD       dwStatus;
    DWORD       dwValue;
    DWORD       dwValueLen;
    DWORD       dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwValue != NULL);
    ASSERT(hkey != NULL);

    *pdwValue = 0;

    // Read the value.
    dwValueLen = sizeof(dwValue);
    dwStatus = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    (LPBYTE) &dwValue,
                    &dwValueLen
                    );
    if (dwStatus == ERROR_SUCCESS)
    {
        ASSERT(dwValueType == REG_DWORD);
        ASSERT(dwValueLen == sizeof(dwValue));
        *pdwValue = dwValue;
    }  // if:  value read successfully

    return dwStatus;

}  //*** CBasePropertyPage::DwReadValue(LPCTSTR, DWORD*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwReadValue
//
//  Routine Description:
//      Read a REG_BINARY value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      ppbValue        [OUT] Pointer in which to return the data.  Caller
//                          is responsible for deallocating the data.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwReadValue(
    IN LPCTSTR      pszValueName,
    OUT LPBYTE *    ppbValue,
    IN HKEY         hkey
    )
{
    DWORD       dwStatus;
    DWORD       dwValueLen;
    DWORD       dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(ppbValue != NULL);
    ASSERT(hkey != NULL);

    *ppbValue = NULL;

    // Get the length of the value.
    dwValueLen = 0;
    dwStatus = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    NULL,
                    &dwValueLen
                    );
    if (dwStatus != ERROR_MORE_DATA)
        return dwStatus;

    ASSERT(dwValueType == REG_BINARY);

    // Allocate a buffer,
    try
    {
        *ppbValue = new BYTE[dwValueLen];
    }  // try
    catch (CMemoryException *)
    {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        return dwStatus;
    }  // catch:  CMemoryException

    // Read the value.
    dwStatus = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    *ppbValue,
                    &dwValueLen
                    );
    if (dwStatus != ERROR_SUCCESS)
    {
        delete [] *ppbValue;
        *ppbValue = NULL;
    }  // if:  value read successfully

    return dwStatus;

}  //*** CBasePropertyPage::DwReadValue(LPCTSTR, LPBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwWriteValue
//
//  Routine Description:
//      Write a REG_SZ value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      rstrValue       [IN] Value data.
//      rstrPrevValue   [IN OUT] Previous value.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      dwStatus
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwWriteValue(
    IN LPCTSTR          pszValueName,
    IN const CString &  rstrValue,
    IN OUT CString &    rstrPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       dwStatus;

    ASSERT(pszValueName != NULL);
    ASSERT(hkey != NULL);

    // Write the value if it hasn't changed.
    if (rstrValue != rstrPrevValue)
    {
        dwStatus = ::ClusterRegSetValue(
                        hkey,
                        pszValueName,
                        REG_SZ,
                        (CONST BYTE *) (LPCTSTR) rstrValue,
                        (rstrValue.GetLength() + 1) * sizeof(TCHAR)
                        );
        if (dwStatus == ERROR_SUCCESS)
            rstrPrevValue = rstrValue;
    }  // if:  value changed
    else
        dwStatus = ERROR_SUCCESS;
    return dwStatus;

}  //*** CBasePropertyPage::DwWriteValue(LPCTSTR, CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwWriteValue
//
//  Routine Description:
//      Write a REG_DWORD value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      dwValue         [IN] Value data.
//      pdwPrevValue    [IN OUT] Previous value.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      dwStatus
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwWriteValue(
    IN LPCTSTR          pszValueName,
    IN DWORD            dwValue,
    IN OUT DWORD *      pdwPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       dwStatus;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwPrevValue != NULL);
    ASSERT(hkey != NULL);

    // Write the value if it hasn't changed.
    if (dwValue != *pdwPrevValue)
    {
        dwStatus = ::ClusterRegSetValue(
                        hkey,
                        pszValueName,
                        REG_DWORD,
                        (CONST BYTE *) &dwValue,
                        sizeof(dwValue)
                        );
        if (dwStatus == ERROR_SUCCESS)
            *pdwPrevValue = dwValue;
    }  // if:  value changed
    else
        dwStatus = ERROR_SUCCESS;
    return dwStatus;

}  //*** CBasePropertyPage::DwWriteValue(LPCTSTR, DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwWriteValue
//
//  Routine Description:
//      Write a REG_BINARY value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pbValue         [IN] Value data.
//      cbValue         [IN] Size of value data.
//      ppbPrevValue    [IN OUT] Previous value.
//      cbPrevValue     [IN] Size of the previous data.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      dwStatus
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwWriteValue(
    IN LPCTSTR          pszValueName,
    IN const LPBYTE     pbValue,
    IN DWORD            cbValue,
    IN OUT LPBYTE *     ppbPrevValue,
    IN DWORD            cbPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       dwStatus;
    LPBYTE      pbPrevValue = NULL;

    ASSERT(pszValueName != NULL);
    ASSERT(pbValue != NULL);
    ASSERT(ppbPrevValue != NULL);
    ASSERT(cbValue > 0);
    ASSERT(hkey != NULL);

    // See if the data has changed.
    if (cbValue == cbPrevValue)
    {
        if (memcmp(pbValue, *ppbPrevValue, cbValue) == 0)
            return ERROR_SUCCESS;
    }  // if:  lengths are the same

    // Allocate a new buffer for the previous data pointer.
    try
    {
        pbPrevValue = new BYTE[cbValue];
    }
    catch (CMemoryException *)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException
    ::CopyMemory(pbPrevValue, pbValue, cbValue);

    // Write the value if it hasn't changed.
    dwStatus = ::ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_BINARY,
                    pbValue,
                    cbValue
                    );
    if (dwStatus == ERROR_SUCCESS)
    {
        delete [] *ppbPrevValue;
        *ppbPrevValue = pbPrevValue;
    }  // if:  set was successful
    else
        delete [] pbPrevValue;

    return dwStatus;

}  //*** CBasePropertyPage::DwWriteValue(LPCTSTR, const LPBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU message.
//
//  Arguments:
//      pWnd    Window in which user clicked the right mouse button.
//      point   Position of the cursor, in screen coordinates.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnHelpInfo
//
//  Routine Description:
//      Handler for the WM_HELPINFO message.
//
//  Arguments:
//      pHelpInfo   Structure containing info about displaying help.
//
//  Return Value:
//      TRUE        Help processed.
//      FALSE       Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo(HELPINFO * pHelpInfo)
{
    BOOL    bProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
    if (!bProcessed)
        bProcessed = CDialog::OnHelpInfo(pHelpInfo);
    return bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCommandHelp
//
//  Routine Description:
//      Handler for the WM_COMMANDHELP message.
//
//  Arguments:
//      wParam      [IN] WPARAM.
//      lParam      [IN] LPARAM.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    BOOL    bProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    bProcessed = (BOOL)m_dlghelp.OnCommandHelp(wParam, lParam);
    if (!bProcessed)
        bProcessed = (BOOL)CDialog::OnCommandHelp(wParam, lParam);

    return bProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Abstract:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Author:
//		David Potter (davidp)	October 2, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_INL_
#define _BASEPAGE_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

IWCWizardCallback * CBasePropertyPage::PiWizardCallback(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->PiWizardCallback();
}

BOOL CBasePropertyPage::BWizard(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->BWizard();
}

HCLUSTER CBasePropertyPage::Hcluster(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Hcluster();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      BasePage.h
//
//  Abstract:
//      Definition of the CBasePropertyPage class.  This class provides base
//      functionality for extension DLL property pages.
//
//  Implementation File:
//      BasePage.cpp
//      BasePage.inl
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"    // for CDialogHelp
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
    CBasePropertyPage(void);
    CBasePropertyPage(
        IN const CMapCtrlToHelpID * pmap
        );
    CBasePropertyPage(
        IN const CMapCtrlToHelpID * pmap,
        IN UINT                     nIDTemplate,
        IN UINT                     nIDCaption = 0
        );
    virtual ~CBasePropertyPage(void) { }

    // Second phase construction.
    virtual BOOL        BInit(IN OUT CExtObject * peo);

protected:
    void                CommonConstruct(void);

// Attributes
protected:
    CExtObject *        m_peo;
    HPROPSHEETPAGE      m_hpage;

    IDD                 m_iddPropertyPage;
    IDD                 m_iddWizardPage;
    IDC                 m_idcPPTitle;
    IDS                 m_idsCaption;

    CExtObject *        Peo(void) const                 { return m_peo; }
    HPROPSHEETPAGE      Hpage(void) const               { return m_hpage; }

    IDD                 IddPropertyPage(void) const     { return m_iddPropertyPage; }
    IDD                 IddWizardPage(void) const       { return m_iddWizardPage; }
    IDS                 IdsCaption(void) const          { return m_idsCaption; }

public:
    void                SetHpage(IN OUT HPROPSHEETPAGE hpage) { m_hpage = hpage; }

// Dialog Data
    //{{AFX_DATA(CBasePropertyPage)
    enum { IDD = 0 };
    //}}AFX_DATA
    CStatic m_staticIcon;
    CStatic m_staticTitle;
    CString m_strTitle;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CBasePropertyPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
    virtual LRESULT OnWizardBack();
    virtual LRESULT OnWizardNext();
    virtual BOOL OnWizardFinish();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual DWORD           DwParseUnknownProperty(
                                IN LPCWSTR                          pwszName,
                                IN const CLUSPROP_BUFFER_HELPER &   rvalue
                                )       { return ERROR_SUCCESS; }
    virtual BOOL            BApplyChanges(void);
    virtual void            BuildPropList(IN OUT CClusPropList & rcpl);

    virtual const CObjectProperty * Pprops(void) const  { return NULL; }
    virtual DWORD                   Cprops(void) const  { return 0; }

// Implementation
protected:
    BOOL                    m_bBackPressed;
    BOOL					m_bDoDetach;

    BOOL                    BBackPressed(void) const        { return m_bBackPressed; }
    IWCWizardCallback *     PiWizardCallback(void) const;
    BOOL                    BWizard(void) const;
    HCLUSTER                Hcluster(void) const;
    void                    EnableNext(IN BOOL bEnable = TRUE);

    DWORD                   DwParseProperties(IN const CClusPropList & rcpl);
    DWORD                   DwSetPrivateProps(IN const CClusPropList & rcpl);

    DWORD                   DwReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT CString &       rstrValue,
                                IN HKEY             hkey
                                );
    DWORD                   DwReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT DWORD *         pdwValue,
                                IN HKEY             hkey
                                );
    DWORD                   DwReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT LPBYTE *        ppbValue,
                                IN HKEY             hkey
                                );

    DWORD                   DwWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const CString &  rstrValue,
                                IN OUT CString &    rstrPrevValue,
                                IN HKEY             hkey
                                );
    DWORD                   DwWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN DWORD            dwValue,
                                IN OUT DWORD *      pdwPrevValue,
                                IN HKEY             hkey
                                );
    DWORD                   DwWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const LPBYTE     pbValue,
                                IN DWORD            cbValue,
                                IN OUT LPBYTE *     ppbPrevValue,
                                IN DWORD            cbPrevValue,
                                IN HKEY             hkey
                                );

    void                    SetHelpMask(IN DWORD dwMask)    { m_dlghelp.SetHelpMask(dwMask); }
    CDialogHelp             m_dlghelp;

    // Generated message map functions
    //{{AFX_MSG(CBasePropertyPage)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnChangeCtrl();
    DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\dlghelp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      DlgHelp.cpp
//
//  Abstract:
//      Implementation of the CDialogHelp class.
//
//  Author:
//      David Potter (davidp)   February 6, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagDlgHelp(_T("Help"), _T("DLG HELP"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CDialogHelp, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::CDialogHelp
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pmap        [IN] Map array mapping control IDs to help IDs.
//      dwMask      [IN] Mask to use for the low word of the help ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDialogHelp::CDialogHelp(IN const CMapCtrlToHelpID * pmap, IN DWORD dwMask)
{
    ASSERT(pmap != NULL);

    CommonConstruct();
    m_pmap = pmap;
    m_dwMask = dwMask;

}  //*** CDialogHelp::CDialogHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::CommonConstruct
//
//  Routine Description:
//      Do common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::CommonConstruct(void)
{
    m_pmap = NULL;

}  //*** CDialogHelp::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::NHelpFromCtrlID
//
//  Routine Description:
//      Return the help ID from a control ID.
//
//  Arguments:
//      nCtrlID     [IN] ID of control to search for.
//
//  Return Value:
//      nHelpID     Help ID associated with the control.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDialogHelp::NHelpFromCtrlID(IN DWORD nCtrlID) const
{
    DWORD                       nHelpID = 0;
    const CMapCtrlToHelpID *    pmap = Pmap();

    ASSERT(pmap != NULL);
    ASSERT(nCtrlID != 0);

    for ( ; pmap->m_nCtrlID != 0 ; pmap++)
    {
        if (pmap->m_nCtrlID == nCtrlID)
        {
            if (pmap->m_nHelpCtrlID == -1)
                nHelpID = (DWORD) -1;
            else
                //nHelpID = (pmap->m_nHelpCtrlID << 16) | (DwMask() & 0xFFFF);
                nHelpID = pmap->m_nHelpCtrlID;
            break;
        }  // if:  found a match
    }  // for:  each control

    Trace(g_tagDlgHelp, _T("NHelpFromCtrlID() - nCtrlID = %x, nHelpID = %x"), nCtrlID, nHelpID);

    return nHelpID;

}  //*** CDialogHelp::NHelpFromCtrlID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU message.
//
//  Arguments:
//      pWnd    Window in which user clicked the right mouse button.
//      point   Position of the cursor, in screen coordinates.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::OnContextMenu(CWnd * pWnd, CPoint point)
{
    CWnd *  pwndChild;
    CPoint  ptDialog;
    DWORD   nHelpID = 0;

    ASSERT(pWnd != NULL);

    m_nHelpID = 0;

    // Convert the point into dialog coordinates.
    ptDialog = point;
    pWnd->ScreenToClient(&ptDialog);

    // Find the control the cursor is over.
    {
        DWORD   nCtrlID;

        pwndChild = pWnd->ChildWindowFromPoint(ptDialog);
        if (pwndChild != NULL && pwndChild->m_hWnd != NULL)
        {
            nCtrlID = pwndChild->GetDlgCtrlID();
            if (nCtrlID != 0)
                nHelpID = NHelpFromCtrlID(nCtrlID);
        }  // if:  over a child window
    }  // Find the control the cursor is over

    // Display a popup menu.
    if ((nHelpID != 0) && (nHelpID != -1))
    {
        CString strMenu;
        CMenu   menu;

        try
        {
            strMenu.LoadString(IDS_MENU_WHATS_THIS);
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            return;
        }  // catch:  CMemoryException

        if (menu.CreatePopupMenu())
        {
            if (menu.AppendMenu(MF_STRING | MF_ENABLED, ID_HELP, strMenu))
            {
                m_nHelpID = nHelpID;
                menu.TrackPopupMenu(
                    TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                    point.x,
                    point.y,
                    AfxGetMainWnd()
                    );
            }  // if:  menu item added successfully
            menu.DestroyMenu();
        }  // if:  popup menu created successfully
    }  // if:  over a child window of this dialog with a tabstop

}  //*** CDialogHelp::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::OnHelpInfo
//
//  Routine Description:
//      Handler for the WM_HELPINFO message.
//
//  Arguments:
//      pHelpInfo   Structure containing info about displaying help.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDialogHelp::OnHelpInfo(HELPINFO * pHelpInfo)
{
    // If this is for a control, display control-specific help.
    if ((pHelpInfo->iContextType == HELPINFO_WINDOW)
            && (pHelpInfo->iCtrlId != 0))
    {
        DWORD   nHelpID = NHelpFromCtrlID(pHelpInfo->iCtrlId);
        if (nHelpID != 0)
        {
            if (nHelpID != -1)
                AfxGetApp()->WinHelp(nHelpID, HELP_CONTEXTPOPUP);
            return TRUE;
        }  // if:  found the control in the list
    }  // if:  need help on a specific control

    // Display dialog help.
    return FALSE;

}  //*** CDialogHelp::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::OnCommandHelp
//
//  Routine Description:
//      Handler for the WM_COMMANDHELP message.
//
//  Arguments:
//      WPARAM      [IN] Passed on to base class method.
//      lParam      [IN] Help ID.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CDialogHelp::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    if (m_nHelpID != 0)
        lParam = m_nHelpID;
    AfxGetApp()->WinHelp((DWORD)lParam, HELP_CONTEXTPOPUP);
    return TRUE;
//  return CDialog::OnCommandHelp(wParam, lParam);

}  //*** CDialogHelp::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\constdef.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      ConstDef.h
//
//  Abstract:
//      Definitions of constants used in the IIS Cluster Administrator
//      extension.
//
//  Author:
//      David Potter (davidp)   March 7, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CONSTDEF_H_
#define _CONSTDEF_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_IIS_SERVICE_NAME               _T("ServiceName")
#define REGPARAM_IIS_DIRECTORY                  _T("Directory")
#define REGPARAM_IIS_INSTANCEID                 _T("InstanceId")
#define REGPARAM_IIS_ACCOUNTNAME                _T("AccountName")
#define REGPARAM_IIS_PASSWORD                   _T("Password")
#define REGPARAM_IIS_ACCESSMASK                 _T("AccessMask")

#define RESTYPE_NAME_IIS_VIRTUAL_ROOT           _T("IIS Server Instance")
#define RESTYPE_NAME_SMTP_VIRTUAL_ROOT          _T("SMTP Server Instance")
#define RESTYPE_NAME_NNTP_VIRTUAL_ROOT          _T("NNTP Server Instance")

#define IIS_SVC_NAME_FTP                        _T("MSFTPSVC")
#define IIS_SVC_NAME_WWW                        _T("W3SVC")
#define IIS_SVC_NAME_SMTP                       _T("SMTPSVC")
#define IIS_SVC_NAME_NNTP                       _T("NNTPSVC")

#define MD_SERVICE_ROOT_FTP                     _T("LM/MSFTPSVC")
#define MD_SERVICE_ROOT_WWW                     _T("LM/W3SVC")
#define MD_SERVICE_ROOT_SMTP                    _T("LM/SMTPSVC")
#define MD_SERVICE_ROOT_NNTP                    _T("LM/NNTPSVC")

/////////////////////////////////////////////////////////////////////////////

#endif // _CONSTDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Abstract:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Author:
//		David Potter (davidp)	September 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DDXDDV_H_
#define _DDXDDV_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _DDXDDV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.cpp
//
//	Abstract:
//		Implementation of custom dialog data exchange/dialog data validation
//		routines.
//
//	Author:
//		David Potter (davidp)	September 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DDxDDv.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_Number
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		dwValue		[IN OUT] Value to set or get.
//		dwMin		[IN] Minimum value.
//		dwMax		[IN] Maximum value.
//		bSigned		[IN] TRUE = value is signed, FALSE = value is unsigned
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned
	)
{
	HWND	hwndCtrl;
	DWORD	dwValue;

	ASSERT(pDX != NULL);
	ASSERT(dwMin < dwMax);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Get the control window handle.
	hwndCtrl = pDX->PrepareEditCtrl(nIDC);

	if (pDX->m_bSaveAndValidate)
	{
		BOOL	bTranslated;

		dwValue = GetDlgItemInt(pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned);
		if (!bTranslated
				|| (dwValue < dwMin)
				|| (dwValue > dwMax)
				)
		{
			TCHAR szMin[32];
			TCHAR szMax[32];
			CString strPrompt;

			wsprintf(szMin, _T("%lu%"), dwMin);
			wsprintf(szMax, _T("%lu%"), dwMax);
			AfxFormatString2(strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE);
			strPrompt.Empty(); // exception prep
			pDX->Fail();
		}  // if:  invalid string
		else
			rdwValue = dwValue;
	}  // if:  saving data
	else
	{
		CString		strMaxValue;

		// Set the maximum number of characters that can be entered.
		if (bSigned)
			strMaxValue.Format(_T("%ld"), dwMax);
		else
			strMaxValue.Format(_T("%lu"), dwMax);
		SendMessage(hwndCtrl, EM_LIMITTEXT, strMaxValue.GetLength(), 0);

		// Set the value into the control.
		DDX_Text(pDX, nIDC, rdwValue);
	}  // else:  setting data onto the dialog

}  //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_RequiredText
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		nIDCLabel	[IN] Label control ID.
//		rstrValue	[IN] Value to set or get.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	)
{
	ASSERT(pDX != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (pDX->m_bSaveAndValidate)
	{
		if (rstrValue.GetLength() == 0)
		{
			HWND		hwndLabel;
			TCHAR		szLabel[1024];
			TCHAR		szStrippedLabel[1024];
			int			iSrc;
			int			iDst;
			TCHAR		ch;
			CString		strPrompt;

			// Get the label window handle
			hwndLabel = pDX->PrepareEditCtrl(nIDCLabel);

			// Get the text of the label.
			GetWindowText(hwndLabel, szLabel, sizeof(szLabel) / sizeof(TCHAR));

			// Remove ampersands (&) and colons (:).
			for (iSrc = 0, iDst = 0 ; szLabel[iSrc] != _T('\0') ; iSrc++)
			{
				ch = szLabel[iSrc];
				if ((ch != _T('&')) && (ch != _T(':')))
					szStrippedLabel[iDst++] = ch;
			}  // for:  each character in the label
			szStrippedLabel[iDst] = _T('\0');

			// Format and display a message.
			strPrompt.FormatMessage(IDS_REQUIRED_FIELD_EMPTY, szStrippedLabel);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION);

			// Do this so that the control receives focus.
			(void) pDX->PrepareEditCtrl(nIDC);

			// Fail the call.
			strPrompt.Empty();	// exception prep
			pDX->Fail();
		}  // if:  field not specified
	}  // if:  saving data

}  //*** DDV_RequiredText()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\dlghelps.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelpS.cpp
//
//	Abstract:
//		Stub for implementation of dialog help classes.
//
//	Author:
//		David Potter (davidp)	February 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\dlghelp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.h
//
//	Abstract:
//		Definition of the CDialogHelp class.
//
//	Implementation File:
//		DlgHelp.cpp
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#define _DLGHELP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID
{
	DWORD	m_nCtrlID;
	DWORD	m_nHelpCtrlID;
};

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp dialog
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp : public CObject
{
	DECLARE_DYNAMIC(CDialogHelp)

// Construction
public:
	CDialogHelp(void) { CommonConstruct(); }
	CDialogHelp(const CMapCtrlToHelpID * pmap, DWORD dwMask);

	void CommonConstruct(void);

// Attributes
protected:
	const CMapCtrlToHelpID *	m_pmap;
	DWORD						m_dwMask;
	DWORD						m_nHelpID;

public:
	const CMapCtrlToHelpID *	Pmap(void) const	{ return m_pmap; }
	DWORD						DwMask(void) const	{ return m_dwMask; }
	DWORD						NHelpID(void) const	{ return m_nHelpID; }

	DWORD						NHelpFromCtrlID(IN DWORD nCtrlID) const;

// Operations
public:
	void		SetHelpMask(IN DWORD dwMask)	{ ASSERT(dwMask != 0); m_dwMask = dwMask; }

	void		OnContextMenu(CWnd * pWnd, CPoint point);
	BOOL		OnHelpInfo(HELPINFO * pHelpInfo);
	LRESULT		OnCommandHelp(WPARAM wParam, LPARAM lParam);

// Overrides

// Implementation

};  //*** class CDialogHelp

/////////////////////////////////////////////////////////////////////////////

#endif // _DLGHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\excoper.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOper.cpp
//
//	Abstract:
//		Implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	May 20, 1996
//
//	Revision History:
//
//	Notes:
//		stdafx.h, TraceTag.h, and resource.h are all pulled from the project
//		directory.
//
//		stdafx.h must have an IDS typedef and disable some W4 warnings.
//
//		TraceTag.h must define TraceError.
//
//		resource.h must define IDS_UNKNOWN_ERROR, and the string must be
//		defined something like "Error %d (0x%08.8x)." in the resource file.
//
/////////////////////////////////////////////////////////////////////////////

#include <string.h>
#include "ExcOper.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExceptionWithOper
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CExceptionWithOper, CException)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::CExceptionWithOper
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExceptionWithOper::CExceptionWithOper(
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	SetOperation(idsOperation, pszOperArg1, pszOperArg2);

}  //*** CExceptionWithOper::CExceptionWithOper()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::CExceptionWithOper
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//		bAutoDelete		[IN] Auto-delete the exception in Delete().
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExceptionWithOper::CExceptionWithOper(
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2,
	IN BOOL			bAutoDelete
	) : CException(bAutoDelete)
{
	SetOperation(idsOperation, pszOperArg1, pszOperArg2);

}  //*** CExceptionWithOper::CExceptionWithOper()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::~CExceptionWithOper
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExceptionWithOper::~CExceptionWithOper(void)
{
}  //*** CExceptionWithOper::~CExceptionWithOper()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::GetErrorMessage
//
//	Routine Description:
//		Get the error message represented by the exception.
//
//	Arguments:
//		lpszError		[OUT] String in which to return the error message.
//		nMaxError		[IN] Maximum length of the output string.
//		pnHelpContext	[OUT] Help context for the error message.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExceptionWithOper::GetErrorMessage(
	LPTSTR	lpszError,
	UINT	nMaxError,
	PUINT	pnHelpContext
	)
{
	// Format the operation string.
	FormatWithOperation(lpszError, nMaxError, NULL);

	return TRUE;

}  //*** CExceptionWithOper::GetErrorMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::ReportError
//
//	Routine Description:
//		Report an error from the exception.  Overriding to get a bigger
//		error message buffer.
//
//	Arguments:
//		nType		[IN] Type of message box.
//		nError		[IN] ID of a mesage to display if exception has no message.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CExceptionWithOper::ReportError(
	UINT nType /* = MB_OK */,
	UINT nError /* = 0 */
	)
{
	TCHAR   szErrorMessage[EXCEPT_MAX_OPER_ARG_LENGTH * 3];
	int     nDisposition;
	UINT    nHelpContext;

	if (GetErrorMessage(szErrorMessage, sizeof(szErrorMessage) / sizeof(TCHAR), &nHelpContext))
		nDisposition = AfxMessageBox(szErrorMessage, nType, nHelpContext);
	else
	{
		if (nError == 0)
			nError = AFX_IDP_NO_ERROR_AVAILABLE;
		nDisposition = AfxMessageBox(nError, nType, nHelpContext);
	}
	return nDisposition;

}  //*** CExceptionWithOper::ReportError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::SetOperation
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExceptionWithOper::SetOperation(
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	m_idsOperation = idsOperation;

	if (pszOperArg1 == NULL)
		m_szOperArg1[0] = _T('\0');
	else
	{
		::_tcsncpy(m_szOperArg1, pszOperArg1, (sizeof(m_szOperArg1) / sizeof(TCHAR)) - 1);
		m_szOperArg1[(sizeof(m_szOperArg1) / sizeof(TCHAR))- 1] = _T('\0');
	}  // else:  first argument specified

	if (pszOperArg2 == NULL)
		m_szOperArg2[0] = _T('\0');
	else
	{
		::_tcsncpy(m_szOperArg2, pszOperArg2, (sizeof(m_szOperArg2) / sizeof(TCHAR)) - 1);
		m_szOperArg2[(sizeof(m_szOperArg2) / sizeof(TCHAR)) - 1] = _T('\0');
	}  // else:  second argument specified

}  //*** CExceptionWithOper::SetOperation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::FormatWithOperation
//
//	Routine Description:
//		Get the error message represented by the exception.
//
//	Arguments:
//		lpszError		[OUT] String in which to return the error message.
//		nMaxError		[IN] Maximum length of the output string.
//		pszMsg			[IN] Message to format with the operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExceptionWithOper::FormatWithOperation(
	OUT LPTSTR	lpszError,
	IN UINT		nMaxError,
	IN LPCTSTR	pszMsg
	)
{
	DWORD		dwResult;
	TCHAR		szOperation[EXCEPT_MAX_OPER_ARG_LENGTH];
	TCHAR		szFmtOperation[EXCEPT_MAX_OPER_ARG_LENGTH * 3];

	ASSERT(lpszError != NULL);
	ASSERT(nMaxError > 0);

	// Format the operation string.
	if (m_idsOperation)
	{
		void *		rgpvArgs[2]	= { m_szOperArg1, m_szOperArg2 };

		// Load the operation string.
		dwResult = ::LoadString(AfxGetApp()->m_hInstance, m_idsOperation, szOperation, (sizeof(szOperation) / sizeof(TCHAR)));
		ASSERT(dwResult != 0);

		// Format the operation string.
		::FormatMessage(
					FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
					szOperation,
					0,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					szFmtOperation,
					sizeof(szFmtOperation) / sizeof(TCHAR),
					(va_list *) rgpvArgs
					);
//		::_sntprintf(szFmtOperation, (sizeof(szFmtOperation) / sizeof(TCHAR)) - 1, szOperation, m_szOperArg1, m_szOperArg2);
		szFmtOperation[(sizeof(szFmtOperation) / sizeof(TCHAR)) - 1] = _T('\0');

		// Format the final error message.
		if (pszMsg != NULL)
			::_sntprintf(lpszError, nMaxError - 1, _T("%s\n\n%s"), szFmtOperation, pszMsg);
		else
			::_tcsncpy(lpszError, szFmtOperation, nMaxError - 1);
		lpszError[nMaxError - 1] = _T('\0');
	}  // if:  operation string specified
	else
	{
		if (pszMsg != NULL)
		{
			::_tcsncpy(lpszError, pszMsg, nMaxError - 1);
			lpszError[nMaxError - 1] = _T('\0');
		}  // if:  additional message specified
		else
			lpszError[0] = _T('\0');
	}  // else:  no operation string specified

}  //*** CExceptionWithOper::FormatWithOperation()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// CException
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CNTException, CExceptionWithOper)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNTException::CNTException
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		sc				[IN] NT status code.
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNTException::CNTException(
	IN SC			sc,
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	) : CExceptionWithOper(idsOperation, pszOperArg1, pszOperArg2)
{
	m_sc = sc;

}  //*** CNTException::CNTException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNTException::CNTException
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		sc				[IN] NT status code.
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//		bAutoDelete		[IN] Auto-delete the exception in Delete().
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNTException::CNTException(
	IN SC			sc,
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2,
	IN BOOL			bAutoDelete
	) : CExceptionWithOper(idsOperation, pszOperArg1, pszOperArg2, bAutoDelete)
{
	m_sc = sc;

}  //*** CNTException::CNTException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNTException::~CNTException
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNTException::~CNTException(void)
{
}  //*** CNTException::~CNTException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNTException::GetErrorMessage
//
//	Routine Description:
//		Get the error message represented by the exception.
//
//	Arguments:
//		lpszError		[OUT] String in which to return the error message.
//		nMaxError		[IN] Maximum length of the output string.
//		pnHelpContext	[OUT] Help context for the error message.
//
//	Return Value:
//		TRUE		Message available.
//		FALSE		No message available.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNTException::GetErrorMessage(
	LPTSTR	lpszError,
	UINT	nMaxError,
	PUINT	pnHelpContext
	)
{
	DWORD		dwResult;
	TCHAR		szNtMsg[128];


	// Format the NT status code from the system.
	dwResult = ::FormatMessage(
					FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
					NULL,
					m_sc,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					szNtMsg,
					sizeof(szNtMsg) / sizeof(TCHAR),
					0
					);
	if (dwResult == 0)
	{
		// Format the NT status code from NTDLL since this hasn't been
		// integrated into the system yet.
		dwResult = ::FormatMessage(
						FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
						::GetModuleHandle(_T("NTDLL.DLL")),
						m_sc,
						MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
						szNtMsg,
						sizeof(szNtMsg) / sizeof(TCHAR),
						0
						);
		if (dwResult == 0)
		{
			TCHAR		szErrorFmt[EXCEPT_MAX_OPER_ARG_LENGTH];

			dwResult = ::LoadString(AfxGetApp()->m_hInstance, IDS_UNKNOWN_ERROR, szErrorFmt, (sizeof(szErrorFmt) / sizeof(TCHAR)));
			ASSERT(dwResult != 0);
			::_sntprintf(szNtMsg, sizeof(szNtMsg) / sizeof(TCHAR), szErrorFmt, m_sc, m_sc);
		}  // if:  error formatting status code from NTDLL
	}  // if:  error formatting status code from system

	// Format the message with the operation string.
	FormatWithOperation(lpszError, nMaxError, szNtMsg);

	return TRUE;

}  //*** CNTException::GetErrorMessage()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

static CNTException			gs_nte(ERROR_SUCCESS, NULL, NULL, NULL, FALSE);
static CExceptionWithOper	gs_ewo(NULL, NULL, NULL, FALSE);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ThrowStaticException
//
//	Purpose:
//		Throw the static NT Exception.
//
//	Arguments:
//		sc				[IN] NT status code.
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Returns:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ThrowStaticException(
	IN SC			sc,
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	gs_nte.SetOperation(sc, idsOperation, pszOperArg1, pszOperArg2);
	TraceError(gs_nte);
	throw &gs_nte;

}  //*** ThrowStaticException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ThrowStaticException
//
//	Purpose:
//		Throw the static Cluster Administrator Exception.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Returns:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ThrowStaticException(
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	gs_ewo.SetOperation(idsOperation, pszOperArg1, pszOperArg2);
	TraceError(gs_ewo);
	throw &gs_ewo;

}  //*** ThrowStaticException()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Abstract:
//		Implementation of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Author:
//		David Potter (davidp)	August 29, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "IISClEx4.h"
#include "ExtObj.h"

#include "Iis.h"
#include "smtpprop.h"
#include "nntpprop.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
		RESTYPE_NAME_IIS_VIRTUAL_ROOT L"\0"
		RESTYPE_NAME_SMTP_VIRTUAL_ROOT L"\0"
		RESTYPE_NAME_NNTP_VIRTUAL_ROOT L"\0"
		L"\0"
		;
const DWORD g_cchResourceTypeNames	= sizeof(g_wszResourceTypeNames) / sizeof(WCHAR);

static CRuntimeClass * g_rgprtcPSIISPages[]	= {
	RUNTIME_CLASS(CIISVirtualRootParamsPage),
	NULL
	};

static CRuntimeClass * g_rgprtcPSSMTPPages[] = {
	RUNTIME_CLASS(CSMTPVirtualRootParamsPage),
	NULL
	};

static CRuntimeClass * g_rgprtcPSNNTPPages[] = {
	RUNTIME_CLASS(CNNTPVirtualRootParamsPage),
	NULL
	};

static CRuntimeClass ** g_rgpprtcPSPages[]	= {
	g_rgprtcPSIISPages,
	g_rgprtcPSSMTPPages,
	g_rgprtcPSNNTPPages
	};

// Wizard pages and property sheet pages are the same.
static CRuntimeClass ** g_rgpprtcWizPages[]	= {
	g_rgprtcPSIISPages,
	g_rgprtcPSSMTPPages,
	g_rgprtcPSNNTPPages
	};

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CExtObject
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject(void)
{
	m_piData = NULL;
	m_piWizardCallback = NULL;
	m_bWizard = FALSE;
	m_istrResTypeName = 0;

	m_hcluster = NULL;
	m_lcid = NULL;
	m_hfont = NULL;
	m_hicon = NULL;

}  //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::~CExtObject
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject(void)
{
	// Release the data interface.
	if (PiData() != NULL)
	{
		PiData()->Release();
		m_piData = NULL;
	}  // if:  we have a data interface pointer

	// Release the wizard callback interface.
	if (PiWizardCallback() != NULL)
	{
		PiWizardCallback()->Release();
		m_piWizardCallback = NULL;
	}  // if:  we have a wizard callback interface pointer

	// Delete the pages.
	{
		POSITION	pos;

		pos = Lpg().GetHeadPosition();
		while (pos != NULL)
			delete Lpg().GetNext(pos);
	}  // Delete the pages
    
}  //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//	Routine Description:
//		Indicates whether an interface suportes the IErrorInfo interface.
//		This interface is provided by ATL.
//
//	Arguments:
//		riid		Interface ID.
//
//	Return Value:
//		S_OK		Interface supports IErrorInfo.
//		S_FALSE		Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID * rgiid[] = 
	{
		&IID_IWEExtendPropertySheet,
		&IID_IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
		&IID_IWEExtendContextMenu,
#endif
	};
	int		iiid;

	for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
	{
		if (InlineIsEqualGUID(*rgiid[iiid], riid))
			return S_OK;
	}
	return S_FALSE;

}  //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//	Routine Description:
//		Create property sheet pages and add them to the sheet.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the sheet is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
	IN IUnknown *					piData,
	IN IWCPropertySheetCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try 
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		// Add each page for this type of resource.
		for (irtc = 0 ; g_rgpprtcPSPages[IstrResTypeName()][irtc] != NULL ; irtc++)
		{
			// Create the property pages.
			ppage = (CBasePropertyPage *) g_rgpprtcPSPages[IstrResTypeName()][irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(g_rgpprtcPSPages[IstrResTypeName()][irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddPropertySheetPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page for the type of resource
	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add property page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add property page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	piCallback->Release();
	return hr;

}  //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreateWizardPages (IWEExtendWizard)
//
//	Routine Description:
//		Create property sheet pages and add them to the wizard.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the wizard is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
	IN IUnknown *			piData,
	IN IWCWizardCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try 
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		m_piWizardCallback = piCallback;
		m_bWizard = TRUE;

		// Add each page for this type of resource.
		for (irtc = 0 ; g_rgpprtcWizPages[IstrResTypeName()][irtc] != NULL ; irtc++)
		{
			// Create the property pages.
			ppage = (CBasePropertyPage *) g_rgpprtcWizPages[IstrResTypeName()][irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(g_rgpprtcWizPages[IstrResTypeName()][irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddWizardPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page for the type of resource
	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add wizard page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add wizard page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piCallback->Release();
		// see description of bug #298124
        if (m_piWizardCallback == piCallback)
        {
            m_piWizardCallback = NULL;
        }
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	return hr;

}  //*** CExtObject::CreateWizardPages()

#ifdef _DEMO_CTX_MENUS
/////////////////////////////////////////////////////////////////////////////
// IWEExtendContextMenu Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::AddContextMenuItems (IWEExtendContextMenu)
//
//	Routine Description:
//		Add items to a context menu.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the context menu is being displayed.
//		piCallback		Pointer to an IWCContextMenuCallback interface
//							for adding menu items to the context menu.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_FAIL			Error adding context menu item.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes returned by HrSaveData() or IWCContextMenuCallback::
//		AddExtensionMenuItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::AddContextMenuItems(
	IN IUnknown *				piData,
	IN IWCContextMenuCallback *	piCallback
	)
{
	HRESULT			hr		= NOERROR;
	CException		exc(FALSE /*bAutoDelete*/);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try 
	{
		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Add menu items specific to this resource type.
		{
			ULONG		iCommandID;
			LPWSTR		pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];
			LPWSTR		pwszName;
			LPWSTR		pwszStatusBarText;

			for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
			{
				pwszName = pwsz;
				pwszStatusBarText = pwszName + (::wcslen(pwszName) + 1);
				hr = piCallback->AddExtensionMenuItem(
									pwszName,			// lpszName
									pwszStatusBarText,	// lpszStatusBarText
									iCommandID,			// lCommandID
									0,					// lSubCommandID
									0					// uFlags
									);
				if (hr != NOERROR)
					throw &exc;
				pwsz = pwszStatusBarText + (::wcslen(pwszStatusBarText) + 1);
			}  // while:  more menu items to add
		}  // Add menu items specific to this resource type
	}  // try
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add context menu item\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	piCallback->Release();
	return hr;

}  //*** CExtObject::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
// IWEInvokeCommand Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::InvokeCommand (IWEInvokeCommand)
//
//	Routine Description:
//		Invoke a command offered by a context menu.
//
//	Arguments:
//		lCommandID		ID of the menu item to execute.  This is the same
//							ID passed to the IWCContextMenuCallback
//							::AddExtensionMenuItem() method.
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the command is to be invoked.
//
//	Return Value:
//		NOERROR			Command invoked successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::InvokeCommand(
	IN ULONG		nCommandID,
	IN IUnknown *	piData
	)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Find the item that was executed in our table.
	hr = HrSaveData(piData);
	if (hr == NOERROR)
	{
		ULONG		iCommandID;
		LPWSTR		pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];
		LPWSTR		pwszName;
		LPWSTR		pwszStatusBarText;

		for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
		{
			pwszName = pwsz;
			pwszStatusBarText = pwszName + (::wcslen(pwszName) + 1);
			if (iCommandID == nCommandID)
				break;
			pwsz = pwszStatusBarText + (::wcslen(pwszStatusBarText) + 1);
		}  // while:  more menu items to add
		if (iCommandID == nCommandID)
		{
			CString		strMsg;
			CString		strName;

			try
			{
				strName = pwszName;
				strMsg.Format(_T("Item %s was executed"), strName);
				AfxMessageBox(strMsg);
			}  // try
			catch (CException * pe)
			{
				pe->Delete();
			}  // catch:  CException
		}  // if:  command ID found
	}  // if:  no errors saving the data

	piData->Release();
	m_piData = NULL;
	return NOERROR;

}  //*** CExtObject::InvokeCommand()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetUIInfo
//
//	Routine Description:
//		Get info about displaying UI.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	// Save info about all types of objects.
	{
		IGetClusterUIInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_lcid = pi->GetLocale();
		m_hfont = pi->GetFont();
		m_hicon = pi->GetIcon();

		pi->Release();
	}  // Save info about all types of objects

	return hr;

}  //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrSaveData
//
//	Routine Description:
//		Save data from the object so that it can be used for the life
//		of the object.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	if (piData != m_piData)
	{
		if (m_piData != NULL)
			m_piData->Release();
		m_piData = piData;
	}  // if:  different data interface pointer

	// Save info about all types of objects.
	{
		IGetClusterDataInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_hcluster = pi->GetClusterHandle();
		m_cobj = pi->GetObjectCount();
		if (Cobj() != 1)
			hr = E_NOTIMPL;
		else
			hr = HrGetClusterName(pi);

		pi->Release();
		if (hr != NOERROR)
			return hr;
	}  // Save info about all types of objects

	// Save info about this object.
	hr = HrGetObjectInfo();
	if (hr != NOERROR)
		return hr;

    //
    // Get the handle of the node we are running on.
    //

    WCHAR   wcsNodeName[MAX_COMPUTERNAME_LENGTH+1] = L"";
    DWORD   dwLength = MAX_COMPUTERNAME_LENGTH+1;
    
    if ( ClusterResourceStateUnknown != 
        GetClusterResourceState(m_rdResData.m_hresource, wcsNodeName, &dwLength, NULL, 0))
    {
        m_strNodeName = wcsNodeName;
    }

	return hr;

}  //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectInfo
//
//	Routine Description:
//		Get information about the object.
//
//	Arguments:
//		None.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
	HRESULT						hr	= NOERROR;
	IGetClusterObjectInfo *		piGcoi;
	IGetClusterResourceInfo *	piGcri;
	CException					exc(FALSE /*bAutoDelete*/);

	ASSERT(PiData() != NULL);

	// Get an IGetClusterObjectInfo interface pointer.
	hr = PiData()->QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &piGcoi);
	if (hr != NOERROR)
		return hr;

	// Read the object data.
	try
	{
		// Get the type of the object.
		m_rdResData.m_cot = piGcoi->GetObjectType(0);
		if (m_rdResData.m_cot != CLUADMEX_OT_RESOURCE)
		{
			hr = E_NOTIMPL;
			throw &exc;
		}  // if:  not a resource

		hr = HrGetObjectName(piGcoi);
	}  // try
	catch (CException * pe)
	{
		pe->Delete();
	}  // catch:  CException

	piGcoi->Release();
	if (hr != NOERROR)
		return hr;

	// Get an IGetClusterResourceInfo interface pointer.
	hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &piGcri);
	if (hr != NOERROR)
		return hr;

	m_rdResData.m_hresource = piGcri->GetResourceHandle(0);
	hr = HrGetResourceTypeName(piGcri);

	// See if we know about this resource type.
	if (hr == NOERROR)
	{
		LPCWSTR	pwszResTypeName;

		// Find the resource type name in our list.
		// Save the index for use in other arrays.
		for (m_istrResTypeName = 0, pwszResTypeName = g_wszResourceTypeNames
				; *pwszResTypeName != L'\0'
				; m_istrResTypeName++, pwszResTypeName += ::wcslen(pwszResTypeName) + 1
				)
		{
			if (RrdResData().m_strResTypeName.CompareNoCase(pwszResTypeName) == 0 )
				break;
		}  // for:  each resource type in the list
		if (*pwszResTypeName == L'\0')
			hr = E_NOTIMPL;
	}  // See if we know about this resource type

	piGcoi->Release();
	return hr;

}  //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetClusterName
//
//	Routine Description:
//		Get the name of the cluster.
//
//	Arguments:
//		piData			IGetClusterDataInfo interface pointer for getting
//							the object name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetClusterName(
	IN OUT IGetClusterDataInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetClusterName(NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetClusterName(pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting cluster name

		m_strClusterName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetClusterName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectName
//
//	Routine Description:
//		Get the name of the object.
//
//	Arguments:
//		piData			IGetClusterObjectInfo interface pointer for getting
//							the object name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(
	IN OUT IGetClusterObjectInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetObjectName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetObjectName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting object name

		m_rdResData.m_strName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetResourceTypeName
//
//	Routine Description:
//		Get the name of the resource's type.
//
//	Arguments:
//		piData			IGetClusterResourceInfo interface pointer for getting
//							the resource type name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(
	IN OUT IGetClusterResourceInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetResourceTypeName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetResourceTypeName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting resource type name

		m_rdResData.m_strResTypeName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetResourceTypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::BGetResourceNetworkName
//
//	Routine Description:
//		Get the name of the resource's type.
//
//	Arguments:
//		lpszNetName		[OUT] String in which to return the network name resource name.
//		pcchNetName		[IN OUT] Points to a variable that specifies the
//							maximum size, in characters, of the buffer.  This
//							value shold be large enough to contain
//							MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//							return it contains the actual number of characters
//							copied.
//
//	Return Value:
//		TRUE		Resource is dependent on a network name resource.
//		FALSE		Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BGetResourceNetworkName(
	OUT WCHAR *		lpszNetName,
	IN OUT DWORD *	pcchNetName
	)
{
	BOOL						bSuccess;
	IGetClusterResourceInfo *	piGcri;

	ASSERT(PiData() != NULL);

	// Get an IGetClusterResourceInfo interface pointer.
	{
		HRESULT		hr;

		hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &piGcri);
		if (hr != NOERROR)
		{
			SetLastError(hr);
			return FALSE;
		}  // if:  error getting the interface
	}  // Get an IGetClusterResourceInfo interface pointer

	// Get the resource network name.
	bSuccess = piGcri->GetResourceNetworkName(0, lpszNetName, pcchNetName);

	piGcri->Release();

	return bSuccess;

}  //*** CExtObject::BGetResourceNetworkName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      HelpData.cpp
//
//  Abstract:
//      Data required for implementing help.
//
//  Author:
//      David Potter (davidp)   February 19, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "HelpData.h"

/////////////////////////////////////////////////////////////////////////////
// Help ID Map for CIISVirtualRootParamsPage
/////////////////////////////////////////////////////////////////////////////

const CMapCtrlToHelpID g_rghelpmapIISParameters[] =
{
    // IIS HelpID
    { IDC_PP_ICON,                  (DWORD) -1 },
    { IDC_PP_TITLE,                 IDC_PP_TITLE },
    { IDC_PP_IIS_FTP,               IDC_PP_IIS_FTP },
    { IDC_PP_IIS_WWW,               IDC_PP_IIS_WWW },
    { IDC_PP_IIS_INSTANCEID,        IDC_PP_IIS_INSTANCEID },
    { IDC_PP_IIS_INSTANCEID_LABEL,  IDC_PP_IIS_INSTANCEID },
    { IDC_PP_REFRESH,               IDC_PP_REFRESH },

    // SMTP HelpID
    { IDC_PP_SMTP_TITLE,            IDC_PP_SMTP_TITLE },
    { IDC_PP_SMTP_INSTANCEID,       IDC_PP_SMTP_INSTANCEID },
    { IDC_PP_SMTP_INSTANCEID_LABEL, IDC_PP_SMTP_INSTANCEID },
    { IDC_PP_SMTP_REFRESH,          IDC_PP_SMTP_REFRESH },

    // NNTP HelpID
    { IDC_PP_NNTP_TITLE,            IDC_PP_NNTP_TITLE },
    { IDC_PP_NNTP_INSTANCEID,       IDC_PP_NNTP_INSTANCEID },
    { IDC_PP_NNTP_INSTANCEID_LABEL, IDC_PP_NNTP_INSTANCEID },
    { IDC_PP_NNTP_REFRESH,          IDC_PP_NNTP_REFRESH },

    { 0,                            0 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Abstract:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Author:
//		David Potter (davidp)	August 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_DATA and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage and CPageList
#endif

//#define _DEMO_CTX_MENUS

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** CObjData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** CResData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject : 
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
	public IWEExtendContextMenu,
	public IWEInvokeCommand,
#endif
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoIISClEx4>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(IWEExtendWizard)
#ifdef _DEMO_CTX_MENUS
	COM_INTERFACE_ENTRY(IWEExtendContextMenu)
	COM_INTERFACE_ENTRY(IWEInvokeCommand)
#endif
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.IIS5"), _T("CLUADMEX.IIS"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD(CreateWizardPages)(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

#ifdef _DEMO_CTX_MENUS
// IWEExtendContextMenu
public:
	STDMETHOD(AddContextMenuItems)(
					IN IUnknown *				piData,
					IN IWCContextMenuCallback *	piCallback
					);

// IWEInvokeCommand
	STDMETHOD(InvokeCommand)(
					IN ULONG					nCommandID,
					IN IUnknown *				piData
					);
#endif

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterDataInfo data
	CString						m_strClusterName;
	CString                     m_strNodeName;
	HCLUSTER					m_hcluster;
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;
	LONG						m_cobj;

	CResData					m_rdResData;

	CObjData *					PodObjDataRW(void) const		{ return (CObjData *) &m_rdResData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) &m_rdResData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback(void) const	{ return m_piWizardCallback; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterDataInfo data
	const CString &				StrClusterName(void) const		{ return m_strClusterName; }
	const CString &				StrNodeName(void) const		    { return m_strNodeName; }
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CResData &			RrdResData(void) const			{ return m_rdResData; }
	const CObjData *			PodObjData(void) const			{ return &m_rdResData; }
	const CResData *			PrdResData(void) const			{ return (CResData *) &m_rdResData; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetClusterName(IN OUT IGetClusterDataInfo * pi);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);
	BOOL						BGetResourceNetworkName(OUT WCHAR * lpszNetName, IN OUT DWORD * pcchNetName);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\excoper.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOper.h
//
//	Abstract:
//		Definition of the exception classes.
//
//	Author:
//		David Potter (davidp)	May 20, 1996
//
//	Implementation File:
//		ExcOper.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXCOPER_H_
#define _EXCOPER_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExceptionWithOper;
class CNTException;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef DWORD SC;

#define EXCEPT_MAX_OPER_ARG_LENGTH	260

/////////////////////////////////////////////////////////////////////////////
// CExceptionWithOper
/////////////////////////////////////////////////////////////////////////////

class CExceptionWithOper : public CException
{
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC(CExceptionWithOper)

public:
// Constructors
	CExceptionWithOper(
		IN IDS		idsOperation,
		IN LPCTSTR	pszOperArg1		= NULL,
		IN LPCTSTR	pszOperArg2		= NULL
		);
	CExceptionWithOper(
		IN IDS		idsOperation,
		IN LPCTSTR	pszOperArg1,
		IN LPCTSTR	pszOperArg2,
		IN BOOL		bAutoDelete
		);

// Operations
public:
	virtual BOOL	GetErrorMessage(
						LPTSTR	lpszError,
						UINT	nMaxError,
						PUINT	pnHelpContext = NULL
						);
	virtual int		ReportError(
						UINT	nType	= MB_OK,
						UINT	nError	= 0
						);
	void			SetOperation(
						IN IDS		idsOperation,
						IN LPCTSTR	pszOperArg1,
						IN LPCTSTR	pszOperArg2
						);
	void			FormatWithOperation(
						OUT LPTSTR	lpszError,
						IN UINT		nMaxError,
						IN LPCTSTR	pszMsg
						);

// Implementation
public:
	virtual ~CExceptionWithOper(void);

protected:
	IDS				m_idsOperation;
	TCHAR			m_szOperArg1[EXCEPT_MAX_OPER_ARG_LENGTH];
	TCHAR			m_szOperArg2[EXCEPT_MAX_OPER_ARG_LENGTH];

public:
	IDS				IdsOperation(void)		{ return m_idsOperation; }
	LPTSTR			PszOperArg1(void)		{ return m_szOperArg1; }
	LPTSTR			PszOperArg2(void)		{ return m_szOperArg2; }

};  //*** class CExceptionWithOper

/////////////////////////////////////////////////////////////////////////////
// CNTException
/////////////////////////////////////////////////////////////////////////////

class CNTException : public CExceptionWithOper
{
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC(CNTException)

public:
// Constructors
	CNTException(
		IN SC		sc,
		IN IDS		idsOperation	= NULL,
		IN LPCTSTR	pszOperArg1		= NULL,
		IN LPCTSTR	pszOperArg2		= NULL
		);
	CNTException(
		IN SC		sc,
		IN IDS		idsOperation,
		IN LPCTSTR	pszOperArg1,
		IN LPCTSTR	pszOperArg2,
		IN BOOL		bAutoDelete
		);

// Operations
public:
	virtual BOOL	GetErrorMessage(
						LPTSTR	lpszError,
						UINT	nMaxError,
						PUINT	pnHelpContext = NULL
						);
	void			SetOperation(
						IN SC		sc,
						IN IDS		idsOperation,
						IN LPCTSTR	pszOperArg1,
						IN LPCTSTR	pszOperArg2
						)
					{
						m_sc = sc;
						CExceptionWithOper::SetOperation(idsOperation, pszOperArg1, pszOperArg2);
					}

// Implementation
public:
	virtual ~CNTException(void);

protected:
	SC				m_sc;

public:
	SC				Sc(void)		{ return m_sc; }

};  //*** class CNTException

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void ThrowStaticException(
	IN IDS			idsOperation	= NULL,
	IN LPCTSTR		pszOperArg1		= NULL,
	IN LPCTSTR		pszOperArg2		= NULL
	);
void ThrowStaticException(
	IN SC			sc,
	IN IDS			idsOperation	= NULL,
	IN LPCTSTR		pszOperArg1		= NULL,
	IN LPCTSTR		pszOperArg2		= NULL
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _CAEXCEPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _HELPDATA_H_
#define _HELPDATA_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CMapCtrlToHelpID
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

extern const CMapCtrlToHelpID g_rghelpmapIISParameters[];

/////////////////////////////////////////////////////////////////////////////

#endif // _HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\iis.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Iis.cpp
//
//	Abstract:
//		Implementation of the CIISVirtualRootParamsPage class.
//
//	Author:
//		Pete Benoit (v-pbenoi)	October 16, 1996
//		David Potter (davidp)	October 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <inetinfo.h>
#include "IISClEx4.h"
#include "Iis.h"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"	// for g_rghelpmap*

#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <iadm.h>
#include <iiscnfgp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CIISVirtualRootParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CIISVirtualRootParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CIISVirtualRootParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CIISVirtualRootParamsPage)
	ON_CBN_SELCHANGE(IDC_PP_IIS_INSTANCEID, OnChangeRequiredField)
	ON_BN_CLICKED(IDC_PP_IIS_FTP, OnChangeServiceType)
	ON_BN_CLICKED(IDC_PP_IIS_WWW, OnChangeServiceType)
	ON_BN_CLICKED(IDC_PP_REFRESH, OnRefresh)
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::CIISVirtualRootParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CIISVirtualRootParamsPage::CIISVirtualRootParamsPage(void)
	: CBasePropertyPage(g_rghelpmapIISParameters)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CIISVirtualRootParamsPage)
	m_strInstanceId = _T("");
	m_nServerType = SERVER_TYPE_WWW;
	//}}AFX_DATA_INIT


    m_fReadList = FALSE;
    
	try
	{
		m_strServiceName = IIS_SVC_NAME_WWW;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->ReportError();
		pme->Delete();
	}  // catch:  CMemoryException

	// Setup the property array.
	{
		m_rgProps[epropServiceName].Set(REGPARAM_IIS_SERVICE_NAME, m_strServiceName, m_strPrevServiceName);
		m_rgProps[epropInstanceId].Set(REGPARAM_IIS_INSTANCEID, m_strInstanceId, m_strPrevInstanceId);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_IIS_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_IIS_PARAMETERS;
	m_idcPPTitle = IDC_PP_TITLE;

}  //*** CIISVirtualRootParamsPage::CIISVirtualRootParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIISVirtualRootParamsPage::DoDataExchange(CDataExchange * pDX)
{
    CString     strInstanceId;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (!pDX->m_bSaveAndValidate)
	{
		// Set the service type.
		if (m_strServiceName.CompareNoCase(IIS_SVC_NAME_FTP) == 0)
			m_nServerType = SERVER_TYPE_FTP;
		else if (m_strServiceName.CompareNoCase(IIS_SVC_NAME_WWW) == 0)
			m_nServerType = SERVER_TYPE_WWW;
		else
			m_nServerType = SERVER_TYPE_WWW;

	}  // if:  setting data to dialog

	CBasePropertyPage::DoDataExchange(pDX);
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_MAP(CIISVirtualRootParamsPage)
	DDX_Control(pDX, IDC_PP_IIS_INSTANCEID, m_cInstanceId);
	DDX_Text(pDX, IDC_PP_IIS_INSTANCEID, m_strInstanceName);
	DDX_Control(pDX, IDC_PP_IIS_WWW, m_rbWWW);
	DDX_Control(pDX, IDC_PP_IIS_FTP, m_rbFTP);
	DDX_Radio(pDX, IDC_PP_IIS_FTP, m_nServerType);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (!BBackPressed())
		{
			DDV_RequiredText(pDX, IDC_PP_IIS_INSTANCEID, IDC_PP_IIS_INSTANCEID_LABEL, m_strInstanceName);
		}  // if:  Back button not pressed

        m_strInstanceId = NameToMetabaseId( m_nServerType == SERVER_TYPE_WWW, m_strInstanceName );

		// Save the type.
		if (m_nServerType == SERVER_TYPE_FTP)
			m_strServiceName = IIS_SVC_NAME_FTP;
		else if (m_nServerType == SERVER_TYPE_WWW)
			m_strServiceName = IIS_SVC_NAME_WWW;
		else
		{
			CString		strMsg;
			strMsg.LoadString(IDS_INVALID_IIS_SERVICE_TYPE);
			AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
			strMsg.Empty();
			pDX->PrepareCtrl(IDC_PP_IIS_FTP);	// do this just to set the control for Fail().
			pDX->Fail();
		}  // else:  no service type set

	}  // if:  saving data from dialog

}  //*** CIISVirtualRootParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIISVirtualRootParamsPage::OnInitDialog(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CBasePropertyPage::OnInitDialog();

	m_cInstanceId.EnableWindow( TRUE );

	//
	// Save the inital server type so it will be possible to determine if it changes (# 265510)
	//
	m_nInitialServerType = m_rbWWW.GetCheck() == BST_CHECKED ? SERVER_TYPE_WWW : SERVER_TYPE_FTP;

	OnChangeServiceType();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CIISVirtualRootParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIISVirtualRootParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Enable/disable the Next/Finish button.
	if (BWizard())
	{
		SetEnableNext();
	}  // if:  in the wizard

	return CBasePropertyPage::OnSetActive();

}  //*** CIISVirtualRootParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnChangeServiceType
//
//	Routine Description:
//		Handler for the BN_CLICKED message on one of the service type radio
//		buttons.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIISVirtualRootParamsPage::OnChangeServiceType(void)
{
#if 0
	int		nCmdShowAccess;
	IDS		idsWriteLabel	= 0;

	OnChangeCtrl();

	if (m_rbFTP.GetCheck() == BST_CHECKED)
	{
		nCmdShowAccess = SW_SHOW;
		idsWriteLabel = IDS_WRITE;
	}  // if:  FTP service
	else if (m_rbWWW.GetCheck() == BST_CHECKED)
	{
		nCmdShowAccess = SW_SHOW;
		idsWriteLabel = IDS_EXECUTE;
	}  // else if:  WWW service
	else
	{
		nCmdShowAccess = SW_HIDE;
	}  // else:  unknown service

	// Set the access checkbox labels.
	if (idsWriteLabel != 0)
	{
		CString		strWriteLabel;

//		AFX_MANAGE_STATE(AfxGetStaticModuleState());
//		strWriteLabel.LoadString(idsWriteLabel);
//		m_ckbWrite.SetWindowText(strWriteLabel);
	}  // if:  write label needs to be set

#endif
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();
    m_nServerType = m_rbWWW.GetCheck() == BST_CHECKED ? SERVER_TYPE_WWW : SERVER_TYPE_FTP; 

    FillServerList();
}  //*** CIISVirtualRootParamsPage::OnChangeServiceType()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnChangeRequiredField
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIISVirtualRootParamsPage::OnChangeRequiredField(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
	{
		SetEnableNext();
	}  // if:  in a wizard

}  //*** CIISVirtualRootParamsPage::OnChangeRequiredField()

////


void 
CIISVirtualRootParamsPage::FillServerList(
    )
/*++

Routine Description:

    Populate server combo box with server list relevant to current service type,
    set current selection based on server instance ID
    enable Finish button if list non empty

Arguments:

    None

Returns:

    Nothing

--*/
{

    int nIndex;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//
    // build array if not already done
    //
    
    if ( !m_fReadList )
    {
        HRESULT hr1, hr2, hr;
        
        hr1 = ReadList( &m_W3Array, MD_SERVICE_ROOT_WWW, LPCTSTR(Peo()->StrNodeName()), SERVER_TYPE_WWW );
        hr2 = ReadList( &m_FTPArray, MD_SERVICE_ROOT_FTP, LPCTSTR(Peo()->StrNodeName()), SERVER_TYPE_FTP );
        
        if (FAILED(hr1) || FAILED(hr2))
        {
            CString err;

            hr = FAILED(hr1) ? hr1 : hr2;

            // 
            // (# 309917) Path not found is not a "reportable" error since it only implies there no servers of the given server type,  which is a case that is dealt with below
            //
            if( (HRESULT_FACILITY(hr) == FACILITY_WIN32) && 
                (HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND) )
            {
				OutputDebugStringW( L"[FillServerList] ReadList() returned : ERROR_PATH_NOT_FOUND\n" );
            } 
            else if ( REGDB_E_IIDNOTREG == hr)
            {
                err.Format(IDS_IIS_PROXY_MISCONFIGURED, Peo()->StrNodeName());
                AfxMessageBox(err);
            }
            else
            {
                CString fmtError;
                DWORD   dwError;

                if ( (HRESULT_FACILITY(hr) == FACILITY_WIN32) ||
                     (HRESULT_FACILITY(hr) == FACILITY_NT_BIT))
                {
                    dwError = (DWORD) HRESULT_CODE(hr);
                }
                else
                {
                    dwError = (DWORD) hr;
                }
                
                FormatError(fmtError, dwError);
                
                err.Format(IDS_ENUMERATE_FAILED, Peo()->StrNodeName(), fmtError);
                AfxMessageBox(err);
            }

            m_cInstanceId.EnableWindow(FALSE);
        }
        else
        {
            m_cInstanceId.EnableWindow(TRUE);
        }
        
        m_fReadList = TRUE;
    }

    m_strInstanceName = MetabaseIdToName( m_nServerType == SERVER_TYPE_WWW, m_strInstanceId );

    // add to combo from array

    CArray <IISMapper, IISMapper>* pArray = m_nServerType == SERVER_TYPE_WWW ? &m_W3Array : &m_FTPArray;
    DWORD  nAddCount = 0;

    m_cInstanceId.ResetContent();

    for ( nIndex = 0 ; nIndex < pArray->GetSize() ; ++nIndex )
    {
        //
        // Only add sites that are not cluster enabled or have the same ID and service type as the resource opened
        //
    
        if ( (!pArray->ElementAt(nIndex).IsClusterEnabled()) || 
             ((!lstrcmp( pArray->ElementAt( nIndex ).GetId(), m_strInstanceId)) &&
             (pArray->ElementAt( nIndex ).GetServerType() == m_nInitialServerType))
           )
        {
            if ( m_cInstanceId.AddString( pArray->ElementAt( nIndex ).GetName() ) < 0 )
            {
                OutputDebugStringW( L"Error add\n" );
            }
            else
            {
                nAddCount++;
            }
        }
    }

    if (0 == nAddCount)
    {
        m_cInstanceId.EnableWindow(FALSE);
        
        if (BWizard())
        {
            //
            // If we're here than there are no more un-clustered sites of server type (m_nServerType)
            //
            BOOL fAllClusterEnabled = TRUE;
            
            //
            // (# 265689) Before reporting that ALL instances are cluster enabled we have to check the other server type for un-clustered sites
            //
            CArray <IISMapper, IISMapper>* pOhterArray = m_nServerType == SERVER_TYPE_WWW ? &m_FTPArray : &m_W3Array ;
            
            for ( nIndex = 0 ; nIndex < pOhterArray->GetSize() ; ++nIndex )
            {
                if( !pOhterArray->ElementAt(nIndex).IsClusterEnabled() )
                {
                    fAllClusterEnabled = FALSE;
                    break;
                }
            }
            
            if( fAllClusterEnabled )
            {
                CString err;
                err.Format(IDS_ALL_INSTANCES_CLUSTER_ENABLED, Peo()->StrNodeName());
                AfxMessageBox(err);
                
            }
            EnableNext(FALSE);
        }
        
        
    }
    else
    {
        m_cInstanceId.EnableWindow(TRUE);   // # 237376

        if (BWizard())
        {
            SetEnableNext();
            m_cInstanceId.SetCurSel(0);
        }
        else
        {
            nIndex = m_cInstanceId.FindStringExact(-1, m_strInstanceName);

            if ( nIndex != CB_ERR )
            {
                m_cInstanceId.SetCurSel(nIndex);
            }
        }
    }
}


HRESULT
CIISVirtualRootParamsPage::ReadList(
    CArray <IISMapper, IISMapper>* pMapperArray,
    LPWSTR                         pszPath,
    LPCWSTR                        wcsMachineName,
    int                            nServerType
    )
/*++

Routine Description:

    Read a server list from metabase based on metabase path

Arguments:

    pMapperArray - array where to add list of ( ServerComment, InstanceId ) pairs
    pszPath - metabase path, e.g. LM/W3SVC

Returns:

    Error code, S_OK if success

--*/
{
    IMSAdminBaseW *     pcAdmCom = NULL;
    METADATA_HANDLE     hmd;
    DWORD               i;
    WCHAR               aId[METADATA_MAX_NAME_LEN+1]  = L"";
    WCHAR               aName[METADATA_MAX_NAME_LEN+1] = L"";
    INT                 cName = METADATA_MAX_NAME_LEN+1;
    HRESULT             hRes = S_OK;
    COSERVERINFO        csiMachine;
    MULTI_QI            QI = {&IID_IMSAdminBase, NULL, 0};
  
    ZeroMemory( &csiMachine, sizeof(COSERVERINFO) );
    csiMachine.pwszName = (LPWSTR)wcsMachineName;

    hRes = CoCreateInstanceEx(  GETAdminBaseCLSID(TRUE), 
                                NULL, 
                                CLSCTX_SERVER, 
                                &csiMachine,
                                1,
                                &QI
                              );

    if ( SUCCEEDED(hRes) && SUCCEEDED(QI.hr))
    {
        pcAdmCom = (IMSAdminBaseW *)QI.pItf;
        
        if( SUCCEEDED( hRes = pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                 pszPath,
                                                 METADATA_PERMISSION_READ,
                                                 5000,
                                                 &hmd)) )
        {
            for ( i = 0 ;
                  SUCCEEDED(pcAdmCom->EnumKeys( hmd, L"", aId, i )) ;
                  ++i )
            {
                METADATA_RECORD md;
                DWORD           dwReq = sizeof(aName);

                memset( &md, 0, sizeof(md) );
                
                md.dwMDDataType     = STRING_METADATA;
                md.dwMDUserType     = IIS_MD_UT_SERVER;
                md.dwMDIdentifier   = MD_SERVER_COMMENT;
                md.dwMDDataLen      = sizeof(aName);
                md.pbMDData         = (LPBYTE)aName;

                if ( SUCCEEDED( pcAdmCom->GetData( hmd, aId, &md, &dwReq) ) )
                {
                    DWORD   dwClusterEnabled = 0;

                    memset( &md, 0, sizeof(md) );
                    
                    md.dwMDDataType     = DWORD_METADATA;
                    md.dwMDUserType     = IIS_MD_UT_SERVER;
                    md.dwMDIdentifier   = MD_CLUSTER_ENABLED;
                    md.dwMDDataLen      = sizeof(dwClusterEnabled);
                    md.pbMDData         = (LPBYTE)&dwClusterEnabled;

                    pcAdmCom->GetData( hmd, aId, &md, &dwReq);
                    
                    //
                    // (# 296798) Use a default name if there is no server comment
                    //
		            if( aId && aName && (0 == lstrlen(aName)) )
                    {
					        if( !LoadString(AfxGetResourceHandle( ), IDS_DEFAULT_SITE_NAME, aName, cName) )
					        {
                   			       OutputDebugStringW( L"Error Loading IDS_DEFAULT_SITE_NAME\n" );
					        }
					
			                lstrcat(aName, aId);
                    }

                    IISMapper*  pMap = new IISMapper( aName, aId, dwClusterEnabled, nServerType );
                    
                    if ( pMap )
                    {
                        pMapperArray->Add( *pMap );
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                        break;
                    }
                }
            }

            pcAdmCom->CloseKey( hmd );
        }

        pcAdmCom->Release();
    }

    return hRes;
}


LPWSTR
CIISVirtualRootParamsPage::NameToMetabaseId(
    BOOL        fIsW3,
    CString&    strName
    )
/*++

Routine Description:

    Convert ServerComment to InstanceId

Arguments:

    fIsW3 - TRUE for WWW, FALSE for FTP
    strName - ServerComment

Returns:

    InstanceId if strName found in array, otherwise NULL

--*/
{
    CArray <IISMapper, IISMapper>* pArray = fIsW3 ? &m_W3Array : &m_FTPArray;
    DWORD   i;

    for ( i = 0 ; i < (DWORD)pArray->GetSize() ; ++i )
    {
        if ( !pArray->ElementAt( i ).GetName().Compare( strName ) )
        {
            return (LPWSTR)(LPCTSTR)(pArray->ElementAt( i ).GetId());
        }
    }

    return NULL;
}


LPWSTR
CIISVirtualRootParamsPage::MetabaseIdToName(
    BOOL        fIsW3,
    CString&    strId
    )
/*++

Routine Description:

    Convert InstanceId to ServerComment

Arguments:

    fIsW3 - TRUE for WWW, FALSE for FTP
    strId - InstanceID

Returns:

    InstanceId if strName found in array. 
    If not found return 1st array element if array not empty, otherwise NULL

--*/
{
    CArray <IISMapper, IISMapper>* pArray = fIsW3 ? &m_W3Array : &m_FTPArray;
    DWORD   i;

    for ( i = 0 ; i < (DWORD)pArray->GetSize() ; ++i )
    {
        if ( !pArray->ElementAt( i ).GetId().Compare( strId ) )
        {
            return (LPWSTR)(LPCTSTR)(pArray->ElementAt( i ).GetName());
        }
    }

    return pArray->GetSize() == 0 ? NULL : (LPWSTR)(LPCTSTR)(pArray->ElementAt( 0 ).GetName());
}


VOID
CIISVirtualRootParamsPage::SetEnableNext(
    VOID
    )
/*++

Routine Description:

    Set enable state of Finish button

Arguments:

    None

Returns:

    Nothing

--*/
{
    BOOL fAllClusterEnabled = TRUE;
    CArray <IISMapper, IISMapper>* pArray = m_nServerType == SERVER_TYPE_WWW ? &m_W3Array : &m_FTPArray;
    
    for (int nIndex = 0 ; nIndex < pArray->GetSize() ; ++nIndex )
    {
        if( !pArray->ElementAt(nIndex).IsClusterEnabled() )
        {
            fAllClusterEnabled = FALSE;
            break;
        }
    }
   
    
    fAllClusterEnabled = !fAllClusterEnabled;
    
    EnableNext( fAllClusterEnabled );
}

void CIISVirtualRootParamsPage::OnRefresh() 
{
	m_fReadList = FALSE;

	m_W3Array.RemoveAll();
	m_FTPArray.RemoveAll();
	
	FillServerList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\iis.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Iis.h
//
//	Abstract:
//		Definition of the CIISVirtualRootParamsPage class, which implements the
//		Parameters page for IIS resources.
//
//	Implementation File:
//		Iis.cpp
//
//	Author:
//		Pete Benoit (v-pbenoi)	October 16, 1996
//		David Potter (davidp)	October 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _IIS_H_
#define _IIS_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#include "ConstDef.h"   // for IIS_SVC_NAME_WWW/IIS_SVC_NAME_FTP

#define SERVER_TYPE_FTP     0
#define SERVER_TYPE_WWW     1
#define SERVER_TYPE_UNKNOWN    -1

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CIISVirtualRootParamsPage;
class IISMapper;

//
// Private prototypes
//

class IISMapper {
public:
    IISMapper() {}
    
    IISMapper( LPWSTR pszName, LPWSTR pszId, BOOL fClusterEnabled, int nServerType = SERVER_TYPE_UNKNOWN)
        :   m_strName           ( pszName ), 
            m_strId             ( pszId ),
            m_fClusterEnabled   ( fClusterEnabled),
            m_nServerType       ( nServerType )
    {
    }
    
    CString& GetName()  { return m_strName; }
    CString& GetId()    { return m_strId; }
    int      GetServerType() { return m_nServerType; }
    BOOL     IsClusterEnabled() { return m_fClusterEnabled; }
    

private:
    CString     m_strName;
    CString     m_strId;
    BOOL        m_fClusterEnabled;
    int         m_nServerType;
} ;

/////////////////////////////////////////////////////////////////////////////
//
//	CIISVirtualRootParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CIISVirtualRootParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CIISVirtualRootParamsPage)

// Construction
public:
	CIISVirtualRootParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CIISVirtualRootParamsPage)
	enum { IDD = IDD_PP_IIS_PARAMETERS };
	CButton	m_ckbWrite;
	CButton	m_ckbRead;
	CButton	m_groupAccess;
	CEdit	m_editPassword;
	CStatic	m_staticPassword;
	CEdit	m_editAccountName;
	CStatic	m_staticAccountName;
	CButton	m_groupAccountInfo;
	CEdit	m_editDirectory;
	CButton	m_rbWWW;
	CButton	m_rbFTP;
	int		m_nServerType;
	int     m_nInitialServerType;
	CString	m_strDirectory;
    CString	m_strAccountName;
	CString	m_strPassword;
	CEdit	m_editInstanceId;
        CComboBox m_cInstanceId;
    CString m_strInstanceName;
    CString m_strInstanceId;
	BOOL	m_bRead;
	BOOL	m_bWrite;
	//}}AFX_DATA
	CString m_strServiceName;
	CString m_strPrevServiceName;
	CString	m_strPrevDirectory;
    CString	m_strPrevAccountName;
	CString	m_strPrevPassword;
	CString	m_strPrevInstanceId;
    DWORD   m_dwAccessMask;
    DWORD   m_dwPrevAccessMask;

protected:
	enum
	{
		epropServiceName,
		epropInstanceId,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIISVirtualRootParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }
    void FillServerList();
    void SetEnableNext();


private:
    BOOL   m_fReadList;
    CArray <IISMapper, IISMapper>  m_W3Array, m_FTPArray;

    LPWSTR  NameToMetabaseId( BOOL  fIsW3, CString&  strName);
    LPWSTR  MetabaseIdToName( BOOL  fIsW3, CString&  strId);
    HRESULT ReadList(CArray <IISMapper, IISMapper>* pMapperArray, LPWSTR pszPath, LPCWSTR wcsServerName, int nServerType);


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CIISVirtualRootParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeRequiredField();
	afx_msg void OnChangeServiceType();
	afx_msg void OnRefresh();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CIISVirtualRootParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _IIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\iisclex4.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//      Copyright (c) 1996-1997 Microsoft Corporation
//
//      Module Name:
//              IISClEx4.cpp
//
//      Abstract:
//              Implementation of the CIISCluExApp class and DLL initialization
//              routines.
//
//      Author:
//              David Potter (davidp)   June 28, 1996
//
//      Revision History:
//
//      Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "IISClEx4.h"
#include "ExtObj.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#include <atlimpl.cpp>

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_CoIISClEx4, CExtObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
STDAPI DllCanUnloadNow(void);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
HRESULT HrDeleteKey(IN const CString & rstrKey);
STDAPI DllGetCluAdminExtensionCaps(
        OUT DWORD *             pdwCaps,
        OUT CLSID *             pclsid,
        OUT LPWSTR              pwszResTypeNames,
        IN OUT DWORD *  pcchResTypeNames
        );

/////////////////////////////////////////////////////////////////////////////
// class CIISCluExApp
/////////////////////////////////////////////////////////////////////////////

class CIISCluExApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();

private:
    TCHAR   szHelpPath[MAX_PATH+1];
};

CIISCluExApp theApp;

BOOL CIISCluExApp::InitInstance()
{
        _Module.Init(ObjectMap, m_hInstance);

        //
        // Setup the help file
        //

        if (GetWindowsDirectory(szHelpPath, MAX_PATH))
        {
            lstrcat(szHelpPath,_T("\\help\\iishelp\\iis\\winhelp\\iisclex4.hlp"));
            m_pszHelpFilePath = szHelpPath;
        }
                
        return CWinApp::InitInstance();
}

int CIISCluExApp::ExitInstance()
{
        m_pszHelpFilePath = NULL;
        _Module.Term();
        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow() && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
        HRESULT hRes = S_OK;
        // registers object, typelib and all interfaces in typelib
        hRes = _Module.RegisterServer(FALSE /*bRegTypeLib*/);
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
        HRESULT hRes = S_OK;
        _Module.UnregisterServer();
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      FormatError
//
//      Routine Description:
//              Format an error.
//
//      Arguments:
//              rstrError       [OUT] String in which to return the error message.
//              dwError         [IN] Error code to format.
//
//      Return Value:
//              None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError(CString & rstrError, DWORD dwError)
{
        DWORD           dwResult;
        TCHAR           szError[256];

        dwResult = ::FormatMessage(
                                        FORMAT_MESSAGE_FROM_SYSTEM,
                                        NULL,
                                        dwError,
                                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                        szError,
                                        sizeof(szError) / sizeof(TCHAR),
                                        0
                                        );
        if (dwResult == 0)
        {
                // Format the NT status code from NTDLL since this hasn't been
                // integrated into the system yet.
                dwResult = ::FormatMessage(
                                                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                                                ::GetModuleHandle(_T("NTDLL.DLL")),
                                                dwError,
                                                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                                szError,
                                                sizeof(szError) / sizeof(TCHAR),
                                                0
                                                );
                if (dwResult == 0)
                {
                        // Format the NT status code from CLUSAPI.  This is necessary
                        // for the cases where cluster messages haven't been added to
                        // the system message file yet.
                        dwResult = ::FormatMessage(
                                                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                                                        ::GetModuleHandle(_T("CLUSAPI.DLL")),
                                                        dwError,
                                                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                                        szError,
                                                        sizeof(szError) / sizeof(TCHAR),
                                                        0
                                                        );
                }  // if:  error formatting status code from NTDLL
        }  // if:  error formatting status code from system

        if (dwResult != 0)
                rstrError = szError;
        else
        {
                TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), dwResult, dwError);
                rstrError.Format(_T("Error 0x%08.8x"));
        }  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//      DllGetCluAdminExtensionCaps
//
//      Routine Description:
//              Returns the CLSID supported by this extension.
//
//      Arguments:
//              pdwCaps                         [OUT] DWORD in which to return extension capabilities.
//              pclsid                          [OUT] Place in which to return the CLSID.
//              pwszResTypeNames        [OUT] Buffer in which to return the resource type
//                                                        names supported by this extension.  Each name is
//                                                        null-terminated.  Two nulls follow the last name.
//              pcchResTypeNames        [IN OUT] On input, contains the number of characters
//                                                        available in the output buffer, including the
//                                                        null-terminators.  On output, contains the
//                                                        total number of characters written, not
//                                                        including the null-terminator.
//
//      Return Value:
//              S_OK                    Capabilities returned successfully.
//              E_INVALIDARG    Invalid argument specified.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllGetCluAdminExtensionCaps(
        OUT DWORD *             pdwCaps,
        OUT CLSID *             pclsid,
        OUT LPWSTR              pwszResTypeNames,
        IN OUT DWORD *  pcchResTypeNames
        )
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // Validate arguments.
        if ((pdwCaps == NULL)
                        || (pclsid == NULL)
                        || (pwszResTypeNames == NULL)
                        || (pcchResTypeNames == NULL)
                        || (*pcchResTypeNames < 1)
                        )
                return E_INVALIDARG;

        // Set capabilities flags.
        *pdwCaps = 0
                        //| CLUADMEX_CAPS_RESOURCE_PAGES
                        ;

        // Copy the CLSID to the caller's buffer.
        CopyMemory(pclsid, &CLSID_CoIISClEx4, sizeof(CLSID));

        // Return the resource type names we support.
        {
                DWORD   cchCopy = min(g_cchResourceTypeNames, *pcchResTypeNames);
                CopyMemory(pwszResTypeNames, g_wszResourceTypeNames, cchCopy * sizeof(WCHAR));
                *pcchResTypeNames = cchCopy;
        }  // Return he resource type names we support

        return S_OK;

}  //*** DllGetCluAdminExtensionCaps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//      DllRegisterCluAdminExtension
//
//      Routine Description:
//              Register the extension with the cluster database.
//
//      Arguments:
//              hCluster                [IN] Handle to the cluster to modify.
//
//      Return Value:
//              S_OK                    Extension registered successfully.
//              Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hCluster)
{
        HRESULT         hr = S_OK;
        LPCWSTR         pwszResTypes = g_wszResourceTypeNames;

        while (*pwszResTypes != L'\0')
        {
                hr = RegisterCluAdminResourceTypeExtension(
                                        hCluster,
                                        pwszResTypes,
                                        &CLSID_CoIISClEx4
                                        );
                if (hr != S_OK)
                        break;

                wprintf(L"  %s\n", pwszResTypes);
                pwszResTypes += lstrlenW(pwszResTypes) + 1;
        }  // while:  more resource types

        return hr;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//      DllUnregisterCluAdminExtension
//
//      Routine Description:
//              Unregister the extension with the cluster database.
//
//      Arguments:
//              hCluster                [IN] Handle to the cluster to modify.
//
//      Return Value:
//              S_OK                    Extension unregistered successfully.
//              Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hCluster)
{
        HRESULT         hr = S_OK;
        LPCWSTR         pwszResTypes = g_wszResourceTypeNames;

        while (*pwszResTypes != L'\0')
        {
                wprintf(L"  %s\n", pwszResTypes);
                hr = UnregisterCluAdminResourceTypeExtension(
                                        hCluster,
                                        pwszResTypes,
                                        &CLSID_CoIISClEx4
                                        );
                if (hr != S_OK)
                        break;
                pwszResTypes += lstrlenW(pwszResTypes) + 1;
        }  // while:  more resource types

        return hr;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\iisclex4.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		IISClEx3.h
//
//	Abstract:
//		Global definitions across the DLL.
//
//	Implementation File:
//		IISClEx3.cpp
//
//	Author:
//		David Potter (davidp)	August 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _IISCLEX3_H_
#define _IISCLEX3_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"

#ifndef _CONSTDEF_H_
#include "ConstDef.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;

/////////////////////////////////////////////////////////////////////////////

#endif // _IISCLEX3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\nntpprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      Iis.cpp
//
//  Abstract:
//      Implementation of the CNNTPVirtualRootParamsPage class.
//
//  Author:
//      Pete Benoit (v-pbenoi)  October 16, 1996
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <inetinfo.h>
#include "IISClEx4.h"
#include "nntpprop.h"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmap*

#include <iadm.h>
#include <iiscnfgp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CNNTPVirtualRootParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNNTPVirtualRootParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNNTPVirtualRootParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CNNTPVirtualRootParamsPage)
    ON_CBN_SELCHANGE(IDC_PP_NNTP_INSTANCEID, OnChangeRequiredField)
    ON_BN_CLICKED(IDC_PP_NNTP_REFRESH, OnRefresh)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::CNNTPVirtualRootParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNNTPVirtualRootParamsPage::CNNTPVirtualRootParamsPage(void)
    : CBasePropertyPage(g_rghelpmapIISParameters)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CNNTPVirtualRootParamsPage)
    m_strInstanceId = _T("");
    //}}AFX_DATA_INIT

    m_fReadList = FALSE;
    
    try
    {
        m_strServiceName = IIS_SVC_NAME_NNTP;
    }  // try
    catch (CMemoryException * pme)
    {
        pme->ReportError();
        pme->Delete();
    }  // catch:  CMemoryException

    // Setup the property array.
    {
        m_rgProps[epropServiceName].Set(REGPARAM_IIS_SERVICE_NAME, m_strServiceName, m_strPrevServiceName);
        m_rgProps[epropInstanceId].Set(REGPARAM_IIS_INSTANCEID, m_strInstanceId, m_strPrevInstanceId);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_NNTP_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_NNTP_PARAMETERS;
    m_idcPPTitle = IDC_PP_NNTP_TITLE;

}  //*** CNNTPVirtualRootParamsPage::CNNTPVirtualRootParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNNTPVirtualRootParamsPage::DoDataExchange(CDataExchange * pDX)
{
    CString     strInstanceId;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::DoDataExchange(pDX);
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_MAP(CNNTPVirtualRootParamsPage)
    DDX_Control(pDX, IDC_PP_NNTP_INSTANCEID, m_cInstanceId);
    DDX_Text(pDX, IDC_PP_NNTP_INSTANCEID, m_strInstanceName);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BBackPressed())
        {
            DDV_RequiredText(pDX, IDC_PP_NNTP_INSTANCEID, IDC_PP_NNTP_INSTANCEID_LABEL, m_strInstanceName);
        }  // if:  Back button not pressed

        m_strInstanceId = NameToMetabaseId( m_strInstanceName );

        m_strServiceName = IIS_SVC_NAME_NNTP;
    }  // if:  saving data from dialog

}  //*** CNNTPVirtualRootParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNNTPVirtualRootParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    m_cInstanceId.EnableWindow( TRUE );

    OnChangeCtrl();

    if (!BWizard())
    {
        FillServerList();
    }

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNNTPVirtualRootParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNNTPVirtualRootParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        FillServerList();
    }  // if:  in the wizard

    return CBasePropertyPage::OnSetActive();

}  //*** CNNTPVirtualRootParamsPage::OnSetActive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::OnChangeRequiredField
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNNTPVirtualRootParamsPage::OnChangeRequiredField(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        SetEnableNext();
    }  // if:  in a wizard

}  //*** CNNTPVirtualRootParamsPage::OnChangeRequiredField()

////


void 
CNNTPVirtualRootParamsPage::FillServerList(
    )
/*++

Routine Description:

    Populate server combo box with server list relevant to current service type,
    set current selection based on server instance ID
    enable Finish button if list non empty

Arguments:

    None

Returns:

    Nothing

--*/
{

    int nIndex;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // build array if not already done
    //
    
    if ( !m_fReadList )
    {
        HRESULT hr;
        
        hr = ReadList( &m_ServiceArray, MD_SERVICE_ROOT_NNTP, LPCTSTR(Peo()->StrNodeName()) );
        
        if (FAILED(hr))
        {
            CString err;

            if ( REGDB_E_IIDNOTREG == hr)
            {
                err.Format(IDS_IIS_PROXY_MISCONFIGURED, Peo()->StrNodeName());
                AfxMessageBox(err);
            }
            else
            {
                CString fmtError;
                DWORD   dwError;

                if ( (HRESULT_FACILITY(hr) == FACILITY_WIN32) ||
                     (HRESULT_FACILITY(hr) == FACILITY_NT_BIT))
                {
                    dwError = (DWORD) HRESULT_CODE(hr);
                }
                else
                {
                    dwError = (DWORD) hr;
                }
                
                FormatError(fmtError, dwError);
                
                err.Format(IDS_ENUMERATE_FAILED, Peo()->StrNodeName(), fmtError);
                AfxMessageBox(err);
            }

            m_cInstanceId.EnableWindow(FALSE);
        }
        else
        {
            m_cInstanceId.EnableWindow(TRUE);
        }
        
        m_fReadList = TRUE;
    }

    m_strInstanceName = MetabaseIdToName( m_strInstanceId );

    // add to combo from array

    DWORD  nAddCount = 0;

    m_cInstanceId.ResetContent();

    for ( nIndex = 0 ; nIndex < m_ServiceArray.GetSize() ; ++nIndex )
    {
        //
        // Only add sites that are not cluster enabled or have the same ID as the resource
        //
    
        if ( (!m_ServiceArray.ElementAt(nIndex).IsClusterEnabled()) || 
             (!lstrcmp( m_ServiceArray.ElementAt( nIndex ).GetId(), m_strInstanceId))
           )
        {
            if ( m_cInstanceId.AddString( m_ServiceArray.ElementAt( nIndex ).GetName() ) < 0 )
            {
                OutputDebugStringW( L"Error add\n" );
            }
            else
            {
                nAddCount++;
            }
        }
    }

    if (0 == nAddCount)
    {
        m_cInstanceId.EnableWindow(FALSE);

        if (BWizard())
        {
            CString err;

            EnableNext(FALSE);

            err.Format(IDS_ALL_INSTANCES_CLUSTER_ENABLED, Peo()->StrNodeName());
            AfxMessageBox(err);
        }
    }
    else
    {
        if (BWizard())
        {
            SetEnableNext();
            m_cInstanceId.SetCurSel(0);
        }
        else
        {
            nIndex = m_cInstanceId.FindStringExact(-1, m_strInstanceName);

            if ( nIndex != CB_ERR )
            {
                m_cInstanceId.SetCurSel(nIndex);
            }
        }
    }
}


HRESULT
CNNTPVirtualRootParamsPage::ReadList(
    CArray <IISMapper, IISMapper>* pMapperArray,
    LPWSTR          pszPath,
    LPCWSTR          wcsMachineName
    )
/*++

Routine Description:

    Read a server list from metabase based on metabase path

Arguments:

    pMapperArray - array where to add list of ( ServerComment, InstanceId ) pairs
    pszPath - metabase path, e.g. LM/NNTPSVC

Returns:

    Error code, S_OK if success

--*/
{
    IMSAdminBaseW *     pcAdmCom = NULL;
    METADATA_HANDLE     hmd;
    DWORD               i;
    WCHAR               aId[METADATA_MAX_NAME_LEN];
    WCHAR               aName[512];
    HRESULT             hRes = S_OK;
    COSERVERINFO        csiMachine;
    MULTI_QI            QI = {&IID_IMSAdminBase, NULL, 0};
  
    ZeroMemory( &csiMachine, sizeof(COSERVERINFO) );
    csiMachine.pwszName = (LPWSTR)wcsMachineName;

    hRes = CoCreateInstanceEx(  GETAdminBaseCLSID(TRUE), 
                                NULL, 
                                CLSCTX_SERVER, 
                                &csiMachine,
                                1,
                                &QI
                              );

    if ( SUCCEEDED(hRes) && SUCCEEDED(QI.hr))
    {
        pcAdmCom = (IMSAdminBaseW *)QI.pItf;
        
        if( SUCCEEDED( hRes = pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                 pszPath,
                                                 METADATA_PERMISSION_READ,
                                                 5000,
                                                 &hmd)) )
        {
            for ( i = 0 ;
                  SUCCEEDED(pcAdmCom->EnumKeys( hmd, L"", aId, i )) ;
                  ++i )
            {
                METADATA_RECORD md;
                DWORD           dwReq = sizeof(aName);

                memset( &md, 0, sizeof(md) );
                
                md.dwMDDataType     = STRING_METADATA;
                md.dwMDUserType     = IIS_MD_UT_SERVER;
                md.dwMDIdentifier   = MD_SERVER_COMMENT;
                md.dwMDDataLen      = sizeof(aName);
                md.pbMDData         = (LPBYTE)aName;

                if ( SUCCEEDED( pcAdmCom->GetData( hmd, aId, &md, &dwReq) ) )
                {
                    DWORD   dwClusterEnabled = 0;

                    memset( &md, 0, sizeof(md) );
                    
                    md.dwMDDataType     = DWORD_METADATA;
                    md.dwMDUserType     = IIS_MD_UT_SERVER;
                    md.dwMDIdentifier   = MD_CLUSTER_ENABLED;
                    md.dwMDDataLen      = sizeof(dwClusterEnabled);
                    md.pbMDData         = (LPBYTE)&dwClusterEnabled;

                    pcAdmCom->GetData( hmd, aId, &md, &dwReq);
                
                    IISMapper*  pMap = new IISMapper( aName, aId, dwClusterEnabled );
                    
                    if ( pMap )
                    {
                        pMapperArray->Add( *pMap );
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                        break;
                    }
                }
            }

            pcAdmCom->CloseKey( hmd );
        }

        pcAdmCom->Release();
    }

    return hRes;
}


LPWSTR
CNNTPVirtualRootParamsPage::NameToMetabaseId(
    CString&    strName
    )
/*++

Routine Description:

    Convert ServerComment to InstanceId

Arguments:

    strName - ServerComment

Returns:

    InstanceId if strName found in array, otherwise NULL

--*/
{
    DWORD   i;

    for ( i = 0 ; i < (DWORD)m_ServiceArray.GetSize() ; ++i )
    {
        if ( !m_ServiceArray.ElementAt( i ).GetName().Compare( strName ) )
        {
            return (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( i ).GetId());
        }
    }

    return NULL;
}


LPWSTR
CNNTPVirtualRootParamsPage::MetabaseIdToName(
    CString&    strId
    )
/*++

Routine Description:

    Convert InstanceId to ServerComment

Arguments:

    strId - InstanceID

Returns:

    InstanceId if strName found in array. 
    If not found return 1st array element if array not empty, otherwise NULL

--*/
{
    DWORD   i;

    for ( i = 0 ; i < (DWORD)m_ServiceArray.GetSize() ; ++i )
    {
        if ( !m_ServiceArray.ElementAt( i ).GetId().Compare( strId ) )
        {
            return (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( i ).GetName());
        }
    }

    return m_ServiceArray.GetSize() == 0 ? NULL : (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( 0 ).GetName());
}


VOID
CNNTPVirtualRootParamsPage::SetEnableNext(
    VOID
    )
/*++

Routine Description:

    Set enable state of Finish button

Arguments:

    None

Returns:

    Nothing

--*/
{
    EnableNext( m_ServiceArray.GetSize() ? TRUE : FALSE );
}

void CNNTPVirtualRootParamsPage::OnRefresh() 
{
    m_fReadList = FALSE;

    m_ServiceArray.RemoveAll();
    
    FillServerList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropLstS.cpp
//
//	Abstract:
//		Stub for implementation of property list classes.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropList.h
//
//	Abstract:
//		Definition of the CClusPropList class.
//
//	Implementation File:
//		PropList.cpp
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _PROPLIST_H_
#define _PROPLIST_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CObjectProperty;
class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CObjectProperty
/////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

class CObjectProperty
{
public:
	LPCWSTR					m_pwszName;
	CLUSTER_PROPERTY_FORMAT	m_propFormat;

	union CValue
	{
		CString *	pstr;
		DWORD *		pdw;
		BOOL *		pb;
		struct
		{
			PBYTE *	ppb;
			DWORD *	pcb;
		};
	};
	CValue					m_value;
	CValue					m_valuePrev;

	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_value.pcb = NULL;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN DWORD & rdwValue,
				IN DWORD & rdwPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pdw = &rdwValue;
		m_value.pcb = NULL;
		m_valuePrev.pdw = &rdwPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN BOOL & rbValue,
				IN BOOL & rbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pb = &rbValue;
		m_value.pcb = NULL;
		m_valuePrev.pb = &rbPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN PBYTE & rpbValue,
				IN DWORD & rcbValue,
				IN PBYTE & rpbPrevValue,
				IN DWORD & rcbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_BINARY;
		m_value.ppb = &rpbValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = &rpbPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN LPWSTR & rpwszValue,
				IN DWORD & rcbValue,
				IN LPWSTR & rpwszPrevValue,
				IN DWORD & rcbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_MULTI_SZ;
		m_value.ppb = (PBYTE *) &rpwszValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = (PBYTE *) &rpwszPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
	}

};  //*** class CObjectProperty

/////////////////////////////////////////////////////////////////////////////
// CClusPropList dialog
/////////////////////////////////////////////////////////////////////////////

class CClusPropList : public CObject
{
	DECLARE_DYNAMIC(CClusPropList);

// Construction
public:
	CClusPropList(IN BOOL bAlwaysAddProp = FALSE);
	~CClusPropList(void);

// Attributes
protected:
	BOOL					m_bAlwaysAddProp;

	CLUSPROP_BUFFER_HELPER	m_proplist;
	CLUSPROP_BUFFER_HELPER	m_propCurrent;
	DWORD					m_cbBufferSize;
	DWORD					m_cbDataSize;

public:
	const CLUSPROP_BUFFER_HELPER const *	Proplist(void) const	{ return &m_proplist; }
	PBYTE					PbProplist(void) const	{ return m_proplist.pb; }
	DWORD					CbProplist(void) const	{ return m_cbDataSize + sizeof(CLUSPROP_SYNTAX); /*endmark*/ }
	DWORD					Cprops(void) const
	{
		if (m_proplist.pb == NULL)
			return 0;
		return m_proplist.pList->nPropertyCount;
	}

	void					AddProp(
								IN LPCWSTR			pwszName,
								IN const CString &	rstrValue,
								IN const CString &	rstrPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN DWORD			dwValue,
								IN DWORD			dwPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN const PBYTE		pbValue,
								IN DWORD			cbValue,
								IN const PBYTE		pbPrevValue,
								IN DWORD			cbPrevValue
								);

	void					AllocPropList(IN DWORD cbMinimum);

// Operations
public:
	DWORD					DwGetNodeProperties(
								IN HNODE		hNode,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetGroupProperties(
								IN HGROUP		hGroup,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetResourceProperties(
								IN HRESOURCE	hResource,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetResourceTypeProperties(
								IN HCLUSTER		hCluster,
								IN LPCWSTR		pwszResTypeName,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetNetworkProperties(
								IN HNETWORK		hNetwork,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetNetInterfaceProperties(
								IN HNETINTERFACE	hNetInterface,
								IN DWORD			dwControlCode,
								IN HNODE			hHostNode		= NULL,
								IN LPVOID			lpInBuffer		= NULL,
								IN DWORD			cbInBufferSize	= 0
								);

// Overrides

// Implementation
protected:
	void					CopyProp(
								IN PCLUSPROP_SZ				pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN LPCWSTR					pwsz,
								IN DWORD					cbsz = 0
								);
	void					CopyProp(
								IN PCLUSPROP_DWORD			pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN DWORD					dw
								);
	void					CopyProp(
								IN PCLUSPROP_BINARY			pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN const PBYTE				pb,
								IN DWORD					cb
								);

	DWORD					DwGetPrivateProps(
								OUT PBYTE *					ppbProps,
								IN CLUSTER_CONTROL_OBJECT	ccobjtype = CLUS_OBJECT_RESOURCE
								);
	DWORD					DwSetPrivateProps(
								IN PBYTE					pbProps,
								IN DWORD					cbProps,
								IN CLUSTER_CONTROL_OBJECT	ccobjtype = CLUS_OBJECT_RESOURCE
								);

};  //*** class CClusPropList

#pragma warning( default : 4201 )

/////////////////////////////////////////////////////////////////////////////

#endif // _PROPLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\regext.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExt.cpp
//
//	Abstract:
//		Implementation of routines for extension registration.
//
//	Author:
//		David Potter (davidp)	April 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <stdafx.h>
#include <ole2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define REG_VALUE_ADMIN_EXTENSIONS L"AdminExtensions"

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminClusterExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** RegisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** RegisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** RegisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminClusterExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** UnregisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** UnregisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Register the extension.
			hr = RegisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyRegistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been registered yet.
			if (pwszValue == NULL)
				bAlreadyRegistered = FALSE;
			else
			{
				LPCWSTR	pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyRegistered = (*pwszValue != L'\0');
			}  // else:  extension value exists

			// Register the extension.
			if (!bAlreadyRegistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize + (cbSize ? 0 : sizeof(WCHAR)) + (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	cch;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if (pwszValue != NULL)
					{
						while (*pwszValueBuf != L'\0')
						{
							lstrcpyW(pwszNewValueBuf, pwszValueBuf);
							cch = lstrlenW(pwszValueBuf);
							pwszValueBuf += cch + 1;
							pwszNewValueBuf += cch + 1;
						}  // while:  more strings in the extension list
					}  // if:  previous value buffer existed

					// Add the new CLSID to the list.
					lstrcpyW(pwszNewValueBuf, pwszClsid);
					pwszNewValueBuf += lstrlenW(pwszClsid) + 1;
					*pwszNewValueBuf = L'\0';

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not registered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Unregister the extension.
			hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyUnregistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been unregistered yet.
			if (pwszValue == NULL)
				bAlreadyUnregistered = TRUE;
			else
			{
				LPCWSTR pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyUnregistered = (*pwszValue != L'\0');
			}  // else:  extension value exists

			// Unregister the extension.
			if (!bAlreadyUnregistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize - (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if (pwszValue != NULL)
					{
						while (*pwszValueBuf != L'\0')
						{
							if (lstrcmpW(pwszClsid, pwszValueBuf) != 0)
							{
								lstrcpyW(pwszNewValueBuf, pwszValueBuf);
								pwszNewValueBuf += lstrlen(pwszNewValueBuf) + 1;
							}  // if:  not CLSID being removed
							pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
						}  // while:  more strings in the extension list
					}  // if:  previous value buffer existed

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not unregistered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ReadValue
//
//	Routine Description:
//		Reads a value from the cluster database.
//
//	Arguments:
//		hkey			[IN] Handle for the key to read from.
//		pwszValueName	[IN] Name of value to read.
//		ppwszValue		[OUT] Address of pointer in which to return data.
//							The string is allocated using LocalAlloc and must
//							be deallocated by the calling LocalFree.
//		pcbSize			[OUT] Size in bytes of the allocated value buffer.
//
//	Return Value:
//		Any return values from ClusterRegQueryValue or errors from new.
//
//--
/////////////////////////////////////////////////////////////////////////////

static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	)
{
	DWORD		dwStatus;
	DWORD		cbSize;
	DWORD		dwType;
	LPWSTR		pwszValue;

	*ppwszValue = NULL;
	*pcbSize = 0;

	// Get the length of the value.
	dwStatus = ClusterRegQueryValue(
					hkey,
					pwszValueName,
					&dwType,
					NULL,
					&cbSize
					);
	if (   (dwStatus != ERROR_SUCCESS)
		&& (dwStatus != ERROR_MORE_DATA))
	{
		if (dwStatus  == ERROR_FILE_NOT_FOUND)
			dwStatus = ERROR_SUCCESS;
		return dwStatus;
	}  // if:  error occurred

	// Allocate a value string.
	pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbSize);
	if (pwszValue == NULL)
	{
		dwStatus = GetLastError();
		return dwStatus;
	}  // if:  error allocating memory

	// Read the the value.
	dwStatus = ClusterRegQueryValue(
					hkey,
					pwszValueName,
					&dwType,
					(LPBYTE) pwszValue,
					&cbSize
					);
	if (dwStatus != ERROR_SUCCESS)
	{
		LocalFree(pwszValue);
		pwszValue = NULL;
		cbSize = 0;
	}  // if:  error occurred

	*ppwszValue = pwszValue;
	*pcbSize = cbSize;
	return dwStatus;

}  //*** ReadValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\nntpprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      nntpprop.h
//
//  Abstract:
//      Definition of the CNNTPVirtualRootParamsPage class, which implements the
//      Parameters page for IIS resources.
//
//  Implementation File:
//      Iis.cpp
//
//  Author:
//      Pete Benoit (v-pbenoi)  October 16, 1996
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NNTPPROP_H_
#define _NNTPPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

#include "ConstDef.h"   // for IIS_SVC_NAME_NNTP
#include "Iis.h"		// for IISMapper

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNNTPVirtualRootParamsPage;
class IISMapper;

/////////////////////////////////////////////////////////////////////////////
//
//  CNNTPVirtualRootParamsPage
//
//  Purpose:
//      Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CNNTPVirtualRootParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CNNTPVirtualRootParamsPage)

// Construction
public:
    CNNTPVirtualRootParamsPage(void);

// Dialog Data
    //{{AFX_DATA(CNNTPVirtualRootParamsPage)
    enum { IDD = IDD_PP_NNTP_PARAMETERS };
    CButton m_ckbWrite;
    CButton m_ckbRead;
    CButton m_groupAccess;
    CEdit   m_editPassword;
    CStatic m_staticPassword;
    CEdit   m_editAccountName;
    CStatic m_staticAccountName;
    CButton m_groupAccountInfo;
    CEdit   m_editDirectory;
    CString m_strDirectory;
    CString m_strAccountName;
    CString m_strPassword;
    CEdit   m_editInstanceId;
    CComboBox m_cInstanceId;
    CString m_strInstanceName;
    CString m_strInstanceId;
    BOOL    m_bRead;
    BOOL    m_bWrite;
    //}}AFX_DATA
    CString m_strServiceName;
    CString m_strPrevServiceName;
    CString m_strPrevDirectory;
    CString m_strPrevAccountName;
    CString m_strPrevPassword;
    CString m_strPrevInstanceId;
    DWORD   m_dwAccessMask;
    DWORD   m_dwPrevAccessMask;

protected:
    enum
    {
        epropServiceName,
        epropInstanceId,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CNNTPVirtualRootParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }
    void FillServerList();
    void SetEnableNext();


private:
    BOOL   m_fReadList;
    CArray <IISMapper, IISMapper>  m_ServiceArray;

    LPWSTR  NameToMetabaseId( CString&  strName);
    LPWSTR  MetabaseIdToName( CString&  strId);
    HRESULT ReadList(CArray <IISMapper, IISMapper>* pMapperArray, LPWSTR pszPath, LPCWSTR wcsServerName);


// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CNNTPVirtualRootParamsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeRequiredField();
    afx_msg void OnRefresh();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CNNTPVirtualRootParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _NNTPPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\proplist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropList.cpp
//
//	Abstract:
//		Implementation of the CClusPropList class.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.h"
#include "BarfClus.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define BUFFER_GROWTH_FACTOR 256

/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CClusPropList, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CClusPropList
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropList::CClusPropList(IN BOOL bAlwaysAddProp)
{
	m_proplist.pList = NULL;
	m_propCurrent.pb = NULL;
	m_cbBufferSize = 0;
	m_cbDataSize = 0;

	m_bAlwaysAddProp = bAlwaysAddProp;

}  //*** CClusPropList::CClusPropList();

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::~CClusPropList
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropList::~CClusPropList(void)
{
	delete [] m_proplist.pb;

}  //*** CClusPropList::~CClusPropList();

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		rstrValue		[IN] Value of the property to set in the list.
//		rstrPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR			pwszName,
	IN const CString &	rstrValue,
	IN const CString &	rstrPrevValue
	)
{
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_SZ			pValue;

	ASSERT(pwszName != NULL);

	if (m_bAlwaysAddProp || (rstrValue != rstrPrevValue))
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_SZ)
						+ ALIGN_CLUSPROP((rstrValue.GetLength() + 1) * sizeof(WCHAR))
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pStringValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, rstrValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value has changed

}  //*** CClusPropList::AddProp(CString)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a DWORD property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		dwValue			[IN] Value of the property to set in the list.
//		dwPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR		pwszName,
	IN DWORD		dwValue,
	IN DWORD		dwPrevValue
	)
{
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_DWORD			pValue;

	ASSERT(pwszName != NULL);

	if (m_bAlwaysAddProp || (dwValue != dwPrevValue))
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_DWORD)
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pDwordValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, dwValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value has changed

}  //*** CClusPropList::AddProp(DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a binary property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pbValue			[IN] Value of the property to set in the list.
//		cbValue			[IN] Count of bytes in pbValue.
//		pbPrevValue		[IN] Previous value of the property.
//		cbPrevValue		[IN] Count of bytes in pbPrevValue.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR			pwszName,
	IN const PBYTE		pbValue,
	IN DWORD			cbValue,
	IN const PBYTE		pbPrevValue,
	IN DWORD			cbPrevValue
	)
{
	BOOL					bChanged = FALSE;
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_BINARY		pValue;

	ASSERT(pwszName != NULL);
	ASSERT(((cbValue == 0) && (cbPrevValue == 0)) || (pbValue != pbPrevValue));

	// Determine if the buffer has changed.
	if (m_bAlwaysAddProp || (cbValue != cbPrevValue))
		bChanged = TRUE;
	else if (!((cbValue == 0) && (cbPrevValue == 0)))
		bChanged = memcmp(pbValue, pbPrevValue, cbValue) == 0;

	if (bChanged)
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_BINARY)
						+ ALIGN_CLUSPROP(cbValue)
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pBinaryValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value changed

}  //*** CClusPropList::AddProp(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of string.
//		pwsz		[IN] String to copy.
//		cbsz		[IN] Count of bytes in pwsz string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN LPCWSTR					pwsz,
	IN DWORD					cbsz
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);
	ASSERT(pwsz != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
	pprop->Syntax.wType = (WORD) proptype;
	if (cbsz == 0)
		cbsz = (lstrlenW(pwsz) + 1) * sizeof(WCHAR);
	ASSERT(cbsz == (lstrlenW(pwsz) + 1) * sizeof(WCHAR));
	pprop->cbLength = cbsz;
	lstrcpyW(pprop->sz, pwsz);

	// Set an endmark.
	props.pStringValue = pprop;
	props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cbsz);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(CString)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a DWORD property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of DWORD.
//		dw			[IN] DWORD to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_DWORD			pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN DWORD					dw
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
	pprop->Syntax.wType = (WORD) proptype;
	pprop->cbLength = sizeof(DWORD);
	pprop->dw = dw;

	// Set an endmark.
	props.pDwordValue = pprop;
	props.pb += sizeof(*props.pDwordValue);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a binary property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of string.
//		pb			[IN] Block to copy.
//		cbsz		[IN] Count of bytes in pb buffer.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_BINARY		pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN const PBYTE				pb,
	IN DWORD					cb
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
	pprop->Syntax.wType = (WORD) proptype;
	pprop->cbLength = cb;
	if (cb > 0)
		CopyMemory(pprop->rgb, pb, cb);

	// Set an endmark.
	props.pBinaryValue = pprop;
	props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cb);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AllocPropList
//
//	Routine Description:
//		Allocate a property list buffer that's big enough to hold the next
//		property.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by BYTE::operator new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AllocPropList(
	IN DWORD	cbMinimum
	)
{
	DWORD		cbTotal;

	ASSERT(cbMinimum > 0);

	// Add the size of the item count and final endmark.
	cbMinimum += sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
	cbTotal = m_cbDataSize + cbMinimum;

	if (m_cbBufferSize < cbTotal)
	{
		PBYTE	pbNewProplist;

		cbMinimum = max(BUFFER_GROWTH_FACTOR, cbMinimum);
		cbTotal = m_cbDataSize + cbMinimum;

		// Allocate and zero a new buffer.
		pbNewProplist = new BYTE[cbTotal];
		ZeroMemory(pbNewProplist, cbTotal);

		// If there was a previous buffer, copy it and the delete it.
		if (m_proplist.pb != NULL)
		{
			if (m_cbDataSize != 0)
				CopyMemory(pbNewProplist, m_proplist.pb, m_cbDataSize);
			delete [] m_proplist.pb;
			m_propCurrent.pb = pbNewProplist + (m_propCurrent.pb - m_proplist.pb);
		}  // if:  there was a previous buffer
		else
			m_propCurrent.pb = pbNewProplist + sizeof(DWORD); // move past prop count

		// Save the new buffer.
		m_proplist.pb = pbNewProplist;
		m_cbBufferSize = cbTotal;
	}  // if:  buffer isn't big enough

}  //*** CClusPropList::AllocPropList(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNodeProperties
//
//	Routine Description:
//		Get properties on a node.
//
//	Arguments:
//		hNode			[IN] Handle for the node to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNodeProperties(
	IN HNODE		hNode,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hNode != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterNodeControl(
						hNode,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNodeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetGroupProperties
//
//	Routine Description:
//		Get properties on a group.
//
//	Arguments:
//		hGroup			[IN] Handle for the group to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetGroupProperties(
	IN HGROUP		hGroup,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hGroup != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterGroupControl(
						hGroup,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetResourceProperties
//
//	Routine Description:
//		Get properties on a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetResourceProperties(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hResource != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetResourceProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetResourceTypeProperties
//
//	Routine Description:
//		Get properties on a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetResourceTypeProperties(
	IN HCLUSTER		hCluster,
	IN LPCWSTR		pwszResTypeName,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hCluster != NULL);
	ASSERT(pwszResTypeName != NULL);
	ASSERT(*pwszResTypeName != L'\0');
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetResourceTypeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNetworkProperties
//
//	Routine Description:
//		Get properties on a network.
//
//	Arguments:
//		hNetwork		[IN] Handle for the network to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNetworkProperties(
	IN HNETWORK		hNetwork,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hNetwork != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterNetworkControl(
						hNetwork,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNetworkProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNetInterfaceProperties
//
//	Routine Description:
//		Get properties on a network interface.
//
//	Arguments:
//		hNetInterface	[IN] Handle for the network interface to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNetInterfaceProperties(
	IN HNETINTERFACE	hNetInterface,
	IN DWORD			dwControlCode,
	IN HNODE			hHostNode,
	IN LPVOID			lpInBuffer,
	IN DWORD			cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hNetInterface != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterNetInterfaceControl(
						hNetInterface,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNetInterfaceProperties()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\regext.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExt.h
//
//	Abstract:
//		Definitions of routines for extension registration.
//
//	Implementation File:
//		RegExt.cpp
//
//	Author:
//		David Potter (davidp)	April 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGEXT_H_
#define _REGEXT_H_

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

// Registration routines.

STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

// Unregistration routines.

STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _REGEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\smtpprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      Iis.cpp
//
//  Abstract:
//      Implementation of the CSMTPVirtualRootParamsPage class.
//
//  Author:
//      Pete Benoit (v-pbenoi)  October 16, 1996
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <inetinfo.h>
#include "IISClEx4.h"
#include "smtpprop.h"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmap*

#include <iadm.h>
#include <iiscnfgp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSMTPVirtualRootParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CSMTPVirtualRootParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CSMTPVirtualRootParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CSMTPVirtualRootParamsPage)
    ON_CBN_SELCHANGE(IDC_PP_SMTP_INSTANCEID, OnChangeRequiredField)
    ON_BN_CLICKED(IDC_PP_SMTP_REFRESH, OnRefresh)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::CSMTPVirtualRootParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSMTPVirtualRootParamsPage::CSMTPVirtualRootParamsPage(void)
    : CBasePropertyPage(g_rghelpmapIISParameters)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CSMTPVirtualRootParamsPage)
    m_strInstanceId = _T("");
    //}}AFX_DATA_INIT

    m_fReadList = FALSE;
    
    try
    {
        m_strServiceName = IIS_SVC_NAME_SMTP;
    }  // try
    catch (CMemoryException * pme)
    {
        pme->ReportError();
        pme->Delete();
    }  // catch:  CMemoryException

    // Setup the property array.
    {
        m_rgProps[epropServiceName].Set(REGPARAM_IIS_SERVICE_NAME, m_strServiceName, m_strPrevServiceName);
        m_rgProps[epropInstanceId].Set(REGPARAM_IIS_INSTANCEID, m_strInstanceId, m_strPrevInstanceId);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_SMTP_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_SMTP_PARAMETERS;
    m_idcPPTitle = IDC_PP_SMTP_TITLE;

}  //*** CSMTPVirtualRootParamsPage::CSMTPVirtualRootParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSMTPVirtualRootParamsPage::DoDataExchange(CDataExchange * pDX)
{
    CString     strInstanceId;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::DoDataExchange(pDX);
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_MAP(CSMTPVirtualRootParamsPage)
    DDX_Control(pDX, IDC_PP_SMTP_INSTANCEID, m_cInstanceId);
    DDX_Text(pDX, IDC_PP_SMTP_INSTANCEID, m_strInstanceName);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BBackPressed())
        {
            DDV_RequiredText(pDX, IDC_PP_SMTP_INSTANCEID, IDC_PP_SMTP_INSTANCEID_LABEL, m_strInstanceName);
        }  // if:  Back button not pressed

        m_strInstanceId = NameToMetabaseId( m_strInstanceName );

        m_strServiceName = IIS_SVC_NAME_SMTP;
    }  // if:  saving data from dialog

}  //*** CSMTPVirtualRootParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CSMTPVirtualRootParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    m_cInstanceId.EnableWindow( TRUE );

    OnChangeCtrl();

    if (!BWizard())
    {
        FillServerList();
    }

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CSMTPVirtualRootParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CSMTPVirtualRootParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        FillServerList();
    }  // if:  in the wizard

    return CBasePropertyPage::OnSetActive();

}  //*** CSMTPVirtualRootParamsPage::OnSetActive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::OnChangeRequiredField
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSMTPVirtualRootParamsPage::OnChangeRequiredField(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        SetEnableNext();
    }  // if:  in a wizard

}  //*** CSMTPVirtualRootParamsPage::OnChangeRequiredField()

////


void 
CSMTPVirtualRootParamsPage::FillServerList(
    )
/*++

Routine Description:

    Populate server combo box with server list relevant to current service type,
    set current selection based on server instance ID
    enable Finish button if list non empty

Arguments:

    None

Returns:

    Nothing

--*/
{

    int nIndex;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // build array if not already done
    //
    
    if ( !m_fReadList )
    {
        HRESULT hr;
        
        hr = ReadList( &m_ServiceArray, MD_SERVICE_ROOT_SMTP, LPCTSTR(Peo()->StrNodeName()) );
        
        if (FAILED(hr))
        {
            CString err;

            if ( REGDB_E_IIDNOTREG == hr)
            {
                err.Format(IDS_IIS_PROXY_MISCONFIGURED, Peo()->StrNodeName());
                AfxMessageBox(err);
            }
            else
            {
                CString fmtError;
                DWORD   dwError;

                if ( (HRESULT_FACILITY(hr) == FACILITY_WIN32) ||
                     (HRESULT_FACILITY(hr) == FACILITY_NT_BIT))
                {
                    dwError = (DWORD) HRESULT_CODE(hr);
                }
                else
                {
                    dwError = (DWORD) hr;
                }
                
                FormatError(fmtError, dwError);
                
                err.Format(IDS_ENUMERATE_FAILED, Peo()->StrNodeName(), fmtError);
                AfxMessageBox(err);
            }

            m_cInstanceId.EnableWindow(FALSE);
        }
        else
        {
            m_cInstanceId.EnableWindow(TRUE);
        }
        
        m_fReadList = TRUE;
    }

    m_strInstanceName = MetabaseIdToName( m_strInstanceId );

    // add to combo from array

    DWORD  nAddCount = 0;

    m_cInstanceId.ResetContent();

    for ( nIndex = 0 ; nIndex < m_ServiceArray.GetSize() ; ++nIndex )
    {
        //
        // Only add sites that are not cluster enabled or have the same ID as the resource
        //
    
        if ( (!m_ServiceArray.ElementAt(nIndex).IsClusterEnabled()) || 
             (!lstrcmp( m_ServiceArray.ElementAt( nIndex ).GetId(), m_strInstanceId))
           )
        {
            if ( m_cInstanceId.AddString( m_ServiceArray.ElementAt( nIndex ).GetName() ) < 0 )
            {
                OutputDebugStringW( L"Error add\n" );
            }
            else
            {
                nAddCount++;
            }
        }
    }

    if (0 == nAddCount)
    {
        m_cInstanceId.EnableWindow(FALSE);

        if (BWizard())
        {
            CString err;

            EnableNext(FALSE);

            err.Format(IDS_ALL_INSTANCES_CLUSTER_ENABLED, Peo()->StrNodeName());
            AfxMessageBox(err);
        }
    }
    else
    {
        if (BWizard())
        {
            SetEnableNext();
            m_cInstanceId.SetCurSel(0);
        }
        else
        {
            nIndex = m_cInstanceId.FindStringExact(-1, m_strInstanceName);

            if ( nIndex != CB_ERR )
            {
                m_cInstanceId.SetCurSel(nIndex);
            }
        }
    }
}


HRESULT
CSMTPVirtualRootParamsPage::ReadList(
    CArray <IISMapper, IISMapper>* pMapperArray,
    LPWSTR          pszPath,
    LPCWSTR          wcsMachineName
    )
/*++

Routine Description:

    Read a server list from metabase based on metabase path

Arguments:

    pMapperArray - array where to add list of ( ServerComment, InstanceId ) pairs
    pszPath - metabase path, e.g. LM/SMTPSVC

Returns:

    Error code, S_OK if success

--*/
{
    IMSAdminBaseW *     pcAdmCom = NULL;
    METADATA_HANDLE     hmd;
    DWORD               i;
    WCHAR               aId[METADATA_MAX_NAME_LEN];
    WCHAR               aName[512];
    HRESULT             hRes = S_OK;
    COSERVERINFO        csiMachine;
    MULTI_QI            QI = {&IID_IMSAdminBase, NULL, 0};
  
    ZeroMemory( &csiMachine, sizeof(COSERVERINFO) );
    csiMachine.pwszName = (LPWSTR)wcsMachineName;

    hRes = CoCreateInstanceEx(  GETAdminBaseCLSID(TRUE), 
                                NULL, 
                                CLSCTX_SERVER, 
                                &csiMachine,
                                1,
                                &QI
                              );

    if ( SUCCEEDED(hRes) && SUCCEEDED(QI.hr))
    {
        pcAdmCom = (IMSAdminBaseW *)QI.pItf;
        
        if( SUCCEEDED( hRes = pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                 pszPath,
                                                 METADATA_PERMISSION_READ,
                                                 5000,
                                                 &hmd)) )
        {
            for ( i = 0 ;
                  SUCCEEDED(pcAdmCom->EnumKeys( hmd, L"", aId, i )) ;
                  ++i )
            {
                METADATA_RECORD md;
                DWORD           dwReq = sizeof(aName);

                memset( &md, 0, sizeof(md) );
                
                md.dwMDDataType     = STRING_METADATA;
                md.dwMDUserType     = IIS_MD_UT_SERVER;
                md.dwMDIdentifier   = MD_SERVER_COMMENT;
                md.dwMDDataLen      = sizeof(aName);
                md.pbMDData         = (LPBYTE)aName;

                if ( SUCCEEDED( pcAdmCom->GetData( hmd, aId, &md, &dwReq) ) )
                {
                    DWORD   dwClusterEnabled = 0;

                    memset( &md, 0, sizeof(md) );
                    
                    md.dwMDDataType     = DWORD_METADATA;
                    md.dwMDUserType     = IIS_MD_UT_SERVER;
                    md.dwMDIdentifier   = MD_CLUSTER_ENABLED;
                    md.dwMDDataLen      = sizeof(dwClusterEnabled);
                    md.pbMDData         = (LPBYTE)&dwClusterEnabled;

                    pcAdmCom->GetData( hmd, aId, &md, &dwReq);
                
                    IISMapper*  pMap = new IISMapper( aName, aId, dwClusterEnabled );
                    
                    if ( pMap )
                    {
                        pMapperArray->Add( *pMap );
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                        break;
                    }
                }
            }

            pcAdmCom->CloseKey( hmd );
        }

        pcAdmCom->Release();
    }

    return hRes;
}


LPWSTR
CSMTPVirtualRootParamsPage::NameToMetabaseId(
    CString&    strName
    )
/*++

Routine Description:

    Convert ServerComment to InstanceId

Arguments:

    strName - ServerComment

Returns:

    InstanceId if strName found in array, otherwise NULL

--*/
{
    DWORD   i;

    for ( i = 0 ; i < (DWORD)m_ServiceArray.GetSize() ; ++i )
    {
        if ( !m_ServiceArray.ElementAt( i ).GetName().Compare( strName ) )
        {
            return (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( i ).GetId());
        }
    }

    return NULL;
}


LPWSTR
CSMTPVirtualRootParamsPage::MetabaseIdToName(
    CString&    strId
    )
/*++

Routine Description:

    Convert InstanceId to ServerComment

Arguments:

    strId - InstanceID

Returns:

    InstanceId if strName found in array. 
    If not found return 1st array element if array not empty, otherwise NULL

--*/
{
    DWORD   i;

    for ( i = 0 ; i < (DWORD)m_ServiceArray.GetSize() ; ++i )
    {
        if ( !m_ServiceArray.ElementAt( i ).GetId().Compare( strId ) )
        {
            return (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( i ).GetName());
        }
    }

    return m_ServiceArray.GetSize() == 0 ? NULL : (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( 0 ).GetName());
}


VOID
CSMTPVirtualRootParamsPage::SetEnableNext(
    VOID
    )
/*++

Routine Description:

    Set enable state of Finish button

Arguments:

    None

Returns:

    Nothing

--*/
{
    EnableNext( m_ServiceArray.GetSize() ? TRUE : FALSE );
}

void CSMTPVirtualRootParamsPage::OnRefresh() 
{
    m_fReadList = FALSE;

    m_ServiceArray.RemoveAll();
    
    FillServerList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iisclex4.rc
//
#define IDD_PP_IIS_PARAMETERS           136
#define IDD_WIZ_IIS_PARAMETERS          145
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_IIS_FTP                  1080
#define IDC_PP_IIS_GOPHER               1081
#define IDC_PP_IIS_WWW                  1082
#define IDC_PP_IIS_INSTANCEID_LABEL     1083
#define IDC_PP_IIS_INSTANCEID           1084
#define IDC_PP_IIS_DIRECTORY_LABEL      1085
#define IDC_PP_IIS_DIRECTORY            1086
#define IDC_PP_IIS_BROWSE               1087
#define IDC_PP_IIS_ACCOUNTNAME_LABEL    1088
#define IDC_PP_IIS_ACCOUNTNAME          1089
#define IDC_PP_IIS_PASSWORD_LABEL       1090
#define IDC_PP_IIS_PASSWORD             1091
#define IDC_PP_IIS_ACCT_INFO_GROUP      1092
#define IDC_PP_IIS_ACCESS_GROUP         1093
#define IDC_PP_IIS_READ_ACCESS          1094
#define IDC_PP_IIS_WRITE_ACCESS         1095
#define IDC_PP_REFRESH                  1178
#define IDS_CLUADMEX_COMOBJ_DESC        30500
#define IDS_WRITE                       30501
#define IDS_EXECUTE                     30502
#define IDS_MENU_WHATS_THIS             30503
#define IDS_UNKNOWN_ERROR               31100
#define IDS_APPLY_PARAM_CHANGES_ERROR   31101
#define IDS_REQUIRED_FIELD_EMPTY        31102
#define IDS_INVALID_IIS_SERVICE_TYPE    31103
#define IDS_ENUMERATE_FAILED            31104
#define IDS_ACCESS_DENIED               31105
#define IDS_IIS_PROXY_MISCONFIGURED     31106
#define IDS_ALL_INSTANCES_CLUSTER_ENABLED 31107
#define IDS_DEFAULT_SITE_NAME           31108

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        152
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1179
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

// SMTP specific resource IDs
#define IDD_PP_SMTP_PARAMETERS          200
#define IDD_WIZ_SMTP_PARAMETERS         201
#define IDC_PP_SMTP_TITLE               202
#define IDC_PP_SMTP_INSTANCEID_LABEL    1200
#define IDC_PP_SMTP_INSTANCEID          1201
#define IDC_PP_SMTP_REFRESH             1202

// NNTP specific resource IDs
#define IDD_PP_NNTP_PARAMETERS          300
#define IDD_WIZ_NNTP_PARAMETERS         301
#define IDC_PP_NNTP_TITLE               302
#define IDC_PP_NNTP_INSTANCEID_LABEL    1300
#define IDC_PP_NNTP_INSTANCEID          1301
#define IDC_PP_NNTP_REFRESH             1302
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CluAdmEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE			// Microsoft Windows NT Cluster Administrator
							//   Extension DLLs need to be Unicode
							//   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>			// MFC core and standard components
#include <afxext.h>			// MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
//#include <afxpriv.h>		// used for OLE2T T2OLE conversions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifndef _CLUSTER_API_
#include <clusapi.h>	// for cluster definitions
#endif

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT	IDS;
typedef UINT	IDD;
typedef UINT    IDC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\cmdsync\iissync.cxx ===
#define INITGUID
#include    <windows.h>
#include    <stdio.h>
#include    <ole2.h>
#include    "mdsync.h"

//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


BOOL        g_fDone = FALSE;
DWORD       g_dwTarget = 0;
SYNC_STAT*  g_pStat = NULL;
CHAR        g_achMsg1[128];
CHAR        g_achMsg2[128];
CHAR        g_achMsg3[128];
CHAR        g_achMsg4[128];
CHAR        g_achMsg5[128];
CHAR        g_achMsg6[128];
CHAR        g_achMsg7[128];
CHAR        g_achMsg8[128];
CHAR        g_achMsg9[128];


DWORD
WINAPI
Monitor(
    LPVOID  pV
    )
{
    for ( ;; )
    {
        printf( g_achMsg1, 
                g_pStat->m_dwSourceScan, 
                g_pStat->m_fSourceComplete ? g_achMsg2 : g_achMsg3 );
        for ( UINT i = 0 ; i < g_dwTarget ; ++i )
        {
            printf( "(%d,%d), ", g_pStat->m_adwTargets[i*2], g_pStat->m_adwTargets[i*2+1] );
        }
        printf( "\r" );

        if ( g_fDone )
        {
            break;
        }

        Sleep( 1000 );
    }

    return 0;
}


/* INTRINSA ignore = all */
VOID
DisplayErrorMessage(
    DWORD   dwErr
    )
{
    LPSTR   pErr;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPSTR)&pErr,
            0,
            NULL ) )
    {
        LPSTR   p;

        if ( p = strchr( pErr, '\r' ) )
        {
            *p = '\0';
        }
        fputs( pErr, stdout );

        LocalFree( pErr );
    }
    else
    {
        fputs( g_achMsg9, stdout );
    }
}


int __cdecl main( int argc, char*argv[] )
{
    IMdSync*    pIf;
    LPDWORD     pdwErr;
    HANDLE      hThread;
    DWORD       dwThreadId;
    LPSTR       pTargets;
    int         iA;
    UINT        cT;
    int         Status = 0;
    HRESULT     hRes;
    DWORD       dwFlags = 0;
    DWORD       iT;
    BOOL        fAtLeastOnError = FALSE;

    if ( argc < 2 )
    {
        CHAR    achMsg[2048];

        if ( LoadString( NULL, 100, achMsg, sizeof(achMsg) ) )
        {
            printf( achMsg );
        }
        return 3;
    }

    if ( !LoadString( NULL, 101, g_achMsg1, sizeof(g_achMsg1) ) ||
         !LoadString( NULL, 102, g_achMsg2, sizeof(g_achMsg2) ) ||
         !LoadString( NULL, 103, g_achMsg3, sizeof(g_achMsg3) ) ||
         !LoadString( NULL, 105, g_achMsg5, sizeof(g_achMsg5) ) ||
         !LoadString( NULL, 106, g_achMsg6, sizeof(g_achMsg6) ) ||
         !LoadString( NULL, 107, g_achMsg7, sizeof(g_achMsg7) ) ||
         !LoadString( NULL, 108, g_achMsg8, sizeof(g_achMsg8) ) ||
         !LoadString( NULL, 109, g_achMsg9, sizeof(g_achMsg9) ) ||
         !LoadString( NULL, 104, g_achMsg4, sizeof(g_achMsg4) ) )
    {
        DisplayErrorMessage( GetLastError() );
        return 1;
    }

    //
    // Count targets, get target name length
    //

    for ( cT = 1, g_dwTarget=0, iA = 1 ; iA < argc ; ++iA )
    {
        if ( argv[iA][0] == '-' )
        {
            switch ( argv[iA][1] )
            {
                case 'c':
                    dwFlags |= MD_SYNC_FLAG_CHECK_ADMINEX_SIGNATURE;
                    break;        
            }
        }
        else
        {
            cT += strlen( argv[iA] ) + 1;
            ++g_dwTarget;
        }
    }

    if ( !(g_pStat = (SYNC_STAT*)LocalAlloc( LMEM_FIXED, 
                sizeof(SYNC_STAT)+sizeof(DWORD)*2*g_dwTarget )) ||
         !(pTargets = (LPSTR)LocalAlloc( LMEM_FIXED, cT )) ||
         !(pdwErr = (LPDWORD)LocalAlloc( LMEM_FIXED, sizeof(DWORD)*g_dwTarget)) )
    {
        DisplayErrorMessage( GetLastError() );
        return 1;
    }

    memset ( g_pStat, '\0', sizeof(SYNC_STAT)+sizeof(DWORD)*2*g_dwTarget  );

    //
    // Create target string
    //

    for ( cT = 0, iA = 1 ; iA < argc ; ++iA )
    {
        if ( argv[iA][0] != '-' )
        {
            strcpy( pTargets + cT, argv[iA] );
            cT += strlen( argv[iA] ) + 1;
        }
    }
    pTargets[cT] = '\0';

    //
    // call synchronize method
    //

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( SUCCEEDED( hRes = CoCreateInstance( CLSID_MDSync, NULL, CLSCTX_INPROC_SERVER,  IID_IMDSync, (LPVOID*)&pIf ) ) )
    {
        hThread = CreateThread( NULL, 0, ::Monitor, NULL, 0, &dwThreadId );

        hRes = pIf->Synchronize( pTargets, pdwErr, dwFlags, (LPDWORD)g_pStat );

        g_fDone = TRUE;

        if ( hThread )
        {
            WaitForSingleObject( hThread, INFINITE );
        }
        printf( "\n" );

        pIf->Release();

        if ( FAILED( hRes ) && hRes != E_FAIL )
        {
            DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
            Status = 2;
        }
        else
        {
            for ( cT = 0, iA = 1, iT = 0 ; iA < argc ; ++iA )
            {
                if ( argv[iA][0] != '-' )
                {
                    if ( pdwErr[iT] )
                    {
                        printf( g_achMsg5, argv[iA] );
                        DisplayErrorMessage( pdwErr[iT] );
                        printf( g_achMsg6, pdwErr[iT], pdwErr[iT] );
                        fAtLeastOnError = TRUE;
                    }
                    else
                    {
                        printf( g_achMsg4, argv[iA] );
                    }
                    ++iT;
                }
            }

            if ( fAtLeastOnError )
            {
                Status = 2;
            }
        }
    }
    else
    {
        DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
        Status = 2;
    }

    CoUninitialize();

    LocalFree( g_pStat );
    LocalFree( pTargets );
    LocalFree( pdwErr );

    if ( Status )
    {
        printf( g_achMsg8 );
    }
    else
    {
        printf( g_achMsg7 );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Dummy header file because we don't support trace tags in DLLs.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

class CTraceTag
{
public:
	CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL) {}

};  //*** class CTraceTag

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
 #define	TraceError				;/##/
 #define	InitAllTraceTags		;/##/

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\admex\smtpprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      smtpprop.h
//
//  Abstract:
//      Definition of the CSMTPVirtualRootParamsPage class, which implements the
//      Parameters page for IIS resources.
//
//  Implementation File:
//      Iis.cpp
//
//  Author:
//      Pete Benoit (v-pbenoi)  October 16, 1996
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SMTPPROP_H_
#define _SMTPPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

#include "ConstDef.h"   // for IIS_SVC_NAME_SMTP
#include "Iis.h"		// for IISMapper

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CSMTPVirtualRootParamsPage;
class IISMapper;

/////////////////////////////////////////////////////////////////////////////
//
//  CSMTPVirtualRootParamsPage
//
//  Purpose:
//      Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CSMTPVirtualRootParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CSMTPVirtualRootParamsPage)

// Construction
public:
    CSMTPVirtualRootParamsPage(void);

// Dialog Data
    //{{AFX_DATA(CSMTPVirtualRootParamsPage)
    enum { IDD = IDD_PP_SMTP_PARAMETERS };
    CButton m_ckbWrite;
    CButton m_ckbRead;
    CButton m_groupAccess;
    CEdit   m_editPassword;
    CStatic m_staticPassword;
    CEdit   m_editAccountName;
    CStatic m_staticAccountName;
    CButton m_groupAccountInfo;
    CEdit   m_editDirectory;
    CString m_strDirectory;
    CString m_strAccountName;
    CString m_strPassword;
    CEdit   m_editInstanceId;
    CComboBox m_cInstanceId;
    CString m_strInstanceName;
    CString m_strInstanceId;
    BOOL    m_bRead;
    BOOL    m_bWrite;
    //}}AFX_DATA
    CString m_strServiceName;
    CString m_strPrevServiceName;
    CString m_strPrevDirectory;
    CString m_strPrevAccountName;
    CString m_strPrevPassword;
    CString m_strPrevInstanceId;
    DWORD   m_dwAccessMask;
    DWORD   m_dwPrevAccessMask;

protected:
    enum
    {
        epropServiceName,
        epropInstanceId,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSMTPVirtualRootParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }
    void FillServerList();
    void SetEnableNext();


private:
    BOOL   m_fReadList;
    CArray <IISMapper, IISMapper>  m_ServiceArray;

    LPWSTR  NameToMetabaseId( CString&  strName);
    LPWSTR  MetabaseIdToName( CString&  strId);
    HRESULT ReadList(CArray <IISMapper, IISMapper>* pMapperArray, LPWSTR pszPath, LPCWSTR wcsServerName);


// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CSMTPVirtualRootParamsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeRequiredField();
    afx_msg void OnRefresh();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CSMTPVirtualRootParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _SMTPPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\api_rpc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Tue Mar 04 14:21:58 1997
 */
/* Compiler settings for api_rpc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __api_rpc_h__
#define __api_rpc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __clusapi_INTERFACE_DEFINED__
#define __clusapi_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: clusapi
 * at Tue Mar 04 14:21:58 1997
 * using MIDL 3.00.44
 ****************************************/
/* [explicit_handle][version][uuid] */ 


typedef /* [context_handle] */ void __RPC_FAR *HCLUSTER_RPC;

typedef /* [context_handle] */ void __RPC_FAR *HNOTIFY_RPC;

typedef /* [context_handle] */ void __RPC_FAR *HNODE_RPC;

typedef /* [context_handle] */ void __RPC_FAR *HGROUP_RPC;

typedef /* [context_handle] */ void __RPC_FAR *HRES_RPC;

typedef /* [context_handle] */ void __RPC_FAR *HKEY_RPC;

typedef struct  _RPC_SECURITY_DESCRIPTOR
    {
    /* [length_is][size_is] */ UCHAR __RPC_FAR *lpSecurityDescriptor;
    DWORD cbInSecurityDescriptor;
    DWORD cbOutSecurityDescriptor;
    }	RPC_SECURITY_DESCRIPTOR;

typedef struct _RPC_SECURITY_DESCRIPTOR __RPC_FAR *PRPC_SECURITY_DESCRIPTOR;

typedef struct  _RPC_SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    RPC_SECURITY_DESCRIPTOR RpcSecurityDescriptor;
    BOOL bInheritHandle;
    }	RPC_SECURITY_ATTRIBUTES;

typedef struct _RPC_SECURITY_ATTRIBUTES __RPC_FAR *PRPC_SECURITY_ATTRIBUTES;

/* client prototype */
HCLUSTER_RPC ApiOpenCluster( 
    /* [in] */ handle_t IDL_handle,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);
/* server prototype */
HCLUSTER_RPC s_ApiOpenCluster( 
    /* [in] */ handle_t IDL_handle,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiCloseCluster( 
    /* [out][in] */ HCLUSTER_RPC __RPC_FAR *Cluster);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiCloseCluster( 
    /* [out][in] */ HCLUSTER_RPC __RPC_FAR *Cluster);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiSetClusterName( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR NewClusterName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiSetClusterName( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR NewClusterName);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetClusterName( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ LPWSTR __RPC_FAR *ClusterName,
    /* [out] */ LPWSTR __RPC_FAR *NodeName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetClusterName( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ LPWSTR __RPC_FAR *ClusterName,
    /* [out] */ LPWSTR __RPC_FAR *NodeName);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetClusterVersion( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ WORD __RPC_FAR *lpwMajorVersion,
    /* [out] */ WORD __RPC_FAR *lpwMinorVersion,
    /* [out] */ WORD __RPC_FAR *lpwBuildNumber,
    /* [string][out] */ LPWSTR __RPC_FAR *lpszVendorId,
    /* [string][out] */ LPWSTR __RPC_FAR *lpszCSDVersion);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetClusterVersion( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ WORD __RPC_FAR *lpwMajorVersion,
    /* [out] */ WORD __RPC_FAR *lpwMinorVersion,
    /* [out] */ WORD __RPC_FAR *lpwBuildNumber,
    /* [string][out] */ LPWSTR __RPC_FAR *lpszVendorId,
    /* [string][out] */ LPWSTR __RPC_FAR *lpszCSDVersion);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetQuorumResource( 
    /* [in] */ handle_t IDL_handle,
    /* [string][out] */ LPWSTR __RPC_FAR *lpszResourceName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetQuorumResource( 
    /* [in] */ handle_t IDL_handle,
    /* [string][out] */ LPWSTR __RPC_FAR *lpszResourceName);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiSetQuorumResource( 
    /* [in] */ HRES_RPC hResource);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiSetQuorumResource( 
    /* [in] */ HRES_RPC hResource);

typedef struct  _ENUM_ENTRY
    {
    DWORD Type;
    /* [string] */ LPWSTR Name;
    }	ENUM_ENTRY;

typedef struct _ENUM_ENTRY __RPC_FAR *PENUM_ENTRY;

typedef struct  _ENUM_LIST
    {
    DWORD EntryCount;
    /* [size_is] */ ENUM_ENTRY Entry[ 1 ];
    }	ENUM_LIST;

typedef struct _ENUM_LIST __RPC_FAR *PENUM_LIST;

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiCreateEnum( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD dwType,
    /* [out] */ PENUM_LIST __RPC_FAR *ReturnEnum);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiCreateEnum( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD dwType,
    /* [out] */ PENUM_LIST __RPC_FAR *ReturnEnum);

/* client prototype */
HRES_RPC ApiOpenResource( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszResourceName,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);
/* server prototype */
HRES_RPC s_ApiOpenResource( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszResourceName,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);

/* client prototype */
HRES_RPC ApiCreateResource( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [string][in] */ LPCWSTR lpszResourceName,
    /* [string][in] */ LPCWSTR lpszResourceType,
    /* [in] */ DWORD dwFlags,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);
/* server prototype */
HRES_RPC s_ApiCreateResource( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [string][in] */ LPCWSTR lpszResourceName,
    /* [string][in] */ LPCWSTR lpszResourceType,
    /* [in] */ DWORD dwFlags,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiDeleteResource( 
    /* [in] */ HRES_RPC hResource);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiDeleteResource( 
    /* [in] */ HRES_RPC hResource);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiCloseResource( 
    /* [out][in] */ HRES_RPC __RPC_FAR *Resource);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiCloseResource( 
    /* [out][in] */ HRES_RPC __RPC_FAR *Resource);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetResourceState( 
    /* [in] */ HRES_RPC hResource,
    /* [out] */ DWORD __RPC_FAR *State,
    /* [string][out] */ LPWSTR __RPC_FAR *NodeName,
    /* [string][out] */ LPWSTR __RPC_FAR *GroupName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetResourceState( 
    /* [in] */ HRES_RPC hResource,
    /* [out] */ DWORD __RPC_FAR *State,
    /* [string][out] */ LPWSTR __RPC_FAR *NodeName,
    /* [string][out] */ LPWSTR __RPC_FAR *GroupName);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiSetResourceName( 
    /* [in] */ HRES_RPC hResource,
    /* [string][in] */ LPCWSTR lpszResourceName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiSetResourceName( 
    /* [in] */ HRES_RPC hResource,
    /* [string][in] */ LPCWSTR lpszResourceName);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetResourceId( 
    /* [in] */ HRES_RPC hResource,
    /* [string][out] */ LPWSTR __RPC_FAR *pGuid);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetResourceId( 
    /* [in] */ HRES_RPC hResource,
    /* [string][out] */ LPWSTR __RPC_FAR *pGuid);

/* client prototype */
error_status_t ApiGetResourceType( 
    /* [in] */ HRES_RPC hResource,
    /* [string][out] */ LPWSTR __RPC_FAR *lpszResourceType);
/* server prototype */
error_status_t s_ApiGetResourceType( 
    /* [in] */ HRES_RPC hResource,
    /* [string][out] */ LPWSTR __RPC_FAR *lpszResourceType);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiFailResource( 
    /* [in] */ HRES_RPC hResource);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiFailResource( 
    /* [in] */ HRES_RPC hResource);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiOnlineResource( 
    /* [in] */ HRES_RPC hResource);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiOnlineResource( 
    /* [in] */ HRES_RPC hResource);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiOfflineResource( 
    /* [in] */ HRES_RPC hResource);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiOfflineResource( 
    /* [in] */ HRES_RPC hResource);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiAddResourceDependency( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HRES_RPC hDependsOn);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiAddResourceDependency( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HRES_RPC hDependsOn);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiRemoveResourceDependency( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HRES_RPC hDependsOn);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiRemoveResourceDependency( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HRES_RPC hDependsOn);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiCanResourceBeDependent( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HRES_RPC hResourceDependent);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiCanResourceBeDependent( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HRES_RPC hResourceDependent);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiCreateResEnum( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ DWORD dwType,
    /* [out] */ PENUM_LIST __RPC_FAR *ReturnEnum);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiCreateResEnum( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ DWORD dwType,
    /* [out] */ PENUM_LIST __RPC_FAR *ReturnEnum);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiAddResourceNode( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HNODE_RPC hNode);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiAddResourceNode( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HNODE_RPC hNode);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiRemoveResourceNode( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HNODE_RPC hNode);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiRemoveResourceNode( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HNODE_RPC hNode);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiChangeResourceGroup( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HGROUP_RPC hGroup);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiChangeResourceGroup( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HGROUP_RPC hGroup);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiCreateResourceType( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszTypeName,
    /* [string][in] */ LPCWSTR lpszDisplayName,
    /* [string][in] */ LPCWSTR lpszDllName,
    /* [in] */ DWORD dwLooksAlive,
    /* [in] */ DWORD dwIsAlive);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiCreateResourceType( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszTypeName,
    /* [string][in] */ LPCWSTR lpszDisplayName,
    /* [string][in] */ LPCWSTR lpszDllName,
    /* [in] */ DWORD dwLooksAlive,
    /* [in] */ DWORD dwIsAlive);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiDeleteResourceType( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszTypeName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiDeleteResourceType( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszTypeName);

/* client prototype */
HKEY_RPC ApiGetRootKey( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD samDesired,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);
/* server prototype */
HKEY_RPC s_ApiGetRootKey( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD samDesired,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);

/* client prototype */
HKEY_RPC ApiCreateKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpSubKey,
    /* [in] */ DWORD dwOptions,
    /* [in] */ DWORD samDesired,
    /* [unique][in] */ PRPC_SECURITY_ATTRIBUTES lpSecurityAttributes,
    /* [out] */ LPDWORD lpdwDisposition,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);
/* server prototype */
HKEY_RPC s_ApiCreateKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpSubKey,
    /* [in] */ DWORD dwOptions,
    /* [in] */ DWORD samDesired,
    /* [unique][in] */ PRPC_SECURITY_ATTRIBUTES lpSecurityAttributes,
    /* [out] */ LPDWORD lpdwDisposition,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);

/* client prototype */
HKEY_RPC ApiOpenKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpSubKey,
    /* [in] */ DWORD samDesired,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);
/* server prototype */
HKEY_RPC s_ApiOpenKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpSubKey,
    /* [in] */ DWORD samDesired,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiEnumKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD dwIndex,
    /* [string][out] */ LPWSTR __RPC_FAR *KeyName,
    /* [out] */ FILETIME __RPC_FAR *lpftLastWriteTime);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiEnumKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD dwIndex,
    /* [string][out] */ LPWSTR __RPC_FAR *KeyName,
    /* [out] */ FILETIME __RPC_FAR *lpftLastWriteTime);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiSetValue( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpValueName,
    /* [in] */ DWORD dwType,
    /* [size_is][in] */ const UCHAR __RPC_FAR *lpData,
    /* [in] */ DWORD cbData);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiSetValue( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpValueName,
    /* [in] */ DWORD dwType,
    /* [size_is][in] */ const UCHAR __RPC_FAR *lpData,
    /* [in] */ DWORD cbData);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiDeleteValue( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpValueName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiDeleteValue( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpValueName);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiQueryValue( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpValueName,
    /* [out] */ DWORD __RPC_FAR *lpValueType,
    /* [size_is][out] */ UCHAR __RPC_FAR *lpData,
    /* [in] */ DWORD cbData,
    /* [out] */ LPDWORD lpcbRequired);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiQueryValue( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpValueName,
    /* [out] */ DWORD __RPC_FAR *lpValueType,
    /* [size_is][out] */ UCHAR __RPC_FAR *lpData,
    /* [in] */ DWORD cbData,
    /* [out] */ LPDWORD lpcbRequired);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiDeleteKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpSubKey);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiDeleteKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [string][in] */ LPCWSTR lpSubKey);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiEnumValue( 
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD dwIndex,
    /* [string][out] */ LPWSTR __RPC_FAR *lpValueName,
    /* [out] */ LPDWORD lpType,
    /* [size_is][out] */ UCHAR __RPC_FAR *lpData,
    /* [out][in] */ LPDWORD lpcbData,
    /* [out] */ LPDWORD TotalSize);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiEnumValue( 
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD dwIndex,
    /* [string][out] */ LPWSTR __RPC_FAR *lpValueName,
    /* [out] */ LPDWORD lpType,
    /* [size_is][out] */ UCHAR __RPC_FAR *lpData,
    /* [out][in] */ LPDWORD lpcbData,
    /* [out] */ LPDWORD TotalSize);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiCloseKey( 
    /* [out][in] */ HKEY_RPC __RPC_FAR *pKey);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiCloseKey( 
    /* [out][in] */ HKEY_RPC __RPC_FAR *pKey);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiQueryInfoKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [out] */ LPDWORD lpcSubKeys,
    /* [out] */ LPDWORD lpcbMaxSubKeyLen,
    /* [out] */ LPDWORD lpcValues,
    /* [out] */ LPDWORD lpcbMaxValueNameLen,
    /* [out] */ LPDWORD lpcbMaxValueLen,
    /* [out] */ LPDWORD lpcbSecurityDescriptor,
    /* [out] */ PFILETIME lpftLastWriteTime);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiQueryInfoKey( 
    /* [in] */ HKEY_RPC hKey,
    /* [out] */ LPDWORD lpcSubKeys,
    /* [out] */ LPDWORD lpcbMaxSubKeyLen,
    /* [out] */ LPDWORD lpcValues,
    /* [out] */ LPDWORD lpcbMaxValueNameLen,
    /* [out] */ LPDWORD lpcbMaxValueLen,
    /* [out] */ LPDWORD lpcbSecurityDescriptor,
    /* [out] */ PFILETIME lpftLastWriteTime);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiSetKeySecurity( 
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD SecurityInformation,
    /* [in] */ PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiSetKeySecurity( 
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD SecurityInformation,
    /* [in] */ PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetKeySecurity( 
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD SecurityInformation,
    /* [out][in] */ PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetKeySecurity( 
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD SecurityInformation,
    /* [out][in] */ PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor);

/* client prototype */
HGROUP_RPC ApiOpenGroup( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszGroupName,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);
/* server prototype */
HGROUP_RPC s_ApiOpenGroup( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszGroupName,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);

/* client prototype */
HGROUP_RPC ApiCreateGroup( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszGroupName,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);
/* server prototype */
HGROUP_RPC s_ApiCreateGroup( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszGroupName,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiDeleteGroup( 
    /* [in] */ HGROUP_RPC Group);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiDeleteGroup( 
    /* [in] */ HGROUP_RPC Group);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiCloseGroup( 
    /* [out][in] */ HGROUP_RPC __RPC_FAR *Group);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiCloseGroup( 
    /* [out][in] */ HGROUP_RPC __RPC_FAR *Group);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetGroupState( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [out] */ DWORD __RPC_FAR *State,
    /* [string][out] */ LPWSTR __RPC_FAR *NodeName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetGroupState( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [out] */ DWORD __RPC_FAR *State,
    /* [string][out] */ LPWSTR __RPC_FAR *NodeName);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiSetGroupName( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [string][in] */ LPCWSTR lpszGroupName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiSetGroupName( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [string][in] */ LPCWSTR lpszGroupName);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetGroupId( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [string][out] */ LPWSTR __RPC_FAR *pGuid);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetGroupId( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [string][out] */ LPWSTR __RPC_FAR *pGuid);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetNodeId( 
    /* [in] */ HNODE_RPC hNode,
    /* [string][out] */ LPWSTR __RPC_FAR *pGuid);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetNodeId( 
    /* [in] */ HNODE_RPC hNode,
    /* [string][out] */ LPWSTR __RPC_FAR *pGuid);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiOnlineGroup( 
    /* [in] */ HGROUP_RPC hGroup);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiOnlineGroup( 
    /* [in] */ HGROUP_RPC hGroup);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiOfflineGroup( 
    /* [in] */ HGROUP_RPC hGroup);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiOfflineGroup( 
    /* [in] */ HGROUP_RPC hGroup);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiMoveGroup( 
    /* [in] */ HGROUP_RPC hGroup);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiMoveGroup( 
    /* [in] */ HGROUP_RPC hGroup);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiMoveGroupToNode( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ HNODE_RPC hNode);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiMoveGroupToNode( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ HNODE_RPC hNode);

/* client prototype */
error_status_t ApiCreateGroupResourceEnum( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ DWORD dwType,
    /* [out] */ PENUM_LIST __RPC_FAR *ReturnEnum);
/* server prototype */
error_status_t s_ApiCreateGroupResourceEnum( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ DWORD dwType,
    /* [out] */ PENUM_LIST __RPC_FAR *ReturnEnum);

/* client prototype */
HNOTIFY_RPC ApiCreateNotify( 
    /* [in] */ handle_t IDL_handle,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *rpc_error);
/* server prototype */
HNOTIFY_RPC s_ApiCreateNotify( 
    /* [in] */ handle_t IDL_handle,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *rpc_error);

/* client prototype */
/* [fault_status][comm_status][fault_status][comm_status] */ error_status_t ApiCloseNotify( 
    /* [out][in] */ HNOTIFY_RPC __RPC_FAR *Notify);
/* server prototype */
/* [fault_status][comm_status][fault_status][comm_status] */ error_status_t s_ApiCloseNotify( 
    /* [out][in] */ HNOTIFY_RPC __RPC_FAR *Notify);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiAddNotifyCluster( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HCLUSTER_RPC hCluster,
    /* [in] */ DWORD dwFilter,
    /* [in] */ DWORD dwNotifyKey);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiAddNotifyCluster( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HCLUSTER_RPC hCluster,
    /* [in] */ DWORD dwFilter,
    /* [in] */ DWORD dwNotifyKey);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiAddNotifyNode( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwFilter,
    /* [in] */ DWORD dwNotifyKey);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiAddNotifyNode( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwFilter,
    /* [in] */ DWORD dwNotifyKey);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiAddNotifyGroup( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ DWORD dwFilter,
    /* [in] */ DWORD dwNotifyKey);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiAddNotifyGroup( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ DWORD dwFilter,
    /* [in] */ DWORD dwNotifyKey);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiAddNotifyResource( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HRES_RPC hResource,
    /* [in] */ DWORD dwFilter,
    /* [in] */ DWORD dwNotifyKey);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiAddNotifyResource( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HRES_RPC hResource,
    /* [in] */ DWORD dwFilter,
    /* [in] */ DWORD dwNotifyKey);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiAddNotifyKey( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD dwNotifyKey,
    /* [in] */ DWORD Filter,
    /* [in] */ BOOL WatchSubTree);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiAddNotifyKey( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ HKEY_RPC hKey,
    /* [in] */ DWORD dwNotifyKey,
    /* [in] */ DWORD Filter,
    /* [in] */ BOOL WatchSubTree);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetNotify( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ DWORD Timeout,
    /* [out] */ DWORD __RPC_FAR *dwNotifyKey,
    /* [out] */ DWORD __RPC_FAR *dwFilter,
    /* [string][out] */ LPWSTR __RPC_FAR *Name);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetNotify( 
    /* [in] */ HNOTIFY_RPC hNotify,
    /* [in] */ DWORD Timeout,
    /* [out] */ DWORD __RPC_FAR *dwNotifyKey,
    /* [out] */ DWORD __RPC_FAR *dwFilter,
    /* [string][out] */ LPWSTR __RPC_FAR *Name);

typedef 
enum _API_NODE_STATE
    {	ApiNodeOnline	= 0,
	ApiNodeOffline	= ApiNodeOnline + 1,
	ApiNodePaused	= ApiNodeOffline + 1
    }	API_NODE_STATE;

/* client prototype */
HNODE_RPC ApiOpenNode( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszNodeName,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);
/* server prototype */
HNODE_RPC s_ApiOpenNode( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszNodeName,
    /* [fault_status][comm_status][out] */ error_status_t __RPC_FAR *Status);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiCloseNode( 
    /* [out][in] */ HNODE_RPC __RPC_FAR *Node);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiCloseNode( 
    /* [out][in] */ HNODE_RPC __RPC_FAR *Node);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGetNodeState( 
    /* [in] */ HNODE_RPC hNode,
    /* [out] */ API_NODE_STATE __RPC_FAR *State);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGetNodeState( 
    /* [in] */ HNODE_RPC hNode,
    /* [out] */ API_NODE_STATE __RPC_FAR *State);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiPauseNode( 
    /* [in] */ HNODE_RPC hNode);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiPauseNode( 
    /* [in] */ HNODE_RPC hNode);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiResumeNode( 
    /* [in] */ HNODE_RPC hNode);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiResumeNode( 
    /* [in] */ HNODE_RPC hNode);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiEvictNode( 
    /* [in] */ HNODE_RPC hNode);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiEvictNode( 
    /* [in] */ HNODE_RPC hNode);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiNodeResourceControl( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiNodeResourceControl( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiResourceControl( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiResourceControl( 
    /* [in] */ HRES_RPC hResource,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiNodeResourceTypeControl( 
    /* [in] */ HCLUSTER_RPC hCluster,
    /* [string][in] */ LPCWSTR lpszResourceTypeName,
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiNodeResourceTypeControl( 
    /* [in] */ HCLUSTER_RPC hCluster,
    /* [string][in] */ LPCWSTR lpszResourceTypeName,
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiResourceTypeControl( 
    /* [in] */ HCLUSTER_RPC hCluster,
    /* [string][in] */ LPCWSTR lpszResourceTypeName,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiResourceTypeControl( 
    /* [in] */ HCLUSTER_RPC hCluster,
    /* [string][in] */ LPCWSTR lpszResourceTypeName,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiNodeGroupControl( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiNodeGroupControl( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiGroupControl( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiGroupControl( 
    /* [in] */ HGROUP_RPC hGroup,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiNodeNodeControl( 
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ HNODE_RPC hHostNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiNodeNodeControl( 
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ HNODE_RPC hHostNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t ApiNodeControl( 
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_ApiNodeControl( 
    /* [in] */ HNODE_RPC hNode,
    /* [in] */ DWORD dwControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *lpInBuffer,
    /* [in] */ DWORD nInBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *lpOutBuffer,
    /* [in] */ DWORD nOutBufferSize,
    /* [out] */ DWORD __RPC_FAR *lpBytesReturned,
    /* [out] */ DWORD __RPC_FAR *lpcbRequired);

/* client prototype */
error_status_t ApiEvPropEvents( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD dwEventInfoSize,
    /* [size_is][in] */ UCHAR __RPC_FAR *pPackedEventInfo);
/* server prototype */
error_status_t s_ApiEvPropEvents( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD dwEventInfoSize,
    /* [size_is][in] */ UCHAR __RPC_FAR *pPackedEventInfo);



extern RPC_IF_HANDLE clusapi_v1_0_c_ifspec;
extern RPC_IF_HANDLE s_clusapi_v1_0_s_ifspec;
#endif /* __clusapi_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

void __RPC_USER HCLUSTER_RPC_rundown( HCLUSTER_RPC );
void __RPC_USER HNOTIFY_RPC_rundown( HNOTIFY_RPC );
void __RPC_USER HNODE_RPC_rundown( HNODE_RPC );
void __RPC_USER HGROUP_RPC_rundown( HGROUP_RPC );
void __RPC_USER HRES_RPC_rundown( HRES_RPC );
void __RPC_USER HKEY_RPC_rundown( HKEY_RPC );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusapi.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    clusapi.h

Abstract:

    This module defines the common management and application interface to
    the Microsoft Cluster Server services.

Revision History:

--*/

#ifndef _CLUSTER_API_
#define _CLUSTER_API_

#ifdef __cplusplus
extern "C" {
#endif


//
// General cluster definitions
//

#ifndef _CLUSTER_API_TYPES_
//
// Defined cluster handle types.
//
typedef struct _HCLUSTER *HCLUSTER;
typedef struct _HNODE *HNODE;
typedef struct _HRESOURCE *HRESOURCE;
typedef struct _HGROUP *HGROUP;
typedef struct _HRESTYPE *HRESTYPE;
typedef struct _HNETWORK *HNETWORK;
typedef struct _HNETINTERFACE *HNETINTERFACE;
typedef struct _HCHANGE *HCHANGE;
typedef struct _HCLUSENUM *HCLUSENUM;
typedef struct _HGROUPENUM *HGROUPENUM;
typedef struct _HRESENUM *HRESENUM;
typedef struct _HNETWORKENUM *HNETWORKENUM;
typedef struct _HNODEENUM *HNODEENUM;

#endif // _CLUSTER_API_TYPES_

//
// Definitions used in cluster management routines.
//

#define MAX_CLUSTERNAME_LENGTH      MAX_COMPUTERNAME_LENGTH

#ifndef _CLUSTER_API_TYPES_
//
// Cluster-related structures and types
//
typedef enum CLUSTER_QUORUM_TYPE {
    OperationalQuorum,
    ModifyQuorum
} CLUSTER_QUORUM_TYPE;

#ifndef MIDL_PASS

typedef struct CLUSTERVERSIONINFO {
    DWORD dwVersionInfoSize;
    WORD  MajorVersion;
    WORD  MinorVersion;
    WORD  BuildNumber;
    WCHAR szVendorId[64];
    WCHAR szCSDVersion[64];
} CLUSTERVERSIONINFO, *LPCLUSTERVERSIONINFO;

#endif // MIDL_PASS

#endif // _CLUSTER_API_TYPES_


//
// Interfaces for managing clusters
//

//
// Cluster API Specific Access Rights
//
#define CLUSAPI_READ_ACCESS     0x00000001L
#define CLUSAPI_CHANGE_ACCESS   0x00000002L
#define CLUSAPI_NO_ACCESS       0x00000004L
#define CLUSAPI_ALL_ACCESS (CLUSAPI_READ_ACCESS | CLUSAPI_CHANGE_ACCESS)



#ifndef MIDL_PASS
HCLUSTER
WINAPI
OpenCluster(
    IN LPCWSTR lpszClusterName
    );

BOOL
WINAPI
CloseCluster(
    IN HCLUSTER hCluster
    );

DWORD
WINAPI
SetClusterName(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNewClusterName
    );

DWORD
WINAPI
GetClusterInformation(
    IN HCLUSTER hCluster,
    OUT LPWSTR lpszClusterName,
    IN OUT LPDWORD lpcbClusterName,
    OUT OPTIONAL LPCLUSTERVERSIONINFO lpClusterInfo
    );

DWORD
WINAPI
GetClusterQuorumResource(
    IN HCLUSTER     hCluster,
    OUT LPWSTR      lpszResourceName,
    IN OUT LPDWORD  lpcbResourceName,
    OUT LPWSTR      lpszDeviceName,
    IN OUT LPDWORD  lpcbDeviceName,
    OUT LPDWORD     lpdwMaxQuorumLogSize
    );

DWORD
WINAPI
SetClusterQuorumResource(
    IN HRESOURCE hResource,
    IN LPCWSTR   lpszDeviceName,
    IN DWORD     dwMaxQuoLogSize
    );

DWORD
WINAPI
SetClusterNetworkPriorityOrder(
    IN HCLUSTER hCluster,
    IN DWORD NetworkCount,
    IN HNETWORK NetworkList[]
    );

#endif // MIDL_PASS

//
// Cluster Event Notification API
//

#ifndef _CLUSTER_API_TYPES_
//
// Cluster event filter flags.
//
typedef enum CLUSTER_CHANGE {
    CLUSTER_CHANGE_NODE_STATE               = 0x00000001,
    CLUSTER_CHANGE_NODE_DELETED             = 0x00000002,
    CLUSTER_CHANGE_NODE_ADDED               = 0x00000004,
    CLUSTER_CHANGE_NODE_PROPERTY            = 0x00000008,

    CLUSTER_CHANGE_REGISTRY_NAME            = 0x00000010,
    CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      = 0x00000020,
    CLUSTER_CHANGE_REGISTRY_VALUE           = 0x00000040,
    CLUSTER_CHANGE_REGISTRY_SUBTREE         = 0x00000080,

    CLUSTER_CHANGE_RESOURCE_STATE           = 0x00000100,
    CLUSTER_CHANGE_RESOURCE_DELETED         = 0x00000200,
    CLUSTER_CHANGE_RESOURCE_ADDED           = 0x00000400,
    CLUSTER_CHANGE_RESOURCE_PROPERTY        = 0x00000800,

    CLUSTER_CHANGE_GROUP_STATE              = 0x00001000,
    CLUSTER_CHANGE_GROUP_DELETED            = 0x00002000,
    CLUSTER_CHANGE_GROUP_ADDED              = 0x00004000,
    CLUSTER_CHANGE_GROUP_PROPERTY           = 0x00008000,

    CLUSTER_CHANGE_RESOURCE_TYPE_DELETED    = 0x00010000,
    CLUSTER_CHANGE_RESOURCE_TYPE_ADDED      = 0x00020000,

    CLUSTER_CHANGE_NETWORK_STATE            = 0x00100000,
    CLUSTER_CHANGE_NETWORK_DELETED          = 0x00200000,
    CLUSTER_CHANGE_NETWORK_ADDED            = 0x00400000,
    CLUSTER_CHANGE_NETWORK_PROPERTY         = 0x00800000,

    CLUSTER_CHANGE_NETINTERFACE_STATE       = 0x01000000,
    CLUSTER_CHANGE_NETINTERFACE_DELETED     = 0x02000000,
    CLUSTER_CHANGE_NETINTERFACE_ADDED       = 0x04000000,
    CLUSTER_CHANGE_NETINTERFACE_PROPERTY    = 0x08000000,

    CLUSTER_CHANGE_QUORUM_STATE             = 0x10000000,
    CLUSTER_CHANGE_CLUSTER_STATE            = 0x20000000,
    CLUSTER_CHANGE_CLUSTER_PROPERTY         = 0x40000000,

    CLUSTER_CHANGE_HANDLE_CLOSE             = 0x80000000,

    CLUSTER_CHANGE_ALL                      = (CLUSTER_CHANGE_NODE_STATE                |
                                               CLUSTER_CHANGE_NODE_DELETED              |
                                               CLUSTER_CHANGE_NODE_ADDED                |
                                               CLUSTER_CHANGE_NODE_PROPERTY             |
                                               CLUSTER_CHANGE_REGISTRY_NAME             |
                                               CLUSTER_CHANGE_REGISTRY_ATTRIBUTES       |
                                               CLUSTER_CHANGE_REGISTRY_VALUE            |
                                               CLUSTER_CHANGE_REGISTRY_SUBTREE          |
                                               CLUSTER_CHANGE_RESOURCE_STATE            |
                                               CLUSTER_CHANGE_RESOURCE_DELETED          |
                                               CLUSTER_CHANGE_RESOURCE_ADDED            |
                                               CLUSTER_CHANGE_RESOURCE_PROPERTY         |
                                               CLUSTER_CHANGE_GROUP_STATE               |
                                               CLUSTER_CHANGE_GROUP_DELETED             |
                                               CLUSTER_CHANGE_GROUP_ADDED               |
                                               CLUSTER_CHANGE_GROUP_PROPERTY            |
                                               CLUSTER_CHANGE_RESOURCE_TYPE_DELETED     |
                                               CLUSTER_CHANGE_RESOURCE_TYPE_ADDED       |
                                               CLUSTER_CHANGE_NETWORK_STATE             |
                                               CLUSTER_CHANGE_NETWORK_DELETED           |
                                               CLUSTER_CHANGE_NETWORK_ADDED             |
                                               CLUSTER_CHANGE_NETWORK_PROPERTY          |
                                               CLUSTER_CHANGE_NETINTERFACE_STATE        |
                                               CLUSTER_CHANGE_NETINTERFACE_DELETED      |
                                               CLUSTER_CHANGE_NETINTERFACE_ADDED        |
                                               CLUSTER_CHANGE_NETINTERFACE_PROPERTY     |
                                               CLUSTER_CHANGE_QUORUM_STATE              |
                                               CLUSTER_CHANGE_CLUSTER_STATE             |
                                               CLUSTER_CHANGE_CLUSTER_PROPERTY          |
                                               CLUSTER_CHANGE_HANDLE_CLOSE)

} CLUSTER_CHANGE;

#endif // _CLUSTER_API_TYPES_

#ifndef MIDL_PASS
HCHANGE
WINAPI
CreateClusterNotifyPort(
    IN OPTIONAL HCHANGE hChange,
    IN OPTIONAL HCLUSTER hCluster,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey
    );

DWORD
WINAPI
RegisterClusterNotify(
    IN HCHANGE hChange,
    IN DWORD dwFilterType,
    IN HANDLE hObject,
    IN DWORD dwNotifyKey
    );

DWORD
WINAPI
GetClusterNotify(
    IN HCHANGE hChange,
    OUT LPDWORD lpdwNotifyKey,
    OUT LPDWORD lpdwFilterType,
    OUT OPTIONAL LPWSTR lpszName,
    IN OUT LPDWORD lpcbName,
    IN DWORD dwMilliseconds
    );

BOOL
WINAPI
CloseClusterNotifyPort(
    IN HCHANGE hChange
    );
#endif // MIDL_PASS

//
// Enumeration routines
//

#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable types
//
typedef enum CLUSTER_ENUM {
    CLUSTER_ENUM_NODE               = 0x00000001,
    CLUSTER_ENUM_RESTYPE            = 0x00000002,
    CLUSTER_ENUM_RESOURCE           = 0x00000004,
    CLUSTER_ENUM_GROUP              = 0x00000008,
    CLUSTER_ENUM_NETWORK            = 0x00000010,
    CLUSTER_ENUM_NETINTERFACE       = 0x00000020,
    CLUSTER_ENUM_INTERNAL_NETWORK   = 0x80000000,

    CLUSTER_ENUM_ALL                = (CLUSTER_ENUM_NODE      |
                                       CLUSTER_ENUM_RESTYPE   |
                                       CLUSTER_ENUM_RESOURCE  |
                                       CLUSTER_ENUM_GROUP     |
                                       CLUSTER_ENUM_NETWORK   |
                                       CLUSTER_ENUM_NETINTERFACE)

} CLUSTER_ENUM;

#endif // _CLUSTER_API_TYPES_

#ifndef MIDL_PASS
HCLUSENUM
WINAPI
ClusterOpenEnum(
    IN HCLUSTER hCluster,
    IN DWORD dwType
    );

DWORD
WINAPI
ClusterEnum(
    IN HCLUSENUM hEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcbName
    );

DWORD
WINAPI
ClusterCloseEnum(
    IN HCLUSENUM hEnum
    );
#endif // MIDL_PASS


#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable node types
//
typedef enum CLUSTER_NODE_ENUM {
    CLUSTER_NODE_ENUM_NETINTERFACES = 0x00000001,

    CLUSTER_NODE_ENUM_ALL           = (CLUSTER_NODE_ENUM_NETINTERFACES)

} CLUSTER_NODE_ENUM;

//
// Node-related structures and types.
//
typedef enum CLUSTER_NODE_STATE {
    ClusterNodeStateUnknown = -1,
    ClusterNodeUp,
    ClusterNodeDown,
    ClusterNodePaused,
    ClusterNodeJoining
} CLUSTER_NODE_STATE;

#endif // _CLUSTER_API_TYPES_

//
// Interfaces for managing the nodes of a cluster.
//

#ifndef MIDL_PASS
HNODE
WINAPI
OpenClusterNode(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNodeName
    );

BOOL
WINAPI
CloseClusterNode(
    IN HNODE hNode
    );

CLUSTER_NODE_STATE
WINAPI
GetClusterNodeState(
    IN HNODE hNode
    );

DWORD
WINAPI
GetClusterNodeId(
    IN HNODE hNode,
    OUT LPWSTR lpszNodeId,
    IN OUT LPDWORD lpcchName
    );

#define GetCurrentClusterNodeId(_lpszNodeId_, _lpcchName_) \
    GetClusterNodeId(NULL, (_lpszNodeId_), (_lpcchName_))

DWORD
WINAPI
PauseClusterNode(
    IN HNODE hNode
    );

DWORD
WINAPI
ResumeClusterNode(
    IN HNODE hNode
    );

DWORD
WINAPI
EvictClusterNode(
    IN HNODE hNode
    );

HNODEENUM
WINAPI
ClusterNodeOpenEnum(
    IN HNODE hNode,
    IN DWORD dwType
    );

DWORD
WINAPI
ClusterNodeCloseEnum(
    IN HNODEENUM hNodeEnum
    );

DWORD
WINAPI
ClusterNodeEnum(
    IN HNODEENUM hNodeEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcbName
    );
#endif // MIDL_PASS


//
// Interfaces for managing the resource types in a cluster
//

#ifndef MIDL_PASS
HKEY
WINAPI
GetClusterResourceTypeKey(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszTypeName,
    IN REGSAM samDesired
    );
#endif // MIDL_PASS

#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable group types
//
typedef enum CLUSTER_GROUP_ENUM {
    CLUSTER_GROUP_ENUM_CONTAINS     = 0x00000001,
    CLUSTER_GROUP_ENUM_NODES        = 0x00000002,

    CLUSTER_GROUP_ENUM_ALL          = (CLUSTER_GROUP_ENUM_CONTAINS |
                                       CLUSTER_GROUP_ENUM_NODES)
} CLUSTER_GROUP_ENUM;

//
// Interfaces for managing the failover groups in a cluster.
//
typedef enum CLUSTER_GROUP_STATE {
    ClusterGroupStateUnknown = -1,
    ClusterGroupOnline,
    ClusterGroupOffline,
    ClusterGroupFailed,
    ClusterGroupPartialOnline
} CLUSTER_GROUP_STATE;

typedef enum CLUSTER_GROUP_AUTOFAILBACK_TYPE
{
    ClusterGroupPreventFailback = 0,
    ClusterGroupAllowFailback,
    ClusterGroupFailbackTypeCount
} CLUSTER_GROUP_AUTOFAILBACK_TYPE, CGAFT;

#endif // _CLUSTER_API_TYPES_

#ifndef MIDL_PASS
HGROUP
WINAPI
CreateClusterGroup(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszGroupName
    );

HGROUP
WINAPI
OpenClusterGroup(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszGroupName
    );

BOOL
WINAPI
CloseClusterGroup(
    IN HGROUP hGroup
    );

CLUSTER_GROUP_STATE
WINAPI
GetClusterGroupState(
    IN HGROUP hGroup,
    OUT OPTIONAL LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcbNodeName
    );

DWORD
WINAPI
SetClusterGroupName(
    IN HGROUP hGroup,
    IN LPCWSTR lpszGroupName
    );

DWORD
WINAPI
SetClusterGroupNodeList(
    IN HGROUP hGroup,
    IN DWORD NodeCount,
    IN HNODE NodeList[]
    );

DWORD
WINAPI
OnlineClusterGroup(
    IN HGROUP hGroup,
    IN OPTIONAL HNODE hDestinationNode
    );

DWORD
WINAPI
MoveClusterGroup(
    IN HGROUP hGroup,
    IN OPTIONAL HNODE hDestinationNode
    );

DWORD
WINAPI
OfflineClusterGroup(
    IN HGROUP hGroup
    );

DWORD
WINAPI
DeleteClusterGroup(
    IN HGROUP hGroup
    );

HGROUPENUM
WINAPI
ClusterGroupOpenEnum(
    IN HGROUP hGroup,
    IN DWORD dwType
    );

DWORD
WINAPI
ClusterGroupEnum(
    IN HGROUPENUM hGroupEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszResourceName,
    IN OUT LPDWORD lpcbName
    );

DWORD
WINAPI
ClusterGroupCloseEnum(
    IN HGROUPENUM hGroupEnum
    );
#endif // MIDL_PASS


//
// Definitions used in resource management routines.
//

#ifndef _CLUSTER_API_TYPES_
//
// Resource-related structures and types
//
typedef enum CLUSTER_RESOURCE_STATE {
    ClusterResourceStateUnknown = -1,
    ClusterResourceInherited,
    ClusterResourceInitializing,
    ClusterResourceOnline,
    ClusterResourceOffline,
    ClusterResourceFailed,
    ClusterResourcePending = 128,
    ClusterResourceOnlinePending,
    ClusterResourceOfflinePending
} CLUSTER_RESOURCE_STATE;

typedef enum CLUSTER_RESOURCE_RESTART_ACTION {
    ClusterResourceDontRestart = 0,
    ClusterResourceRestartNoNotify,
    ClusterResourceRestartNotify,
    ClusterResourceRestartActionCount
} CLUSTER_RESOURCE_RESTART_ACTION, CRRA;

//
// Flags for resource creation
//
typedef enum CLUSTER_RESOURCE_CREATE_FLAGS {
    CLUSTER_RESOURCE_SEPARATE_MONITOR   = 1,

    CLUSTER_RESOURCE_VALID_FLAGS        = CLUSTER_RESOURCE_SEPARATE_MONITOR

} CLUSTER_RESOURCE_CREATE_FLAGS;

#endif // _CLUSTER_API_TYPES_

//
// Interfaces for managing the resources in a cluster
//

#ifndef MIDL_PASS
HRESOURCE
WINAPI
CreateClusterResource(
    IN HGROUP hGroup,
    IN LPCWSTR lpszResourceName,
    IN LPCWSTR lpszResourceType,
    IN DWORD dwFlags
    );

HRESOURCE
WINAPI
OpenClusterResource(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceName
    );

BOOL
WINAPI
CloseClusterResource(
    IN HRESOURCE hResource
    );

DWORD
WINAPI
DeleteClusterResource(
    IN HRESOURCE hResource
    );

CLUSTER_RESOURCE_STATE
WINAPI
GetClusterResourceState(
    IN HRESOURCE hResource,
    OUT OPTIONAL LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcbNodeName,
    OUT OPTIONAL LPWSTR lpszGroupName,
    IN OUT LPDWORD lpcbGroupName
    );

DWORD
WINAPI
SetClusterResourceName(
    IN HRESOURCE hResource,
    IN LPCWSTR lpszResourceName
    );

DWORD
WINAPI
FailClusterResource(
    IN HRESOURCE hResource
    );

DWORD
WINAPI
OnlineClusterResource(
    IN HRESOURCE hResource
    );

DWORD
WINAPI
OfflineClusterResource(
    IN HRESOURCE hResource
    );

DWORD
WINAPI
ChangeClusterResourceGroup(
    IN HRESOURCE hResource,
    IN HGROUP hGroup
    );

DWORD
WINAPI
AddClusterResourceNode(
    IN HRESOURCE hResource,
    IN HNODE hNode
    );

DWORD
WINAPI
RemoveClusterResourceNode(
    IN HRESOURCE hResource,
    IN HNODE hNode
    );

DWORD
WINAPI
AddClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    );

DWORD
WINAPI
RemoveClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    );

BOOL
WINAPI
CanResourceBeDependent(
    IN HRESOURCE hResource,
    IN HRESOURCE hResourceDependent
    );

DWORD
WINAPI
ClusterResourceControl(
    IN HRESOURCE hResource,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    );

DWORD
WINAPI
ClusterResourceTypeControl(
    IN HCLUSTER hCluster,
    IN LPCWSTR ResourceTypeName,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    );

DWORD
WINAPI
ClusterGroupControl(
    IN HGROUP hGroup,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    );

DWORD
WINAPI
ClusterNodeControl(
    IN HNODE hNode,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    );

BOOL
WINAPI
GetClusterResourceNetworkName(
    IN HRESOURCE hResource,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );


#endif // MIDL_PASS


//
// Cluster control properties
//

#ifndef _CLUSTER_API_TYPES_
//
// Cluster Control Property Data - Types (a WORD)
//
typedef enum CLUSTER_PROPERTY_TYPE {
    CLUSPROP_TYPE_ENDMARK = 0,
    CLUSPROP_TYPE_LIST_VALUE,
    CLUSPROP_TYPE_RESCLASS,
    CLUSPROP_TYPE_RESERVED1,
    CLUSPROP_TYPE_NAME,
    CLUSPROP_TYPE_SIGNATURE,
    CLUSPROP_TYPE_SCSI_ADDRESS,
    CLUSPROP_TYPE_DISK_NUMBER,
    CLUSPROP_TYPE_PARTITION_INFO,
    CLUSPROP_TYPE_FTSET_INFO,
    CLUSPROP_TYPE_USER=32768
} CLUSTER_PROPERTY_TYPE;

//
// Cluster Control Property Data - Formats (a WORD)
//
typedef enum CLUSTER_PROPERTY_FORMAT {
    CLUSPROP_FORMAT_UNKNOWN = 0,
    CLUSPROP_FORMAT_BINARY,
    CLUSPROP_FORMAT_DWORD,
    CLUSPROP_FORMAT_SZ,
    CLUSPROP_FORMAT_EXPAND_SZ,
    CLUSPROP_FORMAT_MULTI_SZ,
    CLUSPROP_FORMAT_ULARGE_INTEGER,
    CLUSPROP_FORMAT_USER=32768
} CLUSTER_PROPERTY_FORMAT;

#endif // _CLUSTER_API_TYPES_

//
// Cluster Control Property Data - Syntax
//
#define CLUSPROP_SYNTAX_VALUE( type, format ) ((DWORD) ((type << 16) | format))

#ifndef _CLUSTER_API_TYPES_

typedef enum CLUSTER_PROPERTY_SYNTAX {

    CLUSPROP_SYNTAX_ENDMARK         = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_ENDMARK, CLUSPROP_FORMAT_UNKNOWN ),
    CLUSPROP_SYNTAX_NAME            = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_NAME, CLUSPROP_FORMAT_SZ ),
    CLUSPROP_SYNTAX_RESCLASS        = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_RESCLASS, CLUSPROP_FORMAT_DWORD ),

    CLUSPROP_SYNTAX_LIST_VALUE_SZ           = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_SZ ),
    CLUSPROP_SYNTAX_LIST_VALUE_EXPAND_SZ    = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_EXPAND_SZ ),
    CLUSPROP_SYNTAX_LIST_VALUE_DWORD        = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_DWORD ),
    CLUSPROP_SYNTAX_LIST_VALUE_BINARY       = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_BINARY ),
    CLUSPROP_SYNTAX_LIST_VALUE_MULTI_SZ     = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_MULTI_SZ ),

    // Storage syntax values

    CLUSPROP_SYNTAX_DISK_SIGNATURE  = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_SIGNATURE, CLUSPROP_FORMAT_DWORD ),
    CLUSPROP_SYNTAX_SCSI_ADDRESS    = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_SCSI_ADDRESS, CLUSPROP_FORMAT_DWORD ),
    CLUSPROP_SYNTAX_DISK_NUMBER     = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_DISK_NUMBER, CLUSPROP_FORMAT_DWORD ),
    CLUSPROP_SYNTAX_PARTITION_INFO  = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_PARTITION_INFO, CLUSPROP_FORMAT_BINARY ),
    CLUSPROP_SYNTAX_FTSET_INFO      = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_FTSET_INFO, CLUSPROP_FORMAT_BINARY )

} CLUSTER_PROPERTY_SYNTAX;

#endif // _CLUSTER_API_TYPES_

//
// Define Cluster Control Code access methods
//
#define CLUS_ACCESS_ANY        0
#define CLUS_ACCESS_READ    0x01
#define CLUS_ACCESS_WRITE   0x02

//
// Define Cluster Control Code modification actions
//
#define CLUS_NO_MODIFY      0
#define CLUS_MODIFY         0x01

//
// Define Cluster Control Code Global actions
//
#define CLUS_NOT_GLOBAL     0
#define CLUS_GLOBAL         0x01

#ifndef _CLUSTER_API_TYPES_
//
// Define Cluster Control Code target objects
//
typedef enum CLUSTER_CONTROL_OBJECT {
    CLUS_OBJECT_INVALID=0,
    CLUS_OBJECT_RESOURCE,
    CLUS_OBJECT_RESOURCE_TYPE,
    CLUS_OBJECT_GROUP,
    CLUS_OBJECT_NODE,
    CLUS_OBJECT_NETWORK,
    CLUS_OBJECT_NETINTERFACE,
    CLUS_OBJECT_USER=128
} CLUSTER_CONTROL_OBJECT;

#endif // _CLUSTER_API_TYPES_

//
// Macro to generate full cluster control codes
//
//  31      24 23 22 21 20 19       16 15                    2 1    0
// +----------+--+--+--+--+-----------+-----------------------+------+
// |  OBJECT  |G |M |U |I       CLUSTER CONTROL CODES         |ACCESS|
// +----------+--+--+--+--+-----------+-----------------------+------+
//
// OBJECT - Object identifier (8 bits)
// G - Global bit (operation must be performed on all nodes of cluster)
// M - Modify bit (code causes a modification, may cause event notification)
// U - User code bit (splits the control codes into 2 spaces each 2^^19 in size)
// I - Internal code bit (only for non-user control codes)
// CLUSTER CONTROL CODES - 2^^18 (256 thousand possible control codes)
// ACCESS - Access mode (2 bits)
//

//
// Define control code shifts
//
#define CLUSCTL_ACCESS_SHIFT         0
#define CLUSCTL_FUNCTION_SHIFT       2
#define CLCTL_INTERNAL_SHIFT        20
#define CLCTL_USER_SHIFT            21
#define CLCTL_MODIFY_SHIFT          22
#define CLCTL_GLOBAL_SHIFT          23
#define CLUSCTL_OBJECT_SHIFT        24

//
// Define control code masks
//
#define CLCTL_INTERNAL_MASK             (1<<CLCTL_INTERNAL_SHIFT)
#define CLCTL_USER_MASK                 (1<<CLCTL_USER_SHIFT)
#define CLCTL_MODIFY_MASK               (1<<CLCTL_MODIFY_SHIFT)
#define CLCTL_GLOBAL_MASK               (1<<CLCTL_GLOBAL_SHIFT)
#define CLUSCTL_CONTROL_CODE_MASK       0x3FFFFF // Includes access mask
#define CLUSCTL_OBJECT_MASK             0xFF
#define CLUSCTL_ACCESS_MODE_MASK        0x03

//
// Cluster Control function codes (a DWORD)
//
#define CLCTL_CLUSTER_BASE  0           // Start of cluster defined functions
#define CLCTL_USER_BASE     (1<<CLCTL_USER_SHIFT) // Start of user functions

#define CLCTL_EXTERNAL_CODE( Function, Access, Modify ) ( \
    ((Access) << CLUSCTL_ACCESS_SHIFT) | \
    ((CLCTL_CLUSTER_BASE + Function) << CLUSCTL_FUNCTION_SHIFT) | \
    ((Modify) << CLCTL_MODIFY_SHIFT) )

#define CLCTL_INTERNAL_CODE( Function, Access, Modify ) ( \
    ((Access) << CLUSCTL_ACCESS_SHIFT) | \
    CLCTL_INTERNAL_MASK | \
    ((CLCTL_CLUSTER_BASE + Function) << CLUSCTL_FUNCTION_SHIFT) | \
    ((Modify) << CLCTL_MODIFY_SHIFT) )

#ifndef _CLUSTER_API_TYPES_
typedef enum CLCTL_CODES {
    //
    // External control codes
    //
    CLCTL_UNKNOWN                           = CLCTL_EXTERNAL_CODE( 0, CLUS_ACCESS_ANY, CLUS_NO_MODIFY ),
    CLCTL_GET_CHARACTERISTICS               = CLCTL_EXTERNAL_CODE( 1, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_FLAGS                         = CLCTL_EXTERNAL_CODE( 2, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_CLASS_INFO                    = CLCTL_EXTERNAL_CODE( 3, CLUS_ACCESS_READ, CLUS_NO_MODIFY ), 
    CLCTL_GET_REQUIRED_DEPENDENCIES         = CLCTL_EXTERNAL_CODE( 4, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_GET_NAME                          = CLCTL_EXTERNAL_CODE( 10, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_RESOURCE_TYPE                 = CLCTL_EXTERNAL_CODE( 11, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_NODE                          = CLCTL_EXTERNAL_CODE( 12, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_NETWORK                       = CLCTL_EXTERNAL_CODE( 13, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_ENUM_COMMON_PROPERTIES            = CLCTL_EXTERNAL_CODE( 20, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_RO_COMMON_PROPERTIES          = CLCTL_EXTERNAL_CODE( 21, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_COMMON_PROPERTIES             = CLCTL_EXTERNAL_CODE( 22, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_SET_COMMON_PROPERTIES             = CLCTL_EXTERNAL_CODE( 23, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_VALIDATE_COMMON_PROPERTIES        = CLCTL_EXTERNAL_CODE( 24, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_ENUM_PRIVATE_PROPERTIES           = CLCTL_EXTERNAL_CODE( 30, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_RO_PRIVATE_PROPERTIES         = CLCTL_EXTERNAL_CODE( 31, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_PRIVATE_PROPERTIES            = CLCTL_EXTERNAL_CODE( 32, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_SET_PRIVATE_PROPERTIES            = CLCTL_EXTERNAL_CODE( 33, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_VALIDATE_PRIVATE_PROPERTIES       = CLCTL_EXTERNAL_CODE( 34, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_ADD_REGISTRY_CHECKPOINT           = CLCTL_EXTERNAL_CODE( 40, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_DELETE_REGISTRY_CHECKPOINT        = CLCTL_EXTERNAL_CODE( 41, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_GET_REGISTRY_CHECKPOINTS          = CLCTL_EXTERNAL_CODE( 42, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_GET_LOADBAL_PROCESS_LIST          = CLCTL_EXTERNAL_CODE( 50, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_STORAGE_GET_DISK_INFO             = CLCTL_EXTERNAL_CODE( 100, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_GET_AVAILABLE_DISKS       = CLCTL_EXTERNAL_CODE( 101, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_IS_PATH_VALID             = CLCTL_EXTERNAL_CODE( 102, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_GET_ALL_AVAILABLE_DISKS   = (CLCTL_EXTERNAL_CODE( 103, CLUS_ACCESS_READ, CLUS_NO_MODIFY ) | CLCTL_GLOBAL_MASK),

    //
    // Internal control codes
    //
    CLCTL_DELETE                            = CLCTL_INTERNAL_CODE( 1, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_INSTALL_NODE                      = CLCTL_INTERNAL_CODE( 2, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_EVICT_NODE                        = CLCTL_INTERNAL_CODE( 3, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_ADD_DEPENDENCY                    = CLCTL_INTERNAL_CODE( 4, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_REMOVE_DEPENDENCY                 = CLCTL_INTERNAL_CODE( 5, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_ADD_OWNER                         = CLCTL_INTERNAL_CODE( 6, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_REMOVE_OWNER                      = CLCTL_INTERNAL_CODE( 7, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    //************ Hole here at 8
    CLCTL_SET_NAME                          = CLCTL_INTERNAL_CODE( 9, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_CLUSTER_NAME_CHANGED              = CLCTL_INTERNAL_CODE( 10, CLUS_ACCESS_WRITE, CLUS_MODIFY )

} CLCTL_CODES;

#endif // _CLUSTER_API_TYPES_

//
// Define macros to generate object specific control codes
//
#define CLUSCTL_RESOURCE_CODE( Function ) ( \
    ((CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_RESOURCE_TYPE_CODE( Function ) ( \
    ((CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_GROUP_CODE( Function ) ( \
    ((CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_NODE_CODE( Function ) ( \
    ((CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_NETWORK_CODE( Function ) ( \
    ((CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_NETINTERFACE_CODE( Function ) ( \
    ((CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_USER_CODE( Function, Object ) ( \
    ((Object) << CLUSCTL_OBJECT_SHIFT) | (CLCTL_USER_BASE + Function) )

//
// Define macros to get the function or access mode out of a control code
//
#define CLUSCTL_GET_CONTROL_FUNCTION( ControlCode ) \
    ((ControlCode >> CLUSCTL_ACCESS_SHIFT) & CLUSCTL_CONTROL_CODE_MASK)

#define CLUSCTL_GET_ACCESS_MODE( ControlCode ) \
    ((ControlCode >> CLUSCTL_ACCESS_SHIFT) & CLUSCTL_ACCESS_MODE_MASK)

#define CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) \
    ((ControlCode >> CLUSCTL_OBJECT_SHIFT) & CLUSCTL_OBJECT_MASK)

#ifndef _CLUSTER_API_TYPES_
//
// Cluster Control Codes for Resources
//
typedef enum CLUSCTL_RESOURCE_CODES {

    // External
    CLUSCTL_RESOURCE_UNKNOWN =
        CLUSCTL_RESOURCE_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_RESOURCE_GET_CHARACTERISTICS =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_RESOURCE_GET_FLAGS =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_RESOURCE_GET_CLASS_INFO =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_CLASS_INFO ),

    CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_REQUIRED_DEPENDENCIES ),

    CLUSCTL_RESOURCE_GET_NAME =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_NAME ),

    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_RESOURCE_TYPE ),

    CLUSCTL_RESOURCE_ENUM_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT =
        CLUSCTL_RESOURCE_CODE( CLCTL_ADD_REGISTRY_CHECKPOINT ),

    CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT =
        CLUSCTL_RESOURCE_CODE( CLCTL_DELETE_REGISTRY_CHECKPOINT ),

    CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_REGISTRY_CHECKPOINTS ),

    CLUSCTL_RESOURCE_GET_LOADBAL_PROCESS_LIST =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_LOADBAL_PROCESS_LIST ),

    CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO =
        CLUSCTL_RESOURCE_CODE( CLCTL_STORAGE_GET_DISK_INFO ),

    CLUSCTL_RESOURCE_STORAGE_IS_PATH_VALID =
        CLUSCTL_RESOURCE_CODE( CLCTL_STORAGE_IS_PATH_VALID ),


    // Internal
    CLUSCTL_RESOURCE_DELETE =
        CLUSCTL_RESOURCE_CODE( CLCTL_DELETE ),

    CLUSCTL_RESOURCE_INSTALL_NODE =
        CLUSCTL_RESOURCE_CODE( CLCTL_INSTALL_NODE ),

    CLUSCTL_RESOURCE_EVICT_NODE =
        CLUSCTL_RESOURCE_CODE( CLCTL_EVICT_NODE ),

    CLUSCTL_RESOURCE_ADD_DEPENDENCY =
        CLUSCTL_RESOURCE_CODE( CLCTL_ADD_DEPENDENCY ),

    CLUSCTL_RESOURCE_REMOVE_DEPENDENCY =
        CLUSCTL_RESOURCE_CODE( CLCTL_REMOVE_DEPENDENCY ),

    CLUSCTL_RESOURCE_ADD_OWNER =
        CLUSCTL_RESOURCE_CODE( CLCTL_ADD_OWNER ),

    CLUSCTL_RESOURCE_REMOVE_OWNER =
        CLUSCTL_RESOURCE_CODE( CLCTL_REMOVE_OWNER ),

    CLUSCTL_RESOURCE_SET_NAME =
        CLUSCTL_RESOURCE_CODE( CLCTL_SET_NAME ),

    CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED =
        CLUSCTL_RESOURCE_CODE( CLCTL_CLUSTER_NAME_CHANGED )

} CLUSCTL_RESOURCE_CODES;

//
// Cluster Control Codes for Resource Types
//
typedef enum CLUSCTL_RESOURCE_TYPE_CODES {

    // External
    CLUSCTL_RESOURCE_TYPE_UNKNOWN =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS  =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_RESOURCE_TYPE_GET_FLAGS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_CLASS_INFO ),

    CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_REQUIRED_DEPENDENCIES ),

    CLUSCTL_RESOURCE_TYPE_ENUM_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_REGISTRY_CHECKPOINTS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_REGISTRY_CHECKPOINTS ),

    CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_STORAGE_GET_AVAILABLE_DISKS ),


    // Internal
    CLUSCTL_RESOURCE_TYPE_INSTALL_NODE =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_INSTALL_NODE ),

    CLUSCTL_RESOURCE_TYPE_EVICT_NODE =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_EVICT_NODE )

} CLUSCTL_RESOURCE_TYPE_CODES;

//
// Cluster Control Codes for Groups
//
typedef enum CLUSCTL_GROUP_CODES {

    // External
    CLUSCTL_GROUP_UNKNOWN =
        CLUSCTL_GROUP_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_GROUP_GET_CHARACTERISTICS =
        CLUSCTL_GROUP_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_GROUP_GET_FLAGS =
        CLUSCTL_GROUP_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_GROUP_GET_NAME =
        CLUSCTL_GROUP_CODE( CLCTL_GET_NAME ),

    CLUSCTL_GROUP_ENUM_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_GET_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_SET_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES )

} CLUSCTL_GROUP_CODES;

//
// Cluster Control Codes for Nodes
//
typedef enum CLUSCTL_NODE_CODES {

    // External
    CLUSCTL_NODE_UNKNOWN =
        CLUSCTL_NODE_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_NODE_GET_CHARACTERISTICS =
        CLUSCTL_NODE_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_NODE_GET_FLAGS =
        CLUSCTL_NODE_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_NODE_GET_NAME =
        CLUSCTL_NODE_CODE( CLCTL_GET_NAME ),

    CLUSCTL_NODE_ENUM_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_NODE_GET_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_NODE_SET_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_NODE_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_NODE_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_NODE_GET_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_NODE_SET_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES )

} CLUSCTL_NODE_CODES;

//
// Cluster Control Codes for Networks
//
typedef enum CLUSCTL_NETWORK_CODES {

    // External
    CLUSCTL_NETWORK_UNKNOWN =
        CLUSCTL_NETWORK_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_NETWORK_GET_CHARACTERISTICS =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_NETWORK_GET_FLAGS =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_NETWORK_GET_NAME =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_NAME ),

    CLUSCTL_NETWORK_ENUM_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_GET_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_SET_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES )

} CLUSCTL_NETWORK_CODES;

//
// Cluster Control Codes for Network Interfaces
//
typedef enum CLUSCTL_NETINTERFACE_CODES {

    // External
    CLUSCTL_NETINTERFACE_UNKNOWN =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_NETINTERFACE_GET_CHARACTERISTICS =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_NETINTERFACE_GET_FLAGS =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_NETINTERFACE_GET_NAME =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_NAME ),

    CLUSCTL_NETINTERFACE_GET_NODE =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_NODE ),

    CLUSCTL_NETINTERFACE_GET_NETWORK =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_NETWORK ),

    CLUSCTL_NETINTERFACE_ENUM_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES )

} CLUSCTL_NETINTERFACE_CODES;

//
// Cluster Resource Class types
//
typedef enum CLUSTER_RESOURCE_CLASS {
    CLUS_RESCLASS_UNKNOWN = 0,
    CLUS_RESCLASS_STORAGE,
    CLUS_RESCLASS_USER = 32768
} CLUSTER_RESOURCE_CLASS;

//
// Define Resource SubClass bits
//
typedef enum CLUS_RESSUBCLASS {
    CLUS_RESSUBCLASS_SHARED = 0x80000000
} CLUS_RESSUBCLASS;

//
// Cluster Characteristics
//
typedef enum CLUS_CHARACTERISTICS {
    CLUS_CHAR_UNKNOWN                   = 0x00000000,
    CLUS_CHAR_QUORUM                    = 0x00000001,
    CLUS_CHAR_DELETE_REQUIRES_ALL_NODES = 0x00000002
} CLUS_CHARACTERISTICS;

//
// Cluster Flags
//
typedef enum CLUS_FLAGS {
    CLUS_FLAG_CORE          = 0x00000001
}  CLUS_FLAGS;


//
// Cluster Resource Property Helper Structures
//

#ifndef MIDL_PASS

// Property syntax.  Used for property names and values.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
typedef union CLUSPROP_SYNTAX {
    DWORD dw;
    struct {
        WORD wFormat;
        WORD wType;
    };
} CLUSPROP_SYNTAX, *PCLUSPROP_SYNTAX;
#pragma warning( default : 4201 )

// Property value.
typedef struct CLUSPROP_VALUE {
    CLUSPROP_SYNTAX Syntax;
    DWORD           cbLength;
} CLUSPROP_VALUE, *PCLUSPROP_VALUE;

// Binary property value.
#pragma warning( disable : 4200 ) // nonstandard extension used : zero-sized array in struct/union
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#ifdef __cplusplus
typedef struct CLUSPROP_BINARY : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_BINARY {
    CLUSPROP_VALUE;
#endif
    BYTE            rgb[];
} CLUSPROP_BINARY, *PCLUSPROP_BINARY;
#pragma warning( default : 4200 )
#pragma warning( default : 4201 )

// DWORD property value.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#ifdef __cplusplus
typedef struct CLUSPROP_DWORD : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_DWORD {
    CLUSPROP_VALUE;
#endif
    DWORD           dw;
} CLUSPROP_DWORD, *PCLUSPROP_DWORD;
#pragma warning( default : 4201 )

// String and multiple string property value.
#pragma warning( disable : 4200 ) // nonstandard extension used : zero-sized array in struct/union
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#ifdef __cplusplus
typedef struct CLUSPROP_SZ : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_SZ {
    CLUSPROP_VALUE;
#endif
    WCHAR           sz[];
} CLUSPROP_SZ, *PCLUSPROP_SZ;
#pragma warning( default : 4200 )
#pragma warning( default : 4201 )

// Multiple string property value.
typedef CLUSPROP_SZ CLUSPROP_MULTI_SZ, *PCLUSPROP_MULTI_SZ;

// Property name.
typedef CLUSPROP_SZ CLUSPROP_PROPERTY_NAME, *PCLUSPROP_PROPERTY_NAME;

// Large Integer property value.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#ifdef __cplusplus
typedef struct CLUSPROP_ULARGE_INTEGER
    : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_ULARGE_INTEGER {
    CLUSPROP_VALUE;
#endif
    ULARGE_INTEGER li;
} CLUSPROP_LARGE_INTEGER, *PCLUSPROP_ULARGE_INTEGER;
#pragma warning( default : 4201 )

// Resource class info returned by CLCTL_GET_CLASS_INFO control functions.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
typedef struct CLUS_RESOURCE_CLASS_INFO {
    union {
        struct {
            union {
                DWORD                   dw;
                CLUSTER_RESOURCE_CLASS  rc;
                };
            DWORD           SubClass;
        };
        ULARGE_INTEGER      li;
    };
} CLUS_RESOURCE_CLASS_INFO, *PCLUS_RESOURCE_CLASS_INFO;
#pragma warning( default : 4201 )

// Resource class property value.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#ifdef __cplusplus
typedef struct CLUSPROP_RESOURCE_CLASS
    : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_RESOURCE_CLASS {
    CLUSPROP_VALUE;
#endif
    CLUSTER_RESOURCE_CLASS rc;
} CLUSPROP_RESOURCE_CLASS, *PCLUSPROP_RESOURCE_CLASS;
#pragma warning( default : 4201 )

// Resource class info property value.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#ifdef __cplusplus
typedef struct CLUSPROP_RESOURCE_CLASS_INFO
    : public CLUSPROP_VALUE
    , public CLUS_RESOURCE_CLASS_INFO {
#else
typedef struct CLUSPROP_RESOURCE_CLASS_INFO {
    CLUSPROP_VALUE;
    CLUS_RESOURCE_CLASS_INFO;
#endif
} CLUSPROP_RESOURCE_CLASS_INFO, *PCLUSPROP_RESOURCE_CLASS_INFO;
#pragma warning( default : 4201 )

// One entry from list returned by CLCTL_GET_REQUIRED_DEPENDENCIES control functions.
typedef union CLUSPROP_REQUIRED_DEPENDENCY {
    CLUSPROP_VALUE          Value;
    CLUSPROP_RESOURCE_CLASS ResClass;
    CLUSPROP_SZ             ResTypeName;
} CLUSPROP_REQUIRED_DEPENDENCY, *PCLUSPROP_REQUIRED_DEPENDENCY;

typedef CLUSPROP_DWORD CLUSPROP_DISK_NUMBER, *PCLUSPROP_DISK_NUMBER;

#endif // MIDL_PASS
#endif // _CLUSTER_API_TYPES_

//#ifdef MIDL_PASS
//#ifndef MAX_PATH
//#define MAX_PATH 260
//#endif
//#endif // if MIDL_PASS

#ifndef _CLUSTER_API_TYPES_

// Disk partition information flags.
typedef enum CLUSPROP_PIFLAGS {
    CLUSPROP_PIFLAG_STICKY      = 0x00000001,
    CLUSPROP_PIFLAG_REMOVABLE   = 0x00000002,
    CLUSPROP_PIFLAG_USABLE      = 0x00000004
} CLUSPROP_PIFLAGS;

#ifndef MIDL_PASS

// Disk partition information.
typedef struct CLUS_PARTITION_INFO {
    DWORD           dwFlags;
    WCHAR           szDeviceName[MAX_PATH];
    WCHAR           szVolumeLabel[MAX_PATH];
    DWORD           dwSerialNumber;
    DWORD           rgdwMaximumComponentLength;
    DWORD           dwFileSystemFlags;
    WCHAR           szFileSystem[32];
} CLUS_PARTITION_INFO, *PCLUS_PARTITION_INFO;

// Disk partition information property value.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#ifdef __cplusplus
typedef struct CLUSPROP_PARTITION_INFO
    : public CLUSPROP_VALUE
    , public CLUS_PARTITION_INFO {
#else
typedef struct CLUSPROP_PARTITION_INFO {
    CLUSPROP_VALUE;
    CLUS_PARTITION_INFO;
#endif
} CLUSPROP_PARTITION_INFO, *PCLUSPROP_PARTITION_INFO;
#pragma warning( default : 4201 )

//
// FT set information.
//
typedef struct CLUS_FTSET_INFO {
    DWORD           dwRootSignature;
    DWORD           dwFtType;
} CLUS_FTSET_INFO, *PCLUS_FTSET_INFO;

// Disk partition information property value.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#ifdef __cplusplus
typedef struct CLUSPROP_FTSET_INFO
    : public CLUSPROP_VALUE
    , public CLUS_FTSET_INFO {
#else
typedef struct CLUSPROP_FTSET_INFO {
    CLUSPROP_VALUE;
    CLUS_FTSET_INFO;
#endif
} CLUSPROP_FTSET_INFO, *PCLUSPROP_FTSET_INFO;
#pragma warning( default : 4201 )

// Disk Signature property value.
typedef CLUSPROP_DWORD CLUSPROP_DISK_SIGNATURE, *PCLUSPROP_DISK_SIGNATURE;

// SCSI Address.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
typedef struct CLUS_SCSI_ADDRESS {
    union {
        struct {
            UCHAR PortNumber;
            UCHAR PathId;
            UCHAR TargetId;
            UCHAR Lun;
        };
        DWORD   dw;
    };
} CLUS_SCSI_ADDRESS, *PCLUS_SCSI_ADDRESS;
#pragma warning( default : 4201 ) // nonstandard extension used : nameless struct/union

// SCSI Address property value.
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#ifdef __cplusplus
typedef struct CLUSPROP_SCSI_ADDRESS
    : public CLUSPROP_VALUE
    , public CLUS_SCSI_ADDRESS {
#else
typedef struct CLUSPROP_SCSI_ADDRESS {
    CLUSPROP_VALUE;
    CLUS_SCSI_ADDRESS;
#endif
} CLUSPROP_SCSI_ADDRESS, *PCLUSPROP_SCSI_ADDRESS;
#pragma warning( default : 4201 ) // nonstandard extension used : nameless struct/union


// Beginning of a property list.
typedef struct CLUSPROP_LIST {
    DWORD                   nPropertyCount;
    CLUSPROP_PROPERTY_NAME  PropertyName;
} CLUSPROP_LIST, *PCLUSPROP_LIST;

// Helper for building or parsing a property list buffer.
typedef union CLUSPROP_BUFFER_HELPER {
    BYTE *                          pb;
    WORD *                          pw;
    DWORD *                         pdw;
    LPWSTR                          psz;
    PCLUSPROP_LIST                  pList;
    PCLUSPROP_SYNTAX                pSyntax;
    PCLUSPROP_PROPERTY_NAME         pName;
    PCLUSPROP_VALUE                 pValue;
    PCLUSPROP_BINARY                pBinaryValue;
    PCLUSPROP_DWORD                 pDwordValue;
    PCLUSPROP_ULARGE_INTEGER        pULargeIntegerValue;
    PCLUSPROP_SZ                    pStringValue;
    PCLUSPROP_MULTI_SZ              pMultiSzValue;
    PCLUSPROP_RESOURCE_CLASS        pResourceClassValue;
    PCLUSPROP_RESOURCE_CLASS_INFO   pResourceClassInfoValue;
    PCLUSPROP_DISK_SIGNATURE        pDiskSignatureValue;
    PCLUSPROP_SCSI_ADDRESS          pScsiAddressValue;
    PCLUSPROP_DISK_NUMBER           pDiskNumberValue;
    PCLUSPROP_PARTITION_INFO        pPartitionInfoValue;
    PCLUSPROP_REQUIRED_DEPENDENCY   pRequiredDependencyValue;
} CLUSPROP_BUFFER_HELPER, *PCLUSPROP_BUFFER_HELPER;

#endif // MIDL_PASS

#endif // _CLUSTER_API_TYPES_

// Macro for aligning CLUSPROP buffers on a DWORD boundary.
#define ALIGN_CLUSPROP( count ) ((count + 3) & ~3)

// Macros for declaring array format values
#define CLUSPROP_BINARY_DECLARE( name, cb ) \
    struct {                                \
        CLUSPROP_SYNTAX Syntax;             \
        DWORD           cbLength;           \
        BYTE            rgb[(cb + 3) & ~3]; \
    } name

#define CLUSPROP_SZ_DECLARE( name, cch )    \
    struct {                                \
        CLUSPROP_SYNTAX Syntax;             \
        DWORD           cbLength;           \
        WCHAR           sz[(cch + 1) & ~1]; \
    } name

#define CLUSPROP_PROPERTY_NAME_DECLARE( name, cch ) CLUSPROP_SZ_DECLARE( name, cch )



//
// Cluster resource property enumeration.
//

#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable types
//
typedef enum CLUSTER_RESOURCE_ENUM {
    CLUSTER_RESOURCE_ENUM_DEPENDS   = 0x00000001,
    CLUSTER_RESOURCE_ENUM_PROVIDES  = 0x00000002,
    CLUSTER_RESOURCE_ENUM_NODES     = 0x00000004,

    CLUSTER_RESOURCE_ENUM_ALL       = (CLUSTER_RESOURCE_ENUM_DEPENDS  |
                                         CLUSTER_RESOURCE_ENUM_PROVIDES |
                                         CLUSTER_RESOURCE_ENUM_NODES)
} CLUSTER_RESOURCE_ENUM;

#endif // _CLUSTER_API_TYPES_

#ifndef MIDL_PASS
HRESENUM
WINAPI
ClusterResourceOpenEnum(
    IN HRESOURCE hResource,
    IN DWORD dwType
    );

DWORD
WINAPI
ClusterResourceEnum(
    IN HRESENUM hResEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcbName
    );

DWORD
WINAPI
ClusterResourceCloseEnum(
    IN HRESENUM hResEnum
    );

DWORD
WINAPI
CreateClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszResourceTypeDll,
    IN DWORD dwLooksAlivePollInterval,
    IN DWORD dwIsAlivePollInterval
    );

DWORD
WINAPI
DeleteClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName
    );
#endif // MIDL_PASS



//
// Network-related structures and types.
//

#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable group types
//
typedef enum CLUSTER_NETWORK_ENUM {
    CLUSTER_NETWORK_ENUM_NETINTERFACES  = 0x00000001,

    CLUSTER_NETWORK_ENUM_ALL            = CLUSTER_NETWORK_ENUM_NETINTERFACES
} CLUSTER_NETWORK_ENUM;

typedef enum CLUSTER_NETWORK_STATE {
    ClusterNetworkStateUnknown = -1,
    ClusterNetworkUnavailable,
    ClusterNetworkDown,
    ClusterNetworkPartitioned,
    ClusterNetworkUp
} CLUSTER_NETWORK_STATE;

// Role the network plays in the cluster.  This is a bitmask.
typedef enum CLUSTER_NETWORK_ROLE {
    ClusterNetworkRoleNone              = 0,
    ClusterNetworkRoleInternalUse       = 0x00000001,
    ClusterNetworkRoleClientAccess      = 0x00000002,
    ClusterNetworkRoleInternalAndClient = 0x00000003
} CLUSTER_NETWORK_ROLE;

#endif // _CLUSTER_API_TYPES_

//
// Interfaces for managing the networks of a cluster.
//

#ifndef MIDL_PASS
HNETWORK
WINAPI
OpenClusterNetwork(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNetworkName
    );

BOOL
WINAPI
CloseClusterNetwork(
    IN HNETWORK hNetwork
    );

HNETWORKENUM
WINAPI
ClusterNetworkOpenEnum(
    IN HNETWORK hNetwork,
    IN DWORD dwType
    );

DWORD
WINAPI
ClusterNetworkEnum(
    IN HNETWORKENUM hNetworkEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcbName
    );

DWORD
WINAPI
ClusterNetworkCloseEnum(
    IN HNETWORKENUM hNetworkEnum
    );

CLUSTER_NETWORK_STATE
WINAPI
GetClusterNetworkState(
    IN HNETWORK hNetwork
    );

DWORD
WINAPI
SetClusterNetworkName(
    IN HNETWORK hNetwork,
    IN LPCWSTR lpszName
    );

DWORD
WINAPI
GetClusterNetworkId(
    IN HNETWORK hNetwork,
    OUT LPWSTR lpszNetworkId,
    IN OUT LPDWORD lpcchName
    );

DWORD
WINAPI
ClusterNetworkControl(
    IN HNETWORK hNetwork,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD dwOutBufferSize,
    OUT LPDWORD lpBytesReturned
    );
#endif // MIDL_PASS


#ifndef _CLUSTER_API_TYPES_
//
// Network interface-related structures and types.
//
typedef enum CLUSTER_NETINTERFACE_STATE {
    ClusterNetInterfaceStateUnknown = -1,
    ClusterNetInterfaceUnavailable,
    ClusterNetInterfaceFailed,
    ClusterNetInterfaceUnreachable,
    ClusterNetInterfaceUp
} CLUSTER_NETINTERFACE_STATE;

#endif // _CLUSTER_API_TYPES_

//
// Interfaces for managing the network interfaces of a cluster.
//

#ifndef MIDL_PASS
HNETINTERFACE
WINAPI
OpenClusterNetInterface(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszInterfaceName
    );

DWORD
WINAPI
GetClusterNetInterface(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNodeName,
    IN LPCWSTR lpszNetworkName,
    OUT LPWSTR lpszInterfaceName,
    IN OUT LPDWORD lpcbInterfaceName
    );

BOOL
WINAPI
CloseClusterNetInterface(
    IN HNETINTERFACE hNetInterface
    );

CLUSTER_NETINTERFACE_STATE
WINAPI
GetClusterNetInterfaceState(
    IN HNETINTERFACE hNetInterface
    );

DWORD
WINAPI
ClusterNetInterfaceControl(
    IN HNETINTERFACE hNetInterface,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD dwOutBufferSize,
    OUT LPDWORD lpBytesReturned
    );
#endif // MIDL_PASS


//
// Cluster registry update and access routines
//

#ifndef MIDL_PASS
HKEY
WINAPI
GetClusterKey(
    IN HCLUSTER hCluster,
    IN REGSAM samDesired
    );

HKEY
WINAPI
GetClusterGroupKey(
    IN HGROUP hGroup,
    IN REGSAM samDesired
    );

HKEY
WINAPI
GetClusterResourceKey(
    IN HRESOURCE hResource,
    IN REGSAM samDesired
    );

HKEY
WINAPI
GetClusterNodeKey(
    IN HNODE hNode,
    IN REGSAM samDesired
    );

HKEY
WINAPI
GetClusterNetworkKey(
    IN HNETWORK hNetwork,
    IN REGSAM samDesired
    );

HKEY
WINAPI
GetClusterNetInterfaceKey(
    IN HNETINTERFACE hNetInterface,
    IN REGSAM samDesired
    );

LONG
WINAPI
ClusterRegCreateKey(
    IN HKEY hKey,
    IN LPCWSTR lpszSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT OPTIONAL LPDWORD lpdwDisposition
    );

LONG
WINAPI
ClusterRegOpenKey(
    IN HKEY hKey,
    IN LPCWSTR lpszSubKey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    );

LONG
WINAPI
ClusterRegDeleteKey(
    IN HKEY hKey,
    IN LPCWSTR lpszSubKey
    );

LONG
WINAPI
ClusterRegCloseKey(
    IN HKEY hKey
    );

LONG
WINAPI
ClusterRegEnumKey(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcbName,
    OUT PFILETIME lpftLastWriteTime
    );

DWORD
WINAPI
ClusterRegSetValue(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    );

DWORD
WINAPI
ClusterRegDeleteValue(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName
    );

LONG
WINAPI
ClusterRegQueryValue(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

DWORD
WINAPI
ClusterRegEnumValue(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpszValueName,
    IN OUT LPDWORD lpcbValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

LONG
WINAPI
ClusterRegQueryInfoKey(
    IN HKEY hKey,
    IN LPDWORD lpcSubKeys,
    IN LPDWORD lpcbMaxSubKeyLen,
    IN LPDWORD lpcValues,
    IN LPDWORD lpcbMaxValueNameLen,
    IN LPDWORD lpcbMaxValueLen,
    IN LPDWORD lpcbSecurityDescriptor,
    IN PFILETIME lpftLastWriteTime
    );

LONG
WINAPI
ClusterRegGetKeySecurity (
    IN HKEY hKey,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN LPDWORD lpcbSecurityDescriptor
    );

LONG
WINAPI
ClusterRegSetKeySecurity(
    IN HKEY hKey,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

#endif // MIDL_PASS

#ifdef __cplusplus
}
#endif

#ifndef _CLUSTER_API_TYPES_
#define _CLUSTER_API_TYPES_
#endif // _CLUSTER_API_TYPES_

#endif // _CLUSTER_API_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\cluadmex.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Aug 08 11:34:16 1997
 */
/* Compiler settings for cluadmex.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cluadmex_h__
#define __cluadmex_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IGetClusterUIInfo_FWD_DEFINED__
#define __IGetClusterUIInfo_FWD_DEFINED__
typedef interface IGetClusterUIInfo IGetClusterUIInfo;
#endif 	/* __IGetClusterUIInfo_FWD_DEFINED__ */


#ifndef __IGetClusterDataInfo_FWD_DEFINED__
#define __IGetClusterDataInfo_FWD_DEFINED__
typedef interface IGetClusterDataInfo IGetClusterDataInfo;
#endif 	/* __IGetClusterDataInfo_FWD_DEFINED__ */


#ifndef __IGetClusterObjectInfo_FWD_DEFINED__
#define __IGetClusterObjectInfo_FWD_DEFINED__
typedef interface IGetClusterObjectInfo IGetClusterObjectInfo;
#endif 	/* __IGetClusterObjectInfo_FWD_DEFINED__ */


#ifndef __IGetClusterNodeInfo_FWD_DEFINED__
#define __IGetClusterNodeInfo_FWD_DEFINED__
typedef interface IGetClusterNodeInfo IGetClusterNodeInfo;
#endif 	/* __IGetClusterNodeInfo_FWD_DEFINED__ */


#ifndef __IGetClusterGroupInfo_FWD_DEFINED__
#define __IGetClusterGroupInfo_FWD_DEFINED__
typedef interface IGetClusterGroupInfo IGetClusterGroupInfo;
#endif 	/* __IGetClusterGroupInfo_FWD_DEFINED__ */


#ifndef __IGetClusterResourceInfo_FWD_DEFINED__
#define __IGetClusterResourceInfo_FWD_DEFINED__
typedef interface IGetClusterResourceInfo IGetClusterResourceInfo;
#endif 	/* __IGetClusterResourceInfo_FWD_DEFINED__ */


#ifndef __IGetClusterNetworkInfo_FWD_DEFINED__
#define __IGetClusterNetworkInfo_FWD_DEFINED__
typedef interface IGetClusterNetworkInfo IGetClusterNetworkInfo;
#endif 	/* __IGetClusterNetworkInfo_FWD_DEFINED__ */


#ifndef __IGetClusterNetInterfaceInfo_FWD_DEFINED__
#define __IGetClusterNetInterfaceInfo_FWD_DEFINED__
typedef interface IGetClusterNetInterfaceInfo IGetClusterNetInterfaceInfo;
#endif 	/* __IGetClusterNetInterfaceInfo_FWD_DEFINED__ */


#ifndef __IWCPropertySheetCallback_FWD_DEFINED__
#define __IWCPropertySheetCallback_FWD_DEFINED__
typedef interface IWCPropertySheetCallback IWCPropertySheetCallback;
#endif 	/* __IWCPropertySheetCallback_FWD_DEFINED__ */


#ifndef __IWEExtendPropertySheet_FWD_DEFINED__
#define __IWEExtendPropertySheet_FWD_DEFINED__
typedef interface IWEExtendPropertySheet IWEExtendPropertySheet;
#endif 	/* __IWEExtendPropertySheet_FWD_DEFINED__ */


#ifndef __IWCWizardCallback_FWD_DEFINED__
#define __IWCWizardCallback_FWD_DEFINED__
typedef interface IWCWizardCallback IWCWizardCallback;
#endif 	/* __IWCWizardCallback_FWD_DEFINED__ */


#ifndef __IWEExtendWizard_FWD_DEFINED__
#define __IWEExtendWizard_FWD_DEFINED__
typedef interface IWEExtendWizard IWEExtendWizard;
#endif 	/* __IWEExtendWizard_FWD_DEFINED__ */


#ifndef __IWCContextMenuCallback_FWD_DEFINED__
#define __IWCContextMenuCallback_FWD_DEFINED__
typedef interface IWCContextMenuCallback IWCContextMenuCallback;
#endif 	/* __IWCContextMenuCallback_FWD_DEFINED__ */


#ifndef __IWEExtendContextMenu_FWD_DEFINED__
#define __IWEExtendContextMenu_FWD_DEFINED__
typedef interface IWEExtendContextMenu IWEExtendContextMenu;
#endif 	/* __IWEExtendContextMenu_FWD_DEFINED__ */


#ifndef __IWEInvokeCommand_FWD_DEFINED__
#define __IWEInvokeCommand_FWD_DEFINED__
typedef interface IWEInvokeCommand IWEInvokeCommand;
#endif 	/* __IWEInvokeCommand_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "clusapi.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


			/* size is 2 */
typedef 
enum _CLUADMEX_OBJECT_TYPE
    {	CLUADMEX_OT_NONE	= 0,
	CLUADMEX_OT_CLUSTER	= CLUADMEX_OT_NONE + 1,
	CLUADMEX_OT_NODE	= CLUADMEX_OT_CLUSTER + 1,
	CLUADMEX_OT_GROUP	= CLUADMEX_OT_NODE + 1,
	CLUADMEX_OT_RESOURCE	= CLUADMEX_OT_GROUP + 1,
	CLUADMEX_OT_RESOURCETYPE	= CLUADMEX_OT_RESOURCE + 1,
	CLUADMEX_OT_NETWORK	= CLUADMEX_OT_RESOURCETYPE + 1,
	CLUADMEX_OT_NETINTERFACE	= CLUADMEX_OT_NETWORK + 1
    }	CLUADMEX_OBJECT_TYPE;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IGetClusterUIInfo_INTERFACE_DEFINED__
#define __IGetClusterUIInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetClusterUIInfo
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IGetClusterUIInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGetClusterUIInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetClusterName( 
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG __RPC_FAR *pcchName) = 0;
        
        virtual /* [local] */ LCID STDMETHODCALLTYPE GetLocale( void) = 0;
        
        virtual /* [local] */ HFONT STDMETHODCALLTYPE GetFont( void) = 0;
        
        virtual /* [local] */ HICON STDMETHODCALLTYPE GetIcon( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterUIInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetClusterUIInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetClusterUIInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetClusterUIInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClusterName )( 
            IGetClusterUIInfo __RPC_FAR * This,
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG __RPC_FAR *pcchName);
        
        /* [local] */ LCID ( STDMETHODCALLTYPE __RPC_FAR *GetLocale )( 
            IGetClusterUIInfo __RPC_FAR * This);
        
        /* [local] */ HFONT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )( 
            IGetClusterUIInfo __RPC_FAR * This);
        
        /* [local] */ HICON ( STDMETHODCALLTYPE __RPC_FAR *GetIcon )( 
            IGetClusterUIInfo __RPC_FAR * This);
        
        END_INTERFACE
    } IGetClusterUIInfoVtbl;

    interface IGetClusterUIInfo
    {
        CONST_VTBL struct IGetClusterUIInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterUIInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetClusterUIInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetClusterUIInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetClusterUIInfo_GetClusterName(This,lpszName,pcchName)	\
    (This)->lpVtbl -> GetClusterName(This,lpszName,pcchName)

#define IGetClusterUIInfo_GetLocale(This)	\
    (This)->lpVtbl -> GetLocale(This)

#define IGetClusterUIInfo_GetFont(This)	\
    (This)->lpVtbl -> GetFont(This)

#define IGetClusterUIInfo_GetIcon(This)	\
    (This)->lpVtbl -> GetIcon(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IGetClusterUIInfo_GetClusterName_Proxy( 
    IGetClusterUIInfo __RPC_FAR * This,
    /* [out] */ BSTR lpszName,
    /* [out][in] */ LONG __RPC_FAR *pcchName);


void __RPC_STUB IGetClusterUIInfo_GetClusterName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ LCID STDMETHODCALLTYPE IGetClusterUIInfo_GetLocale_Proxy( 
    IGetClusterUIInfo __RPC_FAR * This);


void __RPC_STUB IGetClusterUIInfo_GetLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HFONT STDMETHODCALLTYPE IGetClusterUIInfo_GetFont_Proxy( 
    IGetClusterUIInfo __RPC_FAR * This);


void __RPC_STUB IGetClusterUIInfo_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HICON STDMETHODCALLTYPE IGetClusterUIInfo_GetIcon_Proxy( 
    IGetClusterUIInfo __RPC_FAR * This);


void __RPC_STUB IGetClusterUIInfo_GetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetClusterUIInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterDataInfo_INTERFACE_DEFINED__
#define __IGetClusterDataInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetClusterDataInfo
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IGetClusterDataInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGetClusterDataInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetClusterName( 
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG __RPC_FAR *pcchName) = 0;
        
        virtual /* [local] */ HCLUSTER STDMETHODCALLTYPE GetClusterHandle( void) = 0;
        
        virtual /* [local] */ LONG STDMETHODCALLTYPE GetObjectCount( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterDataInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetClusterDataInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetClusterDataInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetClusterDataInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClusterName )( 
            IGetClusterDataInfo __RPC_FAR * This,
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG __RPC_FAR *pcchName);
        
        /* [local] */ HCLUSTER ( STDMETHODCALLTYPE __RPC_FAR *GetClusterHandle )( 
            IGetClusterDataInfo __RPC_FAR * This);
        
        /* [local] */ LONG ( STDMETHODCALLTYPE __RPC_FAR *GetObjectCount )( 
            IGetClusterDataInfo __RPC_FAR * This);
        
        END_INTERFACE
    } IGetClusterDataInfoVtbl;

    interface IGetClusterDataInfo
    {
        CONST_VTBL struct IGetClusterDataInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterDataInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetClusterDataInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetClusterDataInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetClusterDataInfo_GetClusterName(This,lpszName,pcchName)	\
    (This)->lpVtbl -> GetClusterName(This,lpszName,pcchName)

#define IGetClusterDataInfo_GetClusterHandle(This)	\
    (This)->lpVtbl -> GetClusterHandle(This)

#define IGetClusterDataInfo_GetObjectCount(This)	\
    (This)->lpVtbl -> GetObjectCount(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IGetClusterDataInfo_GetClusterName_Proxy( 
    IGetClusterDataInfo __RPC_FAR * This,
    /* [out] */ BSTR lpszName,
    /* [out][in] */ LONG __RPC_FAR *pcchName);


void __RPC_STUB IGetClusterDataInfo_GetClusterName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HCLUSTER STDMETHODCALLTYPE IGetClusterDataInfo_GetClusterHandle_Proxy( 
    IGetClusterDataInfo __RPC_FAR * This);


void __RPC_STUB IGetClusterDataInfo_GetClusterHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ LONG STDMETHODCALLTYPE IGetClusterDataInfo_GetObjectCount_Proxy( 
    IGetClusterDataInfo __RPC_FAR * This);


void __RPC_STUB IGetClusterDataInfo_GetObjectCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetClusterDataInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterObjectInfo_INTERFACE_DEFINED__
#define __IGetClusterObjectInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetClusterObjectInfo
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IGetClusterObjectInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGetClusterObjectInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetObjectName( 
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG __RPC_FAR *pcchName) = 0;
        
        virtual /* [local] */ CLUADMEX_OBJECT_TYPE STDMETHODCALLTYPE GetObjectType( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterObjectInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetClusterObjectInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetClusterObjectInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetClusterObjectInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectName )( 
            IGetClusterObjectInfo __RPC_FAR * This,
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG __RPC_FAR *pcchName);
        
        /* [local] */ CLUADMEX_OBJECT_TYPE ( STDMETHODCALLTYPE __RPC_FAR *GetObjectType )( 
            IGetClusterObjectInfo __RPC_FAR * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterObjectInfoVtbl;

    interface IGetClusterObjectInfo
    {
        CONST_VTBL struct IGetClusterObjectInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterObjectInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetClusterObjectInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetClusterObjectInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetClusterObjectInfo_GetObjectName(This,lObjIndex,lpszName,pcchName)	\
    (This)->lpVtbl -> GetObjectName(This,lObjIndex,lpszName,pcchName)

#define IGetClusterObjectInfo_GetObjectType(This,lObjIndex)	\
    (This)->lpVtbl -> GetObjectType(This,lObjIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IGetClusterObjectInfo_GetObjectName_Proxy( 
    IGetClusterObjectInfo __RPC_FAR * This,
    /* [in] */ LONG lObjIndex,
    /* [out] */ BSTR lpszName,
    /* [out][in] */ LONG __RPC_FAR *pcchName);


void __RPC_STUB IGetClusterObjectInfo_GetObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ CLUADMEX_OBJECT_TYPE STDMETHODCALLTYPE IGetClusterObjectInfo_GetObjectType_Proxy( 
    IGetClusterObjectInfo __RPC_FAR * This,
    /* [in] */ LONG lObjIndex);


void __RPC_STUB IGetClusterObjectInfo_GetObjectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetClusterObjectInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterNodeInfo_INTERFACE_DEFINED__
#define __IGetClusterNodeInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetClusterNodeInfo
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IGetClusterNodeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGetClusterNodeInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HNODE STDMETHODCALLTYPE GetNodeHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterNodeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetClusterNodeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetClusterNodeInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetClusterNodeInfo __RPC_FAR * This);
        
        /* [local] */ HNODE ( STDMETHODCALLTYPE __RPC_FAR *GetNodeHandle )( 
            IGetClusterNodeInfo __RPC_FAR * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterNodeInfoVtbl;

    interface IGetClusterNodeInfo
    {
        CONST_VTBL struct IGetClusterNodeInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterNodeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetClusterNodeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetClusterNodeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetClusterNodeInfo_GetNodeHandle(This,lObjIndex)	\
    (This)->lpVtbl -> GetNodeHandle(This,lObjIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HNODE STDMETHODCALLTYPE IGetClusterNodeInfo_GetNodeHandle_Proxy( 
    IGetClusterNodeInfo __RPC_FAR * This,
    /* [in] */ LONG lObjIndex);


void __RPC_STUB IGetClusterNodeInfo_GetNodeHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetClusterNodeInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterGroupInfo_INTERFACE_DEFINED__
#define __IGetClusterGroupInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetClusterGroupInfo
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IGetClusterGroupInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGetClusterGroupInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HGROUP STDMETHODCALLTYPE GetGroupHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterGroupInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetClusterGroupInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetClusterGroupInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetClusterGroupInfo __RPC_FAR * This);
        
        /* [local] */ HGROUP ( STDMETHODCALLTYPE __RPC_FAR *GetGroupHandle )( 
            IGetClusterGroupInfo __RPC_FAR * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterGroupInfoVtbl;

    interface IGetClusterGroupInfo
    {
        CONST_VTBL struct IGetClusterGroupInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterGroupInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetClusterGroupInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetClusterGroupInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetClusterGroupInfo_GetGroupHandle(This,lObjIndex)	\
    (This)->lpVtbl -> GetGroupHandle(This,lObjIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HGROUP STDMETHODCALLTYPE IGetClusterGroupInfo_GetGroupHandle_Proxy( 
    IGetClusterGroupInfo __RPC_FAR * This,
    /* [in] */ LONG lObjIndex);


void __RPC_STUB IGetClusterGroupInfo_GetGroupHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetClusterGroupInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterResourceInfo_INTERFACE_DEFINED__
#define __IGetClusterResourceInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetClusterResourceInfo
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IGetClusterResourceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGetClusterResourceInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESOURCE STDMETHODCALLTYPE GetResourceHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetResourceTypeName( 
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszResTypeName,
            /* [out][in] */ LONG __RPC_FAR *pcchResTypeName) = 0;
        
        virtual /* [local] */ BOOL STDMETHODCALLTYPE GetResourceNetworkName( 
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszNetName,
            /* [out][in] */ ULONG __RPC_FAR *pcchNetName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterResourceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetClusterResourceInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetClusterResourceInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetClusterResourceInfo __RPC_FAR * This);
        
        /* [local] */ HRESOURCE ( STDMETHODCALLTYPE __RPC_FAR *GetResourceHandle )( 
            IGetClusterResourceInfo __RPC_FAR * This,
            /* [in] */ LONG lObjIndex);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResourceTypeName )( 
            IGetClusterResourceInfo __RPC_FAR * This,
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszResTypeName,
            /* [out][in] */ LONG __RPC_FAR *pcchResTypeName);
        
        /* [local] */ BOOL ( STDMETHODCALLTYPE __RPC_FAR *GetResourceNetworkName )( 
            IGetClusterResourceInfo __RPC_FAR * This,
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszNetName,
            /* [out][in] */ ULONG __RPC_FAR *pcchNetName);
        
        END_INTERFACE
    } IGetClusterResourceInfoVtbl;

    interface IGetClusterResourceInfo
    {
        CONST_VTBL struct IGetClusterResourceInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterResourceInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetClusterResourceInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetClusterResourceInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetClusterResourceInfo_GetResourceHandle(This,lObjIndex)	\
    (This)->lpVtbl -> GetResourceHandle(This,lObjIndex)

#define IGetClusterResourceInfo_GetResourceTypeName(This,lObjIndex,lpszResTypeName,pcchResTypeName)	\
    (This)->lpVtbl -> GetResourceTypeName(This,lObjIndex,lpszResTypeName,pcchResTypeName)

#define IGetClusterResourceInfo_GetResourceNetworkName(This,lObjIndex,lpszNetName,pcchNetName)	\
    (This)->lpVtbl -> GetResourceNetworkName(This,lObjIndex,lpszNetName,pcchNetName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESOURCE STDMETHODCALLTYPE IGetClusterResourceInfo_GetResourceHandle_Proxy( 
    IGetClusterResourceInfo __RPC_FAR * This,
    /* [in] */ LONG lObjIndex);


void __RPC_STUB IGetClusterResourceInfo_GetResourceHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IGetClusterResourceInfo_GetResourceTypeName_Proxy( 
    IGetClusterResourceInfo __RPC_FAR * This,
    /* [in] */ LONG lObjIndex,
    /* [out] */ BSTR lpszResTypeName,
    /* [out][in] */ LONG __RPC_FAR *pcchResTypeName);


void __RPC_STUB IGetClusterResourceInfo_GetResourceTypeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ BOOL STDMETHODCALLTYPE IGetClusterResourceInfo_GetResourceNetworkName_Proxy( 
    IGetClusterResourceInfo __RPC_FAR * This,
    /* [in] */ LONG lObjIndex,
    /* [out] */ BSTR lpszNetName,
    /* [out][in] */ ULONG __RPC_FAR *pcchNetName);


void __RPC_STUB IGetClusterResourceInfo_GetResourceNetworkName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetClusterResourceInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterNetworkInfo_INTERFACE_DEFINED__
#define __IGetClusterNetworkInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetClusterNetworkInfo
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IGetClusterNetworkInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGetClusterNetworkInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HNETWORK STDMETHODCALLTYPE GetNetworkHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterNetworkInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetClusterNetworkInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetClusterNetworkInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetClusterNetworkInfo __RPC_FAR * This);
        
        /* [local] */ HNETWORK ( STDMETHODCALLTYPE __RPC_FAR *GetNetworkHandle )( 
            IGetClusterNetworkInfo __RPC_FAR * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterNetworkInfoVtbl;

    interface IGetClusterNetworkInfo
    {
        CONST_VTBL struct IGetClusterNetworkInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterNetworkInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetClusterNetworkInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetClusterNetworkInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetClusterNetworkInfo_GetNetworkHandle(This,lObjIndex)	\
    (This)->lpVtbl -> GetNetworkHandle(This,lObjIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HNETWORK STDMETHODCALLTYPE IGetClusterNetworkInfo_GetNetworkHandle_Proxy( 
    IGetClusterNetworkInfo __RPC_FAR * This,
    /* [in] */ LONG lObjIndex);


void __RPC_STUB IGetClusterNetworkInfo_GetNetworkHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetClusterNetworkInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterNetInterfaceInfo_INTERFACE_DEFINED__
#define __IGetClusterNetInterfaceInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetClusterNetInterfaceInfo
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IGetClusterNetInterfaceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGetClusterNetInterfaceInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HNETINTERFACE STDMETHODCALLTYPE GetNetInterfaceHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterNetInterfaceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetClusterNetInterfaceInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetClusterNetInterfaceInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetClusterNetInterfaceInfo __RPC_FAR * This);
        
        /* [local] */ HNETINTERFACE ( STDMETHODCALLTYPE __RPC_FAR *GetNetInterfaceHandle )( 
            IGetClusterNetInterfaceInfo __RPC_FAR * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterNetInterfaceInfoVtbl;

    interface IGetClusterNetInterfaceInfo
    {
        CONST_VTBL struct IGetClusterNetInterfaceInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterNetInterfaceInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetClusterNetInterfaceInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetClusterNetInterfaceInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetClusterNetInterfaceInfo_GetNetInterfaceHandle(This,lObjIndex)	\
    (This)->lpVtbl -> GetNetInterfaceHandle(This,lObjIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HNETINTERFACE STDMETHODCALLTYPE IGetClusterNetInterfaceInfo_GetNetInterfaceHandle_Proxy( 
    IGetClusterNetInterfaceInfo __RPC_FAR * This,
    /* [in] */ LONG lObjIndex);


void __RPC_STUB IGetClusterNetInterfaceInfo_GetNetInterfaceHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetClusterNetInterfaceInfo_INTERFACE_DEFINED__ */


#ifndef __IWCPropertySheetCallback_INTERFACE_DEFINED__
#define __IWCPropertySheetCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWCPropertySheetCallback
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IWCPropertySheetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWCPropertySheetCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPropertySheetPage( 
            /* [in] */ LONG __RPC_FAR *hpage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWCPropertySheetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWCPropertySheetCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWCPropertySheetCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWCPropertySheetCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPropertySheetPage )( 
            IWCPropertySheetCallback __RPC_FAR * This,
            /* [in] */ LONG __RPC_FAR *hpage);
        
        END_INTERFACE
    } IWCPropertySheetCallbackVtbl;

    interface IWCPropertySheetCallback
    {
        CONST_VTBL struct IWCPropertySheetCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWCPropertySheetCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWCPropertySheetCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWCPropertySheetCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWCPropertySheetCallback_AddPropertySheetPage(This,hpage)	\
    (This)->lpVtbl -> AddPropertySheetPage(This,hpage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWCPropertySheetCallback_AddPropertySheetPage_Proxy( 
    IWCPropertySheetCallback __RPC_FAR * This,
    /* [in] */ LONG __RPC_FAR *hpage);


void __RPC_STUB IWCPropertySheetCallback_AddPropertySheetPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWCPropertySheetCallback_INTERFACE_DEFINED__ */


#ifndef __IWEExtendPropertySheet_INTERFACE_DEFINED__
#define __IWEExtendPropertySheet_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWEExtendPropertySheet
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IWEExtendPropertySheet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWEExtendPropertySheet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePropertySheetPages( 
            /* [in] */ IUnknown __RPC_FAR *piData,
            /* [in] */ IWCPropertySheetCallback __RPC_FAR *piCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWEExtendPropertySheetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWEExtendPropertySheet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWEExtendPropertySheet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWEExtendPropertySheet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheetPages )( 
            IWEExtendPropertySheet __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piData,
            /* [in] */ IWCPropertySheetCallback __RPC_FAR *piCallback);
        
        END_INTERFACE
    } IWEExtendPropertySheetVtbl;

    interface IWEExtendPropertySheet
    {
        CONST_VTBL struct IWEExtendPropertySheetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWEExtendPropertySheet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWEExtendPropertySheet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWEExtendPropertySheet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWEExtendPropertySheet_CreatePropertySheetPages(This,piData,piCallback)	\
    (This)->lpVtbl -> CreatePropertySheetPages(This,piData,piCallback)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWEExtendPropertySheet_CreatePropertySheetPages_Proxy( 
    IWEExtendPropertySheet __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *piData,
    /* [in] */ IWCPropertySheetCallback __RPC_FAR *piCallback);


void __RPC_STUB IWEExtendPropertySheet_CreatePropertySheetPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWEExtendPropertySheet_INTERFACE_DEFINED__ */


#ifndef __IWCWizardCallback_INTERFACE_DEFINED__
#define __IWCWizardCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWCWizardCallback
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IWCWizardCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWCWizardCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddWizardPage( 
            /* [in] */ LONG __RPC_FAR *hpage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableNext( 
            /* [in] */ LONG __RPC_FAR *hpage,
            /* [in] */ BOOL bEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWCWizardCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWCWizardCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWCWizardCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWCWizardCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddWizardPage )( 
            IWCWizardCallback __RPC_FAR * This,
            /* [in] */ LONG __RPC_FAR *hpage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableNext )( 
            IWCWizardCallback __RPC_FAR * This,
            /* [in] */ LONG __RPC_FAR *hpage,
            /* [in] */ BOOL bEnable);
        
        END_INTERFACE
    } IWCWizardCallbackVtbl;

    interface IWCWizardCallback
    {
        CONST_VTBL struct IWCWizardCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWCWizardCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWCWizardCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWCWizardCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWCWizardCallback_AddWizardPage(This,hpage)	\
    (This)->lpVtbl -> AddWizardPage(This,hpage)

#define IWCWizardCallback_EnableNext(This,hpage,bEnable)	\
    (This)->lpVtbl -> EnableNext(This,hpage,bEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWCWizardCallback_AddWizardPage_Proxy( 
    IWCWizardCallback __RPC_FAR * This,
    /* [in] */ LONG __RPC_FAR *hpage);


void __RPC_STUB IWCWizardCallback_AddWizardPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWCWizardCallback_EnableNext_Proxy( 
    IWCWizardCallback __RPC_FAR * This,
    /* [in] */ LONG __RPC_FAR *hpage,
    /* [in] */ BOOL bEnable);


void __RPC_STUB IWCWizardCallback_EnableNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWCWizardCallback_INTERFACE_DEFINED__ */


#ifndef __IWEExtendWizard_INTERFACE_DEFINED__
#define __IWEExtendWizard_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWEExtendWizard
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IWEExtendWizard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWEExtendWizard : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateWizardPages( 
            /* [in] */ IUnknown __RPC_FAR *piData,
            /* [in] */ IWCWizardCallback __RPC_FAR *piCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWEExtendWizardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWEExtendWizard __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWEExtendWizard __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWEExtendWizard __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateWizardPages )( 
            IWEExtendWizard __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piData,
            /* [in] */ IWCWizardCallback __RPC_FAR *piCallback);
        
        END_INTERFACE
    } IWEExtendWizardVtbl;

    interface IWEExtendWizard
    {
        CONST_VTBL struct IWEExtendWizardVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWEExtendWizard_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWEExtendWizard_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWEExtendWizard_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWEExtendWizard_CreateWizardPages(This,piData,piCallback)	\
    (This)->lpVtbl -> CreateWizardPages(This,piData,piCallback)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWEExtendWizard_CreateWizardPages_Proxy( 
    IWEExtendWizard __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *piData,
    /* [in] */ IWCWizardCallback __RPC_FAR *piCallback);


void __RPC_STUB IWEExtendWizard_CreateWizardPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWEExtendWizard_INTERFACE_DEFINED__ */


#ifndef __IWCContextMenuCallback_INTERFACE_DEFINED__
#define __IWCContextMenuCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWCContextMenuCallback
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IWCContextMenuCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWCContextMenuCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddExtensionMenuItem( 
            /* [in] */ BSTR lpszName,
            /* [in] */ BSTR lpszStatusBarText,
            /* [in] */ ULONG nCommandID,
            /* [in] */ ULONG nSubmenuCommandID,
            /* [in] */ ULONG uFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWCContextMenuCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWCContextMenuCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWCContextMenuCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWCContextMenuCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtensionMenuItem )( 
            IWCContextMenuCallback __RPC_FAR * This,
            /* [in] */ BSTR lpszName,
            /* [in] */ BSTR lpszStatusBarText,
            /* [in] */ ULONG nCommandID,
            /* [in] */ ULONG nSubmenuCommandID,
            /* [in] */ ULONG uFlags);
        
        END_INTERFACE
    } IWCContextMenuCallbackVtbl;

    interface IWCContextMenuCallback
    {
        CONST_VTBL struct IWCContextMenuCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWCContextMenuCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWCContextMenuCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWCContextMenuCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWCContextMenuCallback_AddExtensionMenuItem(This,lpszName,lpszStatusBarText,nCommandID,nSubmenuCommandID,uFlags)	\
    (This)->lpVtbl -> AddExtensionMenuItem(This,lpszName,lpszStatusBarText,nCommandID,nSubmenuCommandID,uFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWCContextMenuCallback_AddExtensionMenuItem_Proxy( 
    IWCContextMenuCallback __RPC_FAR * This,
    /* [in] */ BSTR lpszName,
    /* [in] */ BSTR lpszStatusBarText,
    /* [in] */ ULONG nCommandID,
    /* [in] */ ULONG nSubmenuCommandID,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWCContextMenuCallback_AddExtensionMenuItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWCContextMenuCallback_INTERFACE_DEFINED__ */


#ifndef __IWEExtendContextMenu_INTERFACE_DEFINED__
#define __IWEExtendContextMenu_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWEExtendContextMenu
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IWEExtendContextMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWEExtendContextMenu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddContextMenuItems( 
            /* [in] */ IUnknown __RPC_FAR *piData,
            /* [in] */ IWCContextMenuCallback __RPC_FAR *piCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWEExtendContextMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWEExtendContextMenu __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWEExtendContextMenu __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWEExtendContextMenu __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddContextMenuItems )( 
            IWEExtendContextMenu __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piData,
            /* [in] */ IWCContextMenuCallback __RPC_FAR *piCallback);
        
        END_INTERFACE
    } IWEExtendContextMenuVtbl;

    interface IWEExtendContextMenu
    {
        CONST_VTBL struct IWEExtendContextMenuVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWEExtendContextMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWEExtendContextMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWEExtendContextMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWEExtendContextMenu_AddContextMenuItems(This,piData,piCallback)	\
    (This)->lpVtbl -> AddContextMenuItems(This,piData,piCallback)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWEExtendContextMenu_AddContextMenuItems_Proxy( 
    IWEExtendContextMenu __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *piData,
    /* [in] */ IWCContextMenuCallback __RPC_FAR *piCallback);


void __RPC_STUB IWEExtendContextMenu_AddContextMenuItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWEExtendContextMenu_INTERFACE_DEFINED__ */


#ifndef __IWEInvokeCommand_INTERFACE_DEFINED__
#define __IWEInvokeCommand_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWEInvokeCommand
 * at Fri Aug 08 11:34:16 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IWEInvokeCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWEInvokeCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvokeCommand( 
            /* [in] */ ULONG nCommandID,
            /* [in] */ IUnknown __RPC_FAR *piData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWEInvokeCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWEInvokeCommand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWEInvokeCommand __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWEInvokeCommand __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeCommand )( 
            IWEInvokeCommand __RPC_FAR * This,
            /* [in] */ ULONG nCommandID,
            /* [in] */ IUnknown __RPC_FAR *piData);
        
        END_INTERFACE
    } IWEInvokeCommandVtbl;

    interface IWEInvokeCommand
    {
        CONST_VTBL struct IWEInvokeCommandVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWEInvokeCommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWEInvokeCommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWEInvokeCommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWEInvokeCommand_InvokeCommand(This,nCommandID,piData)	\
    (This)->lpVtbl -> InvokeCommand(This,nCommandID,piData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWEInvokeCommand_InvokeCommand_Proxy( 
    IWEInvokeCommand __RPC_FAR * This,
    /* [in] */ ULONG nCommandID,
    /* [in] */ IUnknown __RPC_FAR *piData);


void __RPC_STUB IWEInvokeCommand_InvokeCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWEInvokeCommand_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 <company name>
//
//	Module Name:
//		BasePage.h
//
//	Abstract:
//		Definition of the CBasePropertyPage class.  This class provides base
//		functionality for extension DLL property pages.
//
//	Implementation File:
//		BasePage.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _EXTOBJ_H_
#include "ExtObj.h"		// for CExtObject
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
	CBasePropertyPage(void);
	CBasePropertyPage(IN UINT nIDTemplate, IN UINT nIDCaption = 0);
	~CBasePropertyPage(void);

	// Second phase construction.
	virtual BOOL		BInit(IN OUT CExtObject * peo);
	BOOL				BCreateParamsKey(void);

protected:
	void				CommonConstruct(void);

// Attributes
protected:
	CExtObject *		m_peo;
	HPROPSHEETPAGE		m_hpage;
	HKEY				m_hkeyParameters;

	IDD					m_iddPropertyPage;
	IDD					m_iddWizardPage;
	IDS					m_idsCaption;

	CExtObject *		Peo(void) const					{ return m_peo; }
	HPROPSHEETPAGE		Hpage(void) const				{ return m_hpage; }
	HKEY				HkeyParameters(void) const		{ return m_hkeyParameters; }

	IDD					IddPropertyPage(void) const		{ return m_iddPropertyPage; }
	IDD					IddWizardPage(void) const		{ return m_iddWizardPage; }
	IDS					IdsCaption(void) const			{ return m_idsCaption; }

public:
	void				SetHpage(IN OUT HPROPSHEETPAGE hpage) { m_hpage = hpage; }

// Dialog Data
	//{{AFX_DATA(CBasePropertyPage)
	enum { IDD = 0 };
	//}}AFX_DATA
	CStatic	m_staticIcon;
	CStatic	m_staticTitle;
	CString	m_strTitle;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertyPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	BOOL					m_bBackPressed;

	BOOL					BBackPressed(void) const		{ return m_bBackPressed; }
	IWCWizardCallback *		PiWizardCallback(void) const;
	BOOL					BWizard(void) const;
	HCLUSTER				Hcluster(void) const;
	HKEY					Hkey(void) const;
	void					EnableNext(IN BOOL bEnable = TRUE);

	DWORD					DwReadValue(
								IN LPCTSTR			pszValueName,
								OUT CString &		rstrValue,
								IN HKEY				hkey = NULL
								);
	DWORD					DwReadValue(
								IN LPCTSTR			pszValueName,
								OUT DWORD *			pdwValue,
								IN HKEY				hkey = NULL
								);

	DWORD					DwWriteValue(
								IN LPCTSTR			pszValueName,
								IN const CString &	rstrValue,
								IN OUT CString &	rstrPrevValue,
								IN HKEY				hkey = NULL
								);
	DWORD					DwWriteValue(
								IN LPCTSTR			pszValueName,
								IN DWORD			dwValue,
								IN OUT DWORD *		pdwPrevValue,
								IN HKEY				hkey = NULL
								);

	// Generated message map functions
	//{{AFX_MSG(CBasePropertyPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg void OnChangeCtrl();
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusrpc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Tue Mar 04 14:21:58 1997
 */
/* Compiler settings for clusrpc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __clusrpc_h__
#define __clusrpc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IntraCluster_INTERFACE_DEFINED__
#define __IntraCluster_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IntraCluster
 * at Tue Mar 04 14:21:58 1997
 * using MIDL 3.00.44
 ****************************************/
/* [explicit_handle][version][uuid] */ 


typedef WCHAR __RPC_FAR CLUSTER_ID[ 37 ];

typedef /* [context_handle] */ void __RPC_FAR *HGROUP_ENUM_RPC;

typedef 
enum _GROUP_STATE
    {	GroupOnline	= 0,
	GroupOffline	= GroupOnline + 1,
	GroupFailed	= GroupOffline + 1,
	GroupPartialOnline	= GroupFailed + 1
    }	GROUP_STATE;

typedef struct  _GROUP_ENUM_ENTRY
    {
    /* [string] */ LPWSTR Id;
    DWORD State;
    }	GROUP_ENUM_ENTRY;

typedef struct _GROUP_ENUM_ENTRY __RPC_FAR *PGROUP_ENUM_ENTRY;

typedef struct  _GROUP_ENUM
    {
    DWORD EntryCount;
    /* [size_is] */ GROUP_ENUM_ENTRY Entry[ 1 ];
    }	GROUP_ENUM;

typedef struct _GROUP_ENUM __RPC_FAR *PGROUP_ENUM;

typedef struct  _RESOURCE_ENUM_ENTRY
    {
    /* [string] */ LPWSTR Id;
    DWORD State;
    }	RESOURCE_ENUM_ENTRY;

typedef struct _RESOURCE_ENUM_ENTRY __RPC_FAR *PRESOURCE_ENUM_ENTRY;

typedef struct  _RESOURCE_ENUM
    {
    DWORD EntryCount;
    /* [size_is] */ RESOURCE_ENUM_ENTRY Entry[ 1 ];
    }	RESOURCE_ENUM;

typedef struct _RESOURCE_ENUM __RPC_FAR *PRESOURCE_ENUM;

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsQueryOwnedGroups( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ PGROUP_ENUM __RPC_FAR *OwnedGroups,
    /* [out] */ PRESOURCE_ENUM __RPC_FAR *OwnedResources);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsQueryOwnedGroups( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ PGROUP_ENUM __RPC_FAR *OwnedGroups,
    /* [out] */ PRESOURCE_ENUM __RPC_FAR *OwnedResources);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsOnlineGroupRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsOnlineGroupRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsOfflineGroupRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsOfflineGroupRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsMoveGroupRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId,
    /* [unique][in] */ LPCWSTR DestinationNode);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsMoveGroupRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId,
    /* [unique][in] */ LPCWSTR DestinationNode);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsTakeGroupRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId,
    /* [in] */ DWORD State);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsTakeGroupRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId,
    /* [in] */ DWORD State);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsOnlineResourceRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsOnlineResourceRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsOfflineResourceRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsOfflineResourceRequest( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsChangeResourceNode( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId,
    /* [in] */ LPCWSTR NodeId,
    /* [in] */ BOOL Add);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsChangeResourceNode( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId,
    /* [in] */ LPCWSTR NodeId,
    /* [in] */ BOOL Add);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsArbitrateResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsArbitrateResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsFailResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsFailResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsCreateResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId,
    /* [in] */ LPWSTR ResourceId,
    /* [in] */ LPCWSTR ResourceName);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsCreateResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId,
    /* [in] */ LPWSTR ResourceId,
    /* [in] */ LPCWSTR ResourceName);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsDeleteResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsDeleteResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsResourceControl( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsResourceControl( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceId,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsResourceTypeControl( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceTypeName,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsResourceTypeControl( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceTypeName,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t FmsGroupControl( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_FmsGroupControl( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR GroupId,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);

typedef /* [allocate] */ UCHAR __RPC_FAR *PGUM_DATA;

/* client prototype */
error_status_t GumQueueLockingUpdate( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD NodeId,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Context,
    /* [out] */ LPDWORD Sequence,
    /* [in] */ DWORD BufferLength,
    /* [size_is][in] */ PGUM_DATA Buffer);
/* server prototype */
error_status_t s_GumQueueLockingUpdate( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD NodeId,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Context,
    /* [out] */ LPDWORD Sequence,
    /* [in] */ DWORD BufferLength,
    /* [size_is][in] */ PGUM_DATA Buffer);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t GumAttemptJoinUpdate( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD JoiningId,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Context,
    /* [in] */ DWORD Sequence,
    /* [in] */ DWORD BufferLength,
    /* [size_is][unique][in] */ PGUM_DATA Buffer);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_GumAttemptJoinUpdate( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD JoiningId,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Context,
    /* [in] */ DWORD Sequence,
    /* [in] */ DWORD BufferLength,
    /* [size_is][unique][in] */ PGUM_DATA Buffer);

/* client prototype */
error_status_t GumUnlockUpdate( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Sequence);
/* server prototype */
error_status_t s_GumUnlockUpdate( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Sequence);

/* client prototype */
error_status_t GumUpdateNode( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Context,
    /* [in] */ DWORD Sequence,
    /* [in] */ DWORD BufferLength,
    /* [size_is][in] */ PGUM_DATA Buffer);
/* server prototype */
error_status_t s_GumUpdateNode( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Context,
    /* [in] */ DWORD Sequence,
    /* [in] */ DWORD BufferLength,
    /* [size_is][in] */ PGUM_DATA Buffer);

/* client prototype */
error_status_t GumJoinUpdateNode( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD JoiningId,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Context,
    /* [in] */ DWORD Sequence,
    /* [in] */ DWORD BufferLength,
    /* [size_is][unique][in] */ PGUM_DATA Buffer);
/* server prototype */
error_status_t s_GumJoinUpdateNode( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD JoiningId,
    /* [in] */ DWORD Type,
    /* [in] */ DWORD Context,
    /* [in] */ DWORD Sequence,
    /* [in] */ DWORD BufferLength,
    /* [size_is][unique][in] */ PGUM_DATA Buffer);

typedef struct  _GUM_NODE_LIST
    {
    DWORD NodeCount;
    /* [size_is] */ DWORD NodeId[ 1 ];
    }	GUM_NODE_LIST;

typedef struct _GUM_NODE_LIST __RPC_FAR *PGUM_NODE_LIST;

/* client prototype */
error_status_t GumGetNodeSequence( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Type,
    /* [out] */ LPDWORD Sequence,
    /* [out] */ LPDWORD LockerNodeId,
    /* [out] */ PGUM_NODE_LIST __RPC_FAR *NodeList);
/* server prototype */
error_status_t s_GumGetNodeSequence( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Type,
    /* [out] */ LPDWORD Sequence,
    /* [out] */ LPDWORD LockerNodeId,
    /* [out] */ PGUM_NODE_LIST __RPC_FAR *NodeList);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t MmMsgSend( 
    /* [in] */ handle_t IDL_handle,
    /* [size_is][in] */ const UCHAR __RPC_FAR *buffer,
    /* [in] */ DWORD length);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_MmMsgSend( 
    /* [in] */ handle_t IDL_handle,
    /* [size_is][in] */ const UCHAR __RPC_FAR *buffer,
    /* [in] */ DWORD length);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t NmRpcDeliverJoinMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [size_is][in] */ UCHAR __RPC_FAR *Message,
    /* [in] */ DWORD MessageLength);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_NmRpcDeliverJoinMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [size_is][in] */ UCHAR __RPC_FAR *Message,
    /* [in] */ DWORD MessageLength);

typedef struct pipe_BYTE_PIPE
    {
    void (__RPC_FAR * pull) (
        char __RPC_FAR * state,
        byte __RPC_FAR * buf,
        unsigned long esize,
        unsigned long __RPC_FAR * ecount );
    void (__RPC_FAR * push) (
        char __RPC_FAR * state,
        byte __RPC_FAR * buf,
        unsigned long ecount );
    void (__RPC_FAR * alloc) (
        char __RPC_FAR * state,
        unsigned long bsize,
        byte __RPC_FAR * __RPC_FAR * buf,
        unsigned long __RPC_FAR * bcount );
    char __RPC_FAR * state;
    } 	BYTE_PIPE;

/* client prototype */
/* [fault_status][comm_status] */ error_status_t CpDepositCheckpoint( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ const CLUSTER_ID ResourceId,
    /* [in] */ DWORD dwCheckpointId,
    /* [in] */ BYTE_PIPE CheckpointData);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_CpDepositCheckpoint( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ const CLUSTER_ID ResourceId,
    /* [in] */ DWORD dwCheckpointId,
    /* [in] */ BYTE_PIPE CheckpointData);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t CpRetrieveCheckpoint( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ const CLUSTER_ID ResourceId,
    /* [in] */ DWORD dwCheckpointId,
    /* [out] */ BYTE_PIPE CheckpointData);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_CpRetrieveCheckpoint( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ const CLUSTER_ID ResourceId,
    /* [in] */ DWORD dwCheckpointId,
    /* [out] */ BYTE_PIPE CheckpointData);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t EvPropEvents( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD dwEventInfoSize,
    /* [size_is][in] */ UCHAR __RPC_FAR *pPackedEventInfo);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_EvPropEvents( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD dwEventInfoSize,
    /* [size_is][in] */ UCHAR __RPC_FAR *pPackedEventInfo);



extern RPC_IF_HANDLE IntraCluster_v1_0_c_ifspec;
extern RPC_IF_HANDLE s_IntraCluster_v1_0_s_ifspec;
#endif /* __IntraCluster_INTERFACE_DEFINED__ */

#ifndef __ExtroCluster_INTERFACE_DEFINED__
#define __ExtroCluster_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ExtroCluster
 * at Tue Mar 04 14:21:58 1997
 * using MIDL 3.00.44
 ****************************************/
/* [explicit_handle][version][uuid] */ 


#define	CS_MAX_NODE_NAME_LENGTH	( 15 )

#define	CS_MAX_NODE_ID_LENGTH	( 5 )

#define	CS_NETWORK_ID_LENGTH	( 36 )

typedef struct  _NM_NODE_INFO
    {
    /* [string] */ WCHAR NodeId[ 6 ];
    /* [string] */ WCHAR NodeName[ 16 ];
    DWORD State;
    }	NM_NODE_INFO;

typedef struct _NM_NODE_INFO __RPC_FAR *PNM_NODE_INFO;

typedef struct  _NM_NODE_ENUM
    {
    DWORD NodeCount;
    /* [size_is] */ NM_NODE_INFO NodeList[ 1 ];
    }	NM_NODE_ENUM;

typedef struct _NM_NODE_ENUM __RPC_FAR *PNM_NODE_ENUM;

typedef struct  _NM_NETWORK_NODE_INFO
    {
    /* [string] */ WCHAR NodeId[ 6 ];
    /* [string] */ LPWSTR AdapterName;
    /* [string] */ LPWSTR Address;
    /* [string] */ LPWSTR Endpoint;
    }	NM_NETWORK_NODE_INFO;

typedef struct _NM_NETWORK_NODE_INFO __RPC_FAR *PNM_NETWORK_NODE_INFO;

typedef struct  _NM_NETWORK_NODE_ENUM
    {
    DWORD NetworkNodeCount;
    /* [size_is] */ NM_NETWORK_NODE_INFO NetworkNodeList[ 1 ];
    }	NM_NETWORK_NODE_ENUM;

typedef struct _NM_NETWORK_NODE_ENUM __RPC_FAR *PNM_NETWORK_NODE_ENUM;

typedef struct  _NM_NETWORK_INFO
    {
    /* [string] */ WCHAR NetworkId[ 37 ];
    /* [string] */ LPWSTR NetworkName;
    DWORD Priority;
    /* [string] */ LPWSTR TransportName;
    DWORD IsPublicNetwork;
    DWORD IsClusterInterconnect;
    PNM_NETWORK_NODE_ENUM NetworkNodeEnum;
    }	NM_NETWORK_INFO;

typedef struct _NM_NETWORK_INFO __RPC_FAR *PNM_NETWORK_INFO;

typedef struct  _NM_NETWORK_ENUM
    {
    DWORD NetworkCount;
    /* [size_is] */ NM_NETWORK_INFO NetworkList[ 1 ];
    }	NM_NETWORK_ENUM;

typedef struct _NM_NETWORK_ENUM __RPC_FAR *PNM_NETWORK_ENUM;

/* client prototype */
/* [fault_status][comm_status] */ error_status_t NmRpcGetNodeEnum( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ PNM_NODE_ENUM __RPC_FAR *NodeEnum);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_NmRpcGetNodeEnum( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ PNM_NODE_ENUM __RPC_FAR *NodeEnum);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t NmRpcGetNetworkEnum( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ PNM_NETWORK_ENUM __RPC_FAR *NetworkEnum);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_NmRpcGetNetworkEnum( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ PNM_NETWORK_ENUM __RPC_FAR *NetworkEnum);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t NmRpcSetNetworkNodeInfo( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPWSTR NetworkId,
    /* [string][in] */ LPWSTR NodeId,
    /* [string][in] */ LPWSTR AdapterName,
    /* [string][in] */ LPWSTR Address,
    /* [string][in] */ LPWSTR Endpoint);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_NmRpcSetNetworkNodeInfo( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPWSTR NetworkId,
    /* [string][in] */ LPWSTR NodeId,
    /* [string][in] */ LPWSTR AdapterName,
    /* [string][in] */ LPWSTR Address,
    /* [string][in] */ LPWSTR Endpoint);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t NmRpcJoinBegin( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPWSTR JoinerNodeId,
    /* [string][out] */ LPWSTR __RPC_FAR *SponsorNodeId,
    /* [out] */ LPDWORD JoinSequenceNumber);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_NmRpcJoinBegin( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPWSTR JoinerNodeId,
    /* [string][out] */ LPWSTR __RPC_FAR *SponsorNodeId,
    /* [out] */ LPDWORD JoinSequenceNumber);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t JoinCreateBindings( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD NodeId,
    /* [string][in] */ LPCWSTR lpszNodeId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_JoinCreateBindings( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD NodeId,
    /* [string][in] */ LPCWSTR lpszNodeId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t JoinPetitionForMembership( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD NodeId,
    /* [string][in] */ LPCWSTR lpszNodeId,
    /* [in] */ DWORD Sequence);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_JoinPetitionForMembership( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD NodeId,
    /* [string][in] */ LPCWSTR lpszNodeId,
    /* [in] */ DWORD Sequence);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t JoinAddNode( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszNodeId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_JoinAddNode( 
    /* [in] */ handle_t IDL_handle,
    /* [string][in] */ LPCWSTR lpszNodeId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t DmSyncDatabase( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ BYTE_PIPE reg_data);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_DmSyncDatabase( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ BYTE_PIPE reg_data);



extern RPC_IF_HANDLE ExtroCluster_v1_0_c_ifspec;
extern RPC_IF_HANDLE s_ExtroCluster_v1_0_s_ifspec;
#endif /* __ExtroCluster_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusdef.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clusdef.h

Abstract:

    Common definitions for user-mode and kernel-mode components of the
    cluster project.

Author:

    Mike Massa (mikemas) 15-Feb-1997

Revision History:

--*/
#ifndef _CLUSDEF_H
#define _CLUSDEF_H


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Define the following field to 1 for Cluster Beta testing, zero otherwise.
//
#define CLUSTER_BETA    1

//
// Cluster node ID definition
//
typedef ULONG CL_NODE_ID;

#define ClusterMinNodeId         1
#define ClusterMinNodeIdString   L"1"
#define ClusterDefaultMaxNodes   16
#define ClusterAnyNodeId         0
#define ClusterInvalidNodeId     0xFFFFFFFF


//
// Cluster network ID definition
//
typedef ULONG CL_NETWORK_ID, *PCL_NETWORK_ID;

#define ClusterAnyNetworkId         0
#define ClusterInvalidNetworkId     0xFFFFFFFF


//
// ClusNet node communication state definition
//
typedef enum {
    ClusnetNodeCommStateOffline = 0,
    ClusnetNodeCommStateOfflinePending = 1,
    ClusnetNodeCommStateUnreachable = 2,
    ClusnetNodeCommStateOnlinePending = 3,
    ClusnetNodeCommStateOnline = 4
} CLUSNET_NODE_COMM_STATE, *PCLUSNET_NODE_COMM_STATE;

//
// ClusNet network state definition
//
typedef enum {
    ClusnetNetworkStateOffline = 0,
    ClusnetNetworkStateOfflinePending = 1,
    ClusnetNetworkStatePartitioned = 2,
    ClusnetNetworkStateOnlinePending = 3,
    ClusnetNetworkStateOnline = 4
} CLUSNET_NETWORK_STATE, *PCLUSNET_NETWORK_STATE;

//
// ClusNet interface state definition
//
typedef enum {
    ClusnetInterfaceStateOffline = 0,
    ClusnetInterfaceStateOfflinePending = 1,
    ClusnetInterfaceStateUnreachable = 2,
    ClusnetInterfaceStateOnlinePending = 3,
    ClusnetInterfaceStateOnline = 4
} CLUSNET_INTERFACE_STATE, *PCLUSNET_INTERFACE_STATE;

//
// ClusNet node membership state. This tracks the internal
// membership state maintained by the membership engine in the cluster
// service. This enum MUST start at zero since it is used as an index
// into a state table.
//

typedef enum {
    ClusnetNodeStateAlive = 0,
    ClusnetNodeStateJoining,
    ClusnetNodeStateDead,
    ClusnetNodeStateNotConfigured,
    ClusnetNodeStateLastEntry
} CLUSNET_NODE_STATE, *PCLUSNET_NODE_STATE;

//
// ClusNet Event definitions
//
typedef enum _CLUSNET_EVENT_TYPE {
    ClusnetEventNone                   = 0x00000000,
    ClusnetEventNodeUp                 = 0x00000001,
    ClusnetEventNodeDown               = 0x00000002,
    ClusnetEventPoisonPacketReceived   = 0x00000004,
    ClusnetEventHalt                   = 0x00000008,
    ClusnetEventAll                    = 0xFFFFFFFF
} CLUSNET_EVENT_TYPE, *PCLUSNET_EVENT_TYPE;

typedef struct {
    ULONG                 Epoch;
    CLUSNET_EVENT_TYPE    EventType;
    CL_NODE_ID            NodeId;
    CL_NETWORK_ID         NetworkId;
} CLUSNET_EVENT, *PCLUSNET_EVENT;

//
// ClusNet NTSTATUS codes.
//
// We start by defining our own facility code to distinguish our status
// values.
//
// This claim is also in ntstatus.h.  Leaving it here to avoid any
// possible build breaks or issues.
// EBK - 5/8/2000 Whistler bug # 83157
#ifndef FACILITY_CLUSTER_ERROR_CODE
#define FACILITY_CLUSTER_ERROR_CODE  0x13
#endif

//
// Warning codes
//
#define STATUS_CLUSTER_NODE_ALREADY_ONLINE           0x80130001L
#define STATUS_CLUSTER_NODE_ALREADY_OFFLINE          0x80130002L
#define STATUS_CLUSTER_NETWORK_ALREADY_ONLINE        0x80130003L
#define STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE       0x80130004L
#define STATUS_CLUSTER_NODE_ALREADY_MEMBER           0x80130005L

//
// Error codes
//
#define STATUS_CLUSTER_INVALID_NODE                  0xC0130001L
#define STATUS_CLUSTER_NODE_EXISTS                   0xC0130002L
#define STATUS_CLUSTER_JOIN_IN_PROGRESS              0xC0130003L
#define STATUS_CLUSTER_NODE_NOT_FOUND                0xC0130004L
#define STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND          0xC0130005L
#define STATUS_CLUSTER_NETWORK_EXISTS                0xC0130006L
#define STATUS_CLUSTER_NETWORK_NOT_FOUND             0xC0130007L
#define STATUS_CLUSTER_INTERFACE_EXISTS              0xC0130008L
#define STATUS_CLUSTER_INTERFACE_NOT_FOUND           0xC0130009L
#define STATUS_CLUSTER_INVALID_REQUEST               0xC013000AL
#define STATUS_CLUSTER_INVALID_NETWORK_PROVIDER      0xC013000BL
#define STATUS_CLUSTER_NODE_OFFLINE                  0xC013000CL
#define STATUS_CLUSTER_NODE_UNREACHABLE              0xC013000DL
#define STATUS_CLUSTER_NODE_NOT_MEMBER               0xC013000EL
#define STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS          0xC013000FL
#define STATUS_CLUSTER_INVALID_NETWORK               0xC0130010L
#define STATUS_CLUSTER_NO_NET_ADAPTERS               0xC0130011L
#define STATUS_CLUSTER_NODE_NOT_ONLINE               0xC0130012L
#define STATUS_CLUSTER_NODE_NOT_OFFLINE              0xC0130013L
#define STATUS_CLUSTER_NODE_NOT_PAUSED               0xC0130014L

//
// ClusNet Win32 Error Codes
//

//
// Warning codes
//
// These constants are declared with real values in clusmsg.h.  There declaration
// here maybe completely obsolete.  I just left them here to avoid introducing any 
// unforseen breaks.
// EBK - 5/8/2000 Whistler bug # 83158
//
#define ERROR_CLUSTER_NODE_ALREADY_ONLINE        STATUS_CLUSTER_NODE_ALREADY_ONLINE
#define ERROR_CLUSTER_NODE_ALREADY_OFFLINE       STATUS_CLUSTER_NODE_ALREADY_OFFLINE
#define ERROR_CLUSTER_NETWORK_ALREADY_ONLINE     STATUS_CLUSTER_NETWORK_ALREADY_ONLINE
#define ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE    STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE
#define ERROR_CLUSTER_ALREADY_MEMBER             STATUS_CLUSTER_NODE_ALREADY_MEMBER

//
// Error codes
//
#define ERROR_CLUSTER_INVALID_NODE               STATUS_CLUSTER_INVALID_NODE
#define ERROR_CLUSTER_NODE_EXISTS                STATUS_CLUSTER_NODE_EXISTS
#define ERROR_CLUSTER_JOIN_IN_PROGRESS           STATUS_CLUSTER_JOIN_IN_PROGRESS
#define ERROR_CLUSTER_NODE_NOT_FOUND             STATUS_CLUSTER_NODE_NOT_FOUND
#define ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND       STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND
#define ERROR_CLUSTER_NETWORK_EXISTS             STATUS_CLUSTER_NETWORK_EXISTS
#define ERROR_CLUSTER_NETWORK_NOT_FOUND          STATUS_CLUSTER_NETWORK_NOT_FOUND
#define ERROR_CLUSTER_INTERFACE_EXISTS           STATUS_CLUSTER_INTERFACE_EXISTS
#define ERROR_CLUSTER_INTERFACE_NOT_FOUND        STATUS_CLUSTER_INTERFACE_NOT_FOUND
#define ERROR_CLUSTER_INVALID_REQUEST            STATUS_CLUSTER_INVALID_REQUEST
#define ERROR_CLUSTER_INVALID_NETWORK_PROVIDER   STATUS_CLUSTER_INVALID_NETWORK_PROVIDER
#define ERROR_CLUSTER_NODE_OFFLINE               STATUS_CLUSTER_NODE_OFFLINE
#define ERROR_CLUSTER_NODE_UNREACHABLE           STATUS_CLUSTER_NODE_UNREACHABLE
#define ERROR_CLUSTER_NODE_NOT_MEMBER            STATUS_CLUSTER_NODE_NOT_MEMBER
#define ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS       STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS
#define ERROR_CLUSTER_INVALID_NETWORK            STATUS_CLUSTER_INVALID_NETWORK
#define ERROR_CLUSTER_NO_NET_ADAPTERS            STATUS_CLUSTER_NO_NET_ADAPTERS
#define ERROR_CLUSTER_NODE_NOT_ONLINE            STATUS_CLUSTER_NODE_NOT_ONLINE
#define ERROR_CLUSTER_NODE_NOT_OFFLINE           STATUS_CLUSTER_NODE_NOT_OFFLINE
#define ERROR_CLUSTER_NODE_NOT_PAUSED            STATUS_CLUSTER_NODE_NOT_PAUSED


#define ERROR_CLUSTER_NETWORK_NOT_INTERNAL       0xC0130050L


#ifdef __cplusplus
}
#endif // __cplusplus


#endif //_CLUSDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusdisk.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    clusapi.h

Abstract:

    This module defines the common management and application interface to
    the Windows Clusters services.

Authors:

    Rod Gamache     13-Feb-1996

Revision History:

--*/

#ifndef _CLUSTER_DISK_
#define _CLUSTER_DISK_


//
// Disk States.
//

typedef enum _DiskState {
    DiskOffline,
    DiskOnline,
    DiskFailed,
    DiskStateMaximum = DiskFailed
} DiskState;


//
// Define IOCTLs specific to ClusDisk Filter Driver.
//

#define IOCTL_DISK_CLUSTER_SET_STATE    CTL_CODE(IOCTL_SCSI_BASE, 0x500, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DISK_CLUSTER_RESET_BUS    CTL_CODE(IOCTL_SCSI_BASE, 0x501, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DISK_CLUSTER_READ_CAPACITY CTL_CODE(IOCTL_SCSI_BASE, 0x502, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_DISK_CLUSTER_RESERVE      CTL_CODE(IOCTL_SCSI_BASE, 0x503, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DISK_CLUSTER_RELEASE      CTL_CODE(IOCTL_SCSI_BASE, 0x504, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DISK_CLUSTER_ATTACH       CTL_CODE(IOCTL_SCSI_BASE, 0x505, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DISK_CLUSTER_DETACH       CTL_CODE(IOCTL_SCSI_BASE, 0x506, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DISK_CLUSTER_GET_DRIVE_LAYOUT CTL_CODE(IOCTL_SCSI_BASE, 0x507, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_DISK_CLUSTER_START_RESERVE CTL_CODE(IOCTL_SCSI_BASE, 0x508, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DISK_CLUSTER_STOP_RESERVE CTL_CODE(IOCTL_SCSI_BASE, 0x509, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DISK_CLUSTER_ALIVE_CHECK CTL_CODE(IOCTL_SCSI_BASE, 0x510, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_DISK_CLUSTER_ROOT         CTL_CODE(IOCTL_SCSI_BASE, 0x511, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_DISK_CLUSTER_ACTIVE       CTL_CODE(IOCTL_SCSI_BASE, 0x512, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_DISK_CLUSTER_TEST         CTL_CODE(IOCTL_SCSI_BASE, 0x513, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_DISK_CLUSTER_NOT_CLUSTER_CAPABLE CTL_CODE(IOCTL_SCSI_BASE, 0x514, METHOD_BUFFERED, FILE_ANY_ACCESS)



#endif // _CLUSTER_DISK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusmsg.h ===
/*++

Copyright (c) 1991-1996  Microsoft Corporation

Module Name:

    clusmsg.h

Abstract:

    This file contains the message definitions for the cluster service.

Author:

    davidp 19-Sep-1996

Revision History:

Notes:

    This file is generated from clusmsg.mc

--*/

#ifndef _CLUSMSG_H_
#define _CLUSMSG_H_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: ERROR_NETWORK_NOT_AVAILABLE
//
// MessageText:
//
//  A cluster network is not available for this operation.
//
#define ERROR_NETWORK_NOT_AVAILABLE      0x000013ABL

//
// MessageId: ERROR_NODE_NOT_AVAILABLE
//
// MessageText:
//
//  A cluster node is not available for this operation.
//
#define ERROR_NODE_NOT_AVAILABLE         0x000013ACL

//
// MessageId: ERROR_ALL_NODES_NOT_AVAILABLE
//
// MessageText:
//
//  All cluster nodes must be running to perform this operation.
//
#define ERROR_ALL_NODES_NOT_AVAILABLE    0x000013ADL

//
// MessageId: ERROR_RESOURCE_FAILED
//
// MessageText:
//
//  A cluster resource failed.
//
#define ERROR_RESOURCE_FAILED            0x000013AEL

//
// MessageId: ERROR_CLUSTER_INVALID_NODE
//
// MessageText:
//
//  The cluster node is not valid.
//
#define ERROR_CLUSTER_INVALID_NODE       0x000013AFL

//
// MessageId: ERROR_CLUSTER_NODE_EXISTS
//
// MessageText:
//
//  The cluster node already exists.
//
#define ERROR_CLUSTER_NODE_EXISTS        0x000013B0L

//
// MessageId: ERROR_CLUSTER_JOIN_IN_PROGRESS
//
// MessageText:
//
//  A node is in the process of joining the cluster.
//
#define ERROR_CLUSTER_JOIN_IN_PROGRESS   0x000013B1L

//
// MessageId: ERROR_CLUSTER_NODE_NOT_FOUND
//
// MessageText:
//
//  The cluster node was not found.
//
#define ERROR_CLUSTER_NODE_NOT_FOUND     0x000013B2L

//
// MessageId: ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND
//
// MessageText:
//
//  The cluster local node information was not found.
//
#define ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND 0x000013B3L

//
// MessageId: ERROR_CLUSTER_NETWORK_EXISTS
//
// MessageText:
//
//  The cluster network already exists.
//
#define ERROR_CLUSTER_NETWORK_EXISTS     0x000013B4L

//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_FOUND
//
// MessageText:
//
//  The cluster network was not found.
//
#define ERROR_CLUSTER_NETWORK_NOT_FOUND  0x000013B5L

//
// MessageId: ERROR_CLUSTER_NETINTERFACE_EXISTS
//
// MessageText:
//
//  The cluster network interface already exists.
//
#define ERROR_CLUSTER_NETINTERFACE_EXISTS 0x000013B6L

//
// MessageId: ERROR_CLUSTER_NETINTERFACE_NOT_FOUND
//
// MessageText:
//
//  The cluster network interface was not found.
//
#define ERROR_CLUSTER_NETINTERFACE_NOT_FOUND 0x000013B7L

//
// MessageId: ERROR_CLUSTER_INVALID_REQUEST
//
// MessageText:
//
//  The cluster request is not valid for this object.
//
#define ERROR_CLUSTER_INVALID_REQUEST    0x000013B8L

//
// MessageId: ERROR_CLUSTER_INVALID_NETWORK_PROVIDER
//
// MessageText:
//
//  The cluster network provider is not valid.
//
#define ERROR_CLUSTER_INVALID_NETWORK_PROVIDER 0x000013B9L

//
// MessageId: ERROR_CLUSTER_NODE_DOWN
//
// MessageText:
//
//  The cluster node is down.
//
#define ERROR_CLUSTER_NODE_DOWN          0x000013BAL

//
// MessageId: ERROR_CLUSTER_NODE_UNREACHABLE
//
// MessageText:
//
//  The cluster node is not reachable.
//
#define ERROR_CLUSTER_NODE_UNREACHABLE   0x000013BBL

//
// MessageId: ERROR_CLUSTER_NODE_NOT_MEMBER
//
// MessageText:
//
//  The cluster node is not a member of the cluster.
//
#define ERROR_CLUSTER_NODE_NOT_MEMBER    0x000013BCL

//
// MessageId: ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS
//
// MessageText:
//
//  A cluster join operation is not in progress.
//
#define ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS 0x000013BDL

//
// MessageId: ERROR_CLUSTER_INVALID_NETWORK
//
// MessageText:
//
//  The cluster network is not valid.
//
#define ERROR_CLUSTER_INVALID_NETWORK    0x000013BEL

//
// MessageId: ERROR_CLUSTER_NODE_UP
//
// MessageText:
//
//  The cluster node is up.
//
#define ERROR_CLUSTER_NODE_UP            0x000013C0L

//
// MessageId: ERROR_CLUSTER_IPADDR_IN_USE
//
// MessageText:
//
//  The cluster IP Address is already in use.
//
#define ERROR_CLUSTER_IPADDR_IN_USE      0x000013C1L

//
// MessageId: ERROR_CLUSTER_NODE_NOT_PAUSED
//
// MessageText:
//
//  The cluster node is not paused.
//
#define ERROR_CLUSTER_NODE_NOT_PAUSED    0x000013C2L

//
// MessageId: ERROR_CLUSTER_NO_SECURITY_CONTEXT
//
// MessageText:
//
//  No cluster security context is available.
//
#define ERROR_CLUSTER_NO_SECURITY_CONTEXT 0x000013C3L

//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_INTERNAL
//
// MessageText:
//
//  The cluster network is not configured for internal cluster communication.
//
#define ERROR_CLUSTER_NETWORK_NOT_INTERNAL 0x000013C4L

//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_UP
//
// MessageText:
//
//  The cluster node is already up.
//
#define ERROR_CLUSTER_NODE_ALREADY_UP    0x000013C5L

//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_DOWN
//
// MessageText:
//
//  The cluster node is already down.
//
#define ERROR_CLUSTER_NODE_ALREADY_DOWN  0x000013C6L

//
// MessageId: ERROR_CLUSTER_NETWORK_ALREADY_ONLINE
//
// MessageText:
//
//  The cluster network is already online.
//
#define ERROR_CLUSTER_NETWORK_ALREADY_ONLINE 0x000013C7L

//
// MessageId: ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE
//
// MessageText:
//
//  The cluster network is already offline.
//
#define ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE 0x000013C8L

//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_MEMBER
//
// MessageText:
//
//  The cluster node is already a member of the cluster.
//
#define ERROR_CLUSTER_NODE_ALREADY_MEMBER 0x000013C9L

//
// MessageId: ERROR_CLUSTER_LAST_INTERNAL_NETWORK
//
// MessageText:
//
//  The cluster network is the only one configured for internal cluster
//  communication between two or more active cluster nodes. The internal
//  communication capability cannot be removed from the network.
//
#define ERROR_CLUSTER_LAST_INTERNAL_NETWORK 0x000013CAL

//
// MessageId: ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS
//
// MessageText:
//
//  One or more cluster resources depend on the network to provide service
//  to clients. The client access capability cannot be removed from the network.
//
#define ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS 0x000013CBL

//
// MessageId: ERROR_INVALID_OPERATION_ON_QUORUM
//
// MessageText:
//
//  This operation cannot be performed on the cluster resource as it the quorum
//  resource.  You may not bring the quorum resource offline or modify its
//  possible owners list.
//
#define ERROR_INVALID_OPERATION_ON_QUORUM 0x000013CCL

//
// MessageId: ERROR_DEPENDENCY_NOT_ALLOWED
//
// MessageText:
//
//  The cluster quorum resource is not allowed to have any dependencies.
//
#define ERROR_DEPENDENCY_NOT_ALLOWED     0x000013CDL

//
// MessageId: ERROR_CLUSTER_NODE_PAUSED
//
// MessageText:
//
//  The cluster node is paused.
//
#define ERROR_CLUSTER_NODE_PAUSED        0x000013CEL

//
// MessageId: ERROR_NODE_CANT_HOST_RESOURCE
//
// MessageText:
//
//  The cluster resource cannot be brought online. The owner node cannot run this
//  resource.
//
#define ERROR_NODE_CANT_HOST_RESOURCE    0x000013CFL

//
// MessageId: ERROR_CLUSTER_NODE_NOT_READY
//
// MessageText:
//
//  The cluster node is not ready to perform the requested operation.
//
#define ERROR_CLUSTER_NODE_NOT_READY     0x000013D0L

//
// MessageId: ERROR_CLUSTER_NODE_SHUTTING_DOWN
//
// MessageText:
//
//  The cluster node is shutting down.
//
#define ERROR_CLUSTER_NODE_SHUTTING_DOWN 0x000013D1L

//
// MessageId: ERROR_CLUSTER_JOIN_ABORTED
//
// MessageText:
//
//  The cluster join operation was aborted.
//
#define ERROR_CLUSTER_JOIN_ABORTED       0x000013D2L

#endif // _CLUSMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clustdi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clustdi.h

Abstract:

    TDI definitions for the Cluster Network Protocol suite.

Author:

    Mike Massa (mikemas)  21-Feb-1997

Environment:

    User Mode.

Revision History:

--*/


#ifndef _CLUSTDI_INCLUDED
#define _CLUSTDI_INCLUDED


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


#define TDI_ADDRESS_TYPE_CLUSTER  ((USHORT) 24)

#include <packon.h>

typedef struct _TDI_ADDRESS_CLUSTER {
    USHORT   Port;
    ULONG    Node;
    ULONG    ReservedMBZ;
} TDI_ADDRESS_CLUSTER, *PTDI_ADDRESS_CLUSTER;

#define TDI_ADDRESS_LENGTH_CLUSTER  sizeof(TDI_ADDRESS_CLUSTER)


typedef struct _TA_ADDRESS_CLUSTER {
    LONG TAAddressCount;
    struct _AddrCluster {
        USHORT AddressLength;       // length in bytes of this address == 8
        USHORT AddressType;         // this will == TDI_ADDRESS_TYPE_CLUSTER
        TDI_ADDRESS_CLUSTER Address[1];
    } Address [1];
} TA_CLUSTER_ADDRESS, *PTA_CLUSTER_ADDRESS;

#include <packoff.h>


#ifdef __cplusplus
}
#endif // __cplusplus


#endif  // ifndef _CLUSTDI_INCLUDED


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusres.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clusres.h

Abstract:

    Common Resource DLL Header

Author:

    John Vert (jvert) 12/15/1996

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "clusudef.h"
#include "clusapi.h"
#include "resapi.h"
#include "clusvmsg.h"


#define LOCAL_SERVICES  L"System\\CurrentControlSet\\Services"

extern PLOG_EVENT_ROUTINE ClusResLogEvent;
extern PSET_RESOURCE_STATUS_ROUTINE ClusResSetResourceStatus;

//
// Cluster Resource Specific routines
//

DWORD
ClusResOpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    );

NTSTATUS
ClusResDoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    );


//
// Helpful macros for logging cluster service events
//
VOID
ClusResLogEventWithName0(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );

VOID
ClusResLogEventWithName1(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    );

#define ClusResLogEventByKey(_hKey_, _level_, _msgid_)       \
    ClusResLogEventWithName0(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL)

#define ClusResLogEventByKey1(_hKey_, _level_, _msgid_, _arg1_)       \
    ClusResLogEventWithName1(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL,                           \
                             _arg1_)

#define ClusResLogEventByKeyData(_hKey_, _level_, _msgid_, dwBytes, pData)       \
    ClusResLogEventWithName0(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL)

#define ClusResLogEvent(_level_, _msgid_)           \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL)

#define ClusResLogEvent1(_level_, _msgid_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define ClusResLogEvent2(_level_, _msgid_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_))

#define ClusResLogEvent3(_level_, _msgid_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

#define ClusResLogEventData(_level_, _msgid_, _dwBytes_, _pData_)                \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_))

#define ClusResLogEventData1(_level_, _msgid_, _dwBytes_, _pData_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_))

#define ClusResLogEventData2(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_))

#define ClusResLogEventData3(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

//
// Define interfaces exposed by each specified resource DLL and
// referenced by the common CLUSRES wrapper.
//
#define LOG_MODULE_GENAPP    0x801
#define LOG_MODULE_GENSVC    0x802
#define LOG_MODULE_FTSET     0x803
#define LOG_MODULE_DISK      0x804
#define LOG_MODULE_NETNAME   0x805
#define LOG_MODULE_IPADDR    0x806
#define LOG_MODULE_SMB       0x807
#define LOG_MODULE_TIME      0x808
#define LOG_MODULE_SPOOL     0x809
#define LOG_MODULE_LKQRM     0x80A
#define LOG_MODULE_DHCP      0x80B
#define LOG_MODULE_MSMQ      0x80C
#define LOG_MODULE_MSDTC     0x80D

//
// interfaces for GENAPP
//
extern CLRES_FUNCTION_TABLE GenAppFunctionTable;

BOOLEAN
WINAPI
GenAppDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for GENSVC
//
extern CLRES_FUNCTION_TABLE GenSvcFunctionTable;

BOOLEAN
WINAPI
GenSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for DISKS and FTSET
//
extern CLRES_FUNCTION_TABLE DisksFunctionTable;
extern CLRES_FUNCTION_TABLE FtSetFunctionTable;

BOOLEAN
WINAPI
DisksDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

BOOLEAN
WINAPI
FtSetDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for NETNAME
//
extern CLRES_FUNCTION_TABLE NetNameFunctionTable;

BOOLEAN
WINAPI
NetNameDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for IPADDR
//
extern CLRES_FUNCTION_TABLE IpAddrFunctionTable;

BOOLEAN
WINAPI
IpAddrDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for File Shares
//
extern CLRES_FUNCTION_TABLE SmbShareFunctionTable;

BOOLEAN
WINAPI
SmbShareDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Spool Service
//
extern CLRES_FUNCTION_TABLE SplSvcFunctionTable;

BOOLEAN
WINAPI
SplSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for Local Quorum
//
extern CLRES_FUNCTION_TABLE LkQuorumFunctionTable;

BOOLEAN
WINAPI
LkQuorumDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE DhcpFunctionTable;

BOOLEAN
WINAPI
DhcpDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE MsMQFunctionTable;

BOOLEAN
WINAPI
MsMQDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE MsDTCFunctionTable;

BOOLEAN
WINAPI
MsDTCDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE TimeSvcFunctionTable;

BOOLEAN
WINAPI
TimeSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusrtl.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    clusrtl.h

Abstract:

    Header file for definitions and structures for the NT Cluster
    Run Time Library

Author:

    John Vert (jvert) 30-Nov-1995

Revision History:

--*/

#ifndef _CLUSRTL_INCLUDED_
#define _CLUSRTL_INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif


//
// Service Message IDs
//
#include "clusvmsg.h"

#include "resapi.h"
#include <aclapi.h>

//
//  Routine Description:
//
//      Initializes the cluster run time library.
//
//  Arguments:
//
//      RunningAsService  - TRUE if the process is running as an NT service.
//                          FALSE if running as a console app.
//
//  Return Value:
//
//      ERROR_SUCCESS if the function succeeds.
//      A Win32 error code otherwise.
//
DWORD
ClRtlInitialize(
    IN  BOOLEAN    RunningAsService
    );


//
//  Routine Description:
//
//      Cleans up the cluster run time library.
//
//  Arguments:
//
//      RunningAsService  - TRUE if the process is running as an NT service.
//                          FALSE if running as a console app.
//
//  Return Value:
//
//      None.
//
VOID
ClRtlCleanup(
    VOID
    );

//////////////////////////////////////////////////////////////////////////
//
// Event logging interfaces
//
//
// There are three currently defined logging levels:
//     LOG_CRITICAL - fatal error, chaos and destruction will ensue
//     LOG_UNUSUAL  - unexpected event, but will be handled
//     LOG_NOISE    - normal occurence
//
//////////////////////////////////////////////////////////////////////////

#define LOG_CRITICAL 1
#define LOG_UNUSUAL  2
#define LOG_NOISE    3

//
// A few interfaces for reporting of errors.
//
VOID
ClRtlLogInit(
    VOID
    );

VOID
ClusterLogFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    );

VOID
ClusterLogNonFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    );

VOID
ClusterLogAssertionFailure(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN LPSTR Expression
    );

VOID
ClusterLogEvent0(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );

VOID
ClusterLogEvent1(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    );

VOID
ClusterLogEvent2(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    );

VOID
ClusterLogEvent3(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    );


//
//  Routine Description:
//
//      Prints a message to the debug terminal if running as a service
//      or the console window if running as a console app.
//
//  Arguments:
//
//      FormatString     - Message string.
//
//      Any FormatMessage-compatible arguments to be inserted in the
//      ErrorMessage before it is logged.
//
//  Return Value:
//
//      None.
//
VOID
ClRtlDbgPrint(
    PCHAR FormatString,
    ...
    );

//
// Same as ClRtlDbgPrint, only uses a message ID instead of a string.
//
VOID
ClRtlMsgPrint(
    IN DWORD MessageId,
    ...
    );

//
// Same as ClRtlDbgPrint, only logs to a file instead of screen.
//
VOID
ClRtlLogPrint(
    PCHAR FormatString,
    ...
    );

//
// Macros/prototypes for unexpected error handling.
//

#define ARGUMENT_PRESENT( ArgumentPointer )   (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )


#define CL_UNEXPECTED_ERROR(_errcode_)              \
    ClusterLogFatalError(LOG_CURRENT_MODULE,        \
                         __LINE__,                  \
                         __FILE__,                  \
                        (_errcode_))

WINBASEAPI
BOOL
APIENTRY
IsDebuggerPresent(
    VOID
    );

#define CL_ASSERT( exp )                                    \
    if (!(exp)) {                                           \
        ClusterLogAssertionFailure(LOG_CURRENT_MODULE,      \
                                   __LINE__,                \
                                   __FILE__,                \
                                   #exp);                   \
    }

#define CL_LOGFAILURE( _errcode_ )                  \
ClusterLogNonFatalError(LOG_CURRENT_MODULE,         \
                         __LINE__,                  \
                         __FILE__,                  \
                        (_errcode_))

// Use the following to put cluster specific errors in the event log
#define CL_LOGCLUSERROR( _errcode_ )        \
ClusterLogEvent0(LOG_CRITICAL,              \
                 LOG_CURRENT_MODULE,        \
                 __FILE__,                  \
                 __LINE__,                  \
                 (_errcode_),               \
                 0,                         \
                 NULL)


#define CL_LOGCLUSWARNING( _errcode_ )     \
ClusterLogEvent0(LOG_UNUSUAL,              \
                 LOG_CURRENT_MODULE,       \
                 __FILE__,                 \
                 __LINE__,                 \
                 (_errcode_),              \
                 0,                        \
                 NULL)


#define CL_LOGCLUSWARNING1(_msgid_,_arg1_)      \
    ClusterLogEvent1(LOG_UNUSUAL,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define CL_LOGCLUSERROR1(_msgid_,_arg1_)      \
    ClusterLogEvent1(LOG_CRITICAL,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

//////////////////////////////////////////////////////////////////////////
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures. Stolen from ntrtl.h
//
//////////////////////////////////////////////////////////////////////////

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


//
//  Singly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures. Stolen from ntrtl.h
//

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


//////////////////////////////////////////////////////////////////////////
//
// General-purpose queue package.
//
//////////////////////////////////////////////////////////////////////////
typedef struct _CL_QUEUE {
    LIST_ENTRY ListHead;
    CRITICAL_SECTION Lock;
    HANDLE Event;
    DWORD Count;
    HANDLE Abort;
} CL_QUEUE, *PCL_QUEUE;

DWORD
ClRtlInitializeQueue(
    IN PCL_QUEUE Queue
    );

VOID
ClRtlDeleteQueue(
    IN PCL_QUEUE Queue
    );

PLIST_ENTRY
ClRtlRemoveHeadQueue(
    IN PCL_QUEUE Queue
    );

PLIST_ENTRY
ClRtlRemoveHeadQueueTimeout(
    IN PCL_QUEUE Queue,
    IN DWORD dwMilliseconds
    );

VOID
ClRtlInsertTailQueue(
    IN PCL_QUEUE Queue,
    IN PLIST_ENTRY Item
    );

VOID
ClRtlRundownQueue(
    IN PCL_QUEUE Queue,
    OUT PLIST_ENTRY ListHead
    );


//////////////////////////////////////////////////////////////////////////
//
// General-purpose buffer pool package.
//
//////////////////////////////////////////////////////////////////////////

//
// Buffer pool definition.
//
typedef struct _CLRTL_BUFFER_POOL *PCLRTL_BUFFER_POOL;


//
// Maximum number of buffers that can be allocated from a pool.
//
#define CLRTL_MAX_POOL_BUFFERS  0xFFFFFFFE


//
// Routines for utilizing buffer pools.
//
typedef
DWORD
(*CLRTL_BUFFER_CONSTRUCTOR)(
    PVOID Buffer
    );
/*++

Routine Description:

    Called to initialize a buffer which has been newly allocated
    from system memory.

Arguments:

    Buffer  - A pointer to the buffer to initialize.

Return Value:

    ERROR_SUCCESS if the initialization succeeded.

    A Win32 error code if the initialization failed.

--*/


typedef
VOID
(*CLRTL_BUFFER_DESTRUCTOR)(
    PVOID Buffer
    );
/*++

Routine Description:

    Called to cleanup a buffer which is about to be returned to
    system memory.

Arguments:

    Buffer  - A pointer to the buffer to cleanup.

Return Value:

    None.

--*/


PCLRTL_BUFFER_POOL
ClRtlCreateBufferPool(
    IN DWORD                      BufferSize,
    IN DWORD                      MaximumCached,
    IN DWORD                      MaximumAllocated,
    IN CLRTL_BUFFER_CONSTRUCTOR   Constructor,         OPTIONAL
    IN CLRTL_BUFFER_DESTRUCTOR    Destructor           OPTIONAL
    );
/*++

Routine Description:

    Creates a pool from which fixed-size buffers may be allocated.

Arguments:

    BufferSize        - Size of the buffers managed by the pool.

    MaximumCached     - The maximum number of buffers to cache in the pool.
                        Must be less than or equal to MaximumAllocated.

    MaximumAllocated  - The maximum number of buffers to allocate from
                        system memory. Must be less than or equal to
                        CLRTL_MAX_POOL_BUFFERS.

    Constructor       - An optional routine to be called when a new buffer
                        is allocated from system memory. May be NULL

    Destructor        - An optional routine to be called when a buffer
                        is returned to system memory. May be NULL.

Return Value:

    A pointer to the created buffer pool or NULL on error.
    Extended error information is available from GetLastError().

--*/


VOID
ClRtlDestroyBufferPool(
    IN PCLRTL_BUFFER_POOL  Pool
    );
/*++

Routine Description:

    Destroys a previously created buffer pool.

Arguments:

    Pool  - A pointer to the pool to destroy.

Return Value:

    None.

Notes:

    The pool will not actually be destroyed until all outstanding
    buffers have been returned. Each outstanding buffer is effectively
    a reference on the pool.

--*/


PVOID
ClRtlAllocateBuffer(
    IN PCLRTL_BUFFER_POOL Pool
    );
/*++

Routine Description:

    Allocates a buffer from a previously created buffer pool.

Arguments:

    Pool - A pointer to the pool from which to allocate the buffer.

Return Value:

    A pointer to the allocated buffer if the routine was successfull.
    NULL if the routine failed. Extended error information is available
    by calling GetLastError().

--*/


VOID
ClRtlFreeBuffer(
    PVOID Buffer
    );
/*++

Routine Description:

    Frees a buffer back to its owning pool.

Arguments:

    Buffer   - The buffer to free.

Return Value:

    None.

--*/



//////////////////////////////////////////////////////////////////////////
//
// General-purpose worker thread queue package.
//
//////////////////////////////////////////////////////////////////////////

typedef struct _CLRTL_WORK_ITEM *PCLRTL_WORK_ITEM;

typedef
VOID
(*PCLRTL_WORK_ROUTINE)(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN DWORD              IoContext
    );
/*++

Routine Description:

    Called to process an item posted to a work queue.

Arguments:

    WorkItem          - The work item to process.

    Status            - If the work item represents a completed I/O operation,
                        this parameter contains the completion status of the
                        operation.

    BytesTransferred  - If the work item represents a completed I/O operation,
                        this parameter contains the number of bytes tranferred
                        during the operation. For other work items, the
                        semantics of this parameter are defined by the caller
                        of ClRtlPostItemWorkQueue.

    IoContext         - If the work item represents a completed I/O operation,
                        this parameter contains the context value associated
                        with the handle on which the I/O was submitted. For
                        other work items, the semantics of this parameter are
                        defined by the caller of ClRtlPostItemWorkQueue.

Return Value:

    None.

--*/


//
// Work Item Structure.
//
typedef struct _CLRTL_WORK_ITEM {
    OVERLAPPED             Overlapped;
    PCLRTL_WORK_ROUTINE    WorkRoutine;
    PVOID                  Context;
} CLRTL_WORK_ITEM;


//
// Work queue definition.
//
typedef struct _CLRTL_WORK_QUEUE  *PCLRTL_WORK_QUEUE;


//
// Routines For Utilizing Work Queues
//

#define ClRtlInitializeWorkItem(Item, Routine, Ctx)                   \
            ZeroMemory(&((Item)->Overlapped), sizeof(OVERLAPPED));    \
            (Item)->WorkRoutine = (Routine);                          \
            (Item)->Context = (Ctx);


PCLRTL_WORK_QUEUE
ClRtlCreateWorkQueue(
    IN DWORD  MaximumThreads,
    IN int    ThreadPriority
    );
/*++

Routine Description:

    Creates a work queue and a dynamic pool of threads to service it.

Arguments:

    MaximumThreads - The maximum number of threads to create to service
                     the queue.

    ThreadPriority - The priority level at which the queue worker threads
                     should run.

Return Value:

    A pointer to the created queue if the routine is successful.

    NULL if the routine fails. Call GetLastError for extended
    error information.

--*/


VOID
ClRtlDestroyWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue
    );
/*++

Routine Description:

    Destroys a work queue and its thread pool.

Arguments:

    WorkQueue  - The queue to destroy.

Return Value:

    None.

Notes:

    The following rules must be observed in order to safely destroy a
    work queue:

        1) No new work items may be posted to the queue once all previously
           posted items have been processed by this routine.

        2) WorkRoutines must be able to process items until this
           call returns. After the call returns, no more items will
           be delivered from the specified queue.

    One workable cleanup procedure is as follows: First, direct the
    WorkRoutines to silently discard completed items. Next, eliminate
    all sources of new work. Finally, destroy the work queue. Note that
    when in discard mode, the WorkRoutines may not access any structures
    which will be destroyed by eliminating the sources of new work.

--*/


DWORD
ClRtlPostItemWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              BytesTransferred,  OPTIONAL
    IN DWORD              IoContext          OPTIONAL
    );
/*++

Routine Description:

    Posts a specified work item to a specified work queue.

Arguments:

    WorkQueue         - A pointer to the work queue to which to post the item.

    WorkItem          - A pointer to the item to post.

    BytesTransferred  - If the work item represents a completed I/O operation,
                        this parameter contains the number of bytes
                        transferred during the operation. For other work items,
                        the semantics of this parameter may be defined by
                        the caller.

    IoContext         - If the work item represents a completed I/O operation,
                        this parameter contains the context value associated
                        with the handle on which the operation was submitted.
                        Of other work items, the semantics of this parameter
                        may be defined by the caller.

Return Value:

    ERROR_SUCCESS if the item was posted successfully.
    A Win32 error code if the post operation fails.

--*/


DWORD
ClRtlAssociateIoHandleWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN HANDLE             IoHandle,
    IN DWORD              IoContext
    );
/*++

Routine Description:

    Associates a specified I/O handle, opened for overlapped I/O
    completion, with a work queue. All pending I/O operations on
    the specified handle will be posted to the work queue when
    completed. An initialized CLRTL_WORK_ITEM must be used to supply
    the OVERLAPPED structure whenever an I/O operation is submitted on
    the specified handle.

Arguments:

    WorkQueue     - The work queue with which to associate the I/O handle.

    IoHandle      - The I/O handle to associate.

    IoContext     - A context value to associate with the specified handle.
                    This value will be supplied as a parameter to the
                    WorkRoutine which processes completions for this
                    handle.

Return Value:

    ERROR_SUCCESS if the association completes successfully.
    A Win32 error code if the association fails.

--*/


//////////////////////////////////////////////////////////////////////////
//
// Utilities for accessing the NT system registry.
//
//////////////////////////////////////////////////////////////////////////
DWORD
ClRtlRegQueryDword(
    IN  HKEY    hKey,
    IN  LPWSTR  lpValueName,
    OUT LPDWORD lpValue,
    IN  LPDWORD lpDefaultValue OPTIONAL
    );

DWORD
ClRtlRegQueryString(
    IN     HKEY     Key,
    IN     LPWSTR   ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    );


//////////////////////////////////////////////////////////////////////////
//
// Routines for groveling and managing network configuration.
// Currently, these are specific to TCP/IP.
//
//////////////////////////////////////////////////////////////////////////

//
// Transport interface information structure
//
// The "Ignore" field is intitialized to FALSE. If it is set to
// TRUE by an application, the enum search functions will ignore
// the entry.
//
typedef struct _CLRTL_NET_INTERFACE_INFO {
    struct _CLRTL_NET_INTERFACE_INFO *  Next;
    ULONG                               Context;
    ULONG                               Flags;
    ULONG                               InterfaceAddress;
    LPWSTR                              InterfaceAddressString;
    ULONG                               NetworkAddress;
    LPWSTR                              NetworkAddressString;
    ULONG                               NetworkMask;
    LPWSTR                              NetworkMaskString;
    BOOLEAN                             Ignore;
} CLRTL_NET_INTERFACE_INFO, *PCLRTL_NET_INTERFACE_INFO;

#define CLRTL_NET_INTERFACE_PRIMARY   0x00000001
#define CLRTL_NET_INTERFACE_DYNAMIC   0x00000002

//
// Adapter information structure
//
// The "Ignore" field is intitialized to FALSE. If it is set to
// TRUE by an application, the enum search functions will ignore
// the entry.
//
typedef struct _CLRTL_NET_ADAPTER_INFO {
    struct _CLRTL_NET_ADAPTER_INFO *   Next;
    LPWSTR                             Name;
    ULONG                              Index;
    ULONG                              Flags;
    ULONG                              InterfaceCount;
    PCLRTL_NET_INTERFACE_INFO          InterfaceList;
    BOOLEAN                            Ignore;
} CLRTL_NET_ADAPTER_INFO, *PCLRTL_NET_ADAPTER_INFO;

#define CLRTL_NET_ADAPTER_HIDDEN      0x00000001


typedef struct {
    ULONG                    AdapterCount;
    PCLRTL_NET_ADAPTER_INFO  AdapterList;
} CLRTL_NET_ADAPTER_ENUM, *PCLRTL_NET_ADAPTER_ENUM;


PCLRTL_NET_ADAPTER_ENUM
ClRtlEnumNetAdapters(
    VOID
    );

VOID
ClRtlFreeNetAdapterEnum(
    IN PCLRTL_NET_ADAPTER_ENUM  AdapterEnum
    );

PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByName(
    PCLRTL_NET_ADAPTER_ENUM   AdapterEnum,
    LPWSTR                    AdapterName
    );

PCLRTL_NET_INTERFACE_INFO
ClRtlFindNetInterfaceByNetworkAddress(
    IN PCLRTL_NET_ADAPTER_INFO   AdapterInfo,
    IN LPWSTR                    NetworkAddress
    );

PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByNetworkAddress(
    IN  PCLRTL_NET_ADAPTER_ENUM      AdapterEnum,
    IN  LPWSTR                       NetworkAddress,
    OUT PCLRTL_NET_INTERFACE_INFO *  InterfaceInfo
    );

PCLRTL_NET_INTERFACE_INFO
ClRtlGetPrimaryNetInterface(
    IN PCLRTL_NET_ADAPTER_INFO  AdapterInfo
    );

VOID
ClRtlQueryTcpipInformation(
    OUT  LPDWORD   MaxAddressStringLength,
    OUT  LPDWORD   MaxEndpointStringLength
    );

DWORD
ClRtlTcpipAddressToString(
    ULONG     AddressValue,
    LPWSTR *  AddressString
    );

DWORD
ClRtlTcpipStringToAddress(
    LPWSTR  AddressString,
    PULONG  AddressValue
    );

DWORD
ClRtlTcpipEndpointToString(
    USHORT    EndpointValue,
    LPWSTR *  EndpointString
    );

DWORD
ClRtlTcpipStringToEndpoint(
    LPWSTR   EndpointString,
    PUSHORT  EndpointValue
    );

BOOL
ClRtlIsValidTcpipAddress(
    IN ULONG   Address
    );

BOOL
ClRtlIsValidTcpipSubnetMask(
    IN ULONG   SubnetMask
    );

//
// BOOL
// ClRtlAreTcpipAddressesOnSameSubnet(
//     ULONG Address1,
//     ULONG Address2,
//     ULONG SubnetMask
//     );
//
#define ClRtlAreTcpipAddressesOnSameSubnet(_Addr1, _Addr2, _Mask) \
            ( ((_Addr1 & _Mask) == (_Addr2 & _Mask)) ? TRUE : FALSE )


DWORD
ClRtlBuildTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    IN  LPWSTR    TransportEndpoint,
    OUT LPVOID *  TdiAddress,
    OUT LPDWORD   TdiAddressLength
    );

DWORD
ClRtlBuildLocalTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    OUT LPVOID    TdiAddress,
    OUT LPDWORD   TdiAddressLength
    );

DWORD
ClRtlParseTcpipTdiAddress(
    IN  LPVOID    TdiAddress,
    OUT LPWSTR *  NetworkAddress,
    OUT LPWSTR *  TransportEndpoint
    );


//
// Routines for manipulating IP Addresses
//
BOOLEAN
UnicodeInetAddr(
    PWCHAR  AddressString,
    PULONG  Address
    );

//
// IP_ADDRESS - access an IP address as a single DWORD or 4 BYTEs
//

typedef union {
    DWORD d;
    BYTE b[4];
} IP_ADDRESS, *PIP_ADDRESS, IP_MASK, *PIP_MASK;

//
// IP_ADDRESS_STRING - store an IP address as a dotted decimal string
//

typedef struct {
    char String[4 * 4];
} IP_ADDRESS_STRING, *PIP_ADDRESS_STRING, IP_MASK_STRING, *PIP_MASK_STRING;

//
// IP_ADDR_STRING - store an IP address with its corresponding subnet mask,
// both as dotted decimal strings
//

typedef struct _IP_ADDR_STRING {
    struct _IP_ADDR_STRING* Next;
    IP_ADDRESS_STRING IpAddress;
    IP_MASK_STRING IpMask;
    DWORD Context;
} IP_ADDR_STRING, *PIP_ADDR_STRING;

//
// ADAPTER_INFO - per-adapter information. All IP addresses are stored as
// strings
//
#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arb.
#define MAX_ADAPTER_NAME_LENGTH         32  // arb.
#define MAX_ALLOWED_ADAPTER_NAME_LENGTH (MAX_ADAPTER_NAME_LENGTH + 256)
#define MAX_ADAPTER_ADDRESS_LENGTH      8   // arb.
#define DEFAULT_MINIMUM_ENTITIES        MAX_TDI_ENTITIES // arb.
#define MAX_HOSTNAME_LEN                64  // arb.
#define MAX_DOMAIN_NAME_LEN             64  // arb.
#define MAX_SCOPE_ID_LEN                64  // arb.

typedef struct _ADAPTER_INFO {
    struct _ADAPTER_INFO* Next;
    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 1];
    char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
    UINT AddressLength;
    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
    UINT Index;
    UINT Type;
    UINT DhcpEnabled;
    UINT NodeType;
    IP_ADDR_STRING IpAddressList;
    IP_ADDR_STRING GatewayList;
    IP_ADDR_STRING DhcpServer;
    BOOL HaveWins;
    IP_ADDR_STRING PrimaryWinsServer;
    IP_ADDR_STRING SecondaryWinsServer;
//    time_t LeaseObtained;
//    time_t LeaseExpires;
} ADAPTER_INFO, *PADAPTER_INFO;

//
// FIXED_INFO - the set of IP-related information which does not depend on DHCP
//

typedef struct {
    char HostName[MAX_HOSTNAME_LEN + 1];
    char DomainName[MAX_DOMAIN_NAME_LEN + 1];
    IP_ADDR_STRING DnsServerList;
    UINT NodeType;
    char ScopeId[MAX_SCOPE_ID_LEN + 1];
    UINT EnableRouting;
    UINT EnableProxy;
    UINT EnableDns;
} FIXED_INFO, *PFIXED_INFO;

//
// DHCP_ADAPTER_INFO - the information returned from DHCP VxD per adapter
//

typedef struct {
    DWORD LeaseObtained;
    DWORD LeaseExpires;
    DWORD DhcpServerIpAddress;
    UINT NumberOfDnsServers;
    LPDWORD DnsServerIpAddressList;
} DHCP_ADAPTER_INFO, *PDHCP_ADAPTER_INFO;

//
// PHYSICAL_ADAPTER_ADDRESS - structure describing physical adapter
//

typedef struct {
    UINT AddressLength;
    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
} PHYSICAL_ADAPTER_ADDRESS, *PPHYSICAL_ADAPTER_ADDRESS;

//
// DHCP_ADAPTER_LIST - list of physical adapters known to DHCP, and therefore
// DHCP-enabled
//

typedef struct {
    UINT NumberOfAdapters;
    PHYSICAL_ADAPTER_ADDRESS * AdapterList;
} DHCP_ADAPTER_LIST, *PDHCP_ADAPTER_LIST;

PADAPTER_INFO
GetAdapterInfo(
    VOID
    );

VOID
DeleteAdapterInfo(
    IN PADAPTER_INFO AdapterInfo
    );

DWORD
BuildIpTdiAddress(
    IN  LPWSTR    Address,
    IN  LPWSTR    Endpoint,
    OUT PVOID *   TdiAddress,
    OUT PULONG    TdiAddressLength
    );

#define DeleteIpTdiAddress(_addr)  LocalFree(_addr)

//
// Validate network name
//
typedef enum _CLRTL_NAME_STATUS {
    NetNameOk,
    NetNameEmpty,
    NetNameTooLong,
    NetNameInvalidChars,
    NetNameInUse
} CLRTL_NAME_STATUS;

BOOL
ClRtlIsNetNameValid(
    IN LPCWSTR NetName,
    OUT OPTIONAL CLRTL_NAME_STATUS *Result,
    IN BOOL CheckIfExists
    );


//
// Security related routines
//
LONG
MapSAToRpcSA(
    IN LPSECURITY_ATTRIBUTES lpSA,
    IN OUT struct _RPC_SECURITY_ATTRIBUTES *pRpcSA
    );

LONG
MapSDToRpcSD(
    IN PSECURITY_DESCRIPTOR lpSD,
    IN OUT struct _RPC_SECURITY_DESCRIPTOR *pRpcSD
    );

DWORD
ClRtlSetObjSecurityInfo(
    IN HANDLE           hObject,
    IN SE_OBJECT_TYPE   SeObjType,
    IN DWORD            dwAdminMask,
    IN DWORD            dwOwnerMask,
    IN DWORD            dwEveryOneMask
    );

//
// OS checker
//
DWORD
GetServicePack(
    VOID
    );

BOOL
ClRtlIsOSValid(
    VOID
    );

BOOL
ClRtlIsOSTypeValid(
    VOID
    );

//
// A few MULTI_SZ string manipulation routines
//
DWORD
ClRtlMultiSzAppend(
    IN OUT LPWSTR *MultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    );

DWORD
ClRtlMultiSzRemove(
    IN LPWSTR lpszMultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    );

LPCWSTR
ClRtlMultiSzEnum(
    IN LPCWSTR MszString,
    IN DWORD   MszStringLength,
    IN DWORD   StringIndex
    );

DWORD
ClRtlMultiSzLength(
    IN LPCWSTR lpszMultiSz
    );

LPCWSTR
ClRtlMultiSzScan(
    IN LPCWSTR lpszMultiSz,
    IN LPCWSTR lpszString
    );

DWORD
ClRtlCreateDirectory(
    IN LPCWSTR lpszPath
    );


typedef LONG (*PFNCLRTLCREATEKEY)(
    IN PVOID RegistryKey,
    IN LPCWSTR lpszSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PVOID * phkResult,
    OUT OPTIONAL LPDWORD lpdwDisposition
    );

typedef LONG (*PFNCLRTLOPENKEY)(
    IN PVOID RegistryKey,
    IN LPCWSTR lpszSubKey,
    IN REGSAM samDesired,
    OUT PVOID * phkResult
    );

typedef LONG (*PFNCLRTLCLOSEKEY)(
    IN PVOID RegistryKey
    );

typedef LONG (*PFNCLRTLENUMVALUE)(
    IN PVOID RegistryKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpszValueName,
    IN OUT LPDWORD lpcbValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

typedef LONG (*PFNCLRTLSETVALUE)(
    IN PVOID RegistryKey,
    IN LPCWSTR lpszValueName,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    );

typedef LONG (*PFNCLRTLQUERYVALUE)(
    IN PVOID RegistryKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

typedef struct _CLUSTER_REG_APIS {
    PFNCLRTLCREATEKEY   pfnCreateKey;
    PFNCLRTLOPENKEY     pfnOpenKey;
    PFNCLRTLCLOSEKEY    pfnCloseKey;
    PFNCLRTLSETVALUE    pfnSetValue;
    PFNCLRTLQUERYVALUE  pfnQueryValue;
    PFNCLRTLENUMVALUE   pfnEnumValue;
} CLUSTER_REG_APIS, *PCLUSTER_REG_APIS;

DWORD
WINAPI
ClRtlEnumProperties(
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
ClRtlGetProperties(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
ClRtlGetPrivateProperties(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
ClRtlGetPropertySize(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM Property,
    IN OUT LPDWORD BufferSize,
    IN OUT LPDWORD ItemCount
    );

DWORD
WINAPI
ClRtlGetProperty(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM Property,
    OUT PVOID * OutBuffer,
    IN OUT LPDWORD OutBufferSize
    );

DWORD
WINAPI
ClRtlpSetPropertyTable(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN PVOID Reserved,
    IN BOOL AllowUnknownProperties,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT OPTIONAL LPBYTE OutParams
    );

DWORD
WINAPI
ClRtlSetPropertyParameterBlock(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE InParams,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT OPTIONAL LPBYTE OutParams
    );

DWORD
WINAPI
ClRtlGetAllProperties(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
ClRtlGetPropertiesToParameterBlock(
    IN HKEY RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN OUT LPBYTE OutParams,
    IN BOOL CheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * NameOfPropInError
    );

DWORD
WINAPI
ClRtlPropertyListFromParameterBlock(
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    OUT PVOID * OutBuffer,
    IN OUT LPDWORD OutBufferSize,
    IN const LPBYTE InParams,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
ClRtlGetUnknownProperties(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
ClRtlAddUnknownProperties(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    IN OUT LPDWORD BytesReturned,
    IN OUT LPDWORD Required
    );

DWORD
WINAPI
ClRtlFindProperty(
    IN const PVOID Buffer,
    IN DWORD BufferSize,
    IN LPCWSTR PropName,
    OUT LPDWORD Type
    );

DWORD
WINAPI
ClRtlFindSzProperty(
    IN const PVOID Buffer,
    IN DWORD BufferSize,
    IN LPCWSTR PropName,
    OUT LPWSTR *FoundString
    );

DWORD
WINAPI
ClRtlFindDwordProperty(
    IN const PVOID Buffer,
    IN DWORD BufferSize,
    IN LPCWSTR PropName,
    OUT LPDWORD FoundDword
    );

__inline
DWORD
WINAPI
ClRtlVerifyPropertyTable(
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN PVOID Reserved,
    IN BOOL AllowUnknownProperties,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT OPTIONAL LPBYTE OutParams
    )
{
    return ClRtlpSetPropertyTable(NULL, NULL, PropertyTable, Reserved, AllowUnknownProperties, InBuffer, InBufferSize, OutParams);
}

__inline
DWORD
WINAPI
ClRtlSetPropertyTable(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN PVOID Reserved,
    IN BOOL AllowUnknownProperties,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT OPTIONAL LPBYTE OutParams
    )
{
    if ( (RegistryKey == NULL) ||
         (pClusterRegApis == NULL) ){
        return(ERROR_BAD_ARGUMENTS);
    }
    return ClRtlpSetPropertyTable(RegistryKey, pClusterRegApis, PropertyTable, Reserved, AllowUnknownProperties, InBuffer, InBufferSize, OutParams);
}

DWORD
WINAPI
ClRtlpSetPrivatePropertyList(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize
    );

__inline
DWORD
WINAPI
ClRtlVerifyPrivatePropertyList(
    IN const PVOID InBuffer,
    IN DWORD InBufferSize
    )
{
    return ClRtlpSetPrivatePropertyList(NULL, NULL, InBuffer, InBufferSize);
}

__inline
DWORD
WINAPI
ClRtlSetPrivatePropertyList(
    IN PVOID RegistryKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize
    )
{
    if ( (RegistryKey == NULL) ||
         (pClusterRegApis == NULL) ){
        return(ERROR_BAD_ARGUMENTS);
    }
    return ClRtlpSetPrivatePropertyList(RegistryKey, pClusterRegApis, InBuffer, InBufferSize);
}

DWORD
WINAPI
ClRtlGetBinaryValue(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName,
    OUT LPBYTE * OutValue,
    OUT LPDWORD OutValueSize,
    IN PFNCLRTLQUERYVALUE pfnQueryValue
    );

LPWSTR
WINAPI
ClRtlGetSzValue(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName,
    IN PFNCLRTLQUERYVALUE pfnQueryValue
    );

DWORD
WINAPI
ClRtlDupParameterBlock(
    OUT LPBYTE OutParams,
    IN const LPBYTE InParams,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable
    );

void
WINAPI
ClRtlFreeParameterBlock(
    OUT LPBYTE OutParams,
    IN const LPBYTE InParams,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable
    );


//
// Miscellaneous Routines
//
LPWSTR
ClRtlMakeGuid(
    VOID
    );


#ifdef __cplusplus
}
#endif


#endif // ifndef _CLUSRTL_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\cluster.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cluster.h

Abstract:

    Top-level include file for all user-mode components in the cluster
    project.

Author:

    John Vert (jvert) 30-Nov-1995

Revision History:


Environment:

    User-mode only.

--*/

#ifndef _CLUSTER_H
#define _CLUSTER_H


#include "resapi.h"
#include "clusdef.h"
#include "clusudef.h"
#include "clusrtl.h"
#include "clusapi.h"
#include "clusmsg.h"


//
// Global Debugging Definitions
//
// Removed comment requiring this to be "#if DBG"
// after verifying that this code isn't used anywhere.
// I am not removing it just to be safe.
// EBK - 5/8/2000 Whistler bug # 83160
#if 1  

#define CL_SIG_FIELD                  DWORD    Signature;
#define CL_INIT_SIG(pstruct, sig)     ( (pstruct)->Signature = (sig) )
#define CL_ASSERT_SIG(pstruct, sig)   CL_ASSERT((pstruct)->Signature == (sig))

#else // DBG

#define CL_SIG_FIELD
#define CL_INIT_SIG(pstruct, sig)
#define CL_ASSERT_SIG(pstruct, sig)

#endif // DBG

#endif //_CLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\cluswiz.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cluswiz.h

Abstract:

    Public header file for NT Cluster Wizards

Author:

    John Vert (jvert) 6/17/1996

Revision History:

--*/
#ifndef _CLUSTER_WIZ_
#define _CLUSTER_WIZ_

#ifdef __cplusplus
extern "C" {
#endif

typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;


BOOL WINAPI
ClusterWizInit(
    VOID
    );

LPHPROPSHEETPAGE WINAPI
ClusterWizGetServerPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
ClusterWizGetAdminPages(
    LPDWORD PageCount
    );

#ifdef __cplusplus
}
#endif

#endif // _CLUSTER_API_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusvmsg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    clusmsg.h

Abstract:

    This file contains the message definitions for the cluster manager.

Author:

    Mike Massa (mikemas) 2-Jan-1996

Revision History:

Notes:

    This file is generated from clusmsg.mc

--*/

#ifndef _CLUS_MSG_
#define _CLUS_MSG_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: UNEXPECTED_FATAL_ERROR
//
// MessageText:
//
//  The Cluster Service suffered an unexpected fatal error
//  at line %1 of file %2. The error code was %3.
//
#define UNEXPECTED_FATAL_ERROR           0x000003E8L

//
// MessageId: ASSERTION_FAILURE
//
// MessageText:
//
//  The Cluster Service failed a validity check on line
//  %1 of file %2.
//  "%3"
//
#define ASSERTION_FAILURE                0x000003E9L

//
// MessageId: LOG_FAILURE
//
// MessageText:
//
//  The Cluster Service handled an unexpected error
//  at line %1 of file %2. The error code was %3.
//
#define LOG_FAILURE                      0x000003EAL

//
// MessageId: INVALID_RESOURCETYPE_DLLNAME
//
// MessageText:
//
//  The DllName value for the %1!ws! resource type key does not exist.
//  Resources of this type will not be monitored. The error was %2!d!.
//
#define INVALID_RESOURCETYPE_DLLNAME     0x000003EBL

//
// MessageId: INVALID_RESOURCETYPE_LOOKSALIVE
//
// MessageText:
//
//  The LooksAlive poll interval for the %1!ws! resource type key does not exist.
//  Resources of this type will not be monitored. The error was %2!d!.
//
#define INVALID_RESOURCETYPE_LOOKSALIVE  0x000003ECL

//
// MessageId: INVALID_RESOURCETYPE_ISALIVE
//
// MessageText:
//
//  The IsAlive poll interval for the %1!ws! resource type key does not exist.
//  Resources of this type will not be monitored. The error was %2!d!.
//
#define INVALID_RESOURCETYPE_ISALIVE     0x000003EDL

//
// MessageId: NM_EVENT_HALT
//
// MessageText:
//
//  The Windows NT Cluster Service was halted due to a regroup error or poison
//  packet.
//
#define NM_EVENT_HALT                    0x000003EEL

//
// MessageId: NM_EVENT_NEW_NODE
//
// MessageText:
//
//  A new node, %1, has been added to the cluster.
//
#define NM_EVENT_NEW_NODE                0x000003EFL

//
// MessageId: RMON_INVALID_COMMAND_LINE
//
// MessageText:
//
//  The Cluster Resource Monitor was started with the invalid
//  command line %1.
//
#define RMON_INVALID_COMMAND_LINE        0x000003F0L

//
// MessageId: SERVICE_FAILED_JOIN_OR_FORM
//
// MessageText:
//
//  The Cluster Service could not join an existing cluster and could not form
//  a new cluster. The Cluster Service has terminated.
//
#define SERVICE_FAILED_JOIN_OR_FORM      0x000003F1L

//
// MessageId: SERVICE_FAILED_NOT_MEMBER
//
// MessageText:
//
//  The Cluster Service is shutting down because the current node is not a
//  member of any cluster. Windows NT Clusters must be reinstalled to make
//  this node a member of a cluster.
//
#define SERVICE_FAILED_NOT_MEMBER        0x000003F2L

//
// MessageId: NM_NODE_EVICTED
//
// MessageText:
//
//  Cluster Node %1 has been evicted from the cluster.
//
#define NM_NODE_EVICTED                  0x000003F3L

//
// MessageId: SERVICE_FAILED_INVALID_OS
//
// MessageText:
//
//  The Cluster Service did not start because the current version of Windows
//  NT is not correct. This beta only runs on Windows NT Server 4.0 (build 1381)
//  with SP2 RC1.3
//
#define SERVICE_FAILED_INVALID_OS        0x000003F4L

//
// MessageId: ERROR_LOG_QUORUM_ONLINEFAILED
//
// MessageText:
//
//  The quorum resource failed to come online.
//
#define ERROR_LOG_QUORUM_ONLINEFAILED    0x000003F5L

//
// MessageId: ERROR_LOG_FILE_OPENFAILED
//
// MessageText:
//
//  The quorum log file couldnt be opened.
//
#define ERROR_LOG_FILE_OPENFAILED        0x000003F6L

//
// MessageId: ERROR_LOG_CHKPOINT_UPLOADFAILED
//
// MessageText:
//
//  The checkpoint could not be uploaded.
//
#define ERROR_LOG_CHKPOINT_UPLOADFAILED  0x000003F7L

//
// MessageId: ERROR_QUORUM_RESOURCE_NOTFOUND
//
// MessageText:
//
//  The quorum resource was not found.
//
#define ERROR_QUORUM_RESOURCE_NOTFOUND   0x000003F8L

//
// MessageId: ERROR_LOG_NOCHKPOINT
//
// MessageText:
//
//  No checkpoint record was found in the log file.
//
#define ERROR_LOG_NOCHKPOINT             0x000003F9L

//
// MessageId: ERROR_LOG_CHKPOINT_GETFAILED
//
// MessageText:
//
//  Failed to obtain a checkpoint.
//
#define ERROR_LOG_CHKPOINT_GETFAILED     0x000003FAL

//
// MessageId: ERROR_LOG_EXCEEDS_MAXSIZE
//
// MessageText:
//
//  The log file exceeds its maximum size,  will be reset.
//
#define ERROR_LOG_EXCEEDS_MAXSIZE        0x000003FBL

//
// MessageId: CS_COMMAND_LINE_HELP
//
// MessageText:
//
//  The Cluster Service can be started from the Services applet in the Control
//  Panel or by issuing the command "net start clussvc" at a command prompt.
//
#define CS_COMMAND_LINE_HELP             0x000003FCL

//
// MessageId: ERROR_LOG_CORRUPT
//
// MessageText:
//
//  The Quorum log file is corrupt.
//
#define ERROR_LOG_CORRUPT                0x000003FDL

//
// MessageId: ERROR_QUORUMOFFLINE_DENIED
//
// MessageText:
//
//  The Quorum resource cannot be brought offline.
//
#define ERROR_QUORUMOFFLINE_DENIED       0x000003FEL

//
// MessageId: ERROR_LOG_EXCEEDS_MAXRECORDSIZE
//
// MessageText:
//
//  A log record wasnt logged in the quorum log file since its size exceeded the 
//  permitted maximum size.
//
#define ERROR_LOG_EXCEEDS_MAXRECORDSIZE  0x000003FFL

#endif // _CLUS_MSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusverp.h ===
/****************************************************************************
 *                                                                          *
 *      clusverp.H        -- Version information for cluster builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*                                                              */
/* the VER_PRODUCTBUILD lines must contain the product          */
/* comments (Win9x or NT) and end with the build#<CR><LF>       */
/*                                                              */
/* the VER_PRODUCTBETA_STR lines must contain the product       */
/* comments (Win9x or NT) and end with "some string"<CR><LF>    */
/*--------------------------------------------------------------*/

#define VER_PRODUCTBUILD_QFE        0
#define BETA 1

#define VER_PRODUCTBUILD	    /* NT */	 169
#define VER_PRODUCTBETA_STR         /* NT */     ""
#define VER_PRODUCTVERSION_STRING   "1.00"
#define VER_PRODUCTVERSION          1,00,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0100)
#define VER_PRODUCTVERSION_DW       (0x01000000 | VER_PRODUCTBUILD)

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft(R) Cluster Server"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows NT(TM) is a trademark of Microsoft Corporation."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\cluxport.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cluxport.h

Abstract:

    Cluster Transport public interface definition.

Author:

    Mike Massa (mikemas) 18-April-1996


Revision History:

--*/


#ifndef _CX_INCLUDED
#define _CX_INCLUDED


//
// Removed comment to make these official.  This file 
// does not appear to be being used.  Nor do these 
// constants.  They are being left in only to avoid any
// unexpected breaking issues.
// EBK - 5/8/2000 Whistler bug # 83162

#define   CX_ERROR_BASE   13000

#define   ERROR_INCOMPATIBLE_TRANSPORT_VERSION    (CX_ERROR_BASE + 1)
#define   ERROR_OBJECT_NAME_NOT_FOUND             (CX_ERROR_BASE + 2)
#define   ERROR_NODE_NOT_FOUND                    (CX_ERROR_BASE + 3)

//
//
// Constants
//
//


//
//
// Types
//
//
typedef
VOID
(*CX_NODE_FAILURE_HANDLER)(
    IN CL_NODE_ID  NodeId,
    IN LPVOID      NodeFailureContext
    );

typedef
VOID
(*CX_DATAGRAM_RECEIVE_HANDLER)(
    IN CL_NODE_ID  SourceNode,
    IN LPVOID      Data,
    IN DWORD       DataLength
    );

typedef struct {
    CX_NODE_FAILURE_HANDLER  NodeFailureHandler;
    LPVOID                   NodeFailureContext;
} CX_INIT_INFO, *PCX_INIT_INFO;

typedef struct {
    LPWSTR   RpcProtSeq;
    LPWSTR   RpcClientProviderDll;
    LPWSTR   RpcServerProviderDll;
} CX_TRANSPORT_INFO, *PCX_TRANSPORT_INFO;;

typedef enum {
    CxPublicInterconnect,
    CxPrivateInterconnect
} CX_INTERCONNECT_TYPE;

typedef struct {
    LPWSTR                  InterconnectName;
    CX_INTERCONNECT_TYPE    Type;
    LPWSTR                  AdapterName;
    LPWSTR                  TransportName;
} CX_INTERCONNECT_INFO, *PCX_INTERCONNECT_INFO;

typedef struct {
    LPWSTR        InterfaceName;
    LPWSTR        InterconnectName;
    LPWSTR        TransportName;
    LPWSTR        AddressName;
} CX_INTERFACE_INFO, *PCX_INTERFACE_INFO;


//
//
// Routines
//
//
DWORD
CxInitialize(
    IN PCX_INIT_INFO   InitInfo
    );

VOID
CxShutdown(
    VOID
    );

DWORD
CxRegisterTransport(
    IN LPWSTR                TransportName,
    IN PCX_TRANSPORT_INFO    TransportInfo
    );

DWORD
CxDeregisterTransport(
    IN LPWSTR  TransportName
    );

VOID
CxDeregisterAllTransports(
    IN VOID
    );

DWORD
CxRegisterInterconnect(
    IN PCX_INTERCONNECT_INFO   InterconnectInfo
    );

DWORD
CxDeregisterInterconnect(
    IN LPWSTR  InterconnectName
    );

VOID
CxDeregisterAllInterconnects(
    VOID
    );

DWORD
CxEnumInterconnects(
    IN OUT PCX_INTERCONNECT_INFO InterconnectInfo,
    IN OUT LPDWORD               InterconnectInfoSize,
    OUT    LPDWORD               InterconnectCount
    );

DWORD
CxRegisterNode(
    IN LPWSTR      NodeName,
    IN CL_NODE_ID  NodeId
    );

DWORD
CxDeregisterNode(
    IN CL_NODE_ID  NodeId
    );

VOID
CxDeregisterAllNodes(
    VOID
    );

DWORD
CxRegisterInterface(
    IN LPWSTR      InterfaceName,
    IN CL_NODE_ID  NodeId,
    IN LPWSTR      InterconnectName,
    IN LPWSTR      TransportName,
    IN LPWSTR      InterfaceAddress
    );

DWORD
CxDeregisterInterface(
    IN LPWSTR      InterfaceName,
    IN CL_NODE_ID  NodeId
    );

DWORD
CxEnumInterfaces(
    IN CL_NODE_ID             NodeId,
    IN OUT PCX_INTERFACE_INFO InterfaceInfo,
    IN OUT LPDWORD            InterfaceInfoSize,
    OUT    LPDWORD            InterfaceCount
    );

DWORD
CxDestroyNodeInterfaces(
    IN CL_NODE_ID          NodeId
    );

DWORD
CxLoadTransports(
    VOID
    );

VOID
CxUnloadTransports(
    VOID
    );

DWORD
CxChangeNodeState(
    IN CL_NODE_ID          NodeId,
    IN CLUSTER_NODE_STATE  NewState
    );

CLUSTER_NODE_STATE
CxGetNodeState(
    IN CL_NODE_ID          NodeId
    );

HANDLE
CxOpenDatagramEndpoint(
    IN LPWSTR                       EndpointName,
    IN CX_DATAGRAM_RECEIVE_HANDLER  ReceiveHandler,
    IN DWORD                        MaximumDatagramSize
    );

VOID
CxCloseDatagramEndpoint(
    IN HANDLE EndpointHandle
    );

HANDLE
CxOpenDatagramAddress(
    IN CL_NODE_ID  NodeId,
    IN LPWSTR      EndpointName
    );

VOID
CxCloseDatagramAddress(
    IN HANDLE  AddressHandle
    );

DWORD
CxSendDatagram(
    IN HANDLE   LocalEndpoint,
    IN HANDLE   ServerAddress,
    IN LPVOID   Data,
    IN DWORD    DataLength
    );


#endif  // _CX_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\clusudef.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    clusudef.h

Abstract:

    This module contains definitions of constants used across
    multiple user-mode targets in the cluster project.

Revision History:


Environment:

    User-mode only.

--*/

#ifndef _CLUSUDEF_H_
#define _CLUSUDEF_H_

//
// Default group property definitions
//
#define CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD    10
#define CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD       6
#define CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE    ClusterGroupPreventFailback
#define CLUSTER_GROUP_FAILBACK_WINDOW_NONE          ((DWORD) -1)
#define CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END   CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_DEFAULT_LOADBAL_STATE         1

//
// Default resource property definitions
//
#define CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL  ((DWORD) -1)
#define CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE        CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL
#define CLUSTER_RESOURCE_DEFAULT_IS_ALIVE           CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL
#define CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION     ClusterResourceRestartNotify
#define CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD  3
#define CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD     (900 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT    (3 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_STARTUP    (5 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_SAMPLE     (    10 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_ANALYSIS   (5 * 60 * 1000)

//
// Default resource type property definitions
//
#define CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE     (5 * 1000)
#define CLUSTER_RESTYPE_DEFAULT_IS_ALIVE        (60 * 1000)
#define CLUSTER_RESTYPE_DEFAULT_QUORUM_CAPABLE  FALSE

//
// Default quorum definitions
//
#define CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE     64 * 1024  // 64K
#define CLUSTER_QUORUM_MIN_LOG_SIZE             32 * 1024 //32 K

//
// Key, value, and property names
//
#define CLUSREG_KEYNAME_GROUPS              L"Groups"
#define CLUSREG_KEYNAME_NETWORKS            L"Networks"
#define CLUSREG_KEYNAME_NETINTERFACES       L"NetworkInterfaces"
#define CLUSREG_KEYNAME_NODES               L"Nodes"
#define CLUSREG_KEYNAME_QUORUM              L"Quorum"
#define CLUSREG_KEYNAME_RESOURCES           L"Resources"
#define CLUSREG_KEYNAME_RESOURCE_TYPES      L"ResourceTypes"
#define CLUSREG_KEYNAME_PARAMETERS          L"Parameters"

#define CLUSREG_NAME_CHARACTERISTICS        L"Characteristics"
#define CLUSREG_NAME_FLAGS                  L"Flags"
#define CLUSREG_NAME_ADMIN_EXT              L"AdminExtensions"

#define CLUSREG_NAME_CLUS_NAME              L"ClusterName"
#define CLUSREG_NAME_CLUS_DESC              L"Description"
#define CLUSREG_NAME_CLUS_SECURITY          L"Security"
#define CLUSREG_NAME_CLUS_CLUSTER_NAME_RES  L"ClusterNameResource"
#define CLUSREG_NAME_CLUS_REG_SEQUENCE      L"RegistrySequence"

#define CLUSREG_NAME_NODE_NAME              L"NodeName"
#define CLUSREG_NAME_NODE_DESC              L"Description"
#define CLUSREG_NAME_NODE_PAUSED            L"Paused"

#define CLUSREG_NAME_GRP_NAME               L"Name"
#define CLUSREG_NAME_GRP_DESC               L"Description"
#define CLUSREG_NAME_GRP_PERSISTENT_STATE   L"PersistentState"
#define CLUSREG_NAME_GRP_FAILBACK_TYPE      L"AutoFailbackType"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_START L"FailbackWindowStart"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_END   L"FailbackWindowEnd"
#define CLUSREG_NAME_GRP_FAILOVER_THRESHOLD L"FailoverThreshold"
#define CLUSREG_NAME_GRP_FAILOVER_PERIOD    L"FailoverPeriod"
#define CLUSREG_NAME_GRP_PREFERRED_OWNERS   L"PreferredOwners"
#define CLUSREG_NAME_GRP_CONTAINS           L"Contains"
#define CLUSREG_NAME_GRP_LOADBAL_STATE      L"LoadBalState"

#define CLUSREG_NAME_RES_NAME               L"Name"
#define CLUSREG_NAME_RES_TYPE               L"Type"
#define CLUSREG_NAME_RES_DESC               L"Description"
#define CLUSREG_NAME_RES_DEBUG_PREFIX       L"DebugPrefix"
#define CLUSREG_NAME_RES_SEPARATE_MONITOR   L"SeparateMonitor"
#define CLUSREG_NAME_RES_PERSISTENT_STATE   L"PersistentState"
#define CLUSREG_NAME_RES_LOOKS_ALIVE        L"LooksAlivePollInterval"
#define CLUSREG_NAME_RES_IS_ALIVE           L"IsAlivePollInterval"
#define CLUSREG_NAME_RES_RESTART_ACTION     L"RestartAction"
#define CLUSREG_NAME_RES_RESTART_THRESHOLD  L"RestartThreshold"
#define CLUSREG_NAME_RES_RESTART_PERIOD     L"RestartPeriod"
#define CLUSREG_NAME_RES_PENDING_TIMEOUT    L"PendingTimeout"
#define CLUSREG_NAME_RES_POSSIBLE_OWNERS    L"PossibleOwners"
#define CLUSREG_NAME_RES_DEPENDS_ON         L"DependsOn"
#define CLUSREG_NAME_RES_LOADBAL_STARTUP    L"LoadBalStartupInterval"
#define CLUSREG_NAME_RES_LOADBAL_SAMPLE     L"LoadBalSampleInterval"
#define CLUSREG_NAME_RES_LOADBAL_ANALYSIS   L"LoadBalAnalysisInterval"
#define CLUSREG_NAME_RES_LOADBAL_PROCESSOR  L"LoadBalMinProcessorUnits"
#define CLUSREG_NAME_RES_LOADBAL_MEMORY     L"LoadBalMinMemoryUnits"

#define CLUSREG_NAME_RESTYPE_NAME           L"Name"
#define CLUSREG_NAME_RESTYPE_DESC           L"Description"
#define CLUSREG_NAME_RESTYPE_LOOKS_ALIVE    L"LooksAlivePollInterval"
#define CLUSREG_NAME_RESTYPE_IS_ALIVE       L"IsAlivePollInterval"
#define CLUSREG_NAME_RESTYPE_DLL_NAME       L"DllName"
#define CLUSREG_NAME_RESTYPE_DEBUG_PREFIX   L"DebugPrefix"

#define CLUSREG_NAME_NET_NAME               L"Name"
#define CLUSREG_NAME_NET_DESC               L"Description"
#define CLUSREG_NAME_NET_ROLE               L"Role"
#define CLUSREG_NAME_NET_PRIORITY           L"Priority"
#define CLUSREG_NAME_NET_TRANSPORT          L"Transport"
#define CLUSREG_NAME_NET_ADDRESS            L"Address"
#define CLUSREG_NAME_NET_ADDRESS_MASK       L"AddressMask"

#define CLUSREG_NAME_NETIFACE_NAME          L"Name"
#define CLUSREG_NAME_NETIFACE_DESC          L"Description"
#define CLUSREG_NAME_NETIFACE_NODE          L"Node"
#define CLUSREG_NAME_NETIFACE_NETWORK       L"Network"
#define CLUSREG_NAME_NETIFACE_ADAPTER       L"Adapter"
#define CLUSREG_NAME_NETIFACE_ADDRESS       L"Address"
#define CLUSREG_NAME_NETIFACE_ENDPOINT      L"ClusnetEndpoint"

#define CLUSREG_NAME_QUORUM_RESOURCE        L"Resource"
#define CLUSREG_NAME_QUORUM_PATH            L"Path"
#define CLUSREG_NAME_QUORUM_MAX_LOG_SIZE    L"MaxQuorumLogSize"

#define CLUSREG_NAME_PROXY_RETRY_COUNT      L"RetryCount"
#define CLUSREG_NAME_PROXY_RETRY_INTERVAL   L"RetryInterval"

//
// Standard Resource Type Names
//
#define CLUS_RESTYPE_NAME_GENAPP    L"Generic Application"
#define CLUS_RESTYPE_NAME_GENSVC    L"Generic Service"
#define CLUS_RESTYPE_NAME_FTSET     L"Fault Tolerant Disk Set"
#define CLUS_RESTYPE_NAME_PHYS_DISK L"Physical Disk"
#define CLUS_RESTYPE_NAME_IPADDR    L"IP Address"
#define CLUS_RESTYPE_NAME_NETNAME   L"Network Name"
#define CLUS_RESTYPE_NAME_FILESHR   L"File Share"
#define CLUS_RESTYPE_NAME_PRTSPLR   L"Print Spooler"
#define CLUS_RESTYPE_NAME_TIMESVC   L"Time Service"
#define CLUS_RESTYPE_NAME_LKQUORUM  L"Local Quorum"
#define CLUS_RESTYPE_NAME_DHCP      L"DHCP Server"
#define CLUS_RESTYPE_NAME_MSMQ      L"Microsoft Message Queue Server"
#define CLUS_RESTYPE_NAME_MSDTC     L"Distributed Transaction Coordinator"


#define CLUS_NAME_DEFAULT_FILESPATH L"MSCS\\"

#endif // _CLUSUDEF_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 <company name>
//
//	Module Name:
//		ExtObj.h
//
//	Abstract:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_OBJECT_TYPE and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"	// for CLSID_CoSmbSmpEx
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;
	HKEY					m_hkey;

	virtual ~CObjData(void) { }

};  //*** class CObjData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

	virtual ~CResData(void) { }

};  //*** class CResData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoSmbSmpEx>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(IWEExtendWizard)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.SmbSmpEx"), _T("CLUADMEX.SmbSmpEx"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD(CreateWizardPages)(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterUIInfo data
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;

	// IGetClusterDataInfo data
	HCLUSTER					m_hcluster;
	HKEY						m_hkeyCluster;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW(void) const		{ return m_podObjData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) m_podObjData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback(void) const	{ return m_piWizardCallback; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterUIInfo data
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }

	// IGetClusterDataInfo data
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	HKEY						HkeyCluster(void) const			{ return m_hkeyCluster; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CObjData *			PodObjData(void) const			{ return m_podObjData; }
	const CResData *			PrdResData(void) const			{ return (CResData *) m_podObjData; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\cnetapi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnetapi.h

Abstract:

    Cluster Network driver control APIs

Author:

    Mike Massa (mikemas)  14-Feb-1997

Environment:

    User Mode.

Revision History:

--*/


#ifndef _CNETAPI_INCLUDED
#define _CNETAPI_INCLUDED


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Join Phases
//

typedef enum {
    ClusnetJoinPhase1 = 1,
    ClusnetJoinPhase2 = 2,
    ClusnetJoinPhase3 = 3,
    ClusnetJoinPhase4 = 4,
    ClusnetJoinPhaseAbort = 0xFFFFFFFF
}  CLUSNET_JOIN_PHASE;


//
// Event Handler Routines.
//
typedef
VOID
(*CLUSNET_NODE_UP_ROUTINE)(
    IN CL_NODE_ID   NodeId
    );

typedef
VOID
(*CLUSNET_NODE_DOWN_ROUTINE)(
    IN CL_NODE_ID   NodeId
    );

typedef
BOOL
(*CLUSNET_CHECK_QUORUM_ROUTINE)(
    VOID
    );

typedef
VOID
(*CLUSNET_HOLD_IO_ROUTINE)(
    VOID
    );

typedef
VOID
(*CLUSNET_RESUME_IO_ROUTINE)(
    VOID
    );

typedef
VOID
(*CLUSNET_HALT_ROUTINE)(
    IN DWORD HaltCode
    );

//
// Routines
//
HANDLE
ClusnetOpenControlChannel(
    IN ULONG ShareAccess
    );

#define ClusnetCloseControlChannel(_handle)  CloseHandle(_handle)

DWORD
ClusnetEnableShutdownOnClose(
    IN HANDLE  ControlChannel
    );

DWORD
ClusnetDisableShutdownOnClose(
    IN HANDLE  ControlChannel
    );

DWORD
ClusnetInitialize(
    IN HANDLE                             ControlChannel,
    IN CL_NODE_ID                         LocalNodeId,
    IN ULONG                              MaxNodes,
    IN CLUSNET_NODE_UP_ROUTINE            NodeUpRoutine,
    IN CLUSNET_NODE_DOWN_ROUTINE          NodeDownRoutine,
    IN CLUSNET_CHECK_QUORUM_ROUTINE       CheckQuorumRoutine,
    IN CLUSNET_HOLD_IO_ROUTINE            HoldIoRoutine,
    IN CLUSNET_RESUME_IO_ROUTINE          ResumeIoRoutine,
    IN CLUSNET_HALT_ROUTINE               HaltRoutine
    );

DWORD
ClusnetShutdown(
    IN HANDLE       ControlChannel
    );

DWORD
ClusnetRegisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    );

DWORD
ClusnetDeregisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    );

DWORD
ClusnetRegisterNetwork(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority
    );

DWORD
ClusnetDeregisterNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    );

DWORD
ClusnetRegisterInterface(
    IN HANDLE               ControlChannel,
    IN CL_NODE_ID           NodeId,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority,
    IN PVOID                TdiAddress,
    IN ULONG                TdiAddressLength
    );

DWORD
ClusnetDeregisterInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetOnlineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    );

DWORD
ClusnetOfflineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    );

DWORD
ClusnetOnlineNetwork(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN PWCHAR               TdiProviderName,
    IN PVOID                TdiBindAddress,
    IN ULONG                TdiBindAddressLength,
    IN LPWSTR               AdapterName
    );

DWORD
ClusnetOfflineNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    );

DWORD
ClusnetGetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              Priority
    );

DWORD
ClusnetSetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority
    );

DWORD
ClusnetGetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              InterfacePriority,
    OUT PULONG              NetworkPriority
    );

DWORD
ClusnetSetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN CL_NODE_ID           NodeId,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority
    );

DWORD
ClusnetGetNodeCommState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NODE_ID                NodeId,
    OUT PCLUSNET_NODE_COMM_STATE  State
    );

DWORD
ClusnetGetNetworkState(
    IN  HANDLE                  ControlChannel,
    IN  CL_NETWORK_ID           NetworkId,
    OUT PCLUSNET_NETWORK_STATE  State
    );

DWORD
ClusnetGetInterfaceState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NODE_ID                NodeId,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_INTERFACE_STATE  State
    );

#ifdef MM_IN_CLUSNET

DWORD
ClusnetFormCluster(
    IN HANDLE       ControlChannel,
    IN ULONG        ClockPeriod,
    IN ULONG        SendHBRate,
    IN ULONG        RecvHBRate
    );

DWORD
ClusnetJoinCluster(
    IN     HANDLE              ControlChannel,
    IN     CL_NODE_ID          JoiningNodeId,
    IN     CLUSNET_JOIN_PHASE  Phase,
    IN     ULONG               JoinTimeout,
    IN OUT PVOID *             MessageToSend,
    OUT    PULONG              MessageLength,
    OUT    PULONG              DestNodeMask
    );

VOID
ClusnetEndJoinCluster(
    IN HANDLE  ControlChannel,
    IN PVOID   LastSentMessage
    );

DWORD
ClusnetDeliverJoinMessage(
    IN HANDLE  ControlChannel,
    IN PVOID   Message,
    IN ULONG   MessageLength
    );

DWORD
ClusnetLeaveCluster(
    IN HANDLE       ControlChannel
    );

DWORD
ClusnetEvictNode(
    IN HANDLE       ControlChannel,
    IN ULONG        NodeId
    );

#endif // MM_IN_CLUSNET

DWORD
ClusnetGetNodeMembershipState(
    IN  HANDLE ControlChannel,
    IN  ULONG NodeId,
    OUT CLUSNET_NODE_STATE * State
    );

DWORD
ClusnetSetNodeMembershipState(
    IN  HANDLE ControlChannel,
    IN  ULONG NodeId,
    IN  CLUSNET_NODE_STATE State
    );

DWORD
ClusnetSetEventMask(
    IN  HANDLE              ControlChannel,
    IN  CLUSNET_EVENT_TYPE  EventMask
    );

DWORD
ClusnetGetNextEvent(
    IN  HANDLE          ControlChannel,
    OUT PCLUSNET_EVENT  Event,
    IN  LPOVERLAPPED    Overlapped  OPTIONAL
    );

DWORD
ClusnetHalt(
    IN  HANDLE  ControlChannel
    );

DWORD
ClusnetSetMemLogging(
    IN  HANDLE  ControlChannel,
    IN  ULONG   NumberOfEntires
    );

DWORD
ClusnetSendPoisonPacket(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId
    );

DWORD
ClusnetSetOuterscreen(
    IN HANDLE          ControlChannel,
    IN ULONG           Outerscreen
    );

DWORD
ClusnetRegroupFinished(
    IN HANDLE          ControlChannel,
    IN ULONG           NewEpoch
    );

DWORD
ClusnetImportSecurityContexts(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      JoiningNodeId,
    IN PWCHAR          PackageName,
    IN ULONG           SignatureSize,
    IN PVOID           ServerContext,
    IN PVOID           ClientContext
    );

#if DBG

//
// Test routines - available in debug builds only.
//

DWORD
ClusnetSetDebugMask(
    IN HANDLE   ControlChannel,
    ULONG       Mask
    );

DWORD
ClusnetOnlinePendingInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetOnlineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetOfflineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetFailInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetSendMmMsg(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN ULONG           Pattern
    );

#endif // DBG


#ifdef __cplusplus
}
#endif // __cplusplus


#endif  // ndef _CNETAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\msclus.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Aug 08 11:36:24 1997
 */
/* Compiler settings for msclus.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msclus_h__
#define __msclus_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IClusterApplication_FWD_DEFINED__
#define __IClusterApplication_FWD_DEFINED__
typedef interface IClusterApplication IClusterApplication;
#endif 	/* __IClusterApplication_FWD_DEFINED__ */


#ifndef __Domains_FWD_DEFINED__
#define __Domains_FWD_DEFINED__
typedef interface Domains Domains;
#endif 	/* __Domains_FWD_DEFINED__ */


#ifndef __IClusterDomain_FWD_DEFINED__
#define __IClusterDomain_FWD_DEFINED__
typedef interface IClusterDomain IClusterDomain;
#endif 	/* __IClusterDomain_FWD_DEFINED__ */


#ifndef __Clusters_FWD_DEFINED__
#define __Clusters_FWD_DEFINED__
typedef interface Clusters Clusters;
#endif 	/* __Clusters_FWD_DEFINED__ */


#ifndef __ICluster_FWD_DEFINED__
#define __ICluster_FWD_DEFINED__
typedef interface ICluster ICluster;
#endif 	/* __ICluster_FWD_DEFINED__ */


#ifndef __ClusNode_FWD_DEFINED__
#define __ClusNode_FWD_DEFINED__
typedef interface ClusNode ClusNode;
#endif 	/* __ClusNode_FWD_DEFINED__ */


#ifndef __ClusNodes_FWD_DEFINED__
#define __ClusNodes_FWD_DEFINED__
typedef interface ClusNodes ClusNodes;
#endif 	/* __ClusNodes_FWD_DEFINED__ */


#ifndef __ClusResGroup_FWD_DEFINED__
#define __ClusResGroup_FWD_DEFINED__
typedef interface ClusResGroup ClusResGroup;
#endif 	/* __ClusResGroup_FWD_DEFINED__ */


#ifndef __ClusResGroups_FWD_DEFINED__
#define __ClusResGroups_FWD_DEFINED__
typedef interface ClusResGroups ClusResGroups;
#endif 	/* __ClusResGroups_FWD_DEFINED__ */


#ifndef __ClusResource_FWD_DEFINED__
#define __ClusResource_FWD_DEFINED__
typedef interface ClusResource ClusResource;
#endif 	/* __ClusResource_FWD_DEFINED__ */


#ifndef __ClusResources_FWD_DEFINED__
#define __ClusResources_FWD_DEFINED__
typedef interface ClusResources ClusResources;
#endif 	/* __ClusResources_FWD_DEFINED__ */


#ifndef __ClusResType_FWD_DEFINED__
#define __ClusResType_FWD_DEFINED__
typedef interface ClusResType ClusResType;
#endif 	/* __ClusResType_FWD_DEFINED__ */


#ifndef __ClusResTypes_FWD_DEFINED__
#define __ClusResTypes_FWD_DEFINED__
typedef interface ClusResTypes ClusResTypes;
#endif 	/* __ClusResTypes_FWD_DEFINED__ */


#ifndef __ClusProperty_FWD_DEFINED__
#define __ClusProperty_FWD_DEFINED__
typedef interface ClusProperty ClusProperty;
#endif 	/* __ClusProperty_FWD_DEFINED__ */


#ifndef __ClusProperties_FWD_DEFINED__
#define __ClusProperties_FWD_DEFINED__
typedef interface ClusProperties ClusProperties;
#endif 	/* __ClusProperties_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#ifndef _CLUSTER_API_TYPES_
			/* size is 4 */
typedef struct _HCLUSTER __RPC_FAR *HCLUSTER;

			/* size is 4 */
typedef struct _HNODE __RPC_FAR *HNODE;

			/* size is 4 */
typedef struct _HRESOURCE __RPC_FAR *HRESOURCE;

			/* size is 4 */
typedef struct _HGROUP __RPC_FAR *HGROUP;

			/* size is 4 */
typedef struct _HRESTYPE __RPC_FAR *HRESTYPE;

			/* size is 4 */
typedef struct _HNETWORK __RPC_FAR *HNETWORK;

			/* size is 4 */
typedef struct _HNETINTERFACE __RPC_FAR *HNETINTERFACE;

			/* size is 4 */
typedef struct _HCHANGE __RPC_FAR *HCHANGE;

			/* size is 4 */
typedef struct _HCLUSENUM __RPC_FAR *HCLUSENUM;

			/* size is 4 */
typedef struct _HGROUPENUM __RPC_FAR *HGROUPENUM;

			/* size is 4 */
typedef struct _HRESENUM __RPC_FAR *HRESENUM;

			/* size is 4 */
typedef struct _HNETWORKENUM __RPC_FAR *HNETWORKENUM;

			/* size is 4 */
typedef struct _HNODEENUM __RPC_FAR *HNODEENUM;

			/* size is 2 */
typedef 
enum CLUSTER_QUORUM_TYPE
    {	OperationalQuorum	= 0,
	ModifyQuorum	= OperationalQuorum + 1
    }	CLUSTER_QUORUM_TYPE;

			/* size is 2 */
typedef 
enum CLUSTER_CHANGE
    {	CLUSTER_CHANGE_NODE_STATE	= 0x1,
	CLUSTER_CHANGE_NODE_DELETED	= 0x2,
	CLUSTER_CHANGE_NODE_ADDED	= 0x4,
	CLUSTER_CHANGE_NODE_PROPERTY	= 0x8,
	CLUSTER_CHANGE_REGISTRY_NAME	= 0x10,
	CLUSTER_CHANGE_REGISTRY_ATTRIBUTES	= 0x20,
	CLUSTER_CHANGE_REGISTRY_VALUE	= 0x40,
	CLUSTER_CHANGE_REGISTRY_SUBTREE	= 0x80,
	CLUSTER_CHANGE_RESOURCE_STATE	= 0x100,
	CLUSTER_CHANGE_RESOURCE_DELETED	= 0x200,
	CLUSTER_CHANGE_RESOURCE_ADDED	= 0x400,
	CLUSTER_CHANGE_RESOURCE_PROPERTY	= 0x800,
	CLUSTER_CHANGE_GROUP_STATE	= 0x1000,
	CLUSTER_CHANGE_GROUP_DELETED	= 0x2000,
	CLUSTER_CHANGE_GROUP_ADDED	= 0x4000,
	CLUSTER_CHANGE_GROUP_PROPERTY	= 0x8000,
	CLUSTER_CHANGE_RESOURCE_TYPE_DELETED	= 0x10000,
	CLUSTER_CHANGE_RESOURCE_TYPE_ADDED	= 0x20000,
	CLUSTER_CHANGE_NETWORK_STATE	= 0x100000,
	CLUSTER_CHANGE_NETWORK_DELETED	= 0x200000,
	CLUSTER_CHANGE_NETWORK_ADDED	= 0x400000,
	CLUSTER_CHANGE_NETWORK_PROPERTY	= 0x800000,
	CLUSTER_CHANGE_NETINTERFACE_STATE	= 0x1000000,
	CLUSTER_CHANGE_NETINTERFACE_DELETED	= 0x2000000,
	CLUSTER_CHANGE_NETINTERFACE_ADDED	= 0x4000000,
	CLUSTER_CHANGE_NETINTERFACE_PROPERTY	= 0x8000000,
	CLUSTER_CHANGE_QUORUM_STATE	= 0x10000000,
	CLUSTER_CHANGE_CLUSTER_STATE	= 0x20000000,
	CLUSTER_CHANGE_CLUSTER_PROPERTY	= 0x40000000,
	CLUSTER_CHANGE_HANDLE_CLOSE	= 0x80000000,
	CLUSTER_CHANGE_ALL	= CLUSTER_CHANGE_NODE_STATE | CLUSTER_CHANGE_NODE_DELETED | CLUSTER_CHANGE_NODE_ADDED | CLUSTER_CHANGE_NODE_PROPERTY | CLUSTER_CHANGE_REGISTRY_NAME | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES | CLUSTER_CHANGE_REGISTRY_VALUE | CLUSTER_CHANGE_REGISTRY_SUBTREE | CLUSTER_CHANGE_RESOURCE_STATE | CLUSTER_CHANGE_RESOURCE_DELETED | CLUSTER_CHANGE_RESOURCE_ADDED | CLUSTER_CHANGE_RESOURCE_PROPERTY | CLUSTER_CHANGE_GROUP_STATE | CLUSTER_CHANGE_GROUP_DELETED | CLUSTER_CHANGE_GROUP_ADDED | CLUSTER_CHANGE_GROUP_PROPERTY | CLUSTER_CHANGE_RESOURCE_TYPE_DELETED | CLUSTER_CHANGE_RESOURCE_TYPE_ADDED | CLUSTER_CHANGE_NETWORK_STATE | CLUSTER_CHANGE_NETWORK_DELETED | CLUSTER_CHANGE_NETWORK_ADDED | CLUSTER_CHANGE_NETWORK_PROPERTY | CLUSTER_CHANGE_NETINTERFACE_STATE | CLUSTER_CHANGE_NETINTERFACE_DELETED | CLUSTER_CHANGE_NETINTERFACE_ADDED | CLUSTER_CHANGE_NETINTERFACE_PROPERTY | CLUSTER_CHANGE_QUORUM_STATE | CLUSTER_CHANGE_CLUSTER_STATE | CLUSTER_CHANGE_CLUSTER_PROPERTY | CLUSTER_CHANGE_HANDLE_CLOSE
    }	CLUSTER_CHANGE;

			/* size is 2 */
typedef 
enum CLUSTER_ENUM
    {	CLUSTER_ENUM_NODE	= 0x1,
	CLUSTER_ENUM_RESTYPE	= 0x2,
	CLUSTER_ENUM_RESOURCE	= 0x4,
	CLUSTER_ENUM_GROUP	= 0x8,
	CLUSTER_ENUM_NETWORK	= 0x10,
	CLUSTER_ENUM_NETINTERFACE	= 0x20,
	CLUSTER_ENUM_INTERNAL_NETWORK	= 0x80000000,
	CLUSTER_ENUM_ALL	= CLUSTER_ENUM_NODE | CLUSTER_ENUM_RESTYPE | CLUSTER_ENUM_RESOURCE | CLUSTER_ENUM_GROUP | CLUSTER_ENUM_NETWORK | CLUSTER_ENUM_NETINTERFACE
    }	CLUSTER_ENUM;

			/* size is 2 */
typedef 
enum CLUSTER_NODE_ENUM
    {	CLUSTER_NODE_ENUM_NETINTERFACES	= 0x1,
	CLUSTER_NODE_ENUM_ALL	= CLUSTER_NODE_ENUM_NETINTERFACES
    }	CLUSTER_NODE_ENUM;

			/* size is 2 */
typedef 
enum CLUSTER_NODE_STATE
    {	ClusterNodeStateUnknown	= -1,
	ClusterNodeUp	= ClusterNodeStateUnknown + 1,
	ClusterNodeDown	= ClusterNodeUp + 1,
	ClusterNodePaused	= ClusterNodeDown + 1,
	ClusterNodeJoining	= ClusterNodePaused + 1
    }	CLUSTER_NODE_STATE;

			/* size is 2 */
typedef 
enum CLUSTER_GROUP_ENUM
    {	CLUSTER_GROUP_ENUM_CONTAINS	= 0x1,
	CLUSTER_GROUP_ENUM_NODES	= 0x2,
	CLUSTER_GROUP_ENUM_ALL	= CLUSTER_GROUP_ENUM_CONTAINS | CLUSTER_GROUP_ENUM_NODES
    }	CLUSTER_GROUP_ENUM;

			/* size is 2 */
typedef 
enum CLUSTER_GROUP_STATE
    {	ClusterGroupStateUnknown	= -1,
	ClusterGroupOnline	= ClusterGroupStateUnknown + 1,
	ClusterGroupOffline	= ClusterGroupOnline + 1,
	ClusterGroupFailed	= ClusterGroupOffline + 1,
	ClusterGroupPartialOnline	= ClusterGroupFailed + 1
    }	CLUSTER_GROUP_STATE;

			/* size is 2 */
typedef 
enum CLUSTER_GROUP_AUTOFAILBACK_TYPE
    {	ClusterGroupPreventFailback	= 0,
	ClusterGroupAllowFailback	= ClusterGroupPreventFailback + 1,
	ClusterGroupFailbackTypeCount	= ClusterGroupAllowFailback + 1
    }	CLUSTER_GROUP_AUTOFAILBACK_TYPE;

			/* size is 2 */
typedef enum CLUSTER_GROUP_AUTOFAILBACK_TYPE CGAFT;

			/* size is 2 */
typedef 
enum CLUSTER_RESOURCE_STATE
    {	ClusterResourceStateUnknown	= -1,
	ClusterResourceInherited	= ClusterResourceStateUnknown + 1,
	ClusterResourceInitializing	= ClusterResourceInherited + 1,
	ClusterResourceOnline	= ClusterResourceInitializing + 1,
	ClusterResourceOffline	= ClusterResourceOnline + 1,
	ClusterResourceFailed	= ClusterResourceOffline + 1,
	ClusterResourcePending	= 128,
	ClusterResourceOnlinePending	= ClusterResourcePending + 1,
	ClusterResourceOfflinePending	= ClusterResourceOnlinePending + 1
    }	CLUSTER_RESOURCE_STATE;

			/* size is 2 */
typedef 
enum CLUSTER_RESOURCE_RESTART_ACTION
    {	ClusterResourceDontRestart	= 0,
	ClusterResourceRestartNoNotify	= ClusterResourceDontRestart + 1,
	ClusterResourceRestartNotify	= ClusterResourceRestartNoNotify + 1,
	ClusterResourceRestartActionCount	= ClusterResourceRestartNotify + 1
    }	CLUSTER_RESOURCE_RESTART_ACTION;

			/* size is 2 */
typedef enum CLUSTER_RESOURCE_RESTART_ACTION CRRA;

			/* size is 2 */
typedef 
enum CLUSTER_RESOURCE_CREATE_FLAGS
    {	CLUSTER_RESOURCE_SEPARATE_MONITOR	= 1,
	CLUSTER_RESOURCE_VALID_FLAGS	= CLUSTER_RESOURCE_SEPARATE_MONITOR
    }	CLUSTER_RESOURCE_CREATE_FLAGS;

			/* size is 2 */
typedef 
enum CLUSTER_PROPERTY_TYPE
    {	CLUSPROP_TYPE_ENDMARK	= 0,
	CLUSPROP_TYPE_LIST_VALUE	= CLUSPROP_TYPE_ENDMARK + 1,
	CLUSPROP_TYPE_RESCLASS	= CLUSPROP_TYPE_LIST_VALUE + 1,
	CLUSPROP_TYPE_RESERVED1	= CLUSPROP_TYPE_RESCLASS + 1,
	CLUSPROP_TYPE_NAME	= CLUSPROP_TYPE_RESERVED1 + 1,
	CLUSPROP_TYPE_SIGNATURE	= CLUSPROP_TYPE_NAME + 1,
	CLUSPROP_TYPE_SCSI_ADDRESS	= CLUSPROP_TYPE_SIGNATURE + 1,
	CLUSPROP_TYPE_DISK_NUMBER	= CLUSPROP_TYPE_SCSI_ADDRESS + 1,
	CLUSPROP_TYPE_PARTITION_INFO	= CLUSPROP_TYPE_DISK_NUMBER + 1,
	CLUSPROP_TYPE_FTSET_INFO	= CLUSPROP_TYPE_PARTITION_INFO + 1,
	CLUSPROP_TYPE_USER	= 32768
    }	CLUSTER_PROPERTY_TYPE;

			/* size is 2 */
typedef 
enum CLUSTER_PROPERTY_FORMAT
    {	CLUSPROP_FORMAT_UNKNOWN	= 0,
	CLUSPROP_FORMAT_BINARY	= CLUSPROP_FORMAT_UNKNOWN + 1,
	CLUSPROP_FORMAT_DWORD	= CLUSPROP_FORMAT_BINARY + 1,
	CLUSPROP_FORMAT_SZ	= CLUSPROP_FORMAT_DWORD + 1,
	CLUSPROP_FORMAT_EXPAND_SZ	= CLUSPROP_FORMAT_SZ + 1,
	CLUSPROP_FORMAT_MULTI_SZ	= CLUSPROP_FORMAT_EXPAND_SZ + 1,
	CLUSPROP_FORMAT_ULARGE_INTEGER	= CLUSPROP_FORMAT_MULTI_SZ + 1,
	CLUSPROP_FORMAT_USER	= 32768
    }	CLUSTER_PROPERTY_FORMAT;

			/* size is 2 */
typedef 
enum CLUSTER_PROPERTY_SYNTAX
    {	CLUSPROP_SYNTAX_ENDMARK	= ( DWORD  )(CLUSPROP_TYPE_ENDMARK << 16 | CLUSPROP_FORMAT_UNKNOWN),
	CLUSPROP_SYNTAX_NAME	= ( DWORD  )(CLUSPROP_TYPE_NAME << 16 | CLUSPROP_FORMAT_SZ),
	CLUSPROP_SYNTAX_RESCLASS	= ( DWORD  )(CLUSPROP_TYPE_RESCLASS << 16 | CLUSPROP_FORMAT_DWORD),
	CLUSPROP_SYNTAX_LIST_VALUE_SZ	= ( DWORD  )(CLUSPROP_TYPE_LIST_VALUE << 16 | CLUSPROP_FORMAT_SZ),
	CLUSPROP_SYNTAX_LIST_VALUE_EXPAND_SZ	= ( DWORD  )(CLUSPROP_TYPE_LIST_VALUE << 16 | CLUSPROP_FORMAT_EXPAND_SZ),
	CLUSPROP_SYNTAX_LIST_VALUE_DWORD	= ( DWORD  )(CLUSPROP_TYPE_LIST_VALUE << 16 | CLUSPROP_FORMAT_DWORD),
	CLUSPROP_SYNTAX_LIST_VALUE_BINARY	= ( DWORD  )(CLUSPROP_TYPE_LIST_VALUE << 16 | CLUSPROP_FORMAT_BINARY),
	CLUSPROP_SYNTAX_LIST_VALUE_MULTI_SZ	= ( DWORD  )(CLUSPROP_TYPE_LIST_VALUE << 16 | CLUSPROP_FORMAT_MULTI_SZ),
	CLUSPROP_SYNTAX_DISK_SIGNATURE	= ( DWORD  )(CLUSPROP_TYPE_SIGNATURE << 16 | CLUSPROP_FORMAT_DWORD),
	CLUSPROP_SYNTAX_SCSI_ADDRESS	= ( DWORD  )(CLUSPROP_TYPE_SCSI_ADDRESS << 16 | CLUSPROP_FORMAT_DWORD),
	CLUSPROP_SYNTAX_DISK_NUMBER	= ( DWORD  )(CLUSPROP_TYPE_DISK_NUMBER << 16 | CLUSPROP_FORMAT_DWORD),
	CLUSPROP_SYNTAX_PARTITION_INFO	= ( DWORD  )(CLUSPROP_TYPE_PARTITION_INFO << 16 | CLUSPROP_FORMAT_BINARY),
	CLUSPROP_SYNTAX_FTSET_INFO	= ( DWORD  )(CLUSPROP_TYPE_FTSET_INFO << 16 | CLUSPROP_FORMAT_BINARY)
    }	;

			/* size is 2 */
typedef 
enum CLUSTER_CONTROL_OBJECT
    {	CLUS_OBJECT_INVALID	= 0,
	CLUS_OBJECT_RESOURCE	= CLUS_OBJECT_INVALID + 1,
	CLUS_OBJECT_RESOURCE_TYPE	= CLUS_OBJECT_RESOURCE + 1,
	CLUS_OBJECT_GROUP	= CLUS_OBJECT_RESOURCE_TYPE + 1,
	CLUS_OBJECT_NODE	= CLUS_OBJECT_GROUP + 1,
	CLUS_OBJECT_NETWORK	= CLUS_OBJECT_NODE + 1,
	CLUS_OBJECT_NETINTERFACE	= CLUS_OBJECT_NETWORK + 1,
	CLUS_OBJECT_USER	= 128
    }	CLUSTER_CONTROL_OBJECT;

			/* size is 2 */
typedef 
enum CLCTL_CODES
    {	CLCTL_UNKNOWN	= 0 << 0 | 0 + 0 << 2 | 0 << 22,
	CLCTL_GET_CHARACTERISTICS	= 0x1 << 0 | 0 + 1 << 2 | 0 << 22,
	CLCTL_GET_FLAGS	= 0x1 << 0 | 0 + 2 << 2 | 0 << 22,
	CLCTL_GET_CLASS_INFO	= 0x1 << 0 | 0 + 3 << 2 | 0 << 22,
	CLCTL_GET_REQUIRED_DEPENDENCIES	= 0x1 << 0 | 0 + 4 << 2 | 0 << 22,
	CLCTL_GET_NAME	= 0x1 << 0 | 0 + 10 << 2 | 0 << 22,
	CLCTL_GET_RESOURCE_TYPE	= 0x1 << 0 | 0 + 11 << 2 | 0 << 22,
	CLCTL_GET_NODE	= 0x1 << 0 | 0 + 12 << 2 | 0 << 22,
	CLCTL_GET_NETWORK	= 0x1 << 0 | 0 + 13 << 2 | 0 << 22,
	CLCTL_ENUM_COMMON_PROPERTIES	= 0x1 << 0 | 0 + 20 << 2 | 0 << 22,
	CLCTL_GET_RO_COMMON_PROPERTIES	= 0x1 << 0 | 0 + 21 << 2 | 0 << 22,
	CLCTL_GET_COMMON_PROPERTIES	= 0x1 << 0 | 0 + 22 << 2 | 0 << 22,
	CLCTL_SET_COMMON_PROPERTIES	= 0x2 << 0 | 0 + 23 << 2 | 0x1 << 22,
	CLCTL_VALIDATE_COMMON_PROPERTIES	= 0x1 << 0 | 0 + 24 << 2 | 0 << 22,
	CLCTL_ENUM_PRIVATE_PROPERTIES	= 0x1 << 0 | 0 + 30 << 2 | 0 << 22,
	CLCTL_GET_RO_PRIVATE_PROPERTIES	= 0x1 << 0 | 0 + 31 << 2 | 0 << 22,
	CLCTL_GET_PRIVATE_PROPERTIES	= 0x1 << 0 | 0 + 32 << 2 | 0 << 22,
	CLCTL_SET_PRIVATE_PROPERTIES	= 0x2 << 0 | 0 + 33 << 2 | 0x1 << 22,
	CLCTL_VALIDATE_PRIVATE_PROPERTIES	= 0x1 << 0 | 0 + 34 << 2 | 0 << 22,
	CLCTL_ADD_REGISTRY_CHECKPOINT	= 0x2 << 0 | 0 + 40 << 2 | 0x1 << 22,
	CLCTL_DELETE_REGISTRY_CHECKPOINT	= 0x2 << 0 | 0 + 41 << 2 | 0x1 << 22,
	CLCTL_GET_REGISTRY_CHECKPOINTS	= 0x1 << 0 | 0 + 42 << 2 | 0 << 22,
	CLCTL_GET_LOADBAL_PROCESS_LIST	= 0x1 << 0 | 0 + 50 << 2 | 0 << 22,
	CLCTL_STORAGE_GET_DISK_INFO	= 0x1 << 0 | 0 + 100 << 2 | 0 << 22,
	CLCTL_STORAGE_GET_AVAILABLE_DISKS	= 0x1 << 0 | 0 + 101 << 2 | 0 << 22,
	CLCTL_STORAGE_IS_PATH_VALID	= 0x1 << 0 | 0 + 102 << 2 | 0 << 22,
	CLCTL_STORAGE_GET_ALL_AVAILABLE_DISKS	= 0x1 << 0 | 0 + 103 << 2 | 0 << 22 | 1 << 23,
	CLCTL_DELETE	= 0x2 << 0 | 1 << 20 | 0 + 1 << 2 | 0x1 << 22,
	CLCTL_INSTALL_NODE	= 0x2 << 0 | 1 << 20 | 0 + 2 << 2 | 0x1 << 22,
	CLCTL_EVICT_NODE	= 0x2 << 0 | 1 << 20 | 0 + 3 << 2 | 0x1 << 22,
	CLCTL_ADD_DEPENDENCY	= 0x2 << 0 | 1 << 20 | 0 + 4 << 2 | 0x1 << 22,
	CLCTL_REMOVE_DEPENDENCY	= 0x2 << 0 | 1 << 20 | 0 + 5 << 2 | 0x1 << 22,
	CLCTL_ADD_OWNER	= 0x2 << 0 | 1 << 20 | 0 + 6 << 2 | 0x1 << 22,
	CLCTL_REMOVE_OWNER	= 0x2 << 0 | 1 << 20 | 0 + 7 << 2 | 0x1 << 22,
	CLCTL_SET_NAME	= 0x2 << 0 | 1 << 20 | 0 + 9 << 2 | 0x1 << 22,
	CLCTL_CLUSTER_NAME_CHANGED	= 0x2 << 0 | 1 << 20 | 0 + 10 << 2 | 0x1 << 22
    }	CLCTL_CODES;

			/* size is 2 */
typedef 
enum CLUSCTL_RESOURCE_CODES
    {	CLUSCTL_RESOURCE_UNKNOWN	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_UNKNOWN,
	CLUSCTL_RESOURCE_GET_CHARACTERISTICS	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_CHARACTERISTICS,
	CLUSCTL_RESOURCE_GET_FLAGS	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_FLAGS,
	CLUSCTL_RESOURCE_GET_CLASS_INFO	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_CLASS_INFO,
	CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_REQUIRED_DEPENDENCIES,
	CLUSCTL_RESOURCE_GET_NAME	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_NAME,
	CLUSCTL_RESOURCE_GET_RESOURCE_TYPE	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_RESOURCE_TYPE,
	CLUSCTL_RESOURCE_ENUM_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_ENUM_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_RO_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_SET_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_VALIDATE_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_VALIDATE_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_ENUM_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_RO_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_SET_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_VALIDATE_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_ADD_REGISTRY_CHECKPOINT,
	CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_DELETE_REGISTRY_CHECKPOINT,
	CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_REGISTRY_CHECKPOINTS,
	CLUSCTL_RESOURCE_GET_LOADBAL_PROCESS_LIST	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_GET_LOADBAL_PROCESS_LIST,
	CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_STORAGE_GET_DISK_INFO,
	CLUSCTL_RESOURCE_STORAGE_IS_PATH_VALID	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_STORAGE_IS_PATH_VALID,
	CLUSCTL_RESOURCE_DELETE	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_DELETE,
	CLUSCTL_RESOURCE_INSTALL_NODE	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_INSTALL_NODE,
	CLUSCTL_RESOURCE_EVICT_NODE	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_EVICT_NODE,
	CLUSCTL_RESOURCE_ADD_DEPENDENCY	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_ADD_DEPENDENCY,
	CLUSCTL_RESOURCE_REMOVE_DEPENDENCY	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_REMOVE_DEPENDENCY,
	CLUSCTL_RESOURCE_ADD_OWNER	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_ADD_OWNER,
	CLUSCTL_RESOURCE_REMOVE_OWNER	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_REMOVE_OWNER,
	CLUSCTL_RESOURCE_SET_NAME	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_SET_NAME,
	CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED	= CLUS_OBJECT_RESOURCE << 24 | CLCTL_CLUSTER_NAME_CHANGED
    }	CLUSCTL_RESOURCE_CODES;

			/* size is 2 */
typedef 
enum CLUSCTL_RESOURCE_TYPE_CODES
    {	CLUSCTL_RESOURCE_TYPE_UNKNOWN	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_UNKNOWN,
	CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_GET_CHARACTERISTICS,
	CLUSCTL_RESOURCE_TYPE_GET_FLAGS	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_GET_FLAGS,
	CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_GET_CLASS_INFO,
	CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_GET_REQUIRED_DEPENDENCIES,
	CLUSCTL_RESOURCE_TYPE_ENUM_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_ENUM_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_GET_RO_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_GET_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_VALIDATE_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_VALIDATE_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_SET_COMMON_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_ENUM_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_GET_RO_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_GET_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_SET_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_VALIDATE_PRIVATE_PROPERTIES,
	CLUSCTL_RESOURCE_TYPE_GET_REGISTRY_CHECKPOINTS	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_GET_REGISTRY_CHECKPOINTS,
	CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_STORAGE_GET_AVAILABLE_DISKS,
	CLUSCTL_RESOURCE_TYPE_INSTALL_NODE	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_INSTALL_NODE,
	CLUSCTL_RESOURCE_TYPE_EVICT_NODE	= CLUS_OBJECT_RESOURCE_TYPE << 24 | CLCTL_EVICT_NODE
    }	CLUSCTL_RESOURCE_TYPE_CODES;

			/* size is 2 */
typedef 
enum CLUSCTL_GROUP_CODES
    {	CLUSCTL_GROUP_UNKNOWN	= CLUS_OBJECT_GROUP << 24 | CLCTL_UNKNOWN,
	CLUSCTL_GROUP_GET_CHARACTERISTICS	= CLUS_OBJECT_GROUP << 24 | CLCTL_GET_CHARACTERISTICS,
	CLUSCTL_GROUP_GET_FLAGS	= CLUS_OBJECT_GROUP << 24 | CLCTL_GET_FLAGS,
	CLUSCTL_GROUP_GET_NAME	= CLUS_OBJECT_GROUP << 24 | CLCTL_GET_NAME,
	CLUSCTL_GROUP_ENUM_COMMON_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_ENUM_COMMON_PROPERTIES,
	CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_GET_RO_COMMON_PROPERTIES,
	CLUSCTL_GROUP_GET_COMMON_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_GET_COMMON_PROPERTIES,
	CLUSCTL_GROUP_SET_COMMON_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_SET_COMMON_PROPERTIES,
	CLUSCTL_GROUP_VALIDATE_COMMON_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_VALIDATE_COMMON_PROPERTIES,
	CLUSCTL_GROUP_ENUM_PRIVATE_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_ENUM_PRIVATE_PROPERTIES,
	CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_GET_RO_PRIVATE_PROPERTIES,
	CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_GET_PRIVATE_PROPERTIES,
	CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_SET_PRIVATE_PROPERTIES,
	CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES	= CLUS_OBJECT_GROUP << 24 | CLCTL_VALIDATE_PRIVATE_PROPERTIES
    }	CLUSCTL_GROUP_CODES;

			/* size is 2 */
typedef 
enum CLUSCTL_NODE_CODES
    {	CLUSCTL_NODE_UNKNOWN	= CLUS_OBJECT_NODE << 24 | CLCTL_UNKNOWN,
	CLUSCTL_NODE_GET_CHARACTERISTICS	= CLUS_OBJECT_NODE << 24 | CLCTL_GET_CHARACTERISTICS,
	CLUSCTL_NODE_GET_FLAGS	= CLUS_OBJECT_NODE << 24 | CLCTL_GET_FLAGS,
	CLUSCTL_NODE_GET_NAME	= CLUS_OBJECT_NODE << 24 | CLCTL_GET_NAME,
	CLUSCTL_NODE_ENUM_COMMON_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_ENUM_COMMON_PROPERTIES,
	CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_GET_RO_COMMON_PROPERTIES,
	CLUSCTL_NODE_GET_COMMON_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_GET_COMMON_PROPERTIES,
	CLUSCTL_NODE_SET_COMMON_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_SET_COMMON_PROPERTIES,
	CLUSCTL_NODE_VALIDATE_COMMON_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_VALIDATE_COMMON_PROPERTIES,
	CLUSCTL_NODE_ENUM_PRIVATE_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_ENUM_PRIVATE_PROPERTIES,
	CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_GET_RO_PRIVATE_PROPERTIES,
	CLUSCTL_NODE_GET_PRIVATE_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_GET_PRIVATE_PROPERTIES,
	CLUSCTL_NODE_SET_PRIVATE_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_SET_PRIVATE_PROPERTIES,
	CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES	= CLUS_OBJECT_NODE << 24 | CLCTL_VALIDATE_PRIVATE_PROPERTIES
    }	CLUSCTL_NODE_CODES;

			/* size is 2 */
typedef 
enum CLUSCTL_NETWORK_CODES
    {	CLUSCTL_NETWORK_UNKNOWN	= CLUS_OBJECT_NETWORK << 24 | CLCTL_UNKNOWN,
	CLUSCTL_NETWORK_GET_CHARACTERISTICS	= CLUS_OBJECT_NETWORK << 24 | CLCTL_GET_CHARACTERISTICS,
	CLUSCTL_NETWORK_GET_FLAGS	= CLUS_OBJECT_NETWORK << 24 | CLCTL_GET_FLAGS,
	CLUSCTL_NETWORK_GET_NAME	= CLUS_OBJECT_NETWORK << 24 | CLCTL_GET_NAME,
	CLUSCTL_NETWORK_ENUM_COMMON_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_ENUM_COMMON_PROPERTIES,
	CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_GET_RO_COMMON_PROPERTIES,
	CLUSCTL_NETWORK_GET_COMMON_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_GET_COMMON_PROPERTIES,
	CLUSCTL_NETWORK_SET_COMMON_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_SET_COMMON_PROPERTIES,
	CLUSCTL_NETWORK_VALIDATE_COMMON_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_VALIDATE_COMMON_PROPERTIES,
	CLUSCTL_NETWORK_ENUM_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_ENUM_PRIVATE_PROPERTIES,
	CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_GET_RO_PRIVATE_PROPERTIES,
	CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_GET_PRIVATE_PROPERTIES,
	CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_SET_PRIVATE_PROPERTIES,
	CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETWORK << 24 | CLCTL_VALIDATE_PRIVATE_PROPERTIES
    }	CLUSCTL_NETWORK_CODES;

			/* size is 2 */
typedef 
enum CLUSCTL_NETINTERFACE_CODES
    {	CLUSCTL_NETINTERFACE_UNKNOWN	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_UNKNOWN,
	CLUSCTL_NETINTERFACE_GET_CHARACTERISTICS	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_GET_CHARACTERISTICS,
	CLUSCTL_NETINTERFACE_GET_FLAGS	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_GET_FLAGS,
	CLUSCTL_NETINTERFACE_GET_NAME	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_GET_NAME,
	CLUSCTL_NETINTERFACE_GET_NODE	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_GET_NODE,
	CLUSCTL_NETINTERFACE_GET_NETWORK	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_GET_NETWORK,
	CLUSCTL_NETINTERFACE_ENUM_COMMON_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_ENUM_COMMON_PROPERTIES,
	CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_GET_RO_COMMON_PROPERTIES,
	CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_GET_COMMON_PROPERTIES,
	CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_SET_COMMON_PROPERTIES,
	CLUSCTL_NETINTERFACE_VALIDATE_COMMON_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_VALIDATE_COMMON_PROPERTIES,
	CLUSCTL_NETINTERFACE_ENUM_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_ENUM_PRIVATE_PROPERTIES,
	CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_GET_RO_PRIVATE_PROPERTIES,
	CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_GET_PRIVATE_PROPERTIES,
	CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_SET_PRIVATE_PROPERTIES,
	CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES	= CLUS_OBJECT_NETINTERFACE << 24 | CLCTL_VALIDATE_PRIVATE_PROPERTIES
    }	CLUSCTL_NETINTERFACE_CODES;

			/* size is 2 */
typedef 
enum CLUSTER_RESOURCE_CLASS
    {	CLUS_RESCLASS_UNKNOWN	= 0,
	CLUS_RESCLASS_STORAGE	= CLUS_RESCLASS_UNKNOWN + 1,
	CLUS_RESCLASS_USER	= 32768
    }	CLUSTER_RESOURCE_CLASS;

			/* size is 2 */
typedef 
enum CLUS_RESSUBCLASS
    {	CLUS_RESSUBCLASS_SHARED	= 0x80000000
    }	CLUS_RESSUBCLASS;

			/* size is 2 */
typedef 
enum CLUS_CHARACTERISTICS
    {	CLUS_CHAR_UNKNOWN	= 0,
	CLUS_CHAR_QUORUM	= 0x1,
	CLUS_CHAR_DELETE_REQUIRES_ALL_NODES	= 0x2
    }	CLUS_CHARACTERISTICS;

			/* size is 2 */
typedef 
enum CLUS_FLAGS
    {	CLUS_FLAG_CORE	= 0x1
    }	CLUS_FLAGS;

			/* size is 2 */
typedef 
enum CLUSPROP_PIFLAGS
    {	CLUSPROP_PIFLAG_STICKY	= 0x1,
	CLUSPROP_PIFLAG_REMOVABLE	= 0x2,
	CLUSPROP_PIFLAG_USABLE	= 0x4
    }	CLUSPROP_PIFLAGS;

			/* size is 2 */
typedef 
enum CLUSTER_RESOURCE_ENUM
    {	CLUSTER_RESOURCE_ENUM_DEPENDS	= 0x1,
	CLUSTER_RESOURCE_ENUM_PROVIDES	= 0x2,
	CLUSTER_RESOURCE_ENUM_NODES	= 0x4,
	CLUSTER_RESOURCE_ENUM_ALL	= CLUSTER_RESOURCE_ENUM_DEPENDS | CLUSTER_RESOURCE_ENUM_PROVIDES | CLUSTER_RESOURCE_ENUM_NODES
    }	CLUSTER_RESOURCE_ENUM;

			/* size is 2 */
typedef 
enum CLUSTER_NETWORK_ENUM
    {	CLUSTER_NETWORK_ENUM_NETINTERFACES	= 0x1,
	CLUSTER_NETWORK_ENUM_ALL	= CLUSTER_NETWORK_ENUM_NETINTERFACES
    }	CLUSTER_NETWORK_ENUM;

			/* size is 2 */
typedef 
enum CLUSTER_NETWORK_STATE
    {	ClusterNetworkStateUnknown	= -1,
	ClusterNetworkUnavailable	= ClusterNetworkStateUnknown + 1,
	ClusterNetworkDown	= ClusterNetworkUnavailable + 1,
	ClusterNetworkPartitioned	= ClusterNetworkDown + 1,
	ClusterNetworkUp	= ClusterNetworkPartitioned + 1
    }	CLUSTER_NETWORK_STATE;

			/* size is 2 */
typedef 
enum CLUSTER_NETWORK_ROLE
    {	ClusterNetworkRoleNone	= 0,
	ClusterNetworkRoleInternalUse	= 0x1,
	ClusterNetworkRoleClientAccess	= 0x2,
	ClusterNetworkRoleInternalAndClient	= 0x3
    }	CLUSTER_NETWORK_ROLE;

			/* size is 2 */
typedef 
enum CLUSTER_NETINTERFACE_STATE
    {	ClusterNetInterfaceStateUnknown	= -1,
	ClusterNetInterfaceUnavailable	= ClusterNetInterfaceStateUnknown + 1,
	ClusterNetInterfaceFailed	= ClusterNetInterfaceUnavailable + 1,
	ClusterNetInterfaceUnreachable	= ClusterNetInterfaceFailed + 1,
	ClusterNetInterfaceUp	= ClusterNetInterfaceUnreachable + 1
    }	CLUSTER_NETINTERFACE_STATE;

#define _CLUSTER_API_TYPES_
#endif // _CLUSTER_API_TYPES_
			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IClusterApplication_INTERFACE_DEFINED__
#define __IClusterApplication_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IClusterApplication
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][hidden][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IClusterApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IClusterApplication : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Domains( 
            /* [retval][out] */ Domains __RPC_FAR *__RPC_FAR *ppDomains) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenCluster( 
            /* [in] */ BSTR bstrClusterName,
            /* [retval][out] */ ICluster __RPC_FAR *__RPC_FAR *pCluster) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClusterApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClusterApplication __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClusterApplication __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClusterApplication __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IClusterApplication __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IClusterApplication __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IClusterApplication __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IClusterApplication __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Domains )( 
            IClusterApplication __RPC_FAR * This,
            /* [retval][out] */ Domains __RPC_FAR *__RPC_FAR *ppDomains);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenCluster )( 
            IClusterApplication __RPC_FAR * This,
            /* [in] */ BSTR bstrClusterName,
            /* [retval][out] */ ICluster __RPC_FAR *__RPC_FAR *pCluster);
        
        END_INTERFACE
    } IClusterApplicationVtbl;

    interface IClusterApplication
    {
        CONST_VTBL struct IClusterApplicationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClusterApplication_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClusterApplication_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClusterApplication_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClusterApplication_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IClusterApplication_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IClusterApplication_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IClusterApplication_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IClusterApplication_get_Domains(This,ppDomains)	\
    (This)->lpVtbl -> get_Domains(This,ppDomains)

#define IClusterApplication_OpenCluster(This,bstrClusterName,pCluster)	\
    (This)->lpVtbl -> OpenCluster(This,bstrClusterName,pCluster)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IClusterApplication_get_Domains_Proxy( 
    IClusterApplication __RPC_FAR * This,
    /* [retval][out] */ Domains __RPC_FAR *__RPC_FAR *ppDomains);


void __RPC_STUB IClusterApplication_get_Domains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClusterApplication_OpenCluster_Proxy( 
    IClusterApplication __RPC_FAR * This,
    /* [in] */ BSTR bstrClusterName,
    /* [retval][out] */ ICluster __RPC_FAR *__RPC_FAR *pCluster);


void __RPC_STUB IClusterApplication_OpenCluster_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClusterApplication_INTERFACE_DEFINED__ */


#ifndef __Domains_INTERFACE_DEFINED__
#define __Domains_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Domains
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Domains;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface Domains : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pnCount) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ IClusterDomain __RPC_FAR *__RPC_FAR *ppClusterDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ IClusterDomain __RPC_FAR *pClusterDomain) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DomainsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Domains __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Domains __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Domains __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Domains __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Domains __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Domains __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Domains __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Domains __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnCount);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Domains __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ IClusterDomain __RPC_FAR *__RPC_FAR *ppClusterDomain);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            Domains __RPC_FAR * This,
            /* [in] */ IClusterDomain __RPC_FAR *pClusterDomain);
        
        END_INTERFACE
    } DomainsVtbl;

    interface Domains
    {
        CONST_VTBL struct DomainsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Domains_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Domains_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Domains_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Domains_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Domains_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Domains_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Domains_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Domains_get_Count(This,pnCount)	\
    (This)->lpVtbl -> get_Count(This,pnCount)

#define Domains_get_Item(This,varIndex,ppClusterDomain)	\
    (This)->lpVtbl -> get_Item(This,varIndex,ppClusterDomain)

#define Domains_AddItem(This,pClusterDomain)	\
    (This)->lpVtbl -> AddItem(This,pClusterDomain)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE Domains_get_Count_Proxy( 
    Domains __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnCount);


void __RPC_STUB Domains_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE Domains_get_Item_Proxy( 
    Domains __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ IClusterDomain __RPC_FAR *__RPC_FAR *ppClusterDomain);


void __RPC_STUB Domains_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE Domains_AddItem_Proxy( 
    Domains __RPC_FAR * This,
    /* [in] */ IClusterDomain __RPC_FAR *pClusterDomain);


void __RPC_STUB Domains_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Domains_INTERFACE_DEFINED__ */


#ifndef __IClusterDomain_INTERFACE_DEFINED__
#define __IClusterDomain_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IClusterDomain
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][hidden][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IClusterDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IClusterDomain : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DomainName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDomainName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Clusters( 
            /* [retval][out] */ Clusters __RPC_FAR *__RPC_FAR *ppClusters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClusterDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClusterDomain __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClusterDomain __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClusterDomain __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IClusterDomain __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IClusterDomain __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IClusterDomain __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IClusterDomain __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DomainName )( 
            IClusterDomain __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDomainName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Clusters )( 
            IClusterDomain __RPC_FAR * This,
            /* [retval][out] */ Clusters __RPC_FAR *__RPC_FAR *ppClusters);
        
        END_INTERFACE
    } IClusterDomainVtbl;

    interface IClusterDomain
    {
        CONST_VTBL struct IClusterDomainVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClusterDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClusterDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClusterDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClusterDomain_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IClusterDomain_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IClusterDomain_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IClusterDomain_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IClusterDomain_get_DomainName(This,pbstrDomainName)	\
    (This)->lpVtbl -> get_DomainName(This,pbstrDomainName)

#define IClusterDomain_get_Clusters(This,ppClusters)	\
    (This)->lpVtbl -> get_Clusters(This,ppClusters)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IClusterDomain_get_DomainName_Proxy( 
    IClusterDomain __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDomainName);


void __RPC_STUB IClusterDomain_get_DomainName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IClusterDomain_get_Clusters_Proxy( 
    IClusterDomain __RPC_FAR * This,
    /* [retval][out] */ Clusters __RPC_FAR *__RPC_FAR *ppClusters);


void __RPC_STUB IClusterDomain_get_Clusters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClusterDomain_INTERFACE_DEFINED__ */


#ifndef __Clusters_INTERFACE_DEFINED__
#define __Clusters_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Clusters
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Clusters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface Clusters : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DomainName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDomainName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pnCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *bstrClusterName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClustersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Clusters __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Clusters __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Clusters __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Clusters __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Clusters __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Clusters __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Clusters __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DomainName )( 
            Clusters __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDomainName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Clusters __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Clusters __RPC_FAR * This,
            /* [in] */ LONG nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *bstrClusterName);
        
        END_INTERFACE
    } ClustersVtbl;

    interface Clusters
    {
        CONST_VTBL struct ClustersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Clusters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Clusters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Clusters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Clusters_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Clusters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Clusters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Clusters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Clusters_get_DomainName(This,pbstrDomainName)	\
    (This)->lpVtbl -> get_DomainName(This,pbstrDomainName)

#define Clusters_get_Count(This,pnCount)	\
    (This)->lpVtbl -> get_Count(This,pnCount)

#define Clusters_get_Item(This,nIndex,bstrClusterName)	\
    (This)->lpVtbl -> get_Item(This,nIndex,bstrClusterName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE Clusters_get_DomainName_Proxy( 
    Clusters __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDomainName);


void __RPC_STUB Clusters_get_DomainName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Clusters_get_Count_Proxy( 
    Clusters __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnCount);


void __RPC_STUB Clusters_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Clusters_get_Item_Proxy( 
    Clusters __RPC_FAR * This,
    /* [in] */ LONG nIndex,
    /* [retval][out] */ BSTR __RPC_FAR *bstrClusterName);


void __RPC_STUB Clusters_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Clusters_INTERFACE_DEFINED__ */


#ifndef __ICluster_INTERFACE_DEFINED__
#define __ICluster_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICluster
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][hidden][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICluster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICluster : public IDispatch
    {
    public:
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Handle( 
            /* [retval][out] */ LONG __RPC_FAR *phandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR bstrClusterName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrClusterName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrClusterName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ BSTR __RPC_FAR *pbstrClusterName,
            /* [out] */ SHORT __RPC_FAR *MajorVersion,
            /* [out] */ SHORT __RPC_FAR *MinorVersion,
            /* [out] */ SHORT __RPC_FAR *BuildNumber,
            /* [out] */ BSTR __RPC_FAR *pbstrVendorId,
            /* [out] */ BSTR __RPC_FAR *pbstrCSDVersion) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_QuorumResource( 
            /* [in] */ ClusResource __RPC_FAR *pClusterResource) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_QuorumResource( 
            /* [retval][out] */ ClusResource __RPC_FAR *__RPC_FAR *pClusterResource) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Nodes( 
            /* [retval][out] */ ClusNodes __RPC_FAR *__RPC_FAR *ppClusterNodes) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ResourceGroups( 
            /* [retval][out] */ ClusResGroups __RPC_FAR *__RPC_FAR *ppClusterResourceGroups) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Resources( 
            /* [retval][out] */ ClusResources __RPC_FAR *__RPC_FAR *ppClusterResources) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ResourceTypes( 
            /* [retval][out] */ ClusResTypes __RPC_FAR *__RPC_FAR *ppResourceTypes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClusterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICluster __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICluster __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICluster __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICluster __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICluster __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICluster __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICluster __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Handle )( 
            ICluster __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *phandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            ICluster __RPC_FAR * This,
            /* [in] */ BSTR bstrClusterName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            ICluster __RPC_FAR * This);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            ICluster __RPC_FAR * This,
            /* [in] */ BSTR bstrClusterName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICluster __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrClusterName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            ICluster __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrClusterName,
            /* [out] */ SHORT __RPC_FAR *MajorVersion,
            /* [out] */ SHORT __RPC_FAR *MinorVersion,
            /* [out] */ SHORT __RPC_FAR *BuildNumber,
            /* [out] */ BSTR __RPC_FAR *pbstrVendorId,
            /* [out] */ BSTR __RPC_FAR *pbstrCSDVersion);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_QuorumResource )( 
            ICluster __RPC_FAR * This,
            /* [in] */ ClusResource __RPC_FAR *pClusterResource);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QuorumResource )( 
            ICluster __RPC_FAR * This,
            /* [retval][out] */ ClusResource __RPC_FAR *__RPC_FAR *pClusterResource);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Nodes )( 
            ICluster __RPC_FAR * This,
            /* [retval][out] */ ClusNodes __RPC_FAR *__RPC_FAR *ppClusterNodes);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResourceGroups )( 
            ICluster __RPC_FAR * This,
            /* [retval][out] */ ClusResGroups __RPC_FAR *__RPC_FAR *ppClusterResourceGroups);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Resources )( 
            ICluster __RPC_FAR * This,
            /* [retval][out] */ ClusResources __RPC_FAR *__RPC_FAR *ppClusterResources);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResourceTypes )( 
            ICluster __RPC_FAR * This,
            /* [retval][out] */ ClusResTypes __RPC_FAR *__RPC_FAR *ppResourceTypes);
        
        END_INTERFACE
    } IClusterVtbl;

    interface ICluster
    {
        CONST_VTBL struct IClusterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICluster_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICluster_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICluster_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICluster_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICluster_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICluster_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICluster_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICluster_get_Handle(This,phandle)	\
    (This)->lpVtbl -> get_Handle(This,phandle)

#define ICluster_Open(This,bstrClusterName)	\
    (This)->lpVtbl -> Open(This,bstrClusterName)

#define ICluster_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define ICluster_put_Name(This,bstrClusterName)	\
    (This)->lpVtbl -> put_Name(This,bstrClusterName)

#define ICluster_get_Name(This,pbstrClusterName)	\
    (This)->lpVtbl -> get_Name(This,pbstrClusterName)

#define ICluster_GetVersion(This,pbstrClusterName,MajorVersion,MinorVersion,BuildNumber,pbstrVendorId,pbstrCSDVersion)	\
    (This)->lpVtbl -> GetVersion(This,pbstrClusterName,MajorVersion,MinorVersion,BuildNumber,pbstrVendorId,pbstrCSDVersion)

#define ICluster_put_QuorumResource(This,pClusterResource)	\
    (This)->lpVtbl -> put_QuorumResource(This,pClusterResource)

#define ICluster_get_QuorumResource(This,pClusterResource)	\
    (This)->lpVtbl -> get_QuorumResource(This,pClusterResource)

#define ICluster_get_Nodes(This,ppClusterNodes)	\
    (This)->lpVtbl -> get_Nodes(This,ppClusterNodes)

#define ICluster_get_ResourceGroups(This,ppClusterResourceGroups)	\
    (This)->lpVtbl -> get_ResourceGroups(This,ppClusterResourceGroups)

#define ICluster_get_Resources(This,ppClusterResources)	\
    (This)->lpVtbl -> get_Resources(This,ppClusterResources)

#define ICluster_get_ResourceTypes(This,ppResourceTypes)	\
    (This)->lpVtbl -> get_ResourceTypes(This,ppResourceTypes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE ICluster_get_Handle_Proxy( 
    ICluster __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *phandle);


void __RPC_STUB ICluster_get_Handle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICluster_Open_Proxy( 
    ICluster __RPC_FAR * This,
    /* [in] */ BSTR bstrClusterName);


void __RPC_STUB ICluster_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICluster_Close_Proxy( 
    ICluster __RPC_FAR * This);


void __RPC_STUB ICluster_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICluster_put_Name_Proxy( 
    ICluster __RPC_FAR * This,
    /* [in] */ BSTR bstrClusterName);


void __RPC_STUB ICluster_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICluster_get_Name_Proxy( 
    ICluster __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrClusterName);


void __RPC_STUB ICluster_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICluster_GetVersion_Proxy( 
    ICluster __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrClusterName,
    /* [out] */ SHORT __RPC_FAR *MajorVersion,
    /* [out] */ SHORT __RPC_FAR *MinorVersion,
    /* [out] */ SHORT __RPC_FAR *BuildNumber,
    /* [out] */ BSTR __RPC_FAR *pbstrVendorId,
    /* [out] */ BSTR __RPC_FAR *pbstrCSDVersion);


void __RPC_STUB ICluster_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICluster_put_QuorumResource_Proxy( 
    ICluster __RPC_FAR * This,
    /* [in] */ ClusResource __RPC_FAR *pClusterResource);


void __RPC_STUB ICluster_put_QuorumResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICluster_get_QuorumResource_Proxy( 
    ICluster __RPC_FAR * This,
    /* [retval][out] */ ClusResource __RPC_FAR *__RPC_FAR *pClusterResource);


void __RPC_STUB ICluster_get_QuorumResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICluster_get_Nodes_Proxy( 
    ICluster __RPC_FAR * This,
    /* [retval][out] */ ClusNodes __RPC_FAR *__RPC_FAR *ppClusterNodes);


void __RPC_STUB ICluster_get_Nodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICluster_get_ResourceGroups_Proxy( 
    ICluster __RPC_FAR * This,
    /* [retval][out] */ ClusResGroups __RPC_FAR *__RPC_FAR *ppClusterResourceGroups);


void __RPC_STUB ICluster_get_ResourceGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICluster_get_Resources_Proxy( 
    ICluster __RPC_FAR * This,
    /* [retval][out] */ ClusResources __RPC_FAR *__RPC_FAR *ppClusterResources);


void __RPC_STUB ICluster_get_Resources_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICluster_get_ResourceTypes_Proxy( 
    ICluster __RPC_FAR * This,
    /* [retval][out] */ ClusResTypes __RPC_FAR *__RPC_FAR *ppResourceTypes);


void __RPC_STUB ICluster_get_ResourceTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICluster_INTERFACE_DEFINED__ */


#ifndef __ClusNode_INTERFACE_DEFINED__
#define __ClusNode_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusNode
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusNode : public IDispatch
    {
    public:
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Handle( 
            /* [retval][out] */ LONG __RPC_FAR *phandle) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNodeName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NodeID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNodeID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ LONG __RPC_FAR *dwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Evict( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ResourceGroups( 
            /* [retval][out] */ ClusResGroups __RPC_FAR *__RPC_FAR *ppResourceGroups) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommonProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommonROProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateROProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusNode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusNode __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusNode __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusNode __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Handle )( 
            ClusNode __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *phandle);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ClusNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNodeName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NodeID )( 
            ClusNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNodeID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ClusNode __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *dwState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            ClusNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            ClusNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Evict )( 
            ClusNode __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResourceGroups )( 
            ClusNode __RPC_FAR * This,
            /* [retval][out] */ ClusResGroups __RPC_FAR *__RPC_FAR *ppResourceGroups);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommonProperties )( 
            ClusNode __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrivateProperties )( 
            ClusNode __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommonROProperties )( 
            ClusNode __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrivateROProperties )( 
            ClusNode __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ClusNodeVtbl;

    interface ClusNode
    {
        CONST_VTBL struct ClusNodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusNode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusNode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusNode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusNode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusNode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusNode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusNode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusNode_get_Handle(This,phandle)	\
    (This)->lpVtbl -> get_Handle(This,phandle)

#define ClusNode_get_Name(This,pbstrNodeName)	\
    (This)->lpVtbl -> get_Name(This,pbstrNodeName)

#define ClusNode_get_NodeID(This,pbstrNodeID)	\
    (This)->lpVtbl -> get_NodeID(This,pbstrNodeID)

#define ClusNode_get_State(This,dwState)	\
    (This)->lpVtbl -> get_State(This,dwState)

#define ClusNode_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define ClusNode_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define ClusNode_Evict(This)	\
    (This)->lpVtbl -> Evict(This)

#define ClusNode_get_ResourceGroups(This,ppResourceGroups)	\
    (This)->lpVtbl -> get_ResourceGroups(This,ppResourceGroups)

#define ClusNode_get_CommonProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_CommonProperties(This,ppProperties)

#define ClusNode_get_PrivateProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_PrivateProperties(This,ppProperties)

#define ClusNode_get_CommonROProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_CommonROProperties(This,ppProperties)

#define ClusNode_get_PrivateROProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_PrivateROProperties(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE ClusNode_get_Handle_Proxy( 
    ClusNode __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *phandle);


void __RPC_STUB ClusNode_get_Handle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusNode_get_Name_Proxy( 
    ClusNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrNodeName);


void __RPC_STUB ClusNode_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusNode_get_NodeID_Proxy( 
    ClusNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrNodeID);


void __RPC_STUB ClusNode_get_NodeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusNode_get_State_Proxy( 
    ClusNode __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *dwState);


void __RPC_STUB ClusNode_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusNode_Pause_Proxy( 
    ClusNode __RPC_FAR * This);


void __RPC_STUB ClusNode_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusNode_Resume_Proxy( 
    ClusNode __RPC_FAR * This);


void __RPC_STUB ClusNode_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusNode_Evict_Proxy( 
    ClusNode __RPC_FAR * This);


void __RPC_STUB ClusNode_Evict_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusNode_get_ResourceGroups_Proxy( 
    ClusNode __RPC_FAR * This,
    /* [retval][out] */ ClusResGroups __RPC_FAR *__RPC_FAR *ppResourceGroups);


void __RPC_STUB ClusNode_get_ResourceGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusNode_get_CommonProperties_Proxy( 
    ClusNode __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusNode_get_CommonProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusNode_get_PrivateProperties_Proxy( 
    ClusNode __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusNode_get_PrivateProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusNode_get_CommonROProperties_Proxy( 
    ClusNode __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusNode_get_CommonROProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusNode_get_PrivateROProperties_Proxy( 
    ClusNode __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusNode_get_PrivateROProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusNode_INTERFACE_DEFINED__ */


#ifndef __ClusNodes_INTERFACE_DEFINED__
#define __ClusNodes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusNodes
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusNodes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusNodes : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pnCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusNode __RPC_FAR *__RPC_FAR *ppClusterNode) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusNodesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusNodes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusNodes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusNodes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusNodes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusNodes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusNodes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusNodes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ClusNodes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ClusNodes __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusNode __RPC_FAR *__RPC_FAR *ppClusterNode);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ClusNodes __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } ClusNodesVtbl;

    interface ClusNodes
    {
        CONST_VTBL struct ClusNodesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusNodes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusNodes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusNodes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusNodes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusNodes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusNodes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusNodes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusNodes_get_Count(This,pnCount)	\
    (This)->lpVtbl -> get_Count(This,pnCount)

#define ClusNodes_get_Item(This,varIndex,ppClusterNode)	\
    (This)->lpVtbl -> get_Item(This,varIndex,ppClusterNode)

#define ClusNodes_get__NewEnum(This,ppEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE ClusNodes_get_Count_Proxy( 
    ClusNodes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnCount);


void __RPC_STUB ClusNodes_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ClusNodes_get_Item_Proxy( 
    ClusNodes __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ ClusNode __RPC_FAR *__RPC_FAR *ppClusterNode);


void __RPC_STUB ClusNodes_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ClusNodes_get__NewEnum_Proxy( 
    ClusNodes __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB ClusNodes_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusNodes_INTERFACE_DEFINED__ */


#ifndef __ClusResGroup_INTERFACE_DEFINED__
#define __ClusResGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusResGroup
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusResGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusResGroup : public IDispatch
    {
    public:
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Handle( 
            /* [retval][out] */ LONG __RPC_FAR *phandle) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrGroupName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrGroupName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ LONG __RPC_FAR *dwState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OwnerNode( 
            /* [retval][out] */ ClusNode __RPC_FAR *__RPC_FAR *ppOwnerNode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Resources( 
            /* [retval][out] */ ClusResources __RPC_FAR *__RPC_FAR *ppClusterResources) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PreferredOwnerNodes( 
            /* [retval][out] */ ClusNodes __RPC_FAR *__RPC_FAR *ppOwnerNodes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Online( 
            /* [optional][in] */ ClusNode __RPC_FAR *pDestinationNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [optional][in] */ ClusNode __RPC_FAR *pDestinationNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Offline( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommonProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommonROProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateROProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusResGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusResGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusResGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusResGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusResGroup __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusResGroup __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusResGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusResGroup __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Handle )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *phandle);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            ClusResGroup __RPC_FAR * This,
            /* [in] */ BSTR bstrGroupName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrGroupName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *dwState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OwnerNode )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ ClusNode __RPC_FAR *__RPC_FAR *ppOwnerNode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Resources )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ ClusResources __RPC_FAR *__RPC_FAR *ppClusterResources);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PreferredOwnerNodes )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ ClusNodes __RPC_FAR *__RPC_FAR *ppOwnerNodes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ClusResGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Online )( 
            ClusResGroup __RPC_FAR * This,
            /* [optional][in] */ ClusNode __RPC_FAR *pDestinationNode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            ClusResGroup __RPC_FAR * This,
            /* [optional][in] */ ClusNode __RPC_FAR *pDestinationNode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Offline )( 
            ClusResGroup __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommonProperties )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrivateProperties )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommonROProperties )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrivateROProperties )( 
            ClusResGroup __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ClusResGroupVtbl;

    interface ClusResGroup
    {
        CONST_VTBL struct ClusResGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusResGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusResGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusResGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusResGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusResGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusResGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusResGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusResGroup_get_Handle(This,phandle)	\
    (This)->lpVtbl -> get_Handle(This,phandle)

#define ClusResGroup_put_Name(This,bstrGroupName)	\
    (This)->lpVtbl -> put_Name(This,bstrGroupName)

#define ClusResGroup_get_Name(This,pbstrGroupName)	\
    (This)->lpVtbl -> get_Name(This,pbstrGroupName)

#define ClusResGroup_get_State(This,dwState)	\
    (This)->lpVtbl -> get_State(This,dwState)

#define ClusResGroup_get_OwnerNode(This,ppOwnerNode)	\
    (This)->lpVtbl -> get_OwnerNode(This,ppOwnerNode)

#define ClusResGroup_get_Resources(This,ppClusterResources)	\
    (This)->lpVtbl -> get_Resources(This,ppClusterResources)

#define ClusResGroup_get_PreferredOwnerNodes(This,ppOwnerNodes)	\
    (This)->lpVtbl -> get_PreferredOwnerNodes(This,ppOwnerNodes)

#define ClusResGroup_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define ClusResGroup_Online(This,pDestinationNode)	\
    (This)->lpVtbl -> Online(This,pDestinationNode)

#define ClusResGroup_Move(This,pDestinationNode)	\
    (This)->lpVtbl -> Move(This,pDestinationNode)

#define ClusResGroup_Offline(This)	\
    (This)->lpVtbl -> Offline(This)

#define ClusResGroup_get_CommonProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_CommonProperties(This,ppProperties)

#define ClusResGroup_get_PrivateProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_PrivateProperties(This,ppProperties)

#define ClusResGroup_get_CommonROProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_CommonROProperties(This,ppProperties)

#define ClusResGroup_get_PrivateROProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_PrivateROProperties(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_Handle_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *phandle);


void __RPC_STUB ClusResGroup_get_Handle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ClusResGroup_put_Name_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [in] */ BSTR bstrGroupName);


void __RPC_STUB ClusResGroup_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_Name_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrGroupName);


void __RPC_STUB ClusResGroup_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_State_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *dwState);


void __RPC_STUB ClusResGroup_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_OwnerNode_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ ClusNode __RPC_FAR *__RPC_FAR *ppOwnerNode);


void __RPC_STUB ClusResGroup_get_OwnerNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_Resources_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ ClusResources __RPC_FAR *__RPC_FAR *ppClusterResources);


void __RPC_STUB ClusResGroup_get_Resources_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_PreferredOwnerNodes_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ ClusNodes __RPC_FAR *__RPC_FAR *ppOwnerNodes);


void __RPC_STUB ClusResGroup_get_PreferredOwnerNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResGroup_Delete_Proxy( 
    ClusResGroup __RPC_FAR * This);


void __RPC_STUB ClusResGroup_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResGroup_Online_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [optional][in] */ ClusNode __RPC_FAR *pDestinationNode);


void __RPC_STUB ClusResGroup_Online_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResGroup_Move_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [optional][in] */ ClusNode __RPC_FAR *pDestinationNode);


void __RPC_STUB ClusResGroup_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResGroup_Offline_Proxy( 
    ClusResGroup __RPC_FAR * This);


void __RPC_STUB ClusResGroup_Offline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_CommonProperties_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResGroup_get_CommonProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_PrivateProperties_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResGroup_get_PrivateProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_CommonROProperties_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResGroup_get_CommonROProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroup_get_PrivateROProperties_Proxy( 
    ClusResGroup __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResGroup_get_PrivateROProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusResGroup_INTERFACE_DEFINED__ */


#ifndef __ClusResGroups_INTERFACE_DEFINED__
#define __ClusResGroups_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusResGroups
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusResGroups;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusResGroups : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pnCount) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusResGroup __RPC_FAR *__RPC_FAR *ppResourceGroup) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateItem( 
            /* [in] */ BSTR bstrResourceGroupName,
            /* [retval][out] */ ClusResGroup __RPC_FAR *__RPC_FAR *ppResourceGroup) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ ClusResGroup __RPC_FAR *pResourceGroup) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusResGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusResGroups __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusResGroups __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusResGroups __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusResGroups __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusResGroups __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusResGroups __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusResGroups __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ClusResGroups __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnCount);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ClusResGroups __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusResGroup __RPC_FAR *__RPC_FAR *ppResourceGroup);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ClusResGroups __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateItem )( 
            ClusResGroups __RPC_FAR * This,
            /* [in] */ BSTR bstrResourceGroupName,
            /* [retval][out] */ ClusResGroup __RPC_FAR *__RPC_FAR *ppResourceGroup);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            ClusResGroups __RPC_FAR * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            ClusResGroups __RPC_FAR * This,
            /* [in] */ ClusResGroup __RPC_FAR *pResourceGroup);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveItem )( 
            ClusResGroups __RPC_FAR * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ClusResGroups __RPC_FAR * This);
        
        END_INTERFACE
    } ClusResGroupsVtbl;

    interface ClusResGroups
    {
        CONST_VTBL struct ClusResGroupsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusResGroups_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusResGroups_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusResGroups_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusResGroups_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusResGroups_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusResGroups_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusResGroups_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusResGroups_get_Count(This,pnCount)	\
    (This)->lpVtbl -> get_Count(This,pnCount)

#define ClusResGroups_get_Item(This,varIndex,ppResourceGroup)	\
    (This)->lpVtbl -> get_Item(This,varIndex,ppResourceGroup)

#define ClusResGroups_get__NewEnum(This,ppEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnum)

#define ClusResGroups_CreateItem(This,bstrResourceGroupName,ppResourceGroup)	\
    (This)->lpVtbl -> CreateItem(This,bstrResourceGroupName,ppResourceGroup)

#define ClusResGroups_DeleteItem(This,varIndex)	\
    (This)->lpVtbl -> DeleteItem(This,varIndex)

#define ClusResGroups_AddItem(This,pResourceGroup)	\
    (This)->lpVtbl -> AddItem(This,pResourceGroup)

#define ClusResGroups_RemoveItem(This,varIndex)	\
    (This)->lpVtbl -> RemoveItem(This,varIndex)

#define ClusResGroups_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResGroups_get_Count_Proxy( 
    ClusResGroups __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnCount);


void __RPC_STUB ClusResGroups_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ClusResGroups_get_Item_Proxy( 
    ClusResGroups __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ ClusResGroup __RPC_FAR *__RPC_FAR *ppResourceGroup);


void __RPC_STUB ClusResGroups_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ClusResGroups_get__NewEnum_Proxy( 
    ClusResGroups __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB ClusResGroups_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResGroups_CreateItem_Proxy( 
    ClusResGroups __RPC_FAR * This,
    /* [in] */ BSTR bstrResourceGroupName,
    /* [retval][out] */ ClusResGroup __RPC_FAR *__RPC_FAR *ppResourceGroup);


void __RPC_STUB ClusResGroups_CreateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResGroups_DeleteItem_Proxy( 
    ClusResGroups __RPC_FAR * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB ClusResGroups_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResGroups_AddItem_Proxy( 
    ClusResGroups __RPC_FAR * This,
    /* [in] */ ClusResGroup __RPC_FAR *pResourceGroup);


void __RPC_STUB ClusResGroups_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResGroups_RemoveItem_Proxy( 
    ClusResGroups __RPC_FAR * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB ClusResGroups_RemoveItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResGroups_Refresh_Proxy( 
    ClusResGroups __RPC_FAR * This);


void __RPC_STUB ClusResGroups_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusResGroups_INTERFACE_DEFINED__ */


#ifndef __ClusResource_INTERFACE_DEFINED__
#define __ClusResource_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusResource
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusResource : public IDispatch
    {
    public:
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Handle( 
            /* [retval][out] */ LONG __RPC_FAR *phandle) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrResourceName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrResourceName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ LONG __RPC_FAR *dwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BecomeQuorumResource( 
            /* [in] */ BSTR bstrDevicePath,
            /* [in] */ long lMaxLogSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Fail( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Online( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Offline( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeResourceGroup( 
            /* [in] */ ClusResGroup __RPC_FAR *pResourceGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddResourceNode( 
            /* [in] */ ClusNode __RPC_FAR *pNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveResourceNode( 
            /* [in] */ ClusNode __RPC_FAR *pNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddResourceDependency( 
            /* [in] */ ClusResource __RPC_FAR *pResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveResourceDependency( 
            /* [in] */ ClusResource __RPC_FAR *pResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanResourceBeDependent( 
            /* [in] */ ClusResource __RPC_FAR *pResource,
            /* [retval][out] */ BOOL __RPC_FAR *bDependent) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AllowedNodes( 
            /* [retval][out] */ ClusNodes __RPC_FAR *__RPC_FAR *ppNodes) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Dependencies( 
            /* [retval][out] */ ClusResources __RPC_FAR *__RPC_FAR *ppResources) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommonProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommonROProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateROProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusResource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusResource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusResource __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Handle )( 
            ClusResource __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *phandle);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ BSTR bstrResourceName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ClusResource __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrResourceName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ClusResource __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *dwState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BecomeQuorumResource )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ BSTR bstrDevicePath,
            /* [in] */ long lMaxLogSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ClusResource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Fail )( 
            ClusResource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Online )( 
            ClusResource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Offline )( 
            ClusResource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeResourceGroup )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ ClusResGroup __RPC_FAR *pResourceGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddResourceNode )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ ClusNode __RPC_FAR *pNode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveResourceNode )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ ClusNode __RPC_FAR *pNode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddResourceDependency )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ ClusResource __RPC_FAR *pResource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveResourceDependency )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ ClusResource __RPC_FAR *pResource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanResourceBeDependent )( 
            ClusResource __RPC_FAR * This,
            /* [in] */ ClusResource __RPC_FAR *pResource,
            /* [retval][out] */ BOOL __RPC_FAR *bDependent);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowedNodes )( 
            ClusResource __RPC_FAR * This,
            /* [retval][out] */ ClusNodes __RPC_FAR *__RPC_FAR *ppNodes);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Dependencies )( 
            ClusResource __RPC_FAR * This,
            /* [retval][out] */ ClusResources __RPC_FAR *__RPC_FAR *ppResources);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommonProperties )( 
            ClusResource __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrivateProperties )( 
            ClusResource __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommonROProperties )( 
            ClusResource __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrivateROProperties )( 
            ClusResource __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ClusResourceVtbl;

    interface ClusResource
    {
        CONST_VTBL struct ClusResourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusResource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusResource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusResource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusResource_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusResource_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusResource_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusResource_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusResource_get_Handle(This,phandle)	\
    (This)->lpVtbl -> get_Handle(This,phandle)

#define ClusResource_put_Name(This,bstrResourceName)	\
    (This)->lpVtbl -> put_Name(This,bstrResourceName)

#define ClusResource_get_Name(This,pbstrResourceName)	\
    (This)->lpVtbl -> get_Name(This,pbstrResourceName)

#define ClusResource_get_State(This,dwState)	\
    (This)->lpVtbl -> get_State(This,dwState)

#define ClusResource_BecomeQuorumResource(This,bstrDevicePath,lMaxLogSize)	\
    (This)->lpVtbl -> BecomeQuorumResource(This,bstrDevicePath,lMaxLogSize)

#define ClusResource_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define ClusResource_Fail(This)	\
    (This)->lpVtbl -> Fail(This)

#define ClusResource_Online(This)	\
    (This)->lpVtbl -> Online(This)

#define ClusResource_Offline(This)	\
    (This)->lpVtbl -> Offline(This)

#define ClusResource_ChangeResourceGroup(This,pResourceGroup)	\
    (This)->lpVtbl -> ChangeResourceGroup(This,pResourceGroup)

#define ClusResource_AddResourceNode(This,pNode)	\
    (This)->lpVtbl -> AddResourceNode(This,pNode)

#define ClusResource_RemoveResourceNode(This,pNode)	\
    (This)->lpVtbl -> RemoveResourceNode(This,pNode)

#define ClusResource_AddResourceDependency(This,pResource)	\
    (This)->lpVtbl -> AddResourceDependency(This,pResource)

#define ClusResource_RemoveResourceDependency(This,pResource)	\
    (This)->lpVtbl -> RemoveResourceDependency(This,pResource)

#define ClusResource_CanResourceBeDependent(This,pResource,bDependent)	\
    (This)->lpVtbl -> CanResourceBeDependent(This,pResource,bDependent)

#define ClusResource_get_AllowedNodes(This,ppNodes)	\
    (This)->lpVtbl -> get_AllowedNodes(This,ppNodes)

#define ClusResource_get_Dependencies(This,ppResources)	\
    (This)->lpVtbl -> get_Dependencies(This,ppResources)

#define ClusResource_get_CommonProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_CommonProperties(This,ppProperties)

#define ClusResource_get_PrivateProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_PrivateProperties(This,ppProperties)

#define ClusResource_get_CommonROProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_CommonROProperties(This,ppProperties)

#define ClusResource_get_PrivateROProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_PrivateROProperties(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE ClusResource_get_Handle_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *phandle);


void __RPC_STUB ClusResource_get_Handle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ClusResource_put_Name_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [in] */ BSTR bstrResourceName);


void __RPC_STUB ClusResource_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResource_get_Name_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrResourceName);


void __RPC_STUB ClusResource_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResource_get_State_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *dwState);


void __RPC_STUB ClusResource_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_BecomeQuorumResource_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [in] */ BSTR bstrDevicePath,
    /* [in] */ long lMaxLogSize);


void __RPC_STUB ClusResource_BecomeQuorumResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_Delete_Proxy( 
    ClusResource __RPC_FAR * This);


void __RPC_STUB ClusResource_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_Fail_Proxy( 
    ClusResource __RPC_FAR * This);


void __RPC_STUB ClusResource_Fail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_Online_Proxy( 
    ClusResource __RPC_FAR * This);


void __RPC_STUB ClusResource_Online_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_Offline_Proxy( 
    ClusResource __RPC_FAR * This);


void __RPC_STUB ClusResource_Offline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_ChangeResourceGroup_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [in] */ ClusResGroup __RPC_FAR *pResourceGroup);


void __RPC_STUB ClusResource_ChangeResourceGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_AddResourceNode_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [in] */ ClusNode __RPC_FAR *pNode);


void __RPC_STUB ClusResource_AddResourceNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_RemoveResourceNode_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [in] */ ClusNode __RPC_FAR *pNode);


void __RPC_STUB ClusResource_RemoveResourceNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_AddResourceDependency_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [in] */ ClusResource __RPC_FAR *pResource);


void __RPC_STUB ClusResource_AddResourceDependency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_RemoveResourceDependency_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [in] */ ClusResource __RPC_FAR *pResource);


void __RPC_STUB ClusResource_RemoveResourceDependency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResource_CanResourceBeDependent_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [in] */ ClusResource __RPC_FAR *pResource,
    /* [retval][out] */ BOOL __RPC_FAR *bDependent);


void __RPC_STUB ClusResource_CanResourceBeDependent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResource_get_AllowedNodes_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [retval][out] */ ClusNodes __RPC_FAR *__RPC_FAR *ppNodes);


void __RPC_STUB ClusResource_get_AllowedNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResource_get_Dependencies_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [retval][out] */ ClusResources __RPC_FAR *__RPC_FAR *ppResources);


void __RPC_STUB ClusResource_get_Dependencies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResource_get_CommonProperties_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResource_get_CommonProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResource_get_PrivateProperties_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResource_get_PrivateProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResource_get_CommonROProperties_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResource_get_CommonROProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResource_get_PrivateROProperties_Proxy( 
    ClusResource __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResource_get_PrivateROProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusResource_INTERFACE_DEFINED__ */


#ifndef __ClusResources_INTERFACE_DEFINED__
#define __ClusResources_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusResources
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusResources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusResources : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pnCount) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusResource __RPC_FAR *__RPC_FAR *ppClusterResource) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateItem( 
            /* [in] */ BSTR bstrResourceName,
            /* [in] */ BSTR bstrResourceType,
            /* [in] */ long dwFlags,
            /* [retval][out] */ ClusResource __RPC_FAR *__RPC_FAR *ppClusterResource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ ClusResource __RPC_FAR *pResource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusResourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusResources __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusResources __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusResources __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusResources __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusResources __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusResources __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusResources __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ClusResources __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnCount);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ClusResources __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusResource __RPC_FAR *__RPC_FAR *ppClusterResource);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ClusResources __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateItem )( 
            ClusResources __RPC_FAR * This,
            /* [in] */ BSTR bstrResourceName,
            /* [in] */ BSTR bstrResourceType,
            /* [in] */ long dwFlags,
            /* [retval][out] */ ClusResource __RPC_FAR *__RPC_FAR *ppClusterResource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            ClusResources __RPC_FAR * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            ClusResources __RPC_FAR * This,
            /* [in] */ ClusResource __RPC_FAR *pResource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveItem )( 
            ClusResources __RPC_FAR * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ClusResources __RPC_FAR * This);
        
        END_INTERFACE
    } ClusResourcesVtbl;

    interface ClusResources
    {
        CONST_VTBL struct ClusResourcesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusResources_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusResources_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusResources_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusResources_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusResources_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusResources_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusResources_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusResources_get_Count(This,pnCount)	\
    (This)->lpVtbl -> get_Count(This,pnCount)

#define ClusResources_get_Item(This,varIndex,ppClusterResource)	\
    (This)->lpVtbl -> get_Item(This,varIndex,ppClusterResource)

#define ClusResources_get__NewEnum(This,ppEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnum)

#define ClusResources_CreateItem(This,bstrResourceName,bstrResourceType,dwFlags,ppClusterResource)	\
    (This)->lpVtbl -> CreateItem(This,bstrResourceName,bstrResourceType,dwFlags,ppClusterResource)

#define ClusResources_DeleteItem(This,varIndex)	\
    (This)->lpVtbl -> DeleteItem(This,varIndex)

#define ClusResources_AddItem(This,pResource)	\
    (This)->lpVtbl -> AddItem(This,pResource)

#define ClusResources_RemoveItem(This,varIndex)	\
    (This)->lpVtbl -> RemoveItem(This,varIndex)

#define ClusResources_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResources_get_Count_Proxy( 
    ClusResources __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnCount);


void __RPC_STUB ClusResources_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ClusResources_get_Item_Proxy( 
    ClusResources __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ ClusResource __RPC_FAR *__RPC_FAR *ppClusterResource);


void __RPC_STUB ClusResources_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ClusResources_get__NewEnum_Proxy( 
    ClusResources __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB ClusResources_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResources_CreateItem_Proxy( 
    ClusResources __RPC_FAR * This,
    /* [in] */ BSTR bstrResourceName,
    /* [in] */ BSTR bstrResourceType,
    /* [in] */ long dwFlags,
    /* [retval][out] */ ClusResource __RPC_FAR *__RPC_FAR *ppClusterResource);


void __RPC_STUB ClusResources_CreateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResources_DeleteItem_Proxy( 
    ClusResources __RPC_FAR * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB ClusResources_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResources_AddItem_Proxy( 
    ClusResources __RPC_FAR * This,
    /* [in] */ ClusResource __RPC_FAR *pResource);


void __RPC_STUB ClusResources_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResources_RemoveItem_Proxy( 
    ClusResources __RPC_FAR * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB ClusResources_RemoveItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResources_Refresh_Proxy( 
    ClusResources __RPC_FAR * This);


void __RPC_STUB ClusResources_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusResources_INTERFACE_DEFINED__ */


#ifndef __ClusResType_INTERFACE_DEFINED__
#define __ClusResType_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusResType
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusResType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusResType : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *strTypeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommonProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommonROProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateROProperties( 
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusResTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusResType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusResType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusResType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusResType __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusResType __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusResType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusResType __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ClusResType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *strTypeName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ClusResType __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommonProperties )( 
            ClusResType __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrivateProperties )( 
            ClusResType __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommonROProperties )( 
            ClusResType __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrivateROProperties )( 
            ClusResType __RPC_FAR * This,
            /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ClusResTypeVtbl;

    interface ClusResType
    {
        CONST_VTBL struct ClusResTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusResType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusResType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusResType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusResType_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusResType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusResType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusResType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusResType_get_Name(This,strTypeName)	\
    (This)->lpVtbl -> get_Name(This,strTypeName)

#define ClusResType_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define ClusResType_get_CommonProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_CommonProperties(This,ppProperties)

#define ClusResType_get_PrivateProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_PrivateProperties(This,ppProperties)

#define ClusResType_get_CommonROProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_CommonROProperties(This,ppProperties)

#define ClusResType_get_PrivateROProperties(This,ppProperties)	\
    (This)->lpVtbl -> get_PrivateROProperties(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResType_get_Name_Proxy( 
    ClusResType __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *strTypeName);


void __RPC_STUB ClusResType_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ClusResType_Delete_Proxy( 
    ClusResType __RPC_FAR * This);


void __RPC_STUB ClusResType_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResType_get_CommonProperties_Proxy( 
    ClusResType __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResType_get_CommonProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResType_get_PrivateProperties_Proxy( 
    ClusResType __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResType_get_PrivateProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResType_get_CommonROProperties_Proxy( 
    ClusResType __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResType_get_CommonROProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResType_get_PrivateROProperties_Proxy( 
    ClusResType __RPC_FAR * This,
    /* [retval][out] */ ClusProperties __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ClusResType_get_PrivateROProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusResType_INTERFACE_DEFINED__ */


#ifndef __ClusResTypes_INTERFACE_DEFINED__
#define __ClusResTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusResTypes
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusResTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusResTypes : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pnCount) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusResType __RPC_FAR *__RPC_FAR *ppResourceType) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateItem( 
            /* [in] */ BSTR bstrResourceTypeName,
            /* [in] */ BSTR bstrDisplayName,
            /* [in] */ BSTR bstrResourceTypeDll,
            /* [in] */ LONG dwLooksAlivePollInterval,
            /* [in] */ LONG dwIsAlivePollInterval,
            /* [retval][out] */ ClusResType __RPC_FAR *__RPC_FAR *ppResourceType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ ClusResType __RPC_FAR *pResourceType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusResTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusResTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusResTypes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusResTypes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusResTypes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusResTypes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusResTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusResTypes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ClusResTypes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnCount);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ClusResTypes __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusResType __RPC_FAR *__RPC_FAR *ppResourceType);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ClusResTypes __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateItem )( 
            ClusResTypes __RPC_FAR * This,
            /* [in] */ BSTR bstrResourceTypeName,
            /* [in] */ BSTR bstrDisplayName,
            /* [in] */ BSTR bstrResourceTypeDll,
            /* [in] */ LONG dwLooksAlivePollInterval,
            /* [in] */ LONG dwIsAlivePollInterval,
            /* [retval][out] */ ClusResType __RPC_FAR *__RPC_FAR *ppResourceType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            ClusResTypes __RPC_FAR * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            ClusResTypes __RPC_FAR * This,
            /* [in] */ ClusResType __RPC_FAR *pResourceType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveItem )( 
            ClusResTypes __RPC_FAR * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ClusResTypes __RPC_FAR * This);
        
        END_INTERFACE
    } ClusResTypesVtbl;

    interface ClusResTypes
    {
        CONST_VTBL struct ClusResTypesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusResTypes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusResTypes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusResTypes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusResTypes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusResTypes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusResTypes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusResTypes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusResTypes_get_Count(This,pnCount)	\
    (This)->lpVtbl -> get_Count(This,pnCount)

#define ClusResTypes_get_Item(This,varIndex,ppResourceType)	\
    (This)->lpVtbl -> get_Item(This,varIndex,ppResourceType)

#define ClusResTypes_get__NewEnum(This,ppEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnum)

#define ClusResTypes_CreateItem(This,bstrResourceTypeName,bstrDisplayName,bstrResourceTypeDll,dwLooksAlivePollInterval,dwIsAlivePollInterval,ppResourceType)	\
    (This)->lpVtbl -> CreateItem(This,bstrResourceTypeName,bstrDisplayName,bstrResourceTypeDll,dwLooksAlivePollInterval,dwIsAlivePollInterval,ppResourceType)

#define ClusResTypes_DeleteItem(This,varIndex)	\
    (This)->lpVtbl -> DeleteItem(This,varIndex)

#define ClusResTypes_AddItem(This,pResourceType)	\
    (This)->lpVtbl -> AddItem(This,pResourceType)

#define ClusResTypes_RemoveItem(This,varIndex)	\
    (This)->lpVtbl -> RemoveItem(This,varIndex)

#define ClusResTypes_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE ClusResTypes_get_Count_Proxy( 
    ClusResTypes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnCount);


void __RPC_STUB ClusResTypes_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ClusResTypes_get_Item_Proxy( 
    ClusResTypes __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ ClusResType __RPC_FAR *__RPC_FAR *ppResourceType);


void __RPC_STUB ClusResTypes_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ClusResTypes_get__NewEnum_Proxy( 
    ClusResTypes __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB ClusResTypes_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResTypes_CreateItem_Proxy( 
    ClusResTypes __RPC_FAR * This,
    /* [in] */ BSTR bstrResourceTypeName,
    /* [in] */ BSTR bstrDisplayName,
    /* [in] */ BSTR bstrResourceTypeDll,
    /* [in] */ LONG dwLooksAlivePollInterval,
    /* [in] */ LONG dwIsAlivePollInterval,
    /* [retval][out] */ ClusResType __RPC_FAR *__RPC_FAR *ppResourceType);


void __RPC_STUB ClusResTypes_CreateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResTypes_DeleteItem_Proxy( 
    ClusResTypes __RPC_FAR * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB ClusResTypes_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResTypes_AddItem_Proxy( 
    ClusResTypes __RPC_FAR * This,
    /* [in] */ ClusResType __RPC_FAR *pResourceType);


void __RPC_STUB ClusResTypes_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResTypes_RemoveItem_Proxy( 
    ClusResTypes __RPC_FAR * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB ClusResTypes_RemoveItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusResTypes_Refresh_Proxy( 
    ClusResTypes __RPC_FAR * This);


void __RPC_STUB ClusResTypes_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusResTypes_INTERFACE_DEFINED__ */


#ifndef __ClusProperty_INTERFACE_DEFINED__
#define __ClusProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusProperty
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusProperty : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarValue) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT varValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusProperty __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusProperty __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusProperty __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ClusProperty __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ClusProperty __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ClusProperty __RPC_FAR * This,
            /* [in] */ VARIANT varValue);
        
        END_INTERFACE
    } ClusPropertyVtbl;

    interface ClusProperty
    {
        CONST_VTBL struct ClusPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusProperty_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusProperty_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define ClusProperty_get_Value(This,pvarValue)	\
    (This)->lpVtbl -> get_Value(This,pvarValue)

#define ClusProperty_put_Value(This,varValue)	\
    (This)->lpVtbl -> put_Value(This,varValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE ClusProperty_get_Name_Proxy( 
    ClusProperty __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB ClusProperty_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ClusProperty_get_Value_Proxy( 
    ClusProperty __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarValue);


void __RPC_STUB ClusProperty_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ClusProperty_put_Value_Proxy( 
    ClusProperty __RPC_FAR * This,
    /* [in] */ VARIANT varValue);


void __RPC_STUB ClusProperty_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusProperty_INTERFACE_DEFINED__ */


#ifndef __ClusProperties_INTERFACE_DEFINED__
#define __ClusProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ClusProperties
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ClusProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ClusProperties : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pnCount) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusProperty __RPC_FAR *__RPC_FAR *ppProperty) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT varValue,
            /* [retval][out] */ ClusProperty __RPC_FAR *__RPC_FAR *pProperty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SaveChanges( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ClusPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ClusProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ClusProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ClusProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ClusProperties __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ClusProperties __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ClusProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ClusProperties __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ClusProperties __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnCount);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ClusProperties __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ClusProperty __RPC_FAR *__RPC_FAR *ppProperty);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ClusProperties __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            ClusProperties __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT varValue,
            /* [retval][out] */ ClusProperty __RPC_FAR *__RPC_FAR *pProperty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            ClusProperties __RPC_FAR * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ClusProperties __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            ClusProperties __RPC_FAR * This);
        
        END_INTERFACE
    } ClusPropertiesVtbl;

    interface ClusProperties
    {
        CONST_VTBL struct ClusPropertiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ClusProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ClusProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ClusProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ClusProperties_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ClusProperties_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ClusProperties_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ClusProperties_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ClusProperties_get_Count(This,pnCount)	\
    (This)->lpVtbl -> get_Count(This,pnCount)

#define ClusProperties_get_Item(This,varIndex,ppProperty)	\
    (This)->lpVtbl -> get_Item(This,varIndex,ppProperty)

#define ClusProperties_get__NewEnum(This,ppEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnum)

#define ClusProperties_Add(This,bstrName,varValue,pProperty)	\
    (This)->lpVtbl -> Add(This,bstrName,varValue,pProperty)

#define ClusProperties_Remove(This,varIndex)	\
    (This)->lpVtbl -> Remove(This,varIndex)

#define ClusProperties_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define ClusProperties_SaveChanges(This)	\
    (This)->lpVtbl -> SaveChanges(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE ClusProperties_get_Count_Proxy( 
    ClusProperties __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnCount);


void __RPC_STUB ClusProperties_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ClusProperties_get_Item_Proxy( 
    ClusProperties __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ ClusProperty __RPC_FAR *__RPC_FAR *ppProperty);


void __RPC_STUB ClusProperties_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ClusProperties_get__NewEnum_Proxy( 
    ClusProperties __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB ClusProperties_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusProperties_Add_Proxy( 
    ClusProperties __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ VARIANT varValue,
    /* [retval][out] */ ClusProperty __RPC_FAR *__RPC_FAR *pProperty);


void __RPC_STUB ClusProperties_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusProperties_Remove_Proxy( 
    ClusProperties __RPC_FAR * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB ClusProperties_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusProperties_Refresh_Proxy( 
    ClusProperties __RPC_FAR * This);


void __RPC_STUB ClusProperties_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ClusProperties_SaveChanges_Proxy( 
    ClusProperties __RPC_FAR * This);


void __RPC_STUB ClusProperties_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ClusProperties_INTERFACE_DEFINED__ */



#ifndef __MSClusterLib_LIBRARY_DEFINED__
#define __MSClusterLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSClusterLib
 * at Fri Aug 08 11:36:24 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_MSClusterLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Application;

class Application;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Cluster;

class Cluster;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ClusterDomain;

class ClusterDomain;
#endif
#endif /* __MSClusterLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SmbSmpEx.rc
//
#define IDD_PP_RESOURCE_PARAMETERS      133
#define IDD_WIZ_RESOURCE_PARAMETERS     134
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_RESPARAMS_SHARENAME_LABEL 1070
#define IDC_PP_RESPARAMS_SHARENAME       1071
#define IDC_PP_RESPARAMS_PATH_LABEL 1072
#define IDC_PP_RESPARAMS_PATH       1073
#define IDC_PP_RESPARAMS_REMARK_LABEL 1074
#define IDC_PP_RESPARAMS_REMARK       1075
#define IDS_CLUADMEX_COMOBJ_DESC        31100
#define IDS_APPLY_PARAM_CHANGES_ERROR   31101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1110
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\resprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 <company name>
//
//	Module Name:
//		ResProp.h
//
//	Abstract:
//		Definition of the resource extension property page classes.
//
//	Implementation File:
//		ResProp.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESPROP_H_
#define _RESPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResourceParamPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CResourceParamPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CResourceParamPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CResourceParamPage)

// Construction
public:
	CResourceParamPage(void);
	virtual ~CResourceParamPage(void);

	// Second phase construction.
	BOOL			BInit(IN CExtObject * peo);

// Dialog Data
	//{{AFX_DATA(CResourceParamPage)
	enum { IDD = IDD_PP_RESOURCE_PARAMETERS };
	CString	m_strShareName;
	CString	m_strPath;
	CString	m_strRemark;
	//}}AFX_DATA
	CString	m_strPrevShareName;
	CString	m_strPrevPath;
	CString	m_strPrevRemark;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResourceParamPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL		BApplyChanges(void);

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CResourceParamPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CResourceParamPage

/////////////////////////////////////////////////////////////////////////////

#endif // _RESPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\rm_rpc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Tue Mar 04 14:21:59 1997
 */
/* Compiler settings for rm_rpc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __rm_rpc_h__
#define __rm_rpc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Tue Mar 04 14:21:59 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#define _RESAPI_


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE s___MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __resmon_INTERFACE_DEFINED__
#define __resmon_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: resmon
 * at Tue Mar 04 14:21:59 1997
 * using MIDL 3.00.44
 ****************************************/
/* [explicit_handle][version][uuid] */ 


typedef /* [context_handle] */ void __RPC_FAR *RPC_RESID;

/* client prototype */
RPC_RESID RmCreateResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR DllName,
    /* [in] */ LPCWSTR ResourceType,
    /* [in] */ LPCWSTR ResourceName,
    /* [in] */ DWORD LooksAlivePoll,
    /* [in] */ DWORD IsAlivePoll,
    /* [in] */ DWORD NotifyKey,
    /* [in] */ DWORD PendingTimeout);
/* server prototype */
RPC_RESID s_RmCreateResource( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR DllName,
    /* [in] */ LPCWSTR ResourceType,
    /* [in] */ LPCWSTR ResourceName,
    /* [in] */ DWORD LooksAlivePoll,
    /* [in] */ DWORD IsAlivePoll,
    /* [in] */ DWORD NotifyKey,
    /* [in] */ DWORD PendingTimeout);

/* client prototype */
void RmCloseResource( 
    /* [out][in] */ RPC_RESID __RPC_FAR *ResourceId);
/* server prototype */
void s_RmCloseResource( 
    /* [out][in] */ RPC_RESID __RPC_FAR *ResourceId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t RmChangeResourceParams( 
    /* [in] */ RPC_RESID ResourceId,
    /* [in] */ DWORD LooksAlivePoll,
    /* [in] */ DWORD IsAlivePoll,
    /* [in] */ DWORD PendingTimeout);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_RmChangeResourceParams( 
    /* [in] */ RPC_RESID ResourceId,
    /* [in] */ DWORD LooksAlivePoll,
    /* [in] */ DWORD IsAlivePoll,
    /* [in] */ DWORD PendingTimeout);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t RmOnlineResource( 
    /* [in] */ RPC_RESID ResourceId,
    /* [out] */ DWORD __RPC_FAR *pdwState);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_RmOnlineResource( 
    /* [in] */ RPC_RESID ResourceId,
    /* [out] */ DWORD __RPC_FAR *pdwState);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t RmOfflineResource( 
    /* [in] */ RPC_RESID ResourceId,
    /* [out] */ DWORD __RPC_FAR *pdwState);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_RmOfflineResource( 
    /* [in] */ RPC_RESID ResourceId,
    /* [out] */ DWORD __RPC_FAR *pdwState);

/* client prototype */
void RmTerminateResource( 
    /* [in] */ RPC_RESID ResourceId);
/* server prototype */
void s_RmTerminateResource( 
    /* [in] */ RPC_RESID ResourceId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t RmArbitrateResource( 
    /* [in] */ RPC_RESID ResourceId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_RmArbitrateResource( 
    /* [in] */ RPC_RESID ResourceId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t RmReleaseResource( 
    /* [in] */ RPC_RESID ResourceId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_RmReleaseResource( 
    /* [in] */ RPC_RESID ResourceId);

/* client prototype */
BOOL RmNotifyChanges( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DWORD __RPC_FAR *lpNotifyKey,
    /* [out] */ DWORD __RPC_FAR *lpNotifyEvent,
    /* [out] */ DWORD __RPC_FAR *lpCurrentState);
/* server prototype */
BOOL s_RmNotifyChanges( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DWORD __RPC_FAR *lpNotifyKey,
    /* [out] */ DWORD __RPC_FAR *lpNotifyEvent,
    /* [out] */ DWORD __RPC_FAR *lpCurrentState);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t RmFailResource( 
    /* [in] */ RPC_RESID ResourceId);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_RmFailResource( 
    /* [in] */ RPC_RESID ResourceId);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t RmShutdownProcess( 
    /* [in] */ handle_t IDL_handle);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_RmShutdownProcess( 
    /* [in] */ handle_t IDL_handle);

/* client prototype */
/* [fault_status][comm_status] */ error_status_t RmResourceControl( 
    /* [in] */ RPC_RESID ResourceId,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);
/* server prototype */
/* [fault_status][comm_status] */ error_status_t s_RmResourceControl( 
    /* [in] */ RPC_RESID ResourceId,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);

/* client prototype */
error_status_t RmResourceTypeControl( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceTypeName,
    /* [in] */ LPCWSTR DllName,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);
/* server prototype */
error_status_t s_RmResourceTypeControl( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ LPCWSTR ResourceTypeName,
    /* [in] */ LPCWSTR DllName,
    /* [in] */ DWORD ControlCode,
    /* [size_is][unique][in] */ UCHAR __RPC_FAR *InBuffer,
    /* [in] */ DWORD InBufferSize,
    /* [length_is][size_is][out] */ UCHAR __RPC_FAR *OutBuffer,
    /* [in] */ DWORD OutBufferSize,
    /* [out] */ LPDWORD BytesReturned,
    /* [out] */ LPDWORD Required);



extern RPC_IF_HANDLE resmon_v1_0_c_ifspec;
extern RPC_IF_HANDLE s_resmon_v1_0_s_ifspec;
#endif /* __resmon_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

void __RPC_USER RPC_RESID_rundown( RPC_RESID );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\smbsmpex.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 <company name>
//
//	Module Name:
//		SmbSmpEx.h
//
//	Abstract:
//		Global definitions across the DLL.
//
//	Implementation File:
//		SmbSmpEx.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SMBSMPEX_H_
#define _SMBSMPEX_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_PARAMETERS L"Parameters"
#define REGPARAM_RESOURCE_SHARENAME L"ShareName"
#define REGPARAM_RESOURCE_PATH L"Path"
#define REGPARAM_RESOURCE_REMARK L"Remark"

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

// Defined in Extensn.cpp
extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;

/////////////////////////////////////////////////////////////////////////////

#endif // _SMBSMPEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\resmonp.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    resmonp.h

Abstract:

    Private header file for the Resource Monitor component

Author:

    John Vert (jvert) 30-Nov-1995

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "rm_rpc.h"
#include "monmsg.h"

#define LOG_CURRENT_MODULE 0x0800

#define RESMON_MODULE_EVNTLIST 1
#define RESMON_MODULE_NOTIFY   2
#define RESMON_MODULE_POLLER   3
#define RESMON_MODULE_PROPERTY 4
#define RESMON_MODULE_RESLIST  5
#define RESMON_MODULE_RESMON   6
#define RESMON_MODULE_RMAPI    7

//
// Private type definitions and structures
//

#define RmDbgPrint ClRtlLogPrint
//
// Define the maximum number of resources handled per thread.
// (This value must be smaller than MAXIMUM_WAIT_OBJECTS-1!)
//
#define MAX_RESOURCES_PER_THREAD 16

#define MAX_HANDLES_PER_THREAD (MAX_RESOURCES_PER_THREAD+1)

//
// Define the maximum number of threads.
// (This value can be up to MAXIMUM_WAIT_OBJECTS, however the first two
//  entries are taken by events, so in fact we have 2 less threads available).
//
#define MAX_THREADS (MAXIMUM_WAIT_OBJECTS)

//
// Define structure and flags used for each resource entry
//
#define RESOURCE_SIGNATURE 'crsR'

typedef struct *_PPOLL_EVENT_LIST;

//
// Flags
//
#define RESOURCE_INSERTED 1

typedef struct _RESOURCE {
    ULONG Signature;                // 'Rsrc'
    ULONG Flags;
    LIST_ENTRY ListEntry;           // for linking onto monitoring list
    LPWSTR DllName;
    LPWSTR ResourceType;
    LPWSTR ResourceId;
    LPWSTR ResourceName;
    DWORD LooksAlivePollInterval;
    DWORD IsAlivePollInterval;
    HINSTANCE Dll;                  // handle to resource's DLL
    RESID Id;
    HANDLE  EventHandle;            // async error notification handle
    POPEN_ROUTINE Open;
    PCLOSE_ROUTINE Close;
    PONLINE_ROUTINE Online;
    POFFLINE_ROUTINE Offline;
    PTERMINATE_ROUTINE Terminate;
    PIS_ALIVE_ROUTINE IsAlive;
    PLOOKS_ALIVE_ROUTINE LooksAlive;
    PARBITRATE_ROUTINE Arbitrate;
    PRELEASE_ROUTINE Release;
    PRESOURCE_CONTROL_ROUTINE ResourceControl;
    PRESOURCE_TYPE_CONTROL_ROUTINE ResourceTypeControl;
    CLUSTER_RESOURCE_STATE State;
    ULONG IsAliveCount;
    ULONG IsAliveRollover;
    DWORD NotifyKey;
    _PPOLL_EVENT_LIST EventList;
    HANDLE TimerEvent;              // Timer event for offline completion.
    DWORD  PendingTimeout;
} RESOURCE, *PRESOURCE;

typedef struct _MONITOR_BUCKET {
    LIST_ENTRY BucketList;          // For chaining buckets together.
    LIST_ENTRY ResourceList;        // List of resources in this bucket
    DWORDLONG DueTime;              // Next time that these resources should be polled
    DWORDLONG Period;               // Periodic interval of this bucket.
} MONITOR_BUCKET, *PMONITOR_BUCKET;


//
// The Poll Event List structure.
//

typedef struct _POLL_EVENT_LIST {
    LIST_ENTRY Next;                // Next event list
    LIST_ENTRY BucketListHead;      // Bucket Listhead for this list/thread
    DWORD   NumberOfBuckets;        // Number of entries on this bucket list
    DWORD   NumberOfResources;      // Number of resources on this event list
    CRITICAL_SECTION ListLock;      // Critical section to add/remove events
    DWORD   PPrevPrevListLock;
    DWORD   PrevPrevListLock;
    DWORD   PrevListLock;
    DWORD   LastListLock;
    DWORD   LastListUnlock;
    DWORD   PrevListUnlock;
    DWORD   PrevPrevListUnlock;
    DWORD   PPrevPrevListUnlock;
    HANDLE  ListNotify;             // List change notification
    HANDLE  ThreadHandle;           // Handle of thread processing this list
    DWORD   EventCount;             // Number of events/resources in lists
    HANDLE  Handle[MAX_HANDLES_PER_THREAD]; // Array of handles to wait for
    PRESOURCE Resource[MAX_HANDLES_PER_THREAD]; // Resources that match handles
} POLL_EVENT_LIST, *PPOLL_EVENT_LIST;


#define POLL_GRANULARITY (10)       // 10ms

#define PENDING_TIMEOUT  (3*1000*60) // 3 minutes for pending requests to finish

//
// Private helper macros
//
#define RmpAlloc(size) LocalAlloc(LMEM_FIXED, (size))
#define RmpFree(size)  LocalFree((size))

#define RmpSetMonitorState(state, resource)                                \
    EnterCriticalSection(&RmpMonitorStateLock);                            \
    GetSystemTimeAsFileTime((PFILETIME)&RmpSharedState->LastUpdate);       \
    RmpSharedState->State = (state);                                       \
    RmpSharedState->ActiveResource = (HANDLE)(resource);                   \
    LeaveCriticalSection(&RmpMonitorStateLock);

#define AcquireListLock() \
    EnterCriticalSection( &RmpListLock ); \
    RmpListPPrevPrevLock = RmpListPrevPrevLock; \
    RmpListPrevPrevLock = RmpListPrevLock; \
    RmpListPrevLock = RmpListLastLock; \
    RmpListLastLock = ((RESMON_MODULE << 24) | __LINE__)

#define ReleaseListLock() \
    RmpListPPrevPrevUnlock = RmpListPrevPrevUnlock; \
    RmpListPrevPrevUnlock = RmpListPrevUnlock; \
    RmpListPrevUnlock = RmpListLastUnlock; \
    RmpListLastUnlock = ((RESMON_MODULE << 24) | __LINE__); \
    LeaveCriticalSection( &RmpListLock )

#define AcquireEventListLock( EventList ) \
    EnterCriticalSection( &(EventList)->ListLock ); \
    (EventList)->PPrevPrevListLock = (EventList)->PrevPrevListLock; \
    (EventList)->PrevPrevListLock = (EventList)->PrevListLock; \
    (EventList)->PrevListLock = (EventList)->LastListLock; \
    (EventList)->LastListLock = ((RESMON_MODULE << 24) | __LINE__)

#define ReleaseEventListLock( EventList ) \
    (EventList)->PPrevPrevListUnlock = (EventList)->PrevPrevListUnlock; \
    (EventList)->PrevPrevListUnlock = (EventList)->PrevListUnlock; \
    (EventList)->PrevListUnlock = (EventList)->LastListUnlock; \
    (EventList)->LastListUnlock = ((RESMON_MODULE << 24) | __LINE__); \
    LeaveCriticalSection( &(EventList)->ListLock )

//
// Data global to Resource Monitor
//
extern CRITICAL_SECTION RmpListLock;
extern DWORD RmpListPPrevPrevLock;
extern DWORD RmpListPrevPrevLock;
extern DWORD RmpListPrevLock;
extern DWORD RmpListLastLock;
extern DWORD RmpListLastUnlock;
extern DWORD RmpListPrevUnlock;
extern DWORD RmpListPrevPrevUnlock;
extern DWORD RmpListPPrevPrevUnlock;

extern CRITICAL_SECTION RmpMonitorStateLock;
extern PMONITOR_STATE RmpSharedState;
extern CL_QUEUE RmpNotifyQueue;
extern HKEY RmpResourcesKey;
extern HKEY RmpResTypesKey;
extern HCLUSTER RmpHCluster;
extern BOOL RmpShutdown;
extern LIST_ENTRY RmpEventListHead;
extern HANDLE RmpWaitArray[];
extern HANDLE RmpRewaitEvent;
extern HANDLE RmpClusterProcess;
extern DWORD RmpNumberOfThreads;

//
// Interfaces for manipulating the resource lists
//
VOID
RmpRundownResources(
    VOID
    );

VOID
RmpInsertResourceList(
    IN PRESOURCE Resource
    );

VOID
RmpRemoveResourceList(
    IN PRESOURCE Resource
    );


DWORD
RmpOfflineResource(
    IN RESID ResourceId,
    IN BOOL  Shutdown,
    OUT DWORD *pdwState
    );

VOID
RmpSetResourceStatus(
    IN RESOURCE_HANDLE  ResourceHandle,
    IN PRESOURCE_STATUS ResourceStatus
    );

VOID
RmpLogEvent(
    IN RESOURCE_HANDLE  ResourceHandle,
    IN LOG_LEVEL        LogLevel,
    IN LPCWSTR          FormatString,
    ...
    );

VOID
RmpLostQuorumResource(
    IN RESOURCE_HANDLE ResourceHandle
    );

//
// Interfaces for interfacing with the poller thread
//
DWORD
RmpPollerThread(
    IN LPVOID lpParameter
    );

VOID
RmpSignalPoller(
    IN PPOLL_EVENT_LIST EventList
    );

PVOID
RmpCreateEventList(
    VOID
    );

DWORD
RmpAddPollEvent(
    IN PPOLL_EVENT_LIST EventList,
    IN HANDLE EventHandle,
    IN PRESOURCE Resource
    );

DWORD
RmpRemovePollEvent(
    IN HANDLE EventHandle
    );

DWORD
RmpResourceEventSignaled(
    IN PPOLL_EVENT_LIST EventList,
    IN DWORD EventIndex
    );

//
// Notification interfaces
//
typedef enum _NOTIFY_REASON {
    NotifyResourceStateChange,
    NotifyResourceResuscitate,
    NotifyShutdown
} NOTIFY_REASON;

VOID
RmpPostNotify(
    IN PRESOURCE Resource,
    IN NOTIFY_REASON Reason
    );

DWORD
RmpTimerThread(
    IN LPVOID Context
    );

DWORD
RmpResourceGetCommonProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceSetCommonProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceGetPrivateProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceSetPrivateProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeGetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeSetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeGetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeSetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\ntddstor.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    ntddstor.h

Abstract:

    This is the include file that defines all common constants and types
    accessing the storage class drivers

Author:

    Peter Wieland 19-Jun-1996

Revision History:

--*/

// begin_winioctl

#ifndef _NTDDSTOR_H_
#define _NTDDSTOR_H_

// end_winioctl

#if !defined(FILE_DEVICE_MASS_STORAGE)
#define FILE_DEVICE_MASS_STORAGE 0x0000002d
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_STORAGE_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile

// begin_winioctl

//
// IoControlCode values for disk devices.
//

#define IOCTL_STORAGE_BASE                FILE_DEVICE_MASS_STORAGE

// end_winioctl

// begin_winioctl
//
// The following device control codes are common for all class drivers.  They
// should be used in place of the older IOCTL_DISK, IOCTL_CDROM and IOCTL_TAPE
// common codes
//

#define IOCTL_STORAGE_CHECK_VERIFY     CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_MEDIA_REMOVAL    CTL_CODE(IOCTL_STORAGE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_EJECT_MEDIA      CTL_CODE(IOCTL_STORAGE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA       CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RESERVE          CTL_CODE(IOCTL_STORAGE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RELEASE          CTL_CODE(IOCTL_STORAGE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_FIND_NEW_DEVICES CTL_CODE(IOCTL_STORAGE_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_STORAGE_GET_MEDIA_TYPES  CTL_CODE(IOCTL_STORAGE_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_STORAGE_RESET_BUS        CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_RESET_DEVICE     CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Define the structures for scsi resets
//

typedef struct _STORAGE_BUS_RESET_REQUEST {
    UCHAR PathId;
} STORAGE_BUS_RESET_REQUEST, *PSTORAGE_BUS_RESET_REQUEST;

//
// IOCTL_STORAGE_MEDIA_REMOVAL disables the mechanism
// on a storage device that ejects media. This function
// may or may not be supported on storage devices that
// support removable media.
//
// TRUE means prevent media from being removed.
// FALSE means allow media removal.
//


#endif // _NTDDSTOR_H_
// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE			// Microsoft Windows NT Cluster Administrator
							//   Extension DLLs need to be Unicode
							//   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>			// MFC core and standard components
#include <afxext.h>			// MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
//#include <afxpriv.h>		// used for OLE2T T2OLE conversions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT	IDS;
typedef UINT	IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\inc\wsclus.h ===
/*
 *   wsclus.h
 *
 *   Microsoft Windows
 *   Copyright (C) Microsoft Corporation, 1992-1997.
 *
 *   Windows Sockets include file for the Microsoft Cluster Network
 *   Protocol suite. Include this header file after winsock.h.
 *
 *   To open a Cluster Datagram Protocol socket, call socket() with an
 *   address family of AF_CLUSTER, a socket type of SOCK_DGRAM, and
 *   protocol CLUSPROTO_CDP.
 *
 *   The Cluster Network Protocol suite uses little endian byte
 *   ordering in its address components.
 */

#ifndef _WSCLUS_INCLUDED
#define _WSCLUS_INCLUDED


/*
 *  Define the Cluster address family identifier.
 */

#define AF_CLUSTER   24


/*
 *   This is the structure of the SOCKADDR structure for the Microsoft
 *   Cluster Network Protocol.
 */

typedef struct sockaddr_cluster {
    u_short sac_family;
    u_short sac_port;
    u_long  sac_node;
    u_long  sac_zero;
} SOCKADDR_CLUSTER, *PSOCKADDR_CLUSTER, FAR *LPSOCKADDR_CLUSTER;

/*
 *  Node address constants
 */
#define CLUSADDR_ANY   0


/*
 *   Protocol families used in the "protocol" parameter of the socket() API.
 */

#define CLUSPROTO_CDP  2


/*
 *   Protocol-specific IOCTLs
 *
 */

//
// Removed comment to make this value official.  This file 
// does not appear to be being used.  It is only
// left here to avoid unexpected breaking issues.
// EBK - 5/8/2000 Whistler bug # 83164
#define WSVENDOR_MSFT    0x00010000

#define WSCLUS_IOCTL(_code)    (_WSAIO(IOC_VENDOR, (_code)) | WSVENDOR_MSFT)

#define SIO_CLUS_IGNORE_NODE_STATE   WSCLUS_IOCTL(1)



#endif // ifndef _WSCLUS_INCLUDED


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\resdll\clusres.cxx ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    iisutil.c

Abstract:

    IIS Resource utility routine DLL

Author:

    Pete Benoit (v-pbenoi) 12-SEP-1996

Revision History:

--*/

#define     UNICODE             1

extern "C" {
#include    "clusres.h"
#include    "wtypes.h"
}   // extern "C"

DWORD
WINAPI
ResUtilGetSzProperty(
    OUT LPWSTR * OutValue,
    IN const PCLUSPROP_SZ ValueStruct,
    IN LPCWSTR OldValue,
    OUT LPBYTE * PropBuffer,
    OUT LPDWORD PropBufferSize
    )
/*++

Routine Description:

    Gets a string property from a property list and advances the pointers.

Arguments:

    OutValue - Supplies the address of a pointer in which to return a
        pointer to the string in the property list.

    ValueStruct - Supplies the string value from the property list.

    OldValue - Supplies the previous value for this property.

    PropBuffer - Supplies the address of the pointer to the property list
        buffer which will be advanced to the beginning of the next property.

    PropBufferSize - Supplies a pointer to the buffer size which will be
        decremented to account for this property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    Win32 error code - The operation failed.

--*/

{
    DWORD   dataSize;

    //
    // Make sure the buffer is big enough and
    // the value is formatted correctly.
    //
    dataSize = sizeof(*ValueStruct) + ALIGN_CLUSPROP( ValueStruct->cbLength );
    if ( (*PropBufferSize < dataSize) ||
         (ValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_SZ) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // If the value changed, point to the new value.
    //
    if ( (OldValue == NULL) ||
         (lstrcmpW( ValueStruct->sz, OldValue ) != 0) ) {
        *OutValue = ValueStruct->sz;
    }
    //
    // Decrement remaining buffer size and move to the next property.
    //
    *PropBufferSize -= dataSize;
    *PropBuffer += dataSize;

    return(ERROR_SUCCESS);

} // ResUtilGetSzProperty


DWORD
ResUtilSetSzProperty(
    IN HKEY RegistryKey,
    IN LPCWSTR PropName,
    IN LPCWSTR NewValue,
    IN OUT PWSTR * OutValue
    )
/*++

Routine Description:

    Sets a REG_SZ property in a pointer, deallocating a previous value
    if necessary, and sets the value in the cluster database.

Arguments:

    RegistryKey - Supplies the cluster key where the property is stored.

    PropName - Supplies the name of the value.

    NewValue - Supplies the new string value.

    OutValue - Supplies pointer to the string pointer in which to set
        the property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred attempting to allocate memory.

    Win32 error code - The operation failed.

--*/

{
    DWORD       status;
    DWORD       dataSize;
    PWSTR       allocedValue;

    //
    // Allocate memory for the new value string.
    //
    dataSize = (lstrlenW( NewValue ) + 1) * sizeof(WCHAR);
    allocedValue = (PWSTR)LocalAlloc( LMEM_FIXED, dataSize );
    if ( allocedValue == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Set the property in the cluster database.
    //
    // _ASSERTE( ClusterKey != NULL );
    // _ASSERTE( PropName != NULL );
    status = ClusterRegSetValue( RegistryKey,
                                 PropName,
                                 REG_SZ,
                                 (CONST BYTE*)NewValue,
                                 dataSize );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Copy the new value to the output buffer.
    //
    lstrcpyW( allocedValue, NewValue );

    // Set the new value in the output string pointer.
    if ( *OutValue != NULL ) {
        LocalFree( *OutValue );
    }
    *OutValue = allocedValue;

    return(ERROR_SUCCESS);

} // ResUtilSetSzProperty


//
// Worker thread routines
//
extern CRITICAL_SECTION ClusResWorkerLock;

typedef struct _WORK_CONTEXT {
    PCLUS_WORKER Worker;
    PVOID lpParameter;
    PWORKER_START_ROUTINE lpStartRoutine;
} WORK_CONTEXT, *PWORK_CONTEXT;

DWORD
WINAPI
ClusWorkerStart(
    IN PWORK_CONTEXT pContext
    )
/*++

Routine Description:

    Wrapper routine for cluster resource worker startup

Arguments:

    Context - Supplies the context block. This will be freed.

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD Status;
    WORK_CONTEXT Context;

    //
    // Capture our parameters and free the work context.
    //
    Context = *pContext;
    LocalFree(pContext);

    //
    // Call the worker routine
    //
    Status = (Context.lpStartRoutine)(Context.Worker, Context.lpParameter);

    //
    // Synchronize and clean up properly.
    //
    EnterCriticalSection(&ClusResWorkerLock);
    if (!Context.Worker->Terminate) {
        CloseHandle(Context.Worker->hThread);
        Context.Worker->hThread = NULL;
    }
    Context.Worker->Terminate = TRUE;
    LeaveCriticalSection(&ClusResWorkerLock);

    return(Status);

} // ClusWorkerStart


DWORD
ClusWorkerCreate(
    OUT PCLUS_WORKER Worker,
    IN PWORKER_START_ROUTINE lpStartAddress,
    IN PVOID lpParameter
    )
/*++

Routine Description:

    Common wrapper for resource DLL worker threads. Provides
    "clean" terminate semantics

Arguments:

    Worker - Returns an initialized worker structure

    lpStartAddress - Supplies the worker thread routine

    lpParameter - Supplies the parameter to be passed to the
        worker thread routine

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PWORK_CONTEXT Context;
    DWORD ThreadId;
    DWORD Status;

    Context = (PWORK_CONTEXT)LocalAlloc(LMEM_FIXED, sizeof(WORK_CONTEXT));
    if (Context == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Context->Worker = Worker;
    Context->lpParameter = lpParameter;
    Context->lpStartRoutine = lpStartAddress;

    Worker->Terminate = FALSE;
    Worker->hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ClusWorkerStart,
                                   Context,
                                   0,
                                   &ThreadId);
    if (Worker->hThread == NULL) {
        Status = GetLastError();
        LocalFree(Context);
        return(Status);
    }
    return(ERROR_SUCCESS);

} // ClusWorkerCreate



BOOL
ClusWorkerCheckTerminate(
    IN PCLUS_WORKER Worker
    )
/*++

Routine Description:

    Checks to see if the specified Worker thread should exit ASAP.

Arguments:

    Worker - Supplies the worker

Return Value:

    TRUE if the thread should exit.

    FALSE otherwise

--*/

{
    return(Worker->Terminate);

} // ClusWorkerCheckTerminate



VOID
ClusWorkerTerminate(
    IN PCLUS_WORKER Worker
    )
/*++

Routine Description:

    Checks to see if the specified Worker thread should exit ASAP.

Arguments:

    Worker - Supplies the worker

Return Value:

    None.

--*/

{
    //
    // N.B.  There is a race condition here if multiple threads
    //       call this routine on the same worker. The first one
    //       through will set Terminate. The second one will see
    //       that Terminate is set and return immediately without
    //       waiting for the Worker to exit. Not really any nice
    //       way to fix this without adding another synchronization
    //       object.
    //

    if ((Worker->hThread == NULL) ||
        (Worker->Terminate)) {
        return;
    }
    EnterCriticalSection(&ClusResWorkerLock);
    if (!Worker->Terminate) {
        Worker->Terminate = TRUE;
        LeaveCriticalSection(&ClusResWorkerLock);
        WaitForSingleObject(Worker->hThread, INFINITE);
        CloseHandle(Worker->hThread);
        Worker->hThread = NULL;
    } else {
        LeaveCriticalSection(&ClusResWorkerLock);
    }
    return;

} // ClusWorkerTerminate



VOID
ClusWorkerTerminateEx(
    IN PCLUS_WORKER Worker,
    IN DWORD  Timeout
    )
/*++

Routine Description:

    Checks to see if the specified Worker thread should exit and waits a
    short time before killing the thread.

Arguments:

    Worker - Supplies the worker

    Timeout - Supplies the timeout period in ms.

Return Value:

    None.

--*/

{
    //
    // N.B.  There is a race condition here if multiple threads
    //       call this routine on the same worker. The first one
    //       through will set Terminate. The second one will see
    //       that Terminate is set and return immediately without
    //       waiting for the Worker to exit. Not really any nice
    //       way to fix this without adding another synchronization
    //       object.
    //

    if ((Worker->hThread == NULL) ||
        (Worker->Terminate)) {
        return;
    }
    EnterCriticalSection(&ClusResWorkerLock);
    if (!Worker->Terminate) {
        Worker->Terminate = TRUE;
        LeaveCriticalSection(&ClusResWorkerLock);
        WaitForSingleObject(Worker->hThread, Timeout);
        CloseHandle(Worker->hThread);
        Worker->hThread = NULL;
    } else {
        LeaveCriticalSection(&ClusResWorkerLock);
    }
    return;

} // ClusWorkerTerminate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\resdll\iisutil.cxx ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    iisutil.c

Abstract:

    IIS Resource utility routine DLL

Author:

    Pete Benoit (v-pbenoi) 12-SEP-1996

Revision History:

--*/

#include    "iisutil.h"
#if defined(_DEBUG_SUPPORT)
#include    <time.h>
#endif
#include <pudebug.h>


IMSAdminBase*       CMetaData::g_pMBCom;
CRITICAL_SECTION    CMetaData::g_cs;

VOID
FreeIISResource(
    IN LPIIS_RESOURCE   ResourceEntry
    )

/*++

Routine Description:

    Free all the storage for a IIS_RESOURCE

Arguments:

    vr - virtual root to free

Return Value:

    NONE

--*/

{
    if (ResourceEntry != NULL) 
    {
        if ( ResourceEntry->ResourceName != NULL ) 
        {
            LocalFree( ResourceEntry->ResourceName );
            ResourceEntry->ResourceName = NULL;
        }
#if 0
        if ( ResourceEntry->ResourceHandle != NULL )
        {
            CloseClusterResource( ResourceEntry->ResourceHandle );
        }
#endif
        if ( ResourceEntry->ParametersKey != NULL ) 
        {
            ClusterRegCloseKey( ResourceEntry->ParametersKey );
            ResourceEntry->ParametersKey = NULL;
        }

        if ( ResourceEntry->Params.ServiceName != NULL ) 
        {
            LocalFree( ResourceEntry->Params.ServiceName);
            ResourceEntry->Params.ServiceName = NULL;
        }

        if ( ResourceEntry->Params.InstanceId != NULL ) 
        {
            LocalFree( ResourceEntry->Params.InstanceId);
            ResourceEntry->Params.InstanceId = NULL;
        }

        if ( ResourceEntry->Params.MDPath != NULL ) 
        {
            LocalFree( ResourceEntry->Params.MDPath);
            ResourceEntry->Params.MDPath = NULL;
        }

    } // ResourceEntry != NULL

} // FreeIISResource




VOID
DestructIISResource(
    IN LPIIS_RESOURCE   ResourceEntry
    )

/*++

Routine Description:

    Free all the storage for a ResourceEntry and the ResourceEntry

Arguments:

    vr - virtual root to free

Return Value:

    NONE

--*/
{
    if (ResourceEntry != NULL) 
    {
        FreeIISResource(ResourceEntry);
        LocalFree(ResourceEntry);
    } // ResourceEntry != NULL

} // DestructIISResource

DWORD
GetServerBindings(	
	LPWSTR               MDPath,
	DWORD                dwServiceType,
	SOCKADDR*            psaServer,
	LPDWORD              pdwPort 
	)
/*++
				  
Routine Description:
	
	Read the first ip address and port number form the ServerBindings property for a particlar branch of the metabase

Arguments:
	
	MDPath : the particular branch of the metabase to read the information from (ex. /LM/W3SVC/1)
	dwServiceType : the service type id
	pszServer : the structure to save the ip address
	pdwPort :  the returned port number 
					  
Return Value:

	sucess : ERROR_SUCCESS
	failure : the win32 error code of the failure
						
--*/
{
	DWORD           dwStatus           = ERROR_SUCCESS;
   	DWORD           dwR                = 0;
    DWORD           dwW                = 0;
    TCHAR *         achBindings        = NULL;
    INT             cBindingsSize      = sizeof(TCHAR)*1024;
    TCHAR *         pB                 = NULL;
    TCHAR *         pP                 = NULL;
    DWORD           cL                 = 0;
	BOOL            bGetBindingsStatus = FALSE ;
	
	//
	// allocate space for the server bindings string
	//
    if( !(achBindings = (TCHAR*)LocalAlloc(LMEM_FIXED, cBindingsSize)) )
    {
		dwStatus = GetLastError();
		TR( (DEBUG_BUFFER,"[GetServerBindings] Can't allocate memory for server bindings info. (%d)\n",dwStatus) );
    }
	
	if ( achBindings )
	{
		//
		// Get binding info from metabase 
		//
		
		CMetaData MD;
		
		if ( MD.Open( MDPath ) )
		{
			dwR = cBindingsSize;
			
			if( !(bGetBindingsStatus = MD.GetMultisz( L"", 
				MD_SERVER_BINDINGS,
				IIS_MD_UT_SERVER,
				achBindings, 
				&dwR )) )
			{
				dwStatus = GetLastError();
				
				if ( ERROR_INSUFFICIENT_BUFFER == dwStatus )
				{
					TR( (DEBUG_BUFFER,"[GetServerBindings] Buffer too small, reallocating\n") );
					
					//
					// (# 296798) If the original binding's buffer size is too small so realloc memory to the required size
					//
					TCHAR* achBindingsNew = (TCHAR*)LocalReAlloc(achBindings, dwR, 0);
					if( !achBindingsNew )
					{
						dwStatus = GetLastError();
						
						LocalFree (achBindings);
						achBindings = NULL;
					}
					else
					{
						achBindings = achBindingsNew;
						bGetBindingsStatus = MD.GetMultisz( L"", 
							MD_SERVER_BINDINGS,
							IIS_MD_UT_SERVER,
							achBindings,
							&dwR );
					}
				}
				else
				{
					//
					// error getting server bindings information from the metabase
					//
					TR( (DEBUG_BUFFER,"[GetServerBindings] error getting server bindings information (%d)\n", dwStatus) );
				}
			}
			
			MD.Close();
		}
		else
		{
			dwStatus = GetLastError();
			TR( (DEBUG_BUFFER,"[GetServerBindings] failed to open MD, error %08x\n", dwStatus) );
		}
	}

	//
	// not getting server bindings information is a serious error 
	//
	if ( !bGetBindingsStatus )
	{	
		TR( (DEBUG_BUFFER,"[GetServerBindings] error getting server bindings infomation (%d) \n", dwStatus ) );
	}
	else
	{
		TR( (DEBUG_BUFFER,"[GetServerBindings] got server bindings string (%S) \n", achBindings ) );
	
		(*pdwPort) = DEFAULT_PORT[dwServiceType];
	
		ZeroMemory( psaServer, sizeof(SOCKADDR) );
		((SOCKADDR_IN*)psaServer)->sin_family = AF_INET;
		((SOCKADDR_IN*)psaServer)->sin_addr.s_net = 127;
		((SOCKADDR_IN*)psaServer)->sin_addr.s_impno = 1;

		//
		// Each binding is of the form "addr:port:hostname"
		// we look only at addr & port
		//
		// use the 1st valid binding ( i.e. contains ':' )
		//
		
		dwR /= sizeof(WCHAR);
		
		for ( pB = achBindings ; *pB && dwR ; )
		{
			if ( (cL = wcslen( pB ) + 1 ) > dwR )
			{
				break;
			}
			
			if ( (pP = wcschr( pB, L':' )) )
			{ 
				SOCKADDR    sa;
				INT         cL = sizeof(sa);
				
				pP[0] = '\0';
				if ( achBindings[0] &&
					WSAStringToAddress( achBindings,
					AF_INET,
					NULL,
					&sa,
					&cL ) == 0 )
				{
					memcpy( psaServer, &sa, cL );
				}
				else
				{
					TR( (DEBUG_BUFFER,"[GetServerBindings] WSAStringToAddress failed converting string (%S) \n", achBindings ) );
				}
				
				if ( iswdigit(pP[1]) )
				{
					(*pdwPort) = wcstoul( pP + 1, NULL, 0 );
				}
				
				TR( (DEBUG_BUFFER,"[GetServerBindings] found binding addr %S %u.%u.%u.%u port %u\n",
					achBindings,
					((SOCKADDR_IN*)psaServer)->sin_addr.s_net,
					((SOCKADDR_IN*)psaServer)->sin_addr.s_host,
					((SOCKADDR_IN*)psaServer)->sin_addr.s_lh,
					((SOCKADDR_IN*)psaServer)->sin_addr.s_impno,
					(*pdwPort) ) );

				goto found_bindings;
			}
			
			pB += cL;
			dwR -= cL;
		}
		
	}

found_bindings:
	if( achBindings )
	{
		LocalFree(achBindings);
        achBindings = NULL;
	}
	
	return dwStatus ;
	
} // GetServerBindings



CHAR    IsAliveRequest[]="TRACK / HTTP/1.1\r\nHost: CLUSIIS\r\nConnection: close\r\nContent-length: 0\r\n\r\n";  // # 292727


DWORD
VerifyIISService(
	IN LPWSTR               MDPath,
	IN DWORD                ServiceType,
    IN DWORD                dwPort,
	IN SOCKADDR             saServer,
    IN PLOG_EVENT_ROUTINE   LogEvent
    )

/*++

Routine Description:

    Verify that the IIS service is running and that it has virtual roots
    contained in the resource
    Steps:
       1.  get server instance binding info
       2.  connect to server, send HTTP request & wait for response

Arguments:

    Resource - supplies the resource id

    IsAliveFlag - says this is an IsAlive call

Return Value:

    TRUE - if service is running and service contains resources virtual roots

    FALSE - service is in any other state

--*/
{
    DWORD           status = ERROR_SUCCESS;
	DWORD           dwR;
    DWORD           dwW;
    SOCKET          s;
    CHAR            IsAliveResponse[1024];
    
    TR( (DEBUG_BUFFER,"[IISVerify] Enter\n") );

	TR( (DEBUG_BUFFER,"[IISVerify] checking address %S : %u.%u.%u.%u port %u\n",
					MDPath,
					((SOCKADDR_IN*)&saServer)->sin_addr.s_net,
					((SOCKADDR_IN*)&saServer)->sin_addr.s_host,
					((SOCKADDR_IN*)&saServer)->sin_addr.s_lh,
					((SOCKADDR_IN*)&saServer)->sin_addr.s_impno,
					dwPort ) );

	if ( (s = TcpSockConnectToHost( &saServer,
									dwPort,
									CHECK_IS_ALIVE_CONNECT_TIMEOUT )) != NULL )
	{
		if ( ServiceType == IIS_SERVICE_TYPE_W3 )
		{
			//
			// If this is W3 then attempt to send a request and get response from server.
			//
			if ( TcpSockSend( s, 
								IsAliveRequest, 
								sizeof(IsAliveRequest), 
								&dwW,
								CHECK_IS_ALIVE_SEND_TIMEOUT ) &&
				TcpSockRecv( s,
								IsAliveResponse, 
								sizeof(IsAliveResponse), 
								&dwR,
								CHECK_IS_ALIVE_SEND_TIMEOUT ) &&
				dwR > 5 )
			{
				status = ERROR_SUCCESS;
				TcpSockClose( s );
				goto finished_check;
			}
			else
			{
				TR( (DEBUG_BUFFER,"[IISVerify] failed HTTP request\n") );
				status = ERROR_SERVICE_NOT_ACTIVE;
			}
		}
		else if ( ServiceType == IIS_SERVICE_TYPE_SMTP )
		{
			//
			// If this is SMTP then check the reply code.
			// (220: service ready)
			//
			if ( TcpSockRecv( s,
								IsAliveResponse,
								sizeof(IsAliveResponse),
								&dwR,
								CHECK_IS_ALIVE_SEND_TIMEOUT ) &&
				strncmp( IsAliveResponse, "220", 3 ) == 0 )
			{
				status = ERROR_SUCCESS;
				TcpSockClose( s );
				goto finished_check;
			}
			else
			{
				TR( (DEBUG_BUFFER,"[IISVerify] failed SMTP request, response:%S\n", IsAliveResponse) );
				status = ERROR_SERVICE_NOT_ACTIVE;
			}
		}
		else if ( ServiceType == IIS_SERVICE_TYPE_NNTP )
		{
			//
			// If this is NNTP then check the reply code.
			// (200: service ready - posting allowed) or
			// (201: service ready - no posting allowed)
			//
			if ( TcpSockRecv( s,
					IsAliveResponse,
					sizeof(IsAliveResponse),
					&dwR,
					CHECK_IS_ALIVE_SEND_TIMEOUT ) &&
				( strncmp( IsAliveResponse, "200", 3 ) == 0 ||
				strncmp( IsAliveResponse, "201", 3 ) == 0 ) )
			{
				status = ERROR_SUCCESS;
				TcpSockClose( s );
				goto finished_check;
			}
			else
			{
				TR( (DEBUG_BUFFER,"[IISVerify] failed NNTP request, response:%S\n", IsAliveResponse) );
				status = ERROR_SERVICE_NOT_ACTIVE;
			}
		}
		else
		{
			status = ERROR_SUCCESS;
			TcpSockClose( s );
			goto finished_check;
		}
		
		TcpSockClose( s );
	}
	else
	{
		TR( (DEBUG_BUFFER,"[IISVerify] failed to connect port %d\n", dwPort) );
		status = ERROR_SERVICE_NOT_ACTIVE;
	}
	
finished_check:

    //
    // Check to see if there was an error
    //
	
    if ( status != ERROR_SUCCESS ) 
    {
        TR( (DEBUG_BUFFER,"[IISVerify] FALSE (%d), Leave\n", status) );
		
#if defined(DBG_CANT_VERIFY)
        g_fDbgCantVerify = TRUE;
#endif
		
    }
    else
    {
        TR( (DEBUG_BUFFER,"[IISVerify] TRUE, Leave\n") );
    }
	
    return status;

} // VerifyIISService



LPWSTR
GetClusterResourceType(
            HRESOURCE               hResource,
            LPIIS_RESOURCE          ResourceEntry,
            IN PLOG_EVENT_ROUTINE   LogEvent
            )

/*++

Routine Description:

    Returns the resource type for the resource

Arguments:

    hResource - handle to a resource

Return Value:

    TRUE - if service is running and service contains resources virtual roots

    FALSE - service is in any other state

--*/
{
    DWORD   dwType      = 0;
    DWORD   dwSize      = MAX_DEFAULT_WSTRING_SIZE;
    WCHAR   lpzTypeName[MAX_DEFAULT_WSTRING_SIZE];
    LPWSTR  TypeName    = NULL;
    HKEY    hKey        = NULL;
    LONG    status;

   (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[GetClusterResourceType] entry\n");
    //
    // Valid resource now open the reg and get it's type
    //

    hKey = GetClusterResourceKey(hResource,KEY_READ);
    if (hKey == NULL) 
    {
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[GetClusterResourceType] Unable to open resource key = %1!u!\n",GetLastError());

        return(NULL);
    }

    //
    // Got a valid key now get the type
    //

   status = ClusterRegQueryValue(hKey,L"Type",&dwType,(LPBYTE)lpzTypeName,&dwSize);

   if (status == ERROR_SUCCESS) 
   {
        TypeName = (WCHAR*)LocalAlloc(LMEM_FIXED,(dwSize+16)*sizeof(WCHAR));
        if (TypeName != NULL) 
        {
            wcscpy(TypeName,lpzTypeName);
        } // TypeName != NULL
   } 
   else 
   {
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[GetClusterResourceType] Unable to Query Value = %1!u!\n",status);
   }

   ClusterRegCloseKey(hKey);

   (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[GetClusterResourceType] TypeName = %1!ws!\n",TypeName);

    return TypeName;

}// end GetClusterResourceType


HRESOURCE
ClusterGetResourceDependency(
            IN LPCWSTR              ResourceName,
            IN LPCWSTR              ResourceType,
            IN LPIIS_RESOURCE       ResourceEntry,
            IN PLOG_EVENT_ROUTINE   LogEvent
            )

/*++

Routine Description:

    Returns a dependent resource

Arguments:

    ResourceName - the resource

    ResourceType - the type of resource that it depends on

Return Value:

    NULL - error (use GetLastError() to get further info)

    NON-NULL - Handle to a resource of type ResourceType

--*/
{
    HCLUSTER    hCluster    = NULL;
    HRESOURCE   hResource   = NULL;
    HRESOURCE   hResDepends = NULL;
    HRESENUM    hResEnum    = NULL;
    DWORD       dwType      = 0;
    DWORD       dwIndex     = 0;
    DWORD       dwSize      = MAX_DEFAULT_WSTRING_SIZE;
    WCHAR       lpszName[MAX_DEFAULT_WSTRING_SIZE];
    LPWSTR      ResTypeName = NULL;
    DWORD       status;

    //
    // Open the cluster
    //
    hCluster = OpenCluster(NULL);
    if (hCluster == NULL) 
    {
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[ClusterGetResourceDependency] Unable to OpenCluster status = %1!u!\n",GetLastError());

        return(NULL);
    }

    //
    // Open the resource
    //

    hResource = OpenClusterResource(hCluster,ResourceName);
    if (hResource == NULL) 
    {
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[ClusterGetResourceDependency] Unable to OpenClusterResource status = %1!u!\n",GetLastError());

        goto error_exit;
    }

    //
    // Open the depends on enum
    //

    hResEnum = ClusterResourceOpenEnum(hResource,CLUSTER_RESOURCE_ENUM_DEPENDS);
    if (hResEnum == NULL) 
    {
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[ClusterGetResourceDependency] Unsuccessful ClusterResourceOpenEnum status = %1!u!\n",GetLastError());

        goto error_exit;
    }

    //
    // Enumerate all the depends on keys
    //

    do {
        dwSize = MAX_DEFAULT_WSTRING_SIZE;
        status = ClusterResourceEnum(hResEnum,dwIndex++,&dwType,lpszName,&dwSize);
        if ((status != ERROR_SUCCESS) && (status != ERROR_MORE_DATA)) 
        {
            //
            // This checks to see if NO dependencies were found
            //
            if ((status == ERROR_NO_MORE_ITEMS) && (dwIndex == 1)) 
            {
                SetLastError( ERROR_NO_DATA );
            } 
            else 
            {
                SetLastError( status );
            }
            goto error_exit;
        }

        //
        // Determine the type of resource found
        //

        hResDepends = OpenClusterResource(hCluster,lpszName);
        if (hResDepends == NULL) 
        {
            (LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"[ClusterGetResourceDependency] Unsuccessful OpenClusterResource status = %1!u!\n",GetLastError());
        }
        else 
        {
            //
            // Valid resource now open the reg and get it's type
            //
            ResTypeName = GetClusterResourceType(hResDepends,ResourceEntry,LogEvent);
            if (ResTypeName == NULL) 
            {
               (LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"[ClusterGetResourceDependency] Unsuccessful GetClusterResourceType status = %1!u!\n",GetLastError());
            } 
            else 
            {
                //
                // Compare the types and look for a match
                //
                if ( (_wcsicmp(ResTypeName,ResourceType)) == 0) 
                {
                    //
                    //Found a match
                    //

                    goto success_exit;

                } // END _wcsicmp(ResTypeName,ResourceType)

            } // END if ResourceTypeName != NULL

        } // END if hResDepends != NULL
        //
        // Close all handles, key's
        //
        if (hResDepends != NULL) 
        {
            CloseClusterResource(hResDepends);
            hResDepends = NULL;
        }
    } while ((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA));


    if (hResDepends == NULL) 
    {
       (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[ClusterGetResourceDependency] Unsuccessful resource enum status = %1!u! %2!x! last error = %3!u!\n",status,status,GetLastError());
    }
success_exit:
error_exit:
//
// At this point hResDepends is NULL if no match or non-null (success)
//
    if (hCluster != NULL) 
    {
        CloseCluster(hCluster);
    }
    if (hResource != NULL) 
    {
        CloseClusterResource(hResource);
    }
    if (hResEnum != NULL) 
    {
        ClusterResourceCloseEnum(hResEnum);
    }

    return hResDepends;
} // ClusterGetResourceDependency


DWORD
SetInstanceState(
    IN PCLUS_WORKER             pWorker,
    IN LPIIS_RESOURCE           ResourceEntry,
    IN RESOURCE_STATUS*         presourceStatus,
    IN CLUSTER_RESOURCE_STATE   TargetState,
    IN LPWSTR                   TargetStateString,
    IN DWORD                    dwMdPropControl,
    IN DWORD                    dwMdPropTarget
    )

/*++

Routine Description:

    Set the server instance to te requested state ( start / stop )

Arguments:

    pWorker - thread context to monitor for cancel request
    ResourceEntry - ptr to IIS server instance resource ctx
    presourceStatus - ptr to struct to be updated with new status
    TargetState - cluster API target state
    dwMdPropControl - IIS metabase property value for request to server
    dwMdPropTarget - IIS metabase property value for target state

Return Value:

    Win32 error code, ERROR_SUCCESS if success

--*/

{
    DWORD   status = ERROR_SERVICE_NOT_ACTIVE;
    int     retry;
    DWORD   dwS;
    DWORD   dwEnabled;

    CMetaData MD;

    TR( (DEBUG_BUFFER,"[SetInstanceState] Enter\n") );

    if ( MD.Open( ResourceEntry->Params.MDPath,
                  TRUE,
                  METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
    {

        //
        // Reenable clustering. If we are receiving this notification we know
        // enabled should be set to true.
        //
        if ( !MD.GetDword( L"", MD_CLUSTER_ENABLED, IIS_MD_UT_SERVER, &dwEnabled, 0 ) ||
             dwEnabled == 0 )
        {
            TR( (DEBUG_BUFFER,"[SetInstanceState] cluster not enabled\n") );

            if ( !MD.SetDword( L"", MD_CLUSTER_ENABLED, IIS_MD_UT_SERVER, 1, 0 ) )
            {
                TR( (DEBUG_BUFFER,"[SetInstanceState] failed to re-enable cluster\n") );
            }
        }

        if ( MD.GetDword( L"", MD_SERVER_STATE, IIS_MD_UT_SERVER, &dwS, 0 ) )
        {
            TR( (DEBUG_BUFFER,"[SetInstanceState] state prob is %d\n",dwS) );
        }
        else
        {
            TR( (DEBUG_BUFFER,"[SetInstanceState] failed to probe server state\n") );
            dwS = 0xffffffff;
        }

        if ( dwS != dwMdPropTarget )
        {
            if ( MD.SetDword( L"", MD_CLUSTER_SERVER_COMMAND, IIS_MD_UT_SERVER, dwMdPropControl, 0 ) )
            {
                MD.Close();
                TR( (DEBUG_BUFFER,"[SetInstanceState] command set to %d\n",dwMdPropControl) );

                for ( retry = (TargetState == ClusterResourceOnline) ? IISCLUS_ONLINE_TIMEOUT :IISCLUS_OFFLINE_TIMEOUT ;
                      retry-- ; )
                {
                    if ( ClusWorkerCheckTerminate(pWorker) )
                    {
                        status = ERROR_OPERATION_ABORTED;
                        break;
                    }

                    if ( MD.GetDword( ResourceEntry->Params.MDPath, MD_SERVER_STATE, IIS_MD_UT_SERVER, &dwS, 0 ) )
                    {
                        if ( dwS == dwMdPropTarget )
                        {
                            status = ERROR_SUCCESS;
                            break;
                        }
                        TR( (DEBUG_BUFFER,"[SetInstanceState] state is %d, waiting for %d\n",dwS,dwMdPropTarget) );
                    }
                    else
                    {
                        TR( (DEBUG_BUFFER,"[SetInstanceState] failed to get server state\n") );
                        break;
                    }

                    Sleep(SERVER_START_DELAY);
                }

            }
            else
            {
                TR( (DEBUG_BUFFER,"[SetInstanceState] failed to set server command to %d\n",dwMdPropControl) );
                MD.Close();
            }
        }
        else
        {
            status = ERROR_SUCCESS;
            MD.Close();
        }
    }
    else
    {
        if ( g_hEventLog && TargetState == ClusterResourceOnline )
        {
            LPCTSTR aErrStr[3];
            WCHAR   aErrCode[32];

            _ultow( GetLastError(), aErrCode, 10 );

            aErrStr[0] = ResourceEntry->Params.ServiceName;
            aErrStr[1] = ResourceEntry->Params.InstanceId;
            aErrStr[2] = aErrCode;

            ReportEvent( g_hEventLog,
                         EVENTLOG_ERROR_TYPE,
                         0,
                         IISCL_EVENT_CANT_OPEN_METABASE,
                         NULL,
                         sizeof(aErrStr) / sizeof(LPCTSTR),
                         0,
                         aErrStr,
                         NULL );
        }

        TR( (DEBUG_BUFFER,"[SetInstanceState] failed to open %S, error %08x\n",ResourceEntry->Params.MDPath, GetLastError()) );
    }

    if ( status != ERROR_SUCCESS ) 
    {
        //
        // Error
        //
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error %1!u! cannot bring resource %2!ws! %3!ws!.\n",
            status,
            ResourceEntry->ResourceName,
            TargetStateString );

        presourceStatus->ResourceState  = ClusterResourceFailed;
        ResourceEntry->State            = ClusterResourceFailed;
    } 
    else 
    {
        //
        // Success, update state, log message
        //
        presourceStatus->ResourceState  = TargetState;
        ResourceEntry->State            = TargetState;

		 TR( (DEBUG_BUFFER,"[SetInstanceState] Setting Metadata Path:%S ResourceEntry->State:%d\n", ResourceEntry->Params.MDPath, TargetState) );

        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Success bringing resource %1!ws! %2!ws!.\n",
            ResourceEntry->ResourceName,
            TargetStateString );
    }

    TR( (DEBUG_BUFFER,"[SetInstanceState] status = %d, Leave\n",status) );

    return status;
}


DWORD
InstanceEnableCluster(
    LPWSTR  pwszServiceName,
    LPWSTR  pwszInstanceId
    )

/*++

Routine Description:

    Ensure server instance in state consistent with cluster membership.
    If not already part of a cluster, stop instance & flag it as cluster enabled

Arguments:

    pwszServiceName - IIS service name ( e.g. W3SVC )
    pwszInstanceId - IIS serverr instance ID

Return Value:

    win32 error code or ERROR_SUCCESS if success

--*/

{
    DWORD   status = ERROR_SERVICE_NOT_ACTIVE;
    int     retry;
    DWORD   dwS;
    TCHAR   achMDPath[80];
    DWORD   dwL;

    dwL = wsprintf( achMDPath, L"/LM/%s/%s", pwszServiceName, pwszInstanceId );

    CMetaData MD;

    TR( (DEBUG_BUFFER,"[InstanceEnableCluster] for %S, Enter\n", achMDPath ) );

    if ( MD.Open( achMDPath,
                  TRUE,
                  METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
    {
        //
        // ensure instance is marked as cluster enabled
        //

        if ( !MD.GetDword( L"", MD_CLUSTER_ENABLED, IIS_MD_UT_SERVER, &dwS, 0 ) ||
             dwS == 0 )
        {
            if ( MD.SetDword( L"", MD_CLUSTER_ENABLED, IIS_MD_UT_SERVER, 1, 0 ) )
            {
                if ( MD.GetDword( L"", MD_SERVER_STATE, IIS_MD_UT_SERVER, &dwS, 0 ) )
                {
                    TR( (DEBUG_BUFFER,"[InstanceEnableCluster] state prob is %d\n",dwS) );
                }
                else
                {
                    TR( (DEBUG_BUFFER,"[InstanceEnableCluster] failed to probe server state\n") );
                    dwS = 0xffffffff;
                }

               MD.Close();
               
                if ( dwS != MD_SERVER_STATE_STOPPED )
                {
                    if ( MD.Open( achMDPath,
                                  TRUE,
                                  METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )  &&
                         MD.SetDword( L"", 
                                      MD_CLUSTER_SERVER_COMMAND, 
                                      IIS_MD_UT_SERVER, 
                                      MD_SERVER_COMMAND_STOP, 
                                      0 ) )
                    {

                        TR( (DEBUG_BUFFER,"[InstanceEnableCluster] command set to %d\n",MD_SERVER_COMMAND_STOP) );

                        for ( retry = 30 ; retry-- ; )
                        {
                            if ( MD.GetDword( L"", MD_SERVER_STATE, IIS_MD_UT_SERVER, &dwS, 0 ) )
                            {
                                if ( dwS == MD_SERVER_STATE_STOPPED )
                                {
                                    status = ERROR_SUCCESS;
                                    break;
                                }
                                TR( (DEBUG_BUFFER,"[InstanceEnableCluster] state is %d, waiting for %d\n",dwS,MD_SERVER_STATE_STOPPED) );
                            }
                            else
                            {
                                TR( (DEBUG_BUFFER,"[InstanceEnableCluster] failed to get server state\n") );
                                break;
                            }

                            Sleep(SERVER_START_DELAY);
                        }
                    }
                    else
                    {
                        TR( (DEBUG_BUFFER,"[InstanceEnableCluster] failed to set server command to %d\n",MD_SERVER_COMMAND_STOP) );
                    }
                }
                else
                {
                    status = ERROR_SUCCESS;
                }
            }
            else
            {
                TR( (DEBUG_BUFFER,"[InstanceEnableCluster] failed to set cluster enabled\n") );
            }        
        }
    }
    else
    {
        TR( (DEBUG_BUFFER,"[InstanceEnableCluster] failed to open %S, error %08x\n",achMDPath, GetLastError()) );
    }
    
    TR( (DEBUG_BUFFER,"[InstanceEnableCluster] status = %d, Leave\n",status) );

    MD.Close();
    return status;
}

DWORD
InstanceDisableCluster(
    LPWSTR  pwszServiceName,
    LPWSTR  pwszInstanceId
    )

/*++

Routine Description:

    Ensure server instance in state consistent with cluster membership.
    If already part of a cluster, stop instance & remove its cluster enabled flag.

Arguments:

    pwszServiceName - IIS service name ( e.g. W3SVC )
    pwszInstanceId - IIS serverr instance ID

Return Value:

    win32 error code or ERROR_SUCCESS if success

--*/

{
    DWORD   status = ERROR_SERVICE_NOT_ACTIVE;
    int     retry;
    DWORD   dwS;
    TCHAR   achMDPath[80];
    DWORD   dwL;

    dwL = wsprintf( achMDPath, L"/LM/%s/%s", pwszServiceName, pwszInstanceId );

    CMetaData MD;

    TR( (DEBUG_BUFFER,"[InstanceDisableCluster] for %S, Enter\n", achMDPath ) );

    if ( MD.Open( achMDPath,
                  TRUE,
                  METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
    {
        //
        // ensure instance is marked as cluster enabled
        //

        if ( !MD.GetDword( L"", MD_CLUSTER_ENABLED, IIS_MD_UT_SERVER, &dwS, 0 ) ||
           ( dwS == 0) )
        {
            MD.Close();
            return status;
        }

        if ( MD.SetDword( L"", MD_CLUSTER_ENABLED, IIS_MD_UT_SERVER, 0, 0 ) )
        {
            if ( MD.GetDword( L"", MD_SERVER_STATE, IIS_MD_UT_SERVER, &dwS, 0 ) )
            {
                TR( (DEBUG_BUFFER,"[InstanceDisableCluster] state prob is %d\n",dwS) );
            }
            else
            {
                TR( (DEBUG_BUFFER,"[InstanceDisableCluster] failed to probe server state\n") );
                dwS = 0xffffffff;
            }

            MD.Close();
            
            if ( dwS != MD_SERVER_STATE_STOPPED )
            {
                if ( MD.Open( achMDPath,
                              TRUE,
                              METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) &&
                     MD.SetDword( L"", 
                                  MD_SERVER_COMMAND, 
                                  IIS_MD_UT_SERVER, 
                                  MD_SERVER_COMMAND_STOP, 
                                  0 ))
                {

                    TR( (DEBUG_BUFFER,"[InstanceDisableCluster] command set to %d\n",MD_SERVER_COMMAND_STOP) );

                    for ( retry = 30 ; retry-- ; )
                    {
                        if ( MD.GetDword( L"", MD_SERVER_STATE, IIS_MD_UT_SERVER, &dwS, 0 ) )
                        {
                            if ( dwS == MD_SERVER_STATE_STOPPED )
                            {
                                break;
                            }
                            TR( (DEBUG_BUFFER,"[InstanceDisableCluster] state is %d, waiting for %d\n",dwS,MD_SERVER_STATE_STOPPED) );
                        }
                        else
                        {
                            TR( (DEBUG_BUFFER,"[InstanceDisableCluster] failed to get server state\n") );
                            break;
                        }

                        Sleep(SERVER_START_DELAY);
                    }
                }
                else
                {
                    TR( (DEBUG_BUFFER,"[InstanceDisableCluster] failed to set server command to %d\n",MD_SERVER_COMMAND_STOP) );
                }

                MD.Close();

                //
                // restart the server
                //

                 if ( MD.Open( achMDPath,
                               TRUE,
                               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )  &&
                      MD.SetDword( L"", 
                                   MD_SERVER_COMMAND, 
                                   IIS_MD_UT_SERVER, 
                                   MD_SERVER_COMMAND_START, 
                                   0 ))
                 {
                    TR( (DEBUG_BUFFER,"[InstanceDisableCluster] set server command to %d\n",MD_SERVER_COMMAND_START) );
                 }
                 else
                 {
                     TR( (DEBUG_BUFFER,"[InstanceDisableCluster] failed to set server command to %d\n",MD_SERVER_COMMAND_START) );
                 }

                 status = ERROR_SUCCESS;
            }
        }
        else
        {
            TR( (DEBUG_BUFFER,"[InstanceDisableCluster] failed to set cluster disbled\n") );
        }
    }
    else
    {
        TR( (DEBUG_BUFFER,"[InstanceDisableCluster] failed to open %S, error %08x\n",achMDPath, GetLastError()) );
    }

    MD.Close();
    
    TR( (DEBUG_BUFFER,"[InstanceDisableCluster] status = %d, Leave\n",status) );

    return status;
}


BOOL
CMetaData::Open(
    LPWSTR          pszPath,
    BOOL            fReconnect,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Opens the metabase

Arguments:

    pszPath - Path to open
    dwFlags - Open flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    HRESULT hRes;

    TR( (DEBUG_BUFFER,"[MDOpen] %S\n",pszPath) );

    if ( !GetCoInit() )
    {
        TR( (DEBUG_BUFFER,"[MDOpen] calling CoInit\n") );
        hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if ( FAILED(hRes) )
        {
            TR( (DEBUG_BUFFER,"[MD:GetMD::CoInitializeEx] error %08x\n",HRESULTTOWIN32( hRes )) );
            SetLastError( HRESULTTOWIN32( hRes ) );
            return FALSE;
        }
        SetCoInit( TRUE );
    }

    EnterCriticalSection( &g_cs );

    for ( int retry = 2 ;  retry-- ; )
    {
        if ( !GetMD() )
        {
            LeaveCriticalSection( &g_cs );
            TR( (DEBUG_BUFFER,"[MDOpen] can't get MD interface\n") );
            return FALSE;
        }

        TR( (DEBUG_BUFFER,"[MDOpen] before OpenKey\n") );

        hRes = g_pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                  pszPath,
                                  dwFlags,
                                  MB_TIMEOUT,
                                  &m_hMB );

        if ( SUCCEEDED( hRes ) )
        {
            LeaveCriticalSection( &g_cs );
            TR( (DEBUG_BUFFER,"[MDOpen] OK, leave\n") );
            return TRUE;
        }

        if ( !fReconnect )
        {
            break;
        }

        TR( (DEBUG_BUFFER,"[MDOpen] error %d, fReconnect=%d\n",HRESULTTOWIN32( hRes ),fReconnect) );
        if ( HRESULTTOWIN32( hRes ) == RPC_S_SERVER_UNAVAILABLE ||
             HRESULTTOWIN32( hRes ) == RPC_S_CALL_FAILED_DNE )
        {
            ReleaseMD();
        }
        else
        {
            break;
        }
    }

    SetLastError( HRESULTTOWIN32( hRes ) );

    LeaveCriticalSection( &g_cs );
    return FALSE;
}


BOOL 
CMetaData::Close( 
    VOID 
)

/*++

Routine Description:

    Close opened handle to metadata

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/

{
    if ( m_hMB )
    {
        g_pMBCom->CloseKey( m_hMB );
        m_hMB = NULL;
    }

    return TRUE;
}


BOOL
CMetaData::SetData(
    LPWSTR       pszPath,
    DWORD        dwPropID,
    DWORD        dwUserType,
    DWORD        dwDataType,
    VOID *       pvData,
    DWORD        cbData,
    DWORD        dwFlags
    )

/*++

Routine Description:

    Sets a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    cbData - Size of data
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/

{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    EnterCriticalSection( &g_cs );

    if ( !GetMD() )
    {
        LeaveCriticalSection( &g_cs );
        return FALSE;
    }

    hRes = g_pMBCom->SetData( m_hMB,
                              pszPath,
                              &mdRecord );

    if ( SUCCEEDED( hRes ))
    {
        LeaveCriticalSection( &g_cs );
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ) );

    LeaveCriticalSection( &g_cs );
    return FALSE;
}


BOOL
CMetaData::GetData(
    LPWSTR        pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    DWORD         dwDataType,
    VOID *        pvData,
    DWORD *       pcbData,
    DWORD         dwFlags
    )

/*++

Routine Description:

    Retrieves a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/

{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;
    BOOL            fConvert;

    mdRecord.pbMDData        = (PBYTE) pvData;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;

    EnterCriticalSection( &g_cs );

    if ( !GetMD() )
    {
        LeaveCriticalSection( &g_cs );
        return FALSE;
    }

    hRes = g_pMBCom->GetData( m_hMB,
                              pszPath,
                              &mdRecord,
                              &dwRequiredLen );

    if ( SUCCEEDED( hRes ))
    {
        LeaveCriticalSection( &g_cs );

        *pcbData = mdRecord.dwMDDataLen;

        return TRUE;
    }

    LeaveCriticalSection( &g_cs );

    *pcbData = dwRequiredLen;

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}


BOOL
CMetaData::Init(
    )

/*++

Routine Description:

    Initialize access to metadata

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/

{
    INITIALIZE_CRITICAL_SECTION( &g_cs );
    g_pMBCom = NULL;

    return TRUE;
}


BOOL
CMetaData::Terminate(
    )

/*++

Routine Description:

    Terminate access to metadata

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/

{
    DeleteCriticalSection( &g_cs );
    if ( g_pMBCom )
    {
        if (FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
        {
            return FALSE;
        }
        g_pMBCom->Release();
        g_pMBCom = NULL;
    }

    return TRUE;
}


BOOL
CMetaData::GetMD(
    )

/*++

Routine Description:

    Initialize interface pointer to DCOM metabase object

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/

{
    if ( g_pMBCom == NULL )
    {
        HRESULT hRes;
        hRes = CoCreateInstance(CLSID_MSAdminBase, NULL,
            CLSCTX_SERVER, IID_IMSAdminBase, (void**) &g_pMBCom);

        TR( (DEBUG_BUFFER,"[MD:GetMD] called cocreate\n") );
        if ( hRes == CO_E_NOTINITIALIZED )
        {
            TR( (DEBUG_BUFFER,"[MD:GetMD] call coinit\n") );
            hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
            if ( FAILED(hRes) )
            {
                TR( (DEBUG_BUFFER,"[MD:GetMD::CoInitializeEx] error %08x\n",HRESULTTOWIN32( hRes )) );
                SetLastError( HRESULTTOWIN32( hRes ) );
                return FALSE;
            }
            hRes = CoCreateInstance(CLSID_MSAdminBase, NULL,
                CLSCTX_SERVER, IID_IMSAdminBase, (void**) &g_pMBCom);
        }

        if ( FAILED(hRes) )
        {
            TR( (DEBUG_BUFFER,"[MD:GetMD] error %08x\n",HRESULTTOWIN32( hRes )) );
            SetLastError( HRESULTTOWIN32( hRes ) );
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
CMetaData::ReleaseMD(
    )

/*++

Routine Description:

    Release interface pointer to DCOM metabase object

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/

{
    if ( g_pMBCom )
    {
        g_pMBCom->Release();
        g_pMBCom = NULL;
    }

    return TRUE;
}


SOCKET
TcpSockConnectToHost(
    SOCKADDR*   psaServer,
    DWORD       dwPort,
    DWORD       dwTimeOut
    )

/*++

Routine Description:

    Create a TCP connection to specified port on specified machine

Arguments:

    psaServer - target address
    dwPort - target port to connect to
    dwTimeOut - time out for connection ( in seconds )

Return Value:

    socket or NULL if error

--*/

{
    SOCKET      sNew;
    BOOL        fWrite = FALSE;
    INT         serr = 0;
    SOCKADDR_IN inAddr;
    PSOCKADDR   addr;
    INT         addrLength;


    sNew = WSASocket(
                  AF_INET,
                  SOCK_STREAM,
                  0,
                  NULL,  // protocol info
                  0,     // Group ID = 0 => no constraints
                  WSA_FLAG_OVERLAPPED    // completion port notifications
                  );

    if ( sNew == INVALID_SOCKET ) 
    {
        TR( (DEBUG_BUFFER,"[TcpSockConnectToLocalHost] failed WSASocket, error %08x\n",GetLastError()) );
        return NULL;
    }

    addrLength = sizeof(inAddr);

    ZeroMemory(&inAddr, addrLength);
    inAddr.sin_family = AF_INET;
    inAddr.sin_port = 0;

    ((PSOCKADDR_IN)psaServer)->sin_port = (unsigned short)htons((unsigned short)dwPort );

    //
    // Bind an address to socket
    //

    if ( bind( sNew, 
               (PSOCKADDR)&inAddr, 
               addrLength ) == 0 &&
         WSAConnect( sNew,
                     (PSOCKADDR)psaServer,
                     addrLength,
                     NULL,
                     NULL,
                     NULL,
                     NULL ) == 0 &&
         WaitForSocketWorker(
                    INVALID_SOCKET,
                    sNew,
                    NULL,
                    &fWrite,
                    dwTimeOut ) == 0 )
    {
        return sNew;
    }

    TR( (DEBUG_BUFFER,"[TcpSockConnectToLocalHost] failed connect, error %08x\n",GetLastError()) );
    closesocket( sNew );

    return NULL;
}


VOID
TcpSockClose(
    SOCKET  hSocket
    )

/*++

Routine Description:

    Close a socket opened by TcpSockConnectToLocalHost

Arguments:

    hSocket - socket opened by TcpSockConnectToLocalHost

Return Value:

    Nothing

--*/

{
    closesocket( hSocket );
}


BOOL
TcpSockSend(
    IN SOCKET      sock,
    IN LPVOID      pBuffer,
    IN DWORD       cbBuffer,
    OUT PDWORD     pcbTotalSent,
    IN DWORD       nTimeout
    )

/*++

    Description:
        Do async socket send

    Arguments:
        sock - socket
        pBuffer - buffer to send
        cbBuffer - size of buffer
        pcbTotalSent - bytes sent
        nTimeout - timeout in seconds to use

    Returns:
        FALSE if there is any error.
        TRUE otherwise

--*/

{
    INT         serr = 0;
    INT         cbSent;
    DWORD       dwBytesSent = 0;
    ULONG       one;

    //
    //  Loop until there's no more data to send.
    //

    while( cbBuffer > 0 )
    {
        //
        //  Wait for the socket to become writeable.
        //
        BOOL  fWrite = FALSE;

        serr = WaitForSocketWorker(
                        INVALID_SOCKET,
                        sock,
                        NULL,
                        &fWrite,
                        nTimeout
                        );

        if( serr == 0 )
        {
            //
            //  Write a block to the socket.
            //

            cbSent = send( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

            if( cbSent < 0 )
            {
                //
                //  Socket error.
                //

                serr = WSAGetLastError();
            }
            else
            {
                dwBytesSent += (DWORD)cbSent;
            }
        }

        if( serr != 0 )
        {
            TR( (DEBUG_BUFFER,"[TcpSockSend] failed send, error %08x\n",serr) );
            break;
        }

        pBuffer   = (LPVOID)( (LPBYTE)pBuffer + cbSent );
        cbBuffer -= (DWORD)cbSent;
    }

    if(pcbTotalSent)
    {
        *pcbTotalSent = dwBytesSent;
    }

    return (serr == 0);

}   // SockSend



BOOL
TcpSockRecv(
    IN SOCKET       sock,
    IN LPVOID       pBuffer,
    IN DWORD        cbBuffer,
    OUT LPDWORD     pbReceived,
    IN DWORD        nTimeout
    )

/*++

    Description:
        Do async socket recv

    Arguments:
        sock - The target socket.
        pBuffer - Will receive the data.
        cbBuffer - The size (in bytes) of the buffer.
        pbReceived - Will receive the actual number of bytes
        nTimeout - timeout in seconds

    Returns:
        TRUE, if successful

--*/

{
    INT         serr = 0;
    DWORD       cbTotal = 0;
    INT         cbReceived;
    DWORD       dwBytesRecv = 0;

    ULONG       one;
    BOOL fRead = FALSE;

    //
    //  Wait for the socket to become readable.
    //

    serr = WaitForSocketWorker(
                        sock,
                        INVALID_SOCKET,
                        &fRead,
                        NULL,
                        nTimeout
                        );

    if( serr == 0 )
    {
        //
        //  Read a block from the socket.
        //
        cbReceived = recv( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

        if( cbReceived < 0 )
        {
            //
            //  Socket error.
            //

            serr = WSAGetLastError();
        }
        else 
        {
            cbTotal = cbReceived;
        }
    }
    else
    {
        TR( (DEBUG_BUFFER,"[TcpSockRecv] failed send, error %08x\n",serr) );
    }

    if( serr == 0 )
    {
        //
        //  Return total byte count to caller.
        //

        *pbReceived = cbTotal;
    }

    return (serr == 0);

}   // SockRecv


INT
WaitForSocketWorker(
    IN SOCKET   sockRead,
    IN SOCKET   sockWrite,
    IN LPBOOL   pfRead,
    IN LPBOOL   pfWrite,
    IN DWORD    nTimeout
    )

/*++

    Description:
        Wait routine
        NOTES:      Any (but not all) sockets may be INVALID_SOCKET.  For
                    each socket that is INVALID_SOCKET, the corresponding
                    pf* parameter may be NULL.

    Arguments:
        sockRead - The socket to check for readability.
        sockWrite - The socket to check for writeability.
        pfRead - Will receive TRUE if sockRead is readable.
        pfWrite - Will receive TRUE if sockWrite is writeable.
        nTimeout - timeout in seconds

    Returns:
        SOCKERR - 0 if successful, !0 if not.  Will return
            WSAETIMEDOUT if the timeout period expired.

--*/

{
    INT       serr = 0;
    TIMEVAL   timeout;
    LPTIMEVAL ptimeout;
    fd_set    fdsRead;
    fd_set    fdsWrite;
    INT       res;

    //
    //  Ensure we got valid parameters.
    //

    if( ( sockRead  == INVALID_SOCKET ) &&
        ( sockWrite == INVALID_SOCKET ) ) 
    {

        return WSAENOTSOCK;
    }

    timeout.tv_sec = (LONG )nTimeout;

    if( timeout.tv_sec == 0 ) 
    {

        //
        //  If the connection timeout == 0, then we have no timeout.
        //  So, we block and wait for the specified conditions.
        //

        ptimeout = NULL;

    } 
    else 
    {

        //
        //  The connectio timeout is > 0, so setup the timeout structure.
        //

        timeout.tv_usec = 0;

        ptimeout = &timeout;
    }

    for( ; ; ) 
    {

        //
        //  Setup our socket sets.
        //

        FD_ZERO( &fdsRead );
        FD_ZERO( &fdsWrite );

        if( sockRead != INVALID_SOCKET ) 
        {

            FD_SET( sockRead, &fdsRead );
            *pfRead = FALSE;
        }

        if( sockWrite != INVALID_SOCKET ) 
        {

            FD_SET( sockWrite, &fdsWrite );
            *pfWrite = FALSE;
        }

        //
        //  Wait for one of the conditions to be met.
        //

        res = select( 0, &fdsRead, &fdsWrite, NULL, ptimeout );

        if( res == 0 ) 
        {

            //
            //  Timeout.
            //

            serr = WSAETIMEDOUT;
            break;

        } 
        else if( res == SOCKET_ERROR ) 
        {

            //
            //  Bad news.
            //

            serr = WSAGetLastError();
            TR( (DEBUG_BUFFER,"[WaitForSocketWorker] failed send, error %08x\n",serr) );
            break;
        } 
        else 
        {
            BOOL fSomethingWasSet = FALSE;

            if( pfRead != NULL ) 
            {

                *pfRead   = FD_ISSET( sockRead,   &fdsRead   );
                fSomethingWasSet = TRUE;
            }

            if( pfWrite != NULL ) 
            {
                *pfWrite  = FD_ISSET( sockWrite,  &fdsWrite  );
                fSomethingWasSet = TRUE;
            }

            if( fSomethingWasSet ) 
            {

                //
                //  Success.
                //

                serr = 0;
                break;
            } 
            else 
            {
                //
                //  select() returned with neither a timeout, nor
                //  an error, nor any bits set.  This feels bad...
                //

                continue;
            }
        }
    }

    return serr;

} // WaitForSocketWorker()


#if defined(_DEBUG_SUPPORT)

void 
TimeStamp( 
    FILE* f
    )
{
    time_t t = time( NULL );
    struct tm *pTm;

    if ( pTm = localtime( &t ) )
    {
        fprintf( f, 
                 "%02d:%02d:%02d> ",
                 pTm->tm_hour,
                 pTm->tm_min,
                 pTm->tm_sec );
    }
}

void
InitDebug(
    )
{
    char    achPath[MAX_PATH];
    HKEY    hKey;
    DWORD   dwValue;
    DWORD   dwType;
    DWORD   dwLen;
    BOOL    fDoDebug = FALSE;
    BOOL    fAppend = TRUE;
    INT     cL = 0;
    LPSTR   pTmp;

    //
    // get debug flag from registry
    //

    if ( RegOpenKey( HKEY_LOCAL_MACHINE, 
                     L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters", 
                     &hKey ) 
            == ERROR_SUCCESS )
    {
        TR( (DEBUG_BUFFER,"[InitDebug] opened key\n") );
        dwLen = sizeof( dwValue );
        if ( RegQueryValueEx( hKey,
                              L"ClusterDebugMode",
                              NULL,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwLen ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            fDoDebug = !!dwValue;
        }

        dwLen = sizeof( dwValue );
        if ( RegQueryValueEx( hKey,
                              L"ClusterDebugAppendToFile",
                              NULL,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwLen ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            fAppend = !!dwValue;
        }

        dwLen = sizeof( achPath );
        if ( RegQueryValueExA( hKey,
                               "ClusterDebugPath",
                               NULL,
                               &dwType,
                               (LPBYTE)achPath,
                               &dwLen ) == ERROR_SUCCESS &&
             dwType == REG_SZ )
        {
            if ( dwLen )
            {
                cL = dwLen - 1;
                if ( cL && achPath[cL-1] != '\\' )
                {
                    achPath[cL++] = '\\';
                }
            }
        }

        RegCloseKey( hKey );
    }

    if ( fDoDebug && cL )
    {
        memcpy( achPath + cL, "iisclus.trc", sizeof("iisclus.trc") );
        debug_file = fopen(achPath, fAppend ? "a" : "w" );
    }
}

#endif

DWORD
WINAPI
ResUtilReadProperties(
    IN HKEY RegistryKey,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN OUT LPBYTE OutParams,
    IN RESOURCE_HANDLE ResourceHandle,
    IN PLOG_EVENT_ROUTINE LogEvent
    )

/*++

Routine Description:

    Read properties based on a property table.

Arguments:

    RegistryKey - Supplies the cluster key where the properties are stored.

    PropertyTable - Pointer to the property table to process.

    OutParams - Parameter block to read into.

    ResourceHandle - Handle for the resource fo which properties are being read.

    LogEvent - Function to call to log events to the cluster log.

Return Value:

    ERROR_SUCCESS - Properties read successfully.

    ERROR_INVALID_DATA - Required property not present.

--*/

{
    PRESUTIL_PROPERTY_ITEM  propertyItem = PropertyTable;
    HKEY                    key;
    DWORD                   status = ERROR_SUCCESS;
    LPWSTR                  pszInValue;
    LPBYTE                  pbInValue;
    DWORD                   dwInValue;
    LPWSTR *                ppszOutValue;
    LPBYTE *                ppbOutValue;
    LPDWORD                 pdwOutValue;

    while ( propertyItem->Name != NULL ) {
        //
        // If the value resides at a different location, create the key.
        //
        if ( propertyItem->KeyName != NULL ) {

            DWORD disposition;

            status = ClusterRegCreateKey( RegistryKey,
                                          propertyItem->KeyName,
                                          0,
                                          KEY_ALL_ACCESS,
                                          NULL,
                                          &key,
                                          &disposition );
            if ( status != ERROR_SUCCESS ) {
                return(status);
            }
        } else {
            key = RegistryKey;
        }

        switch ( propertyItem->Format ) {
            case CLUSPROP_FORMAT_DWORD:
                pdwOutValue = (LPDWORD) &OutParams[propertyItem->Offset];
                status = ResUtilGetDwordValue( RegistryKey,
                                               propertyItem->Name,
                                               pdwOutValue,
                                               propertyItem->Default );
                if ( (status == ERROR_FILE_NOT_FOUND) &&
                     !(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ) {
                    *pdwOutValue = propertyItem->Default;
                }
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                ppszOutValue = (LPWSTR*) &OutParams[propertyItem->Offset];
                pszInValue = ResUtilGetSzValue( RegistryKey,
                                                propertyItem->Name );
                if ( pszInValue == NULL ) {
                    status = GetLastError();
                    if ( (status == ERROR_FILE_NOT_FOUND) &&
                         !(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ) {
                        if ( *ppszOutValue != NULL ) {
                            LocalFree( *ppszOutValue );
                            *ppszOutValue = NULL;
                        }

                        // If a default is specified, copy it.
                        if ( propertyItem->lpDefault != NULL ) {
                            *ppszOutValue = (LPWSTR)LocalAlloc( LMEM_FIXED, (lstrlenW( (LPCWSTR) propertyItem->lpDefault ) + 1) * sizeof(WCHAR) );
                            if ( *ppszOutValue == NULL ) {
                                status = GetLastError();
                            } else {
                                lstrcpyW( *ppszOutValue, (LPCWSTR) propertyItem->lpDefault );
                            }
                        }
                    }
                } else {
                    if ( *ppszOutValue != NULL ) {
                        LocalFree( *ppszOutValue );
                    }
                    *ppszOutValue = pszInValue;
                }
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                ppbOutValue = (LPBYTE*) &OutParams[propertyItem->Offset];
                pdwOutValue = (PDWORD) &OutParams[propertyItem->Offset+sizeof(LPBYTE*)];
                status = ResUtilGetBinaryValue( RegistryKey,
                                                propertyItem->Name,
                                                &pbInValue,
                                                &dwInValue );
                if ( status == ERROR_SUCCESS ) {
                    if ( *ppbOutValue != NULL ) {
                        LocalFree( *ppbOutValue );
                    }
                    *ppbOutValue = pbInValue;
                    *pdwOutValue = dwInValue;
                } else if ( (status == ERROR_FILE_NOT_FOUND) &&
                            !(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ) {
                    if ( *ppbOutValue != NULL ) {
                        LocalFree( *ppbOutValue );
                        *ppbOutValue = NULL;
                        *pdwOutValue = 0;
                    }

                    // If a default is specified, copy it.
                    if ( propertyItem->lpDefault !=  NULL ) {
                        *ppbOutValue = (LPBYTE)LocalAlloc( LMEM_FIXED, propertyItem->Minimum );
                        if ( *ppbOutValue == NULL ) {
                            status = GetLastError();
                        } else {
                            memcpy( *ppbOutValue, propertyItem->lpDefault, propertyItem->Minimum );
                            *pdwOutValue = propertyItem->Minimum;
                        }
                    }
                }
                break;
        }

        //
        // Close the key if we opened it.
        //
        if ( (propertyItem->KeyName != NULL) &&
             (key != NULL) ) {
            ClusterRegCloseKey( key );
        }

        //
        // Handle any errors that occurred.
        //
        if ( status != ERROR_SUCCESS ) {
            (LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to read the '%1' property. Error: %2!u!.\n",
                propertyItem->Name,
                status );
            if ( propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED ) {
                if ( status == ERROR_FILE_NOT_FOUND ) {
                    status = ERROR_INVALID_DATA;
                }
                break;
            } else {
                status = ERROR_SUCCESS;
            }
        }

        //
        // Advance to the next property.
        //
        propertyItem++;
    }

    return(status);

} // ResUtilReadProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\resdll\iis.cxx ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    iis.c

Abstract:

    Resource DLL for IIS. This DLL supports the following IIS services
        WWW
        FTP

    Each instance of a resouce is an IIS instance ( a.k.a. virtual server )
    Virtual root may have dependencies on IP Addresses, Physical Disks, or UNC names.

    Known Limitations


Author:

    Pete Benoit (v-pbenoi) 12-SEP-1996

Revision History:

	Rich Demar (rdemar) 5-18-1999

--*/


#define     INITGUID
#include "iisutil.h"
#include <clusapi.h>
#include <resapi.h>
//#include "resmonp.h"
//#include "clusres.h"
#include <pudebug.h>

DECLARE_DEBUG_BUFFER;

//
// Names used to start service
//

LPCWSTR ActualServiceName[] = {
        L"W3SVC",                    // WWW
        L"MSFTPSVC",                 // FTP
        L"SMTPSVC",                  // SMTP
        L"NNTPSVC"                   // NNTP
    };

#define PARAM_NAME__SERVICENAME      L"ServiceName"
#define PARAM_NAME__INSTANCEID       L"InstanceId"

#define MAX_SCMFAILURE_RETRY         5
#define BACKOFF_MULTIPLIER           2
#define DELAY_BETWEEN_ISALIVE_CHECKS 5*1000

#define MAX_DIFFERENCE_BETWEEN_RESOURCE_CHECKS 5*60*1000 // five minutes in milliseconds

//
// IIS resource private read-write parameters.
//
RESUTIL_PROPERTY_ITEM
IISResourcePrivateProperties[] = {
    { PARAM_NAME__SERVICENAME, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(IIS_PARAMS,ServiceName) },
    { PARAM_NAME__INSTANCEID,  NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(IIS_PARAMS,InstanceId) },
    { 0 }
};


//
// Global data.
//

CRITICAL_SECTION    IISTableLock;
LIST_ENTRY          IISResourceTable;
BOOL                g_fIISResourceTable_HadChanged = FALSE;
CLUS_WORKER         g_cwAlivePollingThread;
DWORD               g_dwTickOfLastResourceCheck = 0;
DWORD               g_dwTlsCoInit = 0xffffffff;
#if defined(DBG_CANT_VERIFY)
BOOL                g_fDbgCantVerify = FALSE;
#endif
LONG                g_lOpenRefs = 0;
bool                g_fWinsockInitialized = false;



PLOG_EVENT_ROUTINE              g_IISLogEvent = NULL;
PSET_RESOURCE_STATUS_ROUTINE    IISSetResourceStatus = NULL;
HANDLE                          g_hEventLog = NULL;

extern CLRES_FUNCTION_TABLE IISFunctionTable;


//
// Forward routines
//

PWSTR
IISGetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    );

BOOL
WINAPI
IISIsAlive(
    IN RESID Resource
    );

DWORD
IISReadParameters(
    IN OUT LPIIS_RESOURCE ResourceEntry
    );

DWORD
IISBuildInternalParameters(
    IN OUT IIS_PARAMS* ResourceEntry
    );

VOID
IISInitializeParams(
    IN OUT IIS_PARAMS* Params
    );

VOID
IISFreeInternalParameters(
    IN IIS_PARAMS* Params
    );


LPIIS_RESOURCE
GetValidResource(
    IN RESID    Resource,
    IN LPWSTR   RoutineName
    );

DWORD
IISSetPrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
IISGetPrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
IISValidatePrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PIIS_PARAMS Params
    );

void
IISReplicateProperties(
    IN IIS_PARAMS* lpNewParams, 
    IN IIS_PARAMS* lpOldParams
    );

void
IISSetRemoteNodeProperties(
    IN LPWSTR      wcsNodeName,
    IN IIS_PARAMS* lpNewParams, 
    IN IIS_PARAMS* lpOldParams
    );

DWORD
WINAPI
IISAlivePollingThread(
    IN PCLUS_WORKER     pWorker,
    IN LPVOID           lpVoid    );


//
// Function definitions
//


BOOLEAN
IISInit(
    VOID
    )
{
    WSADATA   wsaData;
    INT       serr;

    INIT_DEBUG;

    INITIALIZE_CRITICAL_SECTION(&IISTableLock);
    InitializeListHead(&IISResourceTable);


    g_dwTlsCoInit = TlsAlloc();
    SetCoInit( FALSE );

    g_hEventLog = RegisterEventSource( NULL, L"CLUSIIS4" );

    //
    // Initialize winsock support
    //
    
    serr = WSAStartup( MAKEWORD( 2, 0), &wsaData);

    if( serr == 0 ) 
    {
        g_fWinsockInitialized = true;
    }
    else
    {
        TR( (DEBUG_BUFFER,"[TcpSockConnectToLocalHost] WSAStartup failed with %08x\n",serr) );
    }

    return TRUE;
}


VOID
IISCleanup()
{

    DeleteCriticalSection(&IISTableLock);

    TlsFree( g_dwTlsCoInit );

    if ( g_hEventLog != NULL )
    {
        DeregisterEventSource( g_hEventLog );
    }

    if (g_fWinsockInitialized)
    {
        WSACleanup();
    }
    
    TERMINATE_DEBUG;
}


extern "C" BOOL WINAPI
DllMain(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch( Reason )
    {

    case DLL_PROCESS_ATTACH:
        if ( !IISInit() )
        {
            return(FALSE);
        }
        break;

    case DLL_PROCESS_DETACH:
        IISCleanup();
        break;

    case DLL_THREAD_ATTACH:
        SetCoInit( FALSE );
        break;

    default:
        break;
    }

    return(TRUE);

} // IISShareDllEntryPoint




BOOLEAN
StartIIS(
    LPIIS_RESOURCE  ResourceEntry
    )
/*++

Routine Description:
    Start the IIS service

Arguments:
    ResourceEntry - resource entry structure, includes name of service

Return Value:
    TRUE - Success
    FALSE - Failure

--*/
{

    SC_HANDLE       scManagerHandle;
    SC_HANDLE       serviceHandle;
    DWORD           errorCode;
    DWORD           iPoll;
    SERVICE_STATUS  ss;
    BOOL            fSt = FALSE;
    INT             iMaxWaitTime  = 1000;   // One second

    //
    // (# 261897) IIS cluster resources are failing to come online because "OpenSCManager" is failing with error "1723"
    //
    srand( (unsigned int)GetCurrentThreadId() );
  
    for(int iScmRetry=0; iScmRetry < MAX_SCMFAILURE_RETRY; iScmRetry++)
    {
         //
         // Open the service control manager
         //

         scManagerHandle = OpenSCManager( NULL,        // local machine
                                          NULL,        // ServicesActive database
                                          SC_MANAGER_ALL_ACCESS ); // all access
        if ( scManagerHandle == NULL )
        {
                if( iScmRetry == (MAX_SCMFAILURE_RETRY-1) )
                {
                    (g_IISLogEvent)(
                           ResourceEntry->ResourceHandle,
                           LOG_ERROR,
                           L"Unable to open Service Control Manager '%1!ws!'. Error: %2!u!. Reached maximum retries (%3!u!)\n",
                           ResourceEntry->ResourceName,
                           GetLastError(),
                           iScmRetry );

                    return FALSE;
                }
                else
                {
                    (g_IISLogEvent)(
                           ResourceEntry->ResourceHandle,
                           LOG_ERROR,
                           L"Unable to open Service Control Manager '%1!ws!'. Error: %2!u!. Retry attempt (%3!u!)\n",
                           ResourceEntry->ResourceName,
                           GetLastError(),
                           iScmRetry );
                }

                Sleep( (DWORD)(rand() % iMaxWaitTime) );

                iMaxWaitTime *= BACKOFF_MULTIPLIER;
        }
        else
        {
                break;
        }
    }
    
    //
    // Open the service
    //

    serviceHandle = OpenService( scManagerHandle,
                                 ResourceEntry->Params.ServiceName,         // Service Name
                                 SERVICE_ALL_ACCESS );

    TR( (DEBUG_BUFFER,"[StartIIS] starting %S\n", ResourceEntry->Params.ServiceName) );

    if ( serviceHandle == NULL )
    {
        CloseServiceHandle( scManagerHandle );
        return FALSE;
    }

    //
    // Make sure the service is running
    //

    if ( !StartService( serviceHandle,
                        0,
                        NULL) )
    {

        errorCode = GetLastError();

        if ( errorCode == ERROR_SERVICE_ALREADY_RUNNING )
        {
            TR( (DEBUG_BUFFER,"[StartIIS] allready running\n") );
            fSt = TRUE;
        }
    }
    else
    {
        for ( iPoll = 0 ; iPoll < SERVICE_START_MAX_POLL ; ++iPoll )
        {
            if ( !QueryServiceStatus( serviceHandle, &ss ) )
            {
                break;
            }

            if ( ss.dwCurrentState == SERVICE_RUNNING )
            {
                fSt = TRUE;
                break;
            }

            //
            // Give the IIS Server a second to start up
            //

            Sleep( SERVICE_START_POLL_DELAY );
        }
    }

    //
    // Close open handles
    //

    CloseServiceHandle( serviceHandle );
    CloseServiceHandle( scManagerHandle);

    return (BOOLEAN)fSt;

} // StartIIS



DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup a particular resource type. This means verifying the version
    requested, and returning the function table for this resource type.

Arguments:

    ResourceType - Supplies the type of resource.

    MinVersionSupported - The minimum version number supported by the cluster
                    service on this system.

    MaxVersionSupported - The maximum version number supported by the cluster
                    service on this system.

    FunctionTable - Returns the Function Table for this resource type.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   serviceType = MAX_SERVICE;
    DWORD   i;
    HRESULT hRes;

#if 1
    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED(hRes) )
    {
        TR( (DEBUG_BUFFER,"[Startup] fail CoInitialize %08x\n",hRes) );
    }
#endif

    //
    // Search for a valid service name supported by this DLL
    //
    for ( i = 0; i < MAX_RESOURCE_TYPE; i++ )
    {
        if ( lstrcmpiW( ResourceType, RESOURCE_TYPE[i] ) == 0 )
            break;
    }

    if ( MAX_RESOURCE_TYPE == i )
    {
        TR( (DEBUG_BUFFER,"[Startup] bad resource type\n") );
        return ERROR_UNKNOWN_REVISION;
    }

    g_IISLogEvent = LogEvent;
    IISSetResourceStatus = SetResourceStatus;

    if ( (MinVersionSupported <= CLRES_VERSION_V1_00) &&
         (MaxVersionSupported >= CLRES_VERSION_V1_00) )
    {

        TR( (DEBUG_BUFFER,"[Startup] OK, leave\n") );
        *FunctionTable = &IISFunctionTable;
        return ERROR_SUCCESS;
    }

    TR( (DEBUG_BUFFER,"[Startup] revision mismatch\n") );
    return ERROR_REVISION_MISMATCH;

} // Startup




RESID
WINAPI
IISOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for IIS resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - Supplies handle to resource's cluster registry key.

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    DWORD           status;
    DWORD           readStatus;
    LPIIS_RESOURCE  ResourceEntry;
    DWORD           count;
    DWORD           Index;
    DWORD           serviceType = MAX_SERVICE;
    LPCWSTR         ResourceType;
    HKEY            hKey;

    TR( (DEBUG_BUFFER,"[IISOpen] Enter\n") );

    EnterCriticalSection(&IISTableLock);

    //
    // Check if IIS is installed
    //

    if ( ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                L"SYSTEM\\CurrentControlSet\\Services\\IISADMIN",
                                0,
                                KEY_READ,
                                &hKey))
    {
        LeaveCriticalSection(&IISTableLock);
        return (RESID)0;
    }
    else
    {
        RegCloseKey(hKey);
    }
    
    if ( g_lOpenRefs == 0 )
    {
        if ( !CMetaData::Init() )
        {
            LeaveCriticalSection(&IISTableLock);
            return (RESID)0;
        }
    }
    InterlockedIncrement( &g_lOpenRefs );
    LeaveCriticalSection(&IISTableLock);

    ResourceEntry = (LPIIS_RESOURCE)LocalAlloc( LMEM_FIXED, sizeof(IIS_RESOURCE) );
    if ( ResourceEntry == NULL )
    {
        (g_IISLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate IIS resource structure.\n");
        TR( (DEBUG_BUFFER,"[IISOpen] can't alloc ResourceEntry\n") );

        InterlockedDecrement( &g_lOpenRefs );

        return (RESID)0;
    }
    ZeroMemory( ResourceEntry, sizeof(IIS_RESOURCE) );
    ResourceEntry->Signature = IIS_RESOURCE_SIGNATURE;

    //
    // Set the resource handle for logging and init the virtual root entry
    //
    ResourceEntry->ResourceHandle = ResourceHandle;

    //
    // Read the Name of the resource, since the GUID is passed in.
    //

    ResourceEntry->ResourceName = IISGetParameter( ResourceKey, L"Name" );

    if ( ResourceEntry->ResourceName == NULL )
    {
        (g_IISLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to read resource name.\n" );
        status = ERROR_RESOURCE_NOT_FOUND;
        FreeIISResource(ResourceEntry);
        LocalFree( ResourceEntry );

        TR( (DEBUG_BUFFER,"[IISOpen] Can't get name\n") );
        InterlockedDecrement( &g_lOpenRefs );
        return (RESID)0;
    }

    //
    // Open the Parameters key for this resource.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"Parameters",
                                KEY_READ,
                                &ResourceEntry->ParametersKey );

    if ( status != ERROR_SUCCESS )
    {
        (g_IISLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key for resource. Error: %1!u!.\n",
            status );
        FreeIISResource( ResourceEntry );
        LocalFree( ResourceEntry );
        TR( (DEBUG_BUFFER,"[IISOpen] Can't open parameters\n") );

        InterlockedDecrement( &g_lOpenRefs );
        return (RESID)0;
    }

    ResourceEntry->State                = ClusterResourceOffline;

    //
    // If instance parameters exist, check instance stopped & marked cluster enabled
    //

    LPWSTR pwszServiceName = IISGetParameter( ResourceEntry->ParametersKey,
                                              PARAM_NAME__SERVICENAME );
    LPWSTR pwszInstanceId = IISGetParameter( ResourceEntry->ParametersKey,
                                             PARAM_NAME__INSTANCEID );

    if ( pwszServiceName && pwszInstanceId )
    {
        InstanceEnableCluster( pwszServiceName, pwszInstanceId );
    }

    if ( pwszServiceName )
    {
        LocalFree(pwszServiceName);
    }
    if ( pwszInstanceId )
    {
        LocalFree(pwszInstanceId);
    }

	//
	// Initialize the metadata path for this instance
	//
	ResourceEntry->Params.MDPath = NULL;

	//
	// Set the resource's initial state to alive
	//
	ResourceEntry->bAlive = TRUE ;

    //
    // If this is first element being added to the list than start the polling thread
    //
    if ( IsListEmpty (&IISResourceTable) )
    {   
        //
        // Initialize the timestamp used in the isalive/looksalive to determine if the polling thread is still running
        //
        InterlockedExchange( (LPLONG) &g_dwTickOfLastResourceCheck, GetTickCount() );
        TR( (DEBUG_BUFFER,"[IISOpen] initialized g_dwTickOfLastResourceCheck (%d)\n", g_dwTickOfLastResourceCheck) );
        
        if( ERROR_SUCCESS != (status = ClusWorkerCreate( &g_cwAlivePollingThread, 
                                                        (PWORKER_START_ROUTINE)IISAlivePollingThread, 
                                                        &IISResourceTable)) )
        {
            TR( (DEBUG_BUFFER,"[IISOpen] Error creating IISAlivePollingThread %08x\n",status) );
            return (RESID)0;
        }
        
        TR( (DEBUG_BUFFER,"[IISOpen] created IISAlivePollingThread\n") );
    }
	

    //
    // Add to resource list
    //
    EnterCriticalSection(&IISTableLock);
    
        InsertHeadList( &IISResourceTable, &ResourceEntry->ListEntry );
        g_fIISResourceTable_HadChanged = TRUE;
    
    LeaveCriticalSection(&IISTableLock);

    (g_IISLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Open request succeeded with id = %1!u!.\n",
        ResourceEntry );
    TR( (DEBUG_BUFFER,"[IISOpen] token=%x Leave\n", ResourceEntry) );

    return (RESID)ResourceEntry;
} // IISOpen


DWORD
WINAPI
IISOnlineThread(
    IN PCLUS_WORKER     pWorker,
    IN LPIIS_RESOURCE   ResourceEntry
    )

/*++

Routine Description:

    Brings a share resource online.

Arguments:
    ResourceEntry - A pointer to a IIS_RESOURCE block for this resource

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD           status;
    DWORD           retry;
    RESOURCE_STATUS resourceStatus;

    TR( (DEBUG_BUFFER,"[IISOnlineThread] Enter\n") );

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState    = ClusterResourceOnlinePending;
    resourceStatus.WaitHint         = 0;
    resourceStatus.CheckPoint       = 1;

    ResourceEntry->State            = ClusterResourceOnlinePending;
    InterlockedExchange( (LPLONG) &ResourceEntry->bAlive, TRUE );

    if (IISReadParameters(ResourceEntry) != ERROR_SUCCESS)
    {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ERROR [OnLineThread] Could not read resource parameters\n");
        status = ERROR_RESOURCE_NOT_FOUND;
        TR( (DEBUG_BUFFER,"[IISOnlineThread] can't read parameters\n") );
        goto SendStatus;
    }

   (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"INFO [OnLineThread] Service = %1!ws! InstanceId = %2!ws!\n",
        ResourceEntry->Params.ServiceName,
        ResourceEntry->Params.InstanceId );

    //
    // get the server bindings information, if this fails should be able to pick the information up in the polling thread 
    //
    if ( ERROR_SUCCESS != (status = GetServerBindings( ResourceEntry->Params.MDPath, ResourceEntry->Params.ServiceType, &ResourceEntry->saServer, &ResourceEntry->dwPort )) )
    {
        TR( (DEBUG_BUFFER,"[IISOnLineThread] failed to get server bindings for %S (%d)\n", ResourceEntry->Params.MDPath, status) );
    }

    //
    // Try to Online the resources
    //
    //

    if ( !StartIIS( ResourceEntry ) )
    {
        status = ERROR_SERVICE_REQUEST_TIMEOUT;
	resourceStatus.ResourceState    = ClusterResourceFailed;
        ResourceEntry->State            = ClusterResourceFailed;
        TR( (DEBUG_BUFFER,"[IISOnlineThread] can't start IIS\n") );
    }
    else
    {
        status = SetInstanceState( pWorker,
                                   ResourceEntry,
                                   &resourceStatus,
                                   ClusterResourceOnline,
                                   L"online",
                                   MD_SERVER_COMMAND_START,
                                   MD_SERVER_STATE_STARTED );
    }

SendStatus:

    //
    // Set the state of the resource
    //

    (IISSetResourceStatus)( ResourceEntry->ResourceHandle,
                             &resourceStatus );

    TR( (DEBUG_BUFFER,"[IISOnlineThread] status = %d, Leave\n",status) );

    return status;

} // IISOnlineThread


DWORD
WINAPI
IISOfflineThread(
    IN PCLUS_WORKER     pWorker,
    IN LPIIS_RESOURCE   ResourceEntry
    )

/*++

Routine Description:

    Brings a share resource offline.

Arguments:
    ResourceEntry - A pointer to a IIS_RESOURCE block for this resource

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD           status;
    DWORD           retry;
    RESOURCE_STATUS resourceStatus;

    TR( (DEBUG_BUFFER,"[IISOfflineThread] Enter\n") );

#if defined(DBG_CANT_VERIFY)
    if ( g_fDbgCantVerify )
    {
        TR( (DEBUG_BUFFER,"[IISOfflineThread] skip stop after failure to verify service\n") );
        return ERROR_INVALID_PARAMETER;
    }
#endif

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState    = ClusterResourceOfflinePending;
    resourceStatus.WaitHint         = 0;
    resourceStatus.CheckPoint       = 1;

    ResourceEntry->State            = ClusterResourceOfflinePending;

    if (IISReadParameters(ResourceEntry) != ERROR_SUCCESS)
    {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ERROR [OffLineThread] Could not read resource parameters\n");
        status = ERROR_RESOURCE_NOT_FOUND;
        goto SendStatus;
    }

   (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"INFO [OffLineThread] Service = %1!ws! InstanceId = %2!ws!\n",
        ResourceEntry->Params.ServiceName,
        ResourceEntry->Params.InstanceId );

    //
    // Try to Offline the resources
    //
    //

    status = SetInstanceState( pWorker, ResourceEntry, &resourceStatus, ClusterResourceOffline, L"offline", MD_SERVER_COMMAND_STOP, MD_SERVER_STATE_STOPPED );

SendStatus:

    //
    // Set the state of the resource
    //

    (IISSetResourceStatus)( ResourceEntry->ResourceHandle,
                             &resourceStatus );

    TR( (DEBUG_BUFFER,"[IISOfflineThread] status = %d, Leave\n",status) );

    return(status);
} // IISOfflineThread


DWORD
WINAPI
IISOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for IIS resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    LPIIS_RESOURCE  ResourceEntry = NULL;
    DWORD           status;

    TR( (DEBUG_BUFFER,"[IISOnline] Enter\n") );

    //
    // Get a valid resource
    //

    ResourceEntry = GetValidResource(Resource,L"OnLine");
    if ( ResourceEntry == NULL )
    {
        return ERROR_RESOURCE_NOT_FOUND;
    }

    //
    // Log the online request
    //

    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request for IIS Resource %1!u! (%2!ws!).\n",
        Resource,
        ResourceEntry->ResourceName );

    // Terminate (or wait) for workers
    ClusWorkerTerminate( &ResourceEntry->OnlineThread );
    ClusWorkerTerminate( &ResourceEntry->OfflineThread );

    status = ClusWorkerCreate( &ResourceEntry->OnlineThread,
                               (PWORKER_START_ROUTINE)IISOnlineThread,
                               ResourceEntry );
    if ( status == ERROR_SUCCESS )
    {
        return ERROR_IO_PENDING;
    }

    //
    // Failure
    //

    (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online request failed, error %1!u!.\n",
            GetLastError() );

    TR( (DEBUG_BUFFER,"[IISOnline] failed %d, Leave\n",GetLastError()) );

    return status;

} // IISOnline


VOID
WINAPI
IISTerminate(
    IN RESID Resource
    )

/*++

Routine Description:

    Terminate routine for IIS resource.

Arguments:

    Resource - supplies resource id to be terminated

Return Value:

    None.

--*/

{
    DWORD           status;
    LPIIS_RESOURCE  ResourceEntry;
    DWORD           dwS;
    int             retry;

    TR( (DEBUG_BUFFER,"[IISTerminate] Enter\n") );

#if defined(DBG_CANT_VERIFY)
    if ( g_fDbgCantVerify )
    {
        TR( (DEBUG_BUFFER,"[IISTerminate] skip stop after failure to verify service\n") );
        return;
    }
#endif

    //
    // Get a valid resource entry, return on error
    //

    ResourceEntry = GetValidResource(Resource,L"Terminate");
    if (ResourceEntry == NULL)
    {
        return;
    }
	
    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate or offline request for Resource%1!u! (%2!ws!).\n",
        Resource,
        ResourceEntry->ResourceName );
	
    //
    // Try to take the resources offline, dont return if an error since
    // the resources may be offline when terminate called
    //
	
	//
	// Terminate the Online & Offline Threads
	//
	
	ClusWorkerTerminate( &ResourceEntry->OnlineThread);
	ClusWorkerTerminate( &ResourceEntry->OfflineThread);
	
	status = ERROR_SERVICE_NOT_ACTIVE;
	
	CMetaData MD;
	
	if ( MD.Open( ResourceEntry->Params.MDPath,
		FALSE,
		METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
	{
		if ( MD.GetDword( L"", MD_SERVER_STATE, IIS_MD_UT_SERVER, &dwS, 0 ) )
		{
			TR( (DEBUG_BUFFER,"[IISTerminate] state prob is %d\n",dwS) );
		}
		else
		{
			TR( (DEBUG_BUFFER,"[IISTerminate] failed to probe server state\n") );
			dwS = 0xffffffff;
		}
		
		if ( dwS != MD_SERVER_STATE_STOPPED )
		{
			if ( MD.SetDword( L"", MD_CLUSTER_SERVER_COMMAND, IIS_MD_UT_SERVER, MD_SERVER_COMMAND_STOP, 0 ) )
			{
				MD.Close();
				TR( (DEBUG_BUFFER,"[IISTerminate] command set to %d\n",MD_SERVER_COMMAND_STOP) );
				status = ERROR_SUCCESS;
				for ( retry = 3 ; retry-- ; )
				{
					if ( MD.GetDword( ResourceEntry->Params.MDPath, MD_SERVER_STATE, IIS_MD_UT_SERVER, &dwS, 0 ) )
					{
						if ( dwS == MD_SERVER_STATE_STOPPED )
						{
							break;
						}
					}
					else
					{
						TR( (DEBUG_BUFFER,"[IISTerminate] failed to get server state\n") );
						break;
					}
					
					Sleep(SERVER_START_DELAY);
				}
			}
			else
			{
				MD.Close();
				TR( (DEBUG_BUFFER,"[IISTerminate] failed to set command to %d\n",MD_SERVER_COMMAND_STOP) );
			}
		}
		else
		{
			status = ERROR_SUCCESS;
			MD.Close();
		}
	}
	
	
	if ( status != ERROR_SUCCESS )
	{
		(g_IISLogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Error removing Resource. Error %1!u!. Resource.  %2!ws! Service. %3!ws!\n",
			status,
			ResourceEntry->ResourceName,
			ResourceEntry->Params.ServiceName);
	}
	
    //
    // Set status to offline
    //
    ResourceEntry->State = ClusterResourceOffline;
	
    TR( (DEBUG_BUFFER,"[IISTerminate] Leave\n") );

} // IISTerminate


DWORD
WINAPI
IISOffline(
    IN RESID Resource
    )

/*++

Routine Description:

    Offline routine for IIS resource.

Arguments:

    Resource - supplies the resource it to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    LPIIS_RESOURCE  ResourceEntry = NULL;
    DWORD           status;

    //
    // Get a valid resource
    //
    ResourceEntry = GetValidResource(Resource,L"OffLine");
    if ( ResourceEntry == NULL )
    {
        return ERROR_RESOURCE_NOT_FOUND;
    }

    //
    // Log the online request
    //

    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request for IIS Resource %1!u! (%2!ws!).\n",
        Resource,
        ResourceEntry->ResourceName );

    // Terminate (or wait) for workers
    ClusWorkerTerminate( &ResourceEntry->OnlineThread );
    ClusWorkerTerminate( &ResourceEntry->OfflineThread );

    status = ClusWorkerCreate( &ResourceEntry->OfflineThread,
                               (PWORKER_START_ROUTINE)IISOfflineThread,
                               ResourceEntry );
    if ( status == ERROR_SUCCESS )
    {
        return ERROR_IO_PENDING;
    }

    //
    // Failure
    //

    (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline request failed, error %1!u!.\n",
            GetLastError() );

    return status;

} // IISOffline


BOOL
WINAPI
IISIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for IIS service resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - if service is running

    FALSE - if service is in any other state

--*/
{
    LPIIS_RESOURCE  ResourceEntry;
    DWORD           dwTickDifference = 0;
    DWORD           dwCurrent;
    DWORD           dwTickOfLastResourceCheck = 0;

    //
    // Get a valid resource
    //
    ResourceEntry = GetValidResource(Resource,L"IsAlive");
    if (ResourceEntry == NULL)
    {
        return(FALSE);
    }

    //
    // Save the current global tick count so it can't change during the calculation
    //
    dwTickOfLastResourceCheck = g_dwTickOfLastResourceCheck;
    
    //
    // Save the current tick count
    // 
    dwCurrent = GetTickCount();

    if (dwCurrent >= g_dwTickOfLastResourceCheck)
    {
        dwTickDifference = dwCurrent - g_dwTickOfLastResourceCheck ;
    }
    else
    {
        dwTickDifference = (0xFFFFFFFF - g_dwTickOfLastResourceCheck) + dwCurrent ;
    }

    //
    // if the polling thread is taking too long there must be a problem 
    //	
    if ( dwTickDifference > MAX_DIFFERENCE_BETWEEN_RESOURCE_CHECKS)
    {
        TR( (DEBUG_BUFFER,"[IsAlive] (dwTickDifference(%d) > MAX_DIFFERENCE_BETWEEN_RESOURCE_CHECKS) returning FALSE dwCurrent(%d) dwTickOfLastResourceCheck(%d)\n", dwTickDifference, dwCurrent, dwTickOfLastResourceCheck) );
        return FALSE;
    }

    return ResourceEntry->bAlive ;

} // IISIsAlive



BOOL
WINAPI
IISLooksAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    LooksAlive routine for IIS resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    LPIIS_RESOURCE  ResourceEntry;
    DWORD           dwTickDifference = 0;
    DWORD           dwCurrent;
    DWORD           dwTickOfLastResourceCheck = 0;

    //
    // Get a valid resource
    //
    ResourceEntry = GetValidResource(Resource,L"LooksAlive");
    if (ResourceEntry == NULL)
    {
        return(FALSE);
    }

    //
    // Save the current global tick count so it can't change during the calculation
    //
    dwTickOfLastResourceCheck = g_dwTickOfLastResourceCheck;
    
    //
    // Save the current tick count
    // 
    dwCurrent = GetTickCount();

    if (dwCurrent >= g_dwTickOfLastResourceCheck)
    {
        dwTickDifference = dwCurrent - g_dwTickOfLastResourceCheck ;
    }
    else
    {
        dwTickDifference = (0xFFFFFFFF - g_dwTickOfLastResourceCheck) + dwCurrent ;
    }

    //
    // if the polling thread is taking too long there must be a problem 
    //	
    if ( dwTickDifference > MAX_DIFFERENCE_BETWEEN_RESOURCE_CHECKS )
    {
        TR( (DEBUG_BUFFER,"[LooksAlive] (dwTickDifference(%d) > MAX_DIFFERENCE_BETWEEN_RESOURCE_CHECKS) returning FALSE dwCurrent(%d) dwTickOfLastResourceCheck(%d)\n", dwTickDifference, dwCurrent, dwTickOfLastResourceCheck) );
        return FALSE;
    }

    return ResourceEntry->bAlive ;

} // IISLooksAlive



VOID
WINAPI
IISClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for IIS resource.

Arguments:

    Resource - supplies resource id to be closed

Return Value:

    None.

--*/

{
    LPIIS_RESOURCE      ResourceEntry = NULL;

    //
    // Get a valid resource
    //
    ResourceEntry = GetValidResource( Resource, L"Close");
    if (ResourceEntry == NULL)
    {
        return; // this should not happen
    }

    (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Close request  for resource '%1!ws!' Service '%2!ws!' \n",
            ResourceEntry->ResourceName,
            ResourceEntry->Params.ServiceName);
    //
    // Remove from list
    //
    EnterCriticalSection(&IISTableLock);
    
        RemoveEntryList( &ResourceEntry->ListEntry );
        g_fIISResourceTable_HadChanged = TRUE;

        
        DestructIISResource(ResourceEntry);
		
		if ( g_lOpenRefs > 0 )
		{
			if ( !InterlockedDecrement( &g_lOpenRefs ) )
			{
				CMetaData::Terminate();
			}
		}
	
    LeaveCriticalSection(&IISTableLock);

	//
	// If this was the last resource in the list than stop the polling thread
	//
	if ( IsListEmpty (&IISResourceTable) )
	{
		ClusWorkerTerminate( &g_cwAlivePollingThread );
		
		TR( (DEBUG_BUFFER,"[IISClose] Terminated IISAlivePollingThread\n") );
	}

} // IISClose


LPIIS_RESOURCE
GetValidResource(
    IN RESID    Resource,
    IN LPWSTR   RoutineName
    )

/*++

Routine Description:
    Validate the resource ID, log any error, return valid resource

Arguments:
    Resource - the resource to validate

    RoutineName - the routine that is requesting the validation

Return Value:
    Success - ResourceEntry
    NULL - Error


--*/
{
    DWORD           Index;
    LPIIS_RESOURCE  ResourceEntry;

    ResourceEntry = (LPIIS_RESOURCE)Resource;

    //
    // Check for a valid
    //
    if ( ResourceEntry == NULL )
    {
        (g_IISLogEvent)(
            NULL,
            LOG_ERROR,
            L"[%1!ws!] Resource Entry is NULL for Resource Id = %2!u!\n",
            RoutineName,
            Resource);

        return NULL;
    }

    //
    // Sanity check the resource struct
    //

    if ( ResourceEntry->Signature != IIS_RESOURCE_SIGNATURE )
    {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[%1!ws!] IIS Resource index sanity checked failed! Index = %2!u!.\n",
            RoutineName,
            Resource );

        return NULL;
    }

    return ResourceEntry;

}  // END GetValidResource



PWSTR
IISGetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )

/*++

Routine Description:

    Queries a REG_SZ parameter out of the registry and allocates the
    necessary storage for it.

Arguments:

    ClusterKey - Supplies the cluster key where the parameter is stored

    ValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter if successful.

    NULL if unsuccessful.

--*/

{
    PWSTR Value;
    PWSTR Value2;
    DWORD ValueLength;
    DWORD ValueType;
    DWORD Status;

    ValueLength = 0;

    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  NULL,
                                  &ValueLength);

    if ( (Status != ERROR_SUCCESS) &&
         (Status != ERROR_MORE_DATA) )
    {
        TR( (DEBUG_BUFFER,"[IISGetParameter] Failed to open %S, error %u\n",ValueName,Status) );
        return(NULL);
    }

    //
    // Add on the size of the null terminator.
    //
    ValueLength += sizeof(UNICODE_NULL);

    Value = (WCHAR*)LocalAlloc(LMEM_FIXED, ValueLength);
    if (Value == NULL)
    {
        return(NULL);
    }

    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  (LPBYTE)Value,
                                  &ValueLength);

    if (Status != ERROR_SUCCESS)
    {
        LocalFree(Value);
        Value = NULL;
    }
    else
    {
        //
        // Numeric value are prefixed with '!' to force them to be stored as string,
        // so remove leading '!' if present
        //

        if ( Value[0] == L'!' )
        {
            Value2 = (WCHAR*)LocalAlloc(LMEM_FIXED, ValueLength);
            if (Value2 == NULL)
            {
                LocalFree( Value );
                return(NULL);
            }
            wcscpy( Value2, Value + 1 );
            LocalFree( Value );
            Value = Value2;
        }
    }


    TR( (DEBUG_BUFFER,"[IISGetParameter] Read %S, length %d, value %S\n",ValueName,ValueLength,Value?Value:L"ERROR") );

    return(Value);

} // IISGetParameter



LPWSTR
GetResourceParameter(
        IN HRESOURCE   hResource,
        IN LPCWSTR     ValueName
        )

/*++

Routine Description:

    Opens the parameter key for the resource. Then Queries a REG_SZ parameter
    out of the registry and allocates the necessary storage for it.

Arguments:

    hResource - the resource to query

    ValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter if successful.

    NULL if unsuccessful.

--*/
{
    HKEY        hKey            = NULL;
    HKEY        hParametersKey  = NULL;
    DWORD       status;
    LPWSTR      paramValue       = NULL;

    //
    // Get Resource key
    //
    hKey = GetClusterResourceKey(hResource,KEY_READ);
    if (hKey == NULL)
    {
        return(NULL);
    }

    //
    // Get parameters key
    //
    status = ClusterRegOpenKey(hKey,
                            L"Parameters",
                            KEY_READ,
                            &hParametersKey );
    if (status != ERROR_SUCCESS)
    {
        goto error_exit;
    }

    paramValue = IISGetParameter(hParametersKey,ValueName);

    if (paramValue == NULL)
    {
        goto error_exit;
    }

error_exit:
    if (hParametersKey != NULL)
    {
        ClusterRegCloseKey(hParametersKey);
    }
    if (hKey != NULL)
    {
        ClusterRegCloseKey(hKey);
    }
    return(paramValue);

} // GetResourceParameter


DWORD
IISReadParameters(
    IN OUT LPIIS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Reads all the parameters for a resource.

Arguments:

    ResourceEntry - Entry in the resource table.

Return Value:

    ERROR_SUCCESS - Success

    ERROR_RESOURCE_NOT_FOUND - failure

--*/

{
    DWORD                           status;

    //
    // Read the parameters for the resource.
    //
    status = ResUtilReadProperties( ResourceEntry->ParametersKey,
                                    IISResourcePrivateProperties,
                                    (LPBYTE) &ResourceEntry->Params,
                                    ResourceEntry->ResourceHandle,
                                    g_IISLogEvent );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    return IISBuildInternalParameters( &ResourceEntry->Params );
}


DWORD
IISBuildInternalParameters(
    IN OUT IIS_PARAMS* Params
    )
/*++

Routine Description:

    Build all the parameters for a resource from wolfpack parameters

Arguments:

    ResourceEntry - Entry in the resource table.

Return Value:

    ERROR_SUCCESS - Success

    ERROR_RESOURCE_NOT_FOUND - failure

--*/

{
    DWORD                           status;
    INT                             iServiceType;
    DWORD                           length;

    //
    // Make sure we got passed a valid service name
    //

    for ( iServiceType = 0 ; iServiceType < MAX_SERVICE ; iServiceType++ )
    {
        if ( lstrcmpiW( Params->ServiceName, ActualServiceName[iServiceType] ) == 0 )
        {
            break;
        }
    }

    if ( iServiceType >= MAX_SERVICE )
    {
        TR( (DEBUG_BUFFER,"[IISBuildInternalParameters] Invalid service name %S", Params->ServiceName) );
        return ERROR_RESOURCE_NOT_FOUND;
    }

    Params->ServiceType = iServiceType;

    //
    // Build MetaData path
    //

    TCHAR   achMDPath[80];
    DWORD   dwL;

    dwL = wsprintf( achMDPath, L"/LM/%s/%s", Params->ServiceName, Params->InstanceId );

    Params->MDPath = (WCHAR*)LocalAlloc( LMEM_FIXED, (dwL+1)*sizeof(WCHAR) );
    if ( Params->MDPath == NULL )
    {
        return ERROR_RESOURCE_NOT_FOUND;
    }
    memcpy( Params->MDPath, achMDPath,(dwL+1)*sizeof(TCHAR) );

    TR( (DEBUG_BUFFER,"[IISBuildInternalParameters] Built path %S\n", Params->MDPath) );

    return(ERROR_SUCCESS);
} // IISReadParameters


VOID
IISInitializeParams(
    IN OUT IIS_PARAMS* Params
    )
{
    ZeroMemory( Params, sizeof(IIS_PARAMS) );
}


VOID
IISFreeInternalParameters(
    IN IIS_PARAMS* Params
    )
{
    if ( Params->MDPath )
    {
        LocalFree( Params->MDPath );
        Params->MDPath = NULL;
    }
}


DWORD
IISGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for resources of type IIS server instance.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    typedef struct DEP_DATA
    {
        CLUSPROP_SZ_DECLARE( ipaddrEntry, sizeof(IP_ADDRESS_RESOURCE_NAME) / sizeof(WCHAR) );
        CLUSPROP_SYNTAX endmark;
    } DEP_DATA, *PDEP_DATA;
    PDEP_DATA   pdepdata = (PDEP_DATA)OutBuffer;
    DWORD       status;

    *BytesReturned = sizeof(DEP_DATA);
    if ( OutBufferSize < sizeof(DEP_DATA) )
    {
        if ( OutBuffer == NULL )
        {
            status = ERROR_SUCCESS;
        }
        else
        {
            TR( (DEBUG_BUFFER,"[IISGetRequiredDependencies] buffer too small: %d bytes\n",OutBufferSize) );
            status = ERROR_MORE_DATA;
        }
    }
    else
    {
        ZeroMemory( pdepdata, sizeof(DEP_DATA) );
        pdepdata->ipaddrEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->ipaddrEntry.cbLength = sizeof(IP_ADDRESS_RESOURCE_NAME);
        lstrcpyW( pdepdata->ipaddrEntry.sz, IP_ADDRESS_RESOURCE_NAME );
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return status;

} // IISGetRequiredDependencies



DWORD
IISResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for IIS Virtual Root resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status = ERROR_SUCCESS;
    LPIIS_RESOURCE      resourceEntry = NULL;
    IIS_PARAMS          params;

    //
    // Get a valid resource
    //
    resourceEntry = GetValidResource( ResourceId, L"ResourceControl");
    if ( resourceEntry == NULL )
    {
        return ERROR_RESOURCE_NOT_FOUND;    // this should not happen
    }

    switch ( ControlCode )
    {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            TR( (DEBUG_BUFFER,"[IISResourceControl] CLUSCTL_RESOURCE_UNKNOWN : status = %d\n",status) );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = IISGetRequiredDependencies(
                        OutBuffer,
                        OutBufferSize,
                        BytesReturned
                        );
            TR( (DEBUG_BUFFER,"[IISResourceControl] CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES : status = %d\n",status) );
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = IISGetPrivateResProperties( resourceEntry,
                                                 OutBuffer,
                                                 OutBufferSize,
                                                 BytesReturned );
            TR( (DEBUG_BUFFER,"[IISResourceControl] CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES : status = %d\n",status) );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = IISValidatePrivateResProperties(
                        resourceEntry,
                        InBuffer,
                        InBufferSize,
                        &params );
            TR( (DEBUG_BUFFER,"[IISResourceControl] CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES : status = %d\n",status) );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = IISSetPrivateResProperties(
                        resourceEntry,
                        InBuffer,
                        InBufferSize );
            TR( (DEBUG_BUFFER,"[IISResourceControl] CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES : status = %d\n",status) );
            break;

        case CLUSCTL_RESOURCE_DELETE:
            InstanceDisableCluster( resourceEntry->Params.ServiceName, resourceEntry->Params.InstanceId);
            IISReplicateProperties(NULL, &(resourceEntry->Params));
            TR( (DEBUG_BUFFER,"[IISResourceControl] CLUSCTL_RESOURCE_DELETE : status = %d\n",status) );
            break;
            
        default:
            status = ERROR_INVALID_FUNCTION;
            TR( (DEBUG_BUFFER,"[IISResourceControl] default %d: status = %d\n",ControlCode,status) );
            break;
    }

    return(status);

} // IISResourceControl



DWORD
IISResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for IIS Virtual Root resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;

    switch ( ControlCode )
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = IISGetRequiredDependencies(
                        OutBuffer,
                        OutBufferSize,
                        BytesReturned
                        );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // IISResourceTypeControl


DWORD
IISGetPrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type IIS.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      IISResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA )
    {
        *BytesReturned = required;
    }

    return(status);

} // IISGetPrivateResProperties


DWORD
IISValidatePrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PIIS_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type IIS Virtual Root.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameters structure to fill in. Pointers in this
        structure will point to the data in InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    IIS_PARAMS      params;
    PIIS_PARAMS     pParams;

    //
    // Check if there is input data.
    //

    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) )
    {
        return(ERROR_INVALID_DATA);
    }

    //
    // Duplicate the resource parameter block.
    //

    if ( Params == NULL )
    {
        pParams = &params;
    }
    else
    {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(params) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &ResourceEntry->Params,
                                       IISResourcePrivateProperties );
    if ( status != ERROR_SUCCESS )
    {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( IISResourcePrivateProperties,
                                         NULL,
                                         TRUE,
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );


    //
    // Cleanup our parameter block.
    //
    if ( pParams == &params )
    {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   IISResourcePrivateProperties );
    }

    return(status);

} // IISValidatePrivateResProperties



DWORD
IISSetPrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type IIS Virtual Root.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    DWORD           dupstatus = ERROR_SUCCESS;
    IIS_PARAMS      params;

    IISInitializeParams( &params );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = IISValidatePrivateResProperties( ResourceEntry,
                                              InBuffer,
                                              InBufferSize,
                                              &params );
    if ( status != ERROR_SUCCESS )
    {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   IISResourcePrivateProperties );
        return(status);
    }

    //
    // Save the original paramters. Use them to unset properties.
    //

    IIS_PARAMS  oldParams;

    dupstatus = ResUtilDupParameterBlock( (LPBYTE) &oldParams,
                                          (LPBYTE) &ResourceEntry->Params,
                                            IISResourcePrivateProperties
                                    );
    
    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               IISResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    //
    // If the resource is online, return a non-success status.
    //

    if (status == ERROR_SUCCESS)
    {
        if ( params.ServiceName && params.InstanceId )
        {
            if ( IISBuildInternalParameters( &params ) == ERROR_SUCCESS )
            {
                //
                // Reflect all properties we set to other nodes of the cluster.
                //

                if (ERROR_SUCCESS == dupstatus)
                {
                    InstanceDisableCluster( oldParams.ServiceName, oldParams.InstanceId);
                    IISReplicateProperties(&params, &oldParams);
                }
                else
                {
                    IISReplicateProperties(&params, NULL);
                }
        
                InstanceEnableCluster( params.ServiceName, params.InstanceId );

                IISFreeInternalParameters( &params );
            }
        }

        if ( (ResourceEntry->State == ClusterResourceOnline) ||
             (ResourceEntry->State == ClusterResourceOnlinePending) )
        {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        }
        else
        {
            status = ERROR_SUCCESS;
        }
    }
    
    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               IISResourcePrivateProperties );

    if (ERROR_SUCCESS == dupstatus)
    {
        ResUtilFreeParameterBlock( (LPBYTE) &oldParams,
                                   (LPBYTE) &ResourceEntry->Params,
                                   IISResourcePrivateProperties );
    }
    
    return status;

} // IISSetPrivateResProperties

void
IISReplicateProperties(
    IN IIS_PARAMS* lpNewParams, 
    IN IIS_PARAMS* lpOldParams
    )
{
    //
    // Get Local Computer Name. Do not replicate to local computer
    //

    WCHAR   wszLocalComputerName[MAX_COMPUTERNAME_LENGTH+1] = L"";
    DWORD   dwLength = MAX_COMPUTERNAME_LENGTH+1;
    
    GetComputerName(wszLocalComputerName, &dwLength);
    
    HCLUSTER  hClus = OpenCluster(NULL);

    if (hClus)
    {
        HCLUSENUM hClusEnumNode = ClusterOpenEnum( hClus, CLUSTER_ENUM_NODE);

        if (hClusEnumNode)
        {
            DWORD   dwType, dwIndex = 0;
            WCHAR   wszNodeName[MAX_COMPUTERNAME_LENGTH+1] = L"";
            DWORD   cbBufferLength = MAX_COMPUTERNAME_LENGTH+1;

            while ( ERROR_SUCCESS == ClusterEnum(   hClusEnumNode, 
                                                    dwIndex, 
                                                    &dwType, 
                                                    wszNodeName, 
                                                    &cbBufferLength))
            {
                dwIndex++;
    
                //
                // Set these properties on the node (if not local computer)
                //

                if (wcscmp(wszNodeName, wszLocalComputerName))
                {
                    IISSetRemoteNodeProperties(wszNodeName, lpNewParams, lpOldParams);
                }

                cbBufferLength = MAX_COMPUTERNAME_LENGTH+1;
            }

            ClusterCloseEnum(hClusEnumNode);
        }

        CloseCluster(hClus);
    }
}   // IISReplicateProperties

void
IISSetRemoteNodeProperties(
    IN LPWSTR      wszNodeName,
    IN IIS_PARAMS* lpNewParams, 
    IN IIS_PARAMS* lpOldParams
    )
{
    IMSAdminBaseW *     pcAdmCom = NULL;
    METADATA_HANDLE     hmd;
    HRESULT             hRes = S_OK;
    COSERVERINFO        csiMachine;
    MULTI_QI            QI = {&IID_IMSAdminBase, NULL, 0};

    //
    // Open Metabase path to the remote Node
    //
  
    ZeroMemory( &csiMachine, sizeof(COSERVERINFO) );
    csiMachine.pwszName = (LPWSTR)wszNodeName;

    hRes = CoCreateInstanceEx(  GETAdminBaseCLSID(TRUE), 
                                NULL, 
                                CLSCTX_SERVER, 
                                &csiMachine,
                                1,
                                &QI
                              );

    if ( SUCCEEDED(hRes) && SUCCEEDED(QI.hr))
    {
        WCHAR           achMDPath[80];
        METADATA_RECORD mdRecord;
        DWORD           dwVal;

        pcAdmCom = (IMSAdminBaseW *)QI.pItf;

        if ( lpOldParams && lpOldParams->ServiceName && lpOldParams->InstanceId)
        {
            wcscpy(achMDPath,L"/LM/");
            wcscat(achMDPath,lpOldParams->ServiceName);
            wcscat(achMDPath,L"/");
            wcscat(achMDPath,lpOldParams->InstanceId);

            dwVal = 0;
            
            if( SUCCEEDED( pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                              achMDPath,
                                              METADATA_PERMISSION_WRITE,
                                              5000,
                                              &hmd)) )
            {
                MD_SET_DATA_RECORD (    &mdRecord, 
                                        MD_CLUSTER_ENABLED,
                                        METADATA_INHERIT,
                                        IIS_MD_UT_SERVER,
                                        DWORD_METADATA,
                                        sizeof(DWORD),
                                        &dwVal
                                    );
                                    
                pcAdmCom->SetData( hmd, L"", &mdRecord);  
                pcAdmCom->CloseKey( hmd );
            }        
        }

        if ( lpNewParams && lpNewParams->ServiceName && lpNewParams->InstanceId)
        {
            wcscpy(achMDPath,L"/LM/");
            wcscat(achMDPath,lpNewParams->ServiceName);
            wcscat(achMDPath,L"/");
            wcscat(achMDPath,lpNewParams->InstanceId);
            
            dwVal = 1;

            if( SUCCEEDED( pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                              achMDPath,
                                              METADATA_PERMISSION_WRITE,
                                              5000,
                                              &hmd)) )
            {
                MD_SET_DATA_RECORD (    &mdRecord, 
                                        MD_CLUSTER_ENABLED,
                                        METADATA_INHERIT,
                                        IIS_MD_UT_SERVER,
                                        DWORD_METADATA,
                                        sizeof(DWORD),
                                        &dwVal
                                    );
                                    
                pcAdmCom->SetData( hmd, L"", &mdRecord);  
                pcAdmCom->CloseKey( hmd );
            }        
        }

        pcAdmCom->Release();
    }
}   // IISSetRemoteNodeProperties


DWORD
WINAPI
IISAlivePollingThread(
    IN PCLUS_WORKER     pWorker,
    IN LPVOID           lpVoid    )

/*++

Routine Description:

    Polls the state of the given resource
    
Arguments:
    
Returns:

    Win32 error code.

--*/

{
    BOOL                bIsAlive       = TRUE;
    BOOL                bFoundRes      = FALSE;
    DWORD               dwStatus       = ERROR_SUCCESS;
    PLIST_ENTRY         pRes           = NULL;              // temp list entry for looping
    PLIST_ENTRY         pListStart     = NULL;              // temp list head used for looping
    PLIST_ENTRY         pEntry         = NULL;              // list entry used to check the list of resources 
    LPIIS_RESOURCE      pResourceEntry = NULL;              // resource entry that corresponds to the list entry

    TR( (DEBUG_BUFFER,"[IISAlivePollingThread] Thread Started \n") );

    while ( !ClusWorkerCheckTerminate( &g_cwAlivePollingThread ) )
    {
        DWORD    dwPort            = 0;
        SOCKADDR saServer;
        DWORD    dwServiceType     = 0;
        LPWSTR   szMDPath          = NULL;
        BOOL     bReadBindingsInfo = FALSE ;
        
        //
        // update the time stamp that is used by the isalive/looksalive check to determine this thread is still running
        //
        InterlockedExchange( (LPLONG) &g_dwTickOfLastResourceCheck, GetTickCount() );
        TR( (DEBUG_BUFFER,"[IISAlivePollingThread] set g_dwTickOfLastResourceCheck (%d)\n", g_dwTickOfLastResourceCheck) );
        
        EnterCriticalSection( &IISTableLock );
        {
            // 
            // check that the list is not empty 
            //
            if ( IsListEmpty ( &IISResourceTable ) )
            {
                LeaveCriticalSection( &IISTableLock );
                pEntry = NULL;

                goto done_check;
            }

            //
            // if we don't have a list element yet get the fisrt element in the list
            //
            if ( !pEntry || g_fIISResourceTable_HadChanged)
            {
                pEntry = IISResourceTable.Flink;
                g_fIISResourceTable_HadChanged = FALSE;
            }
            
            //
            // look for an element in the list that is OnLine 
            //
            bFoundRes  = FALSE ;

            pListStart = pEntry;

            do 
            {
                if ( &IISResourceTable != pEntry )
                {
                    //
                    // get the structure that contains this list element 
                    //
                    pResourceEntry = CONTAINING_RECORD( pEntry, 
                        IIS_RESOURCE,
                        ListEntry );
                    
                    if ( pResourceEntry && 
                        (ClusterResourceOnline == pResourceEntry->State) )
                    {
                        //
                        // grab the info that we need from this structure so we can release the critical section 
                        //
                        dwPort        = pResourceEntry->dwPort;
                        dwServiceType = pResourceEntry->Params.ServiceType;
                        memcpy( (LPVOID) &saServer, (LPVOID) &pResourceEntry->saServer, sizeof(SOCKADDR) );

                        //
                        // allocate memory for the metabase path for this resource
                        //
                        if ( pResourceEntry->Params.MDPath )
                        {
                            szMDPath = (LPWSTR) LocalAlloc ( LPTR, (lstrlen(pResourceEntry->Params.MDPath)+1) * sizeof(WCHAR) ) ;
                            if ( szMDPath )
                            {
                                lstrcpy( szMDPath, pResourceEntry->Params.MDPath );
                    
                                TR( (DEBUG_BUFFER,"[IISAlivePollingThread] checking resource (%S/%S), State:%d OnLineState:%d\n", pResourceEntry->Params.ServiceName, pResourceEntry->Params.InstanceId, pResourceEntry->State, ClusterResourceOnline) );

                                bFoundRes = TRUE;
                                break;
                            }
                            else 
                            {
                                TR( (DEBUG_BUFFER,"[IISAlivePollingThread] Failed to allocate memory for metadata path\n") );
                            }
                        }
                        
                        if ( szMDPath ) TR( (DEBUG_BUFFER,"[IISAlivePollingThread] Checking resource Metadata Path:%S\n", szMDPath) );
                    }
                    else
                    {
                        if ( pResourceEntry ) TR( (DEBUG_BUFFER,"[IISAlivePollingThread] Not checking resource (%S/%S) because it's not Online, State:%d OnLineState:%d\n", pResourceEntry->Params.ServiceName, pResourceEntry->Params.InstanceId, pResourceEntry->State, ClusterResourceOnline) );
                    }
                }

                //
                // check the next element 
                //
                pEntry = pEntry->Flink ;
            } 
            while ( pListStart != pEntry ); 

            //
            // verify the loop ended because a valid resource was found 
            // 
            if ( !bFoundRes ) 
            {
                LeaveCriticalSection( &IISTableLock );
                pEntry = NULL;

                goto done_check;
            }
        }
        LeaveCriticalSection( &IISTableLock );
        
        //
        // if the service status check (isalive/looksalive check) fails then get server bindings and try again
        //
        if ( ERROR_SUCCESS != (dwStatus = VerifyIISService( szMDPath, dwServiceType, dwPort, saServer, g_IISLogEvent )) )
        {
            TR( (DEBUG_BUFFER,"[IISAlivePollingThread] VerifyIISService failed , calling GetServerBindings() and retrying \n") );

            if ( ERROR_SUCCESS == (dwStatus = GetServerBindings( szMDPath, dwServiceType, &saServer, &dwPort )) )
            {
                bReadBindingsInfo = TRUE ;
                dwStatus = VerifyIISService( szMDPath, dwServiceType, dwPort, saServer, g_IISLogEvent );
            }   
        }
       
        bIsAlive = (dwStatus == ERROR_SUCCESS);

        if ( szMDPath )
        {
            LocalFree ( szMDPath );
            szMDPath = NULL;
        }
        
        EnterCriticalSection( &IISTableLock );
        {
            // 
            // check that the list is not empty 
            //
            if ( IsListEmpty ( &IISResourceTable ) )
            {
                LeaveCriticalSection( &IISTableLock );
                pEntry = NULL;

                goto done_check;
            }
            
            //
            // check that the element still exists in the list
            //
            bFoundRes = FALSE ;

            for ( pRes = IISResourceTable.Flink; 
                  pRes != &IISResourceTable;
                  pRes = pRes->Flink )
            {
                if ( pEntry == pRes )
                {
                    bFoundRes = TRUE ;
                    break;
                }
            }
            
            if( bFoundRes )
            {
                //
                // get the elemement
                //
                pResourceEntry = CONTAINING_RECORD( pEntry, 
                                                    IIS_RESOURCE,
                                                    ListEntry );
                
                //
                // update the element's state information (isalive/looksalive)
                //
                InterlockedExchange( (LPLONG)&pResourceEntry->bAlive , bIsAlive );
                
                TR( (DEBUG_BUFFER,"[IISAlivePollingThread] Updating IsAlive/LooksAlive status for resource Metadata Path:%S bAlive:%d State:%d\n", pResourceEntry->Params.MDPath, bIsAlive, pResourceEntry->State) );
                
                //
                // update the bindings info if new information was found . these assignments do not need to be sync'ed 
                // since the only other thread they are used in is in the online thread . before the resource has been marked online
                // so this code will never be executed at the same time .
                //
                if ( bReadBindingsInfo )
                {
                    pResourceEntry->dwPort = dwPort ;
                    memcpy( (LPVOID) &pResourceEntry->saServer, (LPVOID) &saServer, sizeof(SOCKADDR) );
                }

                //
                // print some error messages so users will know when a resource fails 
                //
                if ( !pResourceEntry->bAlive )
                {   
                    if ( g_IISLogEvent )
                    {
                        //
                        // Some type of error
                        //
                        (g_IISLogEvent)(
                            pResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"IsAlive/LooksAlive ERROR getting information for service %1!ws! resource %2!ws!\n",
                            pResourceEntry->Params.ServiceName,
                            pResourceEntry->ResourceName );
                    }
                    
                    if ( g_hEventLog )
                    {
                        LPCTSTR aErrStr[3];
                        WCHAR   aErrCode[32];
                        
                        _ultow( dwStatus, aErrCode, 10 );
                        
                        aErrStr[0] = pResourceEntry->Params.ServiceName;
                        aErrStr[1] = pResourceEntry->Params.InstanceId;
                        aErrStr[2] = aErrCode;
                        
                        ReportEvent( g_hEventLog,
                            EVENTLOG_ERROR_TYPE,
                            0,
                            IISCL_EVENT_CANT_ACCESS_IIS,
                            NULL,
                            sizeof(aErrStr)/sizeof(LPCTSTR),
                            0,
                            aErrStr,
                            NULL );
                    }
                }

                //
                // move to the next element 
                //
                pEntry = pEntry->Flink;
            }
            else
            {
                //
                // the resource was not found , probably deleted so pEntry is now invalid
                //
                pEntry = NULL;

                TR( (DEBUG_BUFFER,"[IISAlivePollingThread] Failed to find a resource after checking its state\n") );
            }
            
        }
        LeaveCriticalSection( &IISTableLock );
        
done_check:
        
        Sleep( DELAY_BETWEEN_ISALIVE_CHECKS );
    }

    TR( (DEBUG_BUFFER,"[IISAlivePollingThread] Thread Exiting \n") );

    return dwStatus;
    
} // IISAlivePollingThread

//***********************************************************
//
// Define Function Table
//
//***********************************************************

// Define entry points


CLRES_V1_FUNCTION_TABLE( IISFunctionTable,
                         CLRES_VERSION_V1_00,
                         IIS,
                         NULL,
                         NULL,
                         IISResourceControl,
                         IISResourceTypeControl );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\sync\regc.cpp ===
// regc.cpp : Implementation of Cregc
#include "stdafx.h"
#include "mdsync.h"
#include "regc.h"

/////////////////////////////////////////////////////////////////////////////
// Cregc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\sync\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\sync\mdsync.cpp ===
// MdSync.cpp : Implementation of CSyncApp and DLL registration.


extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
}   // extern "C"

#include <limits.h>
#include <ole2.h>
#include <wincrypt.h>

#include <dbgutil.h>
#include <buffer.hxx>

#include "mdsync.h"
#include "stdafx.h"
#include <iadmext.h>


#define ADMEX
#if defined(ADMEX)
#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <admex.h>
#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#endif
#include "mdsync.hxx"

//
#include "comrepl_i.c"
#include "comrepl.h"

//
// Global Functions
//

HRESULT
MTS_Propagate2
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer,
/* [in] */ DWORD dwSignatureMismatch
);


//
// Globals
//

DWORD g_dwFalse = FALSE;

const INT COMPUTER_CHARACTER_SIZE = 64;

/////////////////////////////////////////////////////////////////////////////
//

CProps::CProps(
    )
/*++

Routine Description:

    Property list constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_Props = NULL;
    m_dwProps = m_dwLenProps = 0;
    m_lRefCount = 0;
}


CProps::~CProps(
    )
/*++

Routine Description:

    Property list destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( m_Props )
    {
        LocalFree( m_Props );
    }
}


CNodeDesc::CNodeDesc(
    CSync* pSync
    )
/*++

Routine Description:

    Metabase node descriptor constructor

Arguments:

    pSync - ptr to synchronizer object

Returns:

    Nothing

--*/
{
    InitializeListHead(&m_ChildHead);
    m_pszPath = NULL;
    m_pSync = pSync;
    m_fHasProps = FALSE;
    m_fHasObjs = FALSE;
}


CNodeDesc::~CNodeDesc(
    )
/*++

Routine Description:

    Metabase node descriptor destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    LIST_ENTRY*     pChild;
    CNodeDesc*      pNode;

    if ( m_pszPath )
    {
        LocalFree( m_pszPath );
    }

    while ( !IsListEmpty( &m_ChildHead ))
    {
        pNode = CONTAINING_RECORD( m_ChildHead.Flink,
                                   CNodeDesc,
                                   m_ChildList );

        RemoveEntryList( &pNode->m_ChildList );

        delete pNode;
    }
}


BOOL
CNodeDesc::BuildChildObjectsList(
    CMdIf*  pMd,
    LPWSTR  pszPath
)
/*++

Routine Description:

    Build list of child object of this node

Arguments:

    pMd - metabase admin interface
    pszPath - path of current node

Returns:

    Nothing

--*/
{
    CNodeDesc*  pChild;
    WCHAR       achPath[METADATA_MAX_NAME_LEN*2];
    WCHAR       achSrcPath[METADATA_MAX_NAME_LEN];
    DWORD       dwP = wcslen( pszPath );
    UINT        i;
    DWORD       dwRequired;

    //
    // Ugly path trick : metabase will remove trailing '/',
    // so to specify an empty directory at the end of path
    // must add an additional trailing '/'
    //

    memcpy( achSrcPath, pszPath, (dwP + 1) * sizeof(WCHAR) );
    if ( dwP && pszPath[dwP-1] == L'/' )
    {
        achSrcPath[dwP] = L'/';
        achSrcPath[dwP+1] = L'\0';
    }

    memcpy( achPath, pszPath, dwP * sizeof(WCHAR) );
    achPath[dwP++] = L'/';

    //
    // enumerate child
    //

    for ( i = 0 ; ; ++i )
    {
        if ( pMd->Enum( achSrcPath, i, achPath+dwP ) )
        {
            if ( pChild = new CNodeDesc( m_pSync ) )
            {
                pChild->SetPath( achPath );
                InsertHeadList( &m_ChildHead, &pChild->m_ChildList );
            }
            else
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return FALSE;
            }
        }
        else if ( GetLastError() != ERROR_NO_MORE_ITEMS )
        {
            return FALSE;
        }
        else
        {
            break;
        }
    }

    return TRUE;
}


BOOL
CProps::GetAll(
    CMdIf*  pMd,
    LPWSTR  pszPath
    )
/*++

Routine Description:

    Get all properties for this node

Arguments:

    pMd - metabase admin interface
    pszPath - path of current node

Returns:

    Nothing

--*/
{
    DWORD   dwRec;
    DWORD   dwDataSet;
    BYTE    abBuff[4096];
    DWORD   dwRequired;

    if ( pMd->GetAllData( pszPath, &dwRec, &dwDataSet, abBuff, sizeof(abBuff), &dwRequired ) )
    {
        //
        // MetaBase does not update dwRequired supplied buffer is big enough
        // we must assume the whole buffer was used.
        //

        dwRequired = sizeof(abBuff);

        m_Props = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired );
        if ( !m_Props )
        {
            return FALSE;
        }
        m_dwProps = dwRec;
        m_dwLenProps = dwRequired;
        memcpy( m_Props, abBuff, dwRequired );
        return TRUE;
    }
    else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        m_Props = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired );
        if ( !m_Props )
        {
            return FALSE;
        }
        if ( pMd->GetAllData( pszPath, &dwRec, &dwDataSet, m_Props, dwRequired, &dwRequired ) )
        {
            m_dwLenProps = dwRequired;
            m_dwProps = dwRec;
            return TRUE;
        }
        LocalFree( m_Props );
        m_Props = NULL;
    }

    return FALSE;
}


BOOL
CSync::GetProp(
    LPWSTR  pszPath,
    DWORD   dwPropId,
    DWORD   dwUserType,
    DWORD   dwDataType,
    LPBYTE* ppBuf,
    LPDWORD pdwLen
    )
/*++

Routine Description:

    Get property for path

Arguments:

    pszPath - path of current node
    dwPropId - metadata property ID
    dwUserType - metadata user type
    dwDataType - metadata data type
    ppBuf - update with ptr to LocalAlloc'ed buffer or NULL if error
    pdwLen - updated with length

Returns:

    Nothing

--*/
{
    DWORD               dwRec;
    DWORD               dwDataSet;
    DWORD               dwRequired;
    METADATA_RECORD     md;

    memset( &md, '\0', sizeof(md) );

    md.dwMDDataType = dwDataType;
    md.dwMDUserType = dwUserType;
    md.dwMDIdentifier = dwPropId;

    md.dwMDDataLen = 0;

    if ( !wcsncmp( pszPath, L"LM/", 3 ) )
    {
        pszPath += 3;
    }

    if ( !m_Source.GetData( pszPath, &md, NULL, &dwRequired ) &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        *ppBuf = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired );
        if ( !*ppBuf )
        {
            return FALSE;
        }

        *pdwLen = md.dwMDDataLen = dwRequired;

        if ( m_Source.GetData( pszPath, &md, *ppBuf, &dwRequired ) )
        {
            return TRUE;
        }
        LocalFree( *ppBuf );
    }

    *ppBuf = NULL;

    return FALSE;
}


CSync::CSync(
    )
/*++

Routine Description:

    Synchronizer constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pRoot = NULL;
    m_pTargets = NULL;
    m_dwTargets = 0;
    m_fCancel = FALSE;
    InitializeListHead( &m_QueuedRequestsHead );
    INITIALIZE_CRITICAL_SECTION( &m_csQueuedRequestsList );
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    m_fInScan = FALSE;
    m_cbSeed = SEED_MD_DATA_SIZE;
    memset( m_rgbSeed, 0, m_cbSeed );
}


CSync::~CSync(
    )
/*++

Routine Description:

    Synchronizer destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    UINT    i;

    if ( m_pTargets )
    {
        for ( i = 0 ; i < m_dwTargets ; ++i )
        {
            if ( m_pTargets[i] )
            {
                delete m_pTargets[i];
            }
        }

        LocalFree( m_pTargets );
    }

    LIST_ENTRY*     pChild;
    CNseRequest*    pReq;

    while ( !IsListEmpty( &m_QueuedRequestsHead ))
    {
        pReq = CONTAINING_RECORD( m_QueuedRequestsHead.Flink,
                                  CNseRequest,
                                  m_QueuedRequestsList );

        RemoveEntryList( &pReq->m_QueuedRequestsList );

        delete pReq;
    }

    DeleteCriticalSection( &m_csQueuedRequestsList );
    DeleteCriticalSection( &m_csLock );
}


VOID
CSync::SetTargetError(
    DWORD dwTarget,
    DWORD dwError
    )
/*++

Routine Description:

    Set error status for specified target

Arguments:

    dwTarget - target ID
    dwError - error code

Returns:

    Nothing

--*/
{
    m_TargetStatus.SetStatus( dwTarget, dwError );
}


DWORD
WINAPI
ScanThread(
    LPVOID pV
    )
/*++

Routine Description:

    thread scanning a target for synchronization

Arguments:

    pV - ptr to scan context

Returns:

    Error code, 0 if success

--*/
{
    HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if (FAILED(hr))
    {
        return HRESULTTOWIN32(hr);
    }

    THREAD_CONTEXT * pThreadContext = (THREAD_CONTEXT *)pV;
    CSync          * pSync          = (CSync *) pThreadContext->pvContext;

    if ( !( pSync->ScanTarget( pThreadContext->dwIndex)))
    {
        CoUninitialize();

        return GetLastError();
    }

    CoUninitialize();

    return 0;
}


BOOL
CSync::ScanTarget(
    DWORD   dwI
    )
/*++

Routine Description:

    Scan target for synchronization

Arguments:

    dwI - target ID

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL    fSt;

    fSt = m_pRoot->ScanTarget( dwI );

    InterlockedDecrement( &m_lThreads );

    return fSt;
}


BOOL
CSync::GenerateKeySeed( )
/*++

Routine Description:

    Generate the seed which will be used to derive the session key for encryption and
    write it to the metabase

Arguments:

Returns:

    TRUE if successful, FALSE if not

--*/
{
#ifdef NO_ENCRYPTION

    return TRUE;

#else

    HCRYPTPROV hProv = NULL;
    BOOL fOk = TRUE;
    ALG_ID aiAlg = CALG_MD5;
    DWORD i = 0;

    if ( !m_Source.Open( L"/LM/W3SVC", METADATA_PERMISSION_WRITE ) )
    {
        return FALSE;
    }

    //
    // Seed header with version information, hash algorithm used and size of
    // seed used to generate the session key
    //
    m_rgbSeed[i++] = IIS_SEED_MAJOR_VERSION;
    m_rgbSeed[i++] = IIS_SEED_MINOR_VERSION;
    memcpy( m_rgbSeed + i, &aiAlg, sizeof( ALG_ID ) );
    i += sizeof( ALG_ID );
    m_rgbSeed[i++] = RANDOM_SEED_SIZE;

    DBG_ASSERT( i == SEED_HEADER_SIZE );

    //
    // Generate the seed
    //
    if ( ( fOk = CryptAcquireContext( &hProv,
                                      NULL,
                                      NULL,
                                      PROV_RSA_FULL,
                                      CRYPT_VERIFYCONTEXT ) )  &&
         ( fOk = CryptGenRandom( hProv,
                                 RANDOM_SEED_SIZE,
                                 m_rgbSeed + SEED_HEADER_SIZE ) ) )
    {
        //
        // Write the seed to the metabase
        //
        METADATA_RECORD mdr;

        MD_SET_DATA_RECORD( &mdr,
                            MD_SSL_REPLICATION_INFO,
                            METADATA_SECURE,
                            IIS_MD_UT_SERVER,
                            BINARY_METADATA,
                            m_cbSeed,
                            m_rgbSeed );

        fOk = m_Source.SetData( MB_REPLICATION_PATH,
                                &mdr,
                                (LPVOID) m_rgbSeed );
    }


    if ( hProv )
    {
        CryptReleaseContext( hProv,
                             0 );
    }

    m_Source.Close();

    return fOk;

#endif // NO_ENCRYPTION
}


BOOL CSync::PropagateKeySeed( VOID )
/*++

Routine Description:

    Propagate the session key seed to all the remote machines

Arguments:

    None

Returns:

    TRUE if successful, FALSE if not

--*/
{
#ifdef NO_ENCRYPTION

    return TRUE;

#else

    HRESULT hRes = S_OK;

    for ( DWORD dwIndex = 0; dwIndex < m_dwTargets; dwIndex++ )
    {
        if ( m_bmIsRemote.GetFlag( dwIndex ))
        {
            if ( !m_pTargets[dwIndex]->Open( L"/LM/W3SVC",
                                             METADATA_PERMISSION_WRITE ) )
            {
                if ( GetLastError() == ERROR_SUCCESS )
                {
                    SetLastError( RPC_S_SERVER_UNAVAILABLE );
                }
                m_TargetStatus.SetStatus( dwIndex, GetLastError() );
            }
            else
            {
                //
                // Write the seed to the remote metabase
                //
                METADATA_RECORD mdr;

                MD_SET_DATA_RECORD( &mdr,
                                    MD_SSL_REPLICATION_INFO,
                                    METADATA_SECURE,
                                    IIS_MD_UT_SERVER,
                                    BINARY_METADATA,
                                    m_cbSeed,
                                    m_rgbSeed );

                if ( !m_pTargets[dwIndex]->SetData( MB_REPLICATION_PATH,
                                                    &mdr,
                                                    (LPVOID) m_rgbSeed ) )
                {
                    m_TargetStatus.SetStatus( dwIndex, GetLastError() );
                }

                m_pTargets[dwIndex]->Close() ;
            }
        } // if ( m_bmIsRemote
    } // for ( DWORD dwIndex

    return TRUE;

#endif //NO_ENCRYPTION
} //::PropagateKeySeed


BOOL CSync::DeleteKeySeed( VOID )
/*++

Routine Description:

    Deletes the session key seed from the MB

Arguments:

    None

Returns:

    TRUE if successful, FALSE if not
--*/
{
#ifdef NO_ENCRYPTION

    return TRUE;

#else

    BOOL fOk = TRUE;

    if ( !m_Source.Open( L"/LM/W3SVC", METADATA_PERMISSION_WRITE ) )
    {
        return FALSE;
    }

    METADATA_RECORD mdr;

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_REPLICATION_INFO,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        0,
                        NULL );

    fOk =  m_Source.DeleteProp( MB_REPLICATION_PATH,
                                &mdr );

    m_Source.Close();

    return fOk;

#endif //NO_ENCRYPTION
}


HRESULT
CSync::Sync(
    LPSTR       pszTargets,
    LPDWORD     pdwResults,
    DWORD       dwFlags,
    SYNC_STAT*  pStat
    )
/*++

Routine Description:

    Synchronize targets with source

Arguments:

    pszTargets - multisz of target computer names
            can include local computer, will be ignored during synchro
    pdwResults - updated with error code for each target
    dwFlags - flags, no flag defined for now. Should be 0.
    pStat - ptr to stat struct

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LPSTR       p;
    HRESULT     hRes = S_OK;
    CHAR        achLocalComputer[MAX_COMPUTERNAME_LENGTH+1];
    BOOL        fIsError;
    DWORD       dwSize;
    UINT        i;
    LPWSTR      pClsidList;
    BOOL        fGotSeed = FALSE;

    m_fInScan = FALSE;

    if ( m_pRoot )
    {
        return RETURNCODETOHRESULT(ERROR_IO_PENDING);
    }

    if ( !(m_pRoot = new CNodeDesc( this )) )
    {
        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Init MetaData COM I/F on local system
    //

    m_dwThreads = 0;
    dwSize = sizeof(achLocalComputer);

    if ( !m_Source.Init( NULL ) ||
         !GetComputerName( achLocalComputer, &dwSize ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto Exit;
    }


    //
    // Generate seed for session key used during replication
    //
    if ( !GenerateKeySeed() )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "GenerateKeySeed() failed : 0x%x\n",
                   GetLastError() ));
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto Exit;
    }
    else
    {
        fGotSeed = TRUE;
    }

    //
    // For the rest of the replication, we need an open read handle to the metabase; we open
    // the read handle -after- we've generated and written the seed for the session key to the
    // metabase so as not to cause lock
    //
    if ( !m_Source.Open( L"/LM/", METADATA_PERMISSION_READ ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto Exit;
    }

    //
    // Get CLSIDs of extensions
    //

    if ( !GetProp( IISADMIN_EXTENSIONS_CLSID_MD_KEYW,
                   IISADMIN_EXTENSIONS_CLSID_MD_ID,
                   IIS_MD_UT_SERVER,
                   MULTISZ_METADATA,
                   (LPBYTE*)&pClsidList,
                   &dwSize ) )
    {
        pClsidList = NULL;
    }

    //
    // Allocate ptr to target systems
    //

    for ( m_dwTargets = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++m_dwTargets )
    {
    }

    if ( !(m_pTargets = (CMdIf**)LocalAlloc( LMEM_ZEROINIT|LMEM_FIXED,
                                             sizeof(CMdIf*)*m_dwTargets)) )
    {
        hRes = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
        goto Exit;
    }

    if ( !m_TargetStatus.Init( m_dwTargets ) ||
         !m_bmIsRemote.Init( m_dwTargets )   ||
         !m_ThreadHandle.Init( m_dwTargets ) ||
         !m_ThreadContext.Init( m_dwTargets ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto Exit;
    }

    //
    // Init MetaData COM I/F to targets system
    //

    for ( i = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++i )
    {
        if ( !(m_pTargets[i] = new CMdIf()) )
        {
            hRes = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
            goto Exit;
        }

        //
        // set flag indicating whether it's a remote machine
        //
        if ( !_stricmp( p, achLocalComputer ) )
        {
            m_bmIsRemote.SetFlag( i, FALSE );
        }

        //
        // if it's a remote machine, actually get an interface pointer
        //
        if ( m_bmIsRemote.GetFlag( i ) )
        {
            if ( !m_pTargets[i]->Init( p ) )
            {
                if ( GetLastError() == ERROR_SUCCESS )
                {
                    SetLastError( RPC_S_SERVER_UNAVAILABLE );
                }
                m_TargetStatus.SetStatus( i, GetLastError() );
            }
        }
    }

    m_dwFlags = dwFlags;


    //
    // Copy session key seed to remote machines
    //
    PropagateKeySeed();

    //
    // Process replication extensions ( phase 1 )
    //

    if ( pClsidList )
    {
        if ( !ProcessAdminExReplication( pClsidList, pszTargets, AER_PHASE1 ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }
    }

    //
    // Open MetaData on targets system
    //

    for ( i = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++i )
    {
        if ( m_bmIsRemote.GetFlag( i ) )
        {
            if ( !m_pTargets[i]->Open( L"/LM/",
                                       METADATA_PERMISSION_READ |
                                       METADATA_PERMISSION_WRITE ) )
            {
                if ( GetLastError() == ERROR_SUCCESS )
                {
                    SetLastError( RPC_S_SERVER_UNAVAILABLE );
                }
                m_TargetStatus.SetStatus( i, GetLastError() );
            }
        }
    }

    //
    // Create thread pool
    //
    m_lThreads = 0;

    for ( i = 0 ; i < m_dwTargets ; ++i )
    {
        THREAD_CONTEXT threadContext;
        DWORD dwId;
        HANDLE hSem;
#if IIS_NAMED_WIN32_OBJECTS
        CHAR objName[sizeof("CSync::m_ThreadContext( 1234567890*3+2 )")];
#else
        LPSTR objName = NULL;
#endif
        threadContext.pvContext = this;
        threadContext.dwIndex = i;

#if IIS_NAMED_WIN32_OBJECTS
        wsprintfA(
            objName,
            "CSync::m_ThreadContext( %u*3+2 )",
            i
            );
#endif

        hSem = IIS_CREATE_SEMAPHORE(
                   objName,
                   this,
                   0,
                   INT_MAX
                   );

        threadContext.hSemaphore = hSem;

        m_ThreadContext.SetStatus( i, threadContext );

        if ( NULL == hSem )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            break;
        }

        m_ThreadHandle.SetStatus( i,
                                  CreateThread( NULL,
                                                0,
                                                (LPTHREAD_START_ROUTINE)::ScanThread,
                                                m_ThreadContext.GetPtr( i ),
                                                0,
                                                &dwId )
                                 );

        if ( m_ThreadHandle.GetStatus( i ) )
        {
            InterlockedIncrement( &m_lThreads );
            ++m_dwThreads;
        }
        else
        {
            CloseHandle( m_ThreadContext.GetPtr( i )->hSemaphore );
            hRes = RETURNCODETOHRESULT( GetLastError() );
            break;
        }
    }

    m_fInScan = TRUE;

    //
    // Launch scan
    //

    m_pStat = pStat;
    m_pStat->m_dwSourceScan = 0;
    m_pStat->m_fSourceComplete = FALSE;
    memset( m_pStat->m_adwTargets, '\0', sizeof(DWORD)*2*m_dwTargets );

    if ( hRes == S_OK )
    {
        if ( !m_pRoot->SetPath( L"" ) ||
             !m_pRoot->Scan( this ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            Cancel();
        }
        else
        {
            SetSourceComplete();
        }
    }
    else
    {
        Cancel();
    }

    //
    // wait for all threads to exit
    //

    for ( ;; )
    {
        if ( m_lThreads == 0 )
        {
            break;
        }
        Sleep( 1000 );
    }

    //
    // Wait for all threads to be terminated
    //

    WaitForMultipleObjects( m_dwThreads, m_ThreadHandle.GetPtr(0), TRUE, 5000 );

    m_fInScan = FALSE;

    for ( i = 0 ; i < m_dwThreads ; ++i )
    {
        DWORD   dwS;
        if ( !GetExitCodeThread( m_ThreadHandle.GetStatus(i), &dwS ) )
        {
            dwS = GetLastError();
        }
        if ( hRes == S_OK && dwS )
        {
            hRes = RETURNCODETOHRESULT( dwS );
        }
        CloseHandle( m_ThreadHandle.GetStatus(i) );
        CloseHandle( m_ThreadContext.GetPtr(i)->hSemaphore );
    }

    //
    // Process replication extensions ( phase 2 )
    //

    if ( pClsidList )
    {
        if ( !ProcessAdminExReplication( pClsidList, pszTargets, AER_PHASE2 ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }

        LocalFree( pClsidList );
    }

    //
    // Close metadata
    //

    m_Source.Close();
    for ( i = 0 ; i < m_dwTargets ; ++i )
    {
        if ( m_bmIsRemote.GetFlag( i ) )
        {
            m_pTargets[i]->Close();
        }
    }

    //
    // Process queued update requests
    //

    if ( !ProcessQueuedRequest() )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // Terminate target machine metadata objects
    //

    for ( i = 0 ; i < m_dwTargets ; ++i )
    {
        m_pTargets[i]->Terminate();
    }

    //
    // Scan for errors on targets
    //

    for ( fIsError = FALSE, i = 0 ; i < m_dwTargets ; ++i )
    {
        pdwResults[i] = m_TargetStatus.GetStatus( i );
        if ( pdwResults[i] )
        {
            fIsError = TRUE;
        }
    }

    if ( hRes == S_OK && m_fCancel )
    {
        hRes = RETURNCODETOHRESULT( ERROR_CANCELLED );
    }

    if ( hRes == S_OK &&
         fIsError )
    {
        hRes = E_FAIL;
    }

Exit:

    //
    // Clean up session key seed
    //
    if ( fGotSeed )
    {
        DeleteKeySeed();
    }

    //
    // Terminate source machine metadata object
    //
    m_Source.Terminate();


    delete m_pRoot;
    m_pRoot = NULL;
    m_fInScan = FALSE;

    return hRes;
}


BOOL
CMdIf::Init(
    LPSTR   pszComputer
    )
/*++

Routine Description:

    Initialize metabase admin interface :
        get interface pointer, call Initialize()

Arguments:

    pszComputer - computer name, NULL for local computer

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    IClassFactory *     pcsfFactory;
    COSERVERINFO        csiMachineName;
    HRESULT             hresError;
    BOOL                fSt = FALSE;
    WCHAR               awchComputer[COMPUTER_CHARACTER_SIZE];
    WCHAR*              pwchComputer = NULL;

    m_fModified = FALSE;

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;

    if ( pszComputer )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszComputer,
                                   -1,
                                   awchComputer,
                                   COMPUTER_CHARACTER_SIZE ) )
        {
            return FALSE;
        }

        pwchComputer = awchComputer;
    }

    csiMachineName.pwszName =  pwchComputer;

    hresError = CoGetClassObject(
                        CLSID_MSAdminBase_W,
                        CLSCTX_SERVER,
                        &csiMachineName,
                        IID_IClassFactory,
                        (void**) &pcsfFactory );

    if ( SUCCEEDED(hresError) )
    {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase_W, (void **) &m_pcAdmCom);
        if (SUCCEEDED(hresError) )
        {
                fSt = TRUE;
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
            m_pcAdmCom = NULL;
        }

        pcsfFactory->Release();
    }
    else
    {
        if ( hresError == REGDB_E_CLASSNOTREG )
        {
            SetLastError( ERROR_SERVICE_DOES_NOT_EXIST );
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
        }
        m_pcAdmCom = NULL;
    }

    return fSt;
}


BOOL
CMdIf::Open(
    LPWSTR  pszOpenPath,
    DWORD   dwPermission
    )
/*++

Routine Description:

    Open path in metabase

Arguments:

    pszOpenPath - path in metadata
    dwPermission - metadata permission

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    HRESULT hresError;

    if (NULL == m_pcAdmCom)
    {
        SetLastError(E_NOINTERFACE);
        return FALSE;
    }

    hresError = m_pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
        pszOpenPath, dwPermission, TIMEOUT_VALUE, &m_hmd );

    if ( FAILED(hresError) )
    {
        m_hmd = NULL;
        SetLastError( HRESULTTOWIN32(hresError) );
        return FALSE;
    }

    return TRUE;
}


BOOL
CMdIf::Close(
    )
/*++

Routine Description:

    Close path in metabase

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pcAdmCom && m_hmd )
    {
        m_pcAdmCom->CloseKey(m_hmd);
    }

    m_hmd = NULL;

    return TRUE;
}


BOOL
CMdIf::Terminate(
    )
/*++

Routine Description:

    Terminate metabase admin interface :
        call Terminate, release interface pointer

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pcAdmCom )
    {
        if ( m_fModified )
        {
            m_pcAdmCom->SaveData();
        }
        m_pcAdmCom->Release();
        m_hmd = NULL;
        m_pcAdmCom = NULL;
    }

    return TRUE;
}


#if defined(ADMEX)

BOOL
CRpIf::Init(
    LPSTR   pszComputer,
    CLSID*  pClsid
    )
/*++

Routine Description:

    Initialize metabase admin interface :
        get interface pointer, call Initialize()

Arguments:

    pszComputer - computer name, NULL for local computer

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    IClassFactory *     pcsfFactory;
    COSERVERINFO        csiMachineName;
    HRESULT             hresError;
    BOOL                fSt = FALSE;
    WCHAR               awchComputer[COMPUTER_CHARACTER_SIZE];
    WCHAR*              pwchComputer = NULL;

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;

    if ( pszComputer )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszComputer,
                                   -1,
                                   awchComputer,
                                   COMPUTER_CHARACTER_SIZE ) )
        {
            return FALSE;
        }

        pwchComputer = awchComputer;
    }

    csiMachineName.pwszName =  pwchComputer;

    hresError = CoGetClassObject(
                        *pClsid,
                        CLSCTX_SERVER,
                        &csiMachineName,
                        IID_IClassFactory,
                        (void**) &pcsfFactory );

    if ( SUCCEEDED(hresError) )
    {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminReplication, (void **) &m_pcAdmCom);
        if (SUCCEEDED(hresError) )
        {
                fSt = TRUE;
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
            m_pcAdmCom = NULL;
        }

        pcsfFactory->Release();
    }
    else
    {
        if ( hresError == REGDB_E_CLASSNOTREG )
        {
            SetLastError( ERROR_SERVICE_DOES_NOT_EXIST );
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
        }
        m_pcAdmCom = NULL;
    }

    return fSt;
}


BOOL
CRpIf::Terminate(
    )
/*++

Routine Description:

    Terminate metabase admin interface :
        call Terminate, release interface pointer

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pcAdmCom )
    {
        m_pcAdmCom->Release();
        m_pcAdmCom = NULL;
    }

    return TRUE;
}

#endif


BOOL
CNodeDesc::Scan(
    CSync* pSync
    )
/*++

Routine Description:

    Scan subtree for nodes & properties
    Signal each node availability for target synchronization
    after scanning it.

Arguments:

    pSync - synchronizer

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD       dwTarget;

    if ( m_pSync->IsCancelled() )
    {
        return FALSE;
    }

    // get local props

    if ( !m_Props.GetAll( m_pSync->GetSourceIf(), m_pszPath ) )
    {
        return FALSE;
    }

    m_pSync->IncrementSourceScan();

    if ( !BuildChildObjectsList( m_pSync->GetSourceIf(), m_pszPath ) )
    {
        return FALSE;
    }

    m_Props.SetRefCount( m_pSync->GetTargetCount() );  // when 0, free props

    for ( dwTarget = 0 ; dwTarget < m_pSync->GetTargetCount() ; ++dwTarget )
    {
        m_pSync->SignalWorkItem( dwTarget );
    }

    LIST_ENTRY*         pSourceEntry;
    CNodeDesc*          pSourceDir;

    //
    // recursively scan children
    //

    for ( pSourceEntry = m_ChildHead.Flink;
          pSourceEntry != &m_ChildHead ;
          pSourceEntry = pSourceEntry->Flink )
    {
        pSourceDir = CONTAINING_RECORD( pSourceEntry,
                                        CNodeDesc,
                                        m_ChildList );

        if ( !pSourceDir->Scan( pSync ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
CNodeDesc::ScanTarget(
    DWORD   dwTarget
    )
/*++

Routine Description:

    Scan target subtree for nodes and properties,
    synchronizing with source. Wait for source scan
    to be complete before synchronizing.

Arguments:

    dwTarget - target ID

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    m_pSync->WaitForWorkItem( dwTarget );

    if ( m_pSync->IsCancelled() )
    {
        return FALSE;
    }

    if ( !DoWork( SCANMODE_SYNC_PROPS, dwTarget ) )
    {
        return FALSE;
    }

    LIST_ENTRY*         pSourceEntry;
    CNodeDesc*          pSourceDir;

    //
    // recursively scan children
    //

    for ( pSourceEntry = m_ChildHead.Flink;
          pSourceEntry != &m_ChildHead ;
          pSourceEntry = pSourceEntry->Flink )
    {
        pSourceDir = CONTAINING_RECORD( pSourceEntry,
                                        CNodeDesc,
                                        m_ChildList );

        if ( !pSourceDir->ScanTarget( dwTarget ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
CNodeDesc::DoWork(
    SCANMODE    sm,
    DWORD       dwTarget
    )
/*++

Routine Description:

    synchronize target node with source node :
    add/delete/update properties as needed,
    add/delete nodes as needed.

Arguments:

    sm - scan operation to perform
         only SCANMODE_SYNC_PROPS is defined for now.
    dwTarget - target ID

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CProps              Props;
    CNodeDesc           TargetDir( m_pSync );
    LIST_ENTRY*         pSourceEntry;
    CNodeDesc*          pSourceDir;
    LIST_ENTRY*         pTargetEntry;
    CNodeDesc*          pTargetDir;
    BOOL                fMatch;
    PMETADATA_RECORD    pSourceProps;
    PMETADATA_RECORD    pTargetProps;
    PBYTE               pSourceData;
    PBYTE               pTargetData;
    DWORD               dwSourceProps;
    DWORD               dwTargetProps;
    LPBYTE              pbExists;
    DWORD               dwSourceObjs;
    FILETIME            ftSource;
    FILETIME            ftTarget;
    BOOL                fModified = FALSE;
    UINT                iS;
    UINT                iT;
    BOOL                fNeedUpdate;
    BOOL                fExists;
    BOOL                fDoNotSetTimeModif = FALSE;


    //
    // if target already in error, do not process request
    //

    if ( m_pSync->GetTargetError( dwTarget ) ||
         m_pSync->IsLocal( dwTarget ) )
    {
        return TRUE;
    }

    switch ( sm )
    {
        case SCANMODE_SYNC_PROPS:

            //
            // Check date/time last modification.
            // If identical on source & target, do not update
            //

            m_pSync->IncrementTargetScan( dwTarget );

            if ( !(m_pSync->GetSourceIf())->GetLastChangeTime( m_pszPath, &ftSource ) )
            {
                return FALSE;
            }
            if ( m_pSync->GetTargetIf( dwTarget )->GetLastChangeTime( m_pszPath, &ftTarget ) )
            {
                if ( !memcmp( &ftSource, &ftTarget, sizeof(FILETIME) ) )
                {
                    return TRUE;
                }
            }
            else
            {
                m_pSync->SetTargetError( dwTarget, GetLastError() );
                return TRUE;
            }

            // get props on target, set / delete as appropriate
            if ( Props.GetAll( m_pSync->GetTargetIf(dwTarget), m_pszPath ) )
            {
                pSourceProps = (PMETADATA_RECORD)m_Props.GetProps();
                dwSourceProps = m_Props.GetPropsCount();
                dwTargetProps = Props.GetPropsCount();

                if ( !(pbExists = (LPBYTE)LocalAlloc( LMEM_FIXED, dwTargetProps )) )
                {
                    return FALSE;
                }
                memset( pbExists, '\x0', dwTargetProps );

                for ( iS = 0 ; iS < dwSourceProps ; ++iS,++pSourceProps )
                {
                    pSourceData = (LPBYTE)m_Props.GetProps() + (UINT_PTR)pSourceProps->pbMDData;    
                    pTargetProps = (PMETADATA_RECORD)Props.GetProps();

                    fNeedUpdate = TRUE;
                    fExists = FALSE;

                    for ( iT = 0 ; iT < dwTargetProps ; ++iT,++pTargetProps )
                    {
                        if ( pSourceProps->dwMDIdentifier ==
                             pTargetProps->dwMDIdentifier )
                        {
                            pbExists[ iT ] = '\x1';

                            pTargetData = (LPBYTE)Props.GetProps() + (UINT_PTR)pTargetProps->pbMDData;  

                            if ( m_Props.IsNse( pSourceProps->dwMDIdentifier ) )
                            {
                                fNeedUpdate = m_Props.NseIsDifferent( pSourceProps->dwMDIdentifier, pSourceData, pSourceProps->dwMDDataLen, pTargetData, pTargetProps->dwMDDataLen, m_pszPath, dwTarget );
                            }
                            else if ( pSourceProps->dwMDDataType == pTargetProps->dwMDDataType &&
                                 pSourceProps->dwMDUserType == pTargetProps->dwMDUserType )
                            {
                                fExists = TRUE;

                                if( pSourceProps->dwMDDataLen == pTargetProps->dwMDDataLen &&
                                    !memcmp(pSourceData, pTargetData, pSourceProps->dwMDDataLen ) )
                                {
                                    fNeedUpdate = FALSE;
                                }
                                else if ( pSourceProps->dwMDIdentifier == MD_SERVER_STATE ||
                                          pSourceProps->dwMDIdentifier == MD_WIN32_ERROR ||
                                          pSourceProps->dwMDIdentifier == MD_SERVER_COMMAND ||
                                          pSourceProps->dwMDIdentifier == MD_CLUSTER_SERVER_COMMAND ||
                                          pSourceProps->dwMDIdentifier == MD_ANONYMOUS_USER_NAME ||
                                          pSourceProps->dwMDIdentifier == MD_ANONYMOUS_PWD ||
                                          pSourceProps->dwMDIdentifier == MD_WAM_USER_NAME ||
                                          pSourceProps->dwMDIdentifier == MD_WAM_PWD 
                                          )
                                {
                                    fNeedUpdate = FALSE;
                                }
#if defined(METADATA_LOCAL_MACHINE_ONLY)
                                else if ( pSourceProps->dwMDAttributes
                                          & METADATA_LOCAL_MACHINE_ONLY )
                                {
                                    fNeedUpdate = FALSE;
                                }
#endif
                            }
                        }
                    }

                    if ( fNeedUpdate )
                    {
                        if ( m_Props.IsNse( pSourceProps->dwMDIdentifier ) )
                        {
                            if ( !m_pSync->QueueRequest(
                                    pSourceProps->dwMDIdentifier,
                                    m_pszPath,
                                    dwTarget,
                                    &ftSource ) )
                            {
                                m_pSync->SetTargetError( dwTarget, GetLastError() );
                            }
                            else
                            {
                                //
                                // differ updating time last modif
                                // until NSE update processed
                                //

                                fDoNotSetTimeModif = TRUE;
                            }
                        }
                        else
                        {
                            METADATA_RECORD     md;

                            md = *pSourceProps;

                            if ( !(m_pSync->QueryFlags() & MD_SYNC_FLAG_REPLICATE_AUTOSTART) &&
                                 md.dwMDIdentifier == MD_SERVER_AUTOSTART )
                            {
                                if ( fExists )
                                {
                                    fNeedUpdate = FALSE;
                                }
                                else
                                {
                                    //
                                    // create as FALSE ( server won't autostart )
                                    //

                                    pSourceData = (LPBYTE)&g_dwFalse;
                                    md.dwMDDataLen = sizeof(DWORD);
                                    md.dwMDDataType = DWORD_METADATA;
                                }
                            }

                            if ( !(m_pSync->QueryFlags() & MD_SYNC_FLAG_DONT_PRESERVE_IP_BINDINGS) &&
                                 (md.dwMDIdentifier == MD_SERVER_BINDINGS ||
                                  md.dwMDIdentifier == MD_SECURE_BINDINGS) )
                            {
                                if ( fExists )
                                {
                                    fNeedUpdate = FALSE;
                                }
                            }

                            if ( fNeedUpdate )
                            {
                                if ( !m_pSync->GetTargetIf(dwTarget)->SetData( m_pszPath, &md, pSourceData ) )
                                {
                                    m_pSync->SetTargetError( dwTarget, GetLastError() );
                                }
                            }
                        }
                        m_pSync->SetModified( dwTarget );
                        fModified = TRUE;
                    }
                }

                // delete prop not in src
                pTargetProps = (PMETADATA_RECORD)Props.GetProps();
                for ( iT = 0 ; iT < dwTargetProps ; ++iT,++pTargetProps )
                {
                    if ( !pbExists[ iT ] )
                    {
                        if ( !m_pSync->GetTargetIf(dwTarget)->DeleteProp( m_pszPath, pTargetProps ) )
                        {
                            m_pSync->SetTargetError( dwTarget, GetLastError() );
                        }
                        m_pSync->SetModified( dwTarget );
                        fModified = TRUE;
                    }
                }
                LocalFree( pbExists );
            }

            // enum objects on target, delete sub-tree as appropriate
            if ( TargetDir.BuildChildObjectsList( m_pSync->GetTargetIf(dwTarget), m_pszPath ) )
            {
                for ( dwSourceObjs = 0, pSourceEntry = m_ChildHead.Flink;
                      pSourceEntry != &m_ChildHead ;
                      ++dwSourceObjs, pSourceEntry = pSourceEntry->Flink )
                {
                }

                if ( !(pbExists = (LPBYTE)LocalAlloc( LMEM_FIXED, dwSourceObjs )) )
                {
                    return FALSE;
                }
                memset( pbExists, '\x0', dwSourceObjs );

                for ( pTargetEntry = TargetDir.m_ChildHead.Flink;
                      pTargetEntry != &TargetDir.m_ChildHead ;
                      pTargetEntry = pTargetEntry->Flink )
                {
                    pTargetDir = CONTAINING_RECORD( pTargetEntry,
                                                    CNodeDesc,
                                                    m_ChildList );

                    fMatch = FALSE;

                    for ( iS = 0, pSourceEntry = m_ChildHead.Flink;
                          pSourceEntry != &m_ChildHead ;
                          ++iS, pSourceEntry = pSourceEntry->Flink )
                    {
                        pSourceDir = CONTAINING_RECORD( pSourceEntry,
                                                        CNodeDesc,
                                                        m_ChildList );

                        if ( !_wcsicmp( pTargetDir->GetPath(), pSourceDir->GetPath() ) )
                        {
                            pbExists[ iS ] = '\x1';
                            fMatch = TRUE;
                            break;
                        }
                    }

                    if ( !fMatch )
                    {
                        if ( !m_pSync->GetTargetIf(dwTarget)->DeleteSubTree( pTargetDir->GetPath() ) )
                        {
                            m_pSync->SetTargetError( dwTarget, GetLastError() );
                        }
                        m_pSync->SetModified( dwTarget );
                        fModified = TRUE;
                    }
                }

                //
                // Add node if does not exist on target
                //

                for ( iS = 0, pSourceEntry = m_ChildHead.Flink;
                      pSourceEntry != &m_ChildHead ;
                      ++iS, pSourceEntry = pSourceEntry->Flink )
                {
                    if ( !pbExists[iS] )
                    {
                        pSourceDir = CONTAINING_RECORD( pSourceEntry,
                                                        CNodeDesc,
                                                        m_ChildList );

                        if ( !m_pSync->GetTargetIf(dwTarget)->AddNode( pSourceDir->GetPath() ) )
                        {
                            m_pSync->SetTargetError( dwTarget, GetLastError() );
                        }
                        m_pSync->SetModified( dwTarget );
                        fModified = TRUE;
                    }
                }

                LocalFree( pbExists );
            }
            else
            {
                // not error if does not exist on target
            }

            if ( fModified &&
                 !fDoNotSetTimeModif &&
                 !m_pSync->GetTargetError( dwTarget ) &&
                 !m_pSync->GetTargetIf( dwTarget )->SetLastChangeTime( m_pszPath, &ftSource ) )
            {
                m_pSync->SetTargetError( dwTarget, GetLastError() );
            }

            if ( fModified )
            {
                m_pSync->IncrementTargetTouched( dwTarget );
            }

            m_Props.Dereference();
            break;
    }

    return TRUE;
}


BOOL
CProps::NseIsDifferent(
    DWORD   dwId,
    LPBYTE  pSourceData,
    DWORD   dwSourceLen,
    LPBYTE  pTargetData,
    DWORD   dwTargetLen,
    LPWSTR  pszPath,
    DWORD   dwTarget
    )
/*++

Routine Description:

    Check if two NSE properties are different

Arguments:

    dwId - property ID
    pSourceData - ptr to source data for this property
    dwSourceLen - # of bytes in pSourceData
    pTargetData - ptr to target data for this property
    dwTargetLen - # of bytes in pTargetData
    pszPath - path to property
    dwTarget - target ID

Returns:

    TRUE if properties different, FALSE if identical

--*/
{
    switch ( dwId )
    {
        case MD_SERIAL_CERT11:
        case MD_SERIAL_DIGEST:
            //
            // serialized format is (DWORD)len, string, then MD5 signature ( 16 bytes )
            //

            //
            // skip string
            //

            if ( *(LPDWORD)pSourceData < dwSourceLen )
            {
                pSourceData += sizeof(DWORD) + *(LPDWORD)pSourceData;
            }
            if ( *(LPDWORD)pTargetData < dwTargetLen )
            {
                pTargetData += sizeof(DWORD) + *(LPDWORD)pTargetData;
            }

            //
            // compare MD5 signature
            //

            return memcmp( pSourceData, pTargetData, 16 );
    }

    //
    // Don't know how to handle, do not replicate
    //

    return FALSE;
}


CNseRequest::CNseRequest(
    )
/*++

Routine Description:

    NSE request constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pszPath = NULL;
    m_pszModifPath = NULL;
    m_pbData = NULL;
}


CNseRequest::~CNseRequest(
    )
/*++

Routine Description:

    NSE request destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( m_pszPath )
    {
        LocalFree( m_pszPath );
    }

    if ( m_pszModifPath )
    {
        LocalFree( m_pszModifPath );
    }

    if ( m_pszCreatePath )
    {
        LocalFree( m_pszCreatePath );
    }

    if ( m_pszCreateObject )
    {
        LocalFree( m_pszCreateObject );
    }

    if ( m_pbData )
    {
        LocalFree( m_pbData );
    }
}


BOOL
CNseRequest::Init(
    LPWSTR              pszPath,
    LPWSTR              pszCreatePath,
    LPWSTR              pszCreateObject,
    DWORD               dwId,
    DWORD               dwTargetCount,
    LPWSTR              pszModifPath,
    FILETIME*           pftModif,
    METADATA_RECORD*    pMd
    )
/*++

Routine Description:

    Initialize NSE request

Arguments:

    pszPath - NSE path to property
    pszCreatePath - NSE path where to create object if open object fails
    pszCreateObject - name of object to create if open object fails
    dwId - property ID
    dwTargetCount - # of potential targets
    pszModifPath - path where to update last date/time modification
                   on success
    pftModif - last date/time modification to set on success
    pMD - metadata record to set on target

Returns:

    Nothing

--*/
{
    m_dwTargetCount = dwTargetCount;
    m_dwId = dwId;

    if ( !(m_pszPath = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszPath)+1)*sizeof(WCHAR) )) )
    {
        return FALSE;
    }
    wcscpy( m_pszPath, pszPath );

    if ( !(m_pszModifPath = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszModifPath)+1)*sizeof(WCHAR) )) )
    {
        LocalFree( m_pszPath );
        return FALSE;
    }
    wcscpy( m_pszModifPath, pszModifPath );

    if ( !(m_pszCreatePath = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszCreatePath)+1)*sizeof(WCHAR) )) )
    {
        LocalFree( m_pszModifPath );
        LocalFree( m_pszPath );
        return FALSE;
    }
    wcscpy( m_pszCreatePath, pszCreatePath );

    if ( !(m_pszCreateObject = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszCreateObject)+1)*sizeof(WCHAR) )) )
    {
        LocalFree( m_pszCreatePath );
        LocalFree( m_pszModifPath );
        LocalFree( m_pszPath );
        return FALSE;
    }
    wcscpy( m_pszCreateObject, pszCreateObject );

    m_ftModif = *pftModif;
    m_md = *pMd;

    return m_bmTarget.Init( dwTargetCount, FALSE );
}


BOOL
CNseRequest::Process(
    CSync*  pSync
    )
/*++

Routine Description:

    Process a NSE request :
    replicate source property to designated targets

Arguments:

    pSync - synchronizer

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CMdIf*  pSource = pSync->GetSourceIf();
    CMdIf*  pTarget;
    UINT    i;
    DWORD   dwRequired;
    int     retry;

    if ( !pSource )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( pSource->Open( m_pszPath, METADATA_PERMISSION_READ ) )
    {
        m_md.pbMDData = NULL;
        m_md.dwMDDataLen = 0;
        if ( !pSource->GetData( L"", &m_md, NULL, &dwRequired) )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                if ( !(m_pbData = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired )) )
                {
                    pSource->Close();
                    return FALSE;
                }
                m_md.pbMDData = m_pbData;
                m_md.dwMDDataLen = dwRequired;
                if ( !pSource->GetData( L"", &m_md, m_pbData, &dwRequired) )
                {
                    pSource->Close();
                    return FALSE;
                }
            }
            else
            {
                pSource->Close();
                return FALSE;
            }
        }

        for ( i = 0 ; i < m_dwTargetCount ; ++i )
        {
            if ( m_bmTarget.GetFlag(i) &&
                 !pSync->GetTargetError( i ) )
            {
                pTarget = pSync->GetTargetIf( i );

                //
                // Insure object exist by creating it
                // Open path w/o last component, Add last component
                //

                LPWSTR  pLast = m_pszPath + wcslen( m_pszPath ) - 1;
                while ( *pLast != L'/' )
                {
                    --pLast;
                }
                *pLast = L'\0';

                if ( pTarget->Open( m_pszPath, METADATA_PERMISSION_WRITE ) )
                {
                    pTarget->AddNode( pLast + 1 );
                    pTarget->Close();
                }

                *pLast = L'/';

                //
                // Set serialized data
                //

                if ( pTarget->Open( m_pszPath, METADATA_PERMISSION_WRITE ) )
                {
                    if ( !pTarget->SetData( L"", &m_md, m_pbData ) )
                    {
                        pSync->SetTargetError( i, GetLastError() );
                    }
                    pSync->SetModified( i );
                    pTarget->Close();


                    //
                    // set date/time last modif
                    //

                    if ( !pSync->GetTargetError( i ) &&
                         pTarget->Open( L"/LM", METADATA_PERMISSION_WRITE ) )
                    {
                        if ( !pTarget->SetLastChangeTime( m_pszModifPath, &m_ftModif ) )
                        {
                            pSync->SetTargetError( i, GetLastError() );
                        }
                        pTarget->Close();
                    }
                    break;
                }
                else
                {
                    pSync->SetTargetError( i, GetLastError() );
                    break;
                }
            }
        }
        pSource->Close();
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
CSync::ProcessQueuedRequest(
    )
/*++

Routine Description:

    Process all queued NSE requests

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LIST_ENTRY*     pChild;
    CNseRequest*    pReq;
    BOOL            fSt = TRUE;

    while ( !IsListEmpty( &m_QueuedRequestsHead ))
    {
        pReq = CONTAINING_RECORD( m_QueuedRequestsHead.Flink,
                                  CNseRequest,
                                  m_QueuedRequestsList );

        if ( IsCancelled() ||
             !pReq->Process( this ) )
        {
            fSt = FALSE;
        }

        RemoveEntryList( &pReq->m_QueuedRequestsList );

        delete pReq;
    }

    return fSt;
}


BOOL
CSync::QueueRequest(
    DWORD       dwId,
    LPWSTR      pszPath,
    DWORD       dwTarget,
    FILETIME*   pftModif
    )
/*++

Routine Description:

    Queue a NSE request
    We cannot process then inline as we need to open a different
    path to NSE, which will open a path in metabase space, which will
    conflict with the current open.
    So we queue requests to be processed after closing all opened
    metabase paths.

Arguments:

    dwId - property ID
    pszPath - NSE path
    dwTarget - target ID
    pftModif - date/time last modification to set on targets if success

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    WCHAR               achPath[MAX_PATH];
    WCHAR               achCreatePath[MAX_PATH];
    WCHAR               achCreateObject[MAX_PATH];
    DWORD               dwL = wcslen( pszPath );
    BOOL                fSt = TRUE;
    DWORD               dwSerialId;
    METADATA_RECORD     md;

    memcpy( achPath, L"/LM", sizeof(L"/LM") - 1*sizeof(WCHAR) );
    memcpy( (LPBYTE)achPath + sizeof(L"/LM") - 1*sizeof(WCHAR), pszPath, dwL*sizeof(WCHAR) );
    dwL += wcslen(L"/LM");

    memcpy( achCreatePath, achPath, dwL*sizeof(WCHAR) );

    memset( &md, '\0', sizeof(md) );

    md.dwMDAttributes = 0;
    md.dwMDUserType = IIS_MD_UT_SERVER;
    md.dwMDDataType = BINARY_METADATA;
    md.dwMDDataTag = 0;

    switch ( dwId )
    {
        case MD_SERIAL_CERT11:
            wcscpy( achPath+dwL, L"/<nsepm>/Cert11" );
            wcscpy( achCreatePath+dwL, L"/<nsepm>" );
            wcscpy( achCreateObject, L"Cert11" );
            dwSerialId = MD_SERIAL_ALL_CERT11;
            md.dwMDIdentifier = dwSerialId;
            break;

        case MD_SERIAL_DIGEST:
            wcscpy( achPath+dwL, L"/<nsepm>/Digest" );
            wcscpy( achCreatePath+dwL, L"/<nsepm>" );
            wcscpy( achCreateObject, L"Digest" );
            dwSerialId = MD_SERIAL_ALL_DIGEST;
            md.dwMDIdentifier = dwSerialId;
            break;

        default:
            return FALSE;
    }

    EnterCriticalSection( &m_csQueuedRequestsList );

    // locate path in list, add entry if not exists
    // set target bit

    LIST_ENTRY*         pEntry;
    CNseRequest*        pReq;
    BOOL                fFound = FALSE;

    for ( pEntry = m_QueuedRequestsHead.Flink;
          pEntry != &m_QueuedRequestsHead ;
          pEntry = pEntry->Flink )
    {
        pReq = CONTAINING_RECORD( pEntry,
                                  CNseRequest,
                                  m_QueuedRequestsList );

        if ( pReq->Match( achPath, dwSerialId ) )
        {
            fFound = TRUE;
            break;
        }
    }

    if ( !fFound )
    {
        if ( !(pReq = new CNseRequest()) )
        {
            fSt = FALSE;
        }
        else if ( !pReq->Init( achPath,
                               achCreatePath,
                               achCreateObject,
                               dwSerialId,
                               GetTargetCount(),
                               pszPath,
                               pftModif,
                               &md ) )
        {
            delete pReq;
            fSt = FALSE;
        }
        else
        {
            InsertHeadList( &m_QueuedRequestsHead, &pReq->m_QueuedRequestsList );
        }
    }

    if ( fSt )
    {
        pReq->AddTarget( dwTarget );
    }

    LeaveCriticalSection( &m_csQueuedRequestsList );

    return fSt;
}


BOOL
CSync::ProcessAdminExReplication(
    LPWSTR  pszClsids,
    LPSTR   pszTargets,
    DWORD   dwPhase
    )
/*++

Routine Description:

    Process replication using admin extensions

Arguments:

    pszClsids - multi-sz of ClsIds for admin extensions
    pszTargets - multi-sz of target computers ( computer names )
    dwPhase - phase 1 or 2

Returns:

    TRUE if success, otherwise FALSE

--*/
{
#if defined(ADMEX)
    CRpIf   **pTargets;
    CRpIf   Source;
    UINT    i;
    LPWSTR  pw;
    LPSTR   p;
    BOOL    fSt = TRUE;
    BUFFER  buSourceSignature;
    BUFFER  buTargetSignature;
    BUFFER  buSerialize;
    DWORD   dwSourceSignature;
    DWORD   dwTargetSignature;
    DWORD   dwSerialize;
    BOOL    fHasSource;
    CLSID   clsid;
    DWORD   iC;
    BOOL    fFirstPhase2Clsid = TRUE;
    HRESULT hr;

    if ( !(pTargets = (CRpIf**)LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT, sizeof(CRpIf*)*m_dwTargets)) )
    {
        return FALSE;
    }

    for ( i = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++i )
    {
        if ( m_bmIsRemote.GetFlag( i ) )
        {
            if ( !(pTargets[i] = new CRpIf()) )
            {
                goto Exit;
            }
        }
    }

    // build TargetSignatureMismatch array if phase 1

    if ( dwPhase == AER_PHASE1 )
    {
        for (  pw = pszClsids, iC = 0 ; *pw ; pw += wcslen(pw)+1, ++iC )
        {
        }
        m_bmTargetSignatureMismatch.Init( m_dwTargets * iC, FALSE );
    }

    // enumerate all CLSID for extensions

    for (  pw = pszClsids, iC = 0 ; *pw ; pw += wcslen(pw)+1, ++iC )
    {
        // if Source.Init fails skip to next one : replication I/F not available for
        // this CLSID

        if ( SUCCEEDED( CLSIDFromString( pw, &clsid ) ) &&
             Source.Init( NULL, &clsid ) )
        {
            fHasSource = FALSE;

            // for each one, get source signature

            if ( !Source.GetSignature( &buSourceSignature, &dwSourceSignature ) )
            {
                fSt = FALSE;
                goto Exit;
            }

            // enumerate targets, get signature, if <> source Serialize if not already available
            // and propagate to target

            for ( i = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++i )
            {
                if ( IsCancelled() )
                {
                    fSt = FALSE;
                    goto Exit;
                }

                if ( pTargets[i] &&
                     !GetTargetError( i ) &&
                     pTargets[i]->Init( p, &clsid ) )
                {
                    switch ( dwPhase )
                    {
                        case AER_PHASE1:
                            if ( !pTargets[i]->GetSignature( &buTargetSignature,
                                                             &dwTargetSignature ) )
                            {
                                SetTargetError( i, GetLastError() );
                            }
                            else if ( dwSourceSignature != dwTargetSignature ||
                                      memcmp( buSourceSignature.QueryPtr(),
                                              buTargetSignature.QueryPtr(),
                                              dwTargetSignature ) )
                            {
                                if ( !fHasSource &&
                                     !Source.Serialize( &buSerialize, &dwSerialize ) )
                                {
                                    fSt = FALSE;
                                    goto Exit;
                                }
                                fHasSource = TRUE;
                                SetTargetSignatureMismatch( i, iC, TRUE );

                                if ( !Source.Propagate( p, strlen(p)+1 ) )
                                {
                                    SetTargetError( i, GetLastError() );
                                }
                                else if( !pTargets[i]->DeSerialize( &buSerialize, dwSerialize ) )
                                {
                                    SetTargetError( i, GetLastError() );
                                }
                            }
                            break;

                        case AER_PHASE2:
                            if ( fFirstPhase2Clsid )
                            {
                                if ( FAILED( hr = MTS_Propagate2( strlen(p)+1, (PBYTE)p, TRUE ) ) )
                                {
                                    SetTargetError( i, HRESULTTOWIN32(hr) );
                                }
                            }

                            if ( !Source.Propagate2( p,
                                                     strlen(p)+1,
                                                     GetTargetSignatureMismatch( i, iC ) ) )
                            {
                                SetTargetError( i, GetLastError() );
                            }
                            if ( QueryFlags() & MD_SYNC_FLAG_CHECK_ADMINEX_SIGNATURE )
                            {
                                if ( !pTargets[i]->GetSignature( &buTargetSignature, &dwTargetSignature ) )
                                {
                                    SetTargetError( i, GetLastError() );
                                }
                                else if ( dwSourceSignature != dwTargetSignature ||
                                     memcmp( buSourceSignature.QueryPtr(), buTargetSignature.QueryPtr(), dwTargetSignature ) )
                                {
                                    SetTargetError( i, ERROR_REVISION_MISMATCH );
                                }
                            }
                            break;
                    }

                    pTargets[i]->Terminate();
                }
            }

            Source.Terminate();
        }

        fFirstPhase2Clsid = FALSE;
    }

Exit:
    Source.Terminate();

    if ( pTargets )
    {
        for ( i = 0 ; i < m_dwTargets ; ++i )
        {
            if ( pTargets[i] )
            {
                if ( m_bmIsRemote.GetFlag( i ) )
                {
                    pTargets[i]->Terminate();
                }

                delete pTargets[i];
            }
        }

        LocalFree( pTargets );
    }

    return fSt;

#else

    return TRUE;

#endif
}


HRESULT
MdSync::Synchronize(
    LPSTR       pszTargets,
    LPDWORD     pdwResults,
    DWORD       dwFlags,
    LPDWORD     pStat
    )
/*++

Routine Description:

    Entry point for synchronize COM method

Arguments:

    pszTargets - multisz of target computer names
            can include local computer, will be ignored during synchro
    pdwResults - updated with error code for each target
    dwFlags - flags, no flag defined for now. Should be 0.
    pStat - ptr to stat struct

Returns:

    status of request

--*/
{
    return m_Sync.Sync( pszTargets, pdwResults, dwFlags, (SYNC_STAT*)pStat );
}


HRESULT
MdSync::Cancel(
    )
/*++

Routine Description:

    Entry point for cancel COM method

Arguments:

    None

Returns:

    status of request

--*/
{
    return m_Sync.Cancel();
}


HRESULT
MTS_Propagate2
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer,
/* [in] */ DWORD dwSignatureMismatch
)
{
    HRESULT hr = NOERROR;
    BSTR    bstrSourceMachineName = NULL;
    BSTR    bstrTargetMachineName = NULL;
    CHAR    pszComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD   cch = MAX_COMPUTERNAME_LENGTH+1;

    //pszBuffer Contains TargetMachineName(ANSI)
    DBG_ASSERT(pszBuffer);

    if ((BOOL)dwSignatureMismatch == FALSE)
        {
        DBGPRINTF((DBG_CONTEXT, "Signature is identical, MTS replication is not triggered.\n"));
        return hr;
        }

    if (GetComputerName(pszComputerName, &cch))
        {
        WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSuccess = 0;

        dwSuccess = MultiByteToWideChar(0, 0, pszComputerName, -1, wszMachineName, MAX_COMPUTERNAME_LENGTH+1);
        DBG_ASSERT(dwSuccess);

        bstrSourceMachineName = SysAllocString(wszMachineName);

        dwSuccess = MultiByteToWideChar(0, 0, (LPCSTR)pszBuffer, dwBufferSize, wszMachineName, MAX_COMPUTERNAME_LENGTH+1);
        DBG_ASSERT(dwSuccess);

        bstrTargetMachineName = SysAllocString(wszMachineName);
        }
    else
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "GetComputerName failed, hr = %08x\n",
            hr));
        }

    if (SUCCEEDED(hr))
        {
        ICOMReplicate* piReplCat = NULL;

        DBG_ASSERT(bstrSourceMachineName != NULL && bstrTargetMachineName != NULL);

        hr = CoCreateInstance(CLSID_ReplicateCatalog,
                              NULL,
                              CLSCTX_INPROC_SERVER, 
                              IID_ICOMReplicate,
                              (void**)&piReplCat);

        if (SUCCEEDED(hr))
            {
            DBG_ASSERT(piReplCat);

            //
            // For now, just call the replication methods in a row.
            //

            //
            // EBK 5/8/2000 Whistler #83172
			// Removed bug comment from this.  According to NT Bug 37371
			// the best solution we came up with is the solution that is implemented
			// here, so no more work or investigation is required.
            //
            // Replication of the iis com apps is not working. The problem
            // is that com will not replicate iis applciations unless we
            // tell it to (using the COMREPL_OPTION_REPLICATE_IIS_APPS flag).
            // But if we tell it to replicate our apps, then com requires
            // that the activation identity (IWAM_*) be the same on both 
            // machines. In order to do that we would need to replicate the
            // IWAM_ account. There are a number of problems with this, not
            // the least of which is encrypting the password during transfer.
            // So to get this working at least reasonably well, I'm going to
            // continue passing 0 here. And delete/recreate the isolated
            // apps on the target in wamreg during the first phase of
            // replication.
            //
            // See NT Bug 378371 for more details
            //
             
            hr = piReplCat->Initialize( bstrSourceMachineName, 0 );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Initialize() failed with hr = %08x\n",
                            hr ));
                piReplCat->Release();
                goto Finished;
            }

            hr = piReplCat->ExportSourceCatalogFiles();
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "ExportSourceCatalogFiles() failed with hr = %08x\n",
                            hr ));
                piReplCat->CleanupSourceShares();
                piReplCat->Release();
                goto Finished;
            }

            hr = piReplCat->CopyFilesToTarget( bstrTargetMachineName );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "CopyCatalogFilesToTarget() failed with hr = %08x\n",
                            hr ));
                piReplCat->CleanupSourceShares();
                piReplCat->Release();
                goto Finished;
            }

            hr = piReplCat->InstallTarget( bstrTargetMachineName );
            if (FAILED(hr))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "InstallCatalogOnTarget() failed with hr = %08x\n",
                            hr ));
                piReplCat->CleanupSourceShares();
                piReplCat->Release();
                goto Finished;
            }

            piReplCat->CleanupSourceShares();
            piReplCat->Release();
            
            }
        else
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to CoCreateInstance of CLSID_ReplicateCatalog, hr = %08x\n",
                hr));
            }
        }

Finished:

    if (bstrSourceMachineName)
        {
        SysFreeString(bstrSourceMachineName);
        bstrSourceMachineName = NULL;
        }

    if (bstrTargetMachineName)
        {
        SysFreeString(bstrTargetMachineName);
        bstrTargetMachineName = NULL;
        }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\sync\cr.cxx ===
#define UNICODE
#define INITGUID
#include    <windows.h>
#include    <stdio.h>
#include    <clusapi.h>

typedef HCLUSTER
(WINAPI *PFN_OPENCLUSTER)(
    IN LPCWSTR lpszClusterName
    );

typedef BOOL
(WINAPI *PFN_CLOSECLUSTER)(
    IN HCLUSTER hCluster
    );

typedef DWORD
(WINAPI *PFN_CREATECLUSTERRESOURCETYPE)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszResourceTypeDll,
    IN DWORD dwLooksAlivePollInterval,
    IN DWORD dwIsAlivePollInterval
    );

typedef DWORD
(WINAPI *PFN_DELETECLUSTERRESOURCETYPE)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName
    );

typedef HCLUSENUM
(WINAPI
*PFN_ClusterOpenEnum)(
    IN HCLUSTER hCluster,
    IN DWORD dwType
    );

typedef DWORD
(WINAPI
*PFN_ClusterEnum)(
    IN HCLUSENUM hEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcbName
    );

typedef DWORD
(WINAPI
*PFN_ClusterCloseEnum)(
    IN HCLUSENUM hEnum
    );

typedef HRESOURCE
(WINAPI
*PFN_OpenClusterResource)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceName
    );

typedef BOOL
(WINAPI
*PFN_CloseClusterResource)(
    IN HRESOURCE hResource
    );

typedef DWORD
(WINAPI
*PFN_DeleteClusterResource)(
    IN HRESOURCE hResource
    );

typedef DWORD
(WINAPI
*PFN_OfflineClusterResource)(
    IN HRESOURCE hResource
    );

typedef HKEY
(WINAPI
*PFN_GetClusterResourceKey)(
    IN HRESOURCE hResource,
    IN REGSAM samDesired
    );

typedef LONG
(WINAPI
*PFN_ClusterRegCloseKey)(
    IN HKEY hKey
    );

typedef LONG
(WINAPI
*PFN_ClusterRegQueryValue)(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

typedef CLUSTER_RESOURCE_STATE
(WINAPI
*PFN_GetClusterResourceState)(
    IN HRESOURCE hResource,
    OUT OPTIONAL LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcbNodeName,
    OUT OPTIONAL LPWSTR lpszGroupName,
    IN OUT LPDWORD lpcbGroupName
    );

typedef DWORD
(WINAPI *PFN_DLLREGISTERCLUADMINEXTENSION)(
    IN HCLUSTER hCluster
    );

typedef DWORD
(WINAPI *PFN_DLLUNREGISTERCLUADMINEXTENSION)(
    IN HCLUSTER hCluster
    );

BOOL
RegisterIisServerInstanceResourceType(
    LPWSTR pszResType,
    LPWSTR pszResTypeDisplayName,
    LPWSTR pszPath,
    LPWSTR pszAdminPath
    )
{
    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_CREATECLUSTERRESOURCETYPE   pfnCreateClusterResourceType;
    HRESULT                         hres;

    if ( hClusapi = LoadLibrary( L"clusapi.dll" ) )
    {
        pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
        pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
        pfnCreateClusterResourceType = (PFN_CREATECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "CreateClusterResourceType" );

        if ( pfnOpenCluster &&
             pfnCloseCluster &&
             pfnCreateClusterResourceType )
        {
            if ( hC = pfnOpenCluster( NULL ) )
            {
                hres = pfnCreateClusterResourceType(
                    hC,
                    pszResType,
                    pszResType,
                    pszPath,
                    5000,
                    60000 );
       

                if ( SUCCEEDED( hres ) )
                {
                    HINSTANCE                           hAdmin;
                    PFN_DLLREGISTERCLUADMINEXTENSION    pfnDllRegisterCluAdminExtension;

                    if ( hAdmin = LoadLibrary( pszAdminPath ) )
                    {
                        pfnDllRegisterCluAdminExtension = 
                            (PFN_DLLREGISTERCLUADMINEXTENSION)GetProcAddress( hAdmin, "DllRegisterCluAdminExtension" );
                        if ( pfnDllRegisterCluAdminExtension )
                        {
                            if ( FAILED(hres = pfnDllRegisterCluAdminExtension( hC )) )
                            {
                                dwErr = hres;
                            }
                        }
                        else
                        {
                            dwErr = GetLastError();
                        }
                        FreeLibrary( hAdmin );
                    }
                    else
                    {
                        dwErr = GetLastError();
                    }
                }
                else
                {
                    dwErr = hres;
                }

                pfnCloseCluster( hC );

                if ( dwErr )
                {
                    SetLastError( dwErr );
                }
            }
        }
        else
        {
            dwErr = GetLastError();
        }

        FreeLibrary( hClusapi );
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr == ERROR_SUCCESS ? TRUE : FALSE;
}


BOOL
UnregisterIisServerInstanceResourceType(
    LPWSTR pszResType,
    LPWSTR pszAdminPath
    )
{
    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_DELETECLUSTERRESOURCETYPE   pfnDeleteClusterResourceType;
    PFN_ClusterOpenEnum             pfnClusterOpenEnum;
    PFN_ClusterEnum                 pfnClusterEnum;
    PFN_ClusterCloseEnum            pfnClusterCloseEnum;
    PFN_OpenClusterResource         pfnOpenClusterResource;
    PFN_CloseClusterResource        pfnCloseClusterResource;
    PFN_DeleteClusterResource       pfnDeleteClusterResource;
    PFN_OfflineClusterResource      pfnOfflineClusterResource;
    PFN_GetClusterResourceKey       pfnGetClusterResourceKey;
    PFN_ClusterRegCloseKey          pfnClusterRegCloseKey;
    PFN_ClusterRegQueryValue        pfnClusterRegQueryValue;
    PFN_GetClusterResourceState     pfnGetClusterResourceState;
    HRESULT                         hres;
    HCLUSENUM                       hClusEnum;
    WCHAR                           awchResName[256];
    WCHAR                           awchResType[256];
    DWORD                           dwEnum;
    DWORD                           dwType;
    DWORD                           dwStrLen;
    HRESOURCE                       hRes;
    HKEY                            hKey;
    BOOL                            fDel;
    DWORD                           dwRetry;


    if ( hClusapi = LoadLibrary( L"clusapi.dll" ) )
    {
        pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
        pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
        pfnDeleteClusterResourceType = (PFN_DELETECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "DeleteClusterResourceType" );
        pfnClusterOpenEnum = (PFN_ClusterOpenEnum)GetProcAddress( hClusapi, "ClusterOpenEnum" );
        pfnClusterEnum = (PFN_ClusterEnum)GetProcAddress( hClusapi, "ClusterEnum" );
        pfnClusterCloseEnum = (PFN_ClusterCloseEnum)GetProcAddress( hClusapi, "ClusterCloseEnum" );
        pfnOpenClusterResource = (PFN_OpenClusterResource)GetProcAddress( hClusapi, "OpenClusterResource" );
        pfnCloseClusterResource = (PFN_CloseClusterResource)GetProcAddress( hClusapi, "CloseClusterResource" );
        pfnDeleteClusterResource = (PFN_DeleteClusterResource)GetProcAddress( hClusapi, "DeleteClusterResource" );
        pfnOfflineClusterResource = (PFN_OfflineClusterResource)GetProcAddress( hClusapi, "OfflineClusterResource" );
        pfnGetClusterResourceKey = (PFN_GetClusterResourceKey)GetProcAddress( hClusapi, "GetClusterResourceKey" );
        pfnClusterRegCloseKey = (PFN_ClusterRegCloseKey)GetProcAddress( hClusapi, "ClusterRegCloseKey" );
        pfnClusterRegQueryValue = (PFN_ClusterRegQueryValue)GetProcAddress( hClusapi, "ClusterRegQueryValue" );
        pfnGetClusterResourceState = (PFN_GetClusterResourceState)GetProcAddress( hClusapi, "GetClusterResourceState" );

        if ( pfnOpenCluster &&
             pfnCloseCluster &&
             pfnDeleteClusterResourceType &&
             pfnClusterOpenEnum &&
             pfnClusterEnum &&
             pfnClusterCloseEnum &&
             pfnOpenClusterResource &&
             pfnCloseClusterResource &&
             pfnDeleteClusterResource &&
             pfnOfflineClusterResource &&
             pfnGetClusterResourceKey &&
             pfnClusterRegCloseKey &&
             pfnClusterRegQueryValue &&
             pfnGetClusterResourceState )
        {
            if ( hC = pfnOpenCluster( NULL ) )
            {
                //
                // Delete all resources of type pszResType
                //

                if ( (hClusEnum = pfnClusterOpenEnum( hC, CLUSTER_ENUM_RESOURCE )) != NULL )
                {
                    for ( dwEnum = 0 ;
                          pfnClusterEnum( hClusEnum, 
                                          dwEnum, 
                                          &dwType, 
                                          awchResName, 
                                          &(dwStrLen=sizeof(awchResName)/sizeof(WCHAR)) ) 
                                  == ERROR_SUCCESS ;
                          ++dwEnum )
                    {
                        if ( hRes = pfnOpenClusterResource( hC, awchResName ) )
                        {
                            if ( hKey = pfnGetClusterResourceKey( hRes, KEY_READ ) )
                            {
                                dwStrLen = sizeof(awchResType)/sizeof(WCHAR);

                                fDel = pfnClusterRegQueryValue( hKey, 
                                                                L"Type", 
                                                                &dwType, 
                                                                (LPBYTE)awchResType, 
                                                                &dwStrLen )
                                            == ERROR_SUCCESS &&
                                       !wcscmp( awchResType, pszResType );

                                pfnClusterRegCloseKey( hKey );

                                if ( fDel )
                                {
                                    pfnOfflineClusterResource( hRes );
                                    for ( dwRetry = 0 ;
                                          dwRetry < 30 &&
                                              pfnGetClusterResourceState( hRes,
                                                                          NULL,
                                                                          &dwStrLen,
                                                                          NULL,
                                                                          &dwStrLen )
                                              != ClusterResourceOffline ;
                                          ++dwRetry )
                                    {
                                        Sleep( 1000 );
                                    }
                                    pfnDeleteClusterResource( hRes );
                                }
                            }

                            pfnCloseClusterResource( hRes );
                        }
                    }

                    pfnClusterCloseEnum( hClusEnum );
                }

                dwErr = pfnDeleteClusterResourceType(
                    hC,
                    pszResType );
       
                    HINSTANCE                           hAdmin;
                    PFN_DLLUNREGISTERCLUADMINEXTENSION  pfnDllUnregisterCluAdminExtension;

                if ( hAdmin = LoadLibrary( pszAdminPath ) )
                {
                    pfnDllUnregisterCluAdminExtension = 
                        (PFN_DLLUNREGISTERCLUADMINEXTENSION)GetProcAddress( hAdmin, "DllUnregisterCluAdminExtension" );
                    if ( pfnDllUnregisterCluAdminExtension )
                    {
                        if ( FAILED(hres = pfnDllUnregisterCluAdminExtension( hC )) )
                        {
                            dwErr = hres;
                        }
                    }
                    else
                    {
                        dwErr = GetLastError();
                    }
                    FreeLibrary( hAdmin );
                }
                else
                {
                    dwErr = GetLastError();
                }

                pfnCloseCluster( hC );

                if ( dwErr )
                {
                    SetLastError( dwErr );
                }
            }
        }
        else
        {
            dwErr = GetLastError();
        }

        FreeLibrary( hClusapi );
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr == ERROR_SUCCESS ? TRUE : FALSE;
}


int __cdecl main( int argc, char*argv[] )
{
    BOOL fSt;

    if ( !strcmp(argv[1],"install" ) )
    {
        fSt = RegisterIisServerInstanceResourceType(
            L"IIS Server Instance",                          // do not touch
            L"IIS Server Instance",                          // do not touch
            L"c:\\winnt\\system32\\inetsrv\\clusiis4.dll",   // path to clusiis4.dll
	    L"c:\\winnt\\system32\\inetsrv\\iisclex4.dll" ); // path to admin ext
    }
    else
    {
        fSt = UnregisterIisServerInstanceResourceType(
            L"IIS Server Instance",                          // do not touch
	    L"c:\\winnt\\system32\\inetsrv\\iisclex4.dll" ); // path to admin ext
    }

    if ( !fSt )
    {
        printf( "Error %d\n", GetLastError() );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\resdll\iisutil.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    iisutil.h

Abstract:

    IIS Resource utility routine DLL

Author:

    Pete Benoit (v-pbenoi) 12-SEP-1996

Revision History:

--*/

#ifndef IISUTIL_H
#define IISUTIL_H

#define     UNICODE             1

#if defined(__cplusplus)
extern "C" {
#endif

#include    "clusres.h"
#include    "wtypes.h"
#include    "iiscnfg.h"
#include    "iiscnfgp.h"
#include    "iiscl.h"

#if defined(__cplusplus)
}   // extern "C"
#endif

#include    <winsock2.h>
#include    <ole2.h>
#include    <iadm.h>

extern PLOG_EVENT_ROUTINE g_IISLogEvent;
//#define IISLogEvent ClusResLogEvent
//#define IISSetResourceStatus ClusResSetResourceStatus

#if DBG
//#define DBG_CANT_VERIFY
//extern BOOL g_fDbgCantVerify;
#endif

#if 1

#define _DEBUG_SUPPORT
extern char debug_buffer[];
extern FILE* debug_file;
extern void InitDebug();
#define DEBUG_BUFFER debug_buffer
#define DECLARE_DEBUG_BUFFER char debug_buffer[256]; FILE *debug_file=NULL
#define INIT_DEBUG InitDebug()
#define TERMINATE_DEBUG if ( debug_file ) fclose(debug_file)
extern void TimeStamp( FILE* );
#define TR(a) { if ( debug_file ) {TimeStamp(debug_file); wsprintfA a; fputs(debug_buffer,debug_file); fflush(debug_file);} }

#else

#define DEBUG_BUFFER
#define DECLARE_DEBUG_BUFFER
#define INIT_DEBUG
#define TERMINATE_DEBUG
#define TR(a)

#endif

extern DWORD                g_dwTlsCoInit;
extern HANDLE               g_hEventLog;

#define SetCoInit( a ) TlsSetValue( g_dwTlsCoInit, (LPVOID)a )
#define GetCoInit() (BOOL)(!!PtrToUlong(TlsGetValue( g_dwTlsCoInit )))

// Define the Service Identifiers
#define IIS_SERVICE_TYPE_W3     0
#define IIS_SERVICE_TYPE_FTP    1
#define IIS_SERVICE_TYPE_SMTP   2
#define IIS_SERVICE_TYPE_NNTP   3
#define MAX_SERVICE             IIS_SERVICE_TYPE_NNTP + 1

// Define the default ports for services
const USHORT DEFAULT_PORT[MAX_SERVICE] =
{
    80,             // W3
    21,             // FTP
    25,             // SMTP
    119             // NNTP
};

// Define the resource type identifiers
#define IIS_RESOURCE_TYPE       0
#define SMTP_RESOURCE_TYPE      1
#define NNTP_RESOURCE_TYPE      2
#define MAX_RESOURCE_TYPE       NNTP_RESOURCE_TYPE + 1

// Define the resource type names
const WCHAR RESOURCE_TYPE[MAX_RESOURCE_TYPE][MAX_PATH] =
{
    L"IIS Server Instance",
    L"SMTP Server Instance",
    L"NNTP Server Instance"
};

// Define some max values
#define SERVER_START_DELAY          1000        // 1 Second
#define MAX_DEFAULT_WSTRING_SIZE    512         // Default string size
#define MAX_RETRY                   4           // 4 Retries
#define MAX_MUTEX_WAIT              10*1000     // 10 seconds
#define IP_ADDRESS_RESOURCE_NAME    L"IP Address"
#define CHECK_IS_ALIVE_CONNECT_TIMEOUT  10
#define CHECK_IS_ALIVE_SEND_TIMEOUT     10
#define CHECK_IS_ALIVE_SEND_TIMEOUT     10
#define IIS_RESOURCE_SIGNATURE      0x75fc983b
#define MB_TIMEOUT                  5000

#define SERVICE_START_MAX_POLL      30
#define SERVICE_START_POLL_DELAY    1000

#define IISCLUS_ONLINE_TIMEOUT      30          // 30 s
#define IISCLUS_OFFLINE_TIMEOUT     (60*3)      // 3 minutes

// Define parameters structure
typedef struct _IIS_PARAMS {
    LPWSTR          ServiceName;
    LPWSTR          InstanceId;
    LPWSTR          MDPath;
    DWORD           ServiceType;
} IIS_PARAMS, *PIIS_PARAMS;

// Define the resource data structure
typedef struct _IIS_RESOURCE {
    DWORD                           Signature;
    DWORD                           dwPort;
	SOCKADDR                        saServer;
	BOOL                            bAlive;
    LIST_ENTRY                      ListEntry;
    LPWSTR                          ResourceName;
    IIS_PARAMS                      Params;
    RESOURCE_HANDLE                 ResourceHandle;
    HKEY                            ParametersKey;
    CLUS_WORKER                     OnlineThread;
    CLUS_WORKER                     OfflineThread;
	CLUSTER_RESOURCE_STATE          State;
} IIS_RESOURCE, *LPIIS_RESOURCE;



DWORD
SetInstanceState(
    IN PCLUS_WORKER             pWorker,
    IN LPIIS_RESOURCE           ResourceEntry,
    IN RESOURCE_STATUS*         presourceStatus,
    IN CLUSTER_RESOURCE_STATE   TargetState,
    IN LPWSTR                   TargetStateString,
    IN DWORD                    dwMdPropControl,
    IN DWORD                    dwMdPropTarget
    );

DWORD
InstanceEnableCluster(
    LPWSTR  pwszServiceName,
    LPWSTR  pwszInstanceId
    );

DWORD
InstanceDisableCluster(
    LPWSTR  pwszServiceName,
    LPWSTR  pwszInstanceId
    );
    
VOID
DestructIISResource(
        IN LPIIS_RESOURCE   ResourceEntry
        );


VOID
FreeIISResource(
        IN LPIIS_RESOURCE   ResourceEntry
        );



DWORD
VerifyIISService(
	IN LPWSTR               MDPath,
	IN DWORD                ServiceType,
    IN DWORD                dwPort,
	IN SOCKADDR             saServer,
    IN PLOG_EVENT_ROUTINE   LogEvent
    );

DWORD
GetServerBindings(	
	LPWSTR               MDPath,
	DWORD                dwServiceType,
	SOCKADDR*            psaServer,
	LPDWORD              pdwPort 
	);

HRESOURCE
ClusterGetResourceDependency(
    IN LPCWSTR              ResourceName,
    IN LPCWSTR              ResourceType,
    IN LPIIS_RESOURCE       ResourceEntry,
    IN PLOG_EVENT_ROUTINE   LogEvent
    );

DWORD
ResUtilSetSzProperty(
    IN HKEY RegistryKey,
    IN LPCWSTR PropName,
    IN LPCWSTR NewValue,
    IN OUT PWSTR * OutValue
    );

DWORD
WINAPI
ResUtilReadProperties(
    IN HKEY RegistryKey,
    IN const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN OUT LPBYTE OutParams,
    IN RESOURCE_HANDLE ResourceHandle,
    IN PLOG_EVENT_ROUTINE LogEvent
    );

class CMetaData {
public:
    CMetaData() { m_hMB = NULL; }
    ~CMetaData() { Close(); }

    BOOL Open( LPWSTR          pszPath,
               BOOL            fReconnect = FALSE,
               DWORD           dwFlags = METADATA_PERMISSION_READ );

    BOOL Close( VOID );

    BOOL SetData( LPWSTR       pszPath,
                  DWORD        dwPropID,
                  DWORD        dwUserType,
                  DWORD        dwDataType,
                  VOID *       pvData,
                  DWORD        cbData,
                  DWORD        dwFlags = METADATA_INHERIT );

    BOOL GetData( LPWSTR        pszPath,
                  DWORD         dwPropID,
                  DWORD         dwUserType,
                  DWORD         dwDataType,
                  VOID *        pvData,
                  DWORD *       cbData,
                  DWORD         dwFlags = METADATA_INHERIT );

    BOOL SetDword( LPWSTR       pszPath,
                   DWORD        dwPropID,
                   DWORD        dwUserType,
                   DWORD        dwValue,
                   DWORD        dwFlags = METADATA_INHERIT )
    {
        return SetData( pszPath,
                        dwPropID,
                        dwUserType,
                        DWORD_METADATA,
                        (PVOID) &dwValue,
                        sizeof( DWORD ),
                        dwFlags );
    }

    BOOL GetDword( LPWSTR        pszPath,
                   DWORD         dwPropID,
                   DWORD         dwUserType,
                   DWORD *       pdwValue,
                   DWORD         dwFlags = METADATA_INHERIT )
    {
        DWORD cb = sizeof(DWORD);

        return GetData( pszPath,
                        dwPropID,
                        dwUserType,
                        DWORD_METADATA,
                        pdwValue,
                        &cb,
                        dwFlags );
    }

    BOOL GetString( LPWSTR        pszPath,
                    DWORD         dwPropID,
                    DWORD         dwUserType,
                    WCHAR *       pszValue,
                    DWORD *       pcbValue,
                    DWORD         dwFlags = METADATA_INHERIT )
    {
        return GetData( pszPath,
                        dwPropID,
                        dwUserType,
                        STRING_METADATA,
                        pszValue,
                        pcbValue,
                        dwFlags );
    }

    BOOL GetMultisz( LPWSTR        pszPath,
                     DWORD         dwPropID,
                     DWORD         dwUserType,
                     LPWSTR        pszValue,
                     DWORD*        pcbValue,
                     DWORD         dwFlags = METADATA_INHERIT )
    {
        return GetData( pszPath,
                        dwPropID,
                        dwUserType,
                        MULTISZ_METADATA,
                        (LPVOID)pszValue,
                        pcbValue,
                        dwFlags );
    }

    static BOOL Init();
    static BOOL Terminate();

    BOOL GetMD();
    BOOL ReleaseMD();

private:

    METADATA_HANDLE         m_hMB;
    static IMSAdminBase*    g_pMBCom;
    static CRITICAL_SECTION g_cs;
} ;


BOOL
TcpSockSend(
    IN SOCKET      sock,
    IN LPVOID      pBuffer,
    IN DWORD       cbBuffer,
    OUT PDWORD     pcbTotalSent,
    IN DWORD       nTimeout
    );

BOOL
TcpSockRecv(
    IN SOCKET       sock,
    IN LPVOID       pBuffer,
    IN DWORD        cbBuffer,
    OUT LPDWORD     pbReceived,
    IN DWORD        nTimeout
    );

INT
WaitForSocketWorker(
    IN SOCKET   sockRead,
    IN SOCKET   sockWrite,
    IN LPBOOL   pfRead,
    IN LPBOOL   pfWrite,
    IN DWORD    nTimeout
    );

SOCKET
TcpSockConnectToHost(
    SOCKADDR*   psaServer,
    DWORD       dwPort,
    DWORD       dwTimeOut
    );

VOID
TcpSockClose(
    SOCKET  hSocket
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\sync\regc.h ===
// regc.h : Declaration of the Cregc

#ifndef __REGC_H_
#define __REGC_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Cregc
class ATL_NO_VTABLE Cregc : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<Cregc, &CLSID_regc>,
	public IDispatchImpl<IComponentRegistrar, &IID_IComponentRegistrar, &LIBID_MDSYNCLib>
{
public:
	Cregc()
	{
	}

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(Cregc)
	COM_INTERFACE_ENTRY(IComponentRegistrar)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IComponentRegistrar
public:
    STDMETHOD(Attach)(BSTR bstrPath)
	{
		return E_NOTIMPL;
	}
	STDMETHOD(RegisterAll)()
	{
		_ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;
		HRESULT hr = S_OK;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pfnGetObjectDescription() != NULL)
			{
				hr = _Module.RegisterServer(TRUE, pEntry->pclsid);
				if (FAILED(hr))
					break;
			}
			pEntry++;
		}
		return hr;
	}
	STDMETHOD(UnregisterAll)()    
	{
		_ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pfnGetObjectDescription() != NULL)
				_Module.UnregisterServer(pEntry->pclsid);
			pEntry++;
		}
		return S_OK;
	}
	STDMETHOD(GetComponents)(SAFEARRAY **ppCLSIDs, SAFEARRAY **ppDescriptions)
	{
		_ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;
		int nComponents = 0;
		while (pEntry->pclsid != NULL)
		{
			LPCTSTR pszDescription = pEntry->pfnGetObjectDescription();
			if (pszDescription)
				nComponents++;
			pEntry++;
		}
		SAFEARRAYBOUND rgBound[1];
		rgBound[0].lLbound = 0;
		rgBound[0].cElements = nComponents;
		*ppCLSIDs = SafeArrayCreate(VT_BSTR, 1, rgBound);
		*ppDescriptions = SafeArrayCreate(VT_BSTR, 1, rgBound);
		pEntry = _Module.m_pObjMap;
		for (long i=0; pEntry->pclsid != NULL; pEntry++)
		{
			LPCTSTR pszDescription = pEntry->pfnGetObjectDescription();
			if (pszDescription)
			{
				LPOLESTR pszCLSID;
				StringFromCLSID(*pEntry->pclsid, &pszCLSID);
				SafeArrayPutElement(*ppCLSIDs, &i, OLE2BSTR(pszCLSID));
				CoTaskMemFree(pszCLSID);
				SafeArrayPutElement(*ppCLSIDs, &i, T2BSTR(pszDescription));
				i++;
			}
		}
		return S_OK;
	}
	STDMETHOD(RegisterComponent)(BSTR bstrCLSID)
	{
		CLSID clsid;
		CLSIDFromString(bstrCLSID, &clsid);
		_Module.RegisterServer(TRUE, &clsid);
		return S_OK;
	}
	STDMETHOD(UnregisterComponent)(BSTR bstrCLSID)
	{
		CLSID clsid;
		CLSIDFromString(bstrCLSID, &clsid);
		_Module.UnregisterServer(&clsid);
		return S_OK;
	}
};

#endif //__REGC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\sync\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C97912D4_997E_11D0_A5F6_00A0C922E752__INCLUDED_)
#define AFX_STDAFX_H__C97912D4_997E_11D0_A5F6_00A0C922E752__INCLUDED_

#if _MSC_VER >= 1001
#pragma once
#endif // _MSC_VER >= 1001

#if !defined(STRICT)
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C97912D4_997E_11D0_A5F6_00A0C922E752__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\sync\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sync.rc
//
#define IDS_PROJNAME                    100
#define IDS_MDSYNC_DESC                 101
#define IDR_MdSync                      102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\appconfig.cpp ===
// AppConfig.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for AppConfig.idl by adding the following 
//      files to the Outputs.
//          AppConfig_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f AppConfigps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "AppConfig.h"
#include "dlldatax.h"

#include "AppConf_i.c"
#include "IISAppConfig.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IISAppConfig, CIISAppConfig)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_APPCONFIGLib);
        DisableThreadLibraryCalls(hInstance);
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(iccx);
        iccx.dwICC = ICC_DATE_CLASSES | ICC_UPDOWN_CLASS;
        ::InitCommonControlsEx(&iccx);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\sync\sync.cpp ===
// sync.cpp : Implementation of DLL Exports.



// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f syncps.mk in the project directory.

extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
}   // extern "C"

#include <wincrypt.h>

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "mdsync.h"

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include "dbgutil.h"
#include "mdsync_i.c"
#include "MdSync.hxx"
#include "regc.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MdSync, MdSync)
	OBJECT_ENTRY(CLSID_regc, Cregc)
END_OBJECT_MAP()

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#else
#include <initguid.h>
DEFINE_GUID(IisWpSyncGuid, 
0x784d8920, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
DECLARE_DEBUG_PRINTS_OBJECT();
const CHAR 	g_pszModuleName[] = "MDSYNC";
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
#ifdef _NO_TRACING_
		CREATE_DEBUG_PRINT_OBJECT(g_pszModuleName);
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#else
	    CREATE_DEBUG_PRINT_OBJECT(g_pszModuleName, IisWpSyncGuid);
#endif
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
		_Module.Term();
        DELETE_DEBUG_PRINT_OBJECT();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\aspdebug.cpp ===
//
//
//
#include "stdafx.h"
#include "AspDebug.h"

LRESULT
CAspDebugPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   DoDataExchange();

   m_ErrorIdx = m_pData->m_SendAspError ? 0 : 1;

   m_DefaultErrCtrl.EnableWindow(!m_pData->m_SendAspError);
   DoDataExchange(FALSE);

   return FALSE;
}

void
CAspDebugPage::OnChangeError(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE);
   m_pData->m_SendAspError = (m_ErrorIdx == 0);
   m_DefaultErrCtrl.EnableWindow(!m_pData->m_SendAspError);
   SET_MODIFIED(TRUE);
}

BOOL
CAspDebugPage::OnKillActive()
{
   DoDataExchange(TRUE);
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wp\sync\test.cxx ===
#define INITGUID
#include    <windows.h>
#include    <stdio.h>
#include    <ole2.h>
#include    "sync.h"

BOOL        g_fDone = FALSE;
DWORD       g_dwTarget = 0;
SYNC_STAT*  g_pStat = NULL;


DWORD
WINAPI
Monitor(
    LPVOID  pV
    )
{
    for ( ;; )
    {
        printf( "Source : %d, %s, Targets : ", 
                g_pStat->m_dwSourceScan, 
                g_pStat->m_fSourceComplete ? "scanned" : "scanning" );
        for ( int i = 0 ; i < g_dwTarget ; ++i )
        {
            printf( "(%d,%d), ", g_pStat->m_adwTargets[i*2], g_pStat->m_adwTargets[i*2+1] );
        }
        printf( "\r" );

        if ( g_fDone )
        {
            break;
        }

        Sleep( 1000 );
    }

    return 0;
}


int __cdecl main( int argc, char*argv[] )
{
    IMdSync*    pIf;
    DWORD       adwErr[16];
    HANDLE      hThread;
    DWORD       dwThreadId;

    g_pStat = (SYNC_STAT*)LocalAlloc( LMEM_FIXED, sizeof(SYNC_STAT)+sizeof(DWORD)*2*16 );
    memset ( g_pStat, '\0', sizeof(SYNC_STAT)+sizeof(DWORD)*2*16  );

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( SUCCEEDED( CoCreateInstance( CLSID_MDSync, NULL, CLSCTX_INPROC_SERVER,  IID_IMDSync, (LPVOID*)&pIf ) ) )
    {
        g_dwTarget = 1;

        hThread = CreateThread( NULL, 0, ::Monitor, NULL, 0, &dwThreadId );

        pIf->Synchronize( "phillich01\x0", adwErr, 0, (LPDWORD)g_pStat );

        g_fDone = TRUE;

        WaitForSingleObject( hThread, INFINITE );

        pIf->Release();
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\appconfig.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Jul 27 17:55:53 2000
 */
/* Compiler settings for D:\ntw\inetsrv\iis\ui\admin\AppConfig\AppConfig.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __AppConfig_h__
#define __AppConfig_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IIISAppConfig_FWD_DEFINED__
#define __IIISAppConfig_FWD_DEFINED__
typedef interface IIISAppConfig IIISAppConfig;
#endif 	/* __IIISAppConfig_FWD_DEFINED__ */


#ifndef __IISAppConfig_FWD_DEFINED__
#define __IISAppConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class IISAppConfig IISAppConfig;
#else
typedef struct IISAppConfig IISAppConfig;
#endif /* __cplusplus */

#endif 	/* __IISAppConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IIISAppConfig_INTERFACE_DEFINED__
#define __IIISAppConfig_INTERFACE_DEFINED__

/* interface IIISAppConfig */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IIISAppConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4E9B327-D9B4-4942-871E-1AF2FFCF6C0C")
    IIISAppConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ComputerName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UserName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UserPassword( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MetaPath( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIISAppConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIISAppConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIISAppConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IIISAppConfig __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IIISAppConfig __RPC_FAR * This);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ComputerName )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserName )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserPassword )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MetaPath )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IIISAppConfigVtbl;

    interface IIISAppConfig
    {
        CONST_VTBL struct IIISAppConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIISAppConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIISAppConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIISAppConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIISAppConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIISAppConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIISAppConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIISAppConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIISAppConfig_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IIISAppConfig_put_ComputerName(This,newVal)	\
    (This)->lpVtbl -> put_ComputerName(This,newVal)

#define IIISAppConfig_put_UserName(This,newVal)	\
    (This)->lpVtbl -> put_UserName(This,newVal)

#define IIISAppConfig_put_UserPassword(This,newVal)	\
    (This)->lpVtbl -> put_UserPassword(This,newVal)

#define IIISAppConfig_put_MetaPath(This,newVal)	\
    (This)->lpVtbl -> put_MetaPath(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_Run_Proxy( 
    IIISAppConfig __RPC_FAR * This);


void __RPC_STUB IIISAppConfig_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_put_ComputerName_Proxy( 
    IIISAppConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIISAppConfig_put_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_put_UserName_Proxy( 
    IIISAppConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIISAppConfig_put_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_put_UserPassword_Proxy( 
    IIISAppConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIISAppConfig_put_UserPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_put_MetaPath_Proxy( 
    IIISAppConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIISAppConfig_put_MetaPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIISAppConfig_INTERFACE_DEFINED__ */



#ifndef __APPCONFIGLib_LIBRARY_DEFINED__
#define __APPCONFIGLib_LIBRARY_DEFINED__

/* library APPCONFIGLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_APPCONFIGLib;

EXTERN_C const CLSID CLSID_IISAppConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("5443AED3-A8AF-4351-B7E1-929EABCAF250")
IISAppConfig;
#endif
#endif /* __APPCONFIGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\aspdebug.h ===
//
//
//
#ifndef _ASP_DEBUG_H
#define _ASP_DEBUG_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"

class CAspDebugPage : 
   public WTL::CPropertyPageImpl<CAspDebugPage>,
   public WTL::CWinDataExchange<CAspDebugPage>
{
   typedef WTL::CPropertyPageImpl<CAspDebugPage> baseClass;

public:
   CAspDebugPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CAspDebugPage()
   {
   }

   enum {IDD = IDD_ASPDEBUG};

BEGIN_MSG_MAP_EX(CAspDebugPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_SEND_DEF_ERROR, BN_CLICKED, OnChangeError)
   COMMAND_HANDLER_EX(IDC_SEND_DETAILED_ERROR, BN_CLICKED, OnChangeError)
   COMMAND_HANDLER_EX(IDC_CLIENT_DEBUG, BN_CLICKED, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_DEFAULT_ERROR, EN_CHANGE, OnChangeControl)
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CAspDebugPage)
   DDX_CHECK(IDC_SERVER_DEBUG, m_pData->m_ServerDebug)
   DDX_CHECK(IDC_CLIENT_DEBUG, m_pData->m_ClientDebug)
   DDX_RADIO(IDC_SEND_DETAILED_ERROR, m_ErrorIdx)
   DDX_TEXT(IDC_DEFAULT_ERROR, m_pData->m_DefaultError)
   DDX_CONTROL(IDC_DEFAULT_ERROR, m_DefaultErrCtrl)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnChangeError(UINT nCode, UINT nID, HWND hWnd);
   void OnChangeControl(UINT nCode, UINT nID, HWND hWnd)
   {
      SET_MODIFIED(TRUE);
   }
   BOOL OnKillActive();

protected:
   CAppData * m_pData;
   int m_ErrorIdx;
   CEditExch m_DefaultErrCtrl;
};

#endif //_ASP_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\aspmain.h ===
//
//
//
#ifndef _ASP_MAIN_H
#define _ASP_MAIN_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"

class CAspMainPage : 
   public WTL::CPropertyPageImpl<CAspMainPage>,
   public WTL::CWinDataExchange<CAspMainPage>
{
   typedef CPropertyPageImpl<CAspMainPage> baseClass;

public:
   CAspMainPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CAspMainPage()
   {
   }

   enum {IDD = IDD_ASPMAIN};

BEGIN_MSG_MAP_EX(CAspMainPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_ENABLE_SESSION, BN_CLICKED, OnEnableSession)
   COMMAND_HANDLER_EX(IDC_ENABLE_BUFFERING, BN_CLICKED, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_ENABLE_PARENTS, BN_CLICKED, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_SESSION_TIMEOUT, EN_CHANGE, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_SCRIPT_TIMEOUT, EN_CHANGE, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_LANGUAGES, EN_CHANGE, OnChangeControl)
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CAspMainPage)
   DDX_CHECK(IDC_ENABLE_SESSION, m_pData->m_EnableSession)
   DDX_CHECK(IDC_ENABLE_BUFFERING, m_pData->m_EnableBuffering)
   DDX_CHECK(IDC_ENABLE_PARENTS, m_pData->m_EnableParents)
   DDX_INT(IDC_SESSION_TIMEOUT, m_pData->m_SessionTimeout)
   DDX_TEXT(IDC_LANGUAGES, m_pData->m_Languages)
   DDX_INT(IDC_SCRIPT_TIMEOUT, m_pData->m_ScriptTimeout)

   DDX_CONTROL(IDC_LANGUAGES, m_LanguagesCtrl)
   DDX_CONTROL(IDC_TIMEOUT_SPIN, m_TimeoutSpin)
   DDX_CONTROL(IDC_ASPTIMEOUT_SPIN, m_AspTimeoutSpin)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnEnableSession(UINT nCode, UINT nID, HWND hWnd);
   void OnChangeControl(UINT nCode, UINT nID, HWND hWnd)
   {
      SET_MODIFIED(TRUE);
   }
   BOOL OnKillActive();

protected:
   CAppData * m_pData;
   CEditExch m_LanguagesCtrl;
   CUpDownCtrlExch m_TimeoutSpin;
   CUpDownCtrlExch m_AspTimeoutSpin;
};

#endif //_ASP_MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\aspmain.cpp ===
//
//
//
#include "stdafx.h"
#include "aspmain.h"

LRESULT
CAspMainPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   DoDataExchange();

   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};
   m_TimeoutSpin.SetRange32(1, 0x7fffffff);
   m_TimeoutSpin.SetPos32(m_pData->m_SessionTimeout);
   m_TimeoutSpin.SetAccel(3, toAcc);

   m_AspTimeoutSpin.SetRange32(1, 0x7fffffff);
   m_AspTimeoutSpin.SetPos32(m_pData->m_ScriptTimeout);
   m_AspTimeoutSpin.SetAccel(3, toAcc);
   
   return FALSE;
}

void
CAspMainPage::OnEnableSession(UINT nCode, UINT nID, HWND hWnd)
{
   BOOL bEnable = SendDlgItemMessage(IDC_ENABLE_SESSION, BM_GETCHECK, 0, 0);
   ::EnableWindow(GetDlgItem(IDC_SESSION_TIMEOUT), bEnable);
   ::EnableWindow(GetDlgItem(IDC_TIMEOUT_SPIN), bEnable);
   SET_MODIFIED(TRUE);
}

BOOL
CAspMainPage::OnKillActive()
{
   DoDataExchange(TRUE);
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\cacheopt.cpp ===
//
//
//
#include "stdafx.h"
#include "CacheOpt.h"

LRESULT 
CCacheOptPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   if (NULL == m_pData)
   {
      ASSERT(FALSE);
      ::EndDialog(hDlg, 0);
      return -1;
   }
   m_bInitDone = FALSE;
   DoDataExchange();
   m_FileChooser.Init(this, 
      FC_DIRECTORY_ONLY | FC_FORWRITE, IDC_CACHE_PATH, IDC_BROWSE);
   CString title;
   if (title.LoadString(_Module.GetResourceInstance(), IDS_SELECT_CACHE_PATH))
      m_FileChooser.SetDialogTitle(title);
   m_FileChooser.SetPath(m_pData->m_DiskCacheDir);

   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};
   
   m_eng_cache.SetRange32(0, 0x7fffffff);
   m_eng_cache.SetPos32(m_pData->m_ScriptEngCacheMax);
   m_eng_cache.SetAccel(3, toAcc);
   
   m_cache_size.SetRange32(0, 0x7fffffff);
   m_cache_size.SetPos32(m_pData->m_TotalCacheSize);
   m_cache_size.SetAccel(3, toAcc);
   
   m_inmem_unlim.SetRange32(0, m_pData->m_TotalCacheSize);
   m_inmem_unlim.SetPos32(m_pData->m_UnlimCacheInMemorySize);
   m_inmem_unlim.SetAccel(3, toAcc);
   
   m_inmem_lim.SetRange32(0, m_pData->m_TotalCacheSize);
   m_inmem_lim.SetPos32(m_pData->m_LimCacheInMemorySize);
   m_inmem_lim.SetAccel(3, toAcc);

   UINT id = IDC_UNLIMITED_CACHE;
   if (m_pData->m_NoCache) 
      id = IDC_NO_CACHE;
   else if (m_pData->m_LimCache) 
      id = IDC_LIMITED_CACHE;
   OnCacheSwitch(0, id, NULL);

   AdjustTracker();

   DoDataExchange();

   m_bInitDone = TRUE;

   return FALSE;
};

BOOL
CCacheOptPage::OnKillActive()
{
   if (m_bInitDone)
   {
      DoDataExchange(TRUE);
      if (m_pData->m_LimCache)
      {
         if (m_pData->m_LimCacheInMemorySize > m_pData->m_TotalCacheSize)
         {
            ::SetFocus(GetDlgItem(IDC_INMEM_LIM_EDIT));
            return FALSE;
         }
      }
      CString buf;
      if (FC_SUCCESS != m_FileChooser.GetFileName(buf))
         return FALSE;
      DWORD attr = ::GetFileAttributes(buf);
      if (-1 == (int)attr)
      {
         CError err(GetLastError());
         err.MessageBox(MB_OK);
         ::SetFocus(GetDlgItem(IDC_CACHE_PATH));
         SendDlgItemMessage(IDC_CACHE_PATH, EM_SETSEL, 0, -1);
         return FALSE;
      }
      if (  (attr & FILE_ATTRIBUTE_READONLY) != 0
         || (attr & FILE_ATTRIBUTE_DIRECTORY) == 0
         || PathIsNetworkPath(buf)
         )
      {
         CString cap, msg;
         cap.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
         msg.LoadString(_Module.GetResourceInstance(), IDS_READ_ONLY_DIRECTORY);
         SendDlgItemMessage(IDC_CACHE_PATH, EM_SETSEL, 0, -1);
         MessageBox(msg, cap);
         ::SetFocus(GetDlgItem(IDC_CACHE_PATH));
         return FALSE;
      }
      StrCpy(m_pData->m_DiskCacheDir, buf);
   }
   return TRUE;
}

void
CCacheOptPage::OnCacheSwitch(UINT, UINT nID, HWND)
{
   switch (nID)
   {
   case IDC_NO_CACHE:
      m_pData->m_NoCache = TRUE;
      m_pData->m_UnlimCache = FALSE;
      m_pData->m_LimCache = FALSE;
      break;
   case IDC_UNLIMITED_CACHE:
      m_pData->m_NoCache = FALSE;
      m_pData->m_UnlimCache = TRUE;
      m_pData->m_LimCache = FALSE;
      break;
   case IDC_LIMITED_CACHE:
      m_pData->m_NoCache = FALSE;
      m_pData->m_UnlimCache = FALSE;
      m_pData->m_LimCache = TRUE;
      break;
   }
   m_NoCacheBtn.SetCheck(m_pData->m_NoCache);
   m_UnlimCacheBtn.SetCheck(m_pData->m_UnlimCache);
   m_LimCacheBtn.SetCheck(m_pData->m_LimCache);

   m_inmem_unlim.EnableWindow(m_pData->m_UnlimCache);
   ::EnableWindow(GetDlgItem(IDC_INMEM_UNLIM_EDIT), m_pData->m_UnlimCache);

   m_inmem_lim.EnableWindow(m_pData->m_LimCache);
   ::EnableWindow(GetDlgItem(IDC_INMEM_LIM_EDIT), m_pData->m_LimCache);
   m_cache_size.EnableWindow(m_pData->m_LimCache);
   ::EnableWindow(GetDlgItem(IDC_CACHE_SIZE_EDIT), m_pData->m_LimCache);
   m_cache_dist.EnableWindow(m_pData->m_LimCache);

   SET_MODIFIED(TRUE);
}

void
CCacheOptPage::OnChangeCacheSize(UINT nCode, UINT nID, HWND)
{
   if (::IsWindow(m_cache_dist.m_hWnd) && m_bInitDone)
   {
      DoDataExchange(TRUE, IDC_CACHE_SIZE_EDIT);
      AdjustTracker();
      m_inmem_lim.SetRange32(0, m_pData->m_TotalCacheSize);
      // Here we could adjust in memory size to be less or equal to the total size,
      // but I decided that it could be annoying: what if user deleted last zero
      // in total size control, and in memory size turned to be larger than total size.
      // We immediately will cut it to total, and to fix this mistake user will need 
      // to touch two places. It will be too bad.
      SET_MODIFIED(TRUE);
   }
}

void
CCacheOptPage::OnChangeInmemCacheSize(UINT nCode, UINT nID, HWND)
{
   if (::IsWindow(m_cache_dist.m_hWnd) && m_bInitDone)
   {
      DoDataExchange(TRUE, nID);
      AdjustTracker();
      SET_MODIFIED(TRUE);
   }
}

void
CCacheOptPage::OnTrackBarScroll(UINT nSBCode, UINT nPos, HWND hwnd)
{
   BOOL bChange = FALSE;
   switch (nSBCode)
   {
   case SB_THUMBPOSITION:
      m_pData->m_LimCacheInMemorySize = nPos;
      bChange = TRUE;
      break;
   case SB_LINELEFT:
      m_pData->m_LimCacheInMemorySize -= m_cache_dist.GetLineSize();
      bChange = TRUE;
      break;
   case SB_LINERIGHT:
      m_pData->m_LimCacheInMemorySize += m_cache_dist.GetLineSize();
      bChange = TRUE;
      break;
   case SB_PAGELEFT:
      m_pData->m_LimCacheInMemorySize -= m_cache_dist.GetPageSize();
      bChange = TRUE;
      break;
   case SB_PAGERIGHT:
      m_pData->m_LimCacheInMemorySize += m_cache_dist.GetPageSize();
      bChange = TRUE;
      break;
   case SB_THUMBTRACK:
   case SB_LEFT:
   case SB_RIGHT:
   case SB_ENDSCROLL:
      break;
   }
   if (bChange)
   {
      DoDataExchange(FALSE, IDC_INMEM_LIM_EDIT);
      SET_MODIFIED(TRUE);
   }
}

void
CCacheOptPage::AdjustTracker()
{
   if (::IsWindow(m_cache_dist.m_hWnd))
   {
      m_cache_dist.SetRange(0, m_pData->m_TotalCacheSize, TRUE);
      m_cache_dist.SetPos(m_pData->m_LimCacheInMemorySize);
      m_cache_dist.SetPageSize(m_pData->m_TotalCacheSize / 10);
      m_cache_dist.SetLineSize(m_pData->m_TotalCacheSize / 25);
      m_cache_dist.SetTicFreq(m_pData->m_TotalCacheSize / 25);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__C969038E_59A1_48EA_AB6D_7EFFCFCED92E__INCLUDED_)
#define AFX_DLLDATAX_H__C969038E_59A1_48EA_AB6D_7EFFCFCED92E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__C969038E_59A1_48EA_AB6D_7EFFCFCED92E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\cacheopt.h ===
//
//
//
#ifndef _CACHE_OPT_H
#define _CACHE_OPT_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"

class CCacheOptPage : 
   public WTL::CPropertyPageImpl<CCacheOptPage>,
   public WTL::CWinDataExchange<CCacheOptPage>
{
   typedef WTL::CPropertyPageImpl<CCacheOptPage> baseClass;

public:
   CCacheOptPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CCacheOptPage()
   {
   }

   enum {IDD = IDD_CACHE_OPT};

BEGIN_MSG_MAP_EX(CCacheOptPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_NO_CACHE, BN_CLICKED, OnCacheSwitch)
   COMMAND_HANDLER_EX(IDC_UNLIMITED_CACHE, BN_CLICKED, OnCacheSwitch)
   COMMAND_HANDLER_EX(IDC_LIMITED_CACHE, BN_CLICKED, OnCacheSwitch)
   COMMAND_HANDLER_EX(IDC_CACHE_SIZE_EDIT, EN_CHANGE, OnChangeCacheSize)
   COMMAND_HANDLER_EX(IDC_INMEM_LIM_EDIT, EN_CHANGE, OnChangeInmemCacheSize)
   COMMAND_HANDLER_EX(IDC_CACHE_PATH, EN_CHANGE, OnChangeData)
   COMMAND_HANDLER_EX(IDC_ENGINES, EN_CHANGE, OnChangeData)
   MSG_WM_HSCROLL(OnTrackBarScroll)
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CCacheOptPage)
   DDX_CHECK(IDC_NO_CACHE, m_pData->m_NoCache)
   DDX_CHECK(IDC_UNLIMITED_CACHE, m_pData->m_UnlimCache)
   DDX_CHECK(IDC_LIMITED_CACHE, m_pData->m_LimCache)
   DDX_INT(IDC_CACHE_SIZE_EDIT, m_pData->m_TotalCacheSize)
   DDX_INT(IDC_INMEM_UNLIM_EDIT, m_pData->m_UnlimCacheInMemorySize)
   DDX_INT(IDC_INMEM_LIM_EDIT, m_pData->m_LimCacheInMemorySize)
   DDX_CONTROL(IDC_NO_CACHE, m_NoCacheBtn)
   DDX_CONTROL(IDC_UNLIMITED_CACHE, m_UnlimCacheBtn)
   DDX_CONTROL(IDC_LIMITED_CACHE, m_LimCacheBtn)
   DDX_CONTROL(IDC_CACHE_DIST, m_cache_dist)
   DDX_CONTROL(IDC_INMEM_UNLIM_SPIN, m_inmem_unlim)
   DDX_CONTROL(IDC_CACHE_SIZE_SPIN, m_cache_size)
   DDX_CONTROL(IDC_INMEM_LIM_SPIN, m_inmem_lim)
   DDX_CONTROL(IDC_ENG_CACHED_SPIN, m_eng_cache)
   DDX_INT(IDC_ENGINES, m_pData->m_ScriptEngCacheMax)
END_DDX_MAP()

public:
   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnCacheSwitch(UINT nCode, UINT nID, HWND hWnd);
   void OnTrackBarScroll(UINT nSBCode, UINT nPos, HWND hwnd);
   void OnChangeCacheSize(UINT nCode, UINT nID, HWND hWnd);
   void OnChangeInmemCacheSize(UINT nCode, UINT nID, HWND hWnd);
   void OnChangeData(UINT nCode, UINT nID, HWND hWnd)
   {
      SET_MODIFIED(TRUE);
   }
   BOOL OnKillActive();
   BOOL OnApply()
   {
      APPLY_DATA();
      return TRUE;
   }

   void AdjustTracker();

protected:
   CAppData * m_pData;
   CButtonExch m_NoCacheBtn, m_UnlimCacheBtn, m_LimCacheBtn;
   CTrackBarCtrlExch m_cache_dist;
   CUpDownCtrlExch m_inmem_unlim;
   CUpDownCtrlExch m_inmem_lim;
   CUpDownCtrlExch m_cache_size;
   CUpDownCtrlExch m_eng_cache;
   CFileChooser m_FileChooser;
   BOOL m_bInitDone;
};


#endif   //_CACHE_OPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\exchcontrols.h ===
//
//
//
#ifndef _EXCH_CONTROLS_H
#define _EXCH_CONTROLS_H

class CTrackBarCtrlExch : public CWindowImpl<CTrackBarCtrlExch, CTrackBarCtrl>
{
public:
   BEGIN_MSG_MAP_EX(CTrackBarCtrlExch)
   END_MSG_MAP()
};

class CUpDownCtrlExch : public CWindowImpl<CUpDownCtrlExch, CUpDownCtrl>
{
public:
   BEGIN_MSG_MAP_EX(CUpDownCtrlExch)
   END_MSG_MAP()
};

class CButtonExch : public CWindowImpl<CButtonExch, CButton>
{
public:
   BEGIN_MSG_MAP_EX(CButtonExch)
   END_MSG_MAP()
};

class CListViewExch : public CWindowImpl<CListViewExch, CListViewCtrl>
{
public:
   BEGIN_MSG_MAP_EX(CListViewExch)
   END_MSG_MAP()
};

class CListBoxExch : public CWindowImpl<CListBoxExch, CListBox>
{
public:
   BEGIN_MSG_MAP_EX(CListBoxExch)
   END_MSG_MAP()
};

class CEditExch : public CWindowImpl<CEditExch, CEdit>
{
public:
   BEGIN_MSG_MAP_EX(CEditExch)
   END_MSG_MAP()
};

class CTimePickerExch : public CWindowImpl<CTimePickerExch, CDateTimePickerCtrl>
{
public:
   BEGIN_MSG_MAP_EX(CTimePickerExch)
   END_MSG_MAP()
};

#endif //_EXCH_CONTROLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\iisappconfig.h ===
// IISAppConfig.h : Declaration of the CIISAppConfig

#ifndef __IISAPPCONFIG_H_
#define __IISAPPCONFIG_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CIISAppConfig
class ATL_NO_VTABLE CIISAppConfig : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIISAppConfig, &CLSID_IISAppConfig>,
	public IDispatchImpl<IIISAppConfig, &IID_IIISAppConfig, &LIBID_APPCONFIGLib>
{
public:
	CIISAppConfig()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_IISAPPCONFIG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIISAppConfig)
	COM_INTERFACE_ENTRY(IIISAppConfig)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIISAppConfig
public:
	STDMETHOD(put_UserPassword)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_UserName)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_ComputerName)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_MetaPath)(/*[in]*/ BSTR newVal);
	STDMETHOD(Run)();

   CComBSTR m_ComputerName;
   CComBSTR m_UserName;
   CComBSTR m_UserPassword;
   CComBSTR m_MetaPath;
   BOOL m_ShowProcessPage;
};

#endif //__IISAPPCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\iisappconfig.cpp ===
// IISAppConfig.cpp : Implementation of CIISAppConfig
#include "stdafx.h"
#include "AppConfig.h"
#include "IISAppConfig.h"
#include "PropSheet.h"
#include "MappingPage.h"
#include "CacheOpt.h"
#include "ProcessOpt.h"
#include "AspMain.h"
#include "AspDebug.h"

/////////////////////////////////////////////////////////////////////////////
// CIISAppConfig

STDMETHODIMP CIISAppConfig::Run()
{
   CAppPropSheet ps;
   CAppData data;
   HRESULT hr;

   data.m_ServerName = (LPCTSTR)m_ComputerName;
   data.m_UserName = (LPCTSTR)m_UserName;
   data.m_UserPassword = (LPCTSTR)m_UserPassword;
   data.m_MetaPath = (LPCTSTR)m_MetaPath;

   if (SUCCEEDED(hr = data.Load()))
   {
      CAppMappingPage map_page(&data);
      CAspMainPage asp_main(&data);
      CAspDebugPage asp_debug(&data);
      CCacheOptPage cache_page(&data);
      CProcessOptPage proc_page(&data);

      ps.AddPage(map_page);
      ps.AddPage(asp_main);
      ps.AddPage(asp_debug);
      if (  CMetabasePath::IsMasterInstance(data.m_MetaPath) 
         || data.m_AppIsolated == eAppRunOutProcIsolated)
      {
         ps.AddPage(cache_page);
         ps.AddPage(proc_page);
      }

      if (IDOK == ps.DoModal())
      {
         hr = data.Save();
      }
   }
	return hr;
}

STDMETHODIMP CIISAppConfig::put_ComputerName(BSTR newVal)
{
	m_ComputerName = newVal;
	return S_OK;
}

STDMETHODIMP CIISAppConfig::put_UserName(BSTR newVal)
{
   m_UserName = newVal;
	return S_OK;
}

STDMETHODIMP CIISAppConfig::put_UserPassword(BSTR newVal)
{
   m_UserPassword = newVal;
	return S_OK;
}

STDMETHODIMP CIISAppConfig::put_MetaPath(BSTR newVal)
{
   m_MetaPath = newVal;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\processopt.h ===
//
//
//
#ifndef _PROCESS_OPT_H
#define _PROCESS_OPT_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"

#define TIMEOUT_MIN     (int)0
#define TIMEOUT_MAX     (int)(INT_MAX/1000)
#define TIMESPAN_MIN    (int)0
#define TIMESPAN_MAX    (int)(INT_MAX/1000)
#define REQUESTS_MIN    (int)0
#define REQUESTS_MAX    (int)(INT_MAX/1000)

class CProcessOptPage : 
   public WTL::CPropertyPageImpl<CProcessOptPage>,
   public WTL::CWinDataExchange<CProcessOptPage>
{
   typedef WTL::CPropertyPageImpl<CProcessOptPage> baseClass;

public:
   CProcessOptPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CProcessOptPage()
   {
   }

   enum {IDD = IDD_PROCESS_OPT};

BEGIN_MSG_MAP_EX(CProcessOptPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   MSG_WM_COMPAREITEM(OnCompareItem)
   MSG_WM_DRAWITEM(OnDrawItem)
   MSG_WM_MEASUREITEM(OnMeasureItem)
   COMMAND_HANDLER_EX(IDC_LOG_FAILS, BN_CLICKED, OnChangeData)
   COMMAND_HANDLER_EX(IDC_DEBUG_EXCEPTION, BN_CLICKED, OnChangeData)
   COMMAND_HANDLER_EX(IDC_RECYCLE_TIMESPAN, BN_CLICKED, OnRecycleTimespan)
   COMMAND_HANDLER_EX(IDC_RECYCLE_REQUESTS, BN_CLICKED, OnRecycleRequest)
   COMMAND_HANDLER_EX(IDC_RECYCLE_TIMER, BN_CLICKED, OnRecycleTimer)
   COMMAND_HANDLER_EX(IDC_ADD_TIME, BN_CLICKED, OnAddTimer)
   COMMAND_HANDLER_EX(IDC_CHANGE_TIME, BN_CLICKED, OnChangeTimer)
   COMMAND_HANDLER_EX(IDC_DELETE_TIME, BN_CLICKED, OnDeleteTimer)
   COMMAND_HANDLER_EX(IDC_TIMES_LIST, LBN_SELCHANGE, OnTimeSelChanged);
   COMMAND_HANDLER_EX(IDC_TIMES_LIST, LBN_DBLCLK, OnChangeTimer);
   COMMAND_HANDLER_EX(IDC_CGI_TIMEOUT, EN_CHANGE, OnChangeData);
   COMMAND_HANDLER_EX(IDC_TIMESPAN, EN_CHANGE, OnChangeData);
   COMMAND_HANDLER_EX(IDC_REQUEST_LIMIT, EN_CHANGE, OnChangeData);
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CProcessOptPage)
   DDX_CHECK(IDC_LOG_FAILS, m_pData->m_LogFailures)
   DDX_CHECK(IDC_DEBUG_EXCEPTION, m_pData->m_DebugExcept)
   DDX_INT_RANGE(IDC_CGI_TIMEOUT, m_pData->m_CgiTimeout, TIMEOUT_MIN, TIMEOUT_MAX)
   DDX_CHECK(IDC_RECYCLE_TIMESPAN, m_pData->m_RecycleTimespan)
   DDX_INT_RANGE(IDC_TIMESPAN, m_pData->m_Timespan, TIMESPAN_MIN, TIMESPAN_MAX)
   DDX_CHECK(IDC_RECYCLE_REQUESTS, m_pData->m_RecycleRequest)
   DDX_INT_RANGE(IDC_REQUEST_LIMIT, m_pData->m_Requests, REQUESTS_MIN, REQUESTS_MAX)
   DDX_CHECK(IDC_RECYCLE_TIMER, m_pData->m_RecycleTimer)

   DDX_CONTROL(IDC_TIMESPAN, m_TimespanCtrl)
   DDX_CONTROL(IDC_REQUEST_LIMIT, m_RequestCtrl)
   DDX_CONTROL(IDC_TIMEOUT_SPIN, m_TimeoutSpin)
   DDX_CONTROL(IDC_TIMESPAN_SPIN, m_TimespanSpin)
   DDX_CONTROL(IDC_REQUESTS_SPIN, m_RequestSpin)
   DDX_CONTROL(IDC_TIMES_LIST, m_TimerList)
   DDX_CONTROL(IDC_ADD_TIME, m_AddTimer)
   DDX_CONTROL(IDC_CHANGE_TIME, m_ChangeTimer)
   DDX_CONTROL(IDC_DELETE_TIME, m_DeleteTimer)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   LRESULT OnCompareItem(UINT nID, LPCOMPAREITEMSTRUCT cmpi);
   LRESULT OnDrawItem(UINT nID, LPDRAWITEMSTRUCT di);
   LRESULT OnMeasureItem(UINT nID, LPMEASUREITEMSTRUCT mi);
   void OnRecycleTimespan(UINT nCode, UINT nID, HWND hWnd);
   void OnRecycleRequest(UINT nSBCode, UINT nPos, HWND hwnd);
   void OnRecycleTimer(UINT nSBCode, UINT nPos, HWND hwnd);
   void OnAddTimer(UINT nSBCode, UINT nPos, HWND hwnd);
   void OnChangeTimer(UINT nSBCode, UINT nPos, HWND hwnd);
   void OnDeleteTimer(UINT nSBCode, UINT nPos, HWND hwnd);
   void OnTimeSelChanged(UINT nSBCode, UINT nPos, HWND hwnd);
   void OnChangeData(UINT nCode, UINT nID, HWND hWnd)
   {
      SET_MODIFIED(TRUE);
   }
   BOOL OnKillActive();

protected:
   CAppData * m_pData;
   CEditExch m_TimespanCtrl, m_RequestCtrl;
   CListBoxExch m_TimerList;
   CButtonExch m_AddTimer;
   CButtonExch m_ChangeTimer;
   CButtonExch m_DeleteTimer;
   CUpDownCtrlExch m_TimeoutSpin;
   CUpDownCtrlExch m_TimespanSpin;
   CUpDownCtrlExch m_RequestSpin;
};

#endif //_PROCESS_OPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\processopt.cpp ===
//
//
//
#include "stdafx.h"
#include "ProcessOpt.h"

class CTimePickerDlg : 
   public CDialogImpl<CTimePickerDlg>,
   public WTL::CWinDataExchange<CTimePickerDlg>
{
public:
   CTimePickerDlg()
   {
      m_TopLeft.x = m_TopLeft.y = 0;
      ZeroMemory(&m_tm, sizeof(SYSTEMTIME));
   }
   ~CTimePickerDlg()
   {
   }

   enum {IDD = IDD_TIME_PICKER};

BEGIN_MSG_MAP_EX(CTimePickerDlg)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDOK, BN_CLICKED, OnButton)
   COMMAND_HANDLER_EX(IDCANCEL, BN_CLICKED, OnButton)
END_MSG_MAP()

BEGIN_DDX_MAP(CTimePickerDlg)
   DDX_CONTROL(IDC_TIME_PICKER, m_Timer)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnButton(UINT nCode, UINT nID, HWND hWnd);

   CTimePickerExch m_Timer;
   SYSTEMTIME m_tm;
   POINT m_TopLeft;
};

LRESULT
CTimePickerDlg::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   DoDataExchange();

   m_Timer.SetFormat(_T("HH:mm"));
   m_Timer.SetSystemTime(GDT_VALID, &m_tm);
   ::SetWindowPos(m_hWnd, NULL, 
      m_TopLeft.x, m_TopLeft.y, 0, 0, 
      SWP_NOSIZE | SWP_NOZORDER);

   return FALSE;
}

void
CTimePickerDlg::OnButton(UINT nCode, UINT nID, HWND hWnd)
{
   if (nID == IDOK)
      m_Timer.GetSystemTime(&m_tm);
   EndDialog(nID);
}

LRESULT
CProcessOptPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   DoDataExchange();

   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   m_TimeoutSpin.SetRange32(TIMEOUT_MIN, TIMEOUT_MAX);
   m_TimeoutSpin.SetPos32(m_pData->m_CgiTimeout);
   m_TimeoutSpin.SetAccel(3, toAcc);

   m_TimespanSpin.SetRange32(TIMESPAN_MIN, TIMESPAN_MAX);
   m_TimespanSpin.SetPos32(m_pData->m_Timespan);
   m_TimespanSpin.SetAccel(3, toAcc);

   m_RequestSpin.SetRange32(REQUESTS_MIN, REQUESTS_MAX);
   m_RequestSpin.SetPos32(m_pData->m_Requests);
   m_RequestSpin.SetAccel(3, toAcc);

   m_TimespanCtrl.EnableWindow(m_pData->m_RecycleTimespan);
   m_TimespanSpin.EnableWindow(m_pData->m_RecycleTimespan);
   m_RequestCtrl.EnableWindow(m_pData->m_RecycleRequest);
   m_RequestSpin.EnableWindow(m_pData->m_RecycleRequest);
   m_TimerList.EnableWindow(m_pData->m_RecycleTimer);
   m_AddTimer.EnableWindow(m_pData->m_RecycleTimer);

   int count = m_pData->m_Timers.size();
   if (count > 0)
   {
      CStringListEx::iterator it;
      int idx;
      for (idx = 0, it = m_pData->m_Timers.begin(); it != m_pData->m_Timers.end(); it++, idx++)
      {
         int pos = (*it).find(_T(':'));
         int len = (*it).GetLength();
         WORD h = (WORD)StrToInt((*it).Left(pos));
         WORD m = (WORD)StrToInt((*it).Right(len - pos - 1));
         m_TimerList.AddString((LPCTSTR)UIntToPtr(MAKELONG(m, h)));
      }
      m_TimerList.SetCurSel(0);
   }
   m_ChangeTimer.EnableWindow(count > 0);
   m_DeleteTimer.EnableWindow(count > 0);

   DoDataExchange(TRUE);

   return FALSE;
}

LRESULT
CProcessOptPage::OnCompareItem(UINT nID, LPCOMPAREITEMSTRUCT cmpi)
{
   if (nID == IDC_TIMES_LIST)
   {
      ASSERT(cmpi->CtlType == ODT_LISTBOX);
      if (cmpi->itemData1 > cmpi->itemData2)
         return 1;
      else if (cmpi->itemData1 == cmpi->itemData2)
         return 0;
      else
         return -1;
   }
   ASSERT(FALSE);
   return 0;
}

LRESULT
CProcessOptPage::OnMeasureItem(UINT nID, LPMEASUREITEMSTRUCT mi)
{
   if (nID == IDC_TIMES_LIST)
   {
      HWND hwnd = GetDlgItem(IDC_TIMES_LIST);
      HDC hdc = ::GetDC(hwnd);
      HFONT hFont = (HFONT)SendDlgItemMessage(IDC_TIMES_LIST, WM_GETFONT, 0, 0);
      HFONT hf = (HFONT)::SelectObject(hdc, hFont);
      TEXTMETRIC tm;
      ::GetTextMetrics(hdc, &tm);
      ::SelectObject(hdc, hf);
      ::ReleaseDC(hwnd, hdc);
      RECT rc;
      ::GetClientRect(hwnd, &rc);
      mi->itemHeight = tm.tmHeight;
      mi->itemWidth = rc.right - rc.left;
   }
   return TRUE;
}

LRESULT
CProcessOptPage::OnDrawItem(UINT nID, LPDRAWITEMSTRUCT di)
{
   if (nID == IDC_TIMES_LIST && di->itemID != -1)
   {
      SYSTEMTIME tm;
      ::GetSystemTime(&tm);
      tm.wMinute = LOWORD(di->itemData);
      tm.wHour = HIWORD(di->itemData);
      TCHAR buf[32];
      TCHAR fmt[] = _T("HH:mm");
      ::GetTimeFormat(NULL /*LOCALE_SYSTEM_DEFAULT*/, TIME_NOSECONDS, &tm, fmt, buf, 32);

      HBRUSH hBrush;
	   COLORREF prevText;
	   COLORREF prevBk;
      switch (di->itemAction) 
      { 
      case ODA_SELECT: 
      case ODA_DRAWENTIRE: 
         if (di->itemState & ODS_SELECTED) 
         {
            hBrush = ::CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
            prevText = ::SetTextColor(di->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            prevBk = ::SetBkColor(di->hDC, GetSysColor(COLOR_HIGHLIGHT));
         }
         else
         {
            hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
            prevText = ::SetTextColor(di->hDC, GetSysColor(COLOR_WINDOWTEXT));
            prevBk = ::SetBkColor(di->hDC, GetSysColor(COLOR_WINDOW));
         }
         ::FillRect(di->hDC, &di->rcItem, hBrush);
         ::DrawText(di->hDC, buf, -1, &di->rcItem, DT_LEFT | DT_VCENTER | DT_EXTERNALLEADING);
         ::SetTextColor(di->hDC, prevText);
         ::SetTextColor(di->hDC, prevBk);
         ::DeleteObject(hBrush);
         break; 
       
      case ODA_FOCUS: 
         break; 
      } 
   }
   return TRUE;
}

void
CProcessOptPage::OnRecycleTimespan(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE, IDC_RECYCLE_TIMESPAN);
   m_TimespanCtrl.EnableWindow(m_pData->m_RecycleTimespan);
   m_TimespanSpin.EnableWindow(m_pData->m_RecycleTimespan);
   SET_MODIFIED(TRUE);
}

void
CProcessOptPage::OnRecycleRequest(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE, IDC_RECYCLE_REQUESTS);
   m_RequestCtrl.EnableWindow(m_pData->m_RecycleRequest);
   m_RequestSpin.EnableWindow(m_pData->m_RecycleRequest);
   SET_MODIFIED(TRUE);
}

void
CProcessOptPage::OnRecycleTimer(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE, IDC_RECYCLE_TIMER);
   m_TimerList.EnableWindow(m_pData->m_RecycleTimer);
   m_AddTimer.EnableWindow(m_pData->m_RecycleTimer);
   SET_MODIFIED(TRUE);
}

void
CProcessOptPage::OnTimeSelChanged(UINT nCode, UINT nID, HWND hWnd)
{
   int idx = m_TimerList.GetCurSel();
   m_ChangeTimer.EnableWindow(idx != LB_ERR);
   m_DeleteTimer.EnableWindow(idx != LB_ERR);
}

void
CProcessOptPage::OnAddTimer(UINT nCode, UINT nID, HWND hWnd)
{
   CTimePickerDlg dlg;
   RECT rc;
   m_AddTimer.GetWindowRect(&rc);
   dlg.m_TopLeft.x = rc.left;
   dlg.m_TopLeft.y = rc.bottom;
   if (dlg.DoModal(m_hWnd) == IDOK)
   {
      int idx;
      LONG_PTR l = (LONG_PTR)MAKELONG(dlg.m_tm.wMinute, dlg.m_tm.wHour);
      if ((idx = m_TimerList.FindString(-1, 
            (LPCTSTR)l)) == LB_ERR)
      {
         idx = m_TimerList.AddString((LPCTSTR)l);
         m_TimerList.SetCurSel(idx);
         m_ChangeTimer.EnableWindow(idx != LB_ERR);
         m_DeleteTimer.EnableWindow(idx != LB_ERR);
      }
      else
         m_TimerList.SetCurSel(idx);
      SET_MODIFIED(TRUE);
   }
}

void
CProcessOptPage::OnChangeTimer(UINT, UINT, HWND)
{
   CTimePickerDlg dlg;
   RECT rc;
   m_ChangeTimer.GetWindowRect(&rc);
   dlg.m_TopLeft.x = rc.left;
   dlg.m_TopLeft.y = rc.bottom;
   int idx = m_TimerList.GetCurSel();
   LONG l = (LONG)m_TimerList.GetItemData(idx);
   // Looks like we have to init the struct properly
   ::GetSystemTime(&dlg.m_tm);
   dlg.m_tm.wMinute = LOWORD(l);
   dlg.m_tm.wHour = HIWORD(l);
   dlg.m_tm.wSecond = 0;
   if (dlg.DoModal(m_hWnd) == IDOK)
   {
      RECT rc;
      m_TimerList.SetItemData(idx, 
         (DWORD_PTR)MAKELONG(dlg.m_tm.wMinute, dlg.m_tm.wHour));
      m_TimerList.GetItemRect(idx, &rc);
      ::InvalidateRect(GetDlgItem(IDC_TIMES_LIST), &rc, TRUE);
      SET_MODIFIED(TRUE);
   }
}

void
CProcessOptPage::OnDeleteTimer(UINT nCode, UINT nID, HWND hWnd)
{
   int idx = m_TimerList.GetCurSel();
   int count;
   if (idx != LB_ERR)
   {
      m_TimerList.DeleteString(idx);
      SET_MODIFIED(TRUE);
      if ((count = m_TimerList.GetCount()) == 0)
      {
         m_DeleteTimer.EnableWindow(FALSE);
         m_ChangeTimer.EnableWindow(FALSE);
      }
      else
      {
         m_TimerList.SetCurSel(idx == count ? --idx : idx);
      }
   }
}

BOOL
CProcessOptPage::OnKillActive()
{
   BOOL bRes = FALSE;
   do
   {
      DoDataExchange(TRUE, IDC_LOG_FAILS);
      DoDataExchange(TRUE, IDC_DEBUG_EXCEPTION);
      DoDataExchange(TRUE, IDC_CGI_TIMEOUT);
      DoDataExchange(TRUE, IDC_RECYCLE_TIMESPAN);
      if (m_pData->m_RecycleTimespan && !DoDataExchange(TRUE, IDC_TIMESPAN))
      {
         break;
      }
      DoDataExchange(TRUE, IDC_RECYCLE_REQUESTS);
      if (m_pData->m_RecycleRequest && !DoDataExchange(TRUE, IDC_REQUEST_LIMIT))
      {
         break;
      }
      int count = m_TimerList.GetCount();
      TCHAR buf[32];
      SYSTEMTIME tm;
      ::GetSystemTime(&tm);
      m_pData->m_Timers.Clear();
      for (int i = 0; i < count; i++)
      {
         DWORD data = (DWORD)m_TimerList.GetItemData(i);
         tm.wMinute = LOWORD(data);
         tm.wHour = HIWORD(data);
         ::GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
            TIME_NOSECONDS | TIME_FORCE24HOURFORMAT,
            &tm, _T("hh':'mm"), buf, 32);
         m_pData->m_Timers.PushBack(buf);
      }
      bRes = TRUE;
   } while (FALSE);
   return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\mappingpage.h ===
//
//
//
#ifndef _MAPPING_PAGE_H
#define _MAPPING_PAGE_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"

class CAppMappingPage : 
   public WTL::CPropertyPageImpl<CAppMappingPage>,
   public WTL::CWinDataExchange<CAppMappingPage>
{
   typedef WTL::CPropertyPageImpl<CAppMappingPage> baseClass;

public:
   CAppMappingPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CAppMappingPage()
   {
   }

   enum {IDD = IDD_APPMAP};

BEGIN_MSG_MAP_EX(CAppMappingPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_ADD, BN_CLICKED, OnAdd)
   COMMAND_HANDLER_EX(IDC_EDIT, BN_CLICKED, OnEdit)
   COMMAND_HANDLER_EX(IDC_REMOVE, BN_CLICKED, OnRemove)
   COMMAND_HANDLER_EX(IDC_CACHE_ISAPI, BN_CLICKED, OnCacheISAPI)
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CAppMappingPage)
   DDX_CHECK(IDC_CACHE_ISAPI, m_pData->m_CacheISAPI)
   DDX_CONTROL(IDC_LIST, m_list)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnAdd(UINT nCode, UINT nID, HWND hWnd);
   void OnEdit(UINT nCode, UINT nID, HWND hWnd);
   void OnRemove(UINT nCode, UINT nID, HWND hWnd);
   void OnCacheISAPI(UINT nCode, UINT nID, HWND hWnd);
   BOOL OnKillActive();

protected:
   CAppData * m_pData;
   CListViewExch m_list;
};

class CEditMap : 
   public CDialogImpl<CEditMap>,
   public WTL::CWinDataExchange<CEditMap>
{
public:
   CEditMap() :
      m_script_engine(FALSE),
      m_file_exists(FALSE),
      m_verbs_index(0),
      m_new(FALSE)
   {
      m_exec[0] = 0;
      m_ext[0] = 0;
      m_verbs[0] = 0;
   }
   ~CEditMap()
   {
   }

   enum {IDD = IDD_EDITMAP};

protected:

BEGIN_MSG_MAP_EX(CEditMap)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_HELPBTN, BN_CLICKED, OnHelp)
   COMMAND_HANDLER_EX(IDOK, BN_CLICKED, OnOK)
   COMMAND_HANDLER_EX(IDCANCEL, BN_CLICKED, OnCancel)
   COMMAND_HANDLER_EX(IDC_ALL_VERBS, BN_CLICKED, OnVerbs)
   COMMAND_HANDLER_EX(IDC_LIMIT_VERBS, BN_CLICKED, OnVerbs)
   COMMAND_HANDLER_EX(IDC_EXTENSION, EN_CHANGE, OnExtChanged)
   COMMAND_HANDLER_EX(IDC_EXECUTABLE, EN_CHANGE, OnExecChanged)
   COMMAND_HANDLER_EX(IDC_VERBS, EN_CHANGE, OnVerbsChanged)
END_MSG_MAP()

BEGIN_DDX_MAP(CEditMap)
   DDX_TEXT(IDC_EXECUTABLE, m_exec)
   DDX_TEXT(IDC_EXTENSION, m_ext)
   DDX_TEXT(IDC_VERBS, m_verbs)
   DDX_RADIO(IDC_ALL_VERBS, m_verbs_index)
   DDX_CHECK(IDC_SCRIPT_ENGINE, m_script_engine)
   DDX_CHECK(IDC_FILE_EXISTS, m_file_exists)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnBrowse(UINT nCode, UINT nID, HWND hWnd);
   void OnHelp(UINT nCode, UINT nID, HWND hWnd);
   void OnOK(UINT nCode, UINT nID, HWND hWnd);
   void OnCancel(UINT nCode, UINT nID, HWND hWnd);
   void OnVerbs(UINT nCode, UINT nID, HWND hWnd);
   void OnExtChanged(UINT nCode, UINT nID, HWND hWnd);
   void OnExecChanged(UINT nCode, UINT nID, HWND hWnd);
   void OnVerbsChanged(UINT nCode, UINT nID, HWND hWnd);

public:
   TCHAR m_exec[MAX_PATH];
   TCHAR m_ext[MAX_PATH];
   CString m_prev_ext;
   TCHAR m_verbs[MAX_PATH];
   int m_verbs_index;
   BOOL m_script_engine, m_file_exists;
   BOOL m_new, m_bExtValid, m_bExecValid, m_bVerbsValid;
   DWORD m_flags;
   CFileChooser m_FileChooser;
   CAppData * m_pData;
};

#endif //_MAPPING_PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\amapctl.h ===
// AMapCtl.h : Declaration of the CAccountMapperCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CAccountMapperCtrl : See AMapCtl.cpp for implementation.

class CAccountMapperCtrl : public COleControl
{
    DECLARE_DYNCREATE(CAccountMapperCtrl)

// Constructor
public:
    CAccountMapperCtrl();

// Overrides

    // Drawing function
    virtual void OnDraw(
                CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);

    // Persistence
    virtual void DoPropExchange(CPropExchange* pPX);

    // Reset control state
    virtual void OnResetState();

// Implementation
protected:
    // run the mapping dialog - the whole purpose of this control!
    void    RunMappingDialog();

    ~CAccountMapperCtrl();

    DECLARE_OLECREATE_EX(CAccountMapperCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CAccountMapperCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CAccountMapperCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CAccountMapperCtrl)      // Type name and misc status

    // Subclassed control support
    BOOL PreCreateWindow(CREATESTRUCT& cs);
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
    //{{AFX_MSG(CAccountMapperCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CAccountMapperCtrl)
    afx_msg void ShowMappingDialog();
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CAccountMapperCtrl)
    void FireClick()
        {FireEvent(DISPID_CLICK,EVENT_PARAM(VTS_NONE));}
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CAccountMapperCtrl)
    dispidShowMappingDialog = 1L,
    //}}AFX_DISP_ID
    };

private:
    BOOL fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\propsheet.cpp ===
//
//
//
#include "stdafx.h"
#include "resource.h"
#include "PropSheet.h"
#include <common.h>

HRESULT
CMappings::Load(CMetaKey * pKey)
{
   CStringListEx listData;
   HRESULT hr = pKey->QueryValue(MD_SCRIPT_MAPS, listData);
   if (SUCCEEDED(hr))
   {
      CStringListEx::iterator i;
      CString buf;
      for (i = listData.begin(); i != listData.end(); i++)
      {
         buf = *i;
         Mapping map;
         int len = buf.GetLength();
         int pos = buf.find(_T(','));
         ASSERT(pos != CString::npos);
         map.ext = buf.Left(pos);

         int pos1 = buf.find(_T(','), ++pos);
         ASSERT(pos1 != CString::npos);
         map.path = buf.Mid(pos, pos1 - pos);

         pos = pos1;
         pos1 = buf.find(_T(','), ++pos);
         if (pos1 == CString::npos)
         {
            map.flags = StrToInt(buf.Right(len - pos));
            map.verbs.LoadString(_Module.GetResourceInstance(), IDS_ALL);
         }
         else
         {
            map.flags = StrToInt(buf.Mid(pos, pos1 - pos));
            map.verbs = buf.Right(len - pos1 - 1);
         }
         insert(begin(), value_type(map.ext, map));
      }
   }
   return hr;
}

HRESULT
CMappings::Save(CMetaKey * pKey)
{
   CStringListEx listData;
   CMappings::iterator i;
   Mapping map;
   TCHAR buf[MAX_PATH * 2];
   TCHAR num[12];
   for (i = begin(); i != end(); i++)
   {
      map = (*i).second;
      StrCpy(buf, map.ext);
      StrCat(buf, _T(","));
      StrCat(buf, map.path);
      StrCat(buf, _T(","));
      wsprintf(num, _T("%u"), map.flags);
      StrCat(buf, num);
      if (!map.verbs.IsEmpty())
      {
         StrCat(buf, _T(","));
         StrCat(buf, map.verbs);
      }
      listData.PushBack(buf);
      buf[0] = 0;
   }
   HRESULT hr;
   VERIFY(SUCCEEDED(hr = pKey->SetValue(MD_SCRIPT_MAPS, listData)));
   return hr;
}

HRESULT
CAppData::Load()
{
   ASSERT(!m_MetaPath.IsEmpty());
   CComAuthInfo auth(m_ServerName, m_UserName, m_UserPassword); 
   CMetaKey mk(&auth, m_MetaPath, METADATA_PERMISSION_READ);
   HRESULT hr = mk.QueryResult();
   if (FAILED(hr))
      return hr;
   do
   {
      CString buf;
      if (FAILED(hr = mk.QueryValue(MD_APP_ISOLATED, m_AppIsolated)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_ALLOWSESSIONSTATE, m_EnableSession)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_BUFFERINGON, m_EnableBuffering)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_ENABLEPARENTPATHS, m_EnableParents)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SESSIONTIMEOUT, m_SessionTimeout)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTTIMEOUT, m_ScriptTimeout)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTLANGUAGE, buf)))
         break;
      StrCpy(m_Languages, buf);
      //
      if (FAILED(hr = mk.QueryValue(MD_ASP_ENABLESERVERDEBUG, m_ServerDebug)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_ENABLECLIENTDEBUG, m_ClientDebug)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTERRORSSENTTOBROWSER, m_SendAspError)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTERRORMESSAGE, buf)))
         break;
      StrCpy(m_DefaultError, buf);
      //
      if (FAILED(hr = m_Mappings.Load(&mk)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_CACHE_EXTENSIONS, m_CacheISAPI)))
         break;
      //
      if (FAILED(hr = mk.QueryValue(MD_ASP_LOGERRORREQUESTS, m_LogFailures)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_EXCEPTIONCATCHENABLE, m_DebugExcept)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_SCRIPT_TIMEOUT, m_CgiTimeout)))
         break;
      //
      if (FAILED(hr = mk.QueryValue(MD_APP_PERIODIC_RESTART_TIME, m_Timespan)))
      {
         m_Timespan = 0;
         hr = S_OK;
//         break;
      }
      m_RecycleTimespan = (m_Timespan != 0);
      if (FAILED(hr = mk.QueryValue(MD_APP_PERIODIC_RESTART_REQUESTS, m_Requests)))
      {
         m_Requests = 0;
         hr = S_OK;
//         break;
      }
      m_RecycleRequest = (m_Requests != 0);
      if (FAILED(hr = mk.QueryValue(MD_APP_PERIODIC_RESTART_SCHEDULE, m_Timers)))
      {
         hr = S_OK;
//         break;
      }
      m_RecycleTimer = (m_Timers.size() != 0);
      //
      if (FAILED(hr = mk.QueryValue(MD_ASP_DISKTEMPLATECACHEDIRECTORY, buf)))
      {
         VERIFY(0 != ExpandEnvironmentStrings(
            _T("%windir%\\system32\\inetsrv\\ASP Compiled Templates"),
            m_DiskCacheDir, MAX_PATH));
         hr = S_OK;
      }
      else
         StrCpy(m_DiskCacheDir, buf);
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTENGINECACHEMAX, m_ScriptEngCacheMax)))
         break;
      m_NoCache = m_UnlimCache = m_LimCache = FALSE;
      if (FAILED(hr = mk.QueryValue(MD_ASP_MAXDISKTEMPLATECACHEFILES, m_TotalCacheSize)))
      {
         m_TotalCacheSize = -1;
         break;
      }
      if (m_TotalCacheSize == -1)
      {
         m_UnlimCache = TRUE;
         if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTFILECACHESIZE, m_UnlimCacheInMemorySize)))
         {
//            m_UnlimCacheInMemorySize = 250;
            break;
         }
         m_LimCacheInMemorySize = 250;
      }
      else if (m_TotalCacheSize == 0)
      {
         m_NoCache = TRUE;
         m_UnlimCacheInMemorySize = 250;
         m_LimCacheInMemorySize = 0;
      }
      else
      {
         m_LimCache = TRUE;
         if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTFILECACHESIZE, m_LimCacheInMemorySize)))
         {
//            m_LimCacheInMemorySize = 250;
            break;
         }
         m_UnlimCacheInMemorySize = 250;
      }
      //
      m_MetaPath = mk.QueryMetaPath();
   } while (FALSE);
   return hr;
}

HRESULT
CAppData::Save()
{
   ASSERT(!m_MetaPath.IsEmpty());
   CComAuthInfo auth(m_ServerName, m_UserName, m_UserPassword); 
   CMetaKey mk(&auth, m_MetaPath, METADATA_PERMISSION_WRITE);
   HRESULT hr = mk.QueryResult();
   if (FAILED(hr))
      return hr;
   do
   {
      CString buf;
      if (FAILED(hr = mk.SetValue(MD_ASP_ALLOWSESSIONSTATE, m_EnableSession)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_BUFFERINGON, m_EnableBuffering)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_ENABLEPARENTPATHS, m_EnableParents)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_SESSIONTIMEOUT, m_SessionTimeout)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTTIMEOUT, m_ScriptTimeout)))
         break;
      buf = m_Languages;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTLANGUAGE, buf)))
         break;
      //
      if (FAILED(hr = mk.SetValue(MD_ASP_ENABLESERVERDEBUG, m_ServerDebug)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_ENABLECLIENTDEBUG, m_ClientDebug)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTERRORSSENTTOBROWSER, m_SendAspError)))
         break;
      buf = m_DefaultError;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTERRORMESSAGE, buf)))
         break;
      //
      if (FAILED(hr = m_Mappings.Save(&mk)))
         break;
      if (FAILED(hr = mk.SetValue(MD_CACHE_EXTENSIONS, m_CacheISAPI)))
         break;
      //
      if (FAILED(hr = mk.SetValue(MD_ASP_LOGERRORREQUESTS, m_LogFailures)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_EXCEPTIONCATCHENABLE, m_DebugExcept)))
         break;
      if (FAILED(hr = mk.SetValue(MD_SCRIPT_TIMEOUT, m_CgiTimeout)))
         break;
      //
      if (m_RecycleTimespan && m_Timespan > 0)
      {
         if (FAILED(hr = mk.SetValue(MD_APP_PERIODIC_RESTART_TIME, m_Timespan)))
            break;
      }
      else
      {
         if (FAILED(hr = mk.SetValue(MD_APP_PERIODIC_RESTART_TIME, 0)))
            break;
      }
      if (m_RecycleRequest && m_Requests > 0)
      {
         if (FAILED(hr = mk.SetValue(MD_APP_PERIODIC_RESTART_REQUESTS, m_Requests)))
            break;
      }
      else
      {
         if (FAILED(hr = mk.SetValue(MD_APP_PERIODIC_RESTART_REQUESTS, 0)))
            break;
      }
      if (!m_RecycleTimer)
      {
         m_Timers.clear();
      }
      if (FAILED(hr = mk.SetValue(MD_APP_PERIODIC_RESTART_SCHEDULE, m_Timers)))
         break;
      //
      buf = m_DiskCacheDir;
      if (FAILED(hr = mk.SetValue(MD_ASP_DISKTEMPLATECACHEDIRECTORY, buf)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTENGINECACHEMAX, m_ScriptEngCacheMax)))
         break;
      int inmem = 0;
      if (m_NoCache)
      {
         m_TotalCacheSize = 0;
      }
      else if (m_UnlimCache)
      {
         m_TotalCacheSize = -1;
         inmem = m_UnlimCacheInMemorySize;
      }
      else
      {
         inmem = m_LimCacheInMemorySize;
      }
      if (FAILED(hr = mk.SetValue(MD_ASP_MAXDISKTEMPLATECACHEFILES, m_TotalCacheSize)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTFILECACHESIZE, inmem)))
         break;
   } while (FALSE);
   return hr;
}

BOOL
CAppData::IsMasterInstance()
{
   return CMetabasePath::IsMasterInstance(m_MetaPath);
}

CAppPropSheet::CAppPropSheet()
{
   static TCHAR title[256];

   ::LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE, title, 256);
   m_psh.pszCaption = title;

}

LRESULT
CAppPropSheet::OnInitDialog(HWND hDlg, LPARAM)
{
   return 0;
}

void
CAppPropSheet::OnKeyDown(UINT nChar, UINT nRepCount, UINT nFlags)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\mappingpage.cpp ===
//
//
//
#include "stdafx.h"
#include "MappingPage.h"

enum 
{
   COL_EXTENSION = 0,
   COL_PATH,
   COL_EXCLUSIONS
};

#define EXT_WIDTH          58
#define PATH_WIDTH         204
#define EXCLUSIONS_WIDTH   72

LRESULT
CAppMappingPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   CString str;
   CError err;

   DoDataExchange();

	DWORD dwStyle = m_list.GetExtendedListViewStyle();
	m_list.SetExtendedListViewStyle(
      dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP);

   str.LoadString(_Module.GetResourceInstance(), IDS_EXTENSION);
   m_list.InsertColumn(COL_EXTENSION, str, LVCFMT_LEFT, EXT_WIDTH, 0);
   str.LoadString(_Module.GetResourceInstance(), IDS_EXECUTABLE_PATH);
   m_list.InsertColumn(COL_PATH, str, LVCFMT_LEFT, PATH_WIDTH, 1);
   str.LoadString(_Module.GetResourceInstance(), IDS_VERBS);
   m_list.InsertColumn(COL_EXCLUSIONS, str, LVCFMT_LEFT, EXCLUSIONS_WIDTH, 2);

   ASSERT(m_pData != NULL);
   CMappings::iterator it;
   int idx = 0;
   CString all_verbs;
   VERIFY(all_verbs.LoadString(_Module.GetResourceInstance(), IDS_ALL));
   for (it = m_pData->m_Mappings.begin(); it != m_pData->m_Mappings.end(); it++, idx++)
   {
      Mapping map = (*it).second;
      VERIFY(-1 != m_list.InsertItem(idx, map.ext));
      VERIFY(m_list.SetItemText(idx, COL_PATH, map.path));
      VERIFY(m_list.SetItemData(idx, map.flags));
      VERIFY(m_list.SetItemText(idx, COL_EXCLUSIONS, 
         map.verbs.IsEmpty() ? all_verbs : map.verbs));
   }

   CString remainder;
   CMetabasePath::GetRootPath(m_pData->m_MetaPath, str, &remainder);
   ::EnableWindow(GetDlgItem(IDC_CACHE_ISAPI), remainder.IsEmpty());

   int count = m_list.GetItemCount();
   if (count > 0)
   {
      m_list.SelectItem(0);
   }
   ::EnableWindow(GetDlgItem(IDC_EDIT), count > 0);
   ::EnableWindow(GetDlgItem(IDC_REMOVE), count > 0);

   return 0;
}

void 
CAppMappingPage::OnAdd(UINT nCode, UINT nID, HWND hWnd)
{
   CEditMap dlg;
   dlg.m_new = TRUE;
   dlg.m_flags = MD_SCRIPTMAPFLAG_SCRIPT;
   dlg.m_pData = m_pData;
   if (dlg.DoModal() == IDOK)
   {
      CString all_verbs;
      VERIFY(all_verbs.LoadString(_Module.GetResourceInstance(), IDS_ALL));
      
      Mapping map;
      map.ext = dlg.m_ext;
      map.path = dlg.m_exec;
      map.verbs = dlg.m_verbs;
      map.flags = dlg.m_flags;
      m_pData->m_Mappings.insert(CMappings::value_type(map.ext, map));

      int count = m_list.GetItemCount();
      VERIFY(-1 != m_list.InsertItem(count, map.ext));
      VERIFY(m_list.SetItemText(count, COL_PATH, dlg.m_exec));
      VERIFY(m_list.SetItemData(count, dlg.m_flags));
      VERIFY(m_list.SetItemText(count, COL_EXCLUSIONS, 
         dlg.m_verbs[0] == 0 ? all_verbs : dlg.m_verbs));
      SET_MODIFIED(TRUE);
   }
}

void 
CAppMappingPage::OnEdit(UINT nCode, UINT nID, HWND hWnd)
{
   CEditMap dlg;
   dlg.m_new = FALSE;
   dlg.m_pData = m_pData;
   
   int idx = m_list.GetSelectedIndex();
   TCHAR buf[MAX_PATH];
   VERIFY(0 != m_list.GetItemText(idx, 0, buf, MAX_PATH));
   CMappings::iterator it = m_pData->m_Mappings.find(buf);
   ASSERT(it != m_pData->m_Mappings.end());
   StrCpy(dlg.m_ext, buf);
   StrCpy(dlg.m_exec, (*it).second.path);
   StrCpy(dlg.m_verbs, (*it).second.verbs);
   dlg.m_flags = (*it).second.flags;

   if (dlg.DoModal() == IDOK)
   {
      CString all_verbs;
      VERIFY(all_verbs.LoadString(_Module.GetResourceInstance(), IDS_ALL));
      (*it).second.path = dlg.m_exec;
      (*it).second.verbs = dlg.m_verbs;
      (*it).second.flags = dlg.m_flags;
      VERIFY(m_list.SetItemText(idx, COL_PATH, dlg.m_exec));
      VERIFY(m_list.SetItemData(idx, dlg.m_flags));
      VERIFY(m_list.SetItemText(idx, COL_EXCLUSIONS, 
         dlg.m_verbs[0] == 0 ? all_verbs : dlg.m_verbs));
      SET_MODIFIED(TRUE);
   }
}

void 
CAppMappingPage::OnRemove(UINT nCode, UINT nID, HWND hWnd)
{
   CString msg;
   msg.LoadString(_Module.GetResourceInstance(), IDS_CONFIRM_REMOVE_MAP);
   if (MessageBox(msg, NULL, MB_YESNO) == IDYES)
   {
      int i = m_list.GetSelectedIndex();
      int count;
      m_list.DeleteItem(i);
      SET_MODIFIED(TRUE);
      if ((count = m_list.GetItemCount()) > 0)
      {
         if (i >= count)
            i = count - 1;
         m_list.SelectItem(i);
      }
      else
      {
         ::EnableWindow(GetDlgItem(IDC_REMOVE), FALSE);
         ::EnableWindow(GetDlgItem(IDC_EDIT), FALSE);
      }
   }
}

void 
CAppMappingPage::OnCacheISAPI(UINT nCode, UINT nID, HWND hWnd)
{
   SET_MODIFIED(TRUE);
}

BOOL
CAppMappingPage::OnKillActive()
{
   DoDataExchange(TRUE);
   return TRUE;
}

//---------------- CEditMap dialog --------------------------

#define CHECK_VERBS()\
   m_bVerbsValid = \
      (m_verbs_index > 0 && lstrlen(m_verbs) != 0) || (m_verbs_index == 0)
#define CHECK_EXT()\
   m_bExtValid = (lstrlen(m_ext) != 0 && StrCmp(m_ext, _T(".")) != 0)
#define CHECK_EXEC(buf)\
   m_bExecValid = (lstrlen((buf)) != 0 && !PathIsUNC((buf)))
#define ENABLE_OK()\
   ::EnableWindow(GetDlgItem(IDOK), m_bExtValid && m_bExecValid && m_bVerbsValid)

LRESULT
CEditMap::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   DoDataExchange();

   m_prev_ext = m_ext;

   DWORD style = FC_DEFAULT_READ | FC_COMMANDLINE;
   
   if (!::IsServerLocal(m_pData->m_ServerName))
   {
      style &= ~(FC_AUTOCOMPLETION | FC_PATH_CHECK);
      ::EnableWindow(GetDlgItem(IDC_BROWSE), FALSE);
   }

   m_FileChooser.Init(this, style, IDC_EXECUTABLE, IDC_BROWSE);
   m_FileChooser.AddExtension(_Module.GetResourceInstance(),
      IDS_EXECUTABLE_FILES, IDS_EXECUTABLE_EXT);
   m_FileChooser.AddExtension(_Module.GetResourceInstance(),
      IDS_DLL_FILES, IDS_DLL_EXT);
   m_FileChooser.AddExtension(_Module.GetResourceInstance(),
      IDS_ALL_FILES, IDS_ALL_EXT);
   m_FileChooser.SetPath(m_exec);

   m_verbs_index = lstrlen(m_verbs) == 0 ? 0 : 1;
   ::EnableWindow(GetDlgItem(IDC_VERBS), m_verbs_index > 0);

   m_script_engine = ((m_flags & MD_SCRIPTMAPFLAG_SCRIPT) != 0);
   m_file_exists = ((m_flags & MD_SCRIPTMAPFLAG_CHECK_PATH_INFO) != 0);
   ::EnableWindow(GetDlgItem(IDC_EXTENSION), m_new);

   CHECK_EXT();
   CHECK_EXEC(m_exec);
   CHECK_VERBS();
//   ATLTRACE(_T("Enable OK OnInitDialog %s\n"),
//      m_bExtValid && m_bExecValid && m_bVerbsValid ?
//      _T("TRUE") : _T("FALSE"));
   ENABLE_OK();

   DoDataExchange();

   return FALSE;
}

void
CEditMap::OnVerbs(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE);
   ::EnableWindow(GetDlgItem(IDC_VERBS), m_verbs_index > 0);
   CHECK_VERBS();
//   ATLTRACE(_T("Enable OK OnVerbs %s\n"),
//      m_bExtValid && m_bExecValid && m_bVerbsValid ?
//      _T("TRUE") : _T("FALSE"));
   ENABLE_OK();
}

void
CEditMap::OnVerbsChanged(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE, IDC_VERBS);
   CHECK_VERBS();
//   ATLTRACE(_T("Enable OK OnVerbsChanged %s\n"),
//      m_bExtValid && m_bExecValid && m_bVerbsValid ?
//      _T("TRUE") : _T("FALSE"));
   ENABLE_OK();
}

void
CEditMap::OnHelp(UINT nCode, UINT nID, HWND hWnd)
{
}

#define BAIL_WITH_MESSAGE(msg, focus)\
   idmsg = msg;\
   idfocus = focus;\
   break

void
CEditMap::OnOK(UINT nCode, UINT nID, HWND hWnd)
{
   UINT idmsg = 0, idfocus = 0;
   DoDataExchange(TRUE);

   // When All is selected, verbs string is empty
   do
   {
      if (m_verbs_index == 0)
      {
         m_verbs[0] = 0;
      }
      else if (m_verbs[0] == 0)
      {
         BAIL_WITH_MESSAGE(IDS_ERR_NOVERBS, IDC_VERBS);
      }

      CString ext = m_ext;
      if (ext.ReverseFind(_T('.')) > 0)
      {
         BAIL_WITH_MESSAGE(IDS_ERR_BADEXT, IDC_EXTENSION);
      }
      if (ext.GetAt(0) == _T('*'))
         ext.erase(1);
      else if (ext.Compare(_T(".*")) == 0)
         ext = _T("*");
      else if (ext.GetAt(0) != _T('.'))
         ext = _T('.') + ext;

      // Ext should be unique, if new or changed
      if (  (m_new || m_prev_ext.CompareNoCase(ext) != 0)
         && m_pData->m_Mappings.find(ext) != m_pData->m_Mappings.end()
         )
      {
         BAIL_WITH_MESSAGE(IDS_ERR_USEDEXT, IDC_EXTENSION);
      }
      StrCpy(m_ext, ext);

      CString buf;
      if (FC_SUCCESS != m_FileChooser.GetFileName(buf))
      {
         BAIL_WITH_MESSAGE(IDS_ERR_BADEXECFORMAT, IDC_EXECUTABLE);
      }

      int pos;
      CString path;
      if (buf[0] == _T('\"'))
      {
         if ((pos = buf.find_last_of(_T('\"'))) != CString::npos)
         {
            path = buf.substr(1, --pos);
         }
         else
         {
            BAIL_WITH_MESSAGE(IDS_ERR_BADEXECFORMAT, IDC_EXECUTABLE);
         }
      }
      else if (CString::npos != (pos = buf.find(_T(' '))))
      {
         // in case there are parameters after the file name, just take it to the first space
         path = buf.substr(0, --pos);
      }
      if (PathIsUNC(path))
      {
         BAIL_WITH_MESSAGE(IDS_ERR_NOUNC, IDC_EXECUTABLE);
      }
      // perform extra local-machine tests
      if (::IsServerLocal(m_pData->m_ServerName))
      {
         // if local, the drive can't be redirected
         // test the drive and only accept valid, non-remote drives
         if (PathIsNetworkPath(path))
         {
            BAIL_WITH_MESSAGE(IDS_ERR_NOREMOTE, IDC_EXECUTABLE);
         }
         // check that the file exists
         if (PathIsDirectory(path))
         {
            BAIL_WITH_MESSAGE(IDS_ERR_FILENOTEXISTS, IDC_EXECUTABLE);
         }
      }
      m_flags = 0;
      if (m_script_engine)
         m_flags |= MD_SCRIPTMAPFLAG_SCRIPT;
      if (m_file_exists)
         m_flags |= MD_SCRIPTMAPFLAG_CHECK_PATH_INFO;
      StrCpy(m_exec, buf);
   }
   while (FALSE);

   if (idmsg != 0)
   {
      CString msg;
      CString cap;
      msg.LoadString(_Module.GetResourceInstance(), idmsg);
      cap.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
      MessageBox(msg, cap);
      ::SetFocus(GetDlgItem(idfocus));
      SendDlgItemMessage(idfocus, EM_SETSEL, 0, -1);
      return;
   }
   EndDialog(nID);
}

void
CEditMap::OnCancel(UINT nCode, UINT nID, HWND hWnd)
{
   EndDialog(nID);
}

void
CEditMap::OnExtChanged(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE, IDC_EXTENSION);
   CHECK_EXT();
//   ATLTRACE(_T("Enable OK OnExtChanged %s\n"),
//      m_bExtValid && m_bExecValid && m_bVerbsValid ?
//      _T("TRUE") : _T("FALSE"));
   ENABLE_OK();
}

void
CEditMap::OnExecChanged(UINT nCode, UINT nID, HWND hWnd)
{
//   HWND hwnd = GetDlgItem(IDC_EXECUTABLE);
   CString str;
//   if (::GetFocus() == hwnd)
//   {
//      DoDataExchange(TRUE, IDC_EXECUTABLE);
//      str = m_exec;
//   }
//   else
//   {
      m_FileChooser.GetFileName(str);
      // BUGBUG: clean it up
      TCHAR buff[MAX_PATH];
      StrCpyN(buff, str, str.GetLength());
      PathRemoveArgs(buff);
//   }
   CHECK_EXEC(buff);
   ENABLE_OK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\propsheet.h ===
//
//
//
#ifndef _PROP_SHEET_H
#define _PROP_SHEET_H

#ifndef MD_APP_PERIODIC_RESTART_TIME
#define MD_APP_PERIODIC_RESTART_TIME         2111
#endif
#ifndef MD_APP_PERIODIC_RESTART_REQUESTS
#define MD_APP_PERIODIC_RESTART_REQUESTS     2112
#endif
#ifndef MD_APP_PERIODIC_RESTART_SCHEDULE
#define MD_APP_PERIODIC_RESTART_SCHEDULE     2113
#endif
#ifndef MD_ASP_DISKTEMPLATECACHEDIRECTORY
#define MD_ASP_DISKTEMPLATECACHEDIRECTORY    7036
#endif
#ifndef MD_ASP_MAXDISKTEMPLATECACHEFILES
#define MD_ASP_MAXDISKTEMPLATECACHEFILES     7040
#endif

typedef struct _Mapping
{
   CString ext;
   CString path;
   CString verbs;
   DWORD flags;
} Mapping;

class CMetaKey;

class CMappings : public std::map<CString, Mapping>
{
public:
   CMappings()
   {
   }
   ~CMappings()
   {
   }

   HRESULT Load(CMetaKey * pKey);
   HRESULT Save(CMetaKey * pKey);
};

#define SET_MODIFIED(x)\
   m_pData->m_Dirty = (x);\
   SetModified(m_pData->m_Dirty)

#define APPLY_DATA()\
   if (SUCCEEDED(m_pData->Save()))\
      CancelToClose()

class CAppData
{
public:
   CAppData()
   {
   }
   ~CAppData()
   {
   }

   BOOL IsMasterInstance();

   HRESULT Load();
   HRESULT Save();

   CString m_ServerName;
   CString m_UserName;
   CString m_UserPassword;
   CString m_MetaPath;

   BOOL  m_Dirty;
   int   m_AppIsolated;                //MD_APP_ISOLATED
   BOOL  m_EnableSession;              //MD_ASP_ALLOWSESSIONSTATE
   BOOL  m_EnableBuffering;            //MD_ASP_BUFFERINGON
   BOOL  m_EnableParents;              //MD_ASP_ENABLEPARENTPATHS
   int   m_SessionTimeout;             //MD_ASP_SESSIONTIMEOUT
   int   m_ScriptTimeout;              //MD_ASP_SCRIPTTIMEOUT
   TCHAR m_Languages[MAX_PATH];        //MD_ASP_SCRIPTLANGUAGE
   BOOL  m_ServerDebug;                //MD_ASP_ENABLESERVERDEBUG
   BOOL  m_ClientDebug;                //MD_ASP_ENABLECLIENTDEBUG
   BOOL  m_SendAspError;               //MD_ASP_SCRIPTERRORSSENTTOBROWSER
   TCHAR m_DefaultError[MAX_PATH];     //MD_ASP_SCRIPTERRORMESSAGE
   BOOL  m_CacheISAPI;                 //MD_CACHE_EXTENSIONS
   BOOL  m_LogFailures;                //MD_ASP_LOGERRORREQUESTS
   BOOL  m_DebugExcept;                //MD_ASP_EXCEPTIONCATCHENABLE
   int   m_CgiTimeout;                 //MD_SCRIPT_TIMEOUT 
   BOOL  m_RecycleTimespan;            //
   int   m_Timespan;                   //MD_APP_PERIODIC_RESTART_TIME
   BOOL  m_RecycleRequest;             //
   int   m_Requests;                   //MD_APP_PERIODIC_RESTART_REQUESTS
   BOOL  m_RecycleTimer;               //
   CStringListEx m_Timers;             //MD_APP_PERIODIC_RESTART_SCHEDULE
   BOOL  m_NoCache;                    // 
   BOOL  m_UnlimCache;                 //
   int   m_UnlimCacheInMemorySize;     //MD_ASP_SCRIPTFILECACHESIZE
   int   m_LimCacheInMemorySize;       //MD_ASP_SCRIPTFILECACHESIZE
   BOOL  m_LimCache;                   //
   int   m_TotalCacheSize;             //MD_ASP_MAXDISKTEMPLATECACHESIZE
   TCHAR m_DiskCacheDir[MAX_PATH];     //MD_ASP_DISKTEMPLATECACHEDIRECTORY
   int   m_ScriptEngCacheMax;          //MD_ASP_SCRIPTENGINECACHEMAX
   CMappings m_Mappings;               //
};

class CAppPropSheet : public WTL::CPropertySheet
{
public:
   CAppPropSheet();

   ~CAppPropSheet()
   {
   }

BEGIN_MSG_MAP_EX(CAppPropSheet)
   MSG_WM_INITDIALOG(OnInitDialog)
	MSG_WM_KEYDOWN(OnKeyDown)
END_MSG_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnKeyDown(UINT nChar, UINT nRepCnt, UINT hFlags);
};

#endif //_PROP_SHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\authctl.h ===
// AuthCtl.h : Declaration of the CCertAuthCtrl OLE control class.

#ifndef  _AuthCtl_h_12375_
#define  _AuthCtl_h_12375_

//#include "NKChseCA.h"

//#include <wincrypt.h>
// #include "Certifct.h"
// #include "dlgs.h"
// #include "SelAcct.h"
// #include "FindDlg.h"
// #include "wintrust.h"
//#include <cryptui.h>

/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl : See AuthCtl.cpp for implementation.

class CCertAuthCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCertAuthCtrl)

// Constructor
public:
    CCertAuthCtrl();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCertAuthCtrl)
    public:
    virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
    virtual void DoPropExchange(CPropExchange* pPX);
    virtual void OnResetState();
    virtual void OnClick(USHORT iButton);
    virtual void OnFontChanged();

#ifdef FUTURE_USE
    // tompop: some experimental code for testing
    virtual HRESULT LaunchCommonCTLDialog (CCTL* pCTL);
#endif /* FUTURE_USE */

    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
protected:
    ~CCertAuthCtrl();

    DECLARE_OLECREATE_EX(CCertAuthCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCertAuthCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCertAuthCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCertAuthCtrl)       // Type name and misc status

// Message maps
    //{{AFX_MSG(CCertAuthCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCertAuthCtrl)
    afx_msg void SetMachineName(LPCTSTR szMachineName);
    afx_msg void SetServerInstance(LPCTSTR szServerInstance);
    afx_msg void DoClick(long dwButtonNumber);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

    afx_msg void AboutBox();

// Event maps
    //{{AFX_EVENT(CCertAuthCtrl)
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()
    
    // Subclassed control support
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);


//    void NKAddPageToWizard(IN ADMIN_INFO& info, IN CNKPages* nkpg2Add, IN OUT CPropertySheet* psWizard);

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCertAuthCtrl)
    dispidSetMachineName = 1L,
    dispidSetServerInstance = 2L,
    //}}AFX_DISP_ID
    };
    
    ////////////////////////////////////////////////////////////////////////
    // run the dialogs used in this active X control.
    //  Big picture:  OnClick(USHORT iButton) will do all the setup for
    //  activeX controls and then call RunDialogs4OnClick that has the
    // tasks of setting up the MetaBase ptr and call the _RunDialogs4OnClick
    // routine that does all the work...
    //
    // The above 'RunDialogs4OnClick()' calls us inside of a try/catch
    // block to protect the metabase
    ////////////////////////////////////////////////////////////////////////
//    BOOL RunDialogs4OnClick(USHORT iButton);
    
    ////////////////////////////////////////////////////////////////////////
    //  _RunDialogs4OnClick -- main handler for our dialogs
    //
    //  Parms:  info:    holds the information database for out ActiveX cntrol
    //                   By this time its member m_mbWrap holds the MetaBase Wrapper
    //                   that is properly initialized
    //                   and points to the SERVER node that we are operating in.
    //          iButton: tells what "logical button" fired our control:
    //                   0=Get-Cert     1=Edit
    ////////////////////////////////////////////////////////////////////////
//    BOOL  _RunDialogs4OnClick(ADMIN_INFO& info, USHORT iButton);

    /////////////////////////////////////////////////////////////////////
    // Automation defined methods
    /////////////////////////////////////////////////////////////////////
    void OnAmbientPropertyChange(DISPID dispid) ;
    void OnTextChanged();
    void OnMnemonic(LPMSG pMsg); 
    void OnGetControlInfo(LPCONTROLINFO pControlInfo); 
    void OnKeyUpEvent(USHORT nChar, USHORT nShiftState); 
    
    CString     m_szServerInstance;
    CString     m_szMachineName;
    BOOL        m_fUpdateFont;
    CString     m_szOurApplicationTitle; // set in OnClick()
 
        // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;

};


#endif /* _AuthCtl_h_12375_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\authppg.h ===
// CertAuthPpg.h : Declaration of the CCertAuthPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage : See CertAuthPpg.cpp.cpp for implementation.

class CCertAuthPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CCertAuthPropPage)
    DECLARE_OLECREATE_EX(CCertAuthPropPage)

// Constructor
public:
    CCertAuthPropPage();

// Dialog Data
    //{{AFX_DATA(CCertAuthPropPage)
    enum { IDD = IDD_PROPPAGE_CERTAUTH };
    CString m_sz_caption;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CCertAuthPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A74A456C_9DC6_4AD7_8D03_A6611CFFD005__INCLUDED_)
#define AFX_STDAFX_H__A74A456C_9DC6_4AD7_8D03_A6611CFFD005__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <shlwapi.h>
#include <shellapi.h>

#define _WTL_NO_CSTRING

#include <atlwin.h>
#include <atlapp.h>
#include <atldlgs.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlctrlx.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <map>
#include <list>
#include <stack>
#include <set>

#include "common.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A74A456C_9DC6_4AD7_8D03_A6611CFFD005__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\brwsdlg.h ===
//--------------------------------------------------------
class CNTBrowsingDialog : public CDialog
    {
    public:

    // construct / deconstruct
    CNTBrowsingDialog( UINT nIDTemplate, CWnd* pParentWnd = NULL );

    // overrides
    virtual void OnOK();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(CEditOne11MapDlg)
    CEdit   m_cedit_password;
    CEdit   m_cedit_accountname;
    CString m_sz_accountname;
    CString m_sz_password;
    //}}AFX_DATA

//  CEdit   m_cedit_password;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CNTBrowsingDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CNTBrowsingDialog)
    afx_msg void OnBrowse();
    afx_msg void OnChangePassword();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CString m_szOrigPass;
    BOOL    m_bPassTyped;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\appconfig\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppConfig.rc
//
#define IDS_PROJNAME                    100
#define IDR_IISAPPCONFIG                101
#define IDS_SHEET_TITLE                 101
#define IDS_EXTENSION                   102
#define IDS_EXECUTABLE_PATH             103
#define IDS_VERBS                       104
#define IDS_ALL                         105
#define IDS_CONFIRM_REMOVE_MAP          106
#define IDS_EXECUTABLE_FILES            107
#define IDS_EXECUTABLE_EXT              108
#define IDS_DLL_FILES                   109
#define IDS_DLL_EXT                     110
#define IDS_ALL_FILES                   111
#define IDS_ALL_EXT                     112
#define IDS_ERR_NOVERBS                 113
#define IDS_ERR_NOEXT                   114
#define IDS_ERR_USEDEXT                 115
#define IDS_ERR_BADEXECFORMAT           116
#define IDS_ERR_NOUNC                   117
#define IDS_ERR_NOREMOTE                118
#define IDS_ERR_FILENOTEXISTS           119
#define IDS_SELECT_CACHE_PATH           120
#define IDS_ERR_BADEXT                  121
#define IDS_DIRECTORY_DOESNT_EXIST      122
#define IDS_READ_ONLY_DIRECTORY         123
#define IDC_INMEM_UNLIM_EDIT            201
#define IDD_TIME_PICKER                 201
#define IDC_INMEM_UNLIM_SPIN            202
#define IDC_CACHE_SIZE_SPIN             203
#define IDC_ENG_CACHED_SPIN             204
#define IDC_TIMEOUT_SPIN                207
#define IDC_TIMESPAN_SPIN               208
#define IDC_REQUESTS_SPIN               209
#define IDC_ASPTIMEOUT_SPIN             211
#define IDC_TIME_PICKER                 212
#define IDC_BROWSE                      10210
#define IDD_ASPMAIN                     10214
#define IDD_ASPDEBUG                    10215
#define IDD_APP_APPMAP                  10216
#define IDD_APPMAP                      10216
#define IDD_EDITMAP                     10218
#define IDD_APP_PROC                    10220
#define IDD_CACHE_OPT                   10220
#define IDD_APP_RECYCLE                 10221
#define IDD_PROCESS_OPT                 10221
#define IDC_RECYCLE_TIMER               10235
#define IDC_CHK_EXCEPTION_CATCH         10235
#define IDC_SCRIPT_ENGINE               10235
#define IDC_FILE_EXISTS                 10236
#define IDC_DEBUG_EXCEPTION             10236
#define IDC_ENABLE_BUFFERING            10236
#define IDC_ENABLE_PARENTS              10237
#define IDC_CHK_WRITE_FAIL_TO_LOG       10238
#define IDC_LOG_FAILS                   10238
#define IDC_TIMESPAN                    10240
#define IDC_EXECUTABLE                  10240
#define IDC_SESSION_TIMEOUT             10240
#define IDC_REQUEST_LIMIT               10241
#define IDC_EDT_NUM_ENGINES             10241
#define IDC_EXTENSION                   10241
#define IDC_ENGINES                     10241
#define IDC_VERBS                       10243
#define IDC_CACHE_PATH                  10243
#define IDC_SCRIPT_TIMEOUT              10243
#define IDC_RDO_CACHE_ALL               10244
#define IDC_ALL_VERBS                   10244
#define IDC_RDO_CACHE_SIZE              10245
#define IDC_RADIO_LIMIT_VERBS           10245
#define IDC_LIMIT_VERBS                 10245
#define IDC_EDT_CACHE_SIZE              10246
#define IDC_RDO_CACHE_NONE              10247
#define IDC_LIST                        10247
#define IDC_ADD_TIME                    10248
#define IDC_ADD                         10248
#define IDC_NO_CACHE                    10248
#define IDC_REMOVE                      10249
#define IDC_UNLIMITED_CACHE             10249
#define IDC_DELETE_TIME                 10249
#define IDC_EDIT                        10250
#define IDC_LIMITED_CACHE               10250
#define IDC_CHANGE_TIME                 10250
#define IDC_HELPBTN                     10251
#define IDC_CACHE_SIZE_EDIT             10251
#define IDC_SERVER_DEBUG                10251
#define IDC_CLIENT_DEBUG                10252
#define IDC_SEND_DETAILED_ERROR         10253
#define IDC_SEND_DEF_ERROR              10254
#define IDC_DEFAULT_ERROR               10255
#define IDC_CGI_SECONDS                 10258
#define IDC_CGI_TIMEOUT                 10258
#define IDC_ENABLE_SESSION              10263
#define IDC_SESSION_TITLE               10264
#define IDC_SESSION_UNITS               10265
#define IDC_LANG_TITLE                  10267
#define IDC_CACHE_ISAPI                 10268
#define IDC_LANGUAGES                   10270
#define IDC_RECYCLE_TIMESPAN            10271
#define IDC_RECYCLE_REQUESTS            10272
#define IDC_TIMES_LIST                  10273
#define IDC_CACHE_DIST                  10275
#define IDC_INMEM_LIM_EDIT              10276
#define IDC_INMEM_LIM_SPIN              10277

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         213
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\cauthdlg.h ===
// CAuthDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClientAuthoritiesDialog dialog

class CClientAuthoritiesDialog : public CDialog
{
// Construction
public:
    CClientAuthoritiesDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CClientAuthoritiesDialog)
    enum { IDD = IDD_CLIENT_AUTHORITIES };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClientAuthoritiesDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CClientAuthoritiesDialog)
    afx_msg void OnViewCertificate();
    afx_msg void OnDelete();
    afx_msg void OnAdd();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\addcert.cpp ===
// AddCert.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"

// persistence and mapping includes
#include "WrapMaps.h"
#include "wrapmb.h"

#include "ListRow.h"
#include "ChkLstCt.h"

// mapping page includes
#include "brwsdlg.h"
#include "EdtOne11.h"
#include "Ed11Maps.h"
#include "Map11Pge.h"

extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}

#include <iismap.hxx>
#include <iiscmr.hxx>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define COL_NUM_NAME        0
#define COL_NUM_NTACCOUNT   1

#define CERT_HEADER         "-----BEGIN CERTIFICATE-----"



// the code that reads the certificate file is pretty much lifted from the
// keyring application. Which pretty much lifted it from the setkey application

// defines taken from the old KeyGen utility
#define MESSAGE_HEADER  "-----BEGIN NEW CERTIFICATE REQUEST-----\r\n"
#define MESSAGE_TRAILER "-----END NEW CERTIFICATE REQUEST-----\r\n"
#define MIME_TYPE       "Content-Type: application/x-pkcs10\r\n"
#define MIME_ENCODING   "Content-Transfer-Encoding: base64\r\n\r\n"

void uudecode_cert(char *bufcoded, DWORD *pcbDecoded );


//---------------------------------------------------------------------------
// originally from keyring - modified to fit
BOOL CMap11Page::FAddCertificateFile( CString szFile )
    {
    CFile       cfile;
    PVOID       pData = NULL;
    BOOL        fSuccess =FALSE;;

    // open the file
    if ( !cfile.Open( szFile, CFile::modeRead | CFile::shareDenyNone ) )
        return FALSE;

    // how big is the file - add one so we can zero terminate the buffer
    DWORD   cbCertificate = cfile.GetLength() + 1;

    // make sure the file has some size
    if ( !cbCertificate )
        {
        AfxMessageBox( IDS_ERR_INVALID_CERTIFICATE );
        return FALSE;
        }

    // put the rest of the operation in a try/catch
    try
        {
        PCCERT_CONTEXT pCertContext=NULL; //used to determine whether cert file is binary DER encoded
        // allocate space for the data
        pData = GlobalAlloc( GPTR, cbCertificate );
        if ( !pData ) AfxThrowMemoryException();

        // copy in the data from the file to the pointer - will throw and exception
        DWORD cbRead = cfile.Read( pData, cbCertificate );

        // zero terminate for decoding
        ((BYTE*)pData)[cbRead] = 0;

        // close the file
        cfile.Close();

        //certificate file may be either be binary DER file or BASE64 encoded file

        // try binary DER encoded first
        pCertContext= CertCreateCertificateContext(X509_ASN_ENCODING, (const BYTE *)pData, cbRead);
        if(pCertContext != NULL)
        {
                // we created certificate context only to verify that file is binary DER encoded
                // free it now
                CertFreeCertificateContext(pCertContext);
                pCertContext=NULL;
        }
        else    // now try BASE64 encoded
        {       
                // we don't care about header ----BEGIN CERTIFICATE----- or trailer-----END CERTIFICATE-----, 
				// uudecode will take care of that
                uudecode_cert( (PCHAR)pData, &cbRead );
        }
        // we now have a pointer to a certificate. Lets keep it clean looking
        // call another subroutine to finish the job.
        fSuccess = FAddCertificate( (PUCHAR)pData, cbRead );

    }catch( CException e )
        {
        // return failure
        fSuccess = FALSE;

    // if the pointer was allocated, deallocate it
    if ( pData )
        {
        GlobalFree( pData );
        pData = NULL;
        }
    }

    // return success
    return fSuccess;
    }

    #define CERT_HEADER_LEN 17
    CHAR CertTag[ 13 ] = { 0x04, 0x0b, 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e' };

//---------------------------------------------------------------------------
// we are passed in a complete certificate. We need to parse out the subject
// and the issuer fields so we can add the mapping. Then add the mapping.
BOOL CMap11Page::FAddCertificate( PUCHAR pCertificate, DWORD cbCertificate )
    {
    BOOL    fSuccess = FALSE;

    // thankfully, the certificate is already in the correct format.
    // this means that, for now at least, we don't have to do anything
    // special to it to store it. However, we should crack it once just
    // to see that we can to prove that it is a valid cert.

    ASSERT( pCertificate );
    if ( !pCertificate ) return FALSE;

    // crack the certificate to prove that we can
    PX509Certificate    p509 = NULL;
    fSuccess = SslCrackCertificate( pCertificate, cbCertificate, CF_CERT_FROM_FILE, &p509 );
    if ( fSuccess )
        {
        SslFreeCertificate( p509 );
        }
    else
        {
        // we were not able to crack the certificate. Alert the user and fail
        AfxMessageBox( IDS_ERR_INVALID_CERTIFICATE );
        return FALSE;
        }

    // by this point we know we have a valid certificate, make the new mapping and fill it in
    // make the new mapping object
    C11Mapping* pMapping = PNewMapping();
    ASSERT( pMapping );
    if( !pMapping )
        {
        AfxThrowMemoryException();  // seems fairly appropriate
        return FALSE;
        }


    // one more thing before we add the certificate. Skip the header if it is there
    PUCHAR pCert = pCertificate;
    DWORD cbCert = cbCertificate;
    if ( memcmp( pCert + 4, CertTag, sizeof( CertTag ) ) == 0 )
    {
        pCert += CERT_HEADER_LEN;
        cbCert -= CERT_HEADER_LEN;
    }


    // install the certificate into the mapping
    fSuccess &= pMapping->SetCertificate( pCert, cbCert );

    // by default, the mapping is enabled
    fSuccess &= pMapping->SetMapEnabled( TRUE );

    // install a default name
    CString sz;
    
    sz.LoadString( IDS_DEFAULT_11MAP );

    fSuccess &= pMapping->SetMapName( sz );

    // install a blank mapping
    fSuccess &= pMapping->SetNTAccount( "" );

    if ( !fSuccess )
        AfxThrowMemoryException();  // seems fairly appropriate


    // now edit the newly created mapping object. If the user cancels,
    // then do not add it to the mapper object nor the list
    if ( !EditOneMapping( pMapping) )
        {
        DeleteMapping( pMapping );
        return FALSE;
        }

    // add the mapping item to the list control
    fSuccess = FAddMappingToList( pMapping );

    // one more test for success
    if ( !fSuccess )
        {
        DeleteMapping( pMapping );
        ASSERT( FALSE );
        }

    // mark the mapping to be saved
    if ( fSuccess )
        MarkToSave( pMapping );

    // return the answer
    return fSuccess;
    }


//      ==============================================================
//      The function  'uudecode_cert'  IS THE SAME function that is
//      found in file:  Addcert.cpp if we make the following code
//      have a FALSE for bAddWrapperAroundCert -- surely we can unify
//      these 2 functions.  Having 2 functions named 'uudecode_cert'
//      was causing me LINKING errors.  + we have 2 instances of
//      the external tables: uudecode_cert and pr2six
//
//      Since I am linking both Addcert.cpp and CKey.cpp I choose to
//      leave the defintions intact for CKey.cpp   [ and have extended
//      uudecode_cert by adding conditional code as shown below] Further
//      work needs to be done after identification as to why I need both
//      Addcert.cpp and CKey.cpp to pass bAddWrapperAroundCert as a
//      parameter so that both files can be supported.
//      ==============================================================
//  BOOL  bAddWrapperAroundCert = TRUE;
//  if (bAddWrapperAroundCert) {
//     //
//     //  Now we need to add a new wrapper sequence around the certificate
//     //  indicating this is a certificate
//     //
// 
//     memmove( beginbuf + sizeof(abCertHeader),
//              beginbuf,
//              nbytesdecoded );
// 
//     memcpy( beginbuf,
//             abCertHeader,
//             sizeof(abCertHeader) );
// 
//     //
//     //  The beginning record size is the total number of bytes decoded plus
//     //  the number of bytes in the certificate header
//     //
// 
//     beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
//     beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);
// 
//     nbytesdecoded += sizeof(abCertHeader);
//   }

// #ifdef WE_ARE_USING_THE_VERSION_IN__CKey_cpp__NOT_THIS_ONE__ITS_JUST_LIKE_THIS_ONE_WITH_1SMALL_CHANGE

//============================ BASED ON SETKEY
const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//
//  We have to squirt a record into the decoded stream
//

#define CERT_RECORD            13
#define CERT_SIZE_HIBYTE        2       //  Index into record of record size
#define CERT_SIZE_LOBYTE        3

unsigned char abCertHeader[] = {0x30, 0x82,           // Record
                                0x00, 0x00,           // Size of cert + buff
                                0x04, 0x0b, 0x63, 0x65,// Cert record data
                                0x72, 0x74, 0x69, 0x66,
                                0x69, 0x63, 0x61, 0x74,
                                0x65 };

void uudecode_cert(char *bufcoded, DWORD *pcbDecoded )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout = (unsigned char *)bufcoded;
    unsigned char *pbuf;
    int nprbytes;
    char * beginbuf = bufcoded;

    ASSERT(bufcoded);
    ASSERT(pcbDecoded);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' ||
          *bufcoded == '\t' ||
          *bufcoded == '\r' ||
          *bufcoded == '\n' )
    {
          bufcoded++;
    }

    //
    //  If there is a beginning '---- ....' then skip the first line
    //

    if ( bufcoded[0] == '-' && bufcoded[1] == '-' )
    {
        bufin = strchr( bufcoded, '\n' );

        if ( bufin )
        {
            bufin++;
            bufcoded = bufin;
        }
        else
        {
            bufin = bufcoded;
        }
    }
    else
    {
        bufin = bufcoded;
    }

    //
    //  Strip all cr/lf from the block
    //

    pbuf = (unsigned char *)bufin;
    while ( *pbuf )
    {
        if ( (*pbuf == ' ') || (*pbuf == '\r') || (*pbuf == '\n') )
        {
            memmove( (void*)pbuf, pbuf+1, strlen( (char*)pbuf + 1) + 1 );
        }
        else
        {
            pbuf++;
        }
    }

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */

    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    bufin  = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    /*
    //
    //  Now we need to add a new wrapper sequence around the certificate
    //  indicating this is a certificate
    //

    memmove( beginbuf + sizeof(abCertHeader),
             beginbuf,
             nbytesdecoded );

    memcpy( beginbuf,
            abCertHeader,
            sizeof(abCertHeader) );

    //
    //  The beginning record size is the total number of bytes decoded plus
    //  the number of bytes in the certificate header
    //

    beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
    beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);

    nbytesdecoded += sizeof(abCertHeader);
*/

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;
}
// ============ END BASED ON SETKEY

//#endif /* WE_ARE_USING_THE_VERSION_IN__CKey_cpp__NOT_THIS_ONE__ITS_JUST_LIKE_THIS_ONE_WITH_1SMALL_CHANGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\authctl.cpp ===
// AuthCtl.cpp : Implementation of the CCertAuthCtrl OLE control class.

// THIS FEATURE USED TO BE SOMETHING DIFFERENT, now it has meaning of:
// Doing CertificateRequest and Authority Mapping/management.

#include "stdafx.h"
//#include "Util.h"
#include "certmap.h"
#include "AuthCtl.h"
#include "AuthPpg.h"

/*

#include "Reg.h"
#include "nLocEnrl.h"

#ifdef  USE_COMPROP_WIZ97
# include "wizard.h"         // implement Wizard97 look and feel
#endif

#include <windows.h>
#include <wincrypt.h>
//#include <unicode.h>
//#include <base64.h>
//#include <pvk.h>

//need the CLSID and IID for xEnroll

#include    <ole2.h>
#include    "xenroll.h"
#include    <certrpc.h>
#include    <winsock.h>

#include <wintrust.h>

#include "wrapmb.h"


#include "NKWelcom.h"           // for class CNKWelcome
#include "NKMuxPg.h"            // for class CNKMuxPg   -- for new certs
#include "NKMuxPg2.h"           // for class CNKMuxPg2  -- for OOB finish ops
#include "NKMuxPg3.h"           // for class CNKMuxPg3  -- for Mod Existing ops



#define _CRYPT32_
// persistence and mapping includes
extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "CrackCrt.h"
#include "ListRow.h"
#include "ChkLstCt.h"
#include "IssueDlg.h"



// include header files for the dialog pages
//
#include "KeyObjs.h"

//#include "WizSheet.h"
#include "NKChseCA.h"
#include "NKDN.h"
#include "NKDN1.h"
#include "NKDN2.h"
#include "NKFlInfo.h"
#include "NKKyInfo.h"
#include "NKUsrInf.h"
#include "CertSel.h"
#include "CompPage.h"
#include "WizError.h"

#include "Creating.h"

#include "CTLWelc.h"
#include "CTLMuxPg.h"


#include "NKChseCA.h"

#include "NKWelcom.h"           // for class CNKWelcome
#include "NKMuxPg.h"            // for class CNKMuxPg
#include "KeyRImpt.h"           // for class CKeyImpt -- the 1st KeyRing Import page
#include "KeyRFile.h"           // for the second KeyRing Import page that asks
                                // the user to confirm they want to do the import

#include "FinCImpt.h"            // for the first Cert-Finish an offline-request
                                //  Wizard page -- class CFinCertImport
#include "FinCFin.h"            // for the second Cert-Finish an offline-request
                                //  Wizard page -- class CFinCertImport


#include "NKMuxPg3.h"
#include "DelCert.h"
*/





#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertAuthCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertAuthCtrl, COleControl)
    //{{AFX_MSG_MAP(CCertAuthCtrl)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCertAuthCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CCertAuthCtrl)
    DISP_FUNCTION(CCertAuthCtrl, "SetMachineName", SetMachineName, VT_EMPTY, VTS_BSTR)
    DISP_FUNCTION(CCertAuthCtrl, "SetServerInstance", SetServerInstance, VT_EMPTY, VTS_BSTR)
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_CAPTION()
    DISP_FUNCTION_ID(CCertAuthCtrl, "DoClick", DISPID_DOCLICK, DoClick, VT_EMPTY, VTS_I4)
    //}}AFX_DISPATCH_MAP
    DISP_FUNCTION_ID(CCertAuthCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCertAuthCtrl, COleControl)
    //{{AFX_EVENT_MAP(CCertAuthCtrl)
    EVENT_STOCK_CLICK()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CCertAuthCtrl, 2)
    PROPPAGEID(CCertAuthPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CCertAuthCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertAuthCtrl, "CERTMAP.CertmapCtrl.2",
    0x996ff6f, 0xb6a1, 0x11d0, 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCertAuthCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCertAuth =
        { 0x996ff6d, 0xb6a1, 0x11d0, { 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const IID BASED_CODE IID_DCertAuthEvents =
        { 0x996ff6e, 0xb6a1, 0x11d0, { 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCertAuthOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCertAuthCtrl, IDS_CERTAUTH, _dwCertAuthOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::CCertAuthCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertAuthCtrl

BOOL CCertAuthCtrl::CCertAuthCtrlFactory::UpdateRegistry(BOOL bRegister)
    {
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.


    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_CERTAUTH,
            IDB_CERTAUTH,
            afxRegApartmentThreading,
            _dwCertAuthOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::CCertAuthCtrl - Constructor

CCertAuthCtrl::CCertAuthCtrl():
    m_fUpdateFont( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DCertAuth, &IID_DCertAuthEvents);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::~CCertAuthCtrl - Destructor

CCertAuthCtrl::~CCertAuthCtrl()
    {
     if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );

        m_hAccel = NULL;

    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::OnDraw - Drawing function

void CCertAuthCtrl::OnDraw(
            CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
    {
    CFont* pOldFont;

    // select the stock font, recording the old one
    pOldFont = SelectStockFont( pdc );

    // do the superclass draw
    DoSuperclassPaint(pdc, rcBounds);

    // restore the old font - sneakily getting the correct font object
    pOldFont = pdc->SelectObject(pOldFont);

    // we want the button window to continue drawing in the correct font even
    // when we are not using OnDraw. i.e. when it is being pushed down. This
    // means we need to set the CWnd::SetFont() method.
    if ( m_fUpdateFont )
        {
        m_fUpdateFont = FALSE;
        CWnd::SetFont( pOldFont );
        }
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::DoPropExchange - Persistence support

void CCertAuthCtrl::DoPropExchange(CPropExchange* pPX)
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::OnResetState - Reset control to default state

void CCertAuthCtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::AboutBox - Display an "About" box to the user

void CCertAuthCtrl::AboutBox()
    {
//    CDialog dlgAbout(IDD_ABOUTBOX_CERTAUTH);
//    dlgAbout.DoModal();
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl message handlers

//---------------------------------------------------------------------------
BOOL CCertAuthCtrl::PreCreateWindow(CREATESTRUCT& cs) 
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }



/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::IsSubclassedControl - This is a subclassed control

BOOL CCertAuthCtrl::IsSubclassedControl()
    {
    return TRUE;
    }



/////////////////////////////////////////////////////////////////////////////
// OnOcmCommand - Handle command messages

LRESULT CCertAuthCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    // TODO: Switch on wNotifyCode here.

    return 0;
}


/*dddddddddd
#ifdef FUTURE_USE
HRESULT CCertAuthCtrl::LaunchCommonCTLDialog (CCTL* pCTL)
{
    ASSERT (pCTL);
    CRYPTUI_VIEWCTL_STRUCT  vcs;
    HWND                    hwndParent=0;
    // //
    // // Success codes defined for HRESULTS:
    // //
    // #define S_OK                                   ((HRESULT)0x00000000L)
    // #define S_FALSE                                ((HRESULT)0x00000001L)

    HRESULT  hResult= S_OK;

    ::ZeroMemory (&vcs, sizeof (vcs));
    vcs.dwSize = sizeof (vcs);
    vcs.hwndParent = hwndParent;
    vcs.dwFlags = 0;
    vcs.pCTLContext = pCTL->GetCTLContext ();

    BOOL bResult = ::CryptUIDlgViewCTL (&vcs);
    if ( bResult )
    {
    }

    return hResult;
}

#endif


#if defined(DEBUGGING)
//-----------------------------------------------------------------------
// checkSanityMFC is used only for debugging some strange MFC problem
//                where MFC loses it state!
//
//      Method:   20 times ask MFC to get out application name that
//                should be "certmap" --> if we fail we throw assert + return FALSE
//                OTHERWISE we return TRUE;
//-----------------------------------------------------------------------
BOOL  checkSanityMFC()
{

    for (int i=0; i<20; i++) {
        CString szCaption = AfxGetAppName(); // for debug, we now print it out
        ASSERT( STRICMP(szCaption, _T("certmap"))==0);
        return FALSE;
    }
    return TRUE;
 }
#endif
*/


                               

//-------------------------------------------------------------------------------
//  OnClick  -   process a click event.   This will be called by the IIS admin
//               API to launch us!   [people get here by clicking on our control]
//
//  PARAMS:     iButton  an IN param. tells what "logical button" fired our control:
//
//              value
//              ------
//               1          Call CertWiz
//               2          Call CTL Wiz
//-------------------------------------------------------------------------------
extern void test__non2Rons_WizClasses();

void CCertAuthCtrl::OnClick(USHORT iButton) 
    {

/*ddddddddddddddd
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

#if defined(DEBUGGING)
    if (DebugTestEnv(_T("MFC")) && YesNoMsgBox(_T("Shall we run: test__non2Rons_WizClasses"))) {
        test__non2Rons_WizClasses();
    }
#endif

#if defined(DEBUGGING) && defined(SHOW_TRACE_INFO)
    Trace   t( _T("CCertAuthCtrl::OnClick"));
#endif

#if defined(DEBUGGING)
    checkSanityMFC();       
#endif



#if defined(DEBUGGING)

    (void) ShallWeShowDebugMsgs();  // the purpose of this call is to make sure
                                    // that we properly initialize [if we are
                                    // to emit debug stmts, even though we have
                                    // a debug build].  We currently look in Reg:
                                    // "Software\\Microsoft\\CertMap\\Debug" under
                                    // HKEY_CURRENT_USER for a Key with:
                                    // name: "Enabled" and set to "TRUE".
                                    // If we find that we produce debug stmts.
                                    // See file Debug.cpp and Debug.h for more info
#endif

    // m_szMachineName currently has the machine we were told to operate upon
    // "We currently do not support remote administration of Web servers."

    // ComputerNameMatchesOurMachineName(IN OUT CString& remoteHostname)
    //
    //      After trimming [remoteHostname] see if its naming this
    //      machine.  We look for a direct case-independent match
    //      or "localhost"
    //
    // RETURNS: T: iff the name passed in matches the machine we are
    //             running on.
    //
    //  NOTE: remoteHostname is an IN OUT.  OUT since we trim any white
    //        space off of it.
    //------------------------------------------------------------------
    if (FALSE == ComputerNameMatchesOurMachineName(m_szMachineName))
    {
        if (FALSE == m_szMachineName.IsEmpty() ) {
            MessageBeep(0);
            MsgBox( IDS_WE_CURRENTLY_DONT_SUPPORT_REMOTE_ADMIN_OF_SERVERS );
            return ;
        }
    }


    //////////////////////////////////////////////////////////////////////////////
    //  The following bucnch of code's sole purpose is to set the application's
    //  name properly
    //////////////////////////////////////////////////////////////////////////////
    // in case there are any errors, prepare the error string
    //
    //   We store the following in our class:  CString m_szOurApplicationTitle;

    // set the name of the application correctly
    // Use our Fancy Debugging "Load String" found in Easy::CString
    Easy::CString::LoadStringInto( m_szOurApplicationTitle, IDS_ERR_CERTWIZ_TITLE );
    //  tompop: tjp:    do we need a different string than
    //                  what CertMap uses?  They use: IDS_ERR_CERTMAP_TITLE
    //                  should we use the same?  They say "Certificate Mapping"
    //                  as the title; we say "Server Certificate Wizard"


    // Testing needs different titles for the error popups.
    // IDS_ERR_CERTWIZ_TITLE="Server Certificate Wizard" our std title by design.
    // So if somebody has set Env=TitleCertWizError, we give CertWiz as the title
    // so that we can pick them off in automatic tests
    //----------------------------------------------------------
    if (DebugTestEnv(_T("TitleCertWizError"))) {
        m_szOurApplicationTitle = _T("CertWiz");  // used in automatic tests
    }
    
    // free the existing name, and copy in the new one
    //  tjp:  you should compare if the old name matches the current name
    //        and only then free and malloc the new name -- chances are that
    //        the names are the same +++ all the free/malloc can fragment mem.
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(m_szOurApplicationTitle);
    //////////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////////
    // this is why we are here
    // this is the whole purpose of the control
    //////////////////////////////////////////////////////////////////////////////
    RunDialogs4OnClick(iButton);

#if defined(DEBUGGING)
    DODBG MsgBox( _T("DBG:  finished our call to RunDialogs4OnClick") );
#endif
*/   
    // we are not in the business of telling the host to do
    // something here, so just don't fire anything off.
    COleControl::OnClick(iButton);
}




/*
////////////////////////////////////////////////////////////////////////
//  main handler for our dialogs:
//  1. setup the metabase and then,
//  2. call the routine that actually handles the dialogs
//     trapping exceptions to protect the metaBase
//
//  Parms:  iButton: tells what "logical button" fired our control:
//                   0=Get-Cert     1=Edit
////////////////////////////////////////////////////////////////////////
BOOL CCertAuthCtrl::RunDialogs4OnClick(USHORT iButton)
{
#if defined(DEBUGGING) && defined(SHOW_TRACE_INFO)
    Trace   t( _T("CCertAuthCtrl::RunDialogs4OnClick"));
#endif


#if defined(DEBUGGING)
    checkSanityMFC();       
#endif
        ////////////////////////////////////////////////////////////////////
        ///////////////////////  Do a Boydm style m_szServerInstance      //
        ///////////////////////  normalization operation                  //
        ////////////////////////////////////////////////////////////////////
        // if there is nothing in the MB_Path, default to the first instance


        if ( m_szServerInstance.IsEmpty() )
        {
            // we might want to assign a default.  We do so in testing.
            // otherwise we fail hard!
            MsgBox( IDS_NO_SERVER_INSTANCE_SET );
            //"The metabase path is not set for the virtual Web server instance. Internal error; exiting"
                   

#if defined(DEBUGGING)
            if ( DebugTestEnv() ) // if we are in a debug env, we are forgiving
                                  // if the user forgot to set the instance
            {
                m_szServerInstance = _T("/LM/W3SVC/1"); // hack!
                // let it be the default web site! 
            } else {
                return FALSE;
            }
#else
            // production env, this instance path needs to be set
            return FALSE;
#endif
        }

#if defined(DEBUGGING)
      DODBG {
        /////////////////////////////////////////////////////////////////////////////
        //  Below we some testing hooks for manipulating the machine/path
        //  that we operate upon.
        /////////////////////////////////////////////////////////////////////////////

        CEditDialog   dlgMach(m_szMachineName,
                            _T("Below is the machine name of the server instance; it corresponds"
                            " to which machine's metabase we will be administrating.\n"
                            "\nFor testing purposes you"
                            " can change it to whatever you want, now. BLANK means local machine."));
        dlgMach.DoModal();
        
        CEditDialog   dlgPath(m_szServerInstance,
                            _T("Below is the server instance path; it corresponds"
                            " with the path in the metabase.  For testing purposes you"
                            " can change it to whatever you want, now\n"
                            "\n"
                            "Note if it is BLANK we work on \"/LM/W3SVC/1\"" ));

        dlgPath.DoModal();

       }
#endif



//DebugBreak();
    // prepare the machine name pointer
    OLECHAR* poch = NULL;
    if ( !  m_szMachineName.IsEmpty() )
        {
        // allocate the name buffer
        poch = (OLECHAR*)GlobalAlloc( GPTR, MAX_COMPUTERNAME_LENGTH * 2 );

        // unicodize the name into the buffer
        if ( poch )
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, m_szMachineName, -1,
                                poch, MAX_COMPUTERNAME_LENGTH * 2 );
        }
        
    // initialize the metabase wrappings - pass in the name of the target machine
    // if one has been specified

    IMSAdminBase* pMB = FInitMetabaseWrapper( poch );
    if ( !pMB )
    {
        HRESULT hr = GetLastError(); // the bad hr is in GetLastError()

        MessageBeep(0);
        if ( poch )
             GlobalFree( poch );

        const BOOL bDoErrorMsgPopup = TRUE;
        if (bDoErrorMsgPopup) {
            CString  szError;

            Easy::Load(szError, IDS_COULD_NOT_ACCESS_THE_METABASE);
            // "Could not access the metabase, where we store state information"
            
            AppendMachineName(szError, m_szMachineName );
            
            AppendHResultErrorString(szError,  hr);

            MsgBox( szError );
        }

        return  FALSE;              // <<=== we failed!
    }

    // clean up
    if ( poch )
        {
        GlobalFree( poch );
        poch = NULL;
        }

    /////////////////////////////////////////////////////////////////////
    // prepare the metabase wrapper
    /////////////////////////////////////////////////////////////////////
    CWrapMetaBase   mbWrap;
    BOOL f = mbWrap.FInit(pMB);
    if ( FALSE == f )
    {
        return FALSE;              // <<=== we failed!
    }

    /////////////////////////////////////////////////////////////////////
    // Things could (potentially maybe) throw here, so better protect the
    // metabase
    /////////////////////////////////////////////////////////////////////


    //  //-----------------------------------------------------------------------------
    //  //   here is an example of making a CMetaWrapper call,
    //  //   we will typically use GetData calls and grab the meta data Unicode
    //  //   strings also that way since casting a (CONST WCHAR*) into a CString
    //  //   will give us a FREE conversion from WideChar to MultiByte.
    //  //-----------------------------------------------------------------------------
    //  BOOL CAFX_MetaWrapper::GetString( const CHAR* pszPath, 
    //   DWORD dwPropID, DWORD dwUserType,
    //                    CString &sz, DWORD dwFlags )
    //          {
    //  
    //          // first, get the size of the data that we are looking for - it
    //          // will fail because of the NULL,
    //          // but, the size we need should be in cbData;
    //          f = GetData( pszPath, dwPropID, dwUserType, STRING_METADATA, NULL, &cbData );
    //  
    //          // check the error - it should be some sort of memory error
    //  
    //           }
    //  //-----------------------------------------------------------------------------


    try
        {


        // I am assuming that the last character is NOT a '/' Thus, if that is what is
        // there, we need to remove it. Otherwise, the path gets messed up later
        if ( m_szServerInstance.Right(1) == '/' )
            m_szServerInstance = m_szServerInstance.Left( m_szServerInstance.GetLength()-1 );

        
        ADMIN_INFO  info(mbWrap);   // the info object is the central data
                                    //  repository.  It also has the meta
                                    //  base wrapper in it.
        
        info.szMetaBasePath = m_szServerInstance;   // need to store the path
                                        // because we need it for generating
                                        // unique Key Container names, will
                                        // be done in file nLocalEnrl.cpp


        info.szMachineName_MetaBaseTarget = m_szMachineName;

        // NOTE that this routine will either install or DE-install the metabase
        //      GUID strings based on its decision that CertServer is present.
        //      If we find GUID strings in the metabase but can not do a 
        //      CoCreateInstance on ICertConfig:
        //         we remove them so that the rest of CertWizard will see
        //         MB Guids iff we can use CertServer.
        //---------------------------------------------------------------

        BOOL  bFoundCertServer = MigrateGUIDS( info );


        BOOL success = _RunDialogs4OnClick(info,0); // this runs the dialogs
                                                    // note that we are passing
                                                    // mbWrap not pMB
        // save the metabase
        mbWrap.Save();

#if 0
        // close the base object
        //  ==> we dont really have to do this  --  every time we
        //      go to the MB we open and close it.  If closing it again
        //      a second time does not hurt we can do it -- tompop ToDo
        mbWrap.Close();
#endif


    }
    catch ( CException e )
     {
     }

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);

    return (TRUE);
    
}







#if defined(DEBUGGING)
void test_Reg_GetSetName()
{
    CString  newValue=_T("Tommy Boy");
    BOOL bSet =
    Reg::HKEYLM::SetNameValue("Software\\Microsoft\\Keyring\\Parameters",
                               "UserName",
                               newValue);
        ASSERT( bSet==TRUE );

    CString  readValue;
    BOOL bGet =
    Reg::HKEYLM::GetNameValue("Software\\Microsoft\\Keyring\\Parameters",
                               "UserName",
                               readValue);
        ASSERT( bSet==TRUE );

    DEBUG_MSGBOX( (buff, "After calling SetNameValue/SetNameValue; val=%s"
                         "bSet=%d, bGet=%d",
                        (const char*) readValue, (int)bSet, (int)bGet ));
    // the above will test the GetName value and read the 
}
#endif 


void test__CEasyFileDialog();

void  test__itemsWeDependOn(IN OUT ADMIN_INFO& info, USHORT iButton)
{

#if defined(DEBUGGING)
    // note that if you need the meta base wrapper directly
    //      its available as [CWrapMetaBase&] info.mbWrap



       

#if  0  // ----- use this for testing
    BOOL  bTest_Reg_GetSetName = FALSE;
    if (bTest_Reg_GetSetName)
    {
        test_Reg_GetSetName();
    }
#endif //0 ----- use this for testing

    
#if  0  // ----- use this for testing
    ///////////////////  this starts the test of Boydm's MetaBaseWrapper ///
    
    BOOL            fAnswer = FALSE;
    PVOID           pData = NULL;
    DWORD           cbData = 0;

    // attempt to open the object we want to store into
    CWrapMetaBase& mbWrap = info.meta.m_mbWrap;
    BOOL f = mbWrap.Open( m_szServerInstance, METADATA_PERMISSION_READ );

    // if opening the metabase worked, load the data
    if ( f )
        {
        // first, get the size of the data that we are looking for
        pData = mbWrap.GetData( "", 1002, IIS_MD_UT_SERVER, STRING_METADATA, &cbData );
        //             "keytype" is 1002 -- this is just a test
        //              It uses a BINARY_METADATA  is another type
        //               BINARY_METADATA  is another type -- all types are shown
        //               in the comments below, see file MdDefW.h for details
        //  
        //  
        //   enum METADATATYPES
        //      {   ALL_METADATA    = 0,
        //      DWORD_METADATA  = ALL_METADATA + 1,
        //      STRING_METADATA = DWORD_METADATA + 1,
        //      BINARY_METADATA = STRING_METADATA + 1,
        //      EXPANDSZ_METADATA   = BINARY_METADATA + 1,
        //      MULTISZ_METADATA    = EXPANDSZ_METADATA + 1,
        //      INVALID_END_METADATA    = MULTISZ_METADATA + 1
        //      };

        //   if you want you could use our MBPdata_Wrapper to protect
        //   it automatically
        //
        //   Util::MBPdata_Wrapper  a(mbWrap,  pData );

        // if we successfully got the data, unserialize it
        if ( pData )
            {
            // === the following stuff  +  the mbWrap setup code came
            //     from an example in file 'Issudlg.cpp'  see that for
            //     another example.
            //
            //PUCHAR pchData = (PUCHAR)pData;
            //fAnswer = m_Store.Unserialize( &pchData, &cbData );
            }

        // close the object
        f = mbWrap.Close();

        // cleanup
        if ( pData )
            mbWrap.FreeWrapData( pData );
     }
     ///////////////////  this ends the test of Boydm's MetaBaseWrapper ///
#endif //0 ----- use this for testing



#if  0  // ----- use this for testing
    // next we will test our Set/Get Strings on mb prop: MD_SSL_CTL_CONTAINER

    { //MD_SSL_CTL_CONTAINER

        const TCHAR*  szDATA = _T("Tom");
        BOOL f1= SetMetaBaseString ( info, MD_SSL_CTL_CONTAINER, szDATA);

        CString   szReadTom;
        BOOL f2= GetMetaBaseString ( info, MD_SSL_CTL_CONTAINER, szReadTom);

        BOOL f3= (szReadTom == szDATA);

        if ( !( f1  &&  f2  &&  f3)) {
                DEBUG_MSGBOX( (buff, _T("MD_SSL_CTL_CONTAINER prop get/set failed --"
                                     "you have trouble in the MB; Details: %s %s %s"),
                                    Map::Boolean2String(f1),
                                    Map::Boolean2String(f2),
                                    Map::Boolean2String(f3) ));
         }
     }
#endif //0 ----- use this for testing

                                     
    
#if  0  // ----- use this for testing
    // lets see if IIS is up by looking for the following metabase props:
    //
    //   MD_SECURE_BINDINGS is for SECURE server address/port
    //   MD_SERVER_BINDINGS is for non secure server address/port
    //
    {
        CString   szSecureBindings;
        CString   szServerBindings;
        if (   (TRUE == GetMetaBaseString ( info, MD_SECURE_BINDINGS, szSecureBindings))
            && (TRUE == GetMetaBaseString ( info, MD_SERVER_BINDINGS, szServerBindings)))
          {
                DEBUG_MSGBOX( (buff, _T("Looks like IIS is on the machine since we have"
                                      "SERVER_BINDINGS of [%s] and SECURE_BINDINGS of [%s]"),
                                   szServerBindings,  szSecureBindings
                                   //Util::StringOrNil(szServerBindings),  Util::StringOrNil(szSecureBindings)
                                   ));
          }
    }

    DODBG if (NoYesMsgBox(_T("Do You Want to CLEAR out the MetaBase History to GROUND ZERO?") ))
    {
        ClearHistoryState(info);
        DisplayInfoStruct(info);

        if (NoYesMsgBox(_T("Do You Want to SET ALL the bits in the history that deal"
                            "with historyStateSSS bits?  Then see the info printout?") ))
        {
            ClearHistoryState(info);

            SetCertInstalled(info);
            SetOOBCertReq(info);
            SetCTLInstalled(info);
            SetOutstandingRenewalReq(info);

            DisplayInfoStruct(info);

            if (NoYesMsgBox(_T("NEXT Do You Want to CLEAR ALL the bits in the history that deal"
                                "with historyStateSSS bits?  Then see the info printout?") ))
            {
                ClearCertInstalled(info);
                ClearOOBCertReq(info);
                ClearCTLInstalled(info);
                ClearOutstandingRenewalReq(info);
               DisplayInfoStruct(info);
             }
        }
    }

    BOOL  bTest_LoadStrings = FALSE;
    if (bTest_LoadStrings)  Easy::CString::Test_LoadString();
#endif //0 ----- use this for testing


#if  0  // ----- use this for testing
    
    if (YesNoMsgBox(_T("Do You Want to Run the CTL Wizard") ) )
    {  
         // Run the CTL Wizard
        //  v--- was setup in the routine that called RunDialogs4OnClick
        //  info(mbWrap);                 // main status board in the
                                          // wizards
           
        //run the create CTL wizard. We start by declaring all the pieces of it
        CPropertySheet          propsheet_mux(IDS_TITLE_CREATE_CTL_WIZ);
        CTLWelcome              page_welcome;
        CTLMuxPg                page_multiplexer(info);
        CPropertyPage           stubTipsPage(IDD_TIPS_BEFORE__CTL_WIZARD);
        // clear the help button bits
        if ( propsheet_mux.m_psh.dwFlags & PSH_HASHELP )
            propsheet_mux.m_psh.dwFlags &= ~PSH_HASHELP;
        page_welcome.m_psp.dwFlags &= ~(PSP_HASHELP);
        page_multiplexer.m_psp.dwFlags &= ~(PSP_HASHELP);
        stubTipsPage.m_psp.dwFlags &= ~(PSP_HASHELP);

        // add the pages to the property sheet that says Welcome, and the
        // Mux (aka multiplexing) page...
        propsheet_mux.AddPage( &page_welcome );
        propsheet_mux.AddPage( &page_multiplexer );
        propsheet_mux.AddPage( &stubTipsPage );
        
        // set the wizard property
        propsheet_mux.SetWizardMode();

        // run the property sheet
        int i = IDCANCEL;
        i = propsheet_mux.DoModal();
        if ( i != IDCANCEL )
        {


#if defined(DEBUGGING)
            DODBG MsgBox( _T("CTL muxer dialog box works and returned OK" ) );
 #endif
       }
        
    }



//      if (bCall_test__CEasyFileDialog)  test__CEasyFileDialog();
#endif //0 ----- use this for testing

#endif

}


//------------------------------------------------------------------
// NKAddPageToWizard -- just like WizMngr::AddPageToWizard in that
//                   it adds CPropertyPage [CNKPages nkpg2Add] to Wizard [psWizard]
//                   making sure that the [pg2Add] has its help button
//                   turned OFF!
//
//                It also binds the wizard property sheet page [psWizard]
//                to member [m_pPropSheet] of the CNKPages object.
//
//                This is used to add our pages to the Wizard below
//------------------------------------------------------------------
void CCertAuthCtrl::NKAddPageToWizard(IN ADMIN_INFO& info, IN CNKPages* nkpg2Add, IN OUT CPropertySheet* psWizard)
{
    // add the pages to the wizard property sheet AND make no help button
    AddPageToWizard(nkpg2Add, psWizard);

    nkpg2Add->m_pPropSheet = psWizard;
}

#if defined(DEBUGGING)
void test__Rons_WizClasses(IN ADMIN_INFO& info)
{
    CIISWizardSheet     propsheet_mux(IDB_BITMAP_STD_LEFT,
                                                    IDB_BITMAP_TOP);
    CNKWelcome              page_welcome(info);
    CNKMuxPg                page_multiplexer(info);
    propsheet_mux.AddPage( &page_welcome );
    propsheet_mux.AddPage( &page_multiplexer );

    DEBUG_MSGBOX( (buff, _T("Get Ready using real Ron's CIISWizardSheet\n")));

    int i   = propsheet_mux.GetPageCount();
    void* p =  propsheet_mux.GetPage(i-1);

    
    DEBUG_MSGBOX( (buff, _T("%s %d  -- using real Ron's\n"
                    " GetPageCount()=%d  GetPage(%d)=%#lx"), __FILE__, __LINE__,
                    i, i-1, (DWORD)p));
}
#endif //defined(DEBUGGING)

#if defined(DEBUGGING)
void test__nonRons_WizClasses(IN ADMIN_INFO& info)
{
    CPropertySheet    propsheet_mux;
    
    CNKWelcome              page_welcome(info);
    CNKMuxPg                page_multiplexer(info);
    propsheet_mux.AddPage( &page_welcome );
    propsheet_mux.AddPage( &page_multiplexer );

    int i   = propsheet_mux.GetPageCount();
    void* p =  propsheet_mux.GetPage(i-1);

    
    DEBUG_MSGBOX( (buff, _T("%s %d  -- using real CPropertySheet\n"
                    " GetPageCount()=%d  GetPage(%d)=%#lx\n"), __FILE__, __LINE__,
                    i, i-1, (DWORD)p));
}
#endif //defined(DEBUGGING)

#if defined(DEBUGGING)
void test__non2Rons_WizClasses()
{
    DEBUG_MSGBOX( (buff, _T("Sizeof CPropertySheet=%d,CPropertyPage=%d\n"),
                    sizeof(CPropertySheet),sizeof(CPropertyPage)));

    CPropertySheet    propsheet_mux;
    
    CPropertyPage              page_welcome;
    CPropertyPage              page_multiplexer;
    propsheet_mux.AddPage( &page_welcome );
    propsheet_mux.AddPage( &page_multiplexer );

    int i   = propsheet_mux.GetPageCount();
    DEBUG_MSGBOX( (buff, _T("Get Ready using real CPropertySheet,CPropertyPage\n")));
    void* p =  propsheet_mux.GetPage(i-1);

    DEBUG_MSGBOX( (buff, _T("%s %d  -- using real CPropertySheet,CPropertyPage\n"
                    " GetPageCount()=%d  GetPage(%d)=%#lx\n"), __FILE__, __LINE__,
                    i, i-1, (DWORD)p));
}
#endif //defined(DEBUGGING)

////////////////////////////////////////////////////////////////////////
//  _RunDialogs4OnClick -- main handler for our dialogs
//
//  Parms:  mbWrap:  ref to a MetaBase Wrapper that is properly initialized
//                   and points to the SERVER node that we are operating in.
//          iButton: tells what "logical button" fired our control:
//                   0=Get-Cert     1=Edit
////////////////////////////////////////////////////////////////////////
BOOL CCertAuthCtrl::_RunDialogs4OnClick(IN OUT ADMIN_INFO& info, USHORT iButton)
{

#if defined(DEBUGGING) && defined(SHOW_TRACE_INFO)
    Trace   t( _T("CCertAuthCtrl::_RunDialogs4OnClick"));
#endif


#if defined(DEBUGGING)
    checkSanityMFC();
#endif
    
    // EnumCertServerObjects is now our std locate-all-cert-servers available method
    // it enumerates CertServers the metabase for CertServers
    // that are configured correctly and stores a mapping to GUID
    // strings in our 'info.map_CertServerNameToGUIDmap' structure
    EnumCertServerObjects(info);

    // The following will call is used to debug what we depend upon
    test__itemsWeDependOn(info, iButton);

#if defined(DEBUGGING)
    if (DebugTestEnv(_T("MFC")) && YesNoMsgBox(_T("Shall we run: test__Rons_WizClasses"))) {
        test__Rons_WizClasses(info);
    }
#endif


    // ToDo:  we need to change this to buttons
                                        // in a particular call
    //  we should do something like:  if (iButton==1)
    //  for testing you can do    YesNoMsgBox(_T("Do You Want to Run the CertWizard"))
    {
#if defined(DEBUGGING) && defined(SHOW_TRACE_INFO)
    Trace   t( _T("In AuthCtl.cpp -- stack frame launching the propsheet_mux wiz."));
#endif


        // v--- was setup in the routine that called RunDialogs4OnClick
        //ADMIN_INFO   info(mbWrap);        // main status board in the
        //                                  // wizards
           
        //run the create key wizard. We start by declaring all the pieces of it
#ifdef  USE_COMPROP_WIZ97
        CIISWizardSheet     propsheet_mux(IDB_BITMAP_STD_LEFT,
                                                        IDB_BITMAP_TOP);
//         CString szIDS_TITLE_CREATE_WIZ;
//         Easy::Load(szIDS_TITLE_CREATE_WIZ, IDS_TITLE_CREATE_WIZ);
//         propsheet_mux.SetTitle(szIDS_TITLE_CREATE_WIZ);
#else
        CPropertySheet          propsheet_mux( IDS_TITLE_CREATE_WIZ );
#endif

        CNKWelcome              page_welcome(info);
        CNKMuxPg                page_multiplexer(info);

        // Living within info is 'wizMngr' -- this manages the Wizard.  See
        // file WizMngr.cpp for more info.  We need to instruct it what the
        // property sheet is and also where the error page lives.  At this
        // time the only valid pages are the Welcome + Completion + Error 

        WizMngr&  wizMngr = info.wizMngr;
        
        wizMngr.Attach( &propsheet_mux );


        wizMngr.SetErrorPageIndex( WZ_PAGE__GENERIC_ERROR_PAGE );
        wizMngr.SetDonePageIndex(  WZ_PAGE__GENERIC_COMPLETION_PAGE );
        // then later info.wizMngr.ShowDonePage(); will display this completion pg.
        wizMngr.Enable(0,0);    // enable welcome page
        wizMngr.Enable(WZ_PAGE__GENERIC_COMPLETION_PAGE, // Enable our generic
                       WZ_PAGE__GENERIC_ERROR_PAGE);  // Completion-Error page

        
         // the following define the new Server pages
        CNKChooseCA             page_Choose_CA(info);
        CNKKeyInfo              page_Key_Info(info);
        CNKDistinguishedName    page_DN(info);
        CNKDistinguishedName1   page_DN1(info);
        CNKDistinguisedName2    page_DN2(info);
        CNKUserInfo             page_User_Info(info);
        CNKFileInfo             page_File_Info(info);


        // lets warn the user that crytpo is not enabled, GetMaxKeySize will
        // return 0 if no ENCRYPTION is ALLOWED
        //----------------------------------------------
        KeySize  keySize;   // fncts GetMaxKeySize and ComputeKeyAlgMinMaxStep return
                            // this as an OUT parameter.
        if (0 == page_Key_Info.GetMaxKeySize(OUT keySize) ) {
            MsgBox( IDS_ENCRYPTION_NOT_ALLOWED_BASED_ON_THE_MACHINE_CONFIG_DATA );
            //"Encryption is not allowed based on the machine configuration data."END

            return FALSE;
        }

        /////////////////////////////////////////////////////////////////////////////
        // the following 2 Classes contain PropertyPages for the Finish the offline/OOB
        // cert request
        //
        // class CFinCertImport is the 1st & only Property Sheet for "Finish OOB"
        //  (gathers data).  it also verifies and asks the user:
        // are you "ready to "FINISH" and do the conversion
        /////////////////////////////////////////////////////////////////////////////
        CFinCertImport     getFileInfoPage(info);


        // End the above list of "all possible wizard pages" with the
        // completion page then the Error page.  Error always has to be last!
        // Note also that this completion page is the "default" completion
        //      page.  Some sub-wizard might have a more appropriate specialized
        //      page for completion
        CCompletionPage         page_GenericCompletion(info);
        CWizError               page_GenericErrorPage(info);

        info.wizErrorDlg = &page_GenericErrorPage;
        
        // clear the help button bits on the PropertySheet and all Prop
        // pages.  We handle the clearing for each page in the funct AddPageToWizard
        if ( propsheet_mux.m_psh.dwFlags & PSH_HASHELP )
             propsheet_mux.m_psh.dwFlags &= ~PSH_HASHELP;

        // add the pages to the property sheet that says Welcome, and the
        // Mux (aka multiplexing) page...  The AddPageToWizard will do an
        // AddPage on the property sheet and also specify that we dont want
        // any help buttons

        
        NKAddPageToWizard(info, &page_welcome,     &propsheet_mux );    //index:0:WZ_PAGE__WELCOME
        
        //this is for the New Cert Wizard                   
        NKAddPageToWizard(info, &page_multiplexer, &propsheet_mux );  //index:1:WZ_PAGE__CERTMUX
        NKAddPageToWizard(info, &page_Choose_CA,   &propsheet_mux ); 
        NKAddPageToWizard(info, &page_Key_Info,    &propsheet_mux ); 
        NKAddPageToWizard(info, &page_DN,          &propsheet_mux ); 
        NKAddPageToWizard(info, &page_DN1,         &propsheet_mux ); 
        NKAddPageToWizard(info, &page_DN2,         &propsheet_mux ); 
        NKAddPageToWizard(info, &page_User_Info,   &propsheet_mux );   
        NKAddPageToWizard(info, &page_File_Info,   &propsheet_mux );  //index:8:WZ_PAGE__SUCCESS_PAGE
        //this is for finishing the SELECT_EXISTING_CERT page -- request
        CCertSelect                page_CertSelect(info);
       NKAddPageToWizard(info, &page_CertSelect,  &propsheet_mux );    //index:9:WZ_PAGE__SELECT_EXISTING_CERT_PAGE
        //this is for finishing the IMPORT_KEYRING page -- request
        CKeyImpt                gatherData(info);
       NKAddPageToWizard(info, &gatherData,  &propsheet_mux );    //index:10:WZ_PAGE__IMPORT_KEYRING_CERT_PAGE


        //this is for finishing the OOB request
        CNKMuxPg2                page_OOBmultiplexer(info);
        CNKMuxPg                FAKE8page_multiplexer(info);
       NKAddPageToWizard(info, &page_OOBmultiplexer,  &propsheet_mux );//index:11:WZ_PAGE__OOB_CERTMUX
       NKAddPageToWizard(info, &getFileInfoPage,  &propsheet_mux );      //index:12:WZ_PAGE__OOB_FINCERT_GETFILENM
       NKAddPageToWizard(info, &FAKE8page_multiplexer,  &propsheet_mux ); //index:13:WZ_PAGE__OOB_FINCERT_DISREGARD_OOB_REQ
        // tompop:  we dont need the FAKE8page_multiplexer and need to
        //          shift everything down
        
        //this is for finishing the MODIFYEXISTING request
        CNKMuxPg3               page_modifyExisting_multiplexer(info);
        //--- this is part of the 3rd mux page for "ModifyExisting|Renew"
        CNKChooseCA             renewPage_Choose_CA(info);//reuse a pg from ncw
        CNKUserInfo             renewPage_User_Info(info);//reuse a pg from ncw
                    // note that the above page plays double duty as it senses
                    //      that its used to renew a cert and displays a finish
                    //      page behavior.
        CNKFileInfo           renewPage_File_Info(info);// page:WZ_PAGE__MODIFYEXISTING_CERTRENEW_OOB_INSTRUCTIONS
        //--- this is part of 3rd mux page for "ModifyExisting|delete-cert"
        CDeleteCert             page_deleteCert(info);
        //--- the last part of 3rd mux page, enables the new Cert Wizard!
        //    it does not have any pages
       NKAddPageToWizard(info, &page_modifyExisting_multiplexer,  &propsheet_mux ); //index:13:WZ_PAGE__MODIFYEXISTING_CERTMUX
       NKAddPageToWizard(info, &renewPage_Choose_CA,  &propsheet_mux ); //index:14:WZ_PAGE__MODIFYEXISTING_CERTRENEW_CA
       NKAddPageToWizard(info, &renewPage_User_Info,  &propsheet_mux ); //index:15:WZ_PAGE__MODIFYEXISTING_CERTRENEW_Contact
       NKAddPageToWizard(info, &renewPage_File_Info,  &propsheet_mux ); //index:15:WZ_PAGE__MODIFYEXISTING_CERTRENEW_Contact
       NKAddPageToWizard(info, &page_deleteCert,  &propsheet_mux ); //index:16:WZ_PAGE__MODIFYEXISTING_CERTDELETE
        
        NKAddPageToWizard(info, &page_GenericCompletion, &propsheet_mux );//index:17:WZ_PAGE__GENERIC_COMPLETION_PAGE
        NKAddPageToWizard(info, &page_GenericErrorPage , &propsheet_mux );//index:18:WZ_PAGE__GENERIC_ERROR_PAGE

        
        // set the wizard property
        propsheet_mux.SetWizardMode();

        //before we start running the Wizard we need to enable exactly
        //one of the possible SubWizards
        pick_Correct_SubWizard(info);

        // run the property sheet
#define HR_FAIL_SOME_EXCEPTION_HAPPENED  0x666      // very unlikely value
        int i = HR_FAIL_SOME_EXCEPTION_HAPPENED;
        

    if ( DebugTestEnv(DebugTestEnv_noTRY) )  {


#if defined(DEBUGGING) && defined(SHOW_TRACE_INFO)
         Trace   t( _T("propsheet_mux.DoModal() -- running the wizard"));
#endif


                i = propsheet_mux.DoModal();

    } else {
            try {
                
#if defined(DEBUGGING) && defined(SHOW_TRACE_INFO)
        Trace   t( _T("propsheet_mux.DoModal() -- running the wizard"));
#endif


                i = propsheet_mux.DoModal();
            }
            catch (...) {
                if (i==HR_FAIL_SOME_EXCEPTION_HAPPENED)  i=IDCANCEL;

                //----------------------------------------------------
                DoDebugBreak();  // see if we should do a debug break

                MsgBox( IDS_CAUGHT_AN_UNKNOWN_EXCEPTION );
            }
        }
        
        if ( i == IDCANCEL )
        {
#if defined(DEBUGGING)
            DODBG MsgBox( _T("Cert muxer dialog box works and returned IDCANCEL" ) );
#endif

        } else if ( i != IDOK )
        {


#if defined(DEBUGGING)
            DODBG MsgBox( _T("Cert muxer dialog box works and returned OK" ) );
#endif
        } else 
        {


#if defined(DEBUGGING)
            TCHAR szTmp[200];
            wsprintf(szTmp, _T("Cert muxer dialog box returned strange return value"
                                " of %d=%#x"), i, i );
            DODBG MsgBox( szTmp );
#endif
        }
        //MsgBox( "DBG: done w/  Cert Wiz block");


//         // if we want to do a completion page now...  [HOWEVER THIS DOES NOT PRODUCE A GOOD LOOKING COMPL.PG]
//         int  dialogID =  IDD_COMPLETION_PAGE;
//         
//         {
//             CDialog   dlg( dialogID );
//             dlg.DoModal();
//         }

    }

    return TRUE;
}
    //  test the CryptUIWizBuildCTL functions...

    //From CryptUI.h//  //-----------------------------------------------------------------------
    //From CryptUI.h//  // 
    //From CryptUI.h//  // CryptUIWizBuildCTL
    //From CryptUI.h//  //
    //From CryptUI.h//  //  Build a new CTL or modify an existing CTL.   The UI for wizard will
    //From CryptUI.h//  //  always show in this case
    //From CryptUI.h//  //
    //From CryptUI.h//  //
    //From CryptUI.h//  //  dwFlags:            IN  Optional:   Can be set to the following:
    //From CryptUI.h//  //                                      CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION.  This flag
    //From CryptUI.h//  //                                      is valid only when pBuildCTLDest is set               
    //From CryptUI.h//  //  hwndParnet:         IN  Optional:   The parent window handle               
    //From CryptUI.h//  //  pwszWizardTitle:    IN  Optional:   The title of the wizard 
    //From CryptUI.h//  //                                      If NULL, the default will be IDS_BUILDCTL_WIZARD_TITLE
    //From CryptUI.h//  //  pBuildCTLSrc:       IN  Optional:   The source from which the CTL will be built               
    //From CryptUI.h//  //  pBuildCTLDest:      IN  Optional:   The desination where the newly        
    //From CryptUI.h//  //                                      built CTL will be stored               
    //From CryptUI.h//  //  ppCTLContext:       OUT Optaionl:   The newly build CTL                    
    //From CryptUI.h//  //  
    //From CryptUI.h//  //------------------------------------------------------------------------
    //From CryptUI.h//  BOOL
    //From CryptUI.h//  WINAPI
    //From CryptUI.h//  CryptUIWizBuildCTL(
    //From CryptUI.h//      IN              DWORD                                   dwFlags,            
    //From CryptUI.h//      IN  OPTIONAL    HWND                                    hwndParent,         
    //From CryptUI.h//      IN  OPTIONAL    LPCWSTR                                 pwszWizardTitle,    
    //From CryptUI.h//      IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO         pBuildCTLSrc,
    //From CryptUI.h//      IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO        pBuildCTLDest,     
    //From CryptUI.h//      OUT OPTIONAL    PCCTL_CONTEXT                           *ppCTLContext       
    //From CryptUI.h//  );

    //From CryptUI.h//  
    //From CryptUI.h//  Bugs:
    //From CryptUI.h//  
    //From CryptUI.h//  After calling LocalEnroll we get a HRESULT return value of
    //From CryptUI.h//  0x80004005
    //From CryptUI.h//


    // when we finish the enrollment we should see that the Cert gets installed into:
    //
    // HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\SystemCertificates\Trust\CTLs
      

class CCertAuthCtrl;



#if defined(DEBUGGING)
void test__CEasyFileDialog()
{

    CString msg(_T("This will test a Reading EASY CFileDialog"));
    AfxMessageBox( msg );

    CEasyFileDialog  readDlg(CEasyFileDialog::Reading,
                             CEasyFileDialog::FileOpen,
                             IDS_KEY_OR_CERT_FILE_FILTER);
        // The IDS_KEY_OR_CERT_FILE_FILTER string is defined as:
        // "Certificate Import or backup file!*.cbk!KeyRing backup!*.krb!Any Certificate File Type!*.*!!"
        // and provides a way to locate a keyRing/Cert file to import.
        // Users could be ad-hock in how they named the files...

    readDlg.SetTitle(_T("This is a test of the CEasyFileDialog:Reading"));

    if (readDlg.DoModal() == IDOK)  AfxMessageBox( readDlg.GetPathName() );


    CEasyFileDialog  writeDlg(CEasyFileDialog::Writing, 
                             CEasyFileDialog::FileSaveAs,
                             _T("My C Files(*.cpp)!*.cpp!My H Files(*.h)!*.h!!"));

   //   ::MessageBox(NULL, "Body-- after we constructed the writeDlg: via msgBox", "title", MB_OK );


     AfxMessageBox( _T("In this test we are calling 'writeDlg.DoModal()' and"
                "have coded it so that it will grab the extension of the first"
                "extension in the list of file specs, i.e. *.cpp so that if you"
                "dont enter an extension it will use .cpp and append this for you"
                "give  it a try   tjp tompop bug:  for some reason the dialog is"
                "not showing the \"Default Extension\" part of the FileDialog box"
                "\n"
                "Note also that the default ext is pretty brain dead in that if"
                "the default extension is *.cpp and you enter a FileName of story.book"
                "the Dialog will return a file name of \"story.book.cpp\"!!!"
                "\n\n"
                "Try picking a .cpp or swich the type and grab a *.h as we use"
                "the following spec for the file types"
                "\n"
                "\t\"My C Files(*.cpp)!*.cpp!My H Files(*.h)!*.h!\""
                "\n"
                "Try entering:  foo.h  foo.cpp and foo.bak"
                "\n"
                "Try entering:  foo.h  foo.cpp and foo.bak"
                "\n\n"
                "Then try just foo  once with the \"My H Files\" and"
                "once w/ your C files and ALL SHOULD WORK."));

    if (writeDlg.DoModal() == IDOK)  AfxMessageBox( writeDlg.GetPathName() );
    
}
#endif //defined(DEBUGGING)

*/


 //---------------------------------------------------------------------------
void CCertAuthCtrl::SetServerInstance(LPCTSTR szServerInstance) 
    {
    m_szServerInstance = szServerInstance;
    //MsgBox( m_szServerInstance,  _T("m_szServerInstance") );
    }

//---------------------------------------------------------------------------
void CCertAuthCtrl::SetMachineName(LPCTSTR szMachine) 
    {
    m_szMachineName = szMachine;
    //MsgBox( m_szMachineName,  _T("m_szMachineName") );
    }


//---------------------------------------------------------------------------
void CCertAuthCtrl::OnFontChanged() 
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }
//---------------------------------------------------------------------------
void CCertAuthCtrl::OnAmbientPropertyChange(DISPID dispid) 
    {
    BOOL    flag;
    UINT    style;

    // do the right thing depending on the dispid
    switch ( dispid )
        {
        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
                {
                style = GetWindowLong(
                        GetSafeHwnd(), // handle of window 
                        GWL_STYLE  // offset of value to retrieve 
                        );
                if ( flag )
                    style |= BS_DEFPUSHBUTTON;
                else
                    style ^= BS_DEFPUSHBUTTON;
                SetWindowLong(
                        GetSafeHwnd(), // handle of window 
                        GWL_STYLE,  // offset of value to retrieve 
                        style
                        );
                Invalidate(TRUE);
                }
            break;
        };

    COleControl::OnAmbientPropertyChange(dispid);
    }

//---------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CCertAuthCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo) 
    {
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

//---------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CCertAuthCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState) 
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }

//---------------------------------------------------------------------------
void CCertAuthCtrl::OnMnemonic(LPMSG pMsg) 
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//---------------------------------------------------------------------------
void CCertAuthCtrl::OnTextChanged() 
    {
    DWORD   i;
    ACCEL   accel;
    BOOL    f;
    BOOL    flag;
    int     iAccel;

    // get the new text
    CString sz = InternalGetText();
    sz.MakeLower();

    // if the handle has already been allocated, free it
    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    // if there is a & character, then declare the accelerator
    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        // fill in the accererator record
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (WORD)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;
        }

    // finish with the default handling.
    COleControl::OnTextChanged();
    }

//////////////////////////////////////////////////////////////////////////////
//                            FYI ONLY                                      //
//  This RunAuthoritiesDialog()  is Boydm's old starting point for the      //
//  original AuthoritiesDialog.                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
//
//  //---------------------------------------------------------------------------
//  // run the dialog
//  void CCertAuthCtrl::RunAuthoritiesDialog()
//      {
//  //DebugBreak();
//      // prepare the machine name pointer
//      OLECHAR* poch = NULL;
//      if ( !m_szMachineName.IsEmpty() )
//          {
//          // allocate the name buffer
//          poch = (OLECHAR*)GlobalAlloc( GPTR, MAX_COMPUTERNAME_LENGTH * 2 );
//  
//          // unicodize the name into the buffer
//          if ( poch )
//              MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, m_szMachineName, -1,
//                              poch, MAX_COMPUTERNAME_LENGTH * 2 );
//          }
//  
//      // initialize the metabase wrappings - pass in the name of the target machine
//      // if one has been specified
//      IMSAdminBase* pMB = FInitMetabaseWrapper( poch );
//      if ( !pMB )
//              {
//              MessageBeep(0);
//              if ( poch ) GlobalFree( poch );
//              return;
//              }
//  
//      // clean up
//      if ( poch )
//          {
//          GlobalFree( poch );
//          poch = NULL;
//          }
//  
//      // if there is nothing in the MB_Path, default to the first instance
//      if ( m_szServerInstance.IsEmpty() )
//          m_szServerInstance = "/LM/W3SVC/1";
//  
//      // I am assuming that the last character is NOT a '/' Thus, if that is what is
//      // there, we need to remove it. Otherwise, the path gets messed up later
//      if ( m_szServerInstance.Right(1) == '/' )
//          m_szServerInstance = m_szServerInstance.Left( m_szServerInstance.GetLength()-1 );
//  
//      // set up the dialog
//      CSelectIssuersDlg   dlg(pMB);
//      dlg.m_pRule = NULL;
//      dlg.m_szMBPath = m_szServerInstance + SZ_NAMESPACE_EXTENTION;
//  
//      // Use our Fancy Debugging "Load String" found in Easy::CString
//      Easy::CString::LoadStringInto(dlg.m_sz_caption, IDS_TRUSTED_AUTHORITIES );
//      
//      // run the propdsheet dialog
//      // let the host container know that we are putting up a modal dialog
//      PreModalDialog();
//      // run the dialog
//      dlg.DoModal();
//      // let the host container know we are done with the modality
//      PostModalDialog();
//  
//      // close the metabase wrappings
//      FCloseMetabaseWrapper(pMB);
//      }
//  
//---------------------------------------------------------------------------





//-------------------------------------------------------------------------------
//  DoClick  -   process a click event.   This will be called by the IIS admin
//               API to launch us!   [people get here by clicking on our control]
//
//  PARAMS:     dwButtonNumber  an IN param. tells what "logical button" fired our control:
//
//              value
//              ------
//               1          Call CertWiz
//               2          Call CTL Wiz
//-------------------------------------------------------------------------------
void CCertAuthCtrl::DoClick(IN  long dwButtonNumber) 
{
    // TODO: Add your dispatch handler code here


    OnClick( (short) dwButtonNumber );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\amapppg.h ===
// AMapPpg.h : Declaration of the CAccountMapperPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CAccountMapperPropPage : See AMapPpg.cpp.cpp for implementation.

class CAccountMapperPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CAccountMapperPropPage)
    DECLARE_OLECREATE_EX(CAccountMapperPropPage)

// Constructor
public:
    CAccountMapperPropPage();

// Dialog Data
    //{{AFX_DATA(CAccountMapperPropPage)
    enum { IDD = IDD_PROPPAGE_MAPR1 };
    CString m_Caption;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CAccountMapperPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\brwsdlg.cpp ===
/*++

Module Name:

    brwsdlg.cpp

Abstract:

    Intermediate dialog class that provides basic NT user account browsing.
    It assumes that the dialog resource contains BOTH a IDC_BROWSE button
    and a IDC_ACCOUNT_NAME edit field. It maintains both of these items.

Author:

   Boyd Multerer boydm

--*/

#include "stdafx.h"
#include "certmap.h"
#include "brwsdlg.h"
#include "cnfrmpsd.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg dialog

//---------------------------------------------------------------------------
CNTBrowsingDialog::CNTBrowsingDialog( UINT nIDTemplate, CWnd* pParentWnd )
    : CDialog( nIDTemplate, pParentWnd )
    {
    //{{AFX_DATA_INIT(CNTBrowsingDialog)
    m_sz_accountname = _T("");
    m_sz_password = _T("");
    //}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
void CNTBrowsingDialog::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNTBrowsingDialog)
    DDX_Control(pDX, IDC_PASSWORD, m_cedit_password);
    DDX_Control(pDX, IDC_NTACCOUNT, m_cedit_accountname);
    DDX_Text(pDX, IDC_NTACCOUNT, m_sz_accountname);
    DDX_Text(pDX, IDC_PASSWORD, m_sz_password);
    //}}AFX_DATA_MAP
//  DDX_Control(pDX, IDC_PASSWORD, m_cedit_password);
    }

//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CNTBrowsingDialog, CDialog)
    //{{AFX_MSG_MAP(CNTBrowsingDialog)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_PASSWORD, OnChangePassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNTBrowsingDialog message handlers


//---------------------------------------------------------------------------
BOOL CNTBrowsingDialog::OnInitDialog()
  {
    m_bPassTyped = FALSE;
    m_szOrigPass = m_sz_password;
    if ( !m_sz_password.IsEmpty() ) 
    {
        m_sz_password.LoadString( IDS_SHOWN_PASSWORD );
    }
    return CDialog::OnInitDialog();
  }

//---------------------------------------------------------------------------
// run the user browser
void CNTBrowsingDialog::OnBrowse() 
    {
    GetIUsrAccount(NULL, this, m_sz_accountname);
    UpdateData(FALSE);
//    CSingleUserBrowser browser(m_hWnd, IDS_NTBROWSE_TITLE);
//    if ( browser.DoModal() == IDOK )
//        {
//        UpdateData( TRUE );
//        m_sz_accountname = browser.m_sz_account;
//        UpdateData( FALSE );
//        }
    }

//---------------------------------------------------------------------------
// make sure that the selected NT acount is, in fact, a valid account
// 
void CNTBrowsingDialog::OnOK() 
    {
    // update the data
    UpdateData( TRUE );

    // see if the account name is empty
    if ( m_sz_accountname.IsEmpty() )
        {
        AfxMessageBox( IDS_WANTACCOUNT );
        m_cedit_accountname.SetFocus();
        m_cedit_accountname.SetSel(0, -1);
        return;
        }

    // validate the password
    if ( m_bPassTyped )
        {
        CConfirmPassDlg dlgPass;
        dlgPass.m_szOrigPass = m_sz_password;
        if ( dlgPass.DoModal() != IDOK )
            {
            m_cedit_password.SetFocus();
            m_cedit_password.SetSel(0, -1);
            return;
            }
        }
    else
        {
        // restore the original password instead of the
        // standard ****** string
        m_sz_password = m_szOrigPass;
        UpdateData( FALSE );
        }


    // although it would seem to be a nice thing to do to verify the password and
    // account - it is VERY difficult, if not impossible, to do on a remote machine

    // it is valid
    CDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CNTBrowsingDialog::OnChangePassword() 
    {
    // TODO: If this is a RICHEDIT control, the control will not
    // send this notification unless you override the CNTBrowsingDialog::OnInitDialog()
    // function to send the EM_SETEVENTMASK message to the control
    // with the ENM_CHANGE flag ORed into the lParam mask.
    m_bPassTyped = TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\certctl.h ===
// CertCtl.h : Declaration of the CCertmapCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl : See CertCtl.cpp for implementation.

class CCertmapCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCertmapCtrl)

// Constructor
public:
    CCertmapCtrl();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCertmapCtrl)
    public:
    virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
    virtual void DoPropExchange(CPropExchange* pPX);
    virtual void OnResetState();
    virtual void OnClick(USHORT iButton);
    virtual void OnFontChanged();
    virtual void OnAmbientPropertyChange(DISPID dispid);
    virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
    virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
    virtual void OnMnemonic(LPMSG pMsg);
    virtual void OnTextChanged();
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
protected:
    ~CCertmapCtrl();

    // the whole point of the control
    void RunMappingDialog();


    DECLARE_OLECREATE_EX(CCertmapCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCertmapCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCertmapCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCertmapCtrl)        // Type name and misc status

// Message maps
    //{{AFX_MSG(CCertmapCtrl)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCertmapCtrl)
    afx_msg void SetServerInstance(LPCTSTR szServerInstance);
    afx_msg void SetMachineName(LPCTSTR szMachineName);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CCertmapCtrl)
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

    // Subclassed control support
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCertmapCtrl)
    dispidSetServerInstance = 1L,
    dispidSetMachineName = 2L,
    //}}AFX_DISP_ID
    };

    CString     m_szServerInstance;
    CString     m_szMachineName;
    BOOL        m_fUpdateFont;

        // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\certppg.h ===
// CertPpg.h : Declaration of the CCertmapPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage : See CertPpg.cpp.cpp for implementation.

class CCertmapPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CCertmapPropPage)
    DECLARE_OLECREATE_EX(CCertmapPropPage)

// Constructor
public:
    CCertmapPropPage();

// Dialog Data
    //{{AFX_DATA(CCertmapPropPage)
    enum { IDD = IDD_PROPPAGE_CERTMAP };
    CString m_Caption;
    CString m_szPath;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CCertmapPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\authppg.cpp ===
// CertAuthPpg.cpp : Implementation of the CCertAuthPropPage property page class.

#include "stdafx.h"
#include "certmap.h"
#include "AuthPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertAuthPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertAuthPropPage, COlePropertyPage)
    //{{AFX_MSG_MAP(CCertAuthPropPage)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertAuthPropPage, "CERTMAP.CertmapCtrl.2",
    0x996ff70, 0xb6a1, 0x11d0, 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage::CCertAuthPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertAuthPropPage

BOOL CCertAuthPropPage::CCertAuthPropPageFactory::UpdateRegistry(BOOL bRegister)
{
    if (bRegister)
        return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
            m_clsid, IDS_CERTAUTH_PPG);
    else
        return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage::CCertAuthPropPage - Constructor

CCertAuthPropPage::CCertAuthPropPage() :
    COlePropertyPage(IDD, IDS_CERTAUTH_PPG_CAPTION)
{
    //{{AFX_DATA_INIT(CCertAuthPropPage)
    m_sz_caption = _T("");
    //}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage::DoDataExchange - Moves data between page and properties

void CCertAuthPropPage::DoDataExchange(CDataExchange* pDX)
{
    //{{AFX_DATA_MAP(CCertAuthPropPage)
    DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
    DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
    //}}AFX_DATA_MAP
    DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\cauthppg.h ===
// CAuthPpg.h : Declaration of the CCertAuthPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage : See CAuthPpg.cpp.cpp for implementation.

class CCertAuthPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CCertAuthPropPage)
    DECLARE_OLECREATE_EX(CCertAuthPropPage)

// Constructor
public:
    CCertAuthPropPage();

// Dialog Data
    //{{AFX_DATA(CCertAuthPropPage)
    enum { IDD = IDD_PROPPAGE_MAPR2 };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CCertAuthPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\cauthctl.h ===
// CAuthCtl.h : Declaration of the CCertAuthorityCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CCertAuthorityCtrl : See CAuthCtl.cpp for implementation.

class CCertAuthorityCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCertAuthorityCtrl)

// Constructor
public:
    CCertAuthorityCtrl();

// Overrides

    // Drawing function
    virtual void OnDraw(
                CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);

    // Persistence
    virtual void DoPropExchange(CPropExchange* pPX);

    // Reset control state
    virtual void OnResetState();

// Implementation
protected:
    ~CCertAuthorityCtrl();

    DECLARE_OLECREATE_EX(CCertAuthorityCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCertAuthorityCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCertAuthorityCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCertAuthorityCtrl)      // Type name and misc status

    // Subclassed control support
    BOOL PreCreateWindow(CREATESTRUCT& cs);
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
    //{{AFX_MSG(CCertAuthorityCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCertAuthorityCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CCertAuthorityCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCertAuthorityCtrl)
        // NOTE: ClassWizard will add and remove enumeration elements here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DISP_ID
    };

private:
    BOOL fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\cnfrmpsd.cpp ===
// CnfrmPsD.cpp : implementation file
//
// NOTE that file Passdlg.h/cpp is very similar to this
//      file!
//
//       CnfrmPsD class has an OnOK that will complain
//       to the user if the passwds dont match
//       This is above whats in PassDlg class
//
//       And class PassDlg has an OnInitDialog that Cnfrmpsd
//       does not have. This simply puts focus on the edit
//       field for the passwd
//
#include "stdafx.h"
#include "certmap.h"
#include "CnfrmPsD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

CConfirmPassDlg::CConfirmPassDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CConfirmPassDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CConfirmPassDlg)
    m_sz_password_new = _T("");
    //}}AFX_DATA_INIT
    }

void CConfirmPassDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmPassDlg)
    DDX_Text(pDX, IDC_CONFIRM_PASSWORD, m_sz_password_new);
    //}}AFX_DATA_MAP
    }

BEGIN_MESSAGE_MAP(CConfirmPassDlg, CDialog)
    //{{AFX_MSG_MAP(CConfirmPassDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg message handlers

void CConfirmPassDlg::OnOK() 
    {
    UpdateData( TRUE );

    // confirm it
    if ( m_sz_password_new != m_szOrigPass )
        {
        AfxMessageBox( IDS_PASS_CONFIRM_FAIL );
        return;
        }

    CDialog::OnOK();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\certppg.cpp ===
// CertPpg.cpp : Implementation of the CCertmapPropPage property page class.

#include "stdafx.h"
#include "certmap.h"
#include "CertPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertmapPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertmapPropPage, COlePropertyPage)
    //{{AFX_MSG_MAP(CCertmapPropPage)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertmapPropPage, "CERTMAP.CertmapPropPage.1",
    0xbbd8f29c, 0x6f61, 0x11d0, 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32)


/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage::CCertmapPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertmapPropPage

BOOL CCertmapPropPage::CCertmapPropPageFactory::UpdateRegistry(BOOL bRegister)
{
    if (bRegister)
        return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
            m_clsid, IDS_CERTMAP_PPG);
    else
        return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage::CCertmapPropPage - Constructor

CCertmapPropPage::CCertmapPropPage() :
    COlePropertyPage(IDD, IDS_CERTMAP_PPG_CAPTION)
{
    //{{AFX_DATA_INIT(CCertmapPropPage)
    m_Caption = _T("");
    m_szPath = _T("");
    //}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage::DoDataExchange - Moves data between page and properties

void CCertmapPropPage::DoDataExchange(CDataExchange* pDX)
{
    //{{AFX_DATA_MAP(CCertmapPropPage)
    DDP_Text(pDX, IDC_CAPTIONEDIT, m_Caption, _T("Caption") );
    DDX_Text(pDX, IDC_CAPTIONEDIT, m_Caption);
    DDP_Text(pDX, IDC_MB_PATH, m_szPath, _T("MBPath") );
    DDX_Text(pDX, IDC_MB_PATH, m_szPath);
    //}}AFX_DATA_MAP
    DDP_PostProcessing(pDX);
}




/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\certmap.h ===
// certmap.h : main header file for CERTMAP.DLL

#if !defined( __AFXCTL_H__ )
    #error include 'afxctl.h' before including this file
#endif

#ifndef  _certmap_h_1234_
#define  _certmap_h_1234_


#include <iadmw.h>           // MetaBase Wrapper
#include <iis64.h>           // 64-bit helper stuff
#include "Wrapmb.h"          // CWrapMetaBase -- see below we also use CAFX_MetaWrapper
#include <iiscnfg.h>        // IIS config parameters like the MetaBase

// Boyd put a lot of efforts to make it hard to use iisui. Therefore I should
// put this declaration here instead of including the file
BOOL __declspec(dllimport)
GetIUsrAccount(
    IN  LPCTSTR lpstrServer,
    IN  CWnd * pParent,
    OUT CString & str
    );


/*
#include "Easy.h"           // do this before the "using namespace" decl

#include "Debug.h"           // Are we building a debugging build?
#include  "admin.h"         // defines the ADMIN_INFO an some handley #defines for the CN= strings


#include "Easy.h"           // do this before the "using namespace" decl
#include "Cookie.h"         // CCertmapCookie
#include "CTL.h"
#include "Certifct.h"

#include "WrpMBwrp.h"        // CAFX_MetaWrapper  derives from CWrapMetaBase
                             //  and provides a handy GetString method to set
                             //  strings directly.  Otherwise its CWrapMetaBase.

                            // property definitions and keywords
#include  "Meta.h"  // for general MetaBase constant definitions and error values


#include <wincrypt.h>
#include <cryptui.h>

//SkipThis// // We can not simply say:
//SkipThis// //    using namespace Easy;        // use the Easier to use
//SkipThis// // since the "less able" C++ compiler can not differentiate
//SkipThis// // between '::CString' and our Easier to use Easy::CString.  I wanted
//SkipThis// // Easy::CString to be used always and just say look in Easy first...
//SkipThis// //  This is easy to do w/ java by declaring a package and preInserting
//SkipThis// //  it in the class path ahead of the std libraries...
//SkipThis// 
//SkipThis// "#define  CString   Easy::CString"


        

//  Define  'USE_NEW_REG_METHOD'  if you  want us to use our new Reg::
//  methods to read and write strings to the registry...  The old code
//  that straight lines the calls to do this have sections like:
//   #ifdef  USE_NEW_REG_METHOD
//
//     //     Get entry in      ==path===      ==w/ name==    ==place here==
//     return Reg::GetNameValueIn(SZ_PARAMETERS, szValueName, sz,
//                               HKEY_CURRENT_USER);
//
//   #else   ////////////////////////////// use the old method ///////////////
//
//  so that you can choose whether to use the new method of the old one...
#define  USE_NEW_REG_METHOD



#include "Util.h"           // various utilites to help debug
*/

#include "resource.h"       // main symbols
#include "helpmap.h"       // main symbols


//#include "certcli.h"        // has ICertRequest COM interface definitions

/////////////////////////////////////////////////////////////////////////////
// CCertmapApp : See certmap.cpp for implementation.

class CCertmapApp : public COleControlModule
{
public:
    BOOL InitInstance();
    int ExitInstance();
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
};



extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
/*

#define _EXE_                //  We are building the EXE!
                             //  this is used in  "KeyObjs.h"  to
                             //  decide if we are importing or exporting
                             //  "KeyObjs.h" Classes.  We are the EXE,
                             //  aka the guy implementing the CService/etc objs.
#include "KeyObjs.h"
*/
#define         SZ_NAMESPACE_EXTENTION  "/<nsepm>"

/*
 extern void DisplaySystemError (HWND hParent, DWORD dwErr);  // see CTL.cpp
 extern BOOL MyGetOIDInfo (CString & string, LPCSTR pszObjId);
 extern HRESULT FormatDate (FILETIME utcDateTime, CString & pszDateTime);

 // the following fnct is used to move GUID strings out of the registry
 // and into the metabase.  Its called in the OnClick event for our OCX cntrl
 extern BOOL  MigrateGUIDS( ADMIN_INFO& info );

 #define   IDS_CERTIFICATE_MANAGER    IDS_CERTMAP
*/


#endif   /* _certmap_h_1234_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\cnfrmpsd.h ===
// CnfrmPsD.h : header file
//
// NOTE that file Passdlg.h is very similar to this
//      file!
//
//       CnfrmPsD class has an OnOK that will complain
//       to the user if the passwds dont match
//       This is above whats in PassDlg class
//
//       And class PassDlg has an OnInitDialog that Cnfrmpsd
//       does not have. This simply puts focus on the edit
//       field for the passwd
//
//
// DConfirmPassDlg.h : header file
//
#ifndef   _CnfrmPsdConfirmPassDlg_h_file_1287_
#define   _CnfrmPsdConfirmPassDlg_h_file_1287_



/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

class CConfirmPassDlg : public CDialog
{
// Construction
public:
    CConfirmPassDlg(CWnd* pParent = NULL);   // standard constructor

    // the original password that we are confirming
    CString m_szOrigPass;

// Dialog Data
    //{{AFX_DATA(CConfirmPassDlg)
    enum { IDD = IDD_CONFIRM_PASSWORD };
    CString m_sz_password_new;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfirmPassDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfirmPassDlg)
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\certctl.cpp ===
// CertCtl.cpp : Implementation of the CCertmapCtrl OLE control class.

#include "stdafx.h"
#include "certmap.h"
#include "CertCtl.h"
#include "CertPpg.h"

extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}

// persistence and mapping includes
#include "Iismap.hxx"
#include "Iiscmr.hxx"
#include "WrapMaps.h"

#include "ListRow.h"
#include "ChkLstCt.h"

#include "wrapmb.h"

#include "Map11Pge.h"
#include "MapWPge.h"

//#include <iiscnfg.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertmapCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertmapCtrl, COleControl)
    //{{AFX_MSG_MAP(CCertmapCtrl)
    //}}AFX_MSG_MAP
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCertmapCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CCertmapCtrl)
    DISP_FUNCTION(CCertmapCtrl, "SetServerInstance", SetServerInstance, VT_EMPTY, VTS_BSTR)
    DISP_FUNCTION(CCertmapCtrl, "SetMachineName", SetMachineName, VT_EMPTY, VTS_BSTR)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_CAPTION()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCertmapCtrl, COleControl)
    //{{AFX_EVENT_MAP(CCertmapCtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CCertmapCtrl, 2)
    PROPPAGEID(CCertmapPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CCertmapCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertmapCtrl, "CERTMAP.CertmapCtrl.1",
    0xbbd8f29b, 0x6f61, 0x11d0, 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCertmapCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCertmap =
    { 0xbbd8f299, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32 } };
const IID BASED_CODE IID_DCertmapEvents =
    { 0xbbd8f29a, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCertmapOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST  |
    OLEMISC_INSIDEOUT           |
    OLEMISC_CANTLINKINSIDE      |
    OLEMISC_ACTSLIKEBUTTON      |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCertmapCtrl, IDS_CERTMAP, _dwCertmapOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::CCertmapCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertmapCtrl

BOOL CCertmapCtrl::CCertmapCtrlFactory::UpdateRegistry(BOOL bRegister)
    {
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_CERTMAP,
            IDB_CERTMAP,
            afxRegApartmentThreading,
            _dwCertmapOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::CCertmapCtrl - Constructor

CCertmapCtrl::CCertmapCtrl():
    m_fUpdateFont( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DCertmap, &IID_DCertmapEvents);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::~CCertmapCtrl - Destructor

CCertmapCtrl::~CCertmapCtrl()
    {
    if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );
    m_hAccel = NULL;
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::OnDraw - Drawing function

void CCertmapCtrl::OnDraw( CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid )
    {
    DoSuperclassPaint(pdc, rcBounds);
/*
    CFont* pOldFont;

    // select the stock font, recording the old one
    pOldFont = SelectStockFont( pdc );

    // do the superclass draw
    DoSuperclassPaint(pdc, rcBounds);

    // restore the old font - sneakily getting the correct font object
    pOldFont = pdc->SelectObject(pOldFont);
    
    // we want the button window to continue drawing in the correct font even
    // when we are not using OnDraw. i.e. when it is being pushed down. This
    // means we need to set the CWnd::SetFont() method.
    if ( m_fUpdateFont )
        {
        m_fUpdateFont = FALSE;
        CWnd::SetFont( pOldFont );
        }

    DoSuperclassPaint(pdc, rcBounds);
*/
    }

/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::DoPropExchange - Persistence support

void CCertmapCtrl::DoPropExchange( CPropExchange* pPX )
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::OnResetState - Reset control to default state

void CCertmapCtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl message handlers

//---------------------------------------------------------------------------
BOOL CCertmapCtrl::PreCreateWindow(CREATESTRUCT& cs)
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }

/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::IsSubclassedControl - This is a subclassed control

BOOL CCertmapCtrl::IsSubclassedControl()
    {
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::OnOcmCommand - Handle command messages

LRESULT CCertmapCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
    {
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnClick(USHORT iButton)
    {
    // in case there are any errors, prepare the error string
    CString sz;

    sz.LoadString( IDS_ERR_CERTMAP_TITLE );
    
    // free the existing name, and copy in the new one
    //  tjp:  you should compare if the old name matches the current name
    //        and only then free and malloc the new name -- chances are that
    //        the names are the same +++ all the free/malloc can fragment mem.
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(sz);

    // this is the whole purpose of the control
    RunMappingDialog();

    // we are not in the business of telling the host to do
    // something here, so just don't fire anything off.
    COleControl::OnClick(iButton);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::RunMappingDialog()
    {
    //
    // UNICODE/ANSI conversion - RonaldM
    //
    // prepare the machine name pointer
    USES_CONVERSION;

    OLECHAR * poch = NULL;

    if ( !m_szMachineName.IsEmpty() )
    {
        // allocate the name buffer, no need to free

        poch = T2OLE((LPTSTR)(LPCTSTR)m_szMachineName);

        if ( !poch )
        {
            MessageBeep(0);

            return;
        }
    }
        
    // initialize the metabase wrappings - pass in the name of the target machine
    // if one has been specified

    //
    // Changed to generic metabase wrapper class - RonaldM
    //
    //IMSAdminBase * pMB = FInitMetabaseWrapper( poch );
    //if ( !pMB )

    IMSAdminBase * pMB = NULL;
    if (!FInitMetabaseWrapperEx( poch, &pMB ))
    {
        MessageBeep(0);

        return;
    }

    // the 1:1 mapping and rule-based mapping are panes in a single dialog window.
    // first we must build the propertysheet dialog and add the panes

    // pointers to the pages (construction may throw, so we need to be careful)
    CMap11Page       page11mapping;
    CMapWildcardsPge pageWildMapping;

    // declare the property sheet
    CPropertySheet   propsheet( IDS_MAP_SHEET_TITLE );

    // Things could throw here, so better protect it.
    try
        {
        // if there is nothing in the MB_Path, default to the first instance
        if ( m_szServerInstance.IsEmpty() )
            m_szServerInstance = _T("/LM/W3SVC/1");

        // I am assuming that the last character is NOT a '/' Thus, if that is what is
        // there, we need to remove it. Otherwise, the path gets messed up later
        if ( m_szServerInstance.Right(1) == _T('/') )
            m_szServerInstance = m_szServerInstance.Left( m_szServerInstance.GetLength()-1 );

        // tell the pages about the metabase path property
        page11mapping.m_szMBPath   = m_szServerInstance + SZ_NAMESPACE_EXTENTION;
        pageWildMapping.m_szMBPath = m_szServerInstance + SZ_NAMESPACE_EXTENTION;

        // do any other initializing of the pages
        page11mapping.FInit(pMB);
        pageWildMapping.FInit(pMB);
        }
    catch ( CException e )
        {
        }

    // add the pages to the sheet
    propsheet.AddPage( &page11mapping );
    propsheet.AddPage( &pageWildMapping );

    // turn on help
    propsheet.m_psh.dwFlags |= PSH_HASHELP;
    page11mapping.m_psp.dwFlags |= PSP_HASHELP;
    pageWildMapping.m_psp.dwFlags |= PSP_HASHELP;

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // run the propdsheet dialog
        // let the host container know that we are putting up a modal dialog
        PreModalDialog();
        // run the dialog
        //  tjp:   should we not test the outcome of the dialog?
        //         could the user ESCAPE out of it w/o doing anything?
        propsheet.DoModal();
        // let the host container know we are done with the modality
        PostModalDialog();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    //
    // Changed to generic wrapper -- RonaldM
    FCloseMetabaseWrapperEx(&pMB);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::SetServerInstance(LPCTSTR szServerInstance)
    {
    m_szServerInstance = szServerInstance;
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::SetMachineName(LPCTSTR szMachine)
    {
    m_szMachineName = szMachine;
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnFontChanged()
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }


//---------------------------------------------------------------------------
void CCertmapCtrl::OnAmbientPropertyChange(DISPID dispid)
    {
    BOOL    flag;
    UINT    style;

    // do the right thing depending on the dispid
    switch ( dispid )
    {
    case DISPID_AMBIENT_DISPLAYASDEFAULT:
        if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
            {
            style = GetWindowLong(
                    GetSafeHwnd(), // handle of window
                    GWL_STYLE  // offset of value to retrieve
                    );
            if ( flag )
                style |= BS_DEFPUSHBUTTON;
            else
                style ^= BS_DEFPUSHBUTTON;
            SetWindowLong(
                    GetSafeHwnd(), // handle of window
                    GWL_STYLE,  // offset of value to retrieve
                    style
                    );
            Invalidate(TRUE);
            }
        break;
    };

    COleControl::OnAmbientPropertyChange(dispid);
    }

//---------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CCertmapCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
    {
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

//---------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CCertmapCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnMnemonic(LPMSG pMsg)
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnTextChanged()
    {
    DWORD   i;
    ACCEL   accel;
    BOOL    f;
    BOOL    flag;
    int     iAccel;

    // get the new text
    CString sz = InternalGetText();
    sz.MakeLower();

    // if the handle has already been allocated, free it
    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    // if there is a & character, then declare the accelerator
    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        // fill in the accererator record
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (USHORT)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;
        }

    // finish with the default handling.
    COleControl::OnTextChanged();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\certmap.cpp ===
// certmap.cpp : Implementation of CCertmapApp and DLL registration.
                           
#include "stdafx.h"
#include "certmap.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCertmapApp /*NEAR*/ theApp;    // tompop: does this have to be near?  We are now getting errors when we finish refering to this var's addr

const GUID CDECL BASED_CODE _tlid =
        { 0xbbd8f298, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

//--------------------------------------------------------------------------
void CCertmapApp::WinHelp(DWORD dwData, UINT nCmd )
    {
    COleControlModule::WinHelp(dwData,nCmd);
    }

////////////////////////////////////////////////////////////////////////////
// CCertmapApp::InitInstance - DLL initialization

BOOL CCertmapApp::InitInstance()
    {
    BOOL bInit = COleControlModule::InitInstance();

    // init ole stuff
    HRESULT hRes = CoInitialize(NULL);

    // finally, we need to redirect the winhelp file location to something more desirable
    CString sz;
    CString szHelpLocation;
    sz.LoadString( IDS_HELPLOC_PWSHELP );
    
    // expand the path
    ExpandEnvironmentStrings(
        sz,                                     // pointer to string with environment variables 
        szHelpLocation.GetBuffer(MAX_PATH + 1), // pointer to string with expanded environment variables  
        MAX_PATH                                // maximum characters in expanded string 
       );
    szHelpLocation.ReleaseBuffer();

    // free the existing path, and copy in the new one
    if ( m_pszHelpFilePath )
        free((void*)m_pszHelpFilePath);
    m_pszHelpFilePath = _tcsdup(szHelpLocation);

    return bInit;
    }


////////////////////////////////////////////////////////////////////////////
// CCertmapApp::ExitInstance - DLL termination
// tjp:  note that in 'CCertmapApp::InitInstance()' we add our help file to the
//       help path.  do we need to remove it on clean up here?
int CCertmapApp::ExitInstance()
    {
    CoUninitialize();
    return COleControlModule::ExitInstance();
    }


/////////////////////////////////////////////////////////////////////////////
// MigrateGUIDS - does all the GUID migration work. We pass back the
// return value of True iff we find GUIDs in the registry and migrate
// them to the metabase.
//
// We are called by top level fnct: InstallCertServerGUIDs that creates
// our 'info' structure and handles all the metabase init work.
/////////////////////////////////////////////////////////////////////////////
//  This code is written in response to bug # 167410.
//
//  This fix will handle all the GUID migration work, moving GUIDS that
//  CertServer placed in the registry into the metabase for Beta2. 
//  A more general install/deinstall mechanism for products that
//  work with IIS will be come post-Beta2.
//
//  DETAILS:
//  --------
//  
//   We look for evidence of CertServer by examing the Registry because
//   CertServer will write some entries under:
//   HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\KeyRing\Parameters\Certificate 
//         Authorities\Microsoft Certificate Server
//  
//    CertServer currently outputs:
//         CertGetConfig   "{C6CC49B0-CE17-11D0-8833-00A0C903B83C}"
//         CertRequest "{98AFF3F0-5524-11D0-8812-00A0C903B83C}"
//  
//    If we see the manditory 'CertRequest' entry, we will load as many strings
//    as we find, while defaulting the ones that are missing. See below
//    for the equivalent mdutil commands for what defaults are used
//  
//        => if we dont find  'CertRequest' we give up [meaning remove
//          any present MB GUID string entries]
//  
//   When we find that CertServer is installed, we dont fully believe that
//   certserver is still there.  To prove that its there we will do a
//   CoCreateInstance on CertConfig. If that works we install metabase
//   entries that are the equivalent of the following mdutil commands:
//  
//   ## ICERTGETCONFIG default setting:
//   mdutil SET "w3svc/CertServers/Microsoft Certificate Server" -dtype:STRING -
//    -utype:UT_SERVER -prop 5571 -value "{C6CC49B0-CE17-11D0-8833-00A0C903B83C}"
//   
//   ## ICERTREQUEST default setting:
//   mdutil SET "w3svc/CertServers/Microsoft Certificate Server" -dtype:STRING 
//    -utype:UT_SERVER -prop 5572 -value "{98AFF3F0-5524-11D0-8812-00A0C903B83C}"
//   
//   ## ICERTCONFIG default setting:
//   mdutil SET "w3svc/CertServers/Microsoft Certificate Server" -dtype:STRING 
//    -utype:UT_SERVER -prop 5574 -value "{372fce38-4324-11d0-8810-00a0c903b83c}"
//  
//   If the CoCreateInstance fails, we give up and remove MB GUID entries.
//  
//  ---------------------------------------------------------------
//   NOTE that we will either install or DE-install the metabase
//        GUID strings based on its decision that CertServer is present.
//        If we find GUID strings in the metabase but can not do a 
//        CoCreateInstance on CertConfig:
//          we remove them so that the rest of CertWizard will see CertServer
//          Guids iff we can use CertServer.
//  ---------------------------------------------------------------
//  NOTE also that if we make a decision to install GUID strings
//       into the metabase, we honor/preserve any present GUID strings that
//       are present in the metabase.
//  ---------------------------------------------------------------
//
/////////////////////////////////////////////////////////////////////////////


/*ddddddddddddddd
BOOL  MigrateGUIDS( ADMIN_INFO& info )
{
    BOOL   bRet = FALSE;                          // value to return, set to F
                                                  //  for defensive reasons.
    BOOL   bFoundCertSrvRegistryEntries = FALSE;  // assume false for now

    TCHAR* szRegPath = _T("SOFTWARE\\Microsoft\\KeyRing\\Parameters\\Certificate Authorities\\Microsoft Certificate Server");

    //-----------------------------------------------------------------------
    // In each of the following 3 sets of parameters, we have (1) a string
    // like "CertRequest" that CertServer uses in the registry, (2) a default
    // value to use like  "{98AFF3F0-5524-11D0-8812-00A0C903B83C}"  that we
    // use if we can not find anything in the registry, and (3) a CString
    // to hold the GUID.   The value in the CString will be stored in the MB.
    //-----------------------------------------------------------------------

    // CertRequest - variables
    TCHAR* szCertRequest = _T("CertRequest");
    TCHAR* szCertRequestGUIDdefault = _T( "{98AFF3F0-5524-11D0-8812-00A0C903B83C}" );
    CString szCertRequestGUID;

    // CertConfig - variables
    TCHAR* szCertConfig = _T("CertConfig");
    TCHAR* szCertConfigGUIDdefault = _T( "{372fce38-4324-11d0-8810-00a0c903b83c}" );
    CString szCertConfigGUID;

    // CertGetConfig - variables
    TCHAR* szCertGetConfig = _T("CertGetConfig");
    TCHAR* szCertGetConfigGUIDdefault = _T( "{C6CC49B0-CE17-11D0-8833-00A0C903B83C}");
    CString szCertGetConfigGUID;


    CString  szCertServerMetabaseRoot( SZ_ROOT_CERT_SERV_MB_PATH );
                // SZ_ROOT_CERT_SERV_MB_PATH = "/LM/W3SVC/CertServers"

    szCertServerMetabaseRoot += _T("/Microsoft Certificate Server");

#ifdef  DEBUGGING
    CEditDialog  dlg(szCertServerMetabaseRoot,
                _T("use this to test adding new CertServer entries."
                   " In order for us to install a new key you have to change the path"
                   " below to something [strange] and not already in the metabase."));
    dlg.DoModal();
#endif    
    
    // the following string will be restored into info.szMetaBasePath before
    // we exit this fnct.  We switch out the [info.szMetaBasePath] so that
    // we can use our native Set/Get metabase string fncts.
    // We switch it to: "/LM/W3SVC/CertServers/Microsoft Certificate Server" 
    //
    CString  szSaved_info_szMetaBasePath( info.szMetaBasePath  );
    
    info.szMetaBasePath =   szCertServerMetabaseRoot;


    // if we dont find HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\KeyRing\Parameters\
    // Certificate Authorities\Microsoft Certificate Server"
    // with key: CertRequest  quit!   CertServer should have installed this.
    // We are forgiving about the other 2 Registry GUID strings
    //-------------------------------------------------------------------------
    if (   Reg::GetNameValueIn( szRegPath,      szCertRequest,
                                szCertRequestGUID,  HKEY_LOCAL_MACHINE )) {
           bFoundCertSrvRegistryEntries = TRUE;
    }
    if (!  Reg::GetNameValueIn( szRegPath,      szCertConfig,
                                szCertConfigGUID,  HKEY_LOCAL_MACHINE )) {
           szCertConfigGUID = szCertConfigGUIDdefault; // assign default
    }
    if (!  Reg::GetNameValueIn( szRegPath,      szCertGetConfig,
                                szCertGetConfigGUID,  HKEY_LOCAL_MACHINE )) {
           szCertGetConfigGUID = szCertGetConfigGUIDdefault; // assign default
    }

    //------------------------------------------------------------------------
    // First lets try to create the directory path: the user might have
    // deleted it or this might be a virgin machine.
    //------------------------------------------------------------------------
    {
        CWrapMetaBase& MB = info.meta.m_mbWrap; // this is the MetaBase Wrapper
                                                // its already been openned by
                                                // openMetaDataForWrite

        if ( FALSE == openMetaDataForWrite(info,  FALSE) ) {

           if (ERROR_PATH_NOT_FOUND == HRESULT_CODE( MB.getHRESULT() )) {
            // lets create the path in the metabase, using AddObject.
            // recursively creates a "pathway in the metabase". E.g. assume that you
            // want to make sure that "/LM/W3SVC/CertServers/Microsoft Certificate Server"
            // is in the metabase.  you can open /LM/W3SVC and do a AddKey() on
            // "CertServers/Microsoft Certificate Server" to create that stub.

            // above we set:  info.szMetaBasePath =   szCertServerMetabaseRoot
            // here we will temporarily pretend that our root is at level
            // /LM/W3SVC  which we assume is at the top of szCertServerMetabaseRoot
            // and then call AddKey

            TCHAR  szPath[400];
            TCHAR* szRootPrefix = _T("/LM/W3SVC");
            UINT   nRootPrefixLen = STRLEN(szRootPrefix);
            
            STRCPY(szPath, szCertServerMetabaseRoot);

            if (STRNICMP(szRootPrefix, szPath, nRootPrefixLen) != 0) 
               goto returnFALSE;    // we could not figure out a common Root

            info.szMetaBasePath = szRootPrefix;
            if ( FALSE == openMetaDataForWrite(info) )
               goto returnFALSE;    // we could not open the metabase

            // the metabase path is already position to the proper directory
            // in the MB object.  MB will prepend that path to the subDirectory
            // that we want to create, the following will jump past the trailing
            // '/' separating the root and the rest of the sub-directory
            // e.g. "/CertServers/Microsoft Certificate Server"
            //
            // We dont do any other error checking besides notifying and
            // returning FALSE.
            
            if (FALSE == MB.AddObject( &szPath[nRootPrefixLen] )) {
                NotifyUsers_CouldNotAccessMetaBase( MB.getHRESULT() );
                goto returnFALSE;    // we could not create required path
            }

            // since we are continuing, we reset back our proper path.
            info.szMetaBasePath =   szCertServerMetabaseRoot;
               
           } else {
           
               goto returnFALSE;    // we could not open the metabase
           }
        }



    }

    //------------------------------------------------------------------------
    // Below we dont deal with the XENROLL GUID setting that is for future usage
    // PLUS its not CertServer Related, its Xenroll related.  We dont touch it.
    //------------------------------------------------------------------------
    {

        // lets see if we can do a CoCreateInstance on CertRequest.  If we can not
        // we believe that certServer is not installed and set/clear MB entries
        // The following values are set or cleared:
        //
        //  # define MD_SSL_CERT_WIZGUID_ICERTGETCONFIG ( IIS_MD_SSL_BASE+71 )
        //  # define MD_SSL_CERT_WIZGUID_ICERTREQUEST   ( IIS_MD_SSL_BASE+72 )
        //  # define MD_SSL_CERT_WIZGUID_XENROLL        ( IIS_MD_SSL_BASE+73 ) FUTURE USAGE
        //  # define MD_SSL_CERT_WIZGUID_ICERTCONFIG    ( IIS_MD_SSL_BASE+74 )
        //------------------------------------------------------------------------

        IPtr<ICertConfig, &IID_ICertConfig>  iptr;
        CString  szRemoteDCOMTargetMachine;
       
        // REMEMBER  bRet  returns whether we were able to delete everything
        //                 or set everything that we were wanting to set
        // in both cases assume now that we have success and update bRet when
        // we find errors, we continue as long as possible.  E.g. we add or delete
        // as many entries as possible and return our status value to the caller.

        bRet = TRUE;

           
        if ( (FALSE == bFoundCertSrvRegistryEntries)  ||

             (FALSE == GetICertConfigIPtrFromGuid( iptr, szCertConfigGUID,
                        &szRemoteDCOMTargetMachine)) )
        {
            // remove MB entries!

#ifdef  DEBUGGING
            DODBG  MsgBox( _T("adding CertServer MB entries"));
#endif

            if ( FALSE == openMetaDataForWrite(info) ) {
               goto returnFALSE;    // we could not open the metabase
            }

            //  We just need to blow away the cert info in the metabase
            //  which we do using the meta data wrapper
            // deleting values
            CWrapMetaBase& MB = info.meta.m_mbWrap; // this is the MetaBase Wrapper
                                                    // its already been openned by
                                                    // openMetaDataForWrite
            // try deletes once
            

            // In C++ &&= does not exist. However [bRet &= FALSE;] is OK, but we dont
            // have a uniform single value of TRUE in C/C++ so its not safe to use &=
            // to chain a set of TRUE-value
            //   so we can not do:
            //   bRet &&= MB.DeleteData(  _T(""),
            //                  MD_SSL_CERT_WIZGUID_ICERTGETCONFIG, STRING_METADATA);
            // so we will use a [if (! xxx) bRet=FALSE;]  construct below

            if (! MB.DeleteData(  _T(""),
                      MD_SSL_CERT_WIZGUID_ICERTGETCONFIG, STRING_METADATA))  bRet=FALSE;
            if (! MB.DeleteData(  _T(""),
                      MD_SSL_CERT_WIZGUID_ICERTREQUEST, STRING_METADATA))    bRet=FALSE;
            if (! MB.DeleteData(  _T(""),
                      MD_SSL_CERT_WIZGUID_ICERTCONFIG, STRING_METADATA))     bRet=FALSE;

            MB.Close();

        } else {
            
            CString   szPresentValue;        // used to read the present value
                                             // any metabase value so that we
                                             // can preserve it.

#ifdef  DEBUGGING
            DODBG MsgBox( _T("adding CertServer MB entries"));
#endif

            // add MB entries!   If an entry already exists, leave it alone.

            if (!  GetMetaBaseString ( info, 
                          IN  MD_SSL_CERT_WIZGUID_ICERTREQUEST,
                          IN       szPresentValue ) )
            {
              if (!SetMetaBaseString ( info,
                          IN  MD_SSL_CERT_WIZGUID_ICERTREQUEST,
                          IN       szCertRequestGUID ) )     bRet=FALSE;
            }

            if (!  GetMetaBaseString ( info, 
                          IN  MD_SSL_CERT_WIZGUID_ICERTCONFIG,
                          IN       szPresentValue ) )
            {
              if (!SetMetaBaseString ( info,
                          IN  MD_SSL_CERT_WIZGUID_ICERTCONFIG,
                          IN       szCertConfigGUID ) )      bRet=FALSE;
            }

            if (!  GetMetaBaseString ( info,  
                          IN  MD_SSL_CERT_WIZGUID_ICERTGETCONFIG,
                          IN       szPresentValue ) )
            {
              if (!SetMetaBaseString ( info,
                          IN  MD_SSL_CERT_WIZGUID_ICERTGETCONFIG,
                          IN       szCertGetConfigGUID ) )   bRet=FALSE;
            }

        }

    }
    
  commonReturn:         // this is the common return so that we an set
                        // back the metabase path.  We saved it so that
                        // we can switch to where the GUIDs live: 

    // the following will restore the original [info.szMetaBasePath] value
    // before we switched it to: "/LM/W3SVC/CertServers/..." 
    //
    info.szMetaBasePath =   szSaved_info_szMetaBasePath;

    return(bRet);


  returnFALSE:          // this will cause a FALSE return and do all things
                        // required in our "common return"

    bRet = FALSE;
    goto  commonReturn;   
}
*/

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\crackcrt.h ===
class CCrackedCert
    {
    public:
    // constructor
    CCrackedCert();
    ~CCrackedCert();

    // give it a cert to crack. If this object was previously used to
    // crack a key, cleanup is automatically done and the new key is
    // cracked. - NOTE: The target key MUST have either a certificate
    // or a certificate request. Those are what get cracked. A return
    // value of 0 indicates success
    BOOL CrackCert( PUCHAR pCert, DWORD cbCert );

    // The rest of the methods access the data in the cracked certificate
    DWORD       GetVersion();
    DWORD*      PGetSerialNumber(); // returns a pointer to a DWORD[4]
    int         GetSignatureAlgorithm();
    FILETIME    GetValidFrom();
    FILETIME    GetValidUntil();
    PVOID       PSafePublicKey();
    DWORD       GetBitLength();

    void        GetIssuer( CString &sz );
    void        GetIssuerCountry( CString &sz );
    void        GetIssuerOrganization( CString &sz );
    void        GetIssuerUnit( CString &sz );

    void        GetSubject( CString &sz );
    void        GetSubjectCountry( CString &sz );
    void        GetSubjectState( CString &sz );
    void        GetSubjectLocality( CString &sz );
    void        GetSubjectCommonName( CString &sz );
    void        GetSubjectOrganization( CString &sz );
    void        GetSubjectUnit( CString &sz );

    protected:

    // string constants for distinguishing names. Not to be localized
    #define     SZ_KEY_COUNTRY          _T("C=")
    #define     SZ_KEY_STATE            _T("S=")
    #define     SZ_KEY_LOCALITY         _T("L=")
    #define     SZ_KEY_ORGANIZATION     _T("O=")
    #define     SZ_KEY_ORGUNIT          _T("OU=")
    #define     SZ_KEY_COMNAME          _T("CN=")

    private:
    void        GetSubjectDN( CString &szDN, LPCTSTR szKey );
    void        GetIssuerDN( CString &szDN, LPCTSTR szKey );


    // declare the x509 pointer as void so that the
    // files instantiating this don't have to include wincrypt
    PVOID       m_pData;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\crtmapd.h ===
// CrtMapD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// C1To1CertMappingDlg dialog

class C1To1CertMappingDlg : public CPropertyPage
{
// Construction
public:
    C1To1CertMappingDlg(CWnd* pParent = NULL);  // standard constructor
    ~C1To1CertMappingDlg();                     // standard desstructor

    BOOL    FInitMapper();

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(C1To1CertMappingDlg)
    enum { IDD = IDD_11CERT_MAPPING };
    CComboBox   m_ccombo_authorities;
    CButton m_cbutton_chooseaccnt;
    CButton m_cbutton_delete;
    CListCtrl   m_clistctrl_list;
    int     m_int_authorities;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(C1To1CertMappingDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(C1To1CertMappingDlg)
    afx_msg void OnChooseAccount();
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // internal utilities
    BOOL FInitMappingList();
    BOOL FInitAuthorityComboBox();

    // iMap is the mapping's index into the main mapper object. It gets saved as the private
    // data in the list item. Returns success or failure
    BOOL FAddMappingToList( CCert11Mapping* pMap, DWORD iMap );

    BOOL FEditOneMapping( CCert11Mapping* pMap );
    void EditManyMappings();
    void UpdateMappingInDispList( DWORD iList, CCert11Mapping* pMap );

    // reads a named certificate file from the disk. This is the same sort of cert file
    // that is passed around by the keyring application. In fact, this routine is defined
    // in its own source file and is largly lifted from the keyring app. AddCert.cpp
    BOOL FAddCertificateFile( CString szFile );
    BOOL FAddCertificate( PUCHAR pCertificate, DWORD cbCertificate );

    // convert a binary data thing to a distinguished name
    BOOL FBuildNameString( PUCHAR pBData, DWORD cbBData, CString &szDN );
    BOOL BuildRdnList( PNAME_INFO pNameInfo, CString &szDN );
    LPSTR MapAsnName( LPSTR pAsnName );



    // state utilities
    void EnableDependantButtons();

    // its mapper
    CIisCert11Mapper    m_mapper;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\edtone11.cpp ===
// EdtOne11.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"

#include "brwsdlg.h"
#include "EdtOne11.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg dialog

CEditOne11MapDlg::CEditOne11MapDlg(CWnd* pParent /*=NULL*/)
        : CNTBrowsingDialog(CEditOne11MapDlg::IDD, pParent)
        {
        //{{AFX_DATA_INIT(CEditOne11MapDlg)
        m_sz_mapname = _T("");
        m_bool_enable = FALSE;
        //}}AFX_DATA_INIT
        }

void CEditOne11MapDlg::DoDataExchange(CDataExchange* pDX)
        {
        //{{AFX_DATA_MAP(CEditOne11MapDlg)
        DDX_Text(pDX, IDC_MAPNAME, m_sz_mapname);
        DDV_MaxChars(pDX, m_sz_mapname, 60);
        DDX_Check(pDX, IDC_ENABLE, m_bool_enable);
    //}}AFX_DATA_MAP
        CNTBrowsingDialog::DoDataExchange(pDX);
        }

BEGIN_MESSAGE_MAP(CEditOne11MapDlg, CNTBrowsingDialog)
        //{{AFX_MSG_MAP(CEditOne11MapDlg)
    ON_BN_CLICKED(IDC_BTN_HELP, OnBtnHelp)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  OnBtnHelp)
    ON_COMMAND(ID_HELP,         OnBtnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnBtnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnBtnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg message handlers

//---------------------------------------------------------------------------
// make sure that the selected NT acount is, in fact, a valid account
//
void CEditOne11MapDlg::OnOK()
        {
        // update the data
        UpdateData( TRUE );

        // it is valid
        CNTBrowsingDialog::OnOK();
        }

//---------------------------------------------------------------------------
void CEditOne11MapDlg::OnBtnHelp() 
    {
    WinHelp( HIDD_CERTMAP_BASIC_MAP_ONE );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\chklstct.cpp ===
// ChkLstCt.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "ListRow.h"
#include "ChkLstCt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrl

//-----------------------------------------------------------------------------------
CCheckListCtrl::CCheckListCtrl()
    {
    // set the correct start drawing column
    m_StartDrawingCol = 1;
    }

//-----------------------------------------------------------------------------------
CCheckListCtrl::~CCheckListCtrl()
    {
    }


//-----------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CCheckListCtrl, CListSelRowCtrl)
    //{{AFX_MSG_MAP(CCheckListCtrl)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrl message handlers

//-----------------------------------------------------------------------------------
void CCheckListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
    {
    CRect       rcItem = lpDrawItemStruct->rcItem;
    CRect       rcSection;
    UINT        itemID = lpDrawItemStruct->itemID;
    BOOL        f;
    CString     sz;
    LV_COLUMN   colData;

    // setup the CDC object
    CDC         cdc;
    cdc.Attach( lpDrawItemStruct->hDC );

    // clear the columnd buffer
    ZeroMemory( &colData, sizeof(colData) );
    colData.mask = LVCF_WIDTH;


    // get the checkmark bitmap
//  f = m_bitmapCheck.LoadBitmap( IDB_CHECK );


    // First, we draw the "enabled" column Get the data
    // for it first. If there is none, then we can skip it.
    sz = GetItemText( itemID, 0 );
    f = GetColumn( 0, &colData );

    if ( !sz.IsEmpty() )
        {
        // figure out the sectional rect
        rcSection = rcItem;
        rcSection.left += 4;
        rcSection.top += 3;

        rcSection.right = rcSection.left + 9;
        rcSection.bottom = rcSection.top + 9;

        // draw the circle
        cdc.Ellipse( &rcSection );
        rcSection.DeflateRect(1, 1);
        cdc.Ellipse( &rcSection );

/*
        // do all the necessary dc stuff

        // Create a compatible memory DC
        CDC memdc;
        f = memdc.CreateCompatibleDC( &cdc );

        // Select the bitmap into the DC
        CBitmap *poldbmp;
        poldbmp = memdc.SelectObject( &m_bitmapCheck );

// test
RECT    r;
r.left = r.top = 0;
r.right = r.bottom = 7;
memdc.Ellipse( &r );
memdc.InvertRect( &r );


        // for readability...
        int l = rcSection.left + 2;                     // left
        int t = rcSection.top + 2;                      // top
        int w = rcSection.right - rcSection.left;       // width
        int h = rcSection.bottom - rcSection.top;       // height

        // Copy (BitBlt) bitmap from memory DC to screen DC
        f = cdc.BitBlt( l, t, w, h, &memdc, 0, 0, SRCCOPY );
//      f = cdc.StretchBlt( l, t, w, h, &memdc, 0, 0, 7, 7, SRCCOPY );
 
        // restore the old selected bitmap
        memdc.SelectObject( poldbmp );
*/
        }
    
    // cleanup the CDC object
    cdc.Detach();

    // draw the rest of it
    CListSelRowCtrl::DrawItem( lpDrawItemStruct );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\ed11maps.h ===
// Ed11Maps.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEdit11Mappings dialog

class CEdit11Mappings : public CNTBrowsingDialog
{
// Construction
public:
    CEdit11Mappings(CWnd* pParent = NULL);   // standard constructor

    // overrides
    virtual void OnOK();

// Dialog Data
    //{{AFX_DATA(CEdit11Mappings)
    enum { IDD = IDD_MAP_TO_ACCNT };
    int     m_int_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEdit11Mappings)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEdit11Mappings)
    afx_msg void OnBtnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\chklstct.h ===
// ChkLstCt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrl window

class CCheckListCtrl : public CListSelRowCtrl
{
// Construction
public:
    CCheckListCtrl();

    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCheckListCtrl)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CCheckListCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CCheckListCtrl)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\editruld.h ===
// EditRulD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRuleDlg dialog

class CEditWildcardRuleDlg : public CDialog
{
// Construction
public:
    CEditWildcardRuleDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CEditWildcardRuleDlg)
    enum { IDD = IDD_WILDCARDS_2 };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditWildcardRuleDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditWildcardRuleDlg)
    afx_msg void OnSelectIssuer();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\edtrulel.cpp ===
// EdtRulEl.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "EdtRulEl.h"

extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}

#include "Iismap.hxx"
#include "Iiscmr.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditRuleElement dialog


//---------------------------------------------------------------------------
CEditRuleElement::CEditRuleElement(CWnd* pParent /*=NULL*/)
    : CDialog(CEditRuleElement::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CEditRuleElement)
    m_sz_criteria = _T("");
    m_int_field = -1;
    m_sz_subfield = _T("");
    m_bool_match_case = FALSE;
    //}}AFX_DATA_INIT
    }


//---------------------------------------------------------------------------
void CEditRuleElement::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEditRuleElement)
    DDX_Control(pDX, IDC_SUBFIELD, m_ccombobox_subfield);
    DDX_Control(pDX, IDC_FIELDS, m_ccombobox_field);
    DDX_Text(pDX, IDC_CRITERIA, m_sz_criteria);
    DDX_CBIndex(pDX, IDC_FIELDS, m_int_field);
    DDX_CBString(pDX, IDC_SUBFIELD, m_sz_subfield);
    DDX_Check(pDX, IDC_CHK_CAPITALIZATION, m_bool_match_case);
    //}}AFX_DATA_MAP
    }


//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CEditRuleElement, CDialog)
    //{{AFX_MSG_MAP(CEditRuleElement)
    ON_CBN_SELCHANGE(IDC_FIELDS, OnSelchangeFields)
    ON_EN_CHANGE(IDC_SUBFIELD, OnChangeSubfield)
    ON_BN_CLICKED(IDC_BTN_HELP, OnBtnHelp)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  OnBtnHelp)
    ON_COMMAND(ID_HELP,         OnBtnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnBtnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnBtnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditRuleElement message handlers

//---------------------------------------------------------------------------
BOOL CEditRuleElement::OnInitDialog()
    {
    CString     sz;

    // call the parental oninitdialog
    BOOL f = CDialog::OnInitDialog();

    // initialize the elements in the drop-list
    // loop the list of CERT_FIELD_IDs, adding each to the drop-list
    for ( UINT id = CERT_FIELD_ISSUER; id < CERT_FIELD_LAST; id++ )
        {
        // bug 154957 requests that we no longer support mapping on the
        // serial number. This makes sense anyway as mapping to the serial
        // numbers is better off done as 1::1 mapping. If the bug doesn't
        // make this conclusion clear enough upon reading, it is the
        // interpretation that MikeHow has handed down.
        if ( id == CERT_FIELD_SERIAL_NUMBER )
            continue;

        // get the string associated with the id
        sz = MapIdToField( (CERT_FIELD_ID)id );
        m_ccombobox_field.AddString( sz );
        }

    // initialize the list of known subfields

    id = 0;

    //
    // UNICODE conversion -- RonaldM
    //
    LPCSTR  psz;
    while ( psz = EnumerateKnownSubFields(id) )
        {
        CString str(psz);
        // append it to the drop-list
        m_ccombobox_subfield.AddString( str );

        // increment id
        id++;
        }

    UpdateData( FALSE );

    // store the initial value of the sub-field
    m_szTempSubStorage = m_sz_subfield;

    // make sure to check the subfields
    OnSelchangeFields();
    
    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
// make sure that, if there is a sub-field, that it is valid
// 
void CEditRuleElement::OnOK() 
    {
    UpdateData( TRUE );

    //
    // UNICODE/ANSI conversion - RonaldM
    //
    USES_CONVERSION;

    // test the sub-field flag for the newly selected field type
    DWORD   flags = GetIdFlags( (CERT_FIELD_ID)m_int_field );
    BOOL    fSubs = flags & CERT_FIELD_FLAG_CONTAINS_SUBFIELDS;

    // if there are sub-fields, test their validity
    if ( fSubs )
        {
        CString szTest(MapSubFieldToAsn1( T2A((LPTSTR)(LPCTSTR)m_sz_subfield) ));
        // if there is NO match, tell the user
        if ( szTest.IsEmpty() )
            {
            AfxMessageBox( IDS_INVALID_SUBFIELD );
            return;
            }
        }

    // it is valid
    CDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CEditRuleElement::OnSelchangeFields() 
    {
    UpdateData( TRUE );

    // test the sub-field flag for the newly selected field type
    DWORD   flags = GetIdFlags( (CERT_FIELD_ID)m_int_field );
    BOOL    fSubs = flags & CERT_FIELD_FLAG_CONTAINS_SUBFIELDS;

    // set the correct enable state
    BOOL    fWasEnabled = m_ccombobox_subfield.EnableWindow( fSubs );

    // restore the value if necessary
    if ( fSubs )
        {
        m_sz_subfield = m_szTempSubStorage;
        UpdateData( FALSE );
        }
    else
        {
        m_szTempSubStorage = m_sz_subfield;
        m_sz_subfield.Empty();
        UpdateData( FALSE );
        }
    }

//---------------------------------------------------------------------------
void CEditRuleElement::OnChangeSubfield() 
    {
    m_szTempSubStorage = m_sz_subfield;
    }

//---------------------------------------------------------------------------
void CEditRuleElement::OnBtnHelp() 
    {
    WinHelp( HIDD_CERTMAP_RUL_ELEMENT );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\ed11maps.cpp ===
// Ed11Maps.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "brwsdlg.h"
#include "Ed11Maps.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEdit11Mappings dialog
CEdit11Mappings::CEdit11Mappings(CWnd* pParent /*=NULL*/)
    : CNTBrowsingDialog(CEdit11Mappings::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CEdit11Mappings)
    m_int_enable = FALSE;
    //}}AFX_DATA_INIT
    }


void CEdit11Mappings::DoDataExchange(CDataExchange* pDX)
    {
    CNTBrowsingDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEdit11Mappings)
    DDX_Check(pDX, IDC_ENABLE, m_int_enable);
    //}}AFX_DATA_MAP
    }


BEGIN_MESSAGE_MAP(CEdit11Mappings, CNTBrowsingDialog)
    //{{AFX_MSG_MAP(CEdit11Mappings)
    ON_BN_CLICKED(IDC_BTN_HELP, OnBtnHelp)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  OnBtnHelp)
    ON_COMMAND(ID_HELP,         OnBtnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnBtnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnBtnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEdit11Mappings message handlers


//---------------------------------------------------------------------------
void CEdit11Mappings::OnOK()
    {
    UpdateData( TRUE ); 
    // call the superclass ok
    CNTBrowsingDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CEdit11Mappings::OnBtnHelp() 
    {
    WinHelp( HIDD_CERTMAP_BASIC_MAP_MANY );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\edtrulel.h ===
// EdtRulEl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditRuleElement dialog

class CEditRuleElement : public CDialog
{
// Construction
public:
    CEditRuleElement(CWnd* pParent = NULL);   // standard constructor
    virtual BOOL OnInitDialog();

    // overrides
    virtual void OnOK();

// Dialog Data
    //{{AFX_DATA(CEditRuleElement)
    enum { IDD = IDD_EDIT_RULE_ELEMENT };
    CComboBox   m_ccombobox_subfield;
    CComboBox   m_ccombobox_field;
    CString m_sz_criteria;
    int     m_int_field;
    CString m_sz_subfield;
    BOOL    m_bool_match_case;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditRuleElement)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditRuleElement)
    afx_msg void OnSelchangeFields();
    afx_msg void OnChangeSubfield();
    afx_msg void OnBtnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    
    // temporary storage in the event of a disabled subfield
    CString m_szTempSubStorage;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\crackcrt.cpp ===
// implements the exported CKeyCrackedData

#include "stdafx.h"
#include "CrackCrt.h"

extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}

//-------------------------------------------------
CCrackedCert:: CCrackedCert()
        : m_pData(NULL)
    {}

//-------------------------------------------------
CCrackedCert::~CCrackedCert()
    {
    PX509Certificate    p509 = (PX509Certificate)m_pData;

    // if the cracked data is there, free it
    if ( p509 ) 
        SslFreeCertificate( (PX509Certificate)m_pData );
    }

//-------------------------------------------------
// adds a key to the service. They CKey object is added to the
// array object below. If this Service is connected to a machine,
// then the key is also added to the tree view below the service.
//-------------------------------------------------
BOOL CCrackedCert::CrackCert( PUCHAR pCert, DWORD cbCert )
    {
    PX509Certificate    p509 = NULL;
    BOOL                f;

    // if there already is a cracked cert, get rid of it
    if ( m_pData )
        {
        SslFreeCertificate( (PX509Certificate)m_pData );
        m_pData = NULL;
        }

    // crack the certificate
    f = SslCrackCertificate( pCert, cbCert, CF_CERT_FROM_FILE, &p509 );

    m_pData = (PVOID)p509;
    return f;
    }

//-------------------------------------------------
// The rest of the methods access the data in the cracked certificate
//-------------------------------------------------
DWORD CCrackedCert::GetVersion()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return pCert->Version;
    }

//-------------------------------------------------
// returns a pointer to a DWORD[4]
DWORD* CCrackedCert::PGetSerialNumber()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return (DWORD*)&pCert->SerialNumber;
    }

//-------------------------------------------------
int CCrackedCert::GetSignatureAlgorithm()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return pCert->SignatureAlgorithm;
    }

//-------------------------------------------------
FILETIME CCrackedCert::GetValidFrom()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->ValidFrom;
    }

//-------------------------------------------------
FILETIME CCrackedCert::GetValidUntil()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->ValidUntil;
    }

//-------------------------------------------------
PVOID CCrackedCert::PSafePublicKey()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->pPublicKey;
    }

//-------------------------------------------------
DWORD CCrackedCert::GetBitLength()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    LPPUBLIC_KEY pPubKey = (LPPUBLIC_KEY)(pCert->pPublicKey);
    ASSERT(m_pData);
    return pPubKey->bitlen;
    }

//-------------------------------------------------
void CCrackedCert::GetIssuer( CString &sz )
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    sz = pCert->pszIssuer;
    }

//-------------------------------------------------
void CCrackedCert::GetSubject( CString &sz )
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    sz = pCert->pszSubject;
    }

//-------------------------------------------------
// gets a part of the subject's distinguishing information
void CCrackedCert::GetSubjectDN( CString &szDN, LPCTSTR szKey )
    {
    // clear the szDN
    szDN.Empty();

    // start with the dn (aka subject) string
    CString     szSubject;
    GetSubject( szSubject );

    // find the position of the key in the subject
    int cPos = szSubject.Find( szKey );

    // if we got it, get it
    if ( cPos >= 0 )
        {
        szDN = szKey;
        // get the string
        szDN = szSubject.Mid( cPos + szDN.GetLength() );
        // get the comma
        cPos = szDN.Find( _T(',') );
        // truncate at the comma
        if ( cPos >=0 )
            szDN = szDN.Left( cPos );
        }
    }

//-------------------------------------------------
// gets a part of the issuer's distinguishing information
void CCrackedCert::GetIssuerDN( CString &szDN, LPCTSTR szKey )
    {
    // clear the szDN
    szDN.Empty();

    // start with the dn (aka subject) string
    CString     szIssuer;
    GetIssuer( szIssuer );

    // find the position of the key in the subject
    int cPos = szIssuer.Find( szKey );

    // if we got it, get it
    if ( cPos >= 0 )
        {
        szDN = szKey;
        // get the string
        szDN = szIssuer.Mid( cPos + szDN.GetLength() );
        // get the comma
        cPos = szDN.Find( _T(',') );
        // truncate at the comma
        if ( cPos >=0 )
            szDN = szDN.Left( cPos );
        }
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectCountry( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_COUNTRY );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectState( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_STATE );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectLocality( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_LOCALITY );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectCommonName( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_COMNAME );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectOrganization( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_ORGANIZATION );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectUnit( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_ORGUNIT );
    }


//-------------------------------------------------
void CCrackedCert::GetIssuerCountry( CString &sz )
    {
    GetIssuerDN( sz, SZ_KEY_COUNTRY );
    }

//-------------------------------------------------
void CCrackedCert::GetIssuerOrganization( CString &sz )
    {
    GetIssuerDN( sz, SZ_KEY_ORGANIZATION );
    }

//-------------------------------------------------
void CCrackedCert::GetIssuerUnit( CString &sz )
    {
    GetIssuerDN( sz, SZ_KEY_ORGUNIT );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\helpmap.h ===
// header file that equates to the helpmap file.
// these mappings are hand-made so as not to collide
// with other mappings made in other projects that
// all use the main help file

#define HIDD_CERTMAP_MAIN_BASIC                 0x50100
#define HIDD_CERTMAP_BASIC_MAP_ONE              0x50101
#define HIDD_CERTMAP_BASIC_MAP_MANY             0x50102

#define HIDD_CERTMAP_MAIN_ADVANCED              0x50110
#define HIDD_CERTMAP_ADV_RUL_GENERAL            0x50111
#define HIDD_CERTMAP_ADV_RUL_RULES              0x50112
#define HIDD_CERTMAP_ADV_RUL_MAPPING            0x50113
#define HIDD_CERTMAP_RUL_ELEMENT                0x50114
#define HIDD_CERTMAP_SELECT_ISSUERS             0x50115
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\hotlink.cpp ===
// HotLink.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "HotLink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLOR_BLUE          RGB(0, 0, 0xFF)

/////////////////////////////////////////////////////////////////////////////
// CHotLink

CHotLink::CHotLink():
    m_CapturedMouse( FALSE ),
    m_fBrowse( FALSE ),
    m_fExplore( FALSE ),
    m_fOpen( FALSE ),
    m_fInitializedFont( FALSE )
{
}

CHotLink::~CHotLink()
{
}

BEGIN_MESSAGE_MAP(CHotLink, CButton)
    //{{AFX_MSG_MAP(CHotLink)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------
// set the title string
void CHotLink::SetTitle( CString sz )
    {
    // set the title
    SetWindowText( sz );
    // force the window to redraw
    Invalidate( TRUE );
    }

/////////////////////////////////////////////////////////////////////////////
// CHotLink message handlers

//------------------------------------------------------------------------
void CHotLink::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
    {
    // prep the device context
    CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

    // get the drawing rect
    CRect rect = lpDrawItemStruct->rcItem;

    if ( ! m_fInitializedFont )
        {
        // get the window font
        CFont* pfont = GetFont();
        LOGFONT logfont;
        pfont->GetLogFont( &logfont );

        // modify the font  - add underlining
        logfont.lfUnderline = TRUE;

        // set the font back
        pfont->CreateFontIndirect( &logfont );
        SetFont( pfont, TRUE );

        m_fInitializedFont = TRUE;
        }

    // draw the text in blue
    pdc->SetTextColor( COLOR_BLUE );

    // draw the text
    CString sz;
    GetWindowText( sz );
    pdc->DrawText( sz, &rect, DT_LEFT|DT_SINGLELINE|DT_VCENTER );

    // get the extents fo the text for later reference
    m_cpTextExtents = pdc->GetOutputTextExtent( sz );
    }

//------------------------------------------------------------------------
// calculate the rectangle that surrounds the text
void CHotLink::GetTextRect( CRect &rect )
    {
    // get the main rect
    GetClientRect( rect );

    // reduce it by the width of the text
    rect.right = rect.left + m_cpTextExtents.cx;
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonDown(UINT nFlags, CPoint point)
    {
    // don't do the hotlink thing if there is no text
    CString sz;
    GetWindowText( sz );
    if ( sz.IsEmpty() )
        return;

    CRect   rect;
    GetTextRect( rect );
    if ( !m_CapturedMouse && rect.PtInRect(point) )
        {
        SetCapture( );
        m_CapturedMouse = TRUE;
        }
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonUp(UINT nFlags, CPoint point)
    {
    // only bother if we have the capture
    if ( m_CapturedMouse )
        {
        ReleaseCapture();
        if ( m_fBrowse )
            Browse();
        if ( m_fExplore )
            Explore();
        if ( m_fOpen )
            Open();
        }
    }

//------------------------------------------------------------------------
void CHotLink::Browse()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,     // handle to parent window
        NULL,     // pointer to string that specifies operation to perform
        sz,       // pointer to filename or folder name string
        NULL,     // pointer to string that specifies executable-file parameters
        NULL,     // pointer to string that specifies default directory
        SW_SHOW   // whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Explore()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,          // handle to parent window
        _T("explore"), // pointer to string that specifies operation to perform
        sz,            // pointer to filename or folder name string
        NULL,          // pointer to string that specifies executable-file parameters
        NULL,          // pointer to string that specifies default directory
        SW_SHOW        // whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Open()
    {
    // get the window text
    CString sz;
    GetWindowText(sz);

    // and do it to it!
    ShellExecute(
        NULL,          // handle to parent window
        _T("open"),    // pointer to string that specifies operation to perform
        sz,            // pointer to filename or folder name string
        NULL,          // pointer to string that specifies executable-file parameters
        NULL,          // pointer to string that specifies default directory
        SW_SHOW        // whether file is shown when opened
        );
    }

//------------------------------------------------------------------------
void CHotLink::OnMouseMove(UINT nFlags, CPoint point)
    {
    CRect   rect;
    GetTextRect( rect );
    // if the mouse is over the hot area, show the right cursor
    if ( rect.PtInRect(point) )
        ::SetCursor(AfxGetApp()->LoadCursor( IDC_BROWSE ));

//  CButton::OnMouseMove(nFlags, point);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\keyring.h ===
#include "certmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\listrow.h ===
// ListRow.h : header file
//


#ifndef _LISTROW_
#define _LISTROW_

/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl window

class CListSelRowCtrl : public CListCtrl
{
// Construction
public:
    CListSelRowCtrl();

    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CListSelRowCtrl)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CListSelRowCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CListSelRowCtrl)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void GetHiliteColors();

    void HiliteSelectedCells();
    void HiliteSelectedCell( int iCell, BOOL fHilite = TRUE );
    BOOL FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect );

    void FitString( CString &sz, int cpWidth, CDC* pcdc );

    CBitmap     m_bitmapCheck;
    COLORREF    m_colorHiliteText;
    COLORREF    m_colorHilite;

    DWORD       m_StartDrawingCol;

};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\edtone11.h ===
// EdtOne11.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg dialog

class CEditOne11MapDlg : public CNTBrowsingDialog
{
// Construction
public:
    CEditOne11MapDlg(CWnd* pParent = NULL);   // standard constructor
    virtual void OnOK();


// Dialog Data
    //{{AFX_DATA(CEditOne11MapDlg)
    enum { IDD = IDD_MAP_ONE_TO_ACCNT };
    CString m_sz_mapname;
    BOOL    m_bool_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditOne11MapDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditOne11MapDlg)
    afx_msg void OnBtnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\edwldrul.h ===
// EdWldRul.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRule dialog

class CEditWildcardRule : public CNTBrowsingDialog
{
// Construction
public:
    CEditWildcardRule(IMSAdminBase* pMB, CWnd* pParent = NULL);   // standard constructor
    virtual void OnOK();
    virtual BOOL OnInitDialog();

    // the only public member
    CCertMapRule*   m_pRule;

    // base path to the metabase
    CString m_szMBPath;


// Dialog Data
    //{{AFX_DATA(CEditWildcardRule)
    enum { IDD = IDD_WILDCARDS_2 };
    CListSelRowCtrl m_clistctrl_list;
    CButton m_cbutton_edit;
    CButton m_cbutton_delete;
    CButton m_cbutton_new;
    CString m_sz_description;
    BOOL    m_bool_enable;
    int     m_int_MatchAllIssuers;
    int     m_int_DenyAccess;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditWildcardRule)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL



// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditWildcardRule)
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnEdit();
    afx_msg void OnNew();
    afx_msg void OnDelete();
    afx_msg void OnSelectIssuer();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // more initialization methods
    BOOL FInitRulesList();
    BOOL FillRulesList();

    // editing and updating
    void EnableDependantButtons();
    BOOL EditRule( DWORD iList );

    IMSAdminBase*   m_pMB;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\map11pge.cpp ===
// Map11Pge.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

// persistence and mapping includes
#include "WrapMaps.h"
//#include "wrpprsis.h"
//#include "admutil.h"

#include "ListRow.h"
#include "ChkLstCt.h"

#include "wrapmb.h"

// mapping page includes
#include "brwsdlg.h"
#include "EdtOne11.h"
#include "Ed11Maps.h"
#include "Map11Pge.h"

#include "CrackCrt.h"

#include <iiscnfgp.h>
//#include "WrpMBWrp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define COL_NUM_ENABLED         0
#define COL_NUM_NAME            1
#define COL_NUM_NTACCOUNT       2


#define MB_EXTEND_KEY           _T("Cert11")
#define MB_EXTEND_KEY_MAPS      _T("Cert11/Mappings")

/////////////////////////////////////////////////////////////////////////////
// CMap11Page property page

IMPLEMENT_DYNCREATE(CMap11Page, CPropertyPage)

CMap11Page::CMap11Page() : CPropertyPage(CMap11Page::IDD),
                m_MapsInMetabase( 0 )
    {
    //{{AFX_DATA_INIT(CMap11Page)
    m_csz_i_c = _T("");
    m_csz_i_o = _T("");
    m_csz_i_ou = _T("");
    m_csz_s_c = _T("");
    m_csz_s_cn = _T("");
    m_csz_s_l = _T("");
    m_csz_s_o = _T("");
    m_csz_s_ou = _T("");
    m_csz_s_s = _T("");
    //}}AFX_DATA_INIT
    }

CMap11Page::~CMap11Page()
    {
    ResetMappingList();
    }

void CMap11Page::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMap11Page)
    DDX_Control(pDX, IDC_ADD, m_cbutton_add);
    DDX_Control(pDX, IDC_ISSUER, m_cbutton_grp_issuer);
    DDX_Control(pDX, IDC_ISSUED_TO, m_cbutton_grp_issuedto);
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_EDIT_11MAP, m_cbutton_editmap);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    DDX_Text(pDX, IDC_I_C, m_csz_i_c);
    DDX_Text(pDX, IDC_I_O, m_csz_i_o);
    DDX_Text(pDX, IDC_I_OU, m_csz_i_ou);
    DDX_Text(pDX, IDC_S_C, m_csz_s_c);
    DDX_Text(pDX, IDC_S_CN, m_csz_s_cn);
    DDX_Text(pDX, IDC_S_L, m_csz_s_l);
    DDX_Text(pDX, IDC_S_O, m_csz_s_o);
    DDX_Text(pDX, IDC_S_OU, m_csz_s_ou);
    DDX_Text(pDX, IDC_S_S, m_csz_s_s);
    //}}AFX_DATA_MAP
    }


BEGIN_MESSAGE_MAP(CMap11Page, CPropertyPage)
    //{{AFX_MSG_MAP(CMap11Page)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_EDIT_11MAP, OnEdit11map)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CMap11Page::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_MAIN_BASIC );
    }

/////////////////////////////////////////////////////////////////////////////
// initialization routines

//---------------------------------------------------------------------------
// FInitMapper is called by the routine instantiating this page. After the object
// is first created is when it is called. It allows us to fail gracefully.
BOOL    CMap11Page::FInit(IMSAdminBase* pMB)
        {
        m_pMB = pMB;

        // this has become a simple place
        return TRUE;
        }

//---------------------------------------------------------------------------
BOOL CMap11Page::OnInitDialog()
    {
    //call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // if the initinalization (sp?) succeeded, init the list and other items
    if ( f )
        {
        // init the contents of the list
        FInitMappingList();

        // Fill the mapping list with the stored items
        FillMappingList();

        // set the initial button states
        EnableDependantButtons();
        }

    // set any changes in the info into place
    UpdateData(FALSE);

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL    CMap11Page::FInitMappingList()
    {
    CString sz;
    int             i;

    // setup the friendly name column
    sz.Empty();
    i = m_clistctrl_list.InsertColumn( COL_NUM_ENABLED, sz, LVCFMT_LEFT, 20 );

    // setup the friendly name column
    sz.LoadString( IDS_LIST11_NAME );

    i = m_clistctrl_list.InsertColumn( COL_NUM_NAME, sz, LVCFMT_LEFT, 105 );

    // setup the account column
    sz.LoadString( IDS_LIST11_ACCOUNT );

    i = m_clistctrl_list.InsertColumn( COL_NUM_NTACCOUNT, sz, LVCFMT_LEFT, 195 );

    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL    CMap11Page::FillMappingList()
    {
    // reset the mapping list - get rid of anything in there now
    ResetMappingList();

    // read in the mappings - it adds them to the list
    FReadMappings();

    return TRUE;
    }

//---------------------------------------------------------------------------
//BOOL CMap11Page::FAddMappingToList( C11Mapping* pMap, DWORD iList )
BOOL CMap11Page::FAddMappingToList( C11Mapping* pMap )
    {
    CString sz;
    int     i;
    DWORD   iList;

    // if requested, make sure the mapping is added to the end of the list
    iList = m_clistctrl_list.GetItemCount();

    // get the appropriate "enabled" string
    BOOL fEnabled;
    pMap->GetMapEnabled( &fEnabled );
    if ( fEnabled )
         sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // add the friendly name of the mapping
    // create the new entry in the list box. Do not sort on this entry - yet
    i = m_clistctrl_list.InsertItem( iList, sz );

    // add the friendly name of the mapping
    pMap->GetMapName( sz );
    // create the new entry in the list box. Do not sort on this entry - yet
    m_clistctrl_list.SetItemText( i, COL_NUM_NAME, sz );

    // add the account name of the mapping
    pMap->GetNTAccount( sz );
    m_clistctrl_list.SetItemText( i, COL_NUM_NTACCOUNT, sz );

    // attach the pointer to the mapping as the private data in the list.
    m_clistctrl_list.SetItemData( i, (UINT_PTR)pMap );

    // return whether or not the insertion succeeded
    return TRUE;
    }

//---------------------------------------------------------------------------
void CMap11Page::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        {
        // there are items selected
        m_cbutton_editmap.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        EnableCrackDisplay( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_editmap.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the add button
    m_cbutton_add.EnableWindow( TRUE );
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::EditOneMapping( C11Mapping* pUpdateMap )
    {
    CEditOne11MapDlg        mapdlg;

    // prepare the mapping dialog
    pUpdateMap->GetMapName( mapdlg.m_sz_mapname );
    pUpdateMap->GetMapEnabled( &mapdlg.m_bool_enable );
    pUpdateMap->GetNTAccount( mapdlg.m_sz_accountname );
    pUpdateMap->GetNTPassword( mapdlg.m_sz_password );

    // run the mapping dialog
    if ( mapdlg.DoModal() == IDOK )
        {
        // update its friendly name
        pUpdateMap->SetMapName( mapdlg.m_sz_mapname );

        // set the NT account field of the mapping object
        pUpdateMap->SetNTAccount( mapdlg.m_sz_accountname );

        // set the NT account password field of the mapping object
        pUpdateMap->SetNTPassword( mapdlg.m_sz_password );

        // set whether or not the mapping is enabled
        pUpdateMap->SetMapEnabled( mapdlg.m_bool_enable );

        // NOTE: the caller is resposible for calling UpdateMappingInDispList
        // as the mapping in question may not yet be in the display list

        // this mapping has changed. Mark it to be saved
        MarkToSave( pUpdateMap );

        // return true because the user said "OK"
        return TRUE;
        }

    // return FALSE because the user did not say "OK"
    return FALSE;
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::EditMultipleMappings()
        {
        CEdit11Mappings mapdlg;
        C11Mapping*             pUpdate11Map;
        BOOL                    fSetInitialState = FALSE;
        BOOL                    fEnable;


        // scan the list of seleted items for the proper initial enable button state
                // loop through the selected items, setting each one's mapping
                int     iList = -1;
                while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
                        {
                        // get the mapping item for updating purposes
                        pUpdate11Map = GetMappingInDisplay( iList );
                        ASSERT( pUpdate11Map );
                        if ( !pUpdate11Map )
                                {
                                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                                break;
                                }

                        // get the enable state of the mapping
                        pUpdate11Map->GetMapEnabled( &fEnable );

                        // if this is the first time, just set the initial state
                        if ( !fSetInitialState )
                                {
                                mapdlg.m_int_enable = fEnable;
                                fSetInitialState = TRUE;
                                }
                        else
                                {
                                // if it is different, then go indeterminate and break
                                if ( fEnable != mapdlg.m_int_enable )
                                        {
                                        mapdlg.m_int_enable = 2;
                                        break;
                                        }
                                }
                        }

        // run the mapping dialog
        if ( mapdlg.DoModal() == IDOK )
                {
                // loop through the selected items, setting each one's mapping
                int     iList = -1;
                while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
                        {
                        // get the mapping item for updating purposes
                        pUpdate11Map = GetMappingInDisplay( iList );
                        if ( !pUpdate11Map )
                                {
                                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                                break;
                                }

                        // set the enable flag if requested
                        switch ( mapdlg.m_int_enable )
                                {
                                case 0:         // disable
                                        pUpdate11Map->SetMapEnabled( FALSE );
                                        break;
                                case 1:         // enable
                                        pUpdate11Map->SetMapEnabled( TRUE );
                                        break;
                                }

                        // set the NT account field of the mapping object
                        pUpdate11Map->SetNTAccount( mapdlg.m_sz_accountname );

                        // set the NT account password field of the mapping object
                        pUpdate11Map->SetNTPassword( mapdlg.m_sz_password );

                        // update it in the list control too
                        UpdateMappingInDispList( iList, pUpdate11Map );

                        // this mapping has changed. Mark it to be saved
                        MarkToSave( pUpdate11Map );
                        }

                // activate the apply button
                SetModified();

                // return true because the user said "OK"
                return TRUE;
                }

        // return FALSE because the user did not say "OK"
        return FALSE;
        }


//---------------------------------------------------------------------------
void CMap11Page::UpdateMappingInDispList( DWORD iList, C11Mapping* pMap )
    {
    CString sz;

    // verify the index and the pointer!
    ASSERT( pMap == GetMappingInDisplay(iList) );

    // get the appropriate "enabled" string
    BOOL fEnabled;
    pMap->GetMapEnabled( &fEnabled );
    if ( fEnabled )
        sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // update the "Enabled" indicator
    m_clistctrl_list.SetItemText( iList, COL_NUM_ENABLED, sz );

    // update the mapping name
    pMap->GetMapName( sz );
    m_clistctrl_list.SetItemText( iList, COL_NUM_NAME, sz );

    // update the account name
    pMap->GetNTAccount( sz );
    m_clistctrl_list.SetItemText( iList, COL_NUM_NTACCOUNT, sz );
    }

//---------------------------------------------------------------------------
void CMap11Page::ResetMappingList()
    {
    // first, delete all the mapping objects in the list
    DWORD cbList = m_clistctrl_list.GetItemCount();
    for ( DWORD iList = 0; iList < cbList; iList++ )
        DeleteMapping( GetMappingInDisplay(iList) );

    // reset the mapping list - get rid of anything in there now
    m_clistctrl_list.DeleteAllItems();
    }

//---------------------------------------------------------------------------
void CMap11Page::MarkToSave( C11Mapping* pSaveMap, BOOL fSave )
        {
        // first, we see if it is already in the list. If it is, we have nothing to do
        // unless fSave is set to false, then we remove it from the list
        DWORD cbItemsInList = (DWORD)m_rgbSave.GetSize();
        for ( DWORD i = 0; i < cbItemsInList; i++ )
            {
            if ( pSaveMap == (C11Mapping*)m_rgbSave[i] )
                {
                // go away if fSave, otherwise, double check it isn't
                // anywhere else in the list
                if ( fSave )
                    {
                    return;
                    }
                else
                    {
                    // remove the item from the list
                    m_rgbSave.RemoveAt(i);
                    // don't skip now as the list slid down
                    cbItemsInList--;
                    i--;
                    }
                }
            }

        // since it is not there, we should add it, if fSave is true
        if ( fSave )
            m_rgbSave.Add( (CObject*)pSaveMap );
        }

/////////////////////////////////////////////////////////////////////////////
// CMap11Page message handlers


//---------------------------------------------------------------------------
void CMap11Page::OnOK()
    {
    // this has gotten much simpler
    FWriteMappings();
    CPropertyPage::OnOK();
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::OnApply()
    {
    // this has gotten much simpler
    BOOL f = FWriteMappings();
    // rebuild the display
    FillMappingList();
    return f;
    }

//#define MB_EXTEND_KEY         "nsepm/Cert11/"
//#define MB_EXTEND_KEY_MAPS    "nsepm/Cert11/Mappings/"

//---------------------------------------------------------------------------
// when the user pushes the add button, ask them to load a certificate, then
// add it to the list as a mapping
    void CMap11Page::OnAdd()
    {

    // put this in a try/catch to make errors easier to deal with
    try {
        CString     szFilter;
        szFilter.LoadString( IDS_KEY_OR_CERT_FILE_FILTER );

        // prepare the file dialog variables
        CFileDialog cfdlg(TRUE, NULL, NULL,
                    OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY,
                    (LPCTSTR)szFilter);
		// Disable hook to get Windows 2000 style dialog
		cfdlg.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
        // run the dialog
        if ( cfdlg.DoModal() == IDOK )
            {
            // add the certificate to the mapping list
            if ( FAddCertificateFile( cfdlg.GetPathName() ) )
                {
                // activate the apply button
                SetModified();
                }
            }
        }
    catch ( CException e )
        {
        }
    }

//---------------------------------------------------------------------------
void CMap11Page::OnDelete()
    {
    C11Mapping* pKillMap;

    // ask the user to confirm this decision
    if ( AfxMessageBox(IDS_CONFIRM_DELETE, MB_OKCANCEL) != IDOK )
        return;

    // loop through the selected items. Remove each from the list,
    // then mark it to be deleted.
    int     iList = -1;
    while( (iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED )) >= 0 )
        {
        // get the mapping
        pKillMap = GetMappingInDisplay( iList );

        // remove it from the list
        m_clistctrl_list.DeleteItem( iList );

        // if it has not yet been applied to the metabase, continue
        if ( pKillMap->iMD == NEW_OBJECT )
            {
            // since this mapping never existed, we can just remove it from the add/edit lists
            MarkToSave( pKillMap, FALSE );

            // go to the next selected object
            continue;
            }

        // mark the item to be deleted from the metabase
        m_rgbDelete.Add( (CObject*)pKillMap );
        }

    // activate the apply button
    SetModified();
    }

//---------------------------------------------------------------------------
void CMap11Page::OnEdit11map()
    {
    int             iList;
    C11Mapping*     pUpdateMap;

    // what happens here depends on if just one mapping is selected, or many
    switch( m_clistctrl_list.GetSelectedCount() )
        {
        case 0:         // do nothing - should not get here because button grays out
            ASSERT( FALSE );
            break;

        case 1:         // get the mapping for update and run single edit dialog
            // get index of the selected list item
            iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
            ASSERT( iList >= 0 );


            // get the mapping item for updating purposes
            pUpdateMap = GetMappingInDisplay( iList );
            if ( !pUpdateMap )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                break;
                }

            // edit the mapping, update it if successful, delete if not
            if ( EditOneMapping(pUpdateMap) )
                {
                UpdateMappingInDispList( iList, pUpdateMap );
                // activate the apply button
                SetModified();
                }
            break;

        default:        // run the multi edit dialog
            EditMultipleMappings();
            break;
        }
    }

//---------------------------------------------------------------------------
void CMap11Page::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    *pResult = 0;

    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        OnEdit11map();
    }

//---------------------------------------------------------------------------
void CMap11Page::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    C11Mapping*     pSelMap;
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();

    // fill in the cracked information for the selected mapping - if there is only one
    if ( m_clistctrl_list.GetSelectedCount() == 1 )
        {
        // get index of the selected list item
        int i = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
        ASSERT( i >= 0 );

        // get the mapper index for the item
        pSelMap = GetMappingInDisplay( i );
        if ( pSelMap )
            {
            DisplayCrackedMap( pSelMap );
            }
        }
    else
        {
        // either multiple, or no mappings selected
        EnableCrackDisplay( FALSE );
        }
    }


//================================================================================
// special display
//---------------------------------------------------------------------------
BOOL CMap11Page::DisplayCrackedMap( C11Mapping* pMap )
    {
    PUCHAR                          pCert;
    DWORD                           cbCert;
    CString                         sz;

    // obtain a reference to the certificate
    if ( !pMap->GetCertificate( &pCert, &cbCert ) )
            return FALSE;

    // crack the certificate
    CCrackedCert    cracker;
    if ( !cracker.CrackCert( pCert, cbCert ) )
            return FALSE;

    // fill in all the fields
    cracker.GetIssuerCountry( sz );
    m_csz_i_c = sz;

    cracker.GetIssuerOrganization( sz );
    m_csz_i_o = sz;

    cracker.GetIssuerUnit( sz );
    m_csz_i_ou = sz;

    cracker.GetSubjectCountry( sz );
    m_csz_s_c = sz;

    cracker.GetSubjectCommonName( sz );
    m_csz_s_cn = sz;

    cracker.GetSubjectLocality( sz );
    m_csz_s_l = sz;

    cracker.GetSubjectOrganization( sz );
    m_csz_s_o = sz;

    cracker.GetSubjectUnit( sz );
    m_csz_s_ou = sz;

    cracker.GetSubjectState( sz );
    m_csz_s_s = sz;

    UpdateData( FALSE );

    // return success
    return TRUE;
    }

//---------------------------------------------------------------------------
void CMap11Page::ClearCrackDisplay()
    {
    m_csz_i_c.Empty();
    m_csz_i_o.Empty();
    m_csz_i_ou.Empty();
    m_csz_s_c.Empty();
    m_csz_s_cn.Empty();
    m_csz_s_l.Empty();
    m_csz_s_o.Empty();
    m_csz_s_ou.Empty();
    m_csz_s_s.Empty();
    UpdateData( FALSE );
    }

//---------------------------------------------------------------------------
void CMap11Page::EnableCrackDisplay( BOOL fEnable )
    {
    if ( !fEnable )
            ClearCrackDisplay();
    m_cbutton_grp_issuer.EnableWindow( fEnable );
    m_cbutton_grp_issuedto.EnableWindow( fEnable );
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::FReadMappings()
    {
    BOOL                    f;
    C11Mapping*             pMap;
    DWORD                   cbData;
    PVOID                   pData;
    DWORD                   fEnabled;
    CString                 sz;
    BOOL                    fRet = TRUE;

    // before messing with the metabase, prepare the strings we will need
    CString                 szBasePath = m_szMBPath + _T('/');
    CString                 szRelativePath = MB_EXTEND_KEY_MAPS;
    CString                 szObjectPath = m_szMBPath + _T('/') + szRelativePath;
    CString                 szMapPath;

    // prepare the metabase wrappers
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);

    // open the base object
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_READ );
    ASSERT( f );
    if ( !f )
        {
        return FALSE;
        }

    // for now, at least, we are reading in all the mappings. reset the m_nNamer counter
    // so that we end up with a somewhat accurate reading of the last number-name in the list.
    m_MapsInMetabase = 0;

    // Loop the items in the metabase, adding each to the napper.
    DWORD index = 0;
    CString     szEnum;
    while ( mbWrap.EnumObjects(_T(""), szEnum.GetBuffer(MAX_PATH*sizeof(WCHAR)),
                        MAX_PATH*sizeof(WCHAR), index) )
        {
        szEnum.ReleaseBuffer();

        // keep track of the number of mappings we encounter
        m_MapsInMetabase++;

        // build the final mapping object path
        szMapPath.Format( _T("/%s"), szEnum );

        // make a new mapping object
        pMap = PNewMapping();

        if (pMap == NULL) {
            SetLastError(E_OUTOFMEMORY);
            fRet = FALSE;
            break;
        }

        // install the object name into the mapping
        pMap->iMD = m_MapsInMetabase;

        // get the certificate
        pData = mbWrap.GetData( szMapPath, MD_MAPCERT, IIS_MD_UT_SERVER, BINARY_METADATA, &cbData );
        if ( pData )
            {
            // set the data into place
            pMap->SetCertificate( (PUCHAR)pData, cbData );
            // free the buffer
            mbWrap.FreeWrapData( pData );
            }

        // get the NT Account - a string
        cbData = METADATA_MAX_NAME_LEN;
        if ( Get11String( &mbWrap, szMapPath, MD_MAPNTACCT, sz) )
            {
            pMap->SetNTAccount( sz );
            }

        // get the NT Password
        cbData = METADATA_MAX_NAME_LEN;
        if ( Get11String( &mbWrap, szMapPath, MD_MAPNTPWD, sz) )
            {
            pMap->SetNTPassword( sz );
            }

        // get the Enabled flag
        if ( mbWrap.GetDword( szMapPath, MD_MAPENABLED, IIS_MD_UT_SERVER, &fEnabled) )
            pMap->SetMapEnabled( (fEnabled > 0) );

        // get the mapping name
        cbData = METADATA_MAX_NAME_LEN;
        if ( Get11String( &mbWrap, szMapPath, MD_MAPNAME, sz) )
            {
            pMap->SetMapName( sz );
            }

        // add the mapping to the list
        FAddMappingToList( pMap );

        // increment the index
        index++;
        }
    szEnum.ReleaseBuffer();

    // close the mapping object
    mbWrap.Close();

    // return success
    return fRet;
    }

//---------------------------------------------------------------------------
// IMPORTANT: There is a bug in the mapping namespace extension where, even
// though we are using the unicode metabase interface, all the strings are
// expected to be ansi. This means that we cannont use the wrapmb getstring
// and setstring calls with regards to the nsmp extetention. That is why
// there are these two string wrapper classes that

// also, all the strings used here are IIS_MD_UT_SERVER, so we can elimiate that parameter.
BOOL CMap11Page::Get11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz)
    {
    DWORD   dwcb;
    BOOL    fAnswer = FALSE;

    // get the string using the self-allocating get data process
    // that that it is cast as ANSI so the sz gets it right.
    // NOTE: This must be gotten as an ANSI string!
    PCHAR  pchar = (PCHAR)pmb->GetData( pszPath, dwPropID, IIS_MD_UT_SERVER, STRING_METADATA, &dwcb );
    if ( pchar )
        {
        // set the answer
        sz = pchar;

        fAnswer = TRUE;
        // clean up
        pmb->FreeWrapData( pchar );
        }

    // return the answer
    return fAnswer;
    }

//---------------------------------------------------------------------------
/* INTRINSA suppress=null_pointers, uninitialized */
BOOL CMap11Page::Set11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz, DWORD dwFlags )
    {
    USES_CONVERSION;
    // Easy. Just set it as data
    // Make sure it is set back as an ANSI string though
    LPSTR pA = T2A((LPTSTR)(LPCTSTR)sz);
    return pmb->SetData( pszPath, dwPropID, IIS_MD_UT_SERVER, STRING_METADATA,
                            (PVOID)pA, strlen(pA)+1, dwFlags );
    }

//---------------------------------------------------------------------------
// we only need to write out the mappings that have been either changed or added.

// Thoughts on further optimizations: The bare minimum info about where to find
// a mapping in the metabase could be stored in the metabase. Then, the mappings
// would only be loaded when they were added to be edited or displayed in the
// cracked list. The private data for each item in the list would have to have
// some sort of reference to a position in the metabase.

BOOL CMap11Page::FWriteMappings()
    {
    BOOL                            f;
    DWORD                           i,j;
    DWORD                           cMappings;
    C11Mapping*                     pMap;
    C11Mapping*                     pMapTemp;

    CString                         sz;
    DWORD                           dwEnabled;
    PUCHAR                          pCert;
    DWORD                           cbCert;
    DWORD                           iList;

    // before messing with the metabase, prepare the strings we will need
    CString         szTempPath;
    CString         szBasePath = m_szMBPath + _T("/Cert11");
    CString         szRelativePath = _T("/Mappings");
    CString         szObjectPath = szRelativePath + _T('/');

    // prepare the base metabase wrapper
    CWrapMetaBase   mbBase;
    f = mbBase.FInit(m_pMB);
    if ( !f )
        {
        AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
        return FALSE;
        }

        // first, we have to open the Cert11 object. If it doesn't exist
        // then we have to add it tothe metabase
        if ( !mbBase.Open( szBasePath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
            {
            // Cert11 does not exist - open the namespace base and add it
            szTempPath = m_szMBPath + _T('/');
            if ( !mbBase.Open( szTempPath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                return FALSE;   // serious problems if we can't open the base
                }

            // add the Cert11 object
            szTempPath = _T("Cert11");
            f = mbBase.AddObject( szTempPath );
            mbBase.Close();
            if ( !f )
                {
                AfxMessageBox( IDS_ERR_CANTADD );
                return FALSE;
                }

            // try again to open the Cert11. Fail if it doesn't work
            if ( !mbBase.Open( szBasePath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                return FALSE;
                }
            }

    //==========
    // start by deleting all the mappings in the to-be-deleted list
    cMappings = (DWORD)m_rgbDelete.GetSize();

    // only bother if there are items waiting to be deleted
    if ( cMappings > 0 )
        {
        // get the count of mappings in the display list
        DWORD   cList = m_clistctrl_list.GetItemCount();

        // sort the mappings, in decending order
        for ( i = 0; i < cMappings-1; i++ )
            {
            pMap = (C11Mapping*)m_rgbDelete[i];
            for ( j = i; j < cMappings; j++ )
                {
                pMapTemp = (C11Mapping*)m_rgbDelete[j];
                if ( pMap->iMD < pMapTemp->iMD )
                    {
                    m_rgbDelete.SetAt( i, (CObject*)pMapTemp );
                    m_rgbDelete.SetAt( j, (CObject*)pMap );
                    pMap = pMapTemp;
                    }
                }
            }

        // loop the mappings, deleting each from the metabase
        for ( i = 0; i < cMappings; i++ )
            {
            // get the mapping object
            pMap = (C11Mapping*)m_rgbDelete[i];
            if ( !pMap || (pMap->iMD == NEW_OBJECT) )
                continue;

            // build the relative path to the object in question.
            szObjectPath.Format( _T("%s/%d"), szRelativePath, pMap->iMD );

            // delete that mapping's object from the metabase
            f = mbBase.DeleteObject( szObjectPath );

            // decrement the number of maps in the metabase
            m_MapsInMetabase--;

            // loop the items in the list, decrementing the index of those
            // that are above it. Yes - this is non-optimal, but its what
            // has to be done for now
            for ( iList = 0; iList < cList; iList++ )
                {
                pMapTemp = GetMappingInDisplay(iList);
                if ( (pMapTemp->iMD > pMap->iMD) && (pMapTemp->iMD != NEW_OBJECT) )
                    pMapTemp->iMD--;
                }

            // since we will no longer be needing this mapping, delete it
            DeleteMapping( pMap );
            }

        // reset the to-be-deleted list
        m_rgbDelete.RemoveAll();
        }

    //==========
    // get the number mappings in the to-be-saved list
    cMappings = (DWORD)m_rgbSave.GetSize();

    // loop the mappings, adding each to the metabase
    for ( i = 0; i < cMappings; i++ )
        {
        // get the mapping object
        pMap = (C11Mapping*)m_rgbSave[i];
        ASSERT( pMap );

        // if the object is already in the metabase, just open it.
        if ( pMap->iMD != NEW_OBJECT )
            {
            // build the relative path to the object
            szObjectPath.Format( _T("%s/%d"), szRelativePath, pMap->iMD );
            }
        else
            {
            // set up the name of the new mapping as one higher
            // than the number of mappings in the metabase
            pMap->iMD = m_MapsInMetabase + 1;

            // build the relative path to the object
            szObjectPath.Format( _T("%s/%d"), szRelativePath, pMap->iMD );

            // add the mapping object to the base
            f = mbBase.AddObject( szObjectPath );
            if ( f )
                {
                // increment the number of maps in the metabase
                m_MapsInMetabase++;
                }
            }

        // write the object's parameters
        if ( f )
            {
            // save the certificate
            if ( pMap->GetCertificate(&pCert, &cbCert) )
                {
                // set the data into place in the object
                f = mbBase.SetData( szObjectPath, MD_MAPCERT, IIS_MD_UT_SERVER, BINARY_METADATA,
                pCert, cbCert, METADATA_SECURE | METADATA_INHERIT );
                }

            // save the NTAccount
            if ( pMap->GetNTAccount(sz) )
                {
                // set the data into place in the object
                f = Set11String(&mbBase, szObjectPath, MD_MAPNTACCT, sz, METADATA_SECURE);
                }

            // save the password - secure
            if ( pMap->GetNTPassword(sz) )
                {
                // set the data into place in the object
                f = Set11String(&mbBase, szObjectPath, MD_MAPNTPWD, sz, METADATA_SECURE);
                }

            // save the map's name
            if ( pMap->GetMapName(sz) )
                {
                // set the data into place in the object
                f = Set11String(&mbBase, szObjectPath, MD_MAPNAME, sz);
                }

            // save the Enabled flag
            // server reads the flag as the value of the dword
            if ( pMap->GetMapEnabled(&f) )
                {
                dwEnabled = (DWORD)f;
                f = mbBase.SetDword( szObjectPath, MD_MAPENABLED, IIS_MD_UT_SERVER, dwEnabled );
                }
            }
        }

    // close the base object
    mbBase.Close();

    // save the metabase
    mbBase.Save();

    // reset the to-be-saved list
    m_rgbSave.RemoveAll();

    // return success
    return TRUE;
    }

//---------------------------------------------------------------------------
C11Mapping*     CMap11Page::PNewMapping()
    {
    // the way it should be
    return new C11Mapping();
    }

//---------------------------------------------------------------------------
void CMap11Page::DeleteMapping( C11Mapping* pMap )
    {
    // the way it should be
    delete pMap;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\edwldrul.cpp ===
// EdWldRul.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "certmap.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"
#include "IssueDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define ACCESS_DENY         0
#define ACCESS_ACCEPT       1

#define MATCH_ISSUER_ALL    0
#define MATCH_ISSUER_SOME   1


#define COL_CERT_FIELD          0
#define COL_SUB_FIELD           1
#define COL_MATCH_CRITERIA      2


// notes on the list:
// the list is the only source of current data for the rule elements. The actual
// rule object is not updated with changes in the list until the user hits IDOK.
// that way we can cancel without changing the object. All mapping between the
// text in the list and the binary formats used by the server are done at the
// beginning and end of the dialog


/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRule dialog

//---------------------------------------------------------------------------
CEditWildcardRule::CEditWildcardRule(IMSAdminBase* pMB, CWnd* pParent /*=NULL*/)
    : CNTBrowsingDialog(CEditWildcardRule::IDD, pParent),
    m_pMB(pMB)
    {
    //{{AFX_DATA_INIT(CEditWildcardRule)
    m_sz_description = _T("");
    m_bool_enable = FALSE;
    m_int_MatchAllIssuers = -1;
    m_int_DenyAccess = -1;
    //}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::DoDataExchange(CDataExchange* pDX)
    {
    CNTBrowsingDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEditWildcardRule)
    DDX_Control(pDX, IDC_EDIT, m_cbutton_edit);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    DDX_Control(pDX, IDC_NEW, m_cbutton_new);
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
    DDX_Check(pDX, IDC_ENABLE_RULE, m_bool_enable);
    DDX_Radio(pDX, IDC_ALL_ISSUERS, m_int_MatchAllIssuers);
    DDX_Radio(pDX, IDC_REFUSE_LOGON, m_int_DenyAccess);
    //}}AFX_DATA_MAP
    }

//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CEditWildcardRule, CNTBrowsingDialog)
    //{{AFX_MSG_MAP(CEditWildcardRule)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_BN_CLICKED(IDC_NEW, OnNew)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_SELECT_ISSUER, OnSelectIssuer)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//---------------------------------------------------------------------------
BOOL CEditWildcardRule::FInitRulesList()
    {
    CString sz;
    int     i;

    // setup the main field
    sz.LoadString( IDS_CERT_FIELD );

    i = m_clistctrl_list.InsertColumn( COL_CERT_FIELD, sz, LVCFMT_LEFT, 100 );

    // setup the sub field
    sz.LoadString( IDS_SUB_FIELD );

    i = m_clistctrl_list.InsertColumn( COL_SUB_FIELD, sz, LVCFMT_LEFT, 70 );

    // setup the match criteria column
    sz.LoadString( IDS_MATCH_CRITERIA );

    i = m_clistctrl_list.InsertColumn( COL_MATCH_CRITERIA, sz, LVCFMT_LEFT, 255 );

    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CEditWildcardRule::FillRulesList()
    {
    CERT_FIELD_ID   idCertField;
    LPBYTE          pContent;
    DWORD           cbContent;
    LPSTR           psz;

    CString         sz;
    int             i;

    // get the number of subfield rules
    DWORD cbRules = m_pRule->GetRuleElemCount();

    // loop the elements, adding each to the list
    for ( DWORD j = 0; j < cbRules; j++ )
        {
        // get the raw data for the rule element
        if ( !m_pRule->GetRuleElem( j, &idCertField, (PCHAR*)&pContent, &cbContent, &psz ) )
            continue;       // the call failed - try the next

        // start converting the data into readable form and adding it to the list
        sz = MapIdToField( idCertField );
        // create the new entry in the list box.
        i = m_clistctrl_list.InsertItem( j, sz );

        // add the subfield data
        sz = MapAsn1ToSubField( psz );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, sz );

        // add the content data - reuse the psz pointer
        if ( BinaryToMatchRequest( pContent, cbContent, &psz ) )
            m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, psz );

        // finally, attach the id cert field as user data to the item
        m_clistctrl_list.SetItemData( i, idCertField );
        }

        return TRUE;
    }

// editing and updating

//---------------------------------------------------------------------------
void CEditWildcardRule::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();

    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_edit.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_edit.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the new button
    m_cbutton_new.EnableWindow( TRUE );
}

//---------------------------------------------------------------------------
BOOL CEditWildcardRule::EditRule( DWORD iList )
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;

    // fill in its data
    editDlg.m_int_field = m_clistctrl_list.GetItemData( iList );
    editDlg.m_sz_subfield = m_clistctrl_list.GetItemText( iList, COL_SUB_FIELD );
    editDlg.m_sz_criteria = m_clistctrl_list.GetItemText( iList, COL_MATCH_CRITERIA );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // must convert the field into a string too
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        m_clistctrl_list.SetItemText( iList, COL_CERT_FIELD, sz );

        m_clistctrl_list.SetItemData( iList, id );
        m_clistctrl_list.SetItemText( iList, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( iList, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );
        }
    return TRUE;
    }

/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRule message handlers

//---------------------------------------------------------------------------
BOOL CEditWildcardRule::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CNTBrowsingDialog::OnInitDialog();

    // set the easy default strings 
    m_sz_accountname = m_pRule->GetRuleAccount();   // managed by CNTBrowsingDialog from here on
    m_sz_description = m_pRule->GetRuleName();
    m_bool_enable = m_pRule->GetRuleEnabled();

    // set up the deny access radio buttons
    if ( m_pRule->GetRuleDenyAccess() )
        m_int_DenyAccess = ACCESS_DENY;
    else
        m_int_DenyAccess = ACCESS_ACCEPT;

    // set up the match issuer buttons
    if ( m_pRule->GetMatchAllIssuer() )
        m_int_MatchAllIssuers = MATCH_ISSUER_ALL;
    else
        m_int_MatchAllIssuers = MATCH_ISSUER_SOME;

    // initialize the list
    FInitRulesList();
    FillRulesList();
    EnableDependantButtons();

    // initialize the password
    m_sz_password = m_pRule->GetRulePassword();

    // exchange the data
    UpdateData( FALSE );

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
// this is the part where we fill in most of the items
void CEditWildcardRule::OnOK() 
    {
    CERT_FIELD_ID   id;
    CString         szSub, sz;
    LPBYTE          pbBin;
    DWORD           cbBin;
    UINT            cItems;
    UINT            iItem;


    // update the data
    UpdateData( TRUE );

    //======== store the rule elements
    // start by resetting the entire rule - that way we don't have to
    // mess with individual elements in the list, allowing us to cancel. 
    // But that is ok, because we can just spin through
    // the ones in the list very quickly and re-add them

    // remove the existing elements from the list.
    cItems = m_pRule->GetRuleElemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        m_pRule->DeleteRuleElem( 0 );

    // add all the items in the list
    cItems = m_clistctrl_list.GetItemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        {
        // prepare the field id
        id = (CERT_FIELD_ID)m_clistctrl_list.GetItemData( iItem );

        // prepare the subfield
        sz = m_clistctrl_list.GetItemText(iItem, COL_SUB_FIELD);
        szSub = MapSubFieldToAsn1( (PCHAR)(LPCSTR)sz );

        // prepare the data
        sz = m_clistctrl_list.GetItemText(iItem, COL_MATCH_CRITERIA);
        if ( !MatchRequestToBinary((PCHAR)(LPCSTR)sz, &pbBin, &cbBin) )
            continue;

        // add the element to the rule
        m_pRule->AddRuleElem( 0xffffffff, id, (PCHAR)(LPCSTR)szSub, pbBin, cbBin );

        // free the binary match data
        FreeMatchConversion( pbBin );
        }

    // set the easy data
    m_pRule->SetRuleName( (PCHAR)(LPCSTR)m_sz_description );
    m_pRule->SetRuleEnabled( m_bool_enable );

    // store the deny access radio buttons
    m_pRule->SetRuleDenyAccess( m_int_DenyAccess == ACCESS_DENY );

    // store the match issuer buttons
    m_pRule->SetMatchAllIssuer( m_int_MatchAllIssuers == MATCH_ISSUER_ALL );

    
    // we have to set the account name into place here
    m_pRule->SetRuleAccount( (PCHAR)(LPCSTR)m_sz_accountname );


    // store the password
    m_pRule->SetRulePassword( (PCHAR)(LPCSTR)m_sz_password );

    // it is valid
    CNTBrowsingDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    *pResult = 0;
    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        OnEdit();
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnEdit() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // edit the item
    EditRule( iList );
    }

//---------------------------------------------------------------------------
// actually very similar to editing an existing element
void CEditWildcardRule::OnNew() 
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;

    // fill in its data
    editDlg.m_int_field = CERT_FIELD_SUBJECT;
//  editDlg.m_sz_subfield = MapAsn1ToSubField( "O" );
    editDlg.m_sz_subfield = "O";
    
    editDlg.m_sz_criteria.LoadString( IDS_WILDSTRING );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // get the index for adding to the end of the list
        int iEnd = m_clistctrl_list.GetItemCount();

        // Start with the cert field
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        int i = m_clistctrl_list.InsertItem( iEnd, sz );

        m_clistctrl_list.SetItemData( i, id );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );
        }
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnDelete() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // delete the item from the display list
    m_clistctrl_list.DeleteItem ( iList );
    }

//---------------------------------------------------------------------------
// simple - just run the issuer dialog
void CEditWildcardRule::OnSelectIssuer() 
    {
    CSelectIssuersDlg   dlg(m_pMB);

    // prep the dialog
    dlg.m_pRule = m_pRule;
    dlg.m_szMBPath = m_szMBPath;

    dlg.m_sz_caption.LoadString( IDS_MATCH_ON_ISSUERS );

    // run it
    if ( dlg.DoModal() == IDOK )
        {
        UpdateData( TRUE );
        m_int_MatchAllIssuers = MATCH_ISSUER_SOME;
        UpdateData( FALSE );
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\map11pge.h ===
// Map11Pge.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMap11Page dialog

class CMap11Page : public CPropertyPage
{
    DECLARE_DYNCREATE(CMap11Page)

// Construction
public:
    CMap11Page();
    ~CMap11Page();

    BOOL    FInit(IMSAdminBase* pMB);

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    // base path for to the metabase
    CString m_szMBPath;

// Dialog Data
    //{{AFX_DATA(CMap11Page)
    enum { IDD = IDD_11CERT_MAPPING };
    CCheckListCtrl  m_clistctrl_list;
    CButton m_cbutton_add;
    CButton m_cbutton_grp_issuer;
    CButton m_cbutton_grp_issuedto;
    CButton m_cbutton_editmap;
    CButton m_cbutton_delete;
    CString m_csz_i_c;
    CString m_csz_i_o;
    CString m_csz_i_ou;
    CString m_csz_s_c;
    CString m_csz_s_cn;
    CString m_csz_s_l;
    CString m_csz_s_o;
    CString m_csz_s_ou;
    CString m_csz_s_s;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMap11Page)
    public:
    virtual void OnOK();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMap11Page)
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnEdit11map();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    afx_msg void DoHelp();

    // more initialization methods
    BOOL FInitMappingList();
    BOOL FillMappingList();

    // more initialization methods
    BOOL FReadMappings();
    BOOL FWriteMappings();

    // control the maps in the list
//  BOOL FAddMappingToList( C11Mapping* pMap, DWORD iMap );
//  BOOL FAddMappingToList( C11Mapping* pMap, DWORD iList = 0xFFFFFFFF );
    // always adds to the end of the list
    BOOL FAddMappingToList( C11Mapping* pMap );

    // editing and updating
    BOOL EditOneMapping( C11Mapping* pUpdateMap );
    BOOL EditMultipleMappings();
    void EnableDependantButtons();
    void UpdateMappingInDispList( DWORD iList, C11Mapping* pUpdateMap );

    // adding a new certificate
    BOOL FAddCertificateFile( CString szFile );
    BOOL FAddCertificate( PUCHAR pCertificate, DWORD cbCertificate );

    // special display
    BOOL DisplayCrackedMap( C11Mapping* pUpdateMap );
    void ClearCrackDisplay();
    void EnableCrackDisplay( BOOL fEnable = TRUE );

    void ResetMappingList();
    C11Mapping* GetMappingInDisplay( DWORD iList ) {return (C11Mapping*)m_clistctrl_list.GetItemData(iList);}
    void MarkToSave( C11Mapping* pSaveMap, BOOL fSave = TRUE );

    C11Mapping* PNewMapping();
    void DeleteMapping( C11Mapping* pMap );

    BOOL Get11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz);
    BOOL Set11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz, DWORD dwFlags = METADATA_INHERIT);

    // list of names of objects to be deleted
    CObArray    m_rgbDelete;

    // list of objects to be saved
    CObArray    m_rgbSave;

    // number of objects in the etabase
    DWORD   m_MapsInMetabase;

    IMSAdminBase*   m_pMB;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\listrow.cpp ===
// ListRow.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "ListRow.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define SZ_RES_COLOR_PREFS      "Control Panel\\Colors"
#define SZ_RES_COLOR_HILITE     "Hilight"
#define SZ_RES_COLOR_HILITETEXT "HilightText"


/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl
//-----------------------------------------------------------------------------------
CListSelRowCtrl::CListSelRowCtrl():
        m_StartDrawingCol( 0 )
    {
    }

//-----------------------------------------------------------------------------------
CListSelRowCtrl::~CListSelRowCtrl()
    {
    }


//-----------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CListSelRowCtrl, CListCtrl)
    //{{AFX_MSG_MAP(CListSelRowCtrl)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::GetHiliteColors()
    {
    // get the hilite color
    m_colorHilite = GetSysColor( COLOR_HIGHLIGHT );

    // get the hilited text color
    m_colorHiliteText = GetSysColor( COLOR_HIGHLIGHTTEXT );
    }



/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl message handlers

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
    {
    CRect       rcItem = lpDrawItemStruct->rcItem;
    CRect       rcSection;
    UINT        itemID = lpDrawItemStruct->itemID;
    UINT        cpLeft = rcItem.left;
    CString     sz;
    LV_COLUMN   colData;
    COLORREF    colorTextOld;
    COLORREF    colorBackOld;

    // setup the CDC object
    CDC         cdc;
    cdc.Attach( lpDrawItemStruct->hDC );

#ifdef _DEBUG
    if ( m_StartDrawingCol == 0 )
        sz.Empty();
#endif

    // clear the columnd buffer
    ZeroMemory( &colData, sizeof(colData) );
    colData.mask = LVCF_WIDTH;

    // if this is the selected item, prepare the background and the text color
    BOOL fSelected = lpDrawItemStruct->itemState & ODS_SELECTED;
    if ( fSelected )
        {
        GetHiliteColors();
        colorTextOld = cdc.SetTextColor( m_colorHiliteText );
        colorBackOld = cdc.SetBkColor( m_colorHilite );
        }

    // starting with the m_StartDrawingCol column, draw the columns
    // do it in a loop, just skipping until we hit m_StartDrawingCol
    DWORD iCol = 0;
    while ( GetColumn(iCol, &colData) )
        {
        // see if we are ready yet
        if ( iCol < m_StartDrawingCol )
            {
            // set the new left.
            cpLeft += colData.cx;
            // increment the column counter
            iCol++;
            continue;
            }

        // prepare the background but once
        if ( iCol == m_StartDrawingCol )
            {
            // prepare the background
            rcSection = rcItem;
            rcSection.left = cpLeft;
            rcSection.right--;
            CBrush  brush;
            if ( lpDrawItemStruct->itemState & ODS_SELECTED )
                brush.CreateSolidBrush( m_colorHilite );
            else
                brush.CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
            cdc.FillRect( &rcSection, &brush );
            }


        // display the name
        sz = GetItemText( itemID, iCol );
        if ( !sz.IsEmpty() )
            {
            // figure out the sectional rect
            rcSection = rcItem;
            rcSection.left = cpLeft + 2;
            rcSection.right = cpLeft + colData.cx - 1;
            
            // fit the string into the required space
            FitString( sz, rcSection.right - rcSection.left, &cdc );

            //draw the string
            cdc.DrawText( sz, &rcSection, DT_SINGLELINE|DT_LEFT|DT_BOTTOM|DT_NOPREFIX );
            }

        // set the new left.
        cpLeft += colData.cx;
        // increment the column counter
        iCol++;
        }

    // if this is the selected item, restore the colors
    if ( fSelected )
        {
        cdc.SetTextColor( colorTextOld );
        cdc.SetBkColor( colorBackOld );
        }

    // cleanup the CDC object
    cdc.Detach();
    }


//------------------------------------------------------------------------
void CListSelRowCtrl::FitString( CString &sz, int cpWidth, CDC* pcdc )
    {
    CSize       size;
    UINT        cch;
    CString     szEllipsis;

    // start by testing the existing width
    size = pcdc->GetTextExtent( sz );
    if ( size.cx <= cpWidth ) return;

    // initialize szTrunc and szEllipsis
    cch = sz.GetLength();

    szEllipsis.LoadString(IDS_ELLIPSIS);

    // while we are too big, truncate one letter and add an ellipsis
    while( (size.cx > cpWidth) && (cch > 1) )
        {
        // chop off the last letter of the string - not counting the ...
        cch--;
        sz = sz.Left( cch );

        // add the elipsis (spelling?)
        sz += szEllipsis;

        // get the length
        size = pcdc->GetTextExtent( sz );
        }
    }







//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCells()
    {
    int iList = -1;
    while( (iList = GetNextItem( iList, LVNI_SELECTED )) >= 0 )
        HiliteSelectedCell( iList );
    }

//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCell( int iCell, BOOL fHilite )
    {
    // if there is no selected cell, do nothing
    if ( iCell < 0 )
        return;

    // get the rect to draw
    CRect   rect;
    if ( !FGetCellRect(iCell, -1, &rect) )
        {
        ASSERT(FALSE);
        return;
        }

    // get the client rect
    CRect   rectClient;
    GetClientRect( rectClient );

    // make sure it fits ok (problems can occur here when scrolled)
    // don't want it to draw in the column titles
    if ( rect.top < (rect.bottom - rect.top) )
        return;

    // now prepare to draw
    CDC *pdc = GetDC();

    // clip to the client area
    pdc->IntersectClipRect( rectClient );

    // set up the brush
    CBrush  cbrush;
    if ( fHilite )
        cbrush.CreateSolidBrush( RGB(192,192,192) );
    else
        cbrush.CreateSolidBrush( RGB(0xFF,0xFF,0xFF) );

    // draw the hilite rect
    pdc->FrameRect( rect, &cbrush );

    // cleanup
    ReleaseDC( pdc );
    }

//------------------------------------------------------------------------
BOOL    CListSelRowCtrl::FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect )
    {
    // first, get the rect that the list thinks is appropriate
    if ( !GetItemRect(iRow, pcrect, LVIR_BOUNDS) )
        return FALSE;

    // if iCol < 0, then return the total size of the row
    if ( iCol < 0 )
        return TRUE;

    // trim the horizontal dimension to the correct column positioning
    LONG    cpLeft;
    LONG    cpRight = 0;
    for ( WORD i = 0; i <= iCol; i++ )
        {
        // set the left side
        cpLeft = cpRight;

        // get the right
        LONG cpWidth = GetColumnWidth(i);
        if ( cpWidth < 0 ) return FALSE;
        cpRight += cpWidth;
        }

    // well, now trim it seeing as we have the right values
    pcrect->left = cpLeft;
    pcrect->right = cpRight;
    
    // success!
    return TRUE;
    }

#define MAKE_LPARAM(x,y) ( ((unsigned long)(y)<<16) | ((unsigned long)(x)) )

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
    {
    // force the point to be in the right place
    point.x = 6;
    LPARAM lp = MAKE_LPARAM(point.x, point.y);
//  DefWindowProc(WM_LBUTTONDBLCLK, nFlags, lp );
    CListCtrl::OnLButtonDblClk( nFlags, point);
    }

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
    {
    point.x = 6;
    LPARAM lp = MAKE_LPARAM(point.x, point.y);
//  DefWindowProc(WM_LBUTTONDOWN, nFlags, lp );
    CListCtrl::OnLButtonDown( nFlags, point);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\hotlink.h ===
// HotLink.h : header file
//
#ifndef   _HotLink_h_file_123987_
#define   _HotLink_h_file_123987_



/////////////////////////////////////////////////////////////////////////////
// CHotLink window

class CHotLink : public CButton
{
// Construction
public:
    CHotLink();

// Attributes
public:
    BOOL    m_fBrowse;
    BOOL    m_fExplore;
    BOOL    m_fOpen;

// Operations
public:
    void Browse();
    void Explore();
    void Open();

    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

    // set the title string
    void SetTitle( CString sz );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CHotLink)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CHotLink();

    // Generated message map functions
protected:
    //{{AFX_MSG(CHotLink)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    // height and width of the displayed text
    void GetTextRect( CRect &rect );
    CSize   m_cpTextExtents;

    // tracking the mouse flag
    BOOL    m_CapturedMouse;

    // init the font
    BOOL    m_fInitializedFont;
};

/////////////////////////////////////////////////////////////////////////////
#endif   /*_HotLink_h_file_123987_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\mapwpge.h ===
// MapWPge.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMapWildcardsPge dialog

class CMapWildcardsPge : public CPropertyPage
{
    DECLARE_DYNCREATE(CMapWildcardsPge)

// Construction
public:
    CMapWildcardsPge();
    ~CMapWildcardsPge();

    BOOL    FInit(IMSAdminBase* pMB);

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    // base path for to the metabase
    CString m_szMBPath;


// Dialog Data
    //{{AFX_DATA(CMapWildcardsPge)
    enum { IDD = IDD_WILDCARDS_1 };
    CCheckListCtrl  m_clistctrl_list;
    CButton m_cbutton_up;
    CButton m_cbutton_down;
    CButton m_cbutton_add;
    CButton m_cbutton_delete;
    CButton m_cbutton_editrule;
    BOOL    m_bool_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMapWildcardsPge)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMapWildcardsPge)
    afx_msg void OnMoveDown();
    afx_msg void OnMoveUp();
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnEdit();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnEnable();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();


    // more initialization methods
    BOOL FInitRulesList();
    BOOL FillRulesList();

    // editing and updating
    void EnableDependantButtons();

    int AddRuleToList( CCertMapRule* pRule, DWORD iRule, int iInsert = 0xffffffff );
    void UpdateRuleInDispList( DWORD iList, CCertMapRule* pRule );

    BOOL EditOneRule( CCertMapRule* pRule, BOOL fAsWizard = FALSE );
    BOOL EditMultipleRules();

    void OnMove( int delta );


    // its storage/persistance object
//  CMBWrap             m_mbWrap;

    // its mapper
    CIisRuleMapper      m_mapper;

    CString             m_szMetaPath;
    IMSAdminBase*       m_pMB;

    // flag indicating if changes have been made
    BOOL                m_fDirty;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wrapmaps.h ===
// wrapmaps.h  -- 

 
#ifndef   _wrapmaps_h__31598_
#define   _wrapmaps_h__31598_

// see iismap.hxx for the parental classes


//--------------------------------------------------------
class C11Mapping
    {
    public:
    #define NEW_OBJECT  0xFFFFFFFF
    C11Mapping() : 
          m_fEnabled(TRUE),
          m_pCert(NULL),
          m_cbCert(0),
          iMD(NEW_OBJECT)
        {;}
    ~C11Mapping()
        {
        if ( m_pCert )
            GlobalFree( m_pCert );
        }

    BOOL GetCertificate( PUCHAR* ppCert, DWORD* pcbCert );
    BOOL SetCertificate( PUCHAR pCert, DWORD cbCert );

    BOOL GetNTAccount( CString &szAccount );
    BOOL SetNTAccount( CString szAccount );

    BOOL GetNTPassword( CString &szAccount );
    BOOL SetNTPassword( CString szAccount );

    BOOL GetMapName( CString &szName );
    BOOL SetMapName( CString szName );

    BOOL GetMapEnabled( BOOL* pfEnabled );
    BOOL SetMapEnabled( BOOL fEnabled );

//  BOOL GetMapIndex( DWORD* pIndex );
//  BOOL SetMapIndex( DWORD index );

    // name of this mapping's name in the metabase. If it is not in the metabase
    // (its new), then value is NEW_OBJECT
    DWORD       iMD;

    protected:
    #define BUFF_SIZE   MAX_PATH
        CString m_szAccount;
        CString m_szPassword;
        CString m_szName;
        BOOL    m_fEnabled;
        PVOID   m_pCert;
        DWORD   m_cbCert;
    };

#endif  /* _wrapmaps_h__31598_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wrpmbwrp.cpp ===
/*++

Module Name:

    WrpMBWrp.cpp

Abstract:

    A wrapper for my metabase wrapper wrapper. Why? All it does is provide
        AFX support for CString classes. Everything else is passed on to the parent

Author:

   Boyd Multerer bmulterer@accessone.com

--*/

//C:\nt\public\sdk\lib\i386

#include "stdafx.h"
#include <iiscnfgp.h>
#include "wrapmb.h"

#include "WrpMBWrp.h"


//-----------------------------------------------------------------------------
BOOL CAFX_MetaWrapper::GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                                                                 CString &sz, DWORD dwFlags )
        {
        PCHAR           pData = NULL;
        DWORD           cbData = 0;
        DWORD           err = 0;
        BOOL            f;

        // first, get the size of the data that we are looking for - it will fail because of the NULL,
        // but, the size we need should be in cbData;
        f = GetData( pszPath, dwPropID, dwUserType, STRING_METADATA, NULL, &cbData );

        // check the error - it should be some sort of memory error
        err = GetLastError();

        // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
        // otherwise, it is something we can't handle
        if ( err != ERROR_INSUFFICIENT_BUFFER )
                return FALSE;

        // allocate the buffer
        pData = (PCHAR)GlobalAlloc( GPTR, cbData + 1 );
        if ( !pData ) return FALSE;

        // zero out the buffer
        ZeroMemory( pData, cbData + 1 );

        // first, get the size of the data that we are looking for
        f = GetData( pszPath, dwPropID, dwUserType, STRING_METADATA, pData, &cbData );

        // if that getting failed, we need to cleanup
        if ( !f )
                {
                GlobalFree( pData );
                return FALSE;
                }

        // set the answer
        sz = pData;

        // clean up
        GlobalFree( pData );

        // return the allocated buffer
        return TRUE;
        }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wrpmbwrp.h ===
//-------------------------------
class CAFX_MetaWrapper : public CWrapMetaBase
    {
    public:
    BOOL GetString( LPCTSTR, DWORD dwPropID, DWORD dwUserType, CString &sz, DWORD dwFlags = METADATA_INHERIT );
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wwzone.cpp ===
// WildWizOne.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"

#include "WWzOne.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CWildWizOne property page

IMPLEMENT_DYNCREATE(CWildWizOne, CPropertyPage)

CWildWizOne::CWildWizOne() : CPropertyPage(CWildWizOne::IDD)
{
    //{{AFX_DATA_INIT(CWildWizOne)
    m_sz_description = _T("");
    m_bool_enable = FALSE;
    //}}AFX_DATA_INIT
}

CWildWizOne::~CWildWizOne()
{
}

void CWildWizOne::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWildWizOne)
    DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
    DDV_MaxChars(pDX, m_sz_description, 120);
    DDX_Check(pDX, IDC_ENABLE_RULE, m_bool_enable);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWildWizOne, CPropertyPage)
    //{{AFX_MSG_MAP(CWildWizOne)
    ON_EN_CHANGE(IDC_DESCRIPTION, OnChangeDescription)
    ON_BN_CLICKED(IDC_ENABLE_RULE, OnEnableRule)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CWildWizOne::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_ADV_RUL_GENERAL );
    }

/////////////////////////////////////////////////////////////////////////////
// CWildWizOne message handlers

//---------------------------------------------------------------------------
BOOL CWildWizOne::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // set the easy default strings 
    m_sz_description = m_pRule->GetRuleName();
    m_bool_enable = m_pRule->GetRuleEnabled();

    // exchange the data
    UpdateData( FALSE );

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL CWildWizOne::OnApply()
    {
    CERT_FIELD_ID   id;
    CString         szSub, sz;
    LPBYTE          pbBin;
    DWORD           cbBin;
    UINT            cItems;
    UINT            iItem;

    USES_CONVERSION;

    // update the data
    UpdateData( TRUE );

    // set the easy data

    m_pRule->SetRuleName( T2A((LPTSTR)(LPCTSTR)m_sz_description) );
    m_pRule->SetRuleEnabled( m_bool_enable );

    // it is valid
    SetModified( FALSE );
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizOne::OnSetActive() 
    {
    // if this is a wizard, gray out the back button
    if ( m_fIsWizard )
        m_pPropSheet->SetWizardButtons( PSWIZB_NEXT );
    return CPropertyPage::OnSetActive();
    }

//---------------------------------------------------------------------------
void CWildWizOne::OnChangeDescription() 
    {
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizOne::OnEnableRule() 
    {
    // we can now apply
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\mapwpge.cpp ===
// MapWPge.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }

#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "ListRow.h"
#include "ChkLstCt.h"

#include "MapWPge.h"
#include "Ed11Maps.h"
#include "EdWldRul.h"

#include <iiscnfgp.h>
#include "wrapmb.h"

#include "WWzOne.h"
#include "WWzTwo.h"
#include "WWzThree.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define COL_NUM_ENABLED                 0
#define COL_NUM_DESCRIPTION             1
#define COL_NUM_NTACCOUNT               2


#define MB_EXTEND_KEY   "CertW"

/////////////////////////////////////////////////////////////////////////////
// CMapWildcardsPge property page

IMPLEMENT_DYNCREATE(CMapWildcardsPge, CPropertyPage)

//---------------------------------------------------------------------------
CMapWildcardsPge::CMapWildcardsPge() : CPropertyPage(CMapWildcardsPge::IDD),
    m_fDirty(FALSE)
    {
    //{{AFX_DATA_INIT(CMapWildcardsPge)
    m_bool_enable = FALSE;
    //}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
CMapWildcardsPge::~CMapWildcardsPge()
    {
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMapWildcardsPge)
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_MOVE_UP, m_cbutton_up);
    DDX_Control(pDX, IDC_MOVE_DOWN, m_cbutton_down);
    DDX_Control(pDX, IDC_ADD, m_cbutton_add);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    DDX_Control(pDX, IDC_EDIT, m_cbutton_editrule);
    DDX_Check(pDX, IDC_ENABLE, m_bool_enable);
    //}}AFX_DATA_MAP
    }


//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CMapWildcardsPge, CPropertyPage)
    //{{AFX_MSG_MAP(CMapWildcardsPge)
    ON_BN_CLICKED(IDC_MOVE_DOWN, OnMoveDown)
    ON_BN_CLICKED(IDC_MOVE_UP, OnMoveUp)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_BN_CLICKED(IDC_ENABLE, OnEnable)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CMapWildcardsPge::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_MAIN_ADVANCED );
    }

/////////////////////////////////////////////////////////////////////////////
// initialization routines

//---------------------------------------------------------------------------
// FInitMapper is called by the routine instantiating this page. After the object
// is first created is when it is called. It allows us to fail gracefully.
BOOL CMapWildcardsPge::FInit(IMSAdminBase* pMB)
    {
    BOOL            fAnswer = FALSE;
    PVOID           pData = NULL;
    DWORD           cbData = 0;
    BOOL            f;

    m_pMB = pMB;

    // before messing with the metabase, prepare the strings we will need
    CString         szBasePath = m_szMBPath;
    CString         szRelativePath = MB_EXTEND_KEY;
    CString         szObjectPath = m_szMBPath + _T('/') + szRelativePath;

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);
    if ( !f ) return FALSE;

    // attempt to open the object we want to store into
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_READ );

    // if that worked, load the data
    if ( f )
        {
        // first, get the size of the data that we are looking for
        pData = mbWrap.GetData( _T(""), MD_SERIAL_CERTW, IIS_MD_UT_SERVER, BINARY_METADATA, &cbData );

        // if we successfully got the data, unserialize it
        // WARNING: m_mapper.Unserialize changes the value of the pointer that is passed in. Pass
        // in a copy of the pointer
        PUCHAR  pDataCopy = (PUCHAR)pData;
        if ( pData )
            fAnswer = m_mapper.Unserialize( (PUCHAR*)&pDataCopy, &cbData );

        // close the object
        f = mbWrap.Close();

        // cleanup
        if ( pData )
            mbWrap.FreeWrapData( pData );
        }

    // return the answer
    return fAnswer;
    }

//---------------------------------------------------------------------------
BOOL CMapWildcardsPge::OnInitDialog()
    {
    //call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // if the initinalization (sp?) succeeded, init the list and other items
    if ( f )
        {
        // init the contents of the list
        FInitRulesList();

        // Fill the mapping list with the stored items
        FillRulesList();

        // set the initial button states
        EnableDependantButtons();
        }

    // set the initial state of the enable button
    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();
    m_bool_enable = pGlob->GetRulesEnabled();

    // set any changes in the info into place
    UpdateData(FALSE);

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL CMapWildcardsPge::FInitRulesList()
    {
    CString sz;
    int             i;

    // setup the friendly name column
    sz.Empty();
    i = m_clistctrl_list.InsertColumn( COL_NUM_ENABLED, sz, LVCFMT_LEFT, 20 );

    // setup the description column
    sz.LoadString( IDS_WILD_DESCRIPTION );
    i = m_clistctrl_list.InsertColumn( COL_NUM_DESCRIPTION, sz, LVCFMT_LEFT, 238 );

    // setup the account column
    sz.LoadString( IDS_WILD_ACCOUNT );
    i = m_clistctrl_list.InsertColumn( COL_NUM_NTACCOUNT, sz, LVCFMT_LEFT, 220 );

    return TRUE;
    }

//---------------------------------------------------------------------------
// fill in the rules. Get the order for the rules from the globals object. That
// way there is no need to sort them later
BOOL CMapWildcardsPge::FillRulesList()
    {
    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();

    // get the number of rules (actually its a number of rule order - but they are the same thing)
    DWORD   cbRules = m_mapper.GetRuleCount();

    // get the pointer to the order array
    DWORD*  pOrder = pGlob->GetRuleOrderArray();

    // for each item in the mapper object, add it to the list control
    for ( DWORD j = 0; j < cbRules; j++ )
        {
        CCertMapRule*   pRule;
        DWORD                   iRule = pOrder[j];

        // get the mapping
        pRule = m_mapper.GetRule( iRule );

        // if that worked, add it to the list
        if ( pRule )
            {
            // add it to the list
            AddRuleToList( pRule, iRule, 0xffffffff );
            }
        }

    // it worked - so ok.
    return TRUE;
    }

//---------------------------------------------------------------------------
int CMapWildcardsPge::AddRuleToList( CCertMapRule* pRule, DWORD iRule, int iInsert )
    {
    CString sz;
    int             i;

    if ( !pRule )
        return -1;

    // if the item to be inserted is to be the last, set it up
    if ( iInsert == 0xffffffff )
        iInsert = m_clistctrl_list.GetItemCount();

    // get the appropriate "enabled" string
    BOOL fEnabled = pRule->GetRuleEnabled();
    if ( fEnabled )
        sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // add the friendly name of the mapping
    // create the new entry in the list box. Do not sort on this entry - yet
    i = m_clistctrl_list.InsertItem( iInsert, sz );

    // add the friendly name of the rule
    sz = pRule->GetRuleName();
    // create the new entry in the list box. Do not sort on this entry - yet
    m_clistctrl_list.SetItemText( i, COL_NUM_DESCRIPTION, sz );

    // add the account name of the mapping
    if ( pRule->GetRuleDenyAccess() )
        sz.LoadString( IDS_DENYACCESS );
    else
        sz = pRule->GetRuleAccount();
    m_clistctrl_list.SetItemText( i, COL_NUM_NTACCOUNT, sz );

    // attach the mapper index to the item in the list - it may have a different
    // list index after the list has been sorted.
    m_clistctrl_list.SetItemData( i, iRule );

    // return whether or not the insertion succeeded
    return i;
    }

//---------------------------------------------------------------------------
// Note: supposedly, the order of the items in the list and the odrder
// of the items in the globals object should be the same
void CMapWildcardsPge::UpdateRuleInDispList( DWORD iList, CCertMapRule* pRule )
    {
    CString sz;

    // get the appropriate "enabled" string
    BOOL fEnabled = pRule->GetRuleEnabled();
    if ( fEnabled )
        sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // update the "Enabled" indicator
    m_clistctrl_list.SetItemText( iList, COL_NUM_ENABLED, sz );

    // update the mapping name
    sz = pRule->GetRuleName();
    m_clistctrl_list.SetItemText( iList, COL_NUM_DESCRIPTION, sz );

    // update the account name
    if ( pRule->GetRuleDenyAccess() )
        sz.LoadString( IDS_DENYACCESS );
    else
        sz = pRule->GetRuleAccount();
    m_clistctrl_list.SetItemText( iList, COL_NUM_NTACCOUNT, sz );
    }


//---------------------------------------------------------------------------
// editing a wildcard rule is rather complex, thus I am seperating that code
// out into that for the dialog itself. All we do is pass in the rule pointer
// and let it go at that.
BOOL CMapWildcardsPge::EditOneRule( CCertMapRule* pRule, BOOL fAsWizard )
    {
    // edit the item using a tabbed dialog / wizard
    CPropertySheet  propSheet;
    CWildWizOne     wwOne;
    CWildWizTwo     wwTwo;
    CWildWizThree   wwThree;

    // set the params
    wwOne.m_pMB = m_pMB;

    // fill in the data for the pages
    wwOne.m_pRule = pRule;
    wwOne.m_szMBPath = m_szMBPath;
    wwOne.m_fIsWizard = fAsWizard;
    wwOne.m_pPropSheet = &propSheet;

    wwTwo.m_pRule = pRule;
    wwTwo.m_szMBPath = m_szMBPath;
    wwTwo.m_fIsWizard = fAsWizard;
    wwTwo.m_pPropSheet = &propSheet;

    wwThree.m_pRule = pRule;
    wwThree.m_szMBPath = m_szMBPath;
    wwThree.m_fIsWizard = fAsWizard;
    wwThree.m_pPropSheet = &propSheet;

    // add the pages
    propSheet.AddPage( &wwOne );
    propSheet.AddPage( &wwTwo );
    propSheet.AddPage( &wwThree );

    // turn it into a wizard if necessary
    if ( fAsWizard )
        propSheet.SetWizardMode();

    // set the title of the wizard/tabbed dialog thing
    CString   szTitle;

    szTitle.LoadString( IDS_WILDWIZ_TITLE );

    propSheet.SetTitle( szTitle );

    // turn on help
    propSheet.m_psh.dwFlags |= PSH_HASHELP;
    wwOne.m_psp.dwFlags |= PSP_HASHELP;
    wwTwo.m_psp.dwFlags |= PSP_HASHELP;
    wwThree.m_psp.dwFlags |= PSP_HASHELP;

    // run the wizard and return if it ended with IDOK
    INT_PTR id = propSheet.DoModal();
    return ( (id == IDOK) || (id == ID_WIZFINISH) );

 /*
   CEditWildcardRule       ruleDlg;

    // prepare
    ruleDlg.m_pRule = pRule;
    ruleDlg.m_szMBPath = m_szMBPath;

    // run the dialog and return if it ended with IDOK
    return (ruleDlg.DoModal() == IDOK);
*/
    }

//---------------------------------------------------------------------------
// Yeah! the CEdit11Mappings works equally well for multiple rules! - just
// some modifications in this routine!
BOOL CMapWildcardsPge::EditMultipleRules()
    {
    CEdit11Mappings mapdlg;
    CCertMapRule*   pRule;
    BOOL                    fSetInitialState = FALSE;
    BOOL                    fEnable;


    // scan the list of seleted items for the proper initial enable button state
    // loop through the selected items, setting each one's mapping
    int     iList = -1;
    while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
        {
        // get the mapper index for the item
        // IA64 - this is OK to cast to DWORD as it is just an index
        DWORD iMapper = (DWORD)m_clistctrl_list.GetItemData( iList );

        // get the mapping item for updating purposes
        pRule = m_mapper.GetRule( iMapper );
        if ( !pRule )
            {
            AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
            break;
            }

        // get the enable state of the mapping
        fEnable = pRule->GetRuleEnabled();

        // if this is the first time, just set the initial state
        if ( !fSetInitialState )
            {
            mapdlg.m_int_enable = fEnable;
            fSetInitialState = TRUE;
            }
        else
            {
            // if it is different, then go indeterminate and break
            if ( fEnable != mapdlg.m_int_enable )
                {
                mapdlg.m_int_enable = 2;
                break;
                }
            }
        }

    //
    // ANSI/UNICODE conversion - RonaldM
    //
    USES_CONVERSION;

    // run the mapping dialog
    if ( mapdlg.DoModal() == IDOK )
        {
        // loop through the selected items, setting each one's mapping
        int     iList = -1;
        while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
            {
            // get the mapper index for the item
            // IA64 - this is OK to cast to DWORD as it is just an index
            DWORD iMapper = (DWORD)m_clistctrl_list.GetItemData( iList );

            // get the mapping item for updating purposes
            pRule = m_mapper.GetRule( iMapper );
            if ( !pRule )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                break;
                }

            // set the enable flag if requested
            switch ( mapdlg.m_int_enable )
   