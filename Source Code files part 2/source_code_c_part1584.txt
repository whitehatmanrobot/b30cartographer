_SESSION *) pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL         pRequestKernel  = (PTDI_REQUEST_KERNEL) &pIrpSp->Parameters;
    ULONG                       Length, MCastTtl;

    //
    // Verify Minimum Buffer length!
    //
    if (!GetIpAddress (pRequestKernel->RequestConnectionInformation->RemoteAddress,
                       pRequestKernel->RequestConnectionInformation->RemoteAddressLength,
                       &IpAddress,
                       &Port))
    {
        PgmLog (PGM_LOG_ERROR, DBG_CONNECT, "PgmConnect",
            "pSend=<%x>, Invalid Dest address!\n", pSend);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);
    //
    // Now, verify that the Connection handle is valid + associated!
    //
    if ((!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND)) ||
        (!(pAddress = pSend->pAssociatedAddress)) ||
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)) ||
        (pAddress->Flags & PGM_ADDRESS_FLAG_INVALID_OUT_IF))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        PgmLog (PGM_LOG_ERROR, DBG_CONNECT, "PgmConnect",
            "BAD Handle(s), pSend=<%x>, pAddress=<%x>\n", pSend, pAddress);

        return (STATUS_INVALID_HANDLE);
    }

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT, FALSE);

    //
    // If an outgoing interface has not yet been specified by the
    // client, select one ourselves
    //
    if (!pAddress->SenderMCastOutIf)
    {
        status = STATUS_ADDRESS_NOT_ASSOCIATED;
        OutIfAddress = 0;

        pEntry = &PgmDynamicConfig.LocalInterfacesList;
        while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
        {
            pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
            pEntry2 = &pLocalInterface->Addresses;
            while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
            {
                pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);
                OutIfAddress = htonl (pLocalAddress->IpAddress);

                PgmUnlock (&PgmDynamicConfig, OldIrq);
                status = SetSenderMCastOutIf (pAddress, OutIfAddress);
                PgmLock (&PgmDynamicConfig, OldIrq);

                break;
            }

            if (OutIfAddress)
            {
                break;
            }
        }

        if (!NT_SUCCESS (status))
        {
            PgmUnlock (&PgmDynamicConfig, OldIrq);
            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT);

            PgmLog (PGM_LOG_ERROR, DBG_CONNECT, "PgmConnect",
                "Could not bind sender to <%x>!\n", OutIfAddress);

            return (STATUS_UNSUCCESSFUL);
        }
    }

    //
    // So, we found a valid address to send to
    //
    pSend->pSender->DestMCastIpAddress = ntohl (IpAddress);
    pSend->pSender->DestMCastPort = pAddress->SenderMCastPort = ntohs (Port);
    pSend->pSender->SenderMCastOutIf = pAddress->SenderMCastOutIf;

    //
    // Set the FEC Info (if applicable)
    //
    pSend->FECBlockSize = pAddress->FECBlockSize;
    pSend->FECGroupSize = pAddress->FECGroupSize;

    if (pAddress->FECOptions)
    {
        Length = sizeof(tBUILD_PARITY_CONTEXT) + pSend->FECGroupSize*sizeof(PUCHAR);
        if (!(pSend->pSender->pProActiveParityContext = (tBUILD_PARITY_CONTEXT *) PgmAllocMem (Length,PGM_TAG('0'))) ||
            (!NT_SUCCESS (status = CreateFECContext (&pSend->FECContext, pSend->FECGroupSize, pSend->FECBlockSize, FALSE))))
        {
            PgmUnlock (&PgmDynamicConfig, OldIrq);
            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT);

            PgmLog (PGM_LOG_ERROR, DBG_CONNECT, "PgmConnect",
                "CreateFECContext returned <%x>, pSend=<%x>, Dest IpAddress=<%x>, Port=<%x>\n",
                    status, pSend, IpAddress, Port);

            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        pSend->FECOptions = pAddress->FECOptions;
        pSend->FECProActivePackets = pAddress->FECProActivePackets;
        pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_PARITY_PRM;
        pSend->pSender->LastVariableTGPacketSequenceNumber = -1;

        ASSERT (!(pSend->FECProActivePackets || pSend->FECProActivePackets) ||
                 ((pSend->FECGroupSize && pSend->FECBlockSize) &&
                  (pSend->FECGroupSize < pSend->FECBlockSize)));

        //
        // Now determine the MaxPayloadsize and buffer size
        // We will also need to adjust the buffer size to avoid alignment issues
        //
        Length = sizeof (tPACKET_OPTIONS) + pAddress->OutIfMTU + sizeof (tPOST_PACKET_FEC_CONTEXT);
        pSend->pSender->PacketBufferSize = (Length + sizeof (PVOID) - 1) & ~(sizeof (PVOID) - 1);
        pSend->pSender->MaxPayloadSize = pAddress->OutIfMTU - (PGM_MAX_FEC_DATA_HEADER_LENGTH + sizeof (USHORT));
    }
    else
    {
        Length = sizeof (tPACKET_OPTIONS) + pAddress->OutIfMTU;
        pSend->pSender->PacketBufferSize = (Length + sizeof (PVOID) - 1) & ~(sizeof (PVOID) - 1);
        pSend->pSender->MaxPayloadSize = pAddress->OutIfMTU - PGM_MAX_DATA_HEADER_LENGTH;
    }
    ASSERT (pSend->pSender->MaxPayloadSize);

    pSend->TSIPort = PgmDynamicConfig.SourcePort++;    // Set the Global Src Port + Global Src Id
    if (pSend->TSIPort == PgmDynamicConfig.SourcePort)
    {
        //
        // We don't want the local port and remote port to be the same
        // (especially for handling TSI settings on loopback case),
        // so pick a different port
        //
        pSend->TSIPort = PgmDynamicConfig.SourcePort++;
    }

    //
    // Now, initialize the Sender info
    //
    InitializeListHead (&pSend->pSender->PendingSends);
    InitializeListHead (&pSend->pSender->PendingPacketizedSends);
    InitializeListHead (&pSend->pSender->CompletedSendsInWindow);
    InitializeListHead (&pSend->pSender->PendingRDataRequests);
    InitializeListHead (&pSend->pSender->HandledRDataRequests);

    MCastTtl = pAddress->MCastPacketTtl;
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    KeInitializeEvent (&pSend->pSender->SendEvent, SynchronizationEvent, FALSE);

    //
    // Now, set the MCast TTL
    //
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_MCASTTTL,
                            &MCastTtl,
                            sizeof (ULONG));
    if (NT_SUCCESS (status))
    {
        //
        // Set the MCast TTL for the RouterAlert handle also
        //
        status = PgmSetTcpInfo (pAddress->RAlertFileHandle,
                                AO_OPTION_MCASTTTL,
                                &MCastTtl,
                                sizeof (ULONG));
    }

    if (NT_SUCCESS (status))
    {
        status = PgmCreateDataFileAndMapSection (pSend);
        if (!NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_CONNECT, "PgmConnect",
                "PgmCreateDataFileAndMapSection returned <%x>, pSend=<%x>, Dest IpAddress=<%x>, Port=<%x>\n",
                    status, pSend, IpAddress, Port);
        }
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmConnect",
            "AO_OPTION_MCASTTTL returned <%x>\n", status);
    }

    if (!NT_SUCCESS (status))
    {
        pSend->pSender->MaxPayloadSize = 0;
        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT);

        return (status);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    //
    // Set the appropriate data parameters for the timeout routine
    // If the Send rate is quite high, we may need to send more than
    // 1 packet per timeout, but typically it should be low enough to
    // require several timeouts
    // Rate of Kb/Sec == Rate of Bytes/MilliSecs
    //
    ASSERT (pAddress->RateKbitsPerSec &&
            (BASIC_TIMER_GRANULARITY_IN_MSECS > BITS_PER_BYTE));
    if (((pAddress->RateKbitsPerSec * BASIC_TIMER_GRANULARITY_IN_MSECS) / BITS_PER_BYTE) >=
        pSend->pSender->PacketBufferSize)
    {
        //
        // We have a high Send rate, so we need to increment our window every timeout
        // So, Bytes to be sent in (x) Millisecs = Rate of Bytes/Millisecs * (x)
        //
        pSend->pSender->SendTimeoutCount = 1;
    }
    else
    {
        //
        // We will set our Send timeout count based for a slow timer
        // -- enough for pAddress->OutIfMTU
        // So, Number of Timeouts of x millisecs before we can send pAddress->OutIfMTU:
        //  = Rate of Bytes/Millisecs * (x)
        //
        pSend->pSender->SendTimeoutCount = (pAddress->OutIfMTU +(pAddress->RateKbitsPerSec/BITS_PER_BYTE-1)) /
                                            ((pAddress->RateKbitsPerSec * BASIC_TIMER_GRANULARITY_IN_MSECS)/BITS_PER_BYTE);
        if (!pSend->pSender->SendTimeoutCount)
        {
            ASSERT (0);
            pSend->pSender->SendTimeoutCount = 1;
        }
    }
    pSend->pSender->IncrementBytesOnSendTimeout = (ULONG) (pAddress->RateKbitsPerSec *
                                                           pSend->pSender->SendTimeoutCount *
                                                           BASIC_TIMER_GRANULARITY_IN_MSECS) /
                                                           BITS_PER_BYTE;

    //
    // Now, set the values for the next timeout!
    //
    pSend->pSender->CurrentTimeoutCount = pSend->pSender->SendTimeoutCount;
    pSend->pSender->CurrentBytesSendable = pSend->pSender->IncrementBytesOnSendTimeout;

    //
    // Set the SPM timeouts
    //
    pSend->pSender->CurrentSPMTimeout = 0;
    pSend->pSender->AmbientSPMTimeout = AMBIENT_SPM_TIMEOUT_IN_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->InitialHeartbeatSPMTimeout = INITIAL_HEARTBEAT_SPM_TIMEOUT_IN_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->MaxHeartbeatSPMTimeout = MAX_HEARTBEAT_SPM_TIMEOUT_IN_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->HeartbeatSPMTimeout = pSend->pSender->InitialHeartbeatSPMTimeout;

    //
    // Set the Increment window settings
    //
    // TimerTickCount, LastWindowAdvanceTime and LastTrailingEdgeTime should be 0
    WindowAdvanceInMSecs = (((ULONGLONG)pAddress->WindowSizeInMSecs) * pAddress->WindowAdvancePercentage)/100;
    pSend->pSender->WindowSizeTime = pAddress->WindowSizeInMSecs / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->WindowAdvanceDeltaTime = WindowAdvanceInMSecs / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->NextWindowAdvanceTime = pSend->pSender->WindowSizeTime + pSend->pSender->WindowAdvanceDeltaTime;

    // Set the RData linger time!
    pSend->pSender->RDataLingerTime = RDATA_LINGER_TIME_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS;

    //
    // Set the late Joiner settings
    //
    if (pAddress->LateJoinerPercentage)
    {
        pSend->pSender->LateJoinSequenceNumbers = (SEQ_TYPE) ((pSend->pSender->MaxPacketsInBuffer *
                                                               pAddress->LateJoinerPercentage) /
                                                              (2 * 100));

        pSend->pSender->DataOptions |= PGM_OPTION_FLAG_JOIN;
        pSend->pSender->DataOptionsLength += PGM_PACKET_OPT_JOIN_LENGTH;

        pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_JOIN;
    }

    // The timer will be started when the first send comes down
    pSend->SessionFlags |= (PGM_SESSION_FLAG_FIRST_PACKET | PGM_SESSION_FLAG_SENDER);

#if 0
    pSend->pSender->LeadingWindowOffset = pSend->pSender->TrailingWindowOffset =
                (pSend->pSender->MaxDataFileSize/(pSend->pSender->PacketBufferSize*2))*pSend->pSender->PacketBufferSize;
#endif
    pSend->pSender->LeadingWindowOffset = pSend->pSender->TrailingWindowOffset = 0;

    PgmUnlock (&PgmDynamicConfig, OldIrq);
    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT);

    ExInitializeNPagedLookasideList (&pSend->pSender->SenderBufferLookaside,
                                     NULL,
                                     NULL,
                                     0,
                                     pAddress->OutIfMTU + sizeof (tPOST_PACKET_FEC_CONTEXT),
                                     PGM_TAG('2'),
                                     SENDER_BUFFER_LOOKASIDE_DEPTH);

    ExInitializeNPagedLookasideList (&pSend->pSender->SendContextLookaside,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof (tCLIENT_SEND_REQUEST),
                                     PGM_TAG('2'),
                                     SEND_CONTEXT_LOOKASIDE_DEPTH);

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_CONNECT, "PgmConnect",
        "DestIP=<%x>, Rate=<%d>, WinBytes=<%d>, WinMS=<%d>, SendTC=<%d>, IncBytes=<%d>, CurrentBS=<%d>\n",
            (ULONG) IpAddress, (ULONG) pAddress->RateKbitsPerSec,
            (ULONG) pAddress->WindowSizeInBytes, (ULONG) pAddress->WindowSizeInMSecs,
            (ULONG) pSend->pSender->SendTimeoutCount, (ULONG) pSend->pSender->IncrementBytesOnSendTimeout,
            (ULONG) pSend->pSender->CurrentBytesSendable);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

VOID
PgmCancelDisconnectIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Disconnect Irp. It must
    release the cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    None

--*/
{
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation (pIrp);
    tCOMMON_SESSION_CONTEXT *pSession = (tCOMMON_SESSION_CONTEXT *) pIrpSp->FileObject->FsContext;
    PGMLockHandle           OldIrq;
    PIRP                    pIrpToComplete;

    if (!PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE))
    {
        IoReleaseCancelSpinLock (pIrp->CancelIrql);

        PgmLog (PGM_LOG_ERROR, (DBG_SEND | DBG_ADDRESS | DBG_CONNECT), "PgmCancelDisconnectIrp",
            "pIrp=<%x> pSession=<%x>, pAddress=<%x>\n", pIrp, pSession, pSession->pAssociatedAddress);
        return;
    }

    PgmLock (pSession, OldIrq);

    ASSERT (pIrp == pSession->pIrpDisconnect);
    if ((pIrpToComplete = pSession->pIrpDisconnect) &&
        (pIrpToComplete == pIrp))
    {
        pSession->pIrpDisconnect = NULL;
    }
    else
    {
        pIrpToComplete = NULL;
    }

    if (pSession->pSender)
    {
        pSession->pSender->DisconnectTimeInTicks = pSession->pSender->TimerTickCount;
    }

    //
    // If we have reached here, then the Irp must already
    // be in the process of being completed!
    //
    PgmUnlock (pSession, OldIrq);
    IoReleaseCancelSpinLock (pIrp->CancelIrql);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, (DBG_SEND | DBG_ADDRESS | DBG_CONNECT), "PgmCancelDisconnectIrp",
        "pIrp=<%x> was CANCELled, pIrpTpComplete=<%x>\n", pIrp, pIrpToComplete);

    if (pIrpToComplete)
    {
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmDisconnect(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client to disconnect a currently-active
    session

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the disconnect operation

--*/
{
    LIST_ENTRY                      PendingIrpsList;
    PGMLockHandle                   OldIrq1, OldIrq2, OldIrq3;
    PIRP                            pIrpReceive;
    NTSTATUS                        Status;
    LARGE_INTEGER                   TimeoutInMSecs;
    LARGE_INTEGER                   *pTimeoutInMSecs;
    tADDRESS_CONTEXT                *pAddress = NULL;
    tCOMMON_SESSION_CONTEXT         *pSession = (tCOMMON_SESSION_CONTEXT *) pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL_DISCONNECT  pDisconnectRequest = (PTDI_REQUEST_KERNEL_CONNECT) &(pIrpSp->Parameters);

    PgmLock (&PgmDynamicConfig, OldIrq1);
    //
    // Now, verify that the Connection handle is valid + associated!
    //
    if ((!PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE)) ||
        (!(pAddress = pSession->pAssociatedAddress)) ||
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)))
    {
        PgmLog (PGM_LOG_ERROR, DBG_CONNECT, "PgmDisconnect",
            "BAD Handle(s), pSession=<%x>, pAddress=<%x>\n", pSession, pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq1);
        return (STATUS_INVALID_HANDLE);
    }

    Status = STATUS_SUCCESS;
    InitializeListHead (&PendingIrpsList);
    TimeoutInMSecs.QuadPart = 0;

    IoAcquireCancelSpinLock (&OldIrq2);
    PgmLock (pSession, OldIrq3);

    if (pSession->pReceiver)
    {
        //
        // If we have any receive Irps pending, cancel them
        //
        RemovePendingIrps (pSession, &PendingIrpsList);
    }
    else if (pSession->pSender)
    {
        //
        // See if there is an abortive or graceful disconnect, and
        // also if there is a timeout specified.
        //
        if ((pDisconnectRequest->RequestFlags & TDI_DISCONNECT_ABORT) ||
            (pSession->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET))       // No packets sent yet!
        {
            pSession->pSender->DisconnectTimeInTicks = pSession->pSender->TimerTickCount;
        }
        else if (NT_SUCCESS (PgmCheckSetCancelRoutine (pIrp, PgmCancelDisconnectIrp, TRUE)))
        {
            if ((pTimeoutInMSecs = pDisconnectRequest->RequestSpecific) &&
                ((pTimeoutInMSecs->LowPart != -1) || (pTimeoutInMSecs->HighPart != -1)))   // Check Infinite
            {
                //
                // NT relative timeouts are negative. Negate first to get a
                // positive value to pass to the transport.
                //
                TimeoutInMSecs.QuadPart = -((*pTimeoutInMSecs).QuadPart);
                TimeoutInMSecs = PgmConvert100nsToMilliseconds (TimeoutInMSecs);

                pSession->pSender->DisconnectTimeInTicks = pSession->pSender->TimerTickCount +
                                                           TimeoutInMSecs.QuadPart /
                                                               BASIC_TIMER_GRANULARITY_IN_MSECS;
            }

            pSession->pIrpDisconnect = pIrp;
            Status = STATUS_PENDING;
        }
        else
        {
            Status = STATUS_CANCELLED;
        }
    }

    if (NT_SUCCESS (Status))
    {
        pSession->SessionFlags |= PGM_SESSION_CLIENT_DISCONNECTED;
    }

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_CONNECT, "PgmDisconnect",
        "pIrp=<%x>, pSession=<%x>, pAddress=<%x>, Timeout=<%x : %x>, %s\n",
            pIrp, pSession, pAddress, TimeoutInMSecs.QuadPart,
            (pDisconnectRequest->RequestFlags & TDI_DISCONNECT_ABORT ? "ABORTive" : "GRACEful"));

    PgmUnlock (pSession, OldIrq3);
    IoReleaseCancelSpinLock (OldIrq2);
    PgmUnlock (&PgmDynamicConfig, OldIrq1);

    while (!IsListEmpty (&PendingIrpsList))
    {
        pIrpReceive = CONTAINING_RECORD (PendingIrpsList.Flink, IRP, Tail.Overlay.ListEntry);
        RemoveEntryList (&pIrpReceive->Tail.Overlay.ListEntry);

        PgmCancelCancelRoutine (pIrpReceive);
        pIrpReceive->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest (pIrpReceive, IO_NETWORK_INCREMENT);
    }

    return (Status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetRcvBufferLength(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client by the client to set the receive buffer length
    Currently, we do not utilize this option meaningfully.

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    NTSTATUS            status;
    tRECEIVE_SESSION    *pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    PAGED_CODE();

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_CONNECT, "PgmSetRcvBufferLength",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    if (!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE))
    {
        PgmLog (PGM_LOG_ERROR, DBG_CONNECT, "PgmSetRcvBufferLength",
            "Invalid Handle <%x>\n", pReceive);
        return (STATUS_INVALID_HANDLE);
    }

    pReceive->pReceiver->RcvBufferLength = pInputBuffer->RcvBufferLength;

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_CONNECT, "PgmSetRcvBufferLength",
        "RcvBufferLength=<%d>\n", pReceive->pReceiver->RcvBufferLength);

    //
    // ISSUE:  What else should we do here ?
    //

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\inc\macroes.h ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Macroes.h

Abstract:

    This module contains definitions of commonly used macroes

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#ifndef _MACROES_H_
#define _MACROES_H_

#define     MAX_DEBUG_MESSAGE_LENGTH   300

//
// Debug Flags
//
#define DBG_ENABLE_DBGPRINT 0x00000001
#define DBG_DRIVER_ENTRY    0x00000002
#define DBG_INIT_PGM        0x00000004
#define DBG_DEBUG_REF       0x00000008
#define DBG_PNP             0x00000010
#define DBG_TDI             0x00000020
#define DBG_ADDRESS         0x00000040
#define DBG_CONNECT         0x00000080
#define DBG_QUERY           0x00000100
#define DBG_SEND            0x00000200
#define DBG_RECEIVE         0x00000400
#define DBG_FILEIO          0x00000800
#define DBG_FEC             0x00001000

//
// DbgPrint macroes
//

enum eSEVERITY_LEVEL
{
    PGM_LOG_DISABLED,           // No logging!
    PGM_LOG_CRITICAL_ERROR,     // Major errors which can seriously affect functionality
    PGM_LOG_ERROR,              // Common errors which do not affect the system as a whole
    PGM_LOG_INFORM_STATUS,      // Mostly to verify major functionality was executed
    PGM_LOG_INFORM_ALL_FUNCS,   // 1 per function to allow path tracking (not req if printing all code paths)
    PGM_LOG_INFORM_PATH,        // Interspersed throughout function to trace If paths
    PGM_LOG_INFORM_DETAIL,      // while loops, etc
    PGM_LOG_INFORM_REFERENCES,  // 
    PGM_LOG_EVERYTHING
};

#if DBG
//
// ASSERT
//
#undef ASSERT
#define ASSERT(exp)                             \
if (!(exp))                                     \
{                                               \
    DbgPrint("Assertion \"%s\" failed at file %s, line %d\n", #exp, __FILE__, __LINE__ );           \
    if (!PgmDynamicConfig.DoNotBreakOnAssert)   \
    {                                           \
        DbgBreakPoint();                        \
    }                                           \
}
#endif  // DBG


//
// Data/pointer verification
//
#define PGM_VERIFY_HANDLE(p, V)                                             \
    ((p) && (p->Verify == V))

#define PGM_VERIFY_HANDLE2(p, V1, V2)                                       \
    ((p) && ((p->Verify == V1) || (p->Verify == V2)))

#define PGM_VERIFY_HANDLE3(p, V1, V2, V3)                                   \
    ((p) && ((p->Verify == V1) || (p->Verify == V2) || (p->Verify == V3)))

//----------------------------------------------------------------------------
//
// Sequence number macroes
//

#define SEQ_LT(a,b)     ((SIGNED_SEQ_TYPE)((a)-(b)) < 0)
#define SEQ_LEQ(a,b)    ((SIGNED_SEQ_TYPE)((a)-(b)) <= 0)
#define SEQ_GT(a,b)     ((SIGNED_SEQ_TYPE)((a)-(b)) > 0)
#define SEQ_GEQ(a,b)    ((SIGNED_SEQ_TYPE)((a)-(b)) >= 0)


//----------------------------------------------------------------------------

//
// Definitions:
//
#define IS_MCAST_ADDRESS(IpAddress) ((((PUCHAR)(&IpAddress))[3]) >= ((UCHAR)0xe0))
#define CLASSD_ADDR(a)  (( (*((uchar *)&(a))) & 0xf0) == 0xe0)

//
// Alloc and Free macroes
//
#define PGM_TAG(x) (((x)<<24)|'\0mgP')
#define PgmAllocMem(_Size, _Tag)   \
    ExAllocatePoolWithTag(NonPagedPool, (_Size),(_Tag))

#define PgmFreeMem(_Ptr)            ExFreePool(_Ptr)

//
// Misc Ke + Ex macroes
//
#define PgmGetCurrentIrql   KeGetCurrentIrql
#define PgmInterlockedInsertTailList(_pHead, _pEntry, _pStruct) \
     ExInterlockedInsertTailList(_pHead, _pEntry, &(_pStruct)->LockInfo.SpinLock);

//----------------------------------------------------------------------------
//
// PgmAcquireResourceExclusive (Resource, Wait)
//
/*++
Routine Description:

    Acquires the Resource by calling an executive support routine.

Arguments:


Return Value:

    None

--*/
//
// Resource Macros
//
#define PgmAcquireResourceExclusive( _Resource, _Wait )     \
    KeEnterCriticalRegion();                                \
    ExAcquireResourceExclusiveLite(_Resource,_Wait);

//----------------------------------------------------------------------------
//
// PgmReleaseResource (Resource)
//
/*++
Routine Description:

    Releases the Resource by calling an excutive support routine.

Arguments:


Return Value:

    None

--*/
#define PgmReleaseResource( _Resource )         \
    ExReleaseResourceLite(_Resource);           \
    KeLeaveCriticalRegion();

//----------------------------------------------------------------------------
//++
//
// LARGE_INTEGER
// PgmConvert100nsToMilliseconds(
//     IN LARGE_INTEGER HnsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     HnsTime - Time in hundreds of nanoseconds.
//
// Return Value:
//
//     Time in milliseconds.
//
//--

#define SHIFT10000 13
static LARGE_INTEGER Magic10000 = {0xe219652c, 0xd1b71758};

#define PgmConvert100nsToMilliseconds(HnsTime) \
            RtlExtendedMagicDivide((HnsTime), Magic10000, SHIFT10000)

//----------------------------------------------------------------------------

//
// Lock Macroes
//
#if DBG
#define PgmInitLock(_Struct, _N)                            \
    KeInitializeSpinLock (&(_Struct)->LockInfo.SpinLock);   \
    (_Struct)->LockInfo.LockNumber = _N;
#else
#define PgmInitLock(_Struct, _N)                            \
    KeInitializeSpinLock (&(_Struct)->LockInfo.SpinLock);
#endif  // DBG

typedef KIRQL       PGMLockHandle;

#if DBG
#define PgmLock(_Struct, _OldIrqLevel)                                                      \
{                                                                                           \
    ULONG  CurrProc;                                                                        \
    ExAcquireSpinLock (&(_Struct)->LockInfo.SpinLock, &(_OldIrqLevel));                     \
    CurrProc = KeGetCurrentProcessorNumber();                                               \
    ASSERT ((_Struct)->LockInfo.LockNumber > PgmDynamicConfig.CurrentLockNumber[CurrProc]); \
    PgmDynamicConfig.CurrentLockNumber[CurrProc] |= (_Struct)->LockInfo.LockNumber;         \
    (_Struct)->LockInfo.LastLockLine = __LINE__;                                            \
}

#define PgmLockAtDpc(_Struct)                                                               \
{                                                                                           \
    ULONG  CurrProc;                                                                        \
    ExAcquireSpinLockAtDpcLevel (&(_Struct)->LockInfo.SpinLock);                            \
    CurrProc = KeGetCurrentProcessorNumber();                                               \
    ASSERT ((_Struct)->LockInfo.LockNumber > PgmDynamicConfig.CurrentLockNumber[CurrProc]); \
    PgmDynamicConfig.CurrentLockNumber[CurrProc] |= (_Struct)->LockInfo.LockNumber;         \
    (_Struct)->LockInfo.LastLockLine = __LINE__;                                            \
}

#define PgmUnlock(_Struct, _OldIrqLevel)                                                    \
{                                                                                           \
    ULONG  CurrProc = KeGetCurrentProcessorNumber();                                        \
    ASSERT (PgmDynamicConfig.CurrentLockNumber[CurrProc] & (_Struct)->LockInfo.LockNumber); \
    PgmDynamicConfig.CurrentLockNumber[CurrProc] &= ~((_Struct)->LockInfo.LockNumber);      \
    (_Struct)->LockInfo.LastUnlockLine = __LINE__;                                          \
    ExReleaseSpinLock (&(_Struct)->LockInfo.SpinLock, _OldIrqLevel);                        \
}
// ASSERT ((_Struct)->LockInfo.LockNumber > PgmDynamicConfig.CurrentLockNumber[CurrProc]);

#define PgmUnlockAtDpc(_Struct)                                                             \
{                                                                                           \
    ULONG  CurrProc = KeGetCurrentProcessorNumber();                                        \
    ASSERT (PgmDynamicConfig.CurrentLockNumber[CurrProc] & (_Struct)->LockInfo.LockNumber); \
    PgmDynamicConfig.CurrentLockNumber[CurrProc] &= ~((_Struct)->LockInfo.LockNumber);      \
    (_Struct)->LockInfo.LastUnlockLine = __LINE__;                                          \
    ExReleaseSpinLockFromDpcLevel (&(_Struct)->LockInfo.SpinLock);                          \
}
// ASSERT ((_Struct)->LockInfo.LockNumber > PgmDynamicConfig.CurrentLockNumber[CurrProc]); \

#else
#define PgmLock(_Struct, _OldIrqLevel)        \
    ExAcquireSpinLock (&(_Struct)->LockInfo.SpinLock, &(_OldIrqLevel));

#define PgmLockAtDpc(_Struct)        \
    ExAcquireSpinLockAtDpcLevel (&(_Struct)->LockInfo.SpinLock);

#define PgmUnlock(_Struct, _OldIrqLevel)        \
    ExReleaseSpinLock (&(_Struct)->LockInfo.SpinLock, _OldIrqLevel);                     \

#define PgmUnlockAtDpc(_Struct)        \
    ExReleaseSpinLockFromDpcLevel (&(_Struct)->LockInfo.SpinLock);                     \

#endif  // DBG

//
// Memory management macroes
//
#define PgmZeroMemory                   RtlZeroMemory
#define PgmMoveMemory                   RtlMoveMemory
#define PgmCopyMemory                   RtlCopyMemory
#define PgmEqualMemory(_a, _b, _n)      memcmp(_a,_b,_n)

//
// Timer Macroes
//
#define MILLISEC_TO_100NS   10000
#define PgmInitTimer(_PgmTimer)    \
    KeInitializeTimer (&((_PgmTimer)->t_timer));

#define PgmStartTimer(_PgmTimer, _DeltaTimeInMilliSecs, _TimerExpiryRoutine, _Context)  \
{                                                                                       \
    LARGE_INTEGER   Time;                                                               \
    Time.QuadPart = UInt32x32To64 (_DeltaTimeInMilliSecs, MILLISEC_TO_100NS);           \
    Time.QuadPart = -(Time.QuadPart);                                                   \
    KeInitializeDpc (&((_PgmTimer)->t_dpc), (PVOID)_TimerExpiryRoutine, _Context);      \
    KeSetTimer (&((_PgmTimer)->t_timer), Time, &((_PgmTimer))->t_dpc);                  \
}

#define PgmStopTimer(_PgmTimer)     \
    ((int) KeCancelTimer(&((_PgmTimer)->t_timer)))

//
// Referencing and dereferencing macroes
//
#define PGM_REFERENCE_DEVICE( _pPgmDevice, _RefContext, _fLocked)   \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pPgmDevice, OldIrq);                              \
    }                                                               \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_INIT_PGM), "",\
        "\t++pPgmDevice[%x]=<%x:%d->%d>, <%d:%s>\n",                \
            _RefContext, _pPgmDevice,_pPgmDevice->RefCount,(_pPgmDevice->RefCount+1),__LINE__,__FILE__);    \
    ASSERT (PGM_VERIFY_HANDLE (_pPgmDevice, PGM_VERIFY_DEVICE));    \
    ASSERT (++_pPgmDevice->ReferenceContexts[_RefContext]);         \
    ++_pPgmDevice->RefCount;                                        \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pPgmDevice, OldIrq);                            \
    }                                                               \
}

#define PGM_REFERENCE_CONTROL( _pControl, _RefContext, _fLocked)    \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pControl, OldIrq);                                \
    }                                                               \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_TDI), "",     \
        "\t++pControl[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pControl,_pControl->RefCount,(_pControl->RefCount+1),__LINE__,__FILE__);  \
    ASSERT (PGM_VERIFY_HANDLE (_pControl, PGM_VERIFY_CONTROL));     \
    ASSERT (++_pControl->ReferenceContexts[_RefContext]);           \
    ++_pControl->RefCount;                                          \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pControl, OldIrq);                              \
    }                                                               \
}

#define PGM_REFERENCE_ADDRESS( _pAddress, _RefContext, _fLocked)    \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pAddress, OldIrq);                                \
    }                                                               \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_ADDRESS), "", \
        "\t++pAddress[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pAddress,_pAddress->RefCount,(_pAddress->RefCount+1),__LINE__,__FILE__);  \
    ASSERT (PGM_VERIFY_HANDLE (_pAddress, PGM_VERIFY_ADDRESS));     \
    ASSERT (++_pAddress->ReferenceContexts[_RefContext]);           \
    ++_pAddress->RefCount;                                          \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pAddress, OldIrq);                              \
    }                                                               \
}

#define PGM_REFERENCE_SEND_DATA_CONTEXT( _pSendDC, _fLocked)        \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pSendDC->pSend, OldIrq);                          \
    }                                                               \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_SEND), "",    \
        "\t++pSendDataContext[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pSendDC,_pSendDC->RefCount,(_pSendDC->RefCount+1),__LINE__,__FILE__);  \
    ASSERT (PGM_VERIFY_HANDLE (_pSendDC, PGM_VERIFY_SEND_DATA_CONTEXT));    \
    ++_pSendDC->RefCount;                                           \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pSendDC, OldIrq);                               \
    }                                                               \
}

#define PGM_REFERENCE_SESSION( _pSession, _Verify, _RefContext, _fLocked)    \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pSession, OldIrq);                                    \
    }                                                               \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_CONNECT), "", \
        "\t++pSession[%x]=<%x:%d->%d>, <%d:%s>\n",                      \
            _RefContext, _pSession,_pSession->RefCount,(_pSession->RefCount+1),__LINE__,__FILE__);      \
    ASSERT (PGM_VERIFY_HANDLE2 (_pSession, _Verify, PGM_VERIFY_SESSION_DOWN)); \
    ASSERT (++_pSession->ReferenceContexts[_RefContext]);               \
    ++_pSession->RefCount;                                              \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pSession, OldIrq);                                  \
    }                                                               \
}

#define PGM_REFERENCE_SESSION_SEND( _pSend, _RefContext, _fLocked)  \
    PGM_REFERENCE_SESSION (_pSend, PGM_VERIFY_SESSION_SEND, _RefContext, _fLocked)

#define PGM_REFERENCE_SESSION_RECEIVE( _pRcv, _RefContext, _fLocked)\
    PGM_REFERENCE_SESSION (_pRcv, PGM_VERIFY_SESSION_RECEIVE, _RefContext, _fLocked)

#define PGM_REFERENCE_SESSION_UNASSOCIATED( _pRcv, _RefContext, _fLocked)\
    PGM_REFERENCE_SESSION (_pRcv, PGM_VERIFY_SESSION_UNASSOCIATED, _RefContext, _fLocked)


//
// Dereferencing ...
//

#define PGM_DEREFERENCE_DEVICE( _pDevice, _RefContext)              \
{                                                                   \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_INIT_PGM), "",\
        "\t--pDevice[%x]=<%x:%d->%d>, <%d:%s>\n",                   \
            _RefContext, _pDevice,_pDevice->RefCount,(_pDevice->RefCount-1),__LINE__,__FILE__);     \
    PgmDereferenceDevice (_pDevice, _RefContext);                   \
}

#define PGM_DEREFERENCE_CONTROL( _pControl, _RefContext)            \
{                                                                   \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_TDI), "",     \
        "\t--pControl[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pControl,_pControl->RefCount,(_pControl->RefCount-1),__LINE__,__FILE__);  \
    PgmDereferenceControl (_pControl, _RefContext);                 \
}

#define PGM_DEREFERENCE_ADDRESS( _pAddress, _RefContext)            \
{                                                                   \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_ADDRESS), "", \
        "\t--pAddress[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pAddress,_pAddress->RefCount,(_pAddress->RefCount-1),__LINE__,__FILE__);  \
    PgmDereferenceAddress (_pAddress, _RefContext);                 \
}

#define PGM_DEREFERENCE_SEND_CONTEXT( _pSendDC)                     \
{                                                                   \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_SEND), "",    \
        "\t--pSendDC=<%x:%d->%d>, <%d:%s>\n",                  \
            _pSendDC,_pSendDC->RefCount,(_pSendDC->RefCount-1),__LINE__,__FILE__);  \
    PgmDereferenceSendContext (_pSendDC);                 \
}

#define PGM_DEREFERENCE_SESSION( _pSession, _Verify, _RefContext)   \
{                                                                   \
    PgmLog (PGM_LOG_INFORM_PATH, (DBG_DEBUG_REF | DBG_CONNECT), "", \
        "\t--pSession[%x]=<%x:%d->%d>, Verify=<%x>, <%d:%s>\n",     \
            _RefContext, _pSession,_pSession->RefCount,(_pSession->RefCount-1),_Verify,__LINE__,__FILE__);  \
    PgmDereferenceSessionCommon (_pSession, _Verify, _RefContext);  \
}

#define PGM_DEREFERENCE_SESSION_SEND( _pSession, _RefContext)       \
    PGM_DEREFERENCE_SESSION (_pSession, PGM_VERIFY_SESSION_SEND, _RefContext)

#define PGM_DEREFERENCE_SESSION_RECEIVE( _pSession, _RefContext)    \
    PGM_DEREFERENCE_SESSION (_pSession, PGM_VERIFY_SESSION_RECEIVE, _RefContext)

#define PGM_DEREFERENCE_SESSION_UNASSOCIATED( _pSession, _RefContext)    \
    PGM_DEREFERENCE_SESSION (_pSession, PGM_VERIFY_SESSION_UNASSOCIATED, _RefContext)

//----------------------------------------------------------------------------
//
// PgmAttachFsp()
//
/*++
Routine Description:

    This macro attaches a process to the File System Process to be sure
    that handles are created and released in the same process

Arguments:

Return Value:

    none

--*/

#define PgmAttachProcess(_pEProcess, _pApcState, _pAttached, _Context)\
{                                                                   \
    if (PsGetCurrentProcess() !=  _pEProcess)                       \
    {                                                               \
        KeStackAttachProcess(PsGetProcessPcb(_pEProcess), _pApcState);           \
        *_pAttached = TRUE;                                         \
    }                                                               \
    else                                                            \
    {                                                               \
        *_pAttached = FALSE;                                        \
    }                                                               \
}

#define PgmAttachFsp(_pApcState, _pAttached, _Context)              \
    PgmAttachProcess (PgmStaticConfig.FspProcess, _pApcState, _pAttached, _Context)

#define PgmAttachToProcessForVMAccess(_pSend, _pApcState, _pAttached, _Context) \
    PgmAttachProcess (PgmStaticConfig.FspProcess, _pApcState, _pAttached, _Context)


//    PgmAttachProcess ((_pSend)->Process, _pAttached, _Context)

//
// PgmDetachFsp()
//
/*++
Routine Description:

    This macro detaches a process from the File System Process
    if it was ever attached

Arguments:

Return Value:

--*/

#define PgmDetachProcess(_pApcState, _pAttached, _Context)  \
{                                                           \
    if (*_pAttached)                                        \
    {                                                       \
        KeUnstackDetachProcess(_pApcState);                 \
    }                                                       \
}

#define PgmDetachFsp    PgmDetachProcess

//----------------------------------------------------------------------------
#endif  _MACROES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\address.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Address.c

Abstract:

    This module implements Address handling routines
    for the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"
#include <ipinfo.h>     // for IPInterfaceInfo
#include <tcpinfo.h>    // for AO_OPTION_xxx, TCPSocketOption
#include <tdiinfo.h>    // for CL_TL_ENTITY, TCP_REQUEST_SET_INFORMATION_EX
#include <ipexport.h>   // for IP_OPT_ROUTER_ALERT


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

BOOLEAN
GetIpAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddr,
    IN  ULONG                       BufferLength,   // Total Buffer length
    OUT tIPADDRESS                  *pIpAddress,
    OUT USHORT                      *pPort
    )
/*++

Routine Description:

    This routine extracts the IP address from the TDI address block

Arguments:

    IN  pTransportAddr  -- the block of TDI address(es)
    IN  BufferLength    -- length of the block
    OUT pIpAddress      -- contains the IpAddress if we succeeded
    OUT pPort           -- contains the port if we succeeded

Return Value:

    TRUE if we succeeded in extracting the IP address, FALSE otherwise

--*/
{
    ULONG                       MinBufferLength;    // Minimun reqd to read next AddressType and AddressLength
    TA_ADDRESS                  *pAddress;
    TDI_ADDRESS_IP UNALIGNED    *pValidAddr;
    INT                         i;
    BOOLEAN                     fAddressFound = FALSE;

    MinBufferLength = FIELD_OFFSET(TRANSPORT_ADDRESS,Address);
    if (BufferLength < sizeof(TA_IP_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "GetIpAddress",
            "Rejecting Open Address request -- BufferLength<%d> < Min<%d>\n",
                BufferLength, sizeof(TA_IP_ADDRESS));
        return (FALSE);
    }

    try
    {
        pAddress = (TA_ADDRESS *) &pTransportAddr->Address[0];  // address type + the actual address
        for (i=0; i<pTransportAddr->TAAddressCount; i++)
        {
            //
            // We support only IP address types:
            //
            if ((pAddress->AddressType == TDI_ADDRESS_TYPE_IP) &&
                (pAddress->AddressLength >= TDI_ADDRESS_LENGTH_IP)) // sizeof (TDI_ADDRESS_IP)
            {

                pValidAddr = (TDI_ADDRESS_IP UNALIGNED *) pAddress->Address;
                *pIpAddress = pValidAddr->in_addr;
                *pPort = pValidAddr->sin_port;
                fAddressFound = TRUE;
                break;
            }

            //
            // Set pAddress to point to the next address
            //
            pAddress = (TA_ADDRESS *) ((PUCHAR)pAddress->Address + pAddress->AddressLength);

            //
            // Verify that we have enough Buffer space to read in next Address if IP address
            //
            MinBufferLength += pAddress->AddressLength + FIELD_OFFSET(TA_ADDRESS,Address);
            if (BufferLength < (MinBufferLength + sizeof(TDI_ADDRESS_IP)))
            {
                break;
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "GetIpAddress",
            "Exception <0x%x> trying to access Addr info\n", GetExceptionCode());
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, (DBG_ADDRESS | DBG_CONNECT), "GetIpAddress",
        "%s!\n", (fAddressFound ? "SUCCEEDED" : "FAILED"));

    return (fAddressFound);
}


//----------------------------------------------------------------------------

NTSTATUS
SetSenderMCastOutIf(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tIPADDRESS          IpAddress       // Net format
    )
/*++

Routine Description:

    This routine sets the outgoing interface for multicast traffic

Arguments:

    IN  pAddress    -- Pgm's Address object (contains file handle over IP)
    IN  IpAddress   -- interface address

Return Value:

    NTSTATUS - Final status of the set Interface operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    ULONG               BufferLength = 50;
    UCHAR               pBuffer[50];
    IPInterfaceInfo     *pIpIfInfo = (IPInterfaceInfo *) pBuffer;

    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_MCASTIF,
                            &IpAddress,
                            sizeof (tIPADDRESS));

    if (NT_SUCCESS (status))
    {
        status = PgmSetTcpInfo (pAddress->RAlertFileHandle,
                                AO_OPTION_MCASTIF,
                                &IpAddress,
                                sizeof (tIPADDRESS));
        if (NT_SUCCESS (status))
        {
            //
            // Now, determine the MTU
            //
            status = PgmQueryTcpInfo (pAddress->RAlertFileHandle,
                                      IP_INTFC_INFO_ID,
                                      &IpAddress,
                                      sizeof (tIPADDRESS),
                                      pBuffer,
                                      BufferLength);
            if ((NT_SUCCESS (status)) &&
                (pIpIfInfo->iii_mtu <= (sizeof(IPV4Header) +
                                        ROUTER_ALERT_SIZE +
                                        PGM_MAX_FEC_DATA_HEADER_LENGTH)))
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }
    }

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "SetSenderMCastOutIf",
            " AO_OPTION_MCASTIF or IP_INTFC_INFO_ID for <%x> returned <%x>, MTU=<%d>\n",
                IpAddress, status, pIpIfInfo->iii_mtu);

        return (status);
    }

    PgmLock (pAddress, OldIrq);

    //
    // get the length of the mac address in case is is less than 6 bytes
    //
    BufferLength = pIpIfInfo->iii_addrlength < sizeof(tMAC_ADDRESS) ?
                                            pIpIfInfo->iii_addrlength : sizeof(tMAC_ADDRESS);
    PgmZeroMemory (pAddress->OutIfMacAddress.Address, sizeof(tMAC_ADDRESS));
    PgmCopyMemory (&pAddress->OutIfMacAddress, pIpIfInfo->iii_addr, BufferLength);
    pAddress->OutIfMTU = pIpIfInfo->iii_mtu - (sizeof(IPV4Header) + ROUTER_ALERT_SIZE);
    pAddress->OutIfFlags = pIpIfInfo->iii_flags;
    pAddress->SenderMCastOutIf = ntohl (IpAddress);

    PgmUnlock (pAddress, OldIrq);

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "SetSenderMCastOutIf",
        "OutIf=<%x>, MTU=<%d>==><%d>\n", pAddress->SenderMCastOutIf, pIpIfInfo->iii_mtu, pAddress->OutIfMTU);

    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmDestroyAddress(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PVOID               Unused1,
    IN  PVOID               Unused2
    )
/*++

Routine Description:

    This routine closes the Files handles opened earlier and free's the memory
    It should only be called if there is no Reference on the Address Context

Arguments:

    IN  pAddress    -- Pgm's Address object

Return Value:

    NONE

--*/
{
    PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "PgmDestroyAddress",
        "Destroying Address=<%x>\n", pAddress);

    if (pAddress->RAlertFileHandle)
    {
        CloseAddressHandles (pAddress->RAlertFileHandle, pAddress->pRAlertFileObject);
    }

    CloseAddressHandles (pAddress->FileHandle, pAddress->pFileObject);

    PgmFreeMem (pAddress);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCreateAddress(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp,
    IN  PFILE_FULL_EA_INFORMATION   TargetEA
    )
/*++

Routine Description:

    This routine is called to create an address context for the client
    It's main task is to allocate the memory, open handles on IP, and
    set the initial IP options

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer
    IN  TargetEA    -- contains the MCast address info (determines whether
                        the client is a sender or receiver)

Return Value:

    NTSTATUS - Final status of the CreateAddress operation

--*/
{
    tADDRESS_CONTEXT            *pAddress = NULL;
    TRANSPORT_ADDRESS UNALIGNED *pTransportAddr;
    tMCAST_INFO                 MCastInfo;
    NTSTATUS                    status;
    tIPADDRESS                  IpAddress;
    LIST_ENTRY                  *pEntry;
    USHORT                      Port;
    PGMLockHandle               OldIrq;
    UCHAR                       RouterAlert[4] = {IP_OPT_ROUTER_ALERT, ROUTER_ALERT_SIZE, 0, 0};

    //
    // Verify Minimum Buffer length!
    //
    pTransportAddr = (TRANSPORT_ADDRESS UNALIGNED *) &(TargetEA->EaName[TargetEA->EaNameLength+1]);
    if (!GetIpAddress (pTransportAddr, TargetEA->EaValueLength, &IpAddress, &Port))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmCreateAddress",
            "GetIpAddress FAILed to return valid Address!\n");
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // Convert the parameters to host format
    //
    IpAddress = ntohl (IpAddress);
    Port = ntohs (Port);

    //
    // If we have been supplied an address at bind time, it has to
    // be a Multicast address
    //
    if ((IpAddress) &&
        (!IS_MCAST_ADDRESS (IpAddress)))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmCreateAddress",
            "IP=<%x> is not MCast addr!\n", IpAddress);
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // So, we found a valid address -- now, open it!
    //
    if (!(pAddress = PgmAllocMem (sizeof(tADDRESS_CONTEXT), PGM_TAG('0'))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmCreateAddress",
            "STATUS_INSUFFICIENT_RESOURCES!\n");
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    PgmZeroMemory (pAddress, sizeof (tADDRESS_CONTEXT));
    InitializeListHead (&pAddress->Linkage);
    InitializeListHead (&pAddress->AssociatedConnections);  // List of associated connections
    InitializeListHead (&pAddress->ListenHead);             // List of Clients listening on this address
    PgmInitLock (pAddress, ADDRESS_LOCK);

    pAddress->Verify = PGM_VERIFY_ADDRESS;
    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_CREATE, TRUE); // Set Locked to TRUE since it not in use

    pAddress->Process = (PEPROCESS) PsGetCurrentProcess();

    //
    // Now open a handle on IP
    //
    status = TdiOpenAddressHandle (pgPgmDevice,
                                   (PVOID) pAddress,
                                   0,                   // Open any Src address
                                   IPPROTO_RM,          // PGM port
                                   &pAddress->FileHandle,
                                   &pAddress->pFileObject,
                                   &pAddress->pDeviceObject);

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmCreateAddress",
            "TdiOpenAddressHandle returned <%x>\n", status);

        PgmFreeMem (pAddress);
        return (status);
    }

    if (IpAddress)
    {
        //
        // We are now ready to start receiving data (if we designated an MCast receiver)
        // Save the MCast addresses (if any were provided)
        //
        pAddress->ReceiverMCastAddr = IpAddress;    // Saved in Host format
        pAddress->ReceiverMCastPort = Port;

        PgmInterlockedInsertTailList (&PgmDynamicConfig.ReceiverAddressHead, &pAddress->Linkage, &PgmDynamicConfig);
    }
    else
    {
        //
        // This is an address for sending mcast packets, so
        // Open another FileObject for sending packets with RouterAlert option
        //
        status = TdiOpenAddressHandle (pgPgmDevice,
                                       NULL,
                                       0,                   // Open any Src address
                                       IPPROTO_RM,          // PGM port
                                       &pAddress->RAlertFileHandle,
                                       &pAddress->pRAlertFileObject,
                                       &pAddress->pRAlertDeviceObject);

        if (NT_SUCCESS (status))
        {
            // 
            //
            // This is an address for sending RouterAlert packets, so set the Router Alert option
            // 
            status = PgmSetTcpInfo (pAddress->RAlertFileHandle,
                                    AO_OPTION_IPOPTIONS,
                                    RouterAlert,
                                    sizeof (RouterAlert));

            if (!NT_SUCCESS (status))
            {
                PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmCreateAddress",
                    "AO_OPTION_IPOPTIONS for Router Alert returned <%x>\n", status);
            }
        }
        else
        {
            PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmCreateAddress",
                "AO_OPTION_IPOPTIONS for Router Alert returned <%x>\n", status);
        }

        if (!NT_SUCCESS (status))
        {
            PgmDestroyAddress (pAddress, NULL, NULL);
            return (status);
        }

        PgmLock (&PgmDynamicConfig, OldIrq);

        //
        // Set the default sender parameters
        // Since we don't know the MTU at this time, we
        // will assume 1.4K window size for Ethernet
        //
        pAddress->RateKbitsPerSec = SENDER_DEFAULT_RATE_KBITS_PER_SEC;
        pAddress->WindowSizeInBytes = SENDER_DEFAULT_WINDOW_SIZE_BYTES;
        pAddress->MaxWindowSizeBytes = SENDER_MAX_WINDOW_SIZE_PACKETS;
        pAddress->MaxWindowSizeBytes *= 1400;
        ASSERT (pAddress->MaxWindowSizeBytes >= SENDER_DEFAULT_WINDOW_SIZE_BYTES);
        pAddress->WindowSizeInMSecs = (BITS_PER_BYTE * pAddress->WindowSizeInBytes) /
                                      SENDER_DEFAULT_RATE_KBITS_PER_SEC;
        pAddress->WindowAdvancePercentage = SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE;
        pAddress->LateJoinerPercentage = SENDER_DEFAULT_LATE_JOINER_PERCENTAGE;
        pAddress->FECGroupSize = 1;     // ==> No FEC packets!
        pAddress->MCastPacketTtl = MAX_MCAST_TTL;
        InsertTailList (&PgmDynamicConfig.SenderAddressHead, &pAddress->Linkage);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
    }

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "PgmCreateAddress",
        "%s -- pAddress=<%x>, IP:Port=<%x:%x>\n", (IpAddress ? "Receiver" : "Sender"),
        pAddress, IpAddress, Port);

    pIrpSp->FileObject->FsContext = pAddress;
    pIrpSp->FileObject->FsContext2 = (PVOID) TDI_TRANSPORT_ADDRESS_FILE;

    return (STATUS_SUCCESS);
}



//----------------------------------------------------------------------------

VOID
PgmDereferenceAddress(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  ULONG               RefContext
    )
/*++

Routine Description:

    This routine decrements the RefCount on the address object
    and causes a cleanup to occur if the RefCount went to 0

Arguments:

    IN  pAddress    -- Pgm's address object
    IN  RefContext  -- context for which this address object
                        was referenced earlier

Return Value:

    NONE

--*/
{
    NTSTATUS        status;
    PGMLockHandle   OldIrq, OldIrq1;
    PIRP            pIrpCleanUp;

    PgmLock (pAddress, OldIrq);

    ASSERT (PGM_VERIFY_HANDLE2 (pAddress,PGM_VERIFY_ADDRESS, PGM_VERIFY_ADDRESS_DOWN));
    ASSERT (pAddress->RefCount);             // Check for too many derefs
    ASSERT (pAddress->ReferenceContexts[RefContext]--);

    if (--pAddress->RefCount)
    {
        PgmUnlock (pAddress, OldIrq);
        return;
    }

    ASSERT (IsListEmpty (&pAddress->AssociatedConnections));
    PgmUnlock (pAddress, OldIrq);

    //
    // Just Remove from the global list and Put it on the Cleaned up list!
    //
    PgmLock (&PgmDynamicConfig, OldIrq);
    PgmLock (pAddress, OldIrq1);

    pIrpCleanUp = pAddress->pIrpCleanUp;
    pAddress->pIrpCleanUp = NULL;

    RemoveEntryList (&pAddress->Linkage);
    InsertTailList (&PgmDynamicConfig.CleanedUpAddresses, &pAddress->Linkage);

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    //
    // pIrpCleanUp will be NULL if we dereferencing the address
    // as a result of an error during the Create
    //
    if (pIrpCleanUp)
    {
        PgmIoComplete (pIrpCleanUp, STATUS_SUCCESS, 0);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCleanupAddress(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PIRP                pIrp
    )
/*++

Routine Description:

    This routine is called as a result of a close on the client's
    address handle.  Our main job here is to mark the address
    as being cleaned up (so it that subsequent operations will
    fail) and complete the request only when the last RefCount
    has been dereferenced.

Arguments:

    IN  pAddress    -- Pgm's address object
    IN  pIrp        -- Client's request Irp

Return Value:

    NTSTATUS - Final status of the set event operation (STATUS_PENDING)

--*/
{
    NTSTATUS        status;
    PGMLockHandle   OldIrq, OldIrq1;

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "PgmCleanupAddress",
        "Address=<%x> FileHandle=<%x>, FileObject=<%x>\n",
            pAddress, pAddress->FileHandle, pAddress->pFileObject);

    PgmLock (&PgmDynamicConfig, OldIrq);
    PgmLock (pAddress, OldIrq1);

    ASSERT (PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS));
    pAddress->Verify = PGM_VERIFY_ADDRESS_DOWN;
    pAddress->pIrpCleanUp = pIrp;

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CREATE);

    //
    // The final Dereference will complete the Irp!
    //
    return (STATUS_PENDING);
}

//----------------------------------------------------------------------------

NTSTATUS
PgmCloseAddress(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is the final dispatch operation to be performed
    after the cleanup, which should result in the address being
    completely destroyed -- our RefCount must have already
    been set to 0 when we completed the Cleanup request.

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- Current request stack location

Return Value:

    NTSTATUS - Final status of the operation (STATUS_SUCCESS)

--*/
{
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;

    pIrpSp->FileObject->FsContext = NULL;

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_ADDRESS, "PgmCloseAddress",
        "Address=<%x>, RefCount=<%d>\n", pAddress, pAddress->RefCount);

    //
    // Remove from the CleanedUp list
    //
    PgmLock (&PgmDynamicConfig, OldIrq);
    PgmLock (pAddress, OldIrq1);

    RemoveEntryList (&pAddress->Linkage);

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PgmDestroyAddress (pAddress, NULL, NULL);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmAssociateAddress(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    )
/*++

Routine Description:

    This routine associates a connection with an address object

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    tADDRESS_CONTEXT                *pAddress = NULL;
    tCOMMON_SESSION_CONTEXT         *pSession = pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL_ASSOCIATE   pParameters = (PTDI_REQUEST_KERNEL_ASSOCIATE) &pIrpSp->Parameters;
    PFILE_OBJECT                    pFileObject = NULL;
    NTSTATUS                        status;
    PGMLockHandle                   OldIrq, OldIrq1, OldIrq2;

    //
    // Get a pointer to the file object, which points to the address
    // element by calling a kernel routine to convert the filehandle into
    // a file object pointer.
    //
    status = ObReferenceObjectByHandle (pParameters->AddressHandle,
                                        FILE_READ_DATA,
                                        *IoFileObjectType,
                                        pIrp->RequestorMode,
                                        (PVOID *) &pFileObject,
                                        NULL);

    if (!NT_SUCCESS(status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmAssociateAddress",
            "Invalid Address Handle=<%x>\n", pParameters->AddressHandle);
        return (STATUS_INVALID_HANDLE);
    }

    //
    // Acquire the DynamicConfig lock so as to ensure that the Address
    // and Connection cannot get removed while we are processing it!
    //
    PgmLock (&PgmDynamicConfig, OldIrq);

    //
    // Verify the Connection handle
    //
    if ((!PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_UNASSOCIATED)) ||
        (pSession->pAssociatedAddress))       // Ensure the connection is not already associated!
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmAssociateAddress",
            "Invalid Session Handle=<%x>\n", pSession);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        ObDereferenceObject ((PVOID) pFileObject);
        return (STATUS_INVALID_HANDLE);
    }

    //
    // Verify the Address handle
    //
    pAddress = pFileObject->FsContext;
    if ((pFileObject->DeviceObject->DriverObject != PgmStaticConfig.DriverObject) ||
        (PtrToUlong (pFileObject->FsContext2) != TDI_TRANSPORT_ADDRESS_FILE) ||
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmAssociateAddress",
            "Invalid Address Context=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        ObDereferenceObject ((PVOID) pFileObject);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLock (pAddress, OldIrq1);
    PgmLock (pSession, OldIrq2);

    ASSERT (!pSession->pReceiver && !pSession->pSender);

    //
    // Now try to allocate the send / receive context
    //
    if (((pAddress->ReceiverMCastAddr) &&
         !(pSession->pReceiver = PgmAllocMem (sizeof(tRECEIVE_CONTEXT), PGM_TAG('0')))) ||
        (!(pAddress->ReceiverMCastAddr) &&
         !(pSession->pSender = PgmAllocMem (sizeof(tSEND_CONTEXT), PGM_TAG('0')))))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmAssociateAddress",
            "STATUS_INSUFFICIENT_RESOURCES allocating <%d> bytes for pAddress=<%x>, pSession=<%x>\n",
                (pAddress->ReceiverMCastAddr ? sizeof(tRECEIVE_CONTEXT) : sizeof(tSEND_CONTEXT)),
                pAddress, pSession);

        PgmUnlock (pSession, OldIrq2);
        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        ObDereferenceObject ((PVOID) pFileObject);

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Now associate the connection with the address!
    // Unlink from the ConnectionsCreated list which was linked
    // when the connection was created, and put on the AssociatedConnections list
    //
    pSession->pAssociatedAddress = pAddress;
    RemoveEntryList (&pSession->Linkage);
    InsertTailList (&pAddress->AssociatedConnections, &pSession->Linkage);

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_ASSOCIATED, TRUE);

    //
    // Now mark the Connect structure as for whether it is for
    // Sender or a receiver
    //
    if (pAddress->ReceiverMCastAddr)
    {
        //
        // We are a receiver
        //
        PgmZeroMemory (pSession->pReceiver, sizeof(tRECEIVE_CONTEXT));
        InitializeListHead (&pSession->pReceiver->Linkage);
        InitializeListHead (&pSession->pReceiver->NaksForwardDataList);
        InitializeListHead (&pSession->pReceiver->ReceiveIrpsList);
        InitializeListHead (&pSession->pReceiver->BufferedDataList);
        InitializeListHead (&pSession->pReceiver->PendingNaksList);

        pSession->Verify = PGM_VERIFY_SESSION_RECEIVE;
        PGM_REFERENCE_SESSION_RECEIVE (pSession, REF_SESSION_ASSOCIATED, TRUE);

        pSession->pReceiver->ListenMCastIpAddress = pAddress->ReceiverMCastAddr;
        pSession->pReceiver->ListenMCastPort = pAddress->ReceiverMCastPort;
        pSession->pReceiver->pReceive = pSession;
/*
        pSession->pReceiver->NakMaxWaitTime = (2 * NAK_MAX_INITIAL_BACKOFF_TIMEOUT_MSECS) /
                                              BASIC_TIMER_GRANULARITY_IN_MSECS;
*/
    }
    else
    {
        //
        // We are a sender
        //
        PgmZeroMemory (pSession->pSender, sizeof(tSEND_CONTEXT));
        InitializeListHead (&pSession->pSender->Linkage);
        InitializeListHead (&pSession->pSender->PendingSends);
        InitializeListHead (&pSession->pSender->CompletedSendsInWindow);
        InitializeListHead (&pSession->pSender->PendingRDataRequests);
        InitializeListHead (&pSession->pSender->HandledRDataRequests);
        ExInitializeResourceLite (&pSession->pSender->Resource);

        pSession->Verify = PGM_VERIFY_SESSION_SEND;
        PgmCopyMemory (pSession->GSI, &pAddress->OutIfMacAddress, SOURCE_ID_LENGTH);

        PGM_REFERENCE_SESSION_SEND (pSession, REF_SESSION_ASSOCIATED, TRUE);
    }


    PgmUnlock (pSession, OldIrq2);
    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    ObDereferenceObject ((PVOID) pFileObject);

    PgmLog (PGM_LOG_INFORM_STATUS, (DBG_ADDRESS | DBG_CONNECT), "PgmAssociateAddress",
        "Associated pSession=<%x> with pAddress=<%x>\n", pSession, pAddress);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmDisassociateAddress(
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    )
/*++

Routine Description:

    This routine disassociates a connection from an address object

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    tCOMMON_SESSION_CONTEXT         *pSession = pIrpSp->FileObject->FsContext;
    tADDRESS_CONTEXT                *pAddress = NULL;
    PGMLockHandle                   OldIrq, OldIrq1, OldIrq2;

    //
    // Acquire the DynamicConfig lock so as to ensure that the Address
    // and Connection Linkages cannot change while we are processing it!
    //
    PgmLock (&PgmDynamicConfig, OldIrq);

    //
    // First verify all the handles
    //
    if (!PGM_VERIFY_HANDLE3 (pSession, PGM_VERIFY_SESSION_SEND,
                                       PGM_VERIFY_SESSION_RECEIVE,
                                       PGM_VERIFY_SESSION_DOWN))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmDisassociateAddress",
            "Invalid Session Handle=<%x>, Verify=<%x>\n", pSession, pSession->Verify);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    pAddress = pSession->pAssociatedAddress;
    if (!PGM_VERIFY_HANDLE2 (pAddress, PGM_VERIFY_ADDRESS, PGM_VERIFY_ADDRESS_DOWN))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmDisassociateAddress",
            "pSession=<%x>, Invalid Address Context=<%x>\n", pSession, pSession->pAssociatedAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLog (PGM_LOG_INFORM_STATUS, (DBG_ADDRESS | DBG_CONNECT), "PgmDisassociateAddress",
        "Disassociating pSession=<%x:%x> from pAddress=<%x>\n",
            pSession, pSession->ClientSessionContext, pSession->pAssociatedAddress);

    PgmLock (pAddress, OldIrq1);
    PgmLock (pSession, OldIrq2);

    //
    // Unlink from the AssociatedConnections list, which was linked
    // when the connection was created.
    //
    pSession->pAssociatedAddress = NULL;      // Disassociated!
    RemoveEntryList (&pSession->Linkage);
    if (PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE))
    {
        //
        // The connection is still active, so just put it on the CreatedConnections list
        //
        InsertTailList (&PgmDynamicConfig.ConnectionsCreated, &pSession->Linkage);
    }
    else    // PGM_VERIFY_SESSION_DOWN
    {
        //
        // The Connection was CleanedUp and may even be closed,
        // so put it on the CleanedUp list!
        //
        InsertTailList (&PgmDynamicConfig.CleanedUpConnections, &pSession->Linkage);
    }

    PgmUnlock (pSession, OldIrq2);
    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    if (PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_RECEIVE))
    {
        PGM_DEREFERENCE_SESSION_RECEIVE (pSession, REF_SESSION_ASSOCIATED);
    }
    else if (PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_SEND))
    {
        PGM_DEREFERENCE_SESSION_SEND (pSession, REF_SESSION_ASSOCIATED);
    }
    else    // we have already been cleaned up, so just do unassociated!
    {
        PGM_DEREFERENCE_SESSION_UNASSOCIATED (pSession, REF_SESSION_ASSOCIATED);
    }

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_ASSOCIATED);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetMCastOutIf(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called as a result of the client attempting
    to set the outgoing interface for MCast traffic

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set outgoing interface operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    ULONG               Length;
    ULONG               BufferLength = 50;
    UCHAR               pBuffer[50];
    IPInterfaceInfo     *pIpIfInfo = (IPInterfaceInfo *) pBuffer;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;
    ULONG               *pInfoBuffer = (PULONG) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetMCastOutIf",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetMCastOutIf",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                                  // Cannot set OutIf on Receiver!
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetMCastOutIf",
            "Invalid Option for Receiver, pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, FALSE);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    status = SetSenderMCastOutIf (pAddress, pInputBuffer->MCastOutIf);

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO);

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "PgmSetMCastOutIf",
        "OutIf = <%x>\n", pAddress->SenderMCastOutIf);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
ReceiverAddMCastIf(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tIPADDRESS          IpAddress,                  // In host format
    IN  PGMLockHandle       *pOldIrqDynamicConfig,
    IN  PGMLockHandle       *pOldIrqAddress
    )
/*++

Routine Description:

    This routine is called as a result of the client attempting
    to add an interface to the list of interfaces listening for
    MCast traffic

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the add interface operation

--*/
{
    NTSTATUS            status;
    tMCAST_INFO         MCastInfo;
    ULONG               IpInterfaceContext;
    USHORT              i;

    if (!pAddress->ReceiverMCastAddr)                                // Cannot set ReceiveIf on Sender!
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "ReceiverAddMCastIf",
            "Invalid Option for Sender, pAddress=<%x>\n", pAddress);

        return (STATUS_NOT_SUPPORTED);
    }

    status = GetIpInterfaceContextFromAddress (IpAddress, &IpInterfaceContext);
    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "ReceiverAddMCastIf",
            "GetIpInterfaceContextFromAddress returned <%x> for Address=<%x>\n",
                status, IpAddress);

        return (STATUS_SUCCESS);
    }

    //
    // If we are already listening on this interface, return success
    //
    for (i=0; i <pAddress->NumReceiveInterfaces; i++)
    {
#ifdef IP_FIX
        if (pAddress->ReceiverInterfaceList[i] == IpInterfaceContext)
#else
        if (pAddress->ReceiverInterfaceList[i] == IpAddress)
#endif  // IP_FIX
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "ReceiverAddMCastIf",
                "InAddress=<%x> -- Already listening on IfContext=<%x>\n",
                    IpAddress, IpInterfaceContext);

            return (STATUS_SUCCESS);
        }
    }

    //
    // If we have reached the limit on the interfaces we can listen on,
    // return error
    //
    if (pAddress->NumReceiveInterfaces >= MAX_RECEIVE_INTERFACES)
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "ReceiverAddMCastIf",
            "Listening on too many interfaces!, pAddress=<%x>\n", pAddress);

        return (STATUS_NOT_SUPPORTED);
    }

    PgmUnlock (pAddress, *pOldIrqAddress);
    PgmUnlock (&PgmDynamicConfig, *pOldIrqDynamicConfig);

    //
    // This is the interface for receiving mcast packets on, so do JoinLeaf
    // 
    MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
#ifdef IP_FIX
    MCastInfo.MCastInIf = IpInterfaceContext;
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_INDEX_ADD_MCAST,
                            &MCastInfo,
                            sizeof (tMCAST_INFO));
#else
    MCastInfo.MCastInIf = ntohl (IpAddress);
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_ADD_MCAST,
                            &MCastInfo,
                            sizeof (tMCAST_INFO));
#endif  // IP_FIX

    PgmLock (&PgmDynamicConfig, *pOldIrqDynamicConfig);
    PgmLock (pAddress, *pOldIrqAddress);

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "\tReceiverAddMCastIf",
            "PgmSetTcpInfo returned: <%x>, If=<%x>\n", status, IpAddress);

        return (status);
    }

#ifdef IP_FIX
    pAddress->ReceiverInterfaceList[pAddress->NumReceiveInterfaces++] = IpInterfaceContext;
#else
    pAddress->ReceiverInterfaceList[pAddress->NumReceiveInterfaces++] = IpAddress;
#endif  // IP_FIX

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "\tReceiverAddMCastIf",
        "Added Ip=<%x>, IfContext=<%x>\n", IpAddress, IpInterfaceContext);

    return (status);
}



//----------------------------------------------------------------------------

NTSTATUS
PgmSetEventHandler(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine sets the client's Event Handlers wrt its address context

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS                        status = STATUS_SUCCESS;
    tADDRESS_CONTEXT                *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL_SET_EVENT   pKeSetEvent = (PTDI_REQUEST_KERNEL_SET_EVENT) &pIrpSp->Parameters;
    PVOID                           pEventHandler = pKeSetEvent->EventHandler;
    PVOID                           pEventContext = pKeSetEvent->EventContext;
    PGMLockHandle                   OldIrq, OldIrq1;

    PgmLock (&PgmDynamicConfig, OldIrq);
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetEventHandler",
            "Invalid Address Handle=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_ADDRESS, "PgmSetEventHandler",
        "Type=<%x>, Handler=<%x>, Context=<%x>\n", pKeSetEvent->EventType, pEventHandler, pEventContext);

    if (!pEventHandler)
    {
        //
        // We will set it to use the default Tdi Handler!
        //
        pEventContext = NULL;
    }

    PgmLock (pAddress, OldIrq1);
    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, TRUE);

    switch (pKeSetEvent->EventType)
    {
        case TDI_EVENT_CONNECT:
        {
            if (!pAddress->ReceiverMCastAddr)
            {
                PgmUnlock (pAddress, OldIrq1);
                PgmUnlock (&PgmDynamicConfig, OldIrq);

                PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetEventHandler",
                    "TDI_EVENT_CONNECT:  pAddress=<%x> is not a Receiver\n", pAddress);

                return (STATUS_UNSUCCESSFUL);
            }

            pAddress->evConnect = (pEventHandler ? pEventHandler : TdiDefaultConnectHandler);
            pAddress->ConEvContext = pEventContext;

            //
            // If no default interface was specified, we need to set one now
            //
            if (!pAddress->NumReceiveInterfaces)
            {
                if (!IsListEmpty (&PgmDynamicConfig.LocalInterfacesList))
                {
                    status = ListenOnAllInterfaces (pAddress, &OldIrq, &OldIrq1);

                    if (NT_SUCCESS (status))
                    {
                        PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "PgmSetEventHandler",
                            "CONNECT:  ListenOnAllInterfaces for pAddress=<%x> succeeded\n", pAddress);
                    }
                    else
                    {
                        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetEventHandler",
                            "CONNECT:  ListenOnAllInterfaces for pAddress=<%x> returned <%x>\n",
                                pAddress, status);
                    }
                }

                pAddress->Flags |= (PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE |
                                    PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES);
            }

            break;
        }

        case TDI_EVENT_DISCONNECT:
        {
            pAddress->evDisconnect = (pEventHandler ? pEventHandler : TdiDefaultDisconnectHandler);
            pAddress->DiscEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_ERROR:
        {
            pAddress->evError = (pEventHandler ? pEventHandler : TdiDefaultErrorHandler);
            pAddress->ErrorEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_RECEIVE:
        {
            pAddress->evReceive = (pEventHandler ? pEventHandler : TdiDefaultReceiveHandler);
            pAddress->RcvEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_RECEIVE_DATAGRAM:
        {
            pAddress->evRcvDgram = (pEventHandler ? pEventHandler : TdiDefaultRcvDatagramHandler);
            pAddress->RcvDgramEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_RECEIVE_EXPEDITED:
        {
            pAddress->evRcvExpedited = (pEventHandler ? pEventHandler : TdiDefaultRcvExpeditedHandler);
            pAddress->RcvExpedEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_SEND_POSSIBLE:
        {
            pAddress->evSendPossible = (pEventHandler ? pEventHandler : TdiDefaultSendPossibleHandler);
            pAddress->SendPossEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_CHAINED_RECEIVE:
        case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:
        case TDI_EVENT_CHAINED_RECEIVE_EXPEDITED:
        case TDI_EVENT_ERROR_EX:
        {
            status = STATUS_NOT_SUPPORTED;
            break;
        }

        default:
        {
            PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetEventHandler",
                "Invalid Event Type = <%x>\n", pKeSetEvent->EventType);
            status = STATUS_UNSUCCESSFUL;
            break;
        }
    }

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmAddMCastReceiveIf(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called as a result of the client attempting
    to add an interface to the list of interfaces listening for
    MCast traffic

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the add interface operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmAddMCastReceiveIf",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmAddMCastReceiveIf",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLock (pAddress, OldIrq1);

    if (!pInputBuffer->MCastInfo.MCastInIf)
    {
        //
        // We will use default behavior
        //
        pAddress->Flags |= PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES;

        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmLog (PGM_LOG_INFORM_PATH, DBG_ADDRESS, "PgmAddMCastReceiveIf",
            "Application requested bind to IP=<%x>\n", pInputBuffer->MCastInfo.MCastInIf);

        return (STATUS_SUCCESS);
    }

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, TRUE);

    status = ReceiverAddMCastIf (pAddress, ntohl (pInputBuffer->MCastInfo.MCastInIf), &OldIrq, &OldIrq1);

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO);

    if (NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_ADDRESS, "PgmAddMCastReceiveIf",
            "Added Address=<%x>\n", pInputBuffer->MCastInfo.MCastInIf);
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmAddMCastReceiveIf",
            "ReceiverAddMCastIf returned <%x>, Address=<%x>\n", status, pInputBuffer->MCastInfo.MCastInIf);
    }

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmDelMCastReceiveIf(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client to remove an interface from the list
    of interfaces we are currently listening on

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the delete interface operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;
    tMCAST_INFO         MCastInfo;
    ULONG               IpInterfaceContext;
    USHORT              i;
    BOOLEAN             fFound;
#ifndef IP_FIX
    tIPADDRESS          IpAddress;
#endif  // !IP_FIX

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmDelMCastReceiveIf",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmDelMCastReceiveIf",
            "Invalid Handles pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (!pAddress->ReceiverMCastAddr)                                 // Cannot set ReceiveIf on Sender!
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmDelMCastReceiveIf",
            "Invalid Option for Sender, pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    status = GetIpInterfaceContextFromAddress (ntohl(pInputBuffer->MCastInfo.MCastInIf), &IpInterfaceContext);
    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmDelMCastReceiveIf",
            "GetIpInterfaceContextFromAddress returned <%x> for Address=<%x>\n",
                status, pInputBuffer->MCastInfo.MCastInIf);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_ADDRESS);
    }

    PgmLock (pAddress, OldIrq1);

    //
    // Now see if we are even listening on this interface
    //
    fFound = FALSE;
#ifndef IP_FIX
    IpAddress = ntohl(pInputBuffer->MCastInfo.MCastInIf);
#endif  // !IP_FIX
    for (i=0; i <pAddress->NumReceiveInterfaces; i++)
    {
#ifdef IP_FIX
        if (pAddress->ReceiverInterfaceList[i] == IpInterfaceContext)
#else
        if (pAddress->ReceiverInterfaceList[i] == IpAddress)
#endif  // IP_FIX
        {
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "PgmDelMCastReceiveIf",
            "Receiver is no longer listening on InAddress=<%x>, IfContext=<%x>\n",
                pInputBuffer->MCastInfo.MCastInIf, IpInterfaceContext);

        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_SUCCESS);
    }

    pAddress->NumReceiveInterfaces--;
    while (i < pAddress->NumReceiveInterfaces)
    {
        pAddress->ReceiverInterfaceList[i] = pAddress->ReceiverInterfaceList[i+1];
        i++;
    }

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, TRUE);

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
#ifdef IP_FIX
    MCastInfo.MCastInIf = IpInterfaceContext;
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_INDEX_DEL_MCAST,
                            &MCastInfo,
                            sizeof (tMCAST_INFO));
#else
    MCastInfo.MCastInIf = pInputBuffer->MCastInfo.MCastInIf;
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_DEL_MCAST,
                            &MCastInfo,
                            sizeof (tMCAST_INFO));
#endif  // IP_FIX

    if (NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "PgmDelMCastReceiveIf",
            "MCast Addr:Port=<%x:%x>, OutIf=<%x>\n",
                pAddress->ReceiverMCastAddr, pAddress->ReceiverMCastPort,
                pInputBuffer->MCastInfo.MCastInIf);
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmDelMCastReceiveIf",
            "PgmSetTcpInfo returned: <%x> for IP=<%x>, IfContext=<%x>\n",
                status, pInputBuffer->MCastInfo.MCastInIf, IpInterfaceContext);
        return (status);
    }

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetWindowSizeAndSendRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to override the default
    Send Rate and Window size specifications

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;
    ULONGLONG          RateKbitsPerSec;       // Send rate
    ULONGLONG          WindowSizeInBytes;
    ULONGLONG          WindowSizeInMSecs;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetWindowSizeAndSendRate",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetWindowSizeAndSendRate",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if ((pAddress->ReceiverMCastAddr) ||                            // Cannot set OutIf on Receiver!
        (!IsListEmpty (&pAddress->AssociatedConnections)))          // Cannot set options on active sender
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetWindowSizeAndSendRate",
            "Invalid Option, pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    RateKbitsPerSec = pInputBuffer->TransmitWindowInfo.RateKbitsPerSec;
    WindowSizeInBytes = pInputBuffer->TransmitWindowInfo.WindowSizeInBytes;
    WindowSizeInMSecs = pInputBuffer->TransmitWindowInfo.WindowSizeInMSecs;

    //
    // Now, fill in missing info
    //
    if ((RateKbitsPerSec || WindowSizeInMSecs || WindowSizeInBytes) &&     // no paramter specified -- error
        (!(RateKbitsPerSec && WindowSizeInMSecs && WindowSizeInBytes)))    // all parameters specified
    {
        //
        // If 2 parameters have been specified, we only need to compute the third one
        //
        if (RateKbitsPerSec && WindowSizeInMSecs)
        {
            ASSERT (WindowSizeInMSecs >= MIN_RECOMMENDED_WINDOW_MSECS);
            WindowSizeInBytes = (WindowSizeInMSecs * RateKbitsPerSec) / BITS_PER_BYTE;
        }
        else if (RateKbitsPerSec && WindowSizeInBytes)
        {
            WindowSizeInMSecs = (BITS_PER_BYTE * WindowSizeInBytes) / RateKbitsPerSec;
        }
        else if (WindowSizeInBytes && WindowSizeInMSecs)
        {
            RateKbitsPerSec = (WindowSizeInBytes * BITS_PER_BYTE) / WindowSizeInMSecs;
            ASSERT (WindowSizeInMSecs >= MIN_RECOMMENDED_WINDOW_MSECS);
        }
        // for the remainder of the scenarios only 1 parameter has been specified
        // Since WindowSizeInMSecs does not really affect our boundaries,
        // it is the easiest to ignore while picking the defaults
        else if (RateKbitsPerSec)
        {
            // Use default Window size
            WindowSizeInBytes = SENDER_DEFAULT_WINDOW_SIZE_BYTES;
            WindowSizeInMSecs = (BITS_PER_BYTE * WindowSizeInBytes) / RateKbitsPerSec;
            if (WindowSizeInMSecs < MIN_RECOMMENDED_WINDOW_MSECS)
            {
                WindowSizeInMSecs = MIN_RECOMMENDED_WINDOW_MSECS;
                WindowSizeInBytes = (WindowSizeInMSecs * RateKbitsPerSec) / BITS_PER_BYTE;
                if (WindowSizeInBytes > pAddress->MaxWindowSizeBytes)
                {
                    WindowSizeInBytes = pAddress->MaxWindowSizeBytes;
                    WindowSizeInMSecs = (WindowSizeInBytes * BITS_PER_BYTE) / RateKbitsPerSec;
                }
            }
        }
        else if ((WindowSizeInBytes) &&
                 (WindowSizeInBytes >= pAddress->OutIfMTU))             // Necessary so that Win Adv rate!=0
        {
            RateKbitsPerSec = SENDER_DEFAULT_RATE_KBITS_PER_SEC;
            WindowSizeInMSecs = (BITS_PER_BYTE * WindowSizeInBytes) / RateKbitsPerSec;
            ASSERT (WindowSizeInMSecs >= MIN_RECOMMENDED_WINDOW_MSECS);
        }
        else if ((WindowSizeInMSecs < pAddress->MaxWindowSizeBytes) &&  // Necessary so that Rate >= 1
                 (WindowSizeInMSecs >= MIN_RECOMMENDED_WINDOW_MSECS) &&
                 (WindowSizeInMSecs >= pAddress->OutIfMTU))             // Necessary so that Win Adv rate!=0
        {
            // This is trickier -- we will first try to determine our constraints
            // and try to use default settings, otherwise attempt to use the median value.
            if (WindowSizeInMSecs <= (BITS_PER_BYTE * (pAddress->MaxWindowSizeBytes /
                                                       SENDER_DEFAULT_RATE_KBITS_PER_SEC)))
            {
                RateKbitsPerSec = SENDER_DEFAULT_RATE_KBITS_PER_SEC;
                WindowSizeInBytes = (WindowSizeInMSecs * RateKbitsPerSec) / BITS_PER_BYTE;
            }
            // Hmm, we have to drop below out preferred rate -- try to pick the median range
            else if (RateKbitsPerSec = BITS_PER_BYTE * (pAddress->MaxWindowSizeBytes /
                                                        (WindowSizeInMSecs * 2)))
            {   
                WindowSizeInBytes = (WindowSizeInMSecs * RateKbitsPerSec) / BITS_PER_BYTE;
            }
            else
            {
                //
                // Darn, we have to go with a huge file size and the min. rate!
                //
                RateKbitsPerSec = 1;
                WindowSizeInBytes = WindowSizeInMSecs;
            }
        }
    }

    //
    // Check validity of requested settings
    //
    if ((!(RateKbitsPerSec && WindowSizeInMSecs && WindowSizeInBytes)) ||  // all 3 must be specified from above
        (RateKbitsPerSec != (WindowSizeInBytes * BITS_PER_BYTE / WindowSizeInMSecs)) ||
        (WindowSizeInBytes > pAddress->MaxWindowSizeBytes) ||
        (WindowSizeInBytes < pAddress->OutIfMTU))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetWindowSizeAndSendRate",
            "Invalid settings for pAddress=<%x>, Rate=<%d>, WSizeBytes=<%d>, WSizeMS=<%d>, MaxWSize=<%d:%d>\n",
                pAddress,
                pInputBuffer->TransmitWindowInfo.RateKbitsPerSec,
                pInputBuffer->TransmitWindowInfo.WindowSizeInBytes,
                pInputBuffer->TransmitWindowInfo.WindowSizeInMSecs,
                pAddress->MaxWindowSizeBytes);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_PARAMETER);
    }

    pAddress->RateKbitsPerSec = (ULONG) RateKbitsPerSec;
    pAddress->WindowSizeInBytes = (ULONG) WindowSizeInBytes;
    pAddress->WindowSizeInMSecs = (ULONG) WindowSizeInMSecs;

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryWindowSizeAndSendRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Send Rate and Window size specifications

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmQueryWindowSizeAndSendRate",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryWindowSizeAndSendRate",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                              // Invalid option for Receiver!
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryWindowSizeAndSendRate",
            "Invalid option ofr receiver pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    pBuffer->TransmitWindowInfo.RateKbitsPerSec = (ULONG) pAddress->RateKbitsPerSec;
    pBuffer->TransmitWindowInfo.WindowSizeInBytes = (ULONG) pAddress->WindowSizeInBytes;
    pBuffer->TransmitWindowInfo.WindowSizeInMSecs = (ULONG) pAddress->WindowSizeInMSecs;

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetWindowAdvanceRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to override the default
    Window Advance rate

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetWindowAdvanceRate",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    status = STATUS_SUCCESS;
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetWindowAdvanceRate",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        status = STATUS_INVALID_HANDLE;
    }
    else if ((pAddress->ReceiverMCastAddr) ||                       // Cannot set OutIf on Receiver!
             (!IsListEmpty (&pAddress->AssociatedConnections)))     // Cannot set options on active sender
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetWindowAdvanceRate",
            "Invalid pAddress type or state <%x>\n", pAddress);

        status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (status))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (status);
    }

    if ((pInputBuffer->WindowAdvancePercentage) &&
        (pInputBuffer->WindowAdvancePercentage <= MAX_WINDOW_INCREMENT_PERCENTAGE))
    {
        pAddress->WindowAdvancePercentage = pInputBuffer->WindowAdvancePercentage;
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryWindowAdvanceRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Send Window advance rate

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmQueryWindowAdvanceRate",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryWindowAdvanceRate",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                              // Invalid option for Receiver!
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryWindowAdvanceRate",
            "Invalid option for receiver, pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    pBuffer->WindowAdvancePercentage = pAddress->WindowAdvancePercentage;
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetLateJoinerPercentage(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to override the default
    Late Joiner percentage (i.e. % of Window late joiner can request)

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetLateJoinerPercentage",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    status = STATUS_SUCCESS;
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetLateJoinerPercentage",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        status = STATUS_INVALID_HANDLE;
    }
    else if ((pAddress->ReceiverMCastAddr) ||                       // Cannot set LateJoin % on Receiver!
             (!IsListEmpty (&pAddress->AssociatedConnections)))     // Cannot set options on active sender
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetLateJoinerPercentage",
            "Invalid pAddress type or state <%x>\n", pAddress);

        status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (status))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (status);
    }

    if (pInputBuffer->LateJoinerPercentage <= SENDER_MAX_LATE_JOINER_PERCENTAGE)
    {
        pAddress->LateJoinerPercentage = pInputBuffer->LateJoinerPercentage;
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryLateJoinerPercentage(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Late Joiner percentage

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmQueryLateJoinerPercentage",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryLateJoinerPercentage",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                              // Cannot query LateJoin % on Receiver!
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryLateJoinerPercentage",
            "Invalid option for receiver, pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    pBuffer->LateJoinerPercentage = pAddress->LateJoinerPercentage;

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetWindowAdvanceMethod(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to override the default
    Late Joiner percentage (i.e. % of Window late joiner can request)

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetWindowAdvanceMethod",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    status = STATUS_SUCCESS;
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetWindowAdvanceMethod",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        status = STATUS_INVALID_HANDLE;
    }
    else if (pAddress->ReceiverMCastAddr)                           // Cannot set WindowAdvanceMethod on Receiver!
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmSetWindowAdvanceMethod",
            "Invalid pAddress type or state <%x>\n", pAddress);

        status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (status))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (status);
    }

    if (pInputBuffer->WindowAdvanceMethod == E_WINDOW_ADVANCE_BY_TIME)
    {
        pAddress->Flags &= ~PGM_ADDRESS_USE_WINDOW_AS_DATA_CACHE;
    }
    else if (pInputBuffer->WindowAdvanceMethod == E_WINDOW_USE_AS_DATA_CACHE)
    {
//        pAddress->Flags |= PGM_ADDRESS_USE_WINDOW_AS_DATA_CACHE;
        status = STATUS_NOT_SUPPORTED;      // Not supported for now!
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryWindowAdvanceMethod(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Late Joiner percentage

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmQueryWindowAdvanceMethod",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryWindowAdvanceMethod",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    if (pAddress->ReceiverMCastAddr)                              // Cannot query WindowAdvanceMethod on Receiver!
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryWindowAdvanceMethod",
            "Invalid option for receiver, pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    if (pAddress->Flags & PGM_ADDRESS_USE_WINDOW_AS_DATA_CACHE)
    {
        pBuffer->WindowAdvanceMethod = E_WINDOW_USE_AS_DATA_CACHE;
    }
    else
    {
        pBuffer->WindowAdvanceMethod = E_WINDOW_ADVANCE_BY_TIME;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetNextMessageBoundary(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to set the Message length
    for the next set of messages (typically, 1 send is sent as 1 Message).

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tSEND_SESSION       *pSend = (tSEND_SESSION *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetNextMessageBoundary",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if ((!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND)) ||
        (!pSend->pAssociatedAddress))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT | DBG_SEND), "PgmSetNextMessageBoundary",
            "Invalid Handle pSend=<%x>\n", pSend);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (!pSend->pSender)
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT | DBG_SEND), "PgmSetNextMessageBoundary",
            "Invalid Option for Receiver, pSend=<%x>\n", pSend);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PgmLock (pSend, OldIrq1);

    if ((pInputBuffer->NextMessageBoundary) &&
        (!pSend->pSender->ThisSendMessageLength))
    {
        pSend->pSender->ThisSendMessageLength = pInputBuffer->NextMessageBoundary;
        status = STATUS_SUCCESS;
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT | DBG_SEND), "PgmSetNextMessageBoundary",
            "Invalid parameter = <%d>\n", pInputBuffer->NextMessageBoundary);

        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (pSend, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetFECInfo(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to set the parameters
    for using FEC

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetFECInfo",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    status = STATUS_SUCCESS;
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT | DBG_SEND), "PgmSetFECInfo",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        status = STATUS_INVALID_HANDLE;
    }
    else if ((pAddress->ReceiverMCastAddr) ||                       // Cannot set FEC on Receiver!
             (!IsListEmpty (&pAddress->AssociatedConnections)))     // Cannot set options on active sender
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT | DBG_SEND), "PgmSetFECInfo",
            "Invalid pAddress type or state <%x>\n", pAddress);

        status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (status))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (status);
    }

    PgmLock (pAddress, OldIrq1);

    if (!(pInputBuffer->FECInfo.FECProActivePackets || pInputBuffer->FECInfo.fFECOnDemandParityEnabled) ||
        !(pInputBuffer->FECInfo.FECBlockSize && pInputBuffer->FECInfo.FECGroupSize) ||
         (pInputBuffer->FECInfo.FECBlockSize > FEC_MAX_BLOCK_SIZE) ||
         (pInputBuffer->FECInfo.FECBlockSize <= pInputBuffer->FECInfo.FECGroupSize) ||
         (!gFECLog2[pInputBuffer->FECInfo.FECGroupSize]))       // FECGroup size has to be power of 2
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT | DBG_SEND), "PgmSetFECInfo",
            "Invalid parameters, FECBlockSize= <%d>, FECGroupSize=<%d>\n",
                pInputBuffer->FECInfo.FECBlockSize, pInputBuffer->FECInfo.FECGroupSize);

        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = STATUS_SUCCESS;

        pAddress->FECBlockSize = pInputBuffer->FECInfo.FECBlockSize;
        pAddress->FECGroupSize = pInputBuffer->FECInfo.FECGroupSize;
        pAddress->FECOptions = 0;   // Init

        if (pInputBuffer->FECInfo.FECProActivePackets)
        {
            pAddress->FECProActivePackets = pInputBuffer->FECInfo.FECProActivePackets;
            pAddress->FECOptions |= PACKET_OPTION_SPECIFIC_FEC_PRO_BIT;
        }
        if (pInputBuffer->FECInfo.fFECOnDemandParityEnabled)
        {
            pAddress->FECOptions |= PACKET_OPTION_SPECIFIC_FEC_OND_BIT;
        }
    }

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryFecInfo(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Send Window advance rate

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmQueryFecInfo",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryFecInfo",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if ((pAddress->ReceiverMCastAddr) ||                            // Cannot query Fec on Receiver!
        (!IsListEmpty (&pAddress->AssociatedConnections)))          // Cannot query options on active sender
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryFecInfo",
            "Invalid Option for receiver, pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    pBuffer->FECInfo.FECBlockSize = pAddress->FECBlockSize;
    pBuffer->FECInfo.FECGroupSize = pAddress->FECGroupSize;
    pBuffer->FECInfo.FECProActivePackets = pAddress->FECProActivePackets;
    if (pAddress->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT)
    {
        pBuffer->FECInfo.fFECOnDemandParityEnabled = TRUE;
    }
    else
    {
        pBuffer->FECInfo.fFECOnDemandParityEnabled = FALSE;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetMCastTtl(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to set the Message length
    for the next set of messages (typically, 1 send is sent as 1 Message).

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmSetMCastTtl",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT | DBG_SEND), "PgmSetMCastTtl",
            "Invalid Handle pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                              // Cannot set MCast Ttl on Receiver!
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT | DBG_SEND), "PgmSetMCastTtl",
            "Invalid Options for Receiver, pAddress=<%x>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PgmLock (pAddress, OldIrq1);

    if ((pInputBuffer->MCastTtl) &&
        (pInputBuffer->MCastTtl <= MAX_MCAST_TTL))
    {
        pAddress->MCastPacketTtl = pInputBuffer->MCastTtl;
        status = STATUS_SUCCESS;
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT | DBG_SEND), "PgmSetMCastTtl",
            "Invalid parameter = <%d>\n", pInputBuffer->MCastTtl);

        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQuerySenderStats(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Sender-side statistics

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tSEND_SESSION       *pSend = (tSEND_SESSION *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmQuerySenderStats",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if ((!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND)) ||
        (!pSend->pSender) ||
        (!pSend->pAssociatedAddress))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQuerySenderStats",
            "Invalid Handle pSend=<%x>\n", pSend);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLock (pSend, OldIrq1);

    pBuffer->SenderStats.DataBytesSent = pSend->DataBytes;
    pBuffer->SenderStats.TotalBytesSent = pSend->TotalBytes;
    pBuffer->SenderStats.RateKBitsPerSecLast = pSend->RateKBitsPerSecLast;
    pBuffer->SenderStats.RateKBitsPerSecOverall = pSend->RateKBitsPerSecOverall;
    pBuffer->SenderStats.NaksReceived = pSend->pSender->NaksReceived;
    pBuffer->SenderStats.NaksReceivedTooLate = pSend->pSender->NaksReceivedTooLate;
    pBuffer->SenderStats.NumOutstandingNaks = pSend->pSender->NumOutstandingNaks;
    pBuffer->SenderStats.NumNaksAfterRData = pSend->pSender->NumNaksAfterRData;
    pBuffer->SenderStats.RepairPacketsSent = pSend->pSender->RepairPacketsSent;
    pBuffer->SenderStats.BufferSpaceAvailable = pSend->pSender->BufferSizeAvailable;
    pBuffer->SenderStats.TrailingEdgeSeqId = (SEQ_TYPE) pSend->pSender->TrailingEdgeSequenceNumber;
    pBuffer->SenderStats.LeadingEdgeSeqId = (SEQ_TYPE) pSend->pSender->LastODataSentSequenceNumber;

    PgmUnlock (pSend, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryReceiverStats(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Sender-side statistics

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tRECEIVE_SESSION    *pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "PgmQueryReceiverStats",
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if ((!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE)) ||
        (!pReceive->pReceiver) ||
        (!pReceive->pAssociatedAddress))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_ADDRESS | DBG_CONNECT), "PgmQueryReceiverStats",
            "Invalid Handle pReceive=<%x>\n", pReceive);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLock (pReceive, OldIrq1);

    pBuffer->ReceiverStats.NumODataPacketsReceived = pReceive->pReceiver->NumODataPacketsReceived;
    pBuffer->ReceiverStats.NumRDataPacketsReceived = pReceive->pReceiver->NumRDataPacketsReceived;
    pBuffer->ReceiverStats.NumDuplicateDataPackets = pReceive->pReceiver->NumDupPacketsOlderThanWindow +
                                                     pReceive->pReceiver->NumDupPacketsBuffered;

    pBuffer->ReceiverStats.DataBytesReceived = pReceive->DataBytes;
    pBuffer->ReceiverStats.TotalBytesReceived = pReceive->TotalBytes;
    pBuffer->ReceiverStats.RateKBitsPerSecLast = pReceive->RateKBitsPerSecLast;
    pBuffer->ReceiverStats.RateKBitsPerSecOverall = pReceive->RateKBitsPerSecOverall;

    pBuffer->ReceiverStats.TrailingEdgeSeqId = (SEQ_TYPE) pReceive->pReceiver->LastTrailingEdgeSeqNum;
    pBuffer->ReceiverStats.LeadingEdgeSeqId = (SEQ_TYPE) pReceive->pReceiver->FurthestKnownGroupSequenceNumber;
    pBuffer->ReceiverStats.AverageSequencesInWindow = pReceive->pReceiver->AverageSequencesInWindow;
    pBuffer->ReceiverStats.MinSequencesInWindow = pReceive->pReceiver->MinSequencesInWindow;
    pBuffer->ReceiverStats.MaxSequencesInWindow = pReceive->pReceiver->MaxSequencesInWindow;

    pBuffer->ReceiverStats.FirstNakSequenceNumber = pReceive->pReceiver->FirstNakSequenceNumber;
    pBuffer->ReceiverStats.NumPendingNaks = pReceive->pReceiver->NumPendingNaks;
    pBuffer->ReceiverStats.NumOutstandingNaks = pReceive->pReceiver->NumOutstandingNaks;
    pBuffer->ReceiverStats.NumDataPacketsBuffered = pReceive->pReceiver->TotalDataPacketsBuffered;
    pBuffer->ReceiverStats.TotalSelectiveNaksSent = pReceive->pReceiver->TotalSelectiveNaksSent;
    pBuffer->ReceiverStats.TotalParityNaksSent = pReceive->pReceiver->TotalParityNaksSent;

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\driver.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Driver.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for
    the PGM Transport and other routines that are specific to the
    NT implementation of a driver.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

// ULONG   PgmDebugFlags = DBG_ENABLE_DBGPRINT;
// ULONG   PgmDebugFlags = 0xffffffff;

#if DBG
enum eSEVERITY_LEVEL    PgmDebuggerSeverity = PGM_LOG_INFORM_STATUS;
#else
enum eSEVERITY_LEVEL    PgmDebuggerSeverity = PGM_LOG_DISABLED;
#endif  // DBG
ULONG                   PgmDebuggerPath = 0xffffffff;

enum eSEVERITY_LEVEL    PgmLogFileSeverity = PGM_LOG_DISABLED;
ULONG                   PgmLogFilePath = 0x0;

tPGM_STATIC_CONFIG      PgmStaticConfig;
tPGM_DYNAMIC_CONFIG     PgmDynamicConfig;
tPGM_REGISTRY_CONFIG    *pPgmRegistryConfig = NULL;

tPGM_DEVICE             *pgPgmDevice = NULL;
DEVICE_OBJECT           *pPgmDeviceObject = NULL;

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, PgmUnload)
#endif
//*******************  Pageable Routine Declarations ****************



//----------------------------------------------------------------------------
//
// Internal routines
//

FILE_FULL_EA_INFORMATION *
FindEA(
    IN  PFILE_FULL_EA_INFORMATION   StartEA,
    IN  CHAR                        *pTargetName,
    IN  USHORT                      TargetNameLength
    );

VOID
CompleteDispatchIrp(
    IN PIRP         pIrp,
    IN NTSTATUS     status
    );

//----------------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the PGM device driver.
    This routine creates the device object for the PGM
    device and does other driver initialization.

Arguments:

    IN  DriverObject    - Pointer to driver object created by the system.
    IN  RegistryPath    - Pgm driver's registry location

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS                status;

    PAGED_CODE();

    //---------------------------------------------------------------------------------------

    status = InitPgm (DriverObject, RegistryPath);
    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_DRIVER_ENTRY, "DriverEntry",
            "InitPgm returned <%x>\n", status);
        return (status);
    }

    //---------------------------------------------------------------------------------------

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = (PDRIVER_DISPATCH)PgmDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = (PDRIVER_DISPATCH)PgmDispatch;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = (PDRIVER_DISPATCH)PgmDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 = (PDRIVER_DISPATCH)PgmDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = (PDRIVER_DISPATCH)PgmDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = (PDRIVER_DISPATCH)PgmDispatch;
    DriverObject->DriverUnload                                  = PgmUnload;

    //---------------------------------------------------------------------------------------

    status = SetTdiHandlers ();
    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_DRIVER_ENTRY, "DriverEntry",
            "SetTdiHandlers returned <%x>\n", status);
        CleanupInit (E_CLEANUP_DEVICE);
        return (status);
    }

    //---------------------------------------------------------------------------------------

    //
    // Return to the caller.
    //
    PgmLog (PGM_LOG_INFORM_STATUS, DBG_DRIVER_ENTRY, "DriverEntry",
        "Succeeded! ...\n");

    return (status);
}

//----------------------------------------------------------------------------
NTSTATUS
PgmDispatch(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the PGM driver's primary dispatch function for all Irp requests.

Arguments:

    IN  pDeviceObject   - ptr to device object for target device
    IN  pIrp            - ptr to I/O request packet

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    tPGM_DEVICE         *pPgmDevice = pDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  pIrpSp;
    UCHAR               IrpFlags;
    UCHAR               IrpMajorFunction;
    UCHAR               IrpMinorFunction;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    IrpFlags = pIrpSp->Control;
    IrpMajorFunction = pIrpSp->MajorFunction;
    IrpMinorFunction = pIrpSp->MinorFunction;

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);

    ASSERT (pDeviceObject == pPgmDeviceObject);

    switch (IrpMajorFunction)
    {
        case IRP_MJ_CREATE:
        {
            status = PgmCreate (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case IRP_MJ_CLEANUP:
        {
            status = PgmCleanup (pPgmDevice, pIrp, pIrpSp);
            break;
        }
        case IRP_MJ_CLOSE:
        {
            status = PgmClose (pPgmDevice, pIrp, pIrpSp);
            break;
        }
        case IRP_MJ_DEVICE_CONTROL:
        {
            if (STATUS_SUCCESS != TdiMapUserRequest (pDeviceObject, pIrp, pIrpSp))
            {
                //
                // This is not a Tdi request!
                //
                status = PgmDispatchIoctls (pPgmDevice, pIrp, pIrpSp);   // To handle Ioctls
                break;
            }

            //
            // Fall through for Internal Device Control!
            //
        }

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
            status =  PgmDispatchInternalDeviceControl (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case IRP_MJ_PNP:
        {
            PgmLog (PGM_LOG_ERROR, DBG_DRIVER_ENTRY, "PgmDispatch",
                "[IRP_MJ_PNP:%x]:  pIrp=<%x>  Unsupported!\n", pIrpSp->MinorFunction, pIrp);
            break;
        }

        default:
        {
            PgmLog (PGM_LOG_ERROR, DBG_DRIVER_ENTRY, "PgmDispatch",
                "pIrp=<%x>,  Unsupported! [%x:%x]\n", pIrp, pIrpSp->MajorFunction, pIrpSp->MinorFunction);
            break;
        }
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "PgmDispatch",
        "pIrp=<%x>, status=<%x>, [%d-->%d]\n", pIrp, status, IrpMajorFunction, IrpMinorFunction);

    if (status != STATUS_PENDING)
    {
        // reset the pending returned bit, since we are NOT returning pending
        pIrpSp->Control = IrpFlags;
        CompleteDispatchIrp (pIrp, status);
    }

    return (status);
} // PgmDispatch


//----------------------------------------------------------------------------
VOID
CleanupInit(
    enum eCLEANUP_STAGE     CleanupStage
    )
/*++

Routine Description:

    This routine is called either at DriverEntry or DriverUnload
    to cleanup (or do partial cleanup) of items initialized at Init-time

Arguments:

    IN  CleanupStage    -- determines the stage to which we had initialized
                            settings

Return Value:

    NONE

--*/
{
    NTSTATUS                status;
    LIST_ENTRY              *pEntry;
    PGMLockHandle           OldIrq;
    PGM_WORKER_CONTEXT      *pWorkerContext;
    PPGM_WORKER_ROUTINE     pDelayedWorkerRoutine;
    tLOCAL_INTERFACE        *pLocalInterface = NULL;
    tADDRESS_ON_INTERFACE   *pLocalAddress = NULL;

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "CleanupInit",
        "CleanupStage=<%d>\n", CleanupStage);

    switch (CleanupStage)
    {
        case (E_CLEANUP_UNLOAD):
        {
            //
            // Ensure that there are no more worker threads to be cleaned up
            //
            //
            // See if there are any worker threads currently executing, and if so, wait for
            // them to complete
            //
            KeClearEvent (&PgmDynamicConfig.LastWorkerItemEvent);
            PgmLock (&PgmDynamicConfig, OldIrq);
            if (PgmDynamicConfig.NumWorkerThreadsQueued)
            {
                PgmUnlock (&PgmDynamicConfig, OldIrq);

                status = KeWaitForSingleObject(&PgmDynamicConfig.LastWorkerItemEvent,  // Object to wait on.
                                               Executive,            // Reason for waiting
                                               KernelMode,           // Processor mode
                                               FALSE,                // Alertable
                                               NULL);                // Timeout
                ASSERT (status == STATUS_SUCCESS);
                PgmLock (&PgmDynamicConfig, OldIrq);
            }

            ASSERT (!PgmDynamicConfig.NumWorkerThreadsQueued);

            //
            // Dequeue each of the requests in the Worker Queue and complete them
            //
            while (!IsListEmpty (&PgmDynamicConfig.WorkerQList))
            {
                pWorkerContext = CONTAINING_RECORD(PgmDynamicConfig.WorkerQList.Flink, PGM_WORKER_CONTEXT, PgmConfigLinkage);
                RemoveEntryList (&pWorkerContext->PgmConfigLinkage);
                PgmUnlock (&PgmDynamicConfig, OldIrq);

                pDelayedWorkerRoutine = pWorkerContext->WorkerRoutine;

                PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "CleanupInit",
                    "Completing Worker request <%x>\n", pDelayedWorkerRoutine);

                (*pDelayedWorkerRoutine) (pWorkerContext->Context1,
                                          pWorkerContext->Context2,
                                          pWorkerContext->Context3);
                PgmFreeMem ((PVOID) pWorkerContext);

                //
                // Acquire Lock again to check if we have completed all the requests
                //
                PgmLock (&PgmDynamicConfig, OldIrq);
            }

            PgmUnlock (&PgmDynamicConfig, OldIrq);
        }

        // no break -- Fall through!
        case (E_CLEANUP_PNP):
        {
            status = TdiDeregisterPnPHandlers (TdiClientHandle);

            while (!IsListEmpty (&PgmDynamicConfig.LocalInterfacesList))
            {
                pEntry = RemoveHeadList (&PgmDynamicConfig.LocalInterfacesList);
                pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
                while (!IsListEmpty (&pLocalInterface->Addresses))
                {
                    pEntry = RemoveHeadList (&pLocalInterface->Addresses);
                    pLocalAddress = CONTAINING_RECORD (pEntry, tADDRESS_ON_INTERFACE, Linkage);
                    PgmFreeMem (pLocalAddress);
                }
                PgmFreeMem (pLocalInterface);
            }
        }

        // no break -- Fall through!

        case (E_CLEANUP_DEVICE):
        {
            PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_CREATE);
        }

        // no break -- Fall through!

        case (E_CLEANUP_STRUCTURES):
        {
            // Nothing specific to cleanup
        }

        // no break -- Fall through!

        case (E_CLEANUP_REGISTRY_PARAMETERS):
        {
            if (pPgmRegistryConfig)
            {
                if (pPgmRegistryConfig->ucSenderFileLocation.Buffer)
                {
                    PgmFreeMem (pPgmRegistryConfig->ucSenderFileLocation.Buffer);
                    pPgmRegistryConfig->ucSenderFileLocation.Buffer = NULL;
                }

                PgmFreeMem (pPgmRegistryConfig);
                pPgmRegistryConfig = NULL;
            }
        }

        // no break -- Fall through!

        case (E_CLEANUP_DYNAMIC_CONFIG):
        {
            // Nothing specific to cleanup
        }

        // no break -- Fall through!

        case (E_CLEANUP_STATIC_CONFIG):
        {
            ExDeleteNPagedLookasideList(&PgmStaticConfig.DebugMessagesLookasideList);
            ExDeleteNPagedLookasideList(&PgmStaticConfig.TdiLookasideList);

            PgmFreeMem (PgmStaticConfig.RegistryPath.Buffer);
        }

        // no break -- Fall through!

        default:
        {
            break;
        }
    }
}


//----------------------------------------------------------------------------

VOID
PgmUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the Pgm driver's function for Unload requests

Arguments:

    IN  DriverObject - Pointer to driver object created by the system.

Return Value:

    None

--*/

{
    NTSTATUS                status;

    PAGED_CODE();

    PgmDynamicConfig.GlobalFlags |= PGM_CONFIG_FLAG_UNLOADING;

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_DRIVER_ENTRY, "PgmUnload",
        "Unloading ...\n");

    CleanupInit (E_CLEANUP_UNLOAD);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCreate(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )

/*++

Routine Description:

    Dispatch function for creating Pgm objects

Arguments:

    IN  pPgmDevice  - Pointer to the Pgm device extension for this request.
    IN  Irp         - Pointer to I/O request packet
    IN  IrpSp       - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS - Final status of the create request

--*/

{
    tCONTROL_CONTEXT            *pControlContext = NULL;
    FILE_FULL_EA_INFORMATION    *ea = (PFILE_FULL_EA_INFORMATION) pIrp->AssociatedIrp.SystemBuffer;
    FILE_FULL_EA_INFORMATION    *TargetEA;
    TRANSPORT_ADDRESS UNALIGNED *pTransportAddr;
    TA_ADDRESS                  *pAddress;
    NTSTATUS                    status;

    PAGED_CODE();

    //
    // See if this is a Control Channel open.
    //
    if (!ea)
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_DRIVER_ENTRY, "PGMCreate",
            "Opening control channel for file object %lx\n", pIrpSp->FileObject);

        if (pControlContext = PgmAllocMem (sizeof(tCONTROL_CONTEXT), PGM_TAG('0')))
        {
            PgmZeroMemory (pControlContext, sizeof (tCONTROL_CONTEXT));
            InitializeListHead (&pControlContext->Linkage);
            PgmInitLock (pControlContext, CONTROL_LOCK);
            pControlContext->Verify = PGM_VERIFY_CONTROL;
            PGM_REFERENCE_CONTROL (pControlContext, REF_CONTROL_CREATE, TRUE);

            pIrpSp->FileObject->FsContext = pControlContext;
            pIrpSp->FileObject->FsContext2 = (PVOID) TDI_CONTROL_CHANNEL_FILE;

            status = STATUS_SUCCESS;
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return (status);
    }

    //
    // See if this is a Connection Object open.
    //
    if (TargetEA = FindEA (ea, TdiConnectionContext, TDI_CONNECTION_CONTEXT_LENGTH))
    {
        status = PgmCreateConnection (pPgmDevice, pIrp, pIrpSp, TargetEA);

        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, (DBG_DRIVER_ENTRY | DBG_CONNECT), "PGMCreate",
            "Open Connection, pIrp=<%x>, status=<%x>\n", pIrp, status);
    }
    //
    // See if this is an Address Object open.
    //
    else if (TargetEA = FindEA (ea, TdiTransportAddress, TDI_TRANSPORT_ADDRESS_LENGTH))
    {
        status = PgmCreateAddress (pPgmDevice, pIrp, pIrpSp, TargetEA);

        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, (DBG_DRIVER_ENTRY | DBG_ADDRESS), "PGMCreate",
            "Open Address, pIrp=<%x>, status=<%x>\n", pIrp, status);
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_DRIVER_ENTRY, "PGMCreate",
            "Unsupported EA!\n");

        status =  STATUS_INVALID_EA_NAME;
    }

    return (status);
}



//----------------------------------------------------------------------------

NTSTATUS
PgmCleanup(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    Dispatch function for cleaning-up Pgm objects

Arguments:

    IN  pPgmDevice  - Pointer to the Pgm device extension for this request.
    IN  Irp         - Pointer to I/O request packet
    IN  IrpSp       - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS - Final status of the cleanup request

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PVOID               *pContext = pIrpSp->FileObject->FsContext;

    PAGED_CODE();

    switch (PtrToUlong (pIrpSp->FileObject->FsContext2))
    {
        case TDI_TRANSPORT_ADDRESS_FILE:
        {
            status = PgmCleanupAddress ((tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext, pIrp);

            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, (DBG_DRIVER_ENTRY | DBG_ADDRESS), "PGMCleanup",
                "pConnect=<%x>, pIrp=<%x>, status=<%x>\n", pContext, pIrp, status);
            break;
        }

        case TDI_CONNECTION_FILE:
        {
            status = PgmCleanupConnection ((tCOMMON_SESSION_CONTEXT *) pIrpSp->FileObject->FsContext, pIrp);

            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, (DBG_DRIVER_ENTRY | DBG_CONNECT), "PGMCleanup",
                "pConnect=<%x>, pIrp=<%x>, status=<%x>\n", pContext, pIrp, status);
            break;
        }

        case TDI_CONTROL_CHANNEL_FILE:
        {
            //
            // Nothing to Cleanup here!
            //
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_DRIVER_ENTRY, "PGMCleanup",
                "pControl=<%x>, pIrp=<%x>, status=<%x>\n", pContext, pIrp, status);
            break;
        }

        default:
        {
            PgmLog (PGM_LOG_ERROR, DBG_DRIVER_ENTRY, "PGMCleanup",
                "pIrp=<%x>, Context=[%x:%d] ...\n",
                    pIrp, pIrpSp->FileObject->FsContext, pIrpSp->FileObject->FsContext2);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    return (status);
}



//----------------------------------------------------------------------------

NTSTATUS
PgmClose(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine completes the cleanup, closing handles, free'ing all
    memory associated with the object

Arguments:

    IN  pPgmDevice  - Pointer to the Pgm device extension for this request.
    IN  Irp         - Pointer to I/O request packet
    IN  IrpSp       - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS - Final status of the close request

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    tCONTROL_CONTEXT    *pControlContext = pIrpSp->FileObject->FsContext;

    PAGED_CODE();

    switch (PtrToUlong (pIrpSp->FileObject->FsContext2))
    {
        case TDI_TRANSPORT_ADDRESS_FILE:
        {
            status = PgmCloseAddress (pIrp, pIrpSp);

            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, (DBG_DRIVER_ENTRY | DBG_ADDRESS), "PgmClose",
                "pAddress=<%x>, pIrp=<%x>, status=<%x>\n", pControlContext, pIrp, status);
            break;
        }

        case TDI_CONNECTION_FILE:
        {
            status = PgmCloseConnection (pIrp, pIrpSp);

            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, (DBG_DRIVER_ENTRY | DBG_CONNECT), "PgmClose",
                "pConnect=<%x>, pIrp=<%x>, status=<%x>\n", pControlContext, pIrp, status);
            break;
        }

        case TDI_CONTROL_CHANNEL_FILE:
        {
            //
            // There is nothing special to do here so just dereference!
            //
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_DRIVER_ENTRY, "PgmClose",
                "pControl=<%x>, pIrp=<%x>, status=<%x>\n", pIrpSp->FileObject->FsContext, pIrp, status);

            PGM_DEREFERENCE_CONTROL (pControlContext, REF_CONTROL_CREATE);
            break;
        }

        default:
        {
            PgmLog (PGM_LOG_ERROR, DBG_DRIVER_ENTRY, "PgmClose",
                "pIrp=<%x>, Context=[%x:%d] ...\n",
                    pIrp, pIrpSp->FileObject->FsContext, pIrpSp->FileObject->FsContext2);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmDispatchInternalDeviceControl(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine primarily handles Tdi requests since we are a Tdi component

Arguments:

    IN  pPgmDevice  - Pointer to the Pgm device extension for this request.
    IN  Irp         - Pointer to I/O request packet
    IN  IrpSp       - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "PgmDispatchInternalDeviceControl",
        "[%d] Context=<%x> ...\n", pIrpSp->MinorFunction, pIrpSp->FileObject->FsContext);

    switch (pIrpSp->MinorFunction)
    {
        case TDI_QUERY_INFORMATION:
        {
            Status = PgmQueryInformation (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_SET_EVENT_HANDLER:
        {
            Status = PgmSetEventHandler (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_ASSOCIATE_ADDRESS:
        {
            Status = PgmAssociateAddress (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_DISASSOCIATE_ADDRESS:
        {
            Status = PgmDisassociateAddress (pIrp, pIrpSp);
            break;
        }

        case TDI_CONNECT:
        {
            Status = PgmConnect (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_DISCONNECT:
        {
            Status = PgmDisconnect (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_SEND:
        {
            Status = PgmSendRequestFromClient (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_RECEIVE:
        {
            Status = PgmReceive (pPgmDevice, pIrp, pIrpSp);
            break;
        }

/*
        case TDI_SEND_DATAGRAM:
        {
            Status = PgmSendDatagram (pPgmDevice, pIrp, pIrpSp);
            break;
        }
*/

        default:
        {
            PgmLog (PGM_LOG_ERROR, DBG_DRIVER_ENTRY, "PgmDispatchInternalDeviceControl",
                "[%x]:  Context=<%x> ...\n", pIrpSp->MinorFunction, pIrpSp->FileObject->FsContext);

            return (STATUS_UNSUCCESSFUL);
        }
    }

    return (Status);
}



//----------------------------------------------------------------------------

NTSTATUS
PgmDispatchIoctls(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine handles private Ioctls into Pgm.  These Ioctls are
    to be called only by the Pgm Winsock helper (WshPgm.dll)

Arguments:

    IN  pPgmDevice  - Pointer to the Pgm device extension for this request.
    IN  Irp         - Pointer to I/O request packet
    IN  IrpSp       - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    NTSTATUS    status;

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_PGM_WSH_SET_WINDOW_SIZE_RATE:
        {
            status = PgmSetWindowSizeAndSendRate (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_WINDOW_SIZE_RATE:
        {
            status = PgmQueryWindowSizeAndSendRate (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_ADVANCE_WINDOW_RATE:
        {
            status = PgmSetWindowAdvanceRate (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_ADVANCE_WINDOW_RATE:
        {
            status = PgmQueryWindowAdvanceRate (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_LATE_JOINER_PERCENTAGE:
        {
            status = PgmSetLateJoinerPercentage (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_LATE_JOINER_PERCENTAGE:
        {
            status = PgmQueryLateJoinerPercentage (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_WINDOW_ADVANCE_METHOD:
        {
            status = PgmSetWindowAdvanceMethod (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_WINDOW_ADVANCE_METHOD:
        {
            status = PgmQueryWindowAdvanceMethod (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_NEXT_MESSAGE_BOUNDARY:
        {
            status = PgmSetNextMessageBoundary (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_SEND_IF:
        {
            status = PgmSetMCastOutIf (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_ADD_RECEIVE_IF:
        case IOCTL_PGM_WSH_JOIN_MCAST_LEAF:
        {
            status = PgmAddMCastReceiveIf (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_DEL_RECEIVE_IF:
        {
            status = PgmDelMCastReceiveIf (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_RCV_BUFF_LEN:
        {
            status = PgmSetRcvBufferLength (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_SENDER_STATS:
        {
            status = PgmQuerySenderStats (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_RECEIVER_STATS:
        {
            status = PgmQueryReceiverStats (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_USE_FEC:
        {
            status = PgmSetFECInfo (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_FEC_INFO:
        {
            status = PgmQueryFecInfo (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_MCAST_TTL:
        {
            status = PgmSetMCastTtl (pIrp, pIrpSp);
            break;
        }

        default:
        {
            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "PgmDispatchIoctls",
                "WARNING:  Invalid Ioctl=[%x]:  Context=<%x> ...\n",
                    pIrpSp->Parameters.DeviceIoControl.IoControlCode,
                    pIrpSp->FileObject->FsContext);

            return (STATUS_NOT_IMPLEMENTED);
        }
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "PgmDispatchIoctls",
        "[%d]: Context=<%x>, status=<%x>\n",
            pIrpSp->Parameters.DeviceIoControl.IoControlCode,
            pIrpSp->FileObject->FsContext, status);

    return (status);
}




//----------------------------------------------------------------------------
//
// Utility functions
//
//----------------------------------------------------------------------------

FILE_FULL_EA_INFORMATION *
FindEA(
    IN  PFILE_FULL_EA_INFORMATION   StartEA,
    IN  CHAR                        *pTargetName,
    IN  USHORT                      TargetNameLength
    )
/*++

Routine Description:

    Parses and extended attribute list for a given target attribute.

Arguments:

    IN  StartEA           - the first extended attribute in the list.
    IN  pTargetName       - the name of the target attribute.
    IN  TargetNameLength  - the length of the name of the target attribute.

Return Value:

    A pointer to the requested attribute or NULL if the target wasn't found.

--*/

{
    USHORT                      i;
    BOOLEAN                     found;
    FILE_FULL_EA_INFORMATION    *CurrentEA;

    for (CurrentEA = StartEA;
         CurrentEA;
         CurrentEA =  (PFILE_FULL_EA_INFORMATION) ((PUCHAR)CurrentEA + CurrentEA->NextEntryOffset))
    {
        if (strncmp (CurrentEA->EaName, pTargetName, CurrentEA->EaNameLength) == 0)
        {
            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "FindEA",
                "Found EA, Target=<%s>\n", pTargetName);

           return (CurrentEA);
        }

        if (CurrentEA->NextEntryOffset == 0)
        {
            break;
        }
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "FindEA",
        "FAILed to find EA, Target=<%s>\n", pTargetName);

    return (NULL);
}


//----------------------------------------------------------------------------
VOID
PgmIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength
    )
/*++

Routine Description:

    This routine

Arguments:

    IN  pIrp        -- Pointer to I/O request packet
    IN  Status      -- the final status of the request
    IN  SentLength  -- the value to be set in the Information field

Return Value:

    NONE

--*/
{
    pIrp->IoStatus.Status = Status;

    // use -1 as a flag to mean do not adjust the sent length since it is
    // already set
    if (SentLength != -1)
    {
        pIrp->IoStatus.Information = SentLength;
    }

    // set the Irps cancel routine to null or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP
    //
    // refer to IoCancelIrp()  ..\ntos\io\iosubs.c
    //
    PgmCancelCancelRoutine (pIrp);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "PgmIoComplete",
        "pIrp=<%x>, Status=<%x>, SentLength=<%d>\n", pIrp, Status, SentLength);

    IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
}


//----------------------------------------------------------------------------


VOID
CompleteDispatchIrp(
    IN PIRP         pIrp,
    IN NTSTATUS     status
    )

/*++

Routine Description:

    This function completes an IRP, and arranges for return parameters,
    if any, to be copied.

    Although somewhat a misnomer, this function is named after a similar
    function in the SpiderSTREAMS emulator.

Arguments:

    IN  pIrp        -  pointer to the IRP to complete
    IN  status      -  completion status of the IRP

Return Value:

    NONE

--*/

{
    CCHAR priboost;

    //
    // pIrp->IoStatus.Information is meaningful only for STATUS_SUCCESS
    //

    // set the Irps cancel routine to null or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP
    //
    // refer to IoCancelIrp()  ..\ntos\io\iosubs.c
    //
    PgmCancelCancelRoutine (pIrp);

    pIrp->IoStatus.Status = status;

    priboost = (CCHAR) ((status == STATUS_SUCCESS) ? IO_NETWORK_INCREMENT : IO_NO_INCREMENT);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_DRIVER_ENTRY, "CompleteDispatchIrp",
        "Completing pIrp=<%x>, status=<%x>\n", pIrp, status);

    IoCompleteRequest (pIrp, priboost);

    return;

}


//----------------------------------------------------------------------------

NTSTATUS
PgmCheckSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  BOOLEAN         fLocked
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS        status;
    PGMLockHandle   CancelIrql;

    //
    // Check if the irp was cancelled yet and if not, then set the
    // irp cancel routine.
    //
    if (!fLocked)
    {
        IoAcquireCancelSpinLock (&CancelIrql);
    }

    if (pIrp->Cancel)
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        status = STATUS_CANCELLED;
    }
    else
    {
        // setup the cancel routine
        IoMarkIrpPending (pIrp);
        IoSetCancelRoutine (pIrp, CancelRoutine);
        status = STATUS_SUCCESS;
    }

    if (!fLocked)
    {
        IoReleaseCancelSpinLock (CancelIrql);
    }

    return(status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCancelCancelRoutine(
    IN  PIRP            pIrp
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp to NULL

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS        status = STATUS_SUCCESS;
    PGMLockHandle   CancelIrql;

    //
    // Check if the irp was cancelled yet and if not, then set the
    // irp cancel routine.
    //
    IoAcquireCancelSpinLock (&CancelIrql);
    if (pIrp->Cancel)
    {
        status = STATUS_CANCELLED;
    }

    IoSetCancelRoutine (pIrp, NULL);
    IoReleaseCancelSpinLock (CancelIrql);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\fileio.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    FileIo.c

Abstract:

    This module implements various FileSystem routines used by
    the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
BuildPgmDataFileName(
    IN  tSEND_SESSION   *pSend
    )
/*++

Routine Description:

    This routine build the string for the file name used for buffering
    data packets.

Arguments:

    IN  pSend   -- the Send object

Return Value:

    NONE    -- since we don't expect any error

--*/
{
    UNICODE_STRING      ucPortNumber;
    WCHAR               wcPortNumber[10];
    USHORT              MaxFileLength;
    ULONG               RandomNumber;

    PAGED_CODE();

    if (pPgmRegistryConfig->Flags & PGM_REGISTRY_SENDER_FILE_SPECIFIED)
    {
        MaxFileLength = pPgmRegistryConfig->ucSenderFileLocation.Length / sizeof(WCHAR);
    }
    else
    {
        MaxFileLength = sizeof (WS_DEFAULT_SENDER_FILE_LOCATION) /  sizeof (WCHAR);
    }

    //
    // The file name is composed of the following:
    // "\\T" + 2DigitRandom# + UptoMAX_USHORTPort# + ".PGM" + "\0"
    //
    MaxFileLength += 2 + 2 + 5 + 4 + 1;

    if (!(pSend->pSender->DataFileName.Buffer = PgmAllocMem ((sizeof (WCHAR) * MaxFileLength), PGM_TAG('2'))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_FILEIO, "BuildPgmDataFileName",
            "STATUS_INSUFFICIENT_RESOURCES allocating <%d> bytes\n", MaxFileLength);

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    pSend->pSender->DataFileName.MaximumLength = sizeof (WCHAR) * MaxFileLength;
    pSend->pSender->DataFileName.Length = 0;

    //
    // First, set the root directory
    //
    if (pPgmRegistryConfig->Flags & PGM_REGISTRY_SENDER_FILE_SPECIFIED)
    {
        RtlAppendUnicodeToString (&pSend->pSender->DataFileName, pPgmRegistryConfig->ucSenderFileLocation.Buffer);
    }
    else
    {
        RtlAppendUnicodeToString (&pSend->pSender->DataFileName, WS_DEFAULT_SENDER_FILE_LOCATION);
    }

    RtlAppendUnicodeToString (&pSend->pSender->DataFileName, L"\\T");

    //
    // Now, Append a random 2 digit value
    //
    ucPortNumber.MaximumLength = sizeof (wcPortNumber);
    ucPortNumber.Buffer = wcPortNumber;
    RandomNumber = GetRandomInteger (0, 99);
    if (RandomNumber < 10)
    {
        RtlAppendUnicodeToString (&pSend->pSender->DataFileName, L"0");
    }
    RtlIntegerToUnicodeString (RandomNumber, 10, &ucPortNumber);
    RtlAppendUnicodeStringToString (&pSend->pSender->DataFileName, &ucPortNumber);

    //
    // Append the Port#
    //
    RtlIntegerToUnicodeString ((ULONG) pSend->TSIPort, 10, &ucPortNumber);
    RtlAppendUnicodeStringToString (&pSend->pSender->DataFileName, &ucPortNumber);

    //
    // Now, add the file name extension for id
    //
    RtlAppendUnicodeToString (&pSend->pSender->DataFileName, L".PGM");

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCreateDataFileAndMapSection(
    IN  tSEND_SESSION   *pSend
    )
/*++

Routine Description:

    This routine creates the file and creates a section mapping for it.
    This file is used for buffering the data packets on behalf of the sender

Arguments:

    IN  pSend   -- the Send object

Return Value:

    NTSTATUS - Final status of the create operation

--*/
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    LARGE_INTEGER               lgMaxDataFileSize;
    NTSTATUS                    Status;
    ULONGLONG                   Size, BlockSize, PacketsInWindow;

    ULONG                       DesiredAccess;
    ULONG                       FileAttributes, AllocationAttributes;
    ULONG                       ShareAccess;
    ULONG                       CreateDisposition;
    ULONG                       CreateOptions;
    ULONG                       Protection;
    SIZE_T                      ViewSize;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached;

    PAGED_CODE();

    //
    // Make sure we are currently attached to the Application process
    //
    PgmAttachToProcessForVMAccess (pSend, &ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);

    //
    // First build the File name string
    //
    Status = BuildPgmDataFileName (pSend);
    if (!NT_SUCCESS (Status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_FILEIO, "PgmCreateDataFileAndMapSection",
            "BuildPgmDataFileName returned <%x>\n", Status);

        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);
        return (Status);
    }


    //
    // Compute the size of the Data file required to hold 2 * Window size
    // Also make it a multiple of the MTU and the FECGroupSize (if applicable)
    //
    PacketsInWindow = pSend->pAssociatedAddress->WindowSizeInBytes / pSend->pAssociatedAddress->OutIfMTU;
    PacketsInWindow += PacketsInWindow + pSend->FECGroupSize - 1;
    if (PacketsInWindow > SENDER_MAX_WINDOW_SIZE_PACKETS)
    {
        PacketsInWindow = SENDER_MAX_WINDOW_SIZE_PACKETS;
        if (pSend->pAssociatedAddress->WindowSizeInBytes > ((PacketsInWindow >> 1) *
                                                            pSend->pAssociatedAddress->OutIfMTU))
        {
            pSend->pAssociatedAddress->WindowSizeInBytes = (PacketsInWindow >> 1) * pSend->pAssociatedAddress->OutIfMTU;
            pSend->pAssociatedAddress->WindowSizeInMSecs = (BITS_PER_BYTE *
                                                            pSend->pAssociatedAddress->WindowSizeInBytes) /
                                                           pSend->pAssociatedAddress->RateKbitsPerSec;
        }
    }

    BlockSize = pSend->FECGroupSize * pSend->pSender->PacketBufferSize;
    Size = PacketsInWindow * pSend->pSender->PacketBufferSize;
    Size = (Size / BlockSize) * BlockSize; 
    pSend->pSender->MaxDataFileSize = Size;
    pSend->pSender->MaxPacketsInBuffer = Size / pSend->pSender->PacketBufferSize;
    lgMaxDataFileSize.QuadPart = Size;

    PgmZeroMemory (&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes (&ObjectAttributes,
                                &pSend->pSender->DataFileName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);


    //
    // We need to open the data file. This file contains data
    // and will be mapped into memory. Read and Write access 
    // are requested.
    // 

    DesiredAccess = FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |
                    FILE_GENERIC_READ | FILE_GENERIC_WRITE;
    // Using the FILE_ATTRIBUTE_TEMPORARY flag:
    // you let the system know that the file is likely to be short lived.
    // The temporary file is created as a normal file. The system needs to do
    // a minimal amount of lazy writes to the file system to keep the disk
    // structures (directories and so forth) consistent. This gives the
    // appearance that the file has been written to the disk. However, unless
    // the Memory Manager detects an inadequate supply of free pages and
    // starts writing modified pages to the disk, the Cache Manager's Lazy
    // Writer may never write the data pages of this file to the disk.
    // If the system has enough memory, the pages may remain in memory for
    // any arbitrary amount of time. Because temporary files are generally
    // short lived, there is a good chance the system will never write the pages to the disk. 
    FileAttributes = FILE_ATTRIBUTE_TEMPORARY;

    ShareAccess = 0;    // Gives the caller exclusive access to the open file
    CreateDisposition = FILE_CREATE;    // If the file already exists, fail the request and do not create or
                                        // open the given file. If it does not, create the given file.

    // Delete the file when the last handle to it is is passed to ZwClose.
    CreateOptions = FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_DELETE_ON_CLOSE;

    PgmZeroMemory (&IoStatusBlock, sizeof(IO_STATUS_BLOCK));
    Status = ZwCreateFile (&pSend->pSender->FileHandle,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           &lgMaxDataFileSize,              // AllocationSize
                           FileAttributes,
                           ShareAccess,
                           CreateDisposition,
                           CreateOptions,
                           NULL,                            // EaBuffer
                           0);                              // EaLength

    if (!NT_SUCCESS (Status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_FILEIO, "PgmCreateDataFileAndMapSection",
            "ZwCreateFile for <%wZ> returned <%x>\n", &pSend->pSender->DataFileName, Status);

        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);
        pSend->pSender->FileHandle = NULL;
        return (Status);
    }

    //
    // Now we have a handle to our open test file. We now create a section
    // object with this handle.
    //
    DesiredAccess              = STANDARD_RIGHTS_REQUIRED | 
                                 SECTION_QUERY            | 
                                 SECTION_MAP_READ         |
                                 SECTION_MAP_WRITE;
    Protection                 = PAGE_READWRITE;
    AllocationAttributes       = SEC_COMMIT;

    PgmZeroMemory (&ObjectAttributes, sizeof (OBJECT_ATTRIBUTES));
    InitializeObjectAttributes (&ObjectAttributes,
                                NULL,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    Status = ZwCreateSection (&pSend->pSender->SectionHandle,
                              DesiredAccess,
                              &ObjectAttributes,    // NULL ?
                              &lgMaxDataFileSize,
                              Protection,
                              AllocationAttributes,
                              pSend->pSender->FileHandle);

    if (!NT_SUCCESS (Status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_FILEIO, "PgmCreateDataFileAndMapSection",
            "ZwCreateSection for <%wZ> returned <%x>\n", &pSend->pSender->DataFileName, Status);

        ZwClose (pSend->pSender->FileHandle);
        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);
        return (Status);
    }

    //
    // Reference the section object, if a view is mapped to the section
    // object, the object is not dereferenced as the virtual address
    // descriptor contains a pointer to the section object.
    //

    Status = ObReferenceObjectByHandle (pSend->pSender->SectionHandle,
                                        0,
                                        0,
                                        KernelMode,
                                        &pSend->pSender->pSectionObject,
                                        NULL );

    if (!NT_SUCCESS (Status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_FILEIO, "PgmCreateDataFileAndMapSection",
            "ObReferenceObjectByHandle for SectionHandle=<%x> returned <%x>\n",
                pSend->pSender->SectionHandle, Status);

        ZwClose (pSend->pSender->SectionHandle);
        ZwClose (pSend->pSender->FileHandle);
        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);
        return (Status);
    }

    //
    // Our section object has been created and linked to the file
    // object that was previous opened. Now we map a view on
    // this section.
    //
    ViewSize                   = 0; 
    Protection                 = PAGE_READWRITE;
    Status = ZwMapViewOfSection (pSend->pSender->SectionHandle,
                                 NtCurrentProcess(),
                                 &pSend->pSender->SendDataBufferMapping,
                                 0L,                                // ZeroBits
                                 0L,                                // CommitSize (initially committed region)
                                 NULL,                              // &SectionOffset
                                 &ViewSize,
                                 ViewUnmap,                         // InheritDisposition: for child processes
                                 0L,                                // AllocationType
                                 Protection);

    if (!NT_SUCCESS (Status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_FILEIO, "PgmCreateDataFileAndMapSection",
            "ZwMapViewOfSection for <%wZ> returned <%x>\n", &pSend->pSender->DataFileName, Status);

        ObDereferenceObject (pSend->pSender->pSectionObject);
        pSend->pSender->pSectionObject = NULL;

        ZwClose (pSend->pSender->SectionHandle);
        pSend->pSender->SectionHandle = NULL;
        ZwClose (pSend->pSender->FileHandle);
        pSend->pSender->FileHandle = NULL;
        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);
        return (Status);
    }

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_FILEIO, "PgmCreateDataFileAndMapSection",
        "Mapped <%wZ> to address<%x>, Filelength=<%d>\n",
            &pSend->pSender->DataFileName, pSend->pSender->SendDataBufferMapping, Size);

    pSend->pSender->BufferSizeAvailable = pSend->pSender->MaxDataFileSize;
    pSend->pSender->LeadingWindowOffset = pSend->pSender->TrailingWindowOffset = 0;

    //
    // Now, reference the process
    //
    ObReferenceObject (pSend->Process);
    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmUnmapAndCloseDataFile(
    IN  tSEND_SESSION   *pSend
    )
/*++

Routine Description:

    This routine cleansup the file mapping and closes the file
    handles.  The file should automatically get deleted on closing
    the handle since we used the FILE_DELETE_ON_CLOSE option while
    creating the file.

Arguments:

    IN  pSend   -- the Send object

Return Value:

    NTSTATUS - Final status of the operation (STATUS_SUCCESS)

--*/
{
    NTSTATUS    Status;
    KAPC_STATE  ApcState;
    BOOLEAN     fAttached;

    PgmAttachToProcessForVMAccess (pSend, &ApcState, &fAttached, REF_PROCESS_ATTACH_CLOSE_DATA_FILE);
    Status = ZwUnmapViewOfSection (NtCurrentProcess(), (PVOID) pSend->pSender->SendDataBufferMapping);
    ASSERT (NT_SUCCESS (Status));

    Status = ObDereferenceObject (pSend->pSender->pSectionObject);
    ASSERT (NT_SUCCESS (Status));
    pSend->pSender->pSectionObject = NULL;

    Status = ZwClose (pSend->pSender->SectionHandle);
    ASSERT (NT_SUCCESS (Status));
    pSend->pSender->SectionHandle = NULL;

    Status = ZwClose (pSend->pSender->FileHandle);
    ASSERT (NT_SUCCESS (Status));

    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CLOSE_DATA_FILE);
    ObDereferenceObject (pSend->Process);   // Since we had referenced it when the file was created

    pSend->pSender->SendDataBufferMapping = NULL;
    pSend->pSender->pSectionObject = NULL;
    pSend->pSender->SectionHandle = NULL;
    pSend->pSender->FileHandle = NULL;

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_SEND, "PgmUnmapAndCloseDataFile",
        "pSend = <%x>\n", pSend);

    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\precomp.h ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompilation header file.

Author:

    Mohammad Shabbir Alam (MAlam) 3-30-2000

Revision History:

--*/

//
// These are needed for CTE
//

#pragma once

#if DBG
#define DEBUG 1
#endif

#define NT 1

#pragma warning( disable : 4103 )

#include <ntosp.h>
#include <zwapi.h>

#include <ndis.h>
#include <tdikrnl.h>
#include <cxport.h>

#include <tdi.h>
#include <RmCommon.h>

#include <Types.h>
#include <Macroes.h>
#include <DrvProcs.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\pnp.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    PnP.c

Abstract:

    This module contains the various PnP handlers

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

#include <ipinfo.h>     // for IPInterfaceInfo
#include "ntddip.h"     // Needed for IP_INTERFACE_INFO
#include <tcpinfo.h>    // for AO_OPTION_xxx, TCPSocketOption

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SetTdiHandlers)
#endif
//*******************  Pageable Routine Declarations ****************


HANDLE      TdiClientHandle     = NULL;

//----------------------------------------------------------------------------
BOOLEAN
SrcIsUs(
    tIPADDRESS  IpAddress
    )
/*++

Routine Description:

    This routine determines if the IP address passed in is a
    local address

Arguments:

    IN  IpAddress   -- IpAddress to verify

Return Value:

    TRUE if IpAddress is local, FALSE otherwise

--*/
{
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pEntry2;
    PGMLockHandle           OldIrq;
    tLOCAL_INTERFACE        *pLocalInterface;
    tADDRESS_ON_INTERFACE   *pLocalAddress;

    PgmLock (&PgmDynamicConfig, OldIrq);

    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        pEntry2 = &pLocalInterface->Addresses;
        while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);
            if (pLocalAddress->IpAddress == IpAddress)
            {
                PgmUnlock (&PgmDynamicConfig, OldIrq);
                return (TRUE);
            }
        }
    }
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    return (FALSE);
}


//----------------------------------------------------------------------------

NTSTATUS
GetIpInterfaceContextFromAddress(
    IN  tIPADDRESS      IpAddr,
    OUT ULONG           *pIPInterfaceContext
    )
/*++

Routine Description:

    Given an IP address, this routine determines will return the
    Ip interface context that address is registered on

Arguments:

    IN  IpAddress           -- IpAddress
    OUT IpInterfaceContext  -- IpInterfaceContext for the IP address passed

Return Value:

    STATUS_SUCCESS if IpAddress was matched to interface,
    STATUS_UNSUCCESSFUL otherwise

    The DynamicConfig lock is held on entry and exit from this routine
--*/
{
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pEntry2;
    tLOCAL_INTERFACE        *pLocalInterface;
    tADDRESS_ON_INTERFACE   *pLocalAddress;

    ASSERT (IpAddr);

    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        pEntry2 = &pLocalInterface->Addresses;
        while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);
            if (pLocalAddress->IpAddress == IpAddr)
            {
                *pIPInterfaceContext = pLocalInterface->IpInterfaceContext;
                return (STATUS_SUCCESS);
            }
        }
    }

    return (STATUS_UNSUCCESSFUL);
}


//----------------------------------------------------------------------------

NTSTATUS
GetIpInterfaceContextFromDeviceName(
    IN  tIPADDRESS      NetIpAddr,
    IN  PUNICODE_STRING pucBindString,
    OUT ULONG           *pIPInterfaceContext,
    IN  ULONG           BufferLength,
    OUT UCHAR           *pBuffer,
    IN  BOOLEAN         fGetInterfaceInfo
    )
/*++

Routine Description:

    Given a Unicode device name string, this routine will query Ip
    and return the IpInterfaceContext for that device

Arguments:

    IN  NetIpAddr           -- IpAddress on Device
    IN  pucBindString       -- Pointer to unicode device name string
    OUT IpInterfaceContext  -- IpInterfaceContext for the device name
    IN  BufferLength        -- Length of Output buffer passed
    OUT pBuffer             -- Output buffer passed for Interface properties
    IN  fGetInterfaceInfo   -- Whether to return Interface properties or not

Return Value:

    STATUS_SUCCESS if IpInterfaceContext was found, and properties
    successfully queried, STATUS_UNSUCCESSFUL otherwise

--*/
{
    LONG                i;
    NTSTATUS            status;
    PVOID               *pIPInfo;
    PIP_INTERFACE_INFO  pIPIfInfo;
    UNICODE_STRING      ucDeviceName;
    ULONG               BufferLen = 2 * sizeof(IP_ADAPTER_INDEX_MAP);   // assume

    status = PgmProcessIPRequest (IOCTL_IP_INTERFACE_INFO,
                                  NULL,         // No Input buffer
                                  0,
                                  &pIPIfInfo,
                                  &BufferLen);

    if (!NT_SUCCESS(status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_PNP, "GetInterfaceContext",
            "PgmProcessIPRequest returned status=<%x> for IOCTL_IP_INTERFACE_INFO, pDevice=<%wZ>!\n",
                status, pucBindString);

        return (status);
    }

    status = STATUS_UNSUCCESSFUL;
    for (i=0; i < pIPIfInfo->NumAdapters; i++)
    {
        ucDeviceName.Buffer = pIPIfInfo->Adapter[i].Name;
        ucDeviceName.Length = sizeof (WCHAR) * wcslen (pIPIfInfo->Adapter[i].Name);
        ucDeviceName.MaximumLength = ucDeviceName.Length + sizeof (WCHAR);

        PgmLog (PGM_LOG_INFORM_PATH, DBG_PNP, "GetInterfaceContext",
            "[%d/%d]\t<%wZ>\n",
                i+1, pIPIfInfo->NumAdapters, &ucDeviceName);

        if (RtlCompareUnicodeString (&ucDeviceName, pucBindString, TRUE) == 0)
        {
            *pIPInterfaceContext = pIPIfInfo->Adapter[i].Index;
            status = STATUS_SUCCESS;
            break;
        }
    }
    PgmFreeMem (pIPIfInfo);

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_PNP, "GetInterfaceContext",
            "Could not find IPInterfaceContext for Device=<%wZ>\n", pucBindString);

        return (status);
    }

    status = PgmQueryTcpInfo (pgPgmDevice->hControl,
                              IP_INTFC_INFO_ID,
                              &NetIpAddr,
                              sizeof (tIPADDRESS),
                              pBuffer,
                              BufferLength);

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_PNP, "GetInterfaceContext",
            "PgmQueryTcpInfo returned <%x>\n", status);

        return (status);
    }

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "GetInterfaceContext",
        "IPInterfaceContext=<%x> for Device=<%wZ>\n",
            *pIPInterfaceContext, pucBindString);

    return (status);
}


//----------------------------------------------------------------------------

ULONG
StopListeningOnInterface(
#ifdef IP_FIX
    IN  ULONG               IpInterfaceContext,
#else
    IN  tIPADDRESS          IpAddress,          // Host format
#endif  // IP_FIX
    IN  PGMLockHandle       *pOldIrqDynamicConfig
    )
/*++

Routine Description:

    Given an IPInterfaceContext, this routine traverses the list of
    all Receivers, and if any are determined to be listening on that
    interface, stops them from listening on all the addresses on this
    interface.  In the case that the listener is part of an active
    session, the routine will also change the state of the Receiver
    to start listening on all interfaces

Arguments:

    IN  IpInterfaceContext  -- IpInterfaceContext to stop listening on
    IN  pOldIrqDynamicConfig-- OldIrq for DynamicConfig lock held

    The DynamicConfig lock is held on entry and exit from this routine

Return Value:

    Number of receivers found listening on this interface

--*/
{
    NTSTATUS                status;
    tRECEIVE_SESSION        *pReceive;
    tADDRESS_CONTEXT        *pAddress;
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pEntry2;
    PGMLockHandle           OldIrq1, OldIrq2;
    USHORT                  i;
    tMCAST_INFO             MCastInfo;
    ULONG                   NumDisconnected = 0;
    tADDRESS_CONTEXT        *pAddressToDeref = NULL;

#ifdef IP_FIX
    MCastInfo.MCastInIf = IpInterfaceContext;
#else
    MCastInfo.MCastInIf = htonl (IpAddress);
#endif  // IP_FIX

    pEntry = &PgmDynamicConfig.ReceiverAddressHead;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.ReceiverAddressHead)
    {
        pAddress = CONTAINING_RECORD (pEntry, tADDRESS_CONTEXT, Linkage);
        PgmLock (pAddress, OldIrq1);

        if (!(pAddress->Flags & PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES))
        {
            //
            // If the app had specified interfaces to listen on,
            // then don't manage interfaces!
            //
            PgmUnlock (pAddress, OldIrq1);
            continue;
        }

        //
        // See if this address was listening on this interface
        //
        for (i=0; i<pAddress->NumReceiveInterfaces; i++)
        {
#ifdef IP_FIX
            if (pAddress->ReceiverInterfaceList[i] == IpInterfaceContext)
#else
            if (pAddress->ReceiverInterfaceList[i] == IpAddress)
#endif  // IP_FIX
            {
                break;
            }
        }

        if (i >= pAddress->NumReceiveInterfaces)
        {
            PgmUnlock (pAddress, OldIrq1);
            continue;
        }

        //
        // Remove this Interface from the list of listening interfaces
        //
        pAddress->NumReceiveInterfaces--;
        while (i < pAddress->NumReceiveInterfaces)
        {
            pAddress->ReceiverInterfaceList[i] = pAddress->ReceiverInterfaceList[i+1];
            i++;
        }

        PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING, TRUE);

        //
        // If this were the only interface we were listening on
        // for an active session (or waiting for a session), ensure
        // that we go back into listening mode!
        //
        if ((pAddress->Flags & PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES) &&
            (!pAddress->NumReceiveInterfaces))
        {
            pAddress->Flags |= PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE;

            if (!IsListEmpty (&PgmDynamicConfig.LocalInterfacesList))
            {
                status = ListenOnAllInterfaces (pAddress, pOldIrqDynamicConfig, &OldIrq1);

                if (NT_SUCCESS (status))
                {
                    PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "StopListeningOnInterface",
                        "ListenOnAllInterfaces for pAddress=<%x> succeeded\n", pAddress);
                }
                else
                {
                    PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "StopListeningOnInterface",
                        "ListenOnAllInterfaces for pAddress=<%x> returned <%x>\n",
                            pAddress, status);
                }
            }
        }

        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, *pOldIrqDynamicConfig);

        if (pAddressToDeref)
        {
            PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_STOP_LISTENING);
        }
        pAddressToDeref = pAddress;

        //
        // So, stop listening on this interface
        //
        MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
#ifdef IP_FIX
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_INDEX_DEL_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#else
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_DEL_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#endif  // IP_FIX

        if (NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "\tStopListeningOnInterface",
                "Stopped pAddress=<%x> from listening on Interface=<%x>\n",
                    pAddress, MCastInfo.MCastInIf);
        }
        else
        {
            //
            // We failed to stop listening on this interface -- don't so anything!
            //
            PgmLog (PGM_LOG_ERROR, DBG_PNP, "\tStopListeningOnInterface",
                "AO_OPTION_INDEX_DEL_MCAST for If=<%x> on Address=<%x> returned <%x>\n",
                    MCastInfo.MCastInIf, pAddress, status);
        }

        PgmLock (&PgmDynamicConfig, *pOldIrqDynamicConfig);
    }

    if (pAddressToDeref)
    {
        PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_STOP_LISTENING);
    }

    return (NumDisconnected);
}


//----------------------------------------------------------------------------

VOID
StopListeningOnAllInterfacesExcept(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PVOID               Data1,
    IN  PVOID               Unused
    )
/*++

Routine Description:

    Given an Address Context and IPInterfaceContext (Data1), this routine
    stops the Address from listening on all the addresses except on this
    interface.

Arguments:

    IN  pAddress            -- Address Context
    IN  Data1               -- IpInterfaceContext to stop listening on

Return Value:

    None

--*/
{
    NTSTATUS                status;
    PGMLockHandle           OldIrq;
    tMCAST_INFO             MCastInfo;
    ULONG                   InterfacesToStop[MAX_RECEIVE_INTERFACES+1];
    USHORT                  NumInterfaces, i;
    ULONG                   InterfaceToKeep = PtrToUlong (Data1);
#ifndef IP_FIX
    PGMLockHandle           OldIrq0;
    LIST_ENTRY              *pEntry;
    tLOCAL_INTERFACE        *pLocalInterface;
    tADDRESS_ON_INTERFACE   *pLocalAddress;
    USHORT                  j;
#endif  // !IP_FIX

    PgmLock (&PgmDynamicConfig, OldIrq0);
    PgmLock (pAddress, OldIrq);

    //
    // pAddress must be referenced before entering this routine
    //
    if (!(PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)) ||
        (pAddress->Flags & PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE))
    {
        //
        // Out state has changed -- deref and return immediately
        //
        PgmUnlock (pAddress, OldIrq);
        PgmUnlock (&PgmDynamicConfig, OldIrq0);

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING);
        return;
    }

#ifdef IP_FIX
    //
    // If this is the only interface we are listening on,
    // return success
    //
    if ((pAddress->NumReceiveInterfaces == 1) &&
        (pAddress->ReceiverInterfaceList[0] == InterfaceToKeep))
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "StopListeningOnAllInterfacesExcept",
            "pAddress=<%x> is only listening on 1 Interface=<%x>\n",
                pAddress, InterfaceToKeep);

        PgmUnlock (pAddress, OldIrq);
        return;
    }

    ASSERT (pAddress->NumReceiveInterfaces > 1);

    //
    // First, enumerate all interfaces to stop listening on
    //
    NumInterfaces = 0;
    for (i=0; i<pAddress->NumReceiveInterfaces; i++)
    {
        if (pAddress->ReceiverInterfaceList[i] != InterfaceToKeep)
        {
            InterfacesToStop[NumInterfaces++] = pAddress->ReceiverInterfaceList[i];
        }
    }

    pAddress->ReceiverInterfaceList[0] = InterfaceToKeep;
    pAddress->NumReceiveInterfaces = 1;

    //
    // Now, remove the remaining interfaces
    //
#else
    //
    // First, make a copy of all addresses being listened on
    //
    NumInterfaces = 0;
    for (i=0; i<pAddress->NumReceiveInterfaces; i++)
    {
        InterfacesToStop[NumInterfaces++] = pAddress->ReceiverInterfaceList[i];
    }

    //
    // Zero out the current listening list on the address
    //
    pAddress->NumReceiveInterfaces = 0;

    //
    // Now, remove the addresses on this interface from this list
    //
    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        if (InterfaceToKeep == pLocalInterface->IpInterfaceContext)
        {
            //
            // Found the interface -- now save these addresses in the Address
            // list and remove from the stop list
            //
            pEntry = &pLocalInterface->Addresses;
            while ((pEntry = pEntry->Flink) != &pLocalInterface->Addresses)
            {
                pLocalAddress = CONTAINING_RECORD (pEntry, tADDRESS_ON_INTERFACE, Linkage);

                pAddress->ReceiverInterfaceList[pAddress->NumReceiveInterfaces++] = pLocalAddress->IpAddress;

                i = 0;
                while (i < NumInterfaces)
                {
                    if (InterfacesToStop[i] == pLocalAddress->IpAddress)
                    {
                        j = i;
                        NumInterfaces--;
                        while (j < NumInterfaces)
                        {
                            InterfacesToStop[j] = InterfacesToStop[j+1];
                            j++;
                        }
                    }
                    else
                    {
                        i++;
                    }
                }

            }

            break;
        }
    }
#endif  // IP_FIX

    PgmUnlock (pAddress, OldIrq);
    PgmUnlock (&PgmDynamicConfig, OldIrq0);

    MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
    for (i=0; i<NumInterfaces; i++)
    {
#ifdef IP_FIX
        MCastInfo.MCastInIf = InterfacesToStop[i];
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_INDEX_DEL_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#else
        MCastInfo.MCastInIf = htonl (InterfacesToStop[i]);
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_DEL_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#endif  // IP_FIX

        if (NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "\tStopListeningOnAllInterfacesExcept",
                "Stopped pAddress=<%x> from listening on Interface=<%x>\n",
                    pAddress, MCastInfo.MCastInIf);
        }
        else
        {
            //
            // We failed to stop this interface -- don't so anything!
            //
            PgmLog (PGM_LOG_ERROR, DBG_PNP, "\tStopListeningOnAllInterfacesExcept",
                "AO_OPTION_INDEX_DEL_MCAST for If=<%x> on Address=<%x> returned <%x>\n",
                    MCastInfo.MCastInIf, pAddress, status);
        }
    }

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING);
    return;
}


//----------------------------------------------------------------------------

NTSTATUS
ListenOnAllInterfaces(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PGMLockHandle       *pOldIrqDynamicConfig,
    IN  PGMLockHandle       *pOldIrqAddress
    )
/*++

Routine Description:

    Given an Address Context, this routine enables the Address to
    start listening on all interfaces

Arguments:

    IN  pAddress            -- Address Context
    IN  pOldIrqDynamicConfig-- OldIrq for DynamicConfig lock held
    IN  pOldIrqAddress      -- OldIrq for Address lock held

    The DynamicConfig and Address locks are held on entry and exit
    from this routine

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS                status;
    LIST_ENTRY              *pEntry;
    tLOCAL_INTERFACE        *pLocalInterface;
    tMCAST_INFO             MCastInfo;
    ULONG                   InterfacesToAdd[MAX_RECEIVE_INTERFACES+1];
    USHORT                  NumInterfaces, i, j;
#ifndef IP_FIX
    LIST_ENTRY              *pEntry2;
    tADDRESS_ON_INTERFACE   *pLocalAddress;
#endif  // !IP_FIX

    //
    // First, get the list of all active interfaces
    //
    NumInterfaces = 0;
    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
#ifdef IP_FIX
        InterfacesToAdd[NumInterfaces++] = pLocalInterface->IpInterfaceContext;
#else
        pEntry2 = &pLocalInterface->Addresses;
        while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);

            InterfacesToAdd[NumInterfaces++] = pLocalAddress->IpAddress;

            if (NumInterfaces >= MAX_RECEIVE_INTERFACES)
            {
                break;
            }
        }
#endif  // IP_FIX

        if (NumInterfaces >= MAX_RECEIVE_INTERFACES)
        {
            break;
        }
    }

    //
    // Remove all the interfaces we are already listening
    // on from the list of interfaces to be added
    //
    for (i=0; i<pAddress->NumReceiveInterfaces; i++)
    {
        for (j = 0; j < NumInterfaces; j++)
        {
            if (pAddress->ReceiverInterfaceList[i] == InterfacesToAdd[j])
            {
                NumInterfaces--;
                while (j < NumInterfaces)
                {
                    InterfacesToAdd[j] = InterfacesToAdd[j+1];
                    j++;
                }

                break;
            }
        }
    }

    if (!NumInterfaces)
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "ListenOnAllInterfaces",
            "No new interfaces to listen on for pAddress=<%x>, currently listening on <%x> Ifs\n",
                pAddress, pAddress->NumReceiveInterfaces);

        return (STATUS_SUCCESS);
    }

    //
    // Ensure that the complete list will not
    // exceed the maximum limit
    //
    if ((pAddress->NumReceiveInterfaces + NumInterfaces) > MAX_RECEIVE_INTERFACES)
    {
        NumInterfaces = MAX_RECEIVE_INTERFACES - pAddress->NumReceiveInterfaces;
    }

    //
    // Now, add the remaining interfaces
    //
    PgmUnlock (pAddress, *pOldIrqAddress);
    PgmUnlock (&PgmDynamicConfig, *pOldIrqDynamicConfig);

    MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
    i = 0;
    while (i < NumInterfaces)
    {
#ifdef IP_FIX
        MCastInfo.MCastInIf = InterfacesToAdd[i];
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_INDEX_ADD_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#else
        MCastInfo.MCastInIf = htonl (InterfacesToAdd[i]);
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_ADD_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#endif  // IP_FIX

        if (NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "\tListenOnAllInterfaces",
                "pAddress=<%x> now also listening on If=<%x>\n",
                    pAddress, MCastInfo.MCastInIf);

            i++;
            continue;
        }

        //
        // We failed to add this interface, so remove it from   
        // the list
        //
        PgmLog (PGM_LOG_ERROR, DBG_PNP, "\tListenOnAllInterfaces",
            "pAddress=<%x> could not listen on If=<%x>\n",
                pAddress, MCastInfo.MCastInIf);

        j = i;
        NumInterfaces--;
        while (j < NumInterfaces)
        {
            InterfacesToAdd[j] = InterfacesToAdd[j+1];
            j++;
        }
    }

    PgmLock (&PgmDynamicConfig, *pOldIrqDynamicConfig);
    PgmLock (pAddress, *pOldIrqAddress);

    //
    // Now, append the new list to the Address context
    //
    for (i=0; i<NumInterfaces; i++)
    {
        if (pAddress->NumReceiveInterfaces > MAX_RECEIVE_INTERFACES)
        {
            ASSERT (0);
            break;
        }

        pAddress->ReceiverInterfaceList[pAddress->NumReceiveInterfaces] = InterfacesToAdd[i];
        pAddress->NumReceiveInterfaces++;
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

VOID
TdiAddressArrival(
    PTA_ADDRESS         Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
/*++

Routine Description:

    PnP TDI_ADD_ADDRESS_HANDLER
    This routine handles an IP address arriving.
    It is called by TDI when an address arrives.

Arguments:

    IN  Addr        -- IP address that's coming.
    IN  pDeviceName -- Unicode string Ptr for Device whose address is changing
    IN  Context     -- Tdi PnP context

Return Value:

    Nothing!

--*/
{
    tIPADDRESS              IpAddr, NetIpAddr;
    LIST_ENTRY              *pEntry;
    PGMLockHandle           OldIrq, OldIrq1;
    tLOCAL_INTERFACE        *pLocalInterface = NULL;
    tADDRESS_ON_INTERFACE   *pLocalAddress = NULL;
    ULONG                   BufferLength = 50;
    UCHAR                   pBuffer[50];
    IPInterfaceInfo         *pIpIfInfo = (IPInterfaceInfo *) pBuffer;
    NTSTATUS                status;
    tADDRESS_CONTEXT        *pAddress;
    tADDRESS_CONTEXT        *pAddressToDeref = NULL;
    ULONG                   IpInterfaceContext;
    BOOLEAN                 fFound;

    //
    // Proceed only if this is an IP address
    //
    if (Addr->AddressType != TDI_ADDRESS_TYPE_IP)
    {
        return;
    }

    //
    // First, verify that we are not getting unloaded
    //
    PgmLock (&PgmDynamicConfig, OldIrq);
    if (!PGM_VERIFY_HANDLE (pgPgmDevice, PGM_VERIFY_DEVICE))
    {
        //
        // The driver is most probably being unloaded now
        //
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return;
    }
    PGM_REFERENCE_DEVICE (pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION, FALSE);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    NetIpAddr = ((PTDI_ADDRESS_IP)&Addr->Address[0])->in_addr;
    IpAddr = ntohl (NetIpAddr);

    //
    // Now, get the interface context and other info from TcpIp
    //
    status = GetIpInterfaceContextFromDeviceName (NetIpAddr,
                                                  pDeviceName,
                                                  &IpInterfaceContext,
                                                  BufferLength,
                                                  pBuffer,
                                                  TRUE);
    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_PNP, "TdiAddressArrival",
            "GetIpInterfaceContext returned <%x>\n", status);

        PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);
        return;
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    fFound = FALSE;
    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        if (pLocalInterface->IpInterfaceContext == IpInterfaceContext)
        {
            fFound = TRUE;
            break;
        }
    }

    if (fFound)
    {
        fFound = FALSE;
        pEntry = &pLocalInterface->Addresses;
        while ((pEntry = pEntry->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry, tADDRESS_ON_INTERFACE, Linkage);
            if (pLocalAddress->IpAddress == IpAddr)
            {
                PgmUnlock (&PgmDynamicConfig, OldIrq);
                PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);

                PgmLog (PGM_LOG_ERROR, DBG_PNP, "TdiAddressArrival",
                    "\tDUPLICATE address notification for [%d.%d.%d.%d] on <%wZ>\n",
                    (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
                    pDeviceName);

                return;
            }
        }
    }
    else if (pLocalInterface = PgmAllocMem (sizeof(tLOCAL_INTERFACE), PGM_TAG('0')))
    {
        PgmZeroMemory (pLocalInterface, sizeof (tLOCAL_INTERFACE));
        InitializeListHead (&pLocalInterface->Addresses);

        pLocalInterface->IpInterfaceContext = IpInterfaceContext;
        pLocalInterface->MTU = pIpIfInfo->iii_mtu - (sizeof(IPV4Header) + ROUTER_ALERT_SIZE);
        pLocalInterface->Flags = pIpIfInfo->iii_flags;

        BufferLength = pIpIfInfo->iii_addrlength < sizeof(tMAC_ADDRESS) ?
                            pIpIfInfo->iii_addrlength : sizeof(tMAC_ADDRESS);
        PgmCopyMemory (&pLocalInterface->MacAddress, pIpIfInfo->iii_addr, BufferLength);

        if (pLocalInterface->MTU > PgmDynamicConfig.MaxMTU)
        {
            PgmDynamicConfig.MaxMTU = pLocalInterface->MTU;
        }
        InsertTailList (&PgmDynamicConfig.LocalInterfacesList, &pLocalInterface->Linkage);
    }
    else
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmLog (PGM_LOG_ERROR, DBG_PNP, "TdiAddressArrival",
            "STATUS_INSUFFICIENT_RESOURCES[Interface] for IP=<%x>, IfContext=<%x>\n",
                IpAddr, IpInterfaceContext);

        PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);
        return;
    }

    //
    // Now, add this address to the interface
    //
    if (pLocalAddress = PgmAllocMem (sizeof(tADDRESS_ON_INTERFACE), PGM_TAG('0')))
    {
        PgmZeroMemory (pLocalAddress, sizeof (tADDRESS_ON_INTERFACE));
        pLocalAddress->IpAddress = IpAddr;
        InsertTailList (&pLocalInterface->Addresses, &pLocalAddress->Linkage);
    }
    else
    {
        //
        // If we had just added the interface, there is no point
        // in keeping an empty context around!
        //
        if (IsListEmpty (&pLocalInterface->Addresses))
        {
            RemoveEntryList (&pLocalInterface->Linkage);
            PgmFreeMem (pLocalInterface);
        }

        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmLog (PGM_LOG_ERROR, DBG_PNP, "TdiAddressArrival",
            "STATUS_INSUFFICIENT_RESOURCES[Address] -- [%d.%d.%d.%d] on <%wZ>\n",
                (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
                pDeviceName);

        PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);
        return;
    }

    //
    // Now, check if we have any receivers waiting for an address
    //
    pEntry = &PgmDynamicConfig.ReceiverAddressHead;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.ReceiverAddressHead)
    {
        pAddress = CONTAINING_RECORD (pEntry, tADDRESS_CONTEXT, Linkage);
        PgmLock (pAddress, OldIrq1);

        if ((PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)) &&
            (pAddress->Flags & PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE) &&
            (pAddress->Flags & PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES))
        {
            PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, TRUE);

            if (pAddressToDeref)
            {
                PgmUnlock (pAddress, OldIrq1);
                PgmUnlock (&PgmDynamicConfig, OldIrq);

                PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_SET_INFO);

                PgmLock (&PgmDynamicConfig, OldIrq);
                PgmLock (pAddress, OldIrq1);
            }
            pAddressToDeref = pAddress;

            status = ReceiverAddMCastIf (pAddress, IpAddr, &OldIrq, &OldIrq1);

            if (NT_SUCCESS (status))
            {
                PgmLog (PGM_LOG_INFORM_STATUS, DBG_ADDRESS, "TdiAddressArrival",
                    "ReceiverAddMCastIf for pAddress=<%x> succeeded for IP=<%x>\n",
                        pAddress, IpAddr);
            }
            else
            {
                PgmLog (PGM_LOG_ERROR, DBG_ADDRESS, "TdiAddressArrival",
                    "ReceiverAddMCastIf for pAddress=<%x> returned <%x>, IP=<%x>\n",
                        pAddress, status, IpAddr);
            }
        }

        PgmUnlock (pAddress, OldIrq1);
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    if (pAddressToDeref)
    {
        PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_SET_INFO);
    }

    PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiAddressArrival",
        "\t[%d.%d.%d.%d] on <%wZ>\n",
        (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
        pDeviceName);
}


//----------------------------------------------------------------------------

VOID
TdiAddressDeletion(
    PTA_ADDRESS         Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
/*++

Routine Description:

    This routine handles an IP address going away.
    It is called by TDI when an address is deleted.
    If it's an address we care about we'll clean up appropriately.

Arguments:

    IN  Addr        -- IP address that's going.
    IN  pDeviceName -- Unicode string Ptr for Device whose address is changing
    IN  Context     -- Tdi PnP context

Return Value:

    Nothing!

--*/
{
    tIPADDRESS              IpAddr;
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pEntry2;
    PGMLockHandle           OldIrq, OldIrq1;
    tSEND_SESSION           *pSend;
    tADDRESS_CONTEXT        *pAddress;
    NTSTATUS                status;
    BOOLEAN                 fFound;
    tADDRESS_CONTEXT        *pAddressToDeref = NULL;
    tLOCAL_INTERFACE        *pLocalInterface = NULL;
    tADDRESS_ON_INTERFACE   *pLocalAddress = NULL;
    ULONG                   IpInterfaceContext;

    if (Addr->AddressType != TDI_ADDRESS_TYPE_IP)
    {
        return;
    }
    IpAddr = ntohl(((PTDI_ADDRESS_IP)&Addr->Address[0])->in_addr);

    PgmLock (&PgmDynamicConfig, OldIrq);

    fFound = FALSE;
    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        pEntry2 = &pLocalInterface->Addresses;
        while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);
            if (pLocalAddress->IpAddress == IpAddr)
            {
                IpInterfaceContext = pLocalInterface->IpInterfaceContext;
                RemoveEntryList (&pLocalAddress->Linkage);
                PgmFreeMem (pLocalAddress);

                //
                // If this is the last address on this interface, clean up!
                //
                if (IsListEmpty (&pLocalInterface->Addresses))
                {
                    RemoveEntryList (&pLocalInterface->Linkage);
                    PgmFreeMem (pLocalInterface);
                    pLocalInterface = NULL;
                }

                fFound = TRUE;
                break;
            }
        }

        if (fFound)
        {
            break;
        }
    }

    if (!fFound)
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmLog (PGM_LOG_ERROR, DBG_PNP, "TdiAddressDeletion",
            "\tAddress [%d.%d.%d.%d] NOT notified on <%wZ>\n",
            (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
            pDeviceName);

        return;
    }

    pEntry = &PgmDynamicConfig.SenderAddressHead;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.SenderAddressHead)
    {
        pAddress = CONTAINING_RECORD (pEntry, tADDRESS_CONTEXT, Linkage);
        if (pAddress->SenderMCastOutIf == IpAddr)
        {
            PgmLock (pAddress, OldIrq1);
            pAddress->Flags |= PGM_ADDRESS_FLAG_INVALID_OUT_IF;

            pEntry2 = &pAddress->AssociatedConnections;
            while ((pEntry2 = pEntry2->Flink) != &pAddress->AssociatedConnections)
            {
                pSend = CONTAINING_RECORD (pEntry2, tSEND_SESSION, Linkage);
                if (!(pSend->SessionFlags & PGM_SESSION_TERMINATED_ABORT))
                {
                    pSend->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;

                    if (pAddress->evDisconnect)
                    {
                        PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_DISCONNECT, TRUE);
                        PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_DISCONNECT, FALSE);

                        PgmUnlock (pAddress, OldIrq1);
                        PgmUnlock (&PgmDynamicConfig, OldIrq);

                        if (pAddressToDeref)
                        {
                            PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_DISCONNECT);
                        }
                        pAddressToDeref = pAddress;

                        status = (*pAddress->evDisconnect) (pAddress->DiscEvContext,
                                                            pSend->ClientSessionContext,
                                                            0,
                                                            NULL,
                                                            0,
                                                            NULL,
                                                            TDI_DISCONNECT_ABORT);

                        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_DISCONNECT);

                        PgmLock (&PgmDynamicConfig, OldIrq);
                        PgmLock (pAddress, OldIrq1);

                        pEntry = &PgmDynamicConfig.SenderAddressHead;
                        break;
                    }
                }
            }

            PgmUnlock (pAddress, OldIrq1);
        }
    }

    //
    // See which receivers were actively listening on this interface
    // If this was an interface for an active session, then we need to
    // restart listening on all interfaces if no interface(s) had been
    // specified by the user.
    //
#ifdef IP_FIX
    if (!pLocalInterface)
    {
        StopListeningOnInterface (IpInterfaceContext, &OldIrq);
    }
#else
    StopListeningOnInterface (IpAddr, &OldIrq);
#endif  // IP_FIX

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    if (pAddressToDeref)
    {
        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_DISCONNECT);
    }

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiAddressDeletion",
        "\t[%d.%d.%d.%d] on <%wZ>\n",
            (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
            pDeviceName);
}


//----------------------------------------------------------------------------

VOID
TdiBindHandler(
    TDI_PNP_OPCODE  PnPOpCode,
    PUNICODE_STRING pDeviceName,
    PWSTR           MultiSZBindList
    )
/*++

Routine Description:

    This routine is the handler for TDI to notify clients of bind notifications

Arguments:

    IN  PnPOpCode   --  Notification code
    IN  pDeviceName --  Unicode string Ptr for Device whose address is changing
    IN  MultiSZBindList --  Current list of bindings

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{

    PAGED_CODE();

    switch (PnPOpCode)
    {
        case (TDI_PNP_OP_ADD):
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiBindHandler",
                "\t[ADD]: Device=<%wZ>\n", pDeviceName);

            break;
        }

        case (TDI_PNP_OP_DEL):
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiBindHandler",
                "\t[DEL]: Device=<%wZ>\n", pDeviceName);

            break;
        }

        case (TDI_PNP_OP_PROVIDERREADY):
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiBindHandler",
                "\t[PROVIDERREADY]: Device=<%wZ>\n", pDeviceName);

            break;
        }

        case (TDI_PNP_OP_NETREADY):
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiBindHandler",
                "\t[NETREADY]: Device=<%wZ>\n", pDeviceName);

            break;
        }

        default:
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiBindHandler",
                "\t[?=%x]: Device=<%wZ>\n", PnPOpCode, pDeviceName);

            break;
        }
    }

}


//----------------------------------------------------------------------------

NTSTATUS
TdiPnPPowerHandler(
    IN  PUNICODE_STRING     pDeviceName,
    IN  PNET_PNP_EVENT      pPnPEvent,
    IN  PTDI_PNP_CONTEXT    Context1,
    IN  PTDI_PNP_CONTEXT    Context2
    )
/*++

Routine Description:

    This routine is the handler called by TDI notify its clients of Power notifications

Arguments:

    IN  pDeviceName --  Unicode string Ptr for Device whose address is changing
    IN  PnPEvent    --  Event notification
    IN  Context1    --
    IN  Context2    --

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    PAGED_CODE();

    switch (pPnPEvent->NetEvent)
    {
        case (NetEventQueryPower):
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_PNP, "TdiPnPPowerHandler",
                "[QueryPower]:  Device=<%wZ>\n", pDeviceName);

            break;
        }

        case (NetEventSetPower):
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_PNP, "TdiPnPPowerHandler",
                "[SetPower]:  Device=<%wZ>\n", pDeviceName);

            break;
        }

        case (NetEventQueryRemoveDevice):
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiPnPPowerHandler",
                "[QueryRemoveDevice]:  Device=<%wZ>\n", pDeviceName);

            break;
        }

        case (NetEventCancelRemoveDevice):
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiPnPPowerHandler",
                "[CancelRemoveDevice]:  Device=<%wZ>\n", pDeviceName);

            break;
        }

        case (NetEventReconfigure):
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_PNP, "TdiPnPPowerHandler",
                "[Reconfigure]:  Device=<%wZ>\n", pDeviceName);

            break;
        }

        case (NetEventBindList):
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_PNP, "TdiPnPPowerHandler",
                "[BindList]:  Device=<%wZ>\n", pDeviceName);

            break;
        }

        case (NetEventPnPCapabilities):
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_PNP, "TdiPnPPowerHandler",
                "[PnPCapabilities]:  Device=<%wZ>\n", pDeviceName);

            break;
        }

        default:
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_PNP, "TdiPnPPowerHandler",
                "[?=%d]:  Device=<%wZ>\n", (ULONG) pPnPEvent->NetEvent, pDeviceName);

            break;
        }
    }


    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
SetTdiHandlers(
    )
/*++

Routine Description:

    This routine is called at DriverEntry to register our handlers with TDI

Arguments:

    IN

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS                    status;
    UNICODE_STRING              ucPgmClientName;
    TDI_CLIENT_INTERFACE_INFO   TdiClientInterface;

    PAGED_CODE();

    //
    // Register our Handlers with TDI
    //
    RtlInitUnicodeString (&ucPgmClientName, WC_PGM_CLIENT_NAME);
    ucPgmClientName.MaximumLength = sizeof (WC_PGM_CLIENT_NAME);
    PgmZeroMemory (&TdiClientInterface, sizeof(TdiClientInterface));

    TdiClientInterface.MajorTdiVersion      = TDI_CURRENT_MAJOR_VERSION;
    TdiClientInterface.MinorTdiVersion      = TDI_CURRENT_MINOR_VERSION;
    TdiClientInterface.ClientName           = &ucPgmClientName;
    TdiClientInterface.AddAddressHandlerV2  = TdiAddressArrival;
    TdiClientInterface.DelAddressHandlerV2  = TdiAddressDeletion;
    TdiClientInterface.BindingHandler       = TdiBindHandler;
    TdiClientInterface.PnPPowerHandler      = TdiPnPPowerHandler;

    status = TdiRegisterPnPHandlers (&TdiClientInterface, sizeof(TdiClientInterface), &TdiClientHandle);
    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_PNP, "SetTdiHandlers",
            "TdiRegisterPnPHandlers ==> <%x>\n", status);
        return (status);
    }

    TdiEnumerateAddresses(TdiClientHandle);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_PNP, "SetTdiHandlers",
        "\tSUCCEEDed\n");

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\init.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements Initialization routines
    the PGM Transport and other routines that are specific to the
    NT implementation of a driver.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"
#include <ntddtcp.h>


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, InitPgm)
#pragma alloc_text(PAGE, InitStaticPgmConfig)
#pragma alloc_text(PAGE, InitDynamicPgmConfig)
#pragma alloc_text(PAGE, PgmReadRegistryParameters)
#pragma alloc_text(PAGE, AllocateInitialPgmStructures)
#pragma alloc_text(PAGE, PgmCreateDevice)
#pragma alloc_text(PAGE, PgmDereferenceDevice)
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
InitStaticPgmConfig(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    This routine initializes the static values used by Pgm

Arguments:

    IN  DriverObject    - Pointer to driver object created by the system.
    IN  RegistryPath    - Pgm driver's registry location

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    NTSTATUS    status;

    PAGED_CODE();

    //
    // Initialize the Static Configuration data structure
    //
    PgmZeroMemory (&PgmStaticConfig, sizeof(tPGM_STATIC_CONFIG));

    //
    // get the file system process since we need to know this for
    // allocating and freeing handles
    //
    PgmStaticConfig.FspProcess = PsGetCurrentProcess();
    PgmStaticConfig.DriverObject = DriverObject;    // save the driver object for event logging purposes

    //
    // save the registry path for later use (to read the registry)
    //
    PgmStaticConfig.RegistryPath.MaximumLength = (USHORT) RegistryPath->MaximumLength;
    if (PgmStaticConfig.RegistryPath.Buffer = PgmAllocMem (RegistryPath->MaximumLength, PGM_TAG('0')))
    {
        RtlCopyUnicodeString(&PgmStaticConfig.RegistryPath, RegistryPath);
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "InitStaticPgmConfig",
            "INSUFFICIENT_RESOURCES <%d> bytes\n", PgmStaticConfig.RegistryPath.MaximumLength);

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    ExInitializeNPagedLookasideList(&PgmStaticConfig.TdiLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof (tTDI_SEND_CONTEXT),
                                    PGM_TAG('2'),
                                    TDI_LOOKASIDE_DEPTH);

    ExInitializeNPagedLookasideList(&PgmStaticConfig.DebugMessagesLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    (MAX_DEBUG_MESSAGE_LENGTH + 1),
                                    PGM_TAG('3'),
                                    DEBUG_MESSAGES_LOOKASIDE_DEPTH);

    status = FECInitGlobals ();

    if (!NT_SUCCESS (status))
    {
        ExDeleteNPagedLookasideList (&PgmStaticConfig.DebugMessagesLookasideList);
        ExDeleteNPagedLookasideList (&PgmStaticConfig.TdiLookasideList);
        PgmFreeMem (PgmStaticConfig.RegistryPath.Buffer);
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_INIT_PGM, "InitStaticPgmConfig",
        "FECInitGlobals returned <%x>\n", status);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
InitDynamicPgmConfig(
    )
/*++

Routine Description:

    This routine initializes the dynamic values used by Pgm

Arguments:


Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    ULONG       i;

    PAGED_CODE();

    //
    // Initialize the Static Configuration data structure
    //
    PgmZeroMemory (&PgmDynamicConfig, sizeof(tPGM_DYNAMIC_CONFIG));

    //
    // Initialize the list heads before doing anything else since
    // we can access them anytime later
    //
    InitializeListHead (&PgmDynamicConfig.SenderAddressHead);
    InitializeListHead (&PgmDynamicConfig.ReceiverAddressHead);
    InitializeListHead (&PgmDynamicConfig.CurrentReceivers);
    InitializeListHead (&PgmDynamicConfig.CleanedUpAddresses);
    InitializeListHead (&PgmDynamicConfig.ClosedConnections);
    InitializeListHead (&PgmDynamicConfig.ConnectionsCreated);
    InitializeListHead (&PgmDynamicConfig.CleanedUpConnections);
    InitializeListHead (&PgmDynamicConfig.LocalInterfacesList);
    InitializeListHead (&PgmDynamicConfig.WorkerQList);

    PgmDynamicConfig.ReceiversTimerTickCount = 1;       // Init
    PgmDynamicConfig.SourcePort = (USHORT) GetRandomInteger (2000, 20000);

#if DBG
    for (i=0; i<MAXIMUM_PROCESSORS; i++)
    {
        PgmDynamicConfig.CurrentLockNumber[i] = 0;
    }
#endif
    PgmInitLock (&PgmDynamicConfig, DCONFIG_LOCK);

    KeInitializeEvent (&PgmDynamicConfig.LastWorkerItemEvent, NotificationEvent, TRUE);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_INIT_PGM, "InitDynamicPgmConfig",
        "STATUS_SUCCESS\n");

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmOpenRegistryParameters(
    IN  PUNICODE_STRING         RegistryPath,
    OUT HANDLE                  *pConfigHandle,
    OUT HANDLE                  *pParametersHandle
    )
/*++

Routine Description:

    This routine reads any required registry parameters

Arguments:

    OUT ppPgmDynamic    -- non-NULL only if we have any registry valuies to read

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    OBJECT_ATTRIBUTES   TmpObjectAttributes;
    NTSTATUS            status;
    ULONG               Disposition;
    UNICODE_STRING      KeyName;
    PWSTR               ParametersString = L"Parameters";

    PAGED_CODE();

    InitializeObjectAttributes (&TmpObjectAttributes,
                                RegistryPath,               // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
                                NULL,                       // root
                                NULL);                      // security descriptor

    status = ZwCreateKey (pConfigHandle,
                          KEY_READ,
                          &TmpObjectAttributes,
                          0,                 // title index
                          NULL,              // class
                          0,                 // create options
                          &Disposition);     // disposition

    if (!NT_SUCCESS(status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "PgmOpenRegistryParameters",
            "ZwCreateKey returned <%x>\n", status);

        return (status);
    }

    //
    // Open the Pgm key.
    //
    RtlInitUnicodeString (&KeyName, ParametersString);
    InitializeObjectAttributes (&TmpObjectAttributes,
                                &KeyName,                                   // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                *pConfigHandle,                             // root
                                NULL);                                      // security descriptor

    status = ZwOpenKey (pParametersHandle, KEY_READ, &TmpObjectAttributes);
    if (!NT_SUCCESS(status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "PgmOpenRegistryParameters",
            "ZwOpenKey returned <%x>\n", status);

        ZwClose(*pConfigHandle);
    }

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
ReadRegistryElement(
    IN  HANDLE          HandleToKey,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    )
/*++

Routine Description:

    This routine is will read a string value given by pwsValueName, under a
    given Key (which must be open) - given by HandleToKey. This routine
    allocates memory for the buffer in the returned pucString, so the caller
    must deallocate that.

Arguments:

    pwsValueName- the name of the value to read (i.e. IPAddress)

Return Value:

    pucString - the string returns the string read from the registry

--*/

{
    ULONG                       BytesRead;
    NTSTATUS                    Status;
    UNICODE_STRING              TempString;
    PKEY_VALUE_FULL_INFORMATION ReadValue = NULL;

    PAGED_CODE();

    //
    // First, get the sizeof the string
    //
    RtlInitUnicodeString(&TempString, pwsValueName);      // initilize the name of the value to read
    Status = ZwQueryValueKey (HandleToKey,
                              &TempString,               // string to retrieve
                              KeyValueFullInformation,
                              NULL,
                              0,
                              &BytesRead);             // get bytes to be read

    if (((!NT_SUCCESS (Status)) &&
         (Status != STATUS_BUFFER_OVERFLOW) &&
         (Status != STATUS_BUFFER_TOO_SMALL)) ||
        (BytesRead == 0))
    {
        return (STATUS_UNSUCCESSFUL);
    }

    if (ReadValue = (PKEY_VALUE_FULL_INFORMATION) PgmAllocMem (BytesRead, PGM_TAG('R')))
    {
        Status = ZwQueryValueKey (HandleToKey,
                                  &TempString,               // string to retrieve
                                  KeyValueFullInformation,
                                  (PVOID)ReadValue,        // returned info
                                  BytesRead,
                                  &BytesRead);             // # of bytes returned

        if ((NT_SUCCESS (Status)) &&
            (ReadValue->DataLength))
        {
            // move the read in data to the front of the buffer
            RtlMoveMemory ((PVOID) ReadValue, (((PUCHAR)ReadValue) + ReadValue->DataOffset), ReadValue->DataLength);
            RtlInitUnicodeString (pucString, (PWSTR) ReadValue);
        }
        else
        {
            PgmFreeMem (ReadValue);
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    return(Status);
}
//----------------------------------------------------------------------------

NTSTATUS
PgmReadRegistryParameters(
    IN  PUNICODE_STRING         RegistryPath,
    OUT tPGM_REGISTRY_CONFIG    **ppPgmRegistryConfig
    )
/*++

Routine Description:

    This routine reads any required registry parameters

Arguments:

    OUT ppPgmDynamic    -- non-NULL only if we have any registry valuies to read

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    HANDLE                  PgmConfigHandle;
    HANDLE                  ParametersHandle;
    NTSTATUS                status;
    tPGM_REGISTRY_CONFIG    *pRegistryConfig;

    PAGED_CODE();

    if (!(pRegistryConfig = PgmAllocMem (sizeof (tPGM_REGISTRY_CONFIG), PGM_TAG('0'))))
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    status = PgmOpenRegistryParameters (RegistryPath, &PgmConfigHandle, &ParametersHandle);
    if (!NT_SUCCESS(status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "PgmReadRegistryParameters",
            "ZwOpenKey returned <%x>\n", status);

        PgmFreeMem (pRegistryConfig);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // zero out the Registry fields
    //
    PgmZeroMemory (pRegistryConfig, sizeof(tPGM_REGISTRY_CONFIG));

    //
    // ***************************************
    // Now read all the registry needs we need
    //

    status = ReadRegistryElement (ParametersHandle,
                                  PARAM_SENDER_FILE_LOCATION,
                                  &pRegistryConfig->ucSenderFileLocation);
    if (NT_SUCCESS (status))
    {
        pRegistryConfig->Flags |= PGM_REGISTRY_SENDER_FILE_SPECIFIED;
    }

    //
    // End of list of entries to be read
    // ***************************************
    //

    ZwClose(ParametersHandle);
    ZwClose(PgmConfigHandle);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_INIT_PGM, "PgmReadRegistryParameters",
        "STATUS_SUCCESS\n");

    *ppPgmRegistryConfig = pRegistryConfig;

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
AllocateInitialPgmStructures(
    )
/*++

Routine Description:

    This routine allocates any initial structures that may be required

Arguments:


Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    PAGED_CODE();

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_INIT_PGM, "AllocateInitialPgmStructures",
        "STATUS_SUCCESS\n");

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCreateDevice(
    )
/*++

Routine Description:

    This routine allocates the Pgm device for clients to
    call into the Pgm driver.

Arguments:

    IN 

Return Value:

    NTSTATUS - Final status of the CreateDevice operation

--*/
{
    NTSTATUS            Status;
    tPGM_DEVICE         *pPgmDevice = NULL;
    UNICODE_STRING      ucPgmDeviceExportName;
    UNICODE_STRING      ucProtocolNumber;
    WCHAR               wcProtocolNumber[10];
    USHORT              PgmBindDeviceNameLength;

    PAGED_CODE();

    RtlInitUnicodeString (&ucPgmDeviceExportName, WC_PGM_DEVICE_EXPORT_NAME);
    PgmBindDeviceNameLength = sizeof(DD_RAW_IP_DEVICE_NAME) + 10;

    Status = IoCreateDevice (PgmStaticConfig.DriverObject,                  // Driver Object
                             sizeof(tPGM_DEVICE)+PgmBindDeviceNameLength,   // Device Extension
                             &ucPgmDeviceExportName,                        // Device Name
                             FILE_DEVICE_NETWORK,                           // Device type 0x12
                             FILE_DEVICE_SECURE_OPEN,                       // Device Characteristics
                             FALSE,                                         // Exclusive
                             &pPgmDeviceObject);

    if (!NT_SUCCESS (Status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "PgmCreateDevice",
            "FAILed <%x> ExportDevice=%wZ\n", Status, &ucPgmDeviceExportName);

        pgPgmDevice = NULL;
        return Status;
    }

    pPgmDevice = (tPGM_DEVICE *) pPgmDeviceObject->DeviceExtension;

    //
    // zero out the DeviceExtension
    //
    PgmZeroMemory (pPgmDevice, sizeof(tPGM_DEVICE)+PgmBindDeviceNameLength);

    // put a verifier value into the structure so that we can check that
    // we are operating on the right data
    PgmInitLock (pPgmDevice, DEVICE_LOCK);
    pPgmDevice->Verify = PGM_VERIFY_DEVICE;
    PGM_REFERENCE_DEVICE (pPgmDevice, REF_DEV_CREATE, TRUE);

    pPgmDevice->pPgmDeviceObject = pPgmDeviceObject;
    //
    // Save the raw IP device name as a counted string.  The device
    // name is followed by a path separator then the protocol number
    // of interest.
    //
    pPgmDevice->ucBindName.Buffer = (PWSTR) &pPgmDevice->BindNameBuffer;
    pPgmDevice->ucBindName.Length = 0;
    pPgmDevice->ucBindName.MaximumLength = PgmBindDeviceNameLength;
    RtlAppendUnicodeToString (&pPgmDevice->ucBindName, DD_RAW_IP_DEVICE_NAME);
    pPgmDevice->ucBindName.Buffer[pPgmDevice->ucBindName.Length / sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
    pPgmDevice->ucBindName.Length += sizeof(WCHAR);

    ucProtocolNumber.Buffer = wcProtocolNumber;
    ucProtocolNumber.MaximumLength = sizeof (wcProtocolNumber);
    RtlIntegerToUnicodeString ((ULONG) IPPROTO_RM, 10, &ucProtocolNumber);

    RtlAppendUnicodeStringToString (&pPgmDevice->ucBindName, &ucProtocolNumber);

    //
    // Initialize the event that will be used to signal the Device is ready to be deleted
    //
    KeInitializeEvent (&pPgmDevice->DeviceCleanedupEvent, NotificationEvent, FALSE);

    //
    // Now open a control channel on top of Ip
    //
    Status = PgmTdiOpenControl (pPgmDevice);
    if (!NT_SUCCESS (Status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "PgmCreateDevice",
            "PgmTdiOpenControl FAILed <%x>\n", Status);

        IoDeleteDevice (pPgmDeviceObject);
        return (Status);
    }

    // increase the stack size of our device object, over that of the transport
    // so that clients create Irps large enough
    // to pass on to the transport below.
    // In theory, we should just add 1 here, to account for our presence in the
    // driver chain.
    //
    pPgmDeviceObject->StackSize = pPgmDevice->pControlDeviceObject->StackSize + 1;

    pPgmDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    pgPgmDevice = pPgmDevice;

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_INIT_PGM, "PgmCreateDevice",
        "Status=<%x> ExportDevice=%wZ\n", Status, &ucPgmDeviceExportName);

    return (Status);
}


//----------------------------------------------------------------------------

VOID
PgmDereferenceDevice(
    IN OUT  tPGM_DEVICE **ppPgmDevice,
    IN      ULONG       RefContext
    )
/*++

Routine Description:

    This routine dereferences the RefCount on the Pgm
    device extension and deletes the device if the RefCount
    goes down to 0.

Arguments:

    IN  ppPgmDevice --  ptr to PgmDevice Extension
    IN  RefContext  --  the context for which this device extension was
                        referenced earlier

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    tPGM_DEVICE         *pPgmDevice = *ppPgmDevice;
    KAPC_STATE          ApcState;
    BOOLEAN             fAttached;

    PAGED_CODE();

    ASSERT (PGM_VERIFY_HANDLE (pPgmDevice, PGM_VERIFY_DEVICE));
    ASSERT (pPgmDevice->RefCount);             // Check for too many derefs
    ASSERT (pPgmDevice->ReferenceContexts[RefContext]--);

    if (--pPgmDevice->RefCount)
    {
        return;
    }

    if (pPgmDevice->hControl)
    {
        //
        // This is only done at Load/Unload time, so we should
        // be currently in the System Process Context!
        //
        PgmAttachFsp (&ApcState, &fAttached, REF_FSP_DESTROY_DEVICE);

        ObDereferenceObject (pPgmDevice->pControlFileObject);
        ZwClose (pPgmDevice->hControl);

        pPgmDevice->pControlFileObject = NULL;
        pPgmDevice->hControl = NULL;

        PgmDetachFsp (&ApcState, &fAttached, REF_FSP_DESTROY_DEVICE);
    }

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_INIT_PGM, "PgmDereferenceDevice",
        "Deleting pgPgmDevice=%x ...\n", pgPgmDevice);

    IoDeleteDevice (pPgmDevice->pPgmDeviceObject);
    *ppPgmDevice = NULL;

    return;
}


//----------------------------------------------------------------------------

NTSTATUS
InitPgm(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    This routine is called at DriverEntry to initialize all the
    Pgm parameters

Arguments:

    IN  DriverObject    - Pointer to driver object created by the system.
    IN  RegistryPath    - Pgm driver's registry location

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS                status;
    tPGM_REGISTRY_CONFIG    *pPgmRegistry = NULL;

    PAGED_CODE();

    status = InitStaticPgmConfig (DriverObject, RegistryPath);
    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "InitPgm",
            "InitStaticPgmConfig returned <%x>\n", status);
        return (status);
    }

    //---------------------------------------------------------------------------------------

    status = InitDynamicPgmConfig ();
    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "InitPgm",
            "InitDynamicPgmConfig returned <%x>\n", status);
        CleanupInit (E_CLEANUP_STATIC_CONFIG);
        return (status);
    }

    //---------------------------------------------------------------------------------------
    //
    // Read Registry configuration data
    //
    status = PgmReadRegistryParameters (RegistryPath, &pPgmRegistry);
    if (!NT_SUCCESS(status))
    {
        //
        // There must have been some major problems with the registry read, so we will not load!
        //
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "InitPgm",
            "FAILed to read registry, status = <%x>\n", status);
        CleanupInit (E_CLEANUP_DYNAMIC_CONFIG);
        return (status);
    }
    ASSERT (pPgmRegistry);
    pPgmRegistryConfig = pPgmRegistry;

    //---------------------------------------------------------------------------------------

    //
    // Allocate the data structures we need at Init time
    //
    status = AllocateInitialPgmStructures ();
    if (!NT_SUCCESS(status))
    {
        //
        // There must have been some major problems with the registry read, so we will not load!
        //
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "InitPgm",
            "FAILed to allocate initial structures = <%x>\n", status);
        CleanupInit (E_CLEANUP_REGISTRY_PARAMETERS);
        return (status);
    }

    //---------------------------------------------------------------------------------------
    //
    // Create the Pgm Device to be exported
    //
    status = PgmCreateDevice ();
    if (!NT_SUCCESS(status))
    {
        //
        // There must have been some major problems with the registry read, so we will not load!
        //
        PgmLog (PGM_LOG_ERROR, DBG_INIT_PGM, "InitPgm",
            "FAILed to create PgmDevice, status=<%x>\n", status);
        CleanupInit (E_CLEANUP_STRUCTURES);
        return (status);
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_INIT_PGM, "InitPgm",
        "SUCCEEDed!\n");

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\query.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Query.c

Abstract:

    This module implements Query handling routines
    for the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
// #pragma alloc_text(PAGE, PgmQueryInformation)    Should not be pageable!
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
QueryAddressCompletion(
    IN PDEVICE_OBJECT   pDeviceContext,
    IN  PIRP            pIrp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine handles the completion event when the Query address
    Information completes.

Arguments:

    IN  pDeviceContext  -- unused.
    IN  pIrp         -- Supplies Irp that the transport has finished processing.
    IN  Context         -- not used

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    tTDI_QUERY_ADDRESS_INFO                 *pTdiQueryInfo;
    PIO_STACK_LOCATION                      pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    tCOMMON_SESSION_CONTEXT                 *pSession = pIrpSp->FileObject->FsContext;

    if ((NT_SUCCESS (pIrp->IoStatus.Status)) &&
        (pTdiQueryInfo = (tTDI_QUERY_ADDRESS_INFO *) MmGetSystemAddressForMdlSafe (pIrp->MdlAddress,
                                                                                   HighPagePriority)))
    {
        if (PGM_VERIFY_HANDLE3 (pSession, PGM_VERIFY_SESSION_UNASSOCIATED,
                                          PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE))
        {
            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_QUERY, "QueryAddressCompletion",
                "Tdi IpAddress=<%x>, Port=<%x>\n",
                    ((PTDI_ADDRESS_IP) &pTdiQueryInfo->IpAddress.Address[0].Address)->in_addr,
                    ((PTDI_ADDRESS_IP) &pTdiQueryInfo->IpAddress.Address[0].Address)->sin_port);

            //
            // Save the transport's address information in our own structure!
            //
            pSession->TdiIpAddress =((PTDI_ADDRESS_IP) &pTdiQueryInfo->IpAddress.Address[0].Address)->in_addr;
            pSession->TdiPort = ((PTDI_ADDRESS_IP) &pTdiQueryInfo->IpAddress.Address[0].Address)->sin_port;
        }
        else
        {
            PgmLog (PGM_LOG_ERROR, DBG_QUERY, "QueryAddressCompletion",
                "Invalid Session Context <%x>\n", pSession);
        }
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_QUERY, "QueryAddressCompletion",
            "Transport returned <%x>, pTdiQueryInfo=<%x>\n", pIrp->IoStatus.Status, pTdiQueryInfo);
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back into the users buffer.
    //
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
QueryProviderCompletion(
    IN PDEVICE_OBJECT   pDeviceContext,
    IN  PIRP            pIrp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine handles the completion event when the Query Provider
    Information completes.  This routine must decrement the MaxDgramSize
    and max send size by the respective NBT header sizes.

Arguments:

    IN  pDeviceContext  -- unused.
    IN  pIrp         -- Supplies Irp that the transport has finished processing.
    IN  Context         -- not used

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PTDI_PROVIDER_INFO      pProvider;

    if ((NT_SUCCESS (pIrp->IoStatus.Status)) &&
        (pProvider = (PTDI_PROVIDER_INFO) MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority)))
    {

        //
        // Set the correct service flags to indicate what Pgm supports.
        //
        pProvider->ServiceFlags = TDI_SERVICE_MESSAGE_MODE          |
                                  TDI_SERVICE_CONNECTION_MODE       |
                                  TDI_SERVICE_ERROR_FREE_DELIVERY   |
                                  TDI_SERVICE_MULTICAST_SUPPORTED   |
                                  TDI_SERVICE_NO_ZERO_LENGTH        |
                                  TDI_SERVICE_FORCE_ACCESS_CHECK    |
                                  TDI_SERVICE_ROUTE_DIRECTED;

/*
    ISSUE: Do we need: TDI_SERVICE_INTERNAL_BUFFERING ?
                        TDI_SERVICE_FORCE_ACCESS_CHECK ?
                        TDI_SERVICE_CONNECTIONLESS_MODE ?
                        TDI_SERVICE_DELAYED_ACCEPTANCE ?
                        TDI_SERVICE_BROADCAST_SUPPORTED ?
*/
        pProvider->MinimumLookaheadData = 1;

        //
        // The following data is for Streams
        //
        pProvider->MaxSendSize = SENDER_MAX_WINDOW_SIZE_PACKETS;

        if (pProvider->MaxDatagramSize > PGM_MAX_FEC_DATA_HEADER_LENGTH)
        {
            pProvider->MaxDatagramSize -= PGM_MAX_FEC_DATA_HEADER_LENGTH;
        }
        else
        {
            pProvider->MaxDatagramSize = 0;
        }

        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_QUERY, "QueryProviderCompletion",
            "SvcFlags=<%x> MaxSendSize=<%d>, MaxDgramSize=<%d>\n",
                pProvider->ServiceFlags, pProvider->MaxSendSize, pProvider->MaxDatagramSize);
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_QUERY, "QueryProviderCompletion",
            "Transport returned <%x>, pProvider=<%x>\n", pIrp->IoStatus.Status, pProvider);
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back into the users buffer.
    //
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
PgmQueryInformation(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine performs the TdiQueryInformation request for the transport
    provider.

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS                                status = STATUS_NOT_IMPLEMENTED;
    ULONG                                   Size, BytesCopied = 0;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION   Query;
    tTDI_QUERY_ADDRESS_INFO                 TdiQueryInfo;
    tADDRESS_CONTEXT                        *pAddress = pIrpSp->FileObject->FsContext;
    tCOMMON_SESSION_CONTEXT                 *pSession = pIrpSp->FileObject->FsContext;

    Query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION) &pIrpSp->Parameters;

    switch (Query->QueryType)
    {
        case TDI_QUERY_PROVIDER_INFO:
        {
            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_QUERY, "PgmQueryInformation",
                "[TDI_QUERY_PROVIDER_INFO]:\n");

            TdiBuildQueryInformation (pIrp,
                                      pPgmDevice->pControlDeviceObject,
                                      pPgmDevice->pControlFileObject,
                                      QueryProviderCompletion,
                                      NULL,
                                      TDI_QUERY_PROVIDER_INFO,
                                      pIrp->MdlAddress);

            status = IoCallDriver (pPgmDevice->pControlDeviceObject, pIrp);
            //
            // we must return the next drivers ret code back to the IO subsystem
            //
            status = STATUS_PENDING;
            break;
        }

        case TDI_QUERY_ADDRESS_INFO:
        {
            if (pIrp->MdlAddress)
            {
                if (PGM_VERIFY_HANDLE2 (pAddress, PGM_VERIFY_ADDRESS, PGM_VERIFY_ADDRESS_DOWN))
                {
                    PgmZeroMemory (&TdiQueryInfo, sizeof (tTDI_QUERY_ADDRESS_INFO));
                    TdiQueryInfo.ActivityCount = 1;
                    TdiQueryInfo.IpAddress.TAAddressCount = 1;
                    TdiQueryInfo.IpAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
                    TdiQueryInfo.IpAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
                    ((PTDI_ADDRESS_IP) &TdiQueryInfo.IpAddress.Address[0].Address)->in_addr =
                        htonl (pAddress->ReceiverMCastAddr);
                    ((PTDI_ADDRESS_IP) &TdiQueryInfo.IpAddress.Address[0].Address)->sin_port =
                        htons (pAddress->ReceiverMCastPort);

                    //
                    // Due to the structure being Unaligned, we cannot reference the address
                    // and port fields directly!
                    //
                    Size = offsetof (tTDI_QUERY_ADDRESS_INFO, IpAddress.Address[0].Address)
                           + sizeof(TDI_ADDRESS_IP);

                    status = TdiCopyBufferToMdl (&TdiQueryInfo, 0, Size, pIrp->MdlAddress, 0, &BytesCopied);
                    pIrp->IoStatus.Information = BytesCopied;

                    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_QUERY, "PgmQueryInformation",
                        "[ADDRESS_INFO]: pAddress=<%x>, Copied=<%d/%d>\n", pAddress, BytesCopied, Size);

                    break;
                }
                else if (PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE))
                {
                    if ((pAddress = pSession->pAssociatedAddress) &&
                        (PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)))
                    {
                        TdiBuildQueryInformation (pIrp,
                                                  pAddress->pDeviceObject,
                                                  pAddress->pFileObject,
                                                  QueryAddressCompletion,
                                                  NULL,
                                                  TDI_QUERY_ADDRESS_INFO,
                                                  pIrp->MdlAddress);

                        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_QUERY, "PgmQueryInformation",
                            "[ADDRESS_INFO]: pSession=<%x>, querying transport ...\n", pSession);

                        status = IoCallDriver (pPgmDevice->pControlDeviceObject, pIrp);
                        //
                        // we must return the next drivers ret code back to the IO subsystem
                        //
                        status = STATUS_PENDING;
                    }
                    else
                    {
                        PgmLog (PGM_LOG_ERROR, DBG_QUERY, "PgmQueryInformation",
                            "[ADDRESS_INFO]: pSession=<%x>, Invalid pAddress=<%x>\n", pSession, pAddress);

                        status = STATUS_INVALID_HANDLE;
                    }

                    break;
                }
                else    // neither an address nor a connect context!
                {
                    PgmLog (PGM_LOG_ERROR, DBG_QUERY, "PgmQueryInformation",
                        "[TDI_QUERY_ADDRESS_INFO]: Invalid Handle=<%x>\n", pIrpSp->FileObject->FsContext);

                    status = STATUS_INVALID_HANDLE;
                }
            }
            else
            {
                PgmLog (PGM_LOG_ERROR, DBG_QUERY, "PgmQueryInformation",
                    "[TDI_QUERY_ADDRESS_INFO]: No Mdl, pIrp=<%x>\n", pIrp);

                status = STATUS_UNSUCCESSFUL;
            }

            break;
        }

        default:
        {
            PgmLog (PGM_LOG_ERROR, DBG_QUERY, "PgmQueryInformation",
                "Query=<%d> not Implemented!\n", Query->QueryType);

            break;
        }
    }

    return (status);
}
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\send.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Send.c

Abstract:

    This module implements Send routines
    the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
InitDataSpmOptions(
    IN      tCOMMON_SESSION_CONTEXT *pSession,
    IN      tCLIENT_SEND_REQUEST    *pSendContext,
    IN      PUCHAR                  pOptions,
    IN OUT  USHORT                  *pBufferSize,
    IN      ULONG                   PgmOptionsFlag,
    IN      tPACKET_OPTIONS         *pPacketOptions
    )
/*++

Routine Description:

    This routine initializes the header options for Data and Spm packets

Arguments:

    IN      pOptions                    -- Options buffer
    IN OUT  pBufferSize                 -- IN Maximum packet size, OUT Options length
    IN      PgmOptionsFlag              -- Options requested to be set by caller
    IN      pPacketOptions              -- Data for specific options
    IN      pSendContext                -- Context for this send

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    ULONG                               pOptionsData[3];
    USHORT                              OptionsLength = 0;
    USHORT                              MaxBufferSize = *pBufferSize;
    tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader;
    tPACKET_OPTION_LENGTH  UNALIGNED    *pLengthOption = (tPACKET_OPTION_LENGTH UNALIGNED *) pOptions;

    //
    // Set the Packet Extension information
    //
    OptionsLength += PGM_PACKET_EXTENSION_LENGTH;
    if (OptionsLength > MaxBufferSize)
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmOptions",
            "Not enough space for HeaderExtension! <%d> > <%d>\n", OptionsLength, MaxBufferSize);
        return (STATUS_INVALID_BLOCK_LENGTH);
    }
    pLengthOption->Type = PACKET_OPTION_LENGTH;
    pLengthOption->Length = PGM_PACKET_EXTENSION_LENGTH;
    
    //
    // First fill in the Network-Element-specific options:
    //
    if (PgmOptionsFlag & (PGM_OPTION_FLAG_CRQST | PGM_OPTION_FLAG_NBR_UNREACH))
    {
        // Not supporting these options for now
        ASSERT (0);
        return (STATUS_NOT_SUPPORTED);
    }

    if (PgmOptionsFlag & PGM_OPTION_FLAG_PARITY_PRM)
    {
        //
        // Applies to SPMs only
        //
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_PARITY_PRM_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
                "Not enough space for PARITY_PRM Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize);
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_PARITY_PRM;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_PARITY_PRM_LENGTH;

        pOptionHeader->U_OptSpecific = pSession->FECOptions;
        pOptionsData[0] = htonl (pPacketOptions->FECContext.FECGroupInfo);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (sizeof(ULONG)));
    }

    if (PgmOptionsFlag & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
    {
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
                "Not enough space for PARITY_CUR_TGSIZE Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize);
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_CURR_TGSIZE;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH;
        pOptionsData[0] = htonl (pPacketOptions->FECContext.NumPacketsInThisGroup);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (sizeof(ULONG)));
    }

    //
    // Now, fill in the non-Network significant options
    //
    if (PgmOptionsFlag & PGM_OPTION_FLAG_SYN)
    {
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_SYN_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmOptions",
                "Not enough space for SYN Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize);
            return (STATUS_INVALID_BLOCK_LENGTH);
        }

        pOptionHeader->E_OptionType = PACKET_OPTION_SYN;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_SYN_LENGTH;

        if ((pSendContext) &&
            (pSendContext->DataOptions & PGM_OPTION_FLAG_SYN))
        {
            //
            // Remove this option once it has been used!
            //
            pSendContext->DataOptions &= ~PGM_OPTION_FLAG_SYN;
            pSendContext->DataOptionsLength -= PGM_PACKET_OPT_SYN_LENGTH;
            if (!pSendContext->DataOptions)
            {
                // No other options, so set the length to 0
                pSendContext->DataOptionsLength = 0;
            }
        }
    }

    if (PgmOptionsFlag & PGM_OPTION_FLAG_FIN)
    {
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_FIN_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmOptions",
                "Not enough space for FIN Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize);
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_FIN;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_FIN_LENGTH;
    }

    if (PgmOptionsFlag & (PGM_OPTION_FLAG_RST | PGM_OPTION_FLAG_RST_N))
    {
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_RST_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmOptions",
                "Not enough space for RST Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize);
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_RST;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_RST_LENGTH;
        if (PgmOptionsFlag & PGM_OPTION_FLAG_RST_N)
        {
            pOptionHeader->U_OptSpecific = PACKET_OPTION_SPECIFIC_RST_N_BIT;
        }
    }

    //
    // now, set the FEC-specific options
    //
    if (PgmOptionsFlag & PGM_OPTION_FLAG_PARITY_GRP)
    {
        //
        // Applies to Parity packets only
        //
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_PARITY_GRP_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmOptions",
                "Not enough space for PARITY_GRP Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize);
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_PARITY_GRP;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_PARITY_GRP_LENGTH;

        pOptionsData[0] = htonl (pPacketOptions->FECContext.FECGroupInfo);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (sizeof(ULONG)));
    }

    //
    // The following options should always be at the end, since they
    // are never net-sig.
    //
    if (PgmOptionsFlag & PGM_OPTION_FLAG_FRAGMENT)
    {
        pPacketOptions->FragmentOptionOffset = OptionsLength;

        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_FRAGMENT_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmOptions",
                "Not enough space for FragmentExtension! <%d> > <%d>\n", OptionsLength, MaxBufferSize);
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_FRAGMENT;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_FRAGMENT_LENGTH;

        //
        // The PACKET_OPTION_RES_F_OPX_ENCODED_BIT will be set if necessary
        // later since the OptionSpecific component is computed at the same
        // time the entire data is encoded
        //
        pOptionsData[0] = htonl ((ULONG) pPacketOptions->MessageFirstSequence);
        pOptionsData[1] = htonl (pPacketOptions->MessageOffset);
        pOptionsData[2] = htonl (pPacketOptions->MessageLength);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (3 * sizeof(ULONG)));
    }

    if (PgmOptionsFlag & PGM_OPTION_FLAG_JOIN)
    {
        pPacketOptions->LateJoinerOptionOffset = OptionsLength;

        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_JOIN_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmOptions",
                "Not enough space for JOIN Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize);
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_JOIN;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_JOIN_LENGTH;
        pOptionsData[0] = htonl ((ULONG) (SEQ_TYPE) pPacketOptions->LateJoinerSequence);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (sizeof(ULONG)));
    }

    //
    // So far, so good -- so set the rest of the option-specific info
    //
    if (OptionsLength)
    {
        pLengthOption->TotalOptionsLength = htons (OptionsLength);   // Total length of all options
        pOptionHeader->E_OptionType |= PACKET_OPTION_TYPE_END_BIT;        // Indicates the last option
    }

    *pBufferSize = OptionsLength;
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
InitDataSpmHeader(
    IN  tCOMMON_SESSION_CONTEXT *pSession,
    IN  tCLIENT_SEND_REQUEST    *pSendContext,
    IN  PUCHAR                  pHeader,
    IN  OUT USHORT              *pHeaderLength,
    IN  ULONG                   PgmOptionsFlag,
    IN  tPACKET_OPTIONS         *pPacketOptions,
    IN  UCHAR                   PacketType
    )
/*++

Routine Description:

    This routine initializes most of the header for Data and Spm packets
    and fills in all of the optional fields

Arguments:

    IN  pSession                    -- Pgm session (sender) context
    IN  pHeader                     -- Packet buffer
    IN  pHeaderLength               -- Maximum packet size
    IN  PgmOptionsFlag              -- Options requested to be set by caller
    IN  pPacketOptions              -- Data for specific options
    IN  PacketType                  -- whether Data or Spm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    tCOMMON_HEADER                      *pCommonHeader = (tCOMMON_HEADER *) pHeader;
    USHORT                              HeaderLength;
    USHORT                              OptionsLength;
    NTSTATUS                            status = STATUS_SUCCESS;

// NOTE:  Session Lock must be held on Entry and Exit!

    if (!(PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_DOWN)))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
            "Bad Session ptr = <%p>\n", pSession);
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // Memory for the Header must have been pre-allocated by the caller
    //
    if (*pHeaderLength < sizeof (tCOMMON_HEADER))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
            "InBufferLength = <%x> < Min = <%d>\n", *pHeaderLength, sizeof (tCOMMON_HEADER));
        return (STATUS_INVALID_BUFFER_SIZE);
    }

    pCommonHeader->SrcPort = htons (pSession->TSIPort);
    pCommonHeader->DestPort = htons (pSession->pSender->DestMCastPort);
    pCommonHeader->Type = PacketType;
    pCommonHeader->Options = 0;
    PgmCopyMemory (&pCommonHeader->gSourceId, &pSession->GSI, SOURCE_ID_LENGTH);

    //
    // Now, set the initial header size and verify that we have a
    // valid set of options based on the Packet type
    //
    switch (PacketType)
    {
        case (PACKET_TYPE_SPM):
        {
            HeaderLength = sizeof (tBASIC_SPM_PACKET_HEADER);
            if (PgmOptionsFlag != (PGM_VALID_SPM_OPTION_FLAGS & PgmOptionsFlag))
            {
                PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
                    "Unsupported Options flags=<%x> for SPM packets\n", PgmOptionsFlag);

                return (STATUS_INVALID_PARAMETER);
            }

            if (PgmOptionsFlag & NETWORK_SIG_SPM_OPTIONS_FLAGS)
            {
                pCommonHeader->Options |= PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT;
            }

            break;
        }

        case (PACKET_TYPE_ODATA):
        {
            HeaderLength = sizeof (tBASIC_DATA_PACKET_HEADER);
            if (PgmOptionsFlag != (PGM_VALID_DATA_OPTION_FLAGS & PgmOptionsFlag))
            {
                PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
                    "Unsupported Options flags=<%x> for ODATA packets\n", PgmOptionsFlag);

                return (STATUS_INVALID_PARAMETER);
            }

            if (PgmOptionsFlag & NETWORK_SIG_ODATA_OPTIONS_FLAGS)
            {
                pCommonHeader->Options |= PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT;
            }

            break;
        }

        case (PACKET_TYPE_RDATA):
        {
            HeaderLength = sizeof (tBASIC_DATA_PACKET_HEADER);
            if (PgmOptionsFlag != (PGM_VALID_DATA_OPTION_FLAGS & PgmOptionsFlag))
            {
                PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
                    "Unsupported Options flags=<%x> for RDATA packets\n", PgmOptionsFlag);

                return (STATUS_INVALID_PARAMETER);
            }

            if (PgmOptionsFlag & NETWORK_SIG_RDATA_OPTIONS_FLAGS)
            {
                pCommonHeader->Options |= PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT;
            }

            break;
        }

        default:
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
                "Unsupported packet type = <%x>\n", PacketType);

            return (STATUS_INVALID_PARAMETER);          // Unrecognized Packet type!
        }
    }

    if (*pHeaderLength < HeaderLength)
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
            "InBufferLength=<%x> < HeaderLength=<%d> based on PacketType=<%x>\n",
                *pHeaderLength, HeaderLength, PacketType);

        return (STATUS_INVALID_BLOCK_LENGTH);
    }

    //  
    // Add any options if specified
    //
    OptionsLength = 0;
    if (PgmOptionsFlag)
    {
        OptionsLength = *pHeaderLength - HeaderLength;
        status = InitDataSpmOptions (pSession,
                                     pSendContext,
                                     &pHeader[HeaderLength],
                                     &OptionsLength,
                                     PgmOptionsFlag,
                                     pPacketOptions);

        if (!NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "InitDataSpmHeader",
                "InitDataSpmOptions returned <%x>\n", status);

            return (status);
        }

        //
        // So far, so good -- so set the rest of the option-specific info
        //
        pCommonHeader->Options |= PACKET_HEADER_OPTIONS_PRESENT;        // Set the options bit
    }

    //
    // The caller must now set the Checksum and other header information
    //
    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "InitDataSpmHeader",
        "pHeader=<%p>, HeaderLength=<%d>, OptionsLength=<%d>\n",
            pHeader, (ULONG) HeaderLength, (ULONG) OptionsLength);

    *pHeaderLength = HeaderLength + OptionsLength;

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

VOID
PgmSendSpmCompletion(
    IN  tSEND_SESSION                   *pSend,
    IN  tBASIC_SPM_PACKET_HEADER        *pSpmPacket,
    IN  NTSTATUS                        status
    )
/*++

Routine Description:

    This routine is called by the transport when the Spm send has been completed

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pSpmPacket  -- Spm packet buffer
    IN  status      --

Return Value:

    NONE

--*/
{
    PGMLockHandle               OldIrq;

    PgmLock (pSend, OldIrq);
    if (NT_SUCCESS (status))
    {
        //
        // Set the Spm statistics
        //
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendSpmCompletion",
            "SUCCEEDED\n");
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendSpmCompletion",
            "status=<%x>\n", status);
    }
    PgmUnlock (pSend, OldIrq);

    PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_SPM);

    //
    // Free the Memory that was allocated for this
    //
    PgmFreeMem (pSpmPacket);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendSpm(
    IN  tSEND_SESSION   *pSend,
    IN  PGMLockHandle   *pOldIrq,
    OUT ULONG           *pBytesSent
    )
/*++

Routine Description:

    This routine is called to send an Spm packet
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pOldIrq     -- pSend's OldIrq
    OUT pBytesSent  -- Set if send succeeded (used for calculating throughput)

Return Value:

    NTSTATUS - Final status of the send

--*/
{
    NTSTATUS                    status;
    ULONG                       XSum, OptionsFlags;
    tBASIC_SPM_PACKET_HEADER    *pSpmPacket = NULL;
    tPACKET_OPTIONS             PacketOptions;
    USHORT                      PacketLength = (USHORT) pSend->pSender->pAddress->OutIfMTU;   // Init to max

    *pBytesSent = 0;

    if (!(pSpmPacket = PgmAllocMem (PacketLength, PGM_TAG('2'))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendSpm",
            "STATUS_INSUFFICIENT_RESOURCES\n");
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    PgmZeroMemory (pSpmPacket, PacketLength);
    PgmZeroMemory (&PacketOptions, sizeof(tPACKET_OPTIONS));

    OptionsFlags = pSend->pSender->SpmOptions;
    if (OptionsFlags & PGM_OPTION_FLAG_JOIN)
    {
        //
        // See if we have enough packets for the LateJoiner sequence numbers
        //
        if (SEQ_GT (pSend->pSender->LastODataSentSequenceNumber, (pSend->pSender->TrailingGroupSequenceNumber +
                                                                  pSend->pSender->LateJoinSequenceNumbers)))
        {
            PacketOptions.LateJoinerSequence = (ULONG) (SEQ_TYPE) (pSend->pSender->LastODataSentSequenceNumber -
                                                                   pSend->pSender->LateJoinSequenceNumbers);
        }
        else
        {
            PacketOptions.LateJoinerSequence = (ULONG) (SEQ_TYPE) pSend->pSender->TrailingGroupSequenceNumber;
        }
    }

    if (OptionsFlags & PGM_OPTION_FLAG_PARITY_PRM)    // Check if this is FEC-enabled
    {
        PacketOptions.FECContext.FECGroupInfo = pSend->FECGroupSize;

        //
        // See if we need to set the CURR_TGSIZE option for variable Group length
        //
        if ((pSend->pSender->EmptySequencesForLastSend) &&
            (pSend->pSender->LastVariableTGPacketSequenceNumber ==
             (pSend->pSender->LastODataSentSequenceNumber - pSend->pSender->EmptySequencesForLastSend)))
        {
            PacketOptions.FECContext.NumPacketsInThisGroup = pSend->FECGroupSize -
                                                             (UCHAR)pSend->pSender->EmptySequencesForLastSend;
            OptionsFlags |= PGM_OPTION_FLAG_PARITY_CUR_TGSIZE;
            ASSERT (PacketOptions.FECContext.NumPacketsInThisGroup);
        }
    }

    status = InitDataSpmHeader (pSend,
                                NULL,
                                (PUCHAR) pSpmPacket,
                                &PacketLength,
                                OptionsFlags,
                                &PacketOptions,
                                PACKET_TYPE_SPM);

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendSpm",
            "InitDataSpmHeader returned <%x>\n", status);

        PgmFreeMem (pSpmPacket);
        return (status);
    }

    ASSERT (PacketLength);

    pSpmPacket->SpmSequenceNumber = htonl ((ULONG) pSend->pSender->NextSpmSequenceNumber++);
    pSpmPacket->TrailingEdgeSeqNumber = htonl ((ULONG) pSend->pSender->TrailingGroupSequenceNumber);
    pSpmPacket->LeadingEdgeSeqNumber = htonl ((ULONG)((SEQ_TYPE)(pSend->pSender->LastODataSentSequenceNumber -
                                                                 pSend->pSender->EmptySequencesForLastSend)));
    pSpmPacket->PathNLA.NLA_AFI = htons (IPV4_NLA_AFI);
    pSpmPacket->PathNLA.IpAddress = htonl (pSend->pSender->SenderMCastOutIf);

    pSpmPacket->CommonHeader.Checksum = 0;
    XSum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pSpmPacket, PacketLength);       // Compute the Checksum
    pSpmPacket->CommonHeader.Checksum = (USHORT) (~XSum);

    PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_SPM, TRUE);
    PgmUnlock (pSend, *pOldIrq);

    status = TdiSendDatagram (pSend->pSender->pAddress->pRAlertFileObject,
                              pSend->pSender->pAddress->pRAlertDeviceObject,
                              pSpmPacket,
                              PacketLength,
                              PgmSendSpmCompletion,     // Completion
                              pSend,                    // Context1
                              pSpmPacket,               // Context2
                              pSend->pSender->DestMCastIpAddress,
                              pSend->pSender->DestMCastPort);

    ASSERT (NT_SUCCESS (status));

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendSpm",
        "Sent <%d> bytes to <%x:%d>, Options=<%x>, Window=[%d--%d]\n",
            (ULONG) PacketLength, pSend->pSender->DestMCastIpAddress, pSend->pSender->DestMCastPort,
            OptionsFlags, (ULONG) pSend->pSender->TrailingGroupSequenceNumber,
            (ULONG) pSend->pSender->LastODataSentSequenceNumber);

    PgmLock (pSend, *pOldIrq);

    *pBytesSent = PacketLength;
    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmSendRDataCompletion(
    IN  tSEND_RDATA_CONTEXT *pRDataContext,
    IN  PVOID               pRDataBuffer,
    IN  NTSTATUS            status
    )
/*++

Routine Description:

    This routine is called by the transport when the RData send has been completed

Arguments:

    IN  pRDataContext   -- RData context
    IN  pContext2       -- not used
    IN  status          --

Return Value:

    NONE

--*/
{
    tSEND_SESSION       *pSend = pRDataContext->pSend;
    PGMLockHandle       OldIrq;

    ASSERT (NT_SUCCESS (status));

    //
    // Set the RData statistics
    //
    PgmLock (pSend, OldIrq);
    if ((!--pRDataContext->NumPacketsInTransport) &&
        (!pRDataContext->NumNaks))
    {
        pRDataContext->CleanupTime = pSend->pSender->TimerTickCount + pRDataContext->PostRDataHoldTime;
    }
    PgmUnlock (pSend, OldIrq);

    if (pRDataBuffer)
    {
        ExFreeToNPagedLookasideList (&pSend->pSender->SenderBufferLookaside, pRDataBuffer);
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendRDataCompletion",
        "status=<%x>, pRDataBuffer=<%p>\n", status, pRDataBuffer);

    PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_RDATA);
    return;
}


//----------------------------------------------------------------------------

NTSTATUS
PgmBuildParityPacket(
    IN  tSEND_SESSION               *pSend,
    IN  tPACKET_BUFFER              *pPacketBuffer,
    IN  tBUILD_PARITY_CONTEXT       *pParityContext,
    IN  PUCHAR                      pFECPacket,
    IN OUT  USHORT                  *pPacketLength,
    IN  UCHAR                       PacketType
    )
{
    NTSTATUS                            status;
    tPACKET_OPTIONS                     PacketOptions;
    tPOST_PACKET_FEC_CONTEXT UNALIGNED  *pFECContext;
    tPOST_PACKET_FEC_CONTEXT            FECContext;
    ULONG                               SequenceNumber;
    ULONG                               FECGroupMask;
    tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader;
    USHORT                              PacketLength = *pPacketLength;  // Init to max buffer length
    tBASIC_DATA_PACKET_HEADER UNALIGNED *pRData = (tBASIC_DATA_PACKET_HEADER UNALIGNED *)
                                                        &pPacketBuffer->DataPacket;

    *pPacketLength = 0;     // Init, in case of error

    //
    // First, get the options encoded in this RData packet to see
    // if we need to use them!
    //
    FECGroupMask = pSend->FECGroupSize - 1;
    pParityContext->NextFECPacketIndex = pPacketBuffer->PacketOptions.FECContext.SenderNextFECPacketIndex;
    SequenceNumber = (ntohl(pRData->DataSequenceNumber)) | (pParityContext->NextFECPacketIndex & FECGroupMask);
    ASSERT (!(pParityContext->OptionsFlags & ~(PGM_OPTION_FLAG_SYN |
                                               PGM_OPTION_FLAG_FIN |
                                               PGM_OPTION_FLAG_FRAGMENT |
                                               PGM_OPTION_FLAG_PARITY_CUR_TGSIZE |
                                               PGM_OPTION_FLAG_PARITY_GRP)));

    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));

    //
    // We don't need to set any parameters for the SYN and FIN options
    // We will set the parameters for the FRAGMENT option (if needed) later
    // since will need to have the encoded paramters
    //
    if (pParityContext->OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
    {
        ASSERT (pParityContext->NumPacketsInThisGroup);
        PacketOptions.FECContext.NumPacketsInThisGroup = pParityContext->NumPacketsInThisGroup;
    }

    if (pParityContext->NextFECPacketIndex >= pSend->FECGroupSize)
    {
        pParityContext->OptionsFlags |= PGM_OPTION_FLAG_PARITY_GRP;
        PacketOptions.FECContext.FECGroupInfo = pParityContext->NextFECPacketIndex / pSend->FECGroupSize;
    }

    PgmZeroMemory (pFECPacket, PacketLength);
    status = InitDataSpmHeader (pSend,
                                NULL,
                                (PUCHAR) pFECPacket,
                                &PacketLength,
                                pParityContext->OptionsFlags,
                                &PacketOptions,
                                PacketType);

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmBuildParityPacket",
            "InitDataSpmHeader returned <%x>\n", status);
        return (status);
    }

    status = FECEncode (&pSend->FECContext,
                        &pParityContext->pDataBuffers[0],
                        pParityContext->NumPacketsInThisGroup,
                        (pSend->pSender->MaxPayloadSize + sizeof (tPOST_PACKET_FEC_CONTEXT)),
                        pParityContext->NextFECPacketIndex,
                        &pFECPacket[PacketLength]);

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmBuildParityPacket",
            "FECEncode returned <%x>\n", status);
        return (status);
    }

    //
    // Now, fill in the remaining fields of the header
    //
    pRData = (tBASIC_DATA_PACKET_HEADER *) pFECPacket;

    //
    // Set the FEC-specific options
    //
    pRData->CommonHeader.Options |= (PACKET_HEADER_OPTIONS_PARITY |
                                     PACKET_HEADER_OPTIONS_VAR_PKTLEN);

    if (pParityContext->OptionsFlags & PGM_OPTION_FLAG_FRAGMENT)
    {
        pFECContext = (tPOST_PACKET_FEC_CONTEXT UNALIGNED *) (pFECPacket +
                                                              PacketLength +
                                                              pSend->pSender->MaxPayloadSize);
        PgmCopyMemory (&FECContext, pFECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));

        ASSERT (pRData->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT);
        if (PacketOptions.FragmentOptionOffset)
        {
            pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &((PUCHAR) (pRData + 1)) [PacketOptions.FragmentOptionOffset];

            pOptionHeader->Reserved_F_Opx |= PACKET_OPTION_RES_F_OPX_ENCODED_BIT;
            pOptionHeader->U_OptSpecific = FECContext.FragmentOptSpecific;

            PgmCopyMemory ((pOptionHeader + 1),
                           &FECContext.EncodedFragmentOptions,
                           (sizeof (tFRAGMENT_OPTIONS)));
        }
        else
        {
            ASSERT (0);
        }
    }

    pRData->CommonHeader.TSDULength = htons ((USHORT) pSend->pSender->MaxPayloadSize + sizeof (USHORT));
    pRData->DataSequenceNumber = htonl (SequenceNumber);

    //
    // Set the next FECPacketIndex
    //
    if (++pParityContext->NextFECPacketIndex >= pSend->FECBlockSize)    // n
    {
        pParityContext->NextFECPacketIndex = pSend->FECGroupSize;       // k
    }
    pPacketBuffer->PacketOptions.FECContext.SenderNextFECPacketIndex = pParityContext->NextFECPacketIndex;

    PacketLength += (USHORT) (pSend->pSender->MaxPayloadSize + sizeof (USHORT));
    *pPacketLength = PacketLength;
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendRData(
    IN      tSEND_SESSION       *pSend,
    IN      tSEND_RDATA_CONTEXT *pRDataContext,
    IN      PGMLockHandle       *pOldIrq,
    OUT     ULONG               *pBytesSent
    )
/*++

Routine Description:

    This routine is called to send a Repair Data (RData) packet
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pOldIrq     -- pSend's OldIrq
    OUT pBytesSent  -- Set if send succeeded (used for calculating throughput)

Arguments:

    IN

Return Value:

    NTSTATUS - Final status of the send request

--*/
{
    NTSTATUS                    status;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached, fInserted;
    LIST_ENTRY                  *pEntry;
    ULONGLONG                   OffsetBytes;
    ULONG                       XSum, PacketsBehindLeadingEdge;
    tBASIC_DATA_PACKET_HEADER   *pRData;
    PUCHAR                      pSendBuffer = NULL;
    USHORT                      i, PacketLength;
    tPACKET_BUFFER              *pPacketBuffer;
    tPACKET_BUFFER              *pPacketBufferTemp;
    tSEND_RDATA_CONTEXT         *pRDataTemp;

    *pBytesSent = 0;

    ASSERT (SEQ_LEQ (pRDataContext->RDataSequenceNumber, pSend->pSender->LastODataSentSequenceNumber) &&
            SEQ_GEQ (pRDataContext->RDataSequenceNumber, pSend->pSender->TrailingGroupSequenceNumber));

    //
    // Find the buffer address based on offset from the trailing edge
    // Also, check for wrap-around
    //
    OffsetBytes = (SEQ_TYPE) (pRDataContext->RDataSequenceNumber-pSend->pSender->TrailingEdgeSequenceNumber) *
                              pSend->pSender->PacketBufferSize;
    OffsetBytes += pSend->pSender->TrailingWindowOffset;
    if (OffsetBytes >= pSend->pSender->MaxDataFileSize)
    {
        OffsetBytes -= pSend->pSender->MaxDataFileSize;             // Wrap -around
    }

    pPacketBuffer = (tPACKET_BUFFER *) (((PUCHAR) pSend->pSender->SendDataBufferMapping) + OffsetBytes);
    pRData = &pPacketBuffer->DataPacket;

    ASSERT (PGM_MAX_FEC_DATA_HEADER_LENGTH >= PGM_MAX_DATA_HEADER_LENGTH);
    PacketLength = PGM_MAX_FEC_DATA_HEADER_LENGTH + (USHORT) pSend->pSender->MaxPayloadSize;
    if (!(pSendBuffer = ExAllocateFromNPagedLookasideList (&pSend->pSender->SenderBufferLookaside)))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendRData",
            "STATUS_INSUFFICIENT_RESOURCES\n");
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // First do some sanity checks!
    //
    ASSERT ((pRDataContext->NakType == NAK_TYPE_PARITY) ||
            (pRDataContext->NumNaks == 1));

    pRDataContext->NumPacketsInTransport++;        // So that this context cannot go away!
    PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_RDATA, TRUE);

    PgmUnlock (pSend, *pOldIrq);
    PgmAttachToProcessForVMAccess (pSend, &ApcState, &fAttached, REF_PROCESS_ATTACH_SEND_RDATA);

    switch (pRDataContext->NakType)
    {
        case (NAK_TYPE_PARITY):
        {
            //
            // If this is the first parity packet to be sent from this group,
            // then we will need to initialize the buffers
            //
            if (!pRDataContext->OnDemandParityContext.NumPacketsInThisGroup)
            {
                pRDataContext->OnDemandParityContext.OptionsFlags = 0;
                pRDataContext->OnDemandParityContext.NumPacketsInThisGroup = 0;

                pPacketBufferTemp = pPacketBuffer;
                for (i=0; i<pSend->FECGroupSize; i++)
                {
                    pRDataContext->OnDemandParityContext.pDataBuffers[i] = &((PUCHAR) &pPacketBufferTemp->DataPacket)
                                                                    [sizeof (tBASIC_DATA_PACKET_HEADER) +
                                                                     pPacketBufferTemp->PacketOptions.OptionsLength];

                    pRDataContext->OnDemandParityContext.OptionsFlags |= pPacketBufferTemp->PacketOptions.OptionsFlags &
                                                                         (PGM_OPTION_FLAG_SYN |
                                                                          PGM_OPTION_FLAG_FIN |
                                                                          PGM_OPTION_FLAG_FRAGMENT |
                                                                          PGM_OPTION_FLAG_PARITY_CUR_TGSIZE);

                    if (pPacketBufferTemp->PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
                    {
                        ASSERT (!pRDataContext->OnDemandParityContext.NumPacketsInThisGroup);
                        ASSERT (pPacketBufferTemp->PacketOptions.FECContext.NumPacketsInThisGroup);
                        pRDataContext->OnDemandParityContext.NumPacketsInThisGroup = pPacketBufferTemp->PacketOptions.FECContext.NumPacketsInThisGroup;
                    }

                    pPacketBufferTemp = (tPACKET_BUFFER *) (((PUCHAR) pPacketBufferTemp) +
                                                            pSend->pSender->PacketBufferSize);
                }

                if (!(pRDataContext->OnDemandParityContext.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE))
                {
                    ASSERT (!pRDataContext->OnDemandParityContext.NumPacketsInThisGroup);
                    pRDataContext->OnDemandParityContext.NumPacketsInThisGroup = pSend->FECGroupSize;
                }
            }

            ASSERT (pRDataContext->OnDemandParityContext.pDataBuffers[0]);

            //
            // If we have just 1 packet in this group, then we just do
            // a selective Nak
            //
            if (pRDataContext->OnDemandParityContext.NumPacketsInThisGroup != 1)
            {
                status = PgmBuildParityPacket (pSend,
                                               pPacketBuffer,
                                               &pRDataContext->OnDemandParityContext,
                                               pSendBuffer,
                                               &PacketLength,
                                               PACKET_TYPE_RDATA);
                if (!NT_SUCCESS (status))
                {
                    PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendRData",
                        "PgmBuildParityPacket returned <%x>\n", status);

                    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_SEND_RDATA);
                    PgmLock (pSend, *pOldIrq);

                    ExFreeToNPagedLookasideList (&pSend->pSender->SenderBufferLookaside, pSendBuffer);
                    pRDataContext->NumPacketsInTransport--;         // Undoing what we did earlier
                    return (status);
                }

                pRData = (tBASIC_DATA_PACKET_HEADER *) pSendBuffer;

                break;
            }

            pRDataContext->NumNaks = 1;     // Don't want to send excessive Selective naks!
        }

        case (NAK_TYPE_SELECTIVE):
        {
            //
            // Since the packet was already filled in earlier, we just need to
            // update the Trailing Edge Seq number + PacketType and Checksum!
            //
            ASSERT ((ULONG) pRDataContext->RDataSequenceNumber == (ULONG) ntohl (pRData->DataSequenceNumber));

            PacketLength = pPacketBuffer->PacketOptions.TotalPacketLength;

            PgmCopyMemory (pSendBuffer, pRData, PacketLength);
            pRData = (tBASIC_DATA_PACKET_HEADER *) pSendBuffer;

            break;
        }

        default:
        {
            ASSERT (0);
        }
    }

    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_SEND_RDATA);

    pRData->TrailingEdgeSequenceNumber = htonl ((ULONG) pSend->pSender->TrailingGroupSequenceNumber);
    pRData->CommonHeader.Type = PACKET_TYPE_RDATA;
    pRData->CommonHeader.Checksum = 0;
    XSum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pRData, (ULONG) PacketLength);       // Compute the Checksum
    pRData->CommonHeader.Checksum = (USHORT) (~XSum);

    status = TdiSendDatagram (pSend->pSender->pAddress->pRAlertFileObject,
                              pSend->pSender->pAddress->pRAlertDeviceObject,
                              pRData,
                              (ULONG) PacketLength,
                              PgmSendRDataCompletion,                                   // Completion
                              pRDataContext,                                            // Context1
                              pSendBuffer,                                               // Context2
                              pSend->pSender->DestMCastIpAddress,
                              pSend->pSender->DestMCastPort);

    ASSERT (NT_SUCCESS (status));

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendRData",
        "[%d] Sent <%d> bytes to <%x->%d>\n",
            (ULONG) pRDataContext->RDataSequenceNumber, (ULONG) PacketLength,
            pSend->pSender->DestMCastIpAddress, pSend->pSender->DestMCastPort);

    PgmLock (pSend, *pOldIrq);

    if (!--pRDataContext->NumNaks)
    {
        RemoveEntryList (&pRDataContext->Linkage);
        //
        // The Handled list has to be sorted for FilterAndAddNaksToList to work
        // We will traverse the list backwards since there is a higher
        // probability of inserting this context near the end of the list
        // So, we will try to find an element we can insert after
        //
        fInserted = FALSE;
        pEntry = &pSend->pSender->HandledRDataRequests;
        while ((pEntry = pEntry->Blink) != &pSend->pSender->HandledRDataRequests)
        {
            pRDataTemp = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);

            //
            // Sequences greater than this can be skipped
            //
            if (SEQ_GT (pRDataTemp->RDataSequenceNumber, pRDataContext->RDataSequenceNumber))
            {
                continue;
            }

            //
            // We will always order the Parity Nak before the Selective Nak
            // Both the Nak types should not exist in the list for the
            // same sequence number
            //
            if ((pRDataTemp->RDataSequenceNumber == pRDataContext->RDataSequenceNumber) &&
                (pRDataTemp->NakType == NAK_TYPE_SELECTIVE))
            {
                ASSERT (pRDataTemp->NakType != pRDataContext->NakType);
                continue;
            }

            pRDataContext->Linkage.Blink = pEntry;
            pRDataContext->Linkage.Flink = pEntry->Flink;
            pEntry->Flink->Blink = &pRDataContext->Linkage;
            pEntry->Flink = &pRDataContext->Linkage;

            fInserted = TRUE;
            break;
        }

        if (!fInserted)
        {
            InsertHeadList (&pSend->pSender->HandledRDataRequests, &pRDataContext->Linkage);
        }

        pSend->pSender->NumRDataRequestsPending--;

        //
        // If the SendCompletion was called before this point, then we will
        // need to set the CleanupTime outselves
        //
        if (!pRDataContext->NumPacketsInTransport)
        {
            pRDataContext->CleanupTime = pSend->pSender->TimerTickCount + pRDataContext->PostRDataHoldTime;
        }
    }

    pSend->pSender->NumOutstandingNaks--;
    pSend->pSender->RepairPacketsSent++;

    *pBytesSent = PacketLength;
    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmSendNcfCompletion(
    IN  tSEND_SESSION                   *pSend,
    IN  tBASIC_NAK_NCF_PACKET_HEADER    *pNcfPacket,
    IN  NTSTATUS                        status
    )
/*++

Routine Description:

    This routine is called by the transport when the Ncf send has been completed

Arguments:

    IN  pSend           -- Pgm session (sender) context
    IN  pNcfPacket      -- Ncf packet buffer
    IN  status          --

Return Value:

    NONE

--*/
{
    PGMLockHandle       OldIrq;

    PgmLock (pSend, OldIrq);
    if (NT_SUCCESS (status))
    {
        //
        // Set the Ncf statistics
        //
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendNcfCompletion",
            "SUCCEEDED\n");
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendNcfCompletion",
            "status=<%x>\n", status);
    }
    PgmUnlock (pSend, OldIrq);

    PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_NCF);
    PgmFreeMem (pNcfPacket);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendNcf(
    IN  tSEND_SESSION                           *pSend,
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakPacket,
    IN  tNAKS_LIST                              *pNcfsList,
    IN  ULONG                                   NakPacketLength
    )
/*++

Routine Description:

    This routine is called to send an NCF packet

Arguments:

    IN  pSend           -- Pgm session (sender) context
    IN  pNakPacket      -- Nak packet which trigerred the Ncf
    IN  NakPacketLength -- Length of Nak packet

Return Value:

    NTSTATUS - Final status of the send

--*/
{
    ULONG                           i, XSum;
    NTSTATUS                        status;
    tBASIC_NAK_NCF_PACKET_HEADER    *pNcfPacket;
    tPACKET_OPTION_LENGTH           *pPacketExtension;
    tPACKET_OPTION_GENERIC          *pOptionHeader;
    USHORT                          OptionsLength = 0;

    if (!(pNcfPacket = PgmAllocMem (NakPacketLength, PGM_TAG('2'))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendNcf",
            "STATUS_INSUFFICIENT_RESOURCES\n");
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    PgmZeroMemory (pNcfPacket, NakPacketLength);    // Copy the packet in its entirety

    //
    // Now, set the fields specific to this sender
    //
    pNcfPacket->CommonHeader.SrcPort = htons (pSend->TSIPort);
    pNcfPacket->CommonHeader.DestPort = htons (pSend->pSender->DestMCastPort);
    pNcfPacket->CommonHeader.Type = PACKET_TYPE_NCF;
    if (pNcfsList->NakType == NAK_TYPE_PARITY)
    {
        pNcfPacket->CommonHeader.Options = PACKET_HEADER_OPTIONS_PARITY;
    }
    else
    {
        pNcfPacket->CommonHeader.Options = 0;
    }
    PgmCopyMemory (&pNcfPacket->CommonHeader.gSourceId, &pSend->GSI, SOURCE_ID_LENGTH);

    pNcfPacket->SourceNLA.NLA_AFI = pNakPacket->SourceNLA.NLA_AFI;
    pNcfPacket->SourceNLA.IpAddress = pNakPacket->SourceNLA.IpAddress;
    pNcfPacket->MCastGroupNLA.NLA_AFI = pNakPacket->MCastGroupNLA.NLA_AFI;
    pNcfPacket->MCastGroupNLA.IpAddress = pNakPacket->MCastGroupNLA.IpAddress;

    //
    // Now, fill in the Sequence numbers
    //
    ASSERT (pNcfsList->NumNaks[0]);
    pNcfPacket->RequestedSequenceNumber = htonl ((ULONG) ((SEQ_TYPE) (pNcfsList->pNakSequences[0] +
                                                                      pNcfsList->NumNaks[0] - 1)));
    if (pNcfsList->NumSequences > 1)
    {
        pPacketExtension = (tPACKET_OPTION_LENGTH *) (pNcfPacket + 1);
        pPacketExtension->Type = PACKET_OPTION_LENGTH;
        pPacketExtension->Length = PGM_PACKET_EXTENSION_LENGTH;
        OptionsLength += PGM_PACKET_EXTENSION_LENGTH;

        pOptionHeader = (tPACKET_OPTION_GENERIC *) (pPacketExtension + 1);
        pOptionHeader->E_OptionType = PACKET_OPTION_NAK_LIST;
        pOptionHeader->OptionLength = 4 + (UCHAR) ((pNcfsList->NumSequences-1) * sizeof(ULONG));
        for (i=1; i<pNcfsList->NumSequences; i++)
        {
            ASSERT (pNcfsList->NumNaks[i]);
            ((PULONG) (pOptionHeader))[i] = htonl ((ULONG) ((SEQ_TYPE) (pNcfsList->pNakSequences[i] +
                                                                        pNcfsList->NumNaks[i] - 1)));
        }

        pOptionHeader->E_OptionType |= PACKET_OPTION_TYPE_END_BIT;    // One and only (last) opt
        pNcfPacket->CommonHeader.Options |=(PACKET_HEADER_OPTIONS_PRESENT |
                                            PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT);
        OptionsLength = PGM_PACKET_EXTENSION_LENGTH + pOptionHeader->OptionLength;
        pPacketExtension->TotalOptionsLength = htons (OptionsLength);
    }

    OptionsLength += sizeof(tBASIC_NAK_NCF_PACKET_HEADER);  // Now is whole pkt

    pNcfPacket->CommonHeader.Checksum = 0;
    XSum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pNcfPacket, NakPacketLength);
    pNcfPacket->CommonHeader.Checksum = (USHORT) (~XSum);

    PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_NCF, FALSE);

    status = TdiSendDatagram (pSend->pSender->pAddress->pRAlertFileObject,
                              pSend->pSender->pAddress->pRAlertDeviceObject,
                              pNcfPacket,
                              OptionsLength,
                              PgmSendNcfCompletion,     // Completion
                              pSend,                    // Context1
                              pNcfPacket,               // Context2
                              pSend->pSender->DestMCastIpAddress,
                              pSend->pSender->DestMCastPort);

    ASSERT (NT_SUCCESS (status));

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendNcf",
        "Sent <%d> bytes to <%x:%d>\n",
            NakPacketLength, pSend->pSender->DestMCastIpAddress, pSend->pSender->DestMCastPort);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
FilterAndAddNaksToList(
    IN  tSEND_SESSION   *pSend,
    IN  tNAKS_LIST      *pNaksList
    )
/*++

Routine Description:

    This routine processes a list of Naks, removing duplicates and adding
    new Naks where necessary

Arguments:

    IN  pSend           -- Pgm session (sender) context
    IN  pNaksList       -- Contains Nak type and List of Nak sequences

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    tSEND_RDATA_CONTEXT             *pRDataContext;
    tSEND_RDATA_CONTEXT             *pRDataNew;
    LIST_ENTRY                      *pEntry;
    ULONG                           i, j, NumNcfs, RDataContextSize;
    ULONGLONG                       PreRDataWait;

    //
    // First, eliminate the entries that are currently in the handled list!
    //
    i = 0;
    NumNcfs = 0;
    ASSERT (pNaksList->NumSequences);
    pEntry = &pSend->pSender->HandledRDataRequests;
    while ((pEntry = pEntry->Flink) != &pSend->pSender->HandledRDataRequests)
    {
        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
        if (pRDataContext->NakType != pNaksList->NakType)
        {
            continue;
        }

        if (pRDataContext->RDataSequenceNumber == pNaksList->pNakSequences[i])
        {
#if 0
            //
            // If this RData has passed the Linger time, cleanup here!
            //
            if ((pRDataContext->CleanupTime) &&
                (pSend->pSender->TimerTickCount > pRDataContext->CleanupTime))
            {
                PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "FilterAndAddNaksToList",
                    "Removing lingering RData for SeqNum=<%d>\n", (ULONG) pRDataContext->RDataSequenceNumber);

                pEntry = pEntry->Blink;     // Set this because this pEntry will not be valid any more!
                RemoveEntryList (&pRDataContext->Linkage);
                PgmFreeMem (pRDataContext);

                continue;
            }
#endif  // 0

            pSend->pSender->NumNaksAfterRData++;

            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "FilterAndAddNaksToList",
                "Ignoring Sequence # [%d] since we just sent RData for it!\n",
                    (ULONG) pNaksList->pNakSequences[i]);

            pNaksList->NumSequences--;
            for (j = i; j < pNaksList->NumSequences; j++)
            {
                pNaksList->pNakSequences[j] = pNaksList->pNakSequences[j+1];
                pNaksList->NumNaks[j] = pNaksList->NumNaks[j+1];
            }
        }
        else if (SEQ_GT (pRDataContext->RDataSequenceNumber, pNaksList->pNakSequences[i]))
        {
            //
            // Our current sequence is not in the list, so go to the next one
            // and recompare with this sequence
            //
            i++;
            pEntry = pEntry->Blink;
        }

        if (i >= pNaksList->NumSequences)
        {
            break;
        }
    }

    //
    // Now, check for pending RData requests and add new ones if necessary
    //
    i = 0;
    RDataContextSize = sizeof(tSEND_RDATA_CONTEXT) + pSend->FECGroupSize*sizeof(PUCHAR);
    pEntry = &pSend->pSender->PendingRDataRequests;
    while ((pEntry = pEntry->Flink) != &pSend->pSender->PendingRDataRequests)
    {
        if (i >= pNaksList->NumSequences)
        {
            break;
        }

        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
        if (SEQ_LT (pRDataContext->RDataSequenceNumber, pNaksList->pNakSequences[i]))
        {
            continue;
        }

        if (SEQ_GT (pRDataContext->RDataSequenceNumber, pNaksList->pNakSequences[i]) ||
            ((pRDataContext->NakType == NAK_TYPE_SELECTIVE) &&  // If seq #s are equal, parity Naks will be added before selective
             (pNaksList->NakType == NAK_TYPE_PARITY)))
        {
            //
            // Our current sequence is not in the list, so add it!
            //
            if (!(pRDataNew = PgmAllocMem (RDataContextSize, PGM_TAG('2'))))
            {
                PgmLog (PGM_LOG_ERROR, DBG_SEND, "FilterAndAddNaksToList",
                    "[1] STATUS_INSUFFICIENT_RESOURCES\n");
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
            PgmZeroMemory (pRDataNew, RDataContextSize);

            pRDataNew->Linkage.Flink = pEntry;
            pRDataNew->Linkage.Blink = pEntry->Blink;
            pEntry->Blink->Flink = &pRDataNew->Linkage;
            pEntry->Blink = &pRDataNew->Linkage;

            pRDataNew->pSend = pSend;
            pRDataNew->RDataSequenceNumber = pNaksList->pNakSequences[i];
            pRDataNew->NakType = pNaksList->NakType;
            pRDataNew->NumNaks = pNaksList->NumNaks[i];
            pRDataNew->RequestTime = pSend->pSender->CurrentTimeoutCount;

            pSend->pSender->NumOutstandingNaks += pNaksList->NumNaks[i];
            pSend->pSender->NumRDataRequestsPending++;
            if (SEQ_GT (pSend->pSender->LastODataSentSequenceNumber, pSend->pSender->TrailingGroupSequenceNumber))
            {
                PreRDataWait = (((SEQ_TYPE) (pRDataNew->RDataSequenceNumber -
                                           pSend->pSender->TrailingGroupSequenceNumber)) *
                                 pSend->pSender->RDataLingerTime) /
                               ((SEQ_TYPE) (pSend->pSender->LastODataSentSequenceNumber -
                                            pSend->pSender->TrailingGroupSequenceNumber + 1));
                ASSERT (PreRDataWait <= RDATA_LINGER_TIME_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS);
                pRDataNew->EarliestRDataSendTime = pSend->pSender->TimerTickCount + PreRDataWait;
                pRDataNew->PostRDataHoldTime = pSend->pSender->RDataLingerTime - PreRDataWait;
            }
            else
            {
                pRDataNew->EarliestRDataSendTime = 0;
                pRDataNew->PostRDataHoldTime = pSend->pSender->RDataLingerTime;
            }

            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "FilterAndAddNaksToList",
                "Inserted Sequence # [%d] to RData list!\n",
                    (ULONG) pNaksList->pNakSequences[i]);

            pEntry = &pRDataNew->Linkage;
        }
        //
        // (pRDataContext->RDataSequenceNumber == pNaksList->pNakSequences[i])
        //
        else if (pRDataContext->NakType != pNaksList->NakType)  // RData is Parity and Nak is Selective, so check next entry
        {
            continue;
        }
        else
        {
            if (pNaksList->NumNaks[i] > pRDataContext->NumNaks)
            {
                pSend->pSender->NumOutstandingNaks += (pNaksList->NumNaks[i] - pRDataContext->NumNaks);
                pRDataContext->NumNaks = pNaksList->NumNaks[i];
            }

            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "FilterAndAddNaksToList",
                "Ignoring Sequence # [%d] since we just already have pending RData!\n",
                    (ULONG) pNaksList->pNakSequences[i]);
        }

        i++;
    }

    //
    // Now, add any remaining Nak entries at the end of the Pending list
    //
    for ( ; i < pNaksList->NumSequences; i++)
    {
        //
        // Add this sequence number to the end of the list
        //
        if (!(pRDataNew = PgmAllocMem (RDataContextSize, PGM_TAG('2'))))
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "FilterAndAddNaksToList",
                "[2] STATUS_INSUFFICIENT_RESOURCES\n");
            return (STATUS_DATA_NOT_ACCEPTED);
        }
        PgmZeroMemory (pRDataNew, RDataContextSize);

        pRDataNew->pSend = pSend;
        pRDataNew->RDataSequenceNumber = pNaksList->pNakSequences[i];
        pRDataNew->NakType = pNaksList->NakType;
        pRDataNew->NumNaks = pNaksList->NumNaks[i];
        pRDataNew->RequestTime = pSend->pSender->CurrentTimeoutCount;

        InsertTailList (&pSend->pSender->PendingRDataRequests, &pRDataNew->Linkage);

        pSend->pSender->NumOutstandingNaks += pNaksList->NumNaks[i];
        pSend->pSender->NumRDataRequestsPending++;
        if (SEQ_GT (pSend->pSender->LastODataSentSequenceNumber, pSend->pSender->TrailingGroupSequenceNumber))
        {
            PreRDataWait = (((SEQ_TYPE) (pRDataNew->RDataSequenceNumber -
                                         pSend->pSender->TrailingGroupSequenceNumber)) *
                            pSend->pSender->RDataLingerTime) /
                           ((SEQ_TYPE) (pSend->pSender->LastODataSentSequenceNumber -
                                        pSend->pSender->TrailingGroupSequenceNumber + 1));
            pRDataNew->EarliestRDataSendTime = pSend->pSender->TimerTickCount + PreRDataWait;
            pRDataNew->PostRDataHoldTime = pSend->pSender->RDataLingerTime - PreRDataWait;
        }
        else
        {
            pRDataNew->EarliestRDataSendTime = 0;
            pRDataNew->PostRDataHoldTime = pSend->pSender->RDataLingerTime;
        }

        PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "FilterAndAddNaksToList",
            "Appended Sequence # [%d] to RData list!\n",
                (ULONG) pNaksList->pNakSequences[i]);
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
SenderProcessNakPacket(
    IN  tADDRESS_CONTEXT                        *pAddress,
    IN  tSEND_SESSION                           *pSend,
    IN  ULONG                                   PacketLength,
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakPacket
    )
/*++

Routine Description:

    This routine processes an incoming Nak packet sent to the sender

Arguments:

    IN  pAddress        -- Pgm's address object
    IN  pSend           -- Pgm session (sender) context
    IN  PacketLength    -- Nak packet length
    IN  pNakPacket      -- Nak packet data


Return Value:

    NTSTATUS - Final status of the call

--*/
{
    PGMLockHandle                   OldIrq;
    tNAKS_LIST                      NaksList;
    tSEND_RDATA_CONTEXT             *pRDataContext;
    tSEND_RDATA_CONTEXT             *pRDataNew;
    SEQ_TYPE                        LastSequenceNumber;
    NTSTATUS                        status;

    if (PacketLength < sizeof(tBASIC_NAK_NCF_PACKET_HEADER))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "SenderProcessNakPacket",
            "Invalid Packet length=<%d>, Min=<%d> ...\n",
            PacketLength, sizeof(tBASIC_NAK_NCF_PACKET_HEADER));
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    ASSERT (!pNakPacket->CommonHeader.TSDULength);

    PgmLock (pSend, OldIrq);

    status = ExtractNakNcfSequences (pNakPacket,
                                     (PacketLength - sizeof(tBASIC_NAK_NCF_PACKET_HEADER)),
                                     &NaksList,
                                     pSend->FECGroupSize);
    if (!NT_SUCCESS (status))
    {
        PgmUnlock (pSend, OldIrq);
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "SenderProcessNakPacket",
            "ExtractNakNcfSequences returned <%x>\n", status);

        return (status);
    }

    pSend->pSender->NaksReceived += NaksList.NumSequences;

    //
    // The oldest as well as latest sequence numbers have to be in our window
    //
    if (SEQ_LT (NaksList.pNakSequences[0], pSend->pSender->TrailingGroupSequenceNumber) ||
        SEQ_GT (NaksList.pNakSequences[NaksList.NumSequences-1], pSend->pSender->LastODataSentSequenceNumber))
    {
        pSend->pSender->NaksReceivedTooLate++;
        PgmUnlock (pSend, OldIrq);

        PgmLog (PGM_LOG_ERROR, DBG_SEND, "SenderProcessNakPacket",
            "Invalid %s Naks = [%d-%d] not in window [%d -- [%d]\n",
                (NaksList.NakType == NAK_TYPE_PARITY ? "Parity" : "Selective"),
                (ULONG) NaksList.pNakSequences[0], (ULONG) NaksList.pNakSequences[NaksList.NumSequences-1],
                (ULONG) pSend->pSender->TrailingGroupSequenceNumber, (ULONG) pSend->pSender->LastODataSentSequenceNumber);

        return (STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Check if this is a parity Nak and we are anabled for Parity Naks
    //
    if ((pNakPacket->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY) &&
        !(pSend->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "SenderProcessNakPacket",
            "Receiver requested Parity Naks, but we are not enabled for parity!\n");

        PgmUnlock (pSend, OldIrq);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    status = FilterAndAddNaksToList (pSend, &NaksList);

    PgmUnlock (pSend, OldIrq);

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "SenderProcessNakPacket",
            "FilterAndAddNaksToList returned <%x>\n", status);

        return (status);
    }

    //
    // If applicable, send the Ncf for this Nak
    //
    if (NaksList.NumSequences)
    {
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "SenderProcessNakPacket",
            "Now sending Ncf for Nak received for <%d> Sequences, NakType=<%x>\n",
                NaksList.NumSequences, NaksList.NakType);

        status = PgmSendNcf (pSend, pNakPacket, &NaksList, PacketLength);
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetFin(
    IN  tSEND_SESSION           *pSend,
    IN  tCLIENT_SEND_REQUEST    *pSendContext,
    IN  PGMLockHandle           *pOldIrq
    )
/*++

Routine Description:

    This routine is called to set the Fin option on the last data packet
    if the packets have been packetized, but not yet sent out
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pOldIrq     -- pSend's OldIrq

Return Value:

    NTSTATUS - Final status of the set FIN operation

--*/
{
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached;
    NTSTATUS                    status;
    tPACKET_BUFFER              *pPacketBuffer;
    ULONG                       OptionsFlags;
    ULONGLONG                   LastPacketOffset;
    tBASIC_DATA_PACKET_HEADER   *pLastDataPacket;
    tBASIC_DATA_PACKET_HEADER   *pFinPacket = NULL;
    SEQ_TYPE                    LastODataSequenceNumber = pSend->pSender->NextODataSequenceNumber - 1;
    USHORT                      OriginalHeaderLength, HeaderLength = (USHORT) pSend->pSender->PacketBufferSize;

    //
    // This will be called only if we have finished packetizing
    // all the packets, but have not yet sent the last one out!
    // We need to set the FIN on the last packet
    //
    ASSERT (!pSendContext->BytesLeftToPacketize);
    ASSERT (pSendContext->pIrp);

    //
    // First set the FIN flag so that the Spm can get sent
    //
    pSendContext->DataOptions |= PGM_OPTION_FLAG_FIN;

    //
    // Allocate memory for saving the last packet's data
    //
    if (!(pFinPacket = PgmAllocMem (pSend->pSender->PacketBufferSize, PGM_TAG('2'))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSetFin",
            "STATUS_INSUFFICIENT_RESOURCES\n");
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // First, determine where the last packet packetized is located
    //
    if (pSend->pSender->LeadingWindowOffset < pSend->pSender->PacketBufferSize)
    {
        ASSERT (pSend->pSender->LeadingWindowOffset == 0);  // This is the only valid value!
        LastPacketOffset = pSend->pSender->MaxDataFileSize - pSend->pSender->PacketBufferSize;
    }
    else
    {
        ASSERT (pSend->pSender->LeadingWindowOffset < pSend->pSender->MaxDataFileSize);
        LastPacketOffset = pSend->pSender->LeadingWindowOffset - pSend->pSender->PacketBufferSize;
    }

    pPacketBuffer = (tPACKET_BUFFER *) (((PUCHAR) pSend->pSender->SendDataBufferMapping) + LastPacketOffset);
    pLastDataPacket = &pPacketBuffer->DataPacket;

    //
    // First get all the options that were set in the last packet
    //
    PgmUnlock (pSend, *pOldIrq);
    PgmAttachToProcessForVMAccess (pSend->Process, &ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);

    OptionsFlags = pPacketBuffer->PacketOptions.OptionsFlags | PGM_OPTION_FLAG_FIN;
    OriginalHeaderLength = sizeof(tBASIC_DATA_PACKET_HEADER) + pPacketBuffer->PacketOptions.OptionsLength;

    PgmZeroMemory (pFinPacket, pSend->pSender->PacketBufferSize);
    status = InitDataSpmHeader (pSend,
                                pSendContext,
                                (PUCHAR) pFinPacket,
                                &HeaderLength,
                                OptionsFlags,
                                &pPacketBuffer->PacketOptions,
                                PACKET_TYPE_ODATA);

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSetFin",
            "[1] InitDataSpmHeader returned <%x>\n", status);

        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);
        PgmLock (pSend, *pOldIrq);

        PgmFreeMem (pFinPacket);
        return (status);
    }

    pFinPacket->DataSequenceNumber = htonl ((ULONG) LastODataSequenceNumber);
    pFinPacket->CommonHeader.TSDULength = htons (pPacketBuffer->PacketOptions.TotalPacketLength -
                                                 OriginalHeaderLength);

    ASSERT (pFinPacket->DataSequenceNumber == pLastDataPacket->DataSequenceNumber);

    //
    // Copy the data
    //
    PgmCopyMemory (&((PUCHAR) pFinPacket) [HeaderLength],
                   &((PUCHAR) pLastDataPacket) [OriginalHeaderLength],
                   (pSend->pSender->MaxPayloadSize));

    //
    // Now, copy the reconstructed packet back into the buffer
    //
    if (pSend->FECOptions)
    {
        PgmCopyMemory (&((PUCHAR)pFinPacket) [HeaderLength + pSend->pSender->MaxPayloadSize],
                       &((PUCHAR)pLastDataPacket) [OriginalHeaderLength + pSend->pSender->MaxPayloadSize],
                       sizeof(tPOST_PACKET_FEC_CONTEXT));

        PgmCopyMemory (pLastDataPacket, pFinPacket,
                      (HeaderLength+pSend->pSender->MaxPayloadSize+sizeof(tPOST_PACKET_FEC_CONTEXT)));
    }
    else
    {
        PgmCopyMemory (pLastDataPacket, pFinPacket, (HeaderLength+pSend->pSender->MaxPayloadSize));
    }


    pPacketBuffer->PacketOptions.TotalPacketLength = HeaderLength +
                                                     ntohs (pFinPacket->CommonHeader.TSDULength);
    pPacketBuffer->PacketOptions.OptionsFlags = OptionsFlags;
    pPacketBuffer->PacketOptions.OptionsLength = HeaderLength - sizeof(tBASIC_DATA_PACKET_HEADER);

    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);
    PgmLock (pSend, *pOldIrq);

    PgmFreeMem (pFinPacket);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSetFin",
        "Set Fin option on last packet\n");

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PacketizeMessage(
    IN      tSEND_SESSION           *pSend,
    IN      PGMLockHandle           *pOldIrq,
    IN      tCLIENT_SEND_REQUEST    *pSendContext,
    IN OUT  ULONG                   *pBytesToPacketize,
    IN OUT  ULONGLONG               *pLeadingWindowOffset,
    IN      ULONGLONG               *pTrailingWindowOffset,
    IN OUT  ULONGLONG               *pBufferSize,
    IN OUT  SEQ_TYPE                *pNextODataSequenceNumber,
    IN OUT  ULONG                   *pBytesPacketized,
    IN OUT  ULONG                   *pNextDataOffsetInMdl,
    IN OUT  ULONG                   *pDataPacketsPacketized,
    IN OUT  ULONG                   *pDataBytesInLastPacket,
    OUT     PVOID                   *ppLastVariableTGPacket
    )
/*++

Routine Description:

    This routine pactizes the data to be sent into packets
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend                       -- Pgm session (sender) context
    IN  pOldIrq                     -- pSend's OldIrq
    IN  pSendContext                -- Pgm's SendContext for this send request from client
    IN OUT  pBytesToPacketize       -- Client data bytes left to packetize before and after
    IN OUT  pLeadingWindowOffset
    IN OUT  pBufferSizeAvailable    -- IN ==> Buffer available, OUT ==> Buffer consumed
    IN OUT  pBytesPacketized
    IN OUT  pDataPacketsPacketized
    IN OUT  pDataBytesInLastPacket
Return Value:

    NTSTATUS - Final status of the request

--*/
{
    tBASIC_DATA_PACKET_HEADER           *pODataBuffer;
    ULONG                               ulBytes, DataOptions;
    USHORT                              usBytes, HeaderLength, PacketsLeftInGroup;
    KAPC_STATE                          ApcState;
    BOOLEAN                             fAttached;
    tPACKET_OPTIONS                     *pPacketOptions;
    tPACKET_BUFFER                      *pPacketBuffer;
    tPACKET_BUFFER                      *pGroupLeaderPacketBuffer;
    tPOST_PACKET_FEC_CONTEXT UNALIGNED  *pBufferFECContext;
    tPOST_PACKET_FEC_CONTEXT            FECContext;
    ULONGLONG                           Buffer1Packets, Buffer2Packets;
    ULONGLONG                           ActualBuffer1Packets, ActualBuffer2Packets;
    SEQ_TYPE                            FECGroupMask = pSend->FECGroupSize-1;
    ULONG                               NumPacketsRemaining;
    tSEND_CONTEXT                       *pSender = pSend->pSender;
    NTSTATUS                            status = STATUS_SUCCESS;
    PMDL                                pMdlChain = pSendContext->pIrp->MdlAddress;
    ULONG                               BytesToPacketize = *pBytesToPacketize;
    ULONGLONG                           LeadingWindowOffset = *pLeadingWindowOffset;
    ULONGLONG                           TrailingWindowOffset = *pTrailingWindowOffset;
    ULONGLONG                           BufferSizeAvailable = *pBufferSize;
    SEQ_TYPE                            NextODataSequenceNumber = *pNextODataSequenceNumber;
    ULONG                               BytesPacketized = *pBytesPacketized;
    ULONG                               NextDataOffsetInMdl = *pNextDataOffsetInMdl;
    ULONG                               DataPacketsPacketized = *pDataPacketsPacketized;
    ULONG                               DataBytesInLastPacket = *pDataBytesInLastPacket;

    //
    // First do some sanity checks!
    //
    ASSERT (LeadingWindowOffset < pSender->MaxDataFileSize);
    ASSERT (BufferSizeAvailable <= pSender->MaxDataFileSize);
    ASSERT (pSend->FECGroupSize);

    //
    // Next, determine how many Packets we can packetize at this time
    // For FEC, we will need to make sure we don't packetize beyond
    // the first group of the trailing edge!
    // We will do 2 sets of calculations -- ActualBuffer[n]Packets represents
    // the actual number of available packets, while Buffer[n]Packets
    // represents the packets available for packetization
    //
    if (!BufferSizeAvailable)
    {
        //
        // Our buffer is full!
        //
        Buffer1Packets = Buffer2Packets = 0;
        ActualBuffer1Packets = ActualBuffer2Packets = 0;
        ASSERT (LeadingWindowOffset == TrailingWindowOffset);
    }
    else if (LeadingWindowOffset < TrailingWindowOffset)
    {
#if DBG
//        ActualBuffer1Packets = (TrailingWindowOffset - LeadingWindowOffset) / pSender->PacketBufferSize;
        ActualBuffer1Packets = TrailingWindowOffset / pSender->PacketBufferSize;
        ActualBuffer2Packets = LeadingWindowOffset / pSender->PacketBufferSize;
        Buffer1Packets = ActualBuffer1Packets & ~((ULONGLONG) FECGroupMask);

        ActualBuffer1Packets -= ActualBuffer2Packets;
        Buffer1Packets -= ActualBuffer2Packets;

#else
        Buffer1Packets = (TrailingWindowOffset / pSender->PacketBufferSize) & ~((ULONGLONG)FECGroupMask);
        Buffer1Packets -= LeadingWindowOffset / pSender->PacketBufferSize;
#endif  // DBG
        ActualBuffer2Packets = Buffer2Packets = 0;
    }
    else
    {
        ActualBuffer1Packets = Buffer1Packets = (pSender->MaxDataFileSize - LeadingWindowOffset) /
                                                pSender->PacketBufferSize;
#if DBG
        ActualBuffer2Packets = TrailingWindowOffset / pSender->PacketBufferSize;
        Buffer2Packets = ActualBuffer2Packets & ~((ULONGLONG)FECGroupMask);
#else
        Buffer2Packets = (TrailingWindowOffset / pSender->PacketBufferSize) & ~((ULONGLONG)FECGroupMask);
#endif  // DBG
    }
    ASSERT (Buffer1Packets || !Buffer2Packets);
    ASSERT (((ActualBuffer1Packets + ActualBuffer2Packets) *
             pSender->PacketBufferSize) == BufferSizeAvailable);
    ASSERT (Buffer1Packets <= ActualBuffer1Packets);
    ASSERT (Buffer2Packets <= ActualBuffer2Packets);

    // Initialize
    NumPacketsRemaining = pSender->NumPacketsRemaining;
    PacketsLeftInGroup = pSend->FECGroupSize - (UCHAR) (NextODataSequenceNumber & FECGroupMask);
    if (pSend->FECOptions)
    {
        PgmZeroMemory (&FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));
    }

    PgmUnlock (pSend, *pOldIrq);
    PgmAttachToProcessForVMAccess (pSend->Process, &ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);

    while (Buffer1Packets || Buffer2Packets)
    {
        //
        // For FEC, we must start the next send from the next group boundary.
        // Thus, we need to pad any intermediate sequence# packets
        //
        if (!BytesToPacketize)
        {
            if ((NumPacketsRemaining >= 1) ||   // More packets, so not a partial group
                (PacketsLeftInGroup == pSend->FECGroupSize))    // New group boundary (always TRUE for non-FEC packets!)
            {
                break;
            }
        }

        //
        // Get the next packet ptr and Packet size
        //
        pPacketBuffer = (tPACKET_BUFFER *) (pSender->SendDataBufferMapping + LeadingWindowOffset);
        pODataBuffer = &pPacketBuffer->DataPacket;
        pPacketOptions = &pPacketBuffer->PacketOptions;
        PgmZeroMemory (pPacketBuffer, pSender->PacketBufferSize);     // Zero the entire buffer

        //
        // Prepare info for any applicable options
        //
        pPacketOptions->OptionsFlags = pSendContext->DataOptions;
        ulBytes = pSendContext->DataOptionsLength;  // Save for assert below

        if ((BytesToPacketize) &&
            (pPacketOptions->OptionsFlags & PGM_OPTION_FLAG_FRAGMENT))
        {
            pPacketOptions->MessageFirstSequence = (ULONG) (SEQ_TYPE) pSendContext->MessageFirstSequenceNumber;
            pPacketOptions->MessageOffset =  pSendContext->LastMessageOffset + BytesPacketized;
            pPacketOptions->MessageLength = pSendContext->ThisMessageLength;
        }
        else
        {
            if (pPacketOptions->OptionsFlags & PGM_OPTION_FLAG_FRAGMENT)
            {
                ASSERT (!BytesToPacketize);
                pPacketOptions->OptionsFlags &= ~PGM_OPTION_FLAG_FRAGMENT;
                if (pPacketOptions->OptionsFlags)
                {
                    ulBytes -= PGM_PACKET_OPT_FRAGMENT_LENGTH;
                }
                else
                {
                    ulBytes = 0;
                }
            }
        }

        if (pPacketOptions->OptionsFlags & PGM_OPTION_FLAG_JOIN)
        {
            //
            // See if we have enough packets for the LateJoiner sequence numbers
            //
            if (SEQ_GT (NextODataSequenceNumber, (pSender->TrailingGroupSequenceNumber +
                                                  pSender->LateJoinSequenceNumbers)))
            {
                pPacketOptions->LateJoinerSequence = (ULONG) (SEQ_TYPE) (NextODataSequenceNumber -
                                                                         pSender->LateJoinSequenceNumbers);
            }
            else
            {
                pPacketOptions->LateJoinerSequence = (ULONG) (SEQ_TYPE) pSender->TrailingGroupSequenceNumber;
            }
        }

        if (pSend->FECBlockSize)                           // Check if this is FEC-enabled
        {
            //
            // Save information if we are at beginning of group boundary
            //
            if (PacketsLeftInGroup == pSend->FECGroupSize)
            {
                pPacketOptions->FECContext.SenderNextFECPacketIndex = pSend->FECGroupSize;
            }

            //
            // Check if we need to set the variable TG size option
            //
            if ((NumPacketsRemaining == 1) &&   // Last packet
                (BytesToPacketize) &&                                       // non-Zero length
                (PacketsLeftInGroup > 1))                                   // Variable TG size
            {
                //
                // This is a variable Transmission Group Size, i.e. PacketsInGroup < pSend->FECGroupSize
                //
                ASSERT ((Buffer1Packets + Buffer2Packets) >= PacketsLeftInGroup);

                if (!pPacketOptions->OptionsFlags)
                {
                    ulBytes = PGM_PACKET_EXTENSION_LENGTH;
                }
                ulBytes += PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH;
                pPacketOptions->OptionsFlags |= PGM_OPTION_FLAG_PARITY_CUR_TGSIZE;

                pPacketOptions->FECContext.NumPacketsInThisGroup = pSend->FECGroupSize - (PacketsLeftInGroup - 1);
                *ppLastVariableTGPacket = (PVOID) pODataBuffer;
            }
        }

        HeaderLength = (USHORT) pSender->MaxPayloadSize;          // Init -- max buffer size available
        status = InitDataSpmHeader (pSend,
                                    pSendContext,
                                    (PUCHAR) pODataBuffer,
                                    &HeaderLength,
                                    pPacketOptions->OptionsFlags,
                                    pPacketOptions,
                                    PACKET_TYPE_ODATA);

        if (NT_SUCCESS (status))
        {
            ASSERT ((sizeof(tBASIC_DATA_PACKET_HEADER) + ulBytes) == HeaderLength);
            ASSERT ((pSend->FECBlockSize && (HeaderLength+pSendContext->DataPayloadSize) <=
                                            (pSender->PacketBufferSize-sizeof(tPOST_PACKET_FEC_CONTEXT))) ||
                    (!pSend->FECBlockSize && ((HeaderLength+pSendContext->DataPayloadSize) <=
                                              pSender->PacketBufferSize)));

            if (BytesToPacketize > pSender->MaxPayloadSize)
            {
                DataBytesInLastPacket = pSender->MaxPayloadSize;
            }
            else
            {
                DataBytesInLastPacket = (USHORT) BytesToPacketize;
            }
            pODataBuffer->CommonHeader.TSDULength = htons ((USHORT) DataBytesInLastPacket);
            pODataBuffer->DataSequenceNumber = htonl ((ULONG) NextODataSequenceNumber++);

            ulBytes = 0;
            status = TdiCopyMdlToBuffer (pMdlChain,
                                         NextDataOffsetInMdl,
                                         (((PUCHAR) pODataBuffer) + HeaderLength),
                                         0,                         // Destination Offset
                                         DataBytesInLastPacket,
                                         &ulBytes);

            if (((!NT_SUCCESS (status)) && (STATUS_BUFFER_OVERFLOW != status)) || // Overflow acceptable!
                (ulBytes != DataBytesInLastPacket))
            {
                PgmLog (PGM_LOG_ERROR, DBG_SEND, "PacketizeMessage",
                    "TdiCopyMdlToBuffer returned <%x>, BytesCopied=<%d/%d>\n",
                        status, ulBytes, DataBytesInLastPacket);

                status = STATUS_UNSUCCESSFUL;
            }
            else
            {
                pPacketOptions->TotalPacketLength = HeaderLength + (USHORT) DataBytesInLastPacket;
                pPacketOptions->OptionsLength = HeaderLength - sizeof (tBASIC_DATA_PACKET_HEADER);
                //
                // Set the PacketOptions Information for FEC packets
                //
                if (pSend->FECOptions)
                {
                    pBufferFECContext = (tPOST_PACKET_FEC_CONTEXT *) (((PUCHAR) pODataBuffer) +
                                                                       HeaderLength +
                                                                       pSender->MaxPayloadSize);

                    if (DataBytesInLastPacket)
                    {
                        FECContext.EncodedTSDULength = htons ((USHORT) DataBytesInLastPacket);

                        FECContext.EncodedFragmentOptions.MessageFirstSequence = htonl ((ULONG) (SEQ_TYPE) pPacketOptions->MessageFirstSequence);
                        FECContext.EncodedFragmentOptions.MessageOffset =  htonl (pPacketOptions->MessageOffset);
                        FECContext.EncodedFragmentOptions.MessageLength = htonl (pPacketOptions->MessageLength);
                        PgmCopyMemory (pBufferFECContext, &FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));
                    }
                    else
                    {
                        //
                        // We had already initialized this memory earlier in the loop
                        //
//                        PgmZeroMemory (pBufferFECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));
                    }

                    //
                    // If this is not a fragment, set the PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT
                    //
                    if ((!DataBytesInLastPacket) ||
                        (!(pPacketOptions->OptionsFlags & PGM_OPTION_FLAG_FRAGMENT)))
                    {
                        ((PUCHAR) pBufferFECContext)
                            [FIELD_OFFSET (tPOST_PACKET_FEC_CONTEXT, FragmentOptSpecific)] =
                                PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT;
                    }
                }

                status = STATUS_SUCCESS;
            }
        }
        else
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "PacketizeMessage",
                "InitDataSpmHeader returned <%x>\n", status);
        }

        if (!NT_SUCCESS (status))
        {
            break;
        }

        LeadingWindowOffset += pSender->PacketBufferSize;
        BufferSizeAvailable -= pSender->PacketBufferSize;
        BytesPacketized += DataBytesInLastPacket;
        NextDataOffsetInMdl += DataBytesInLastPacket;
        if (DataBytesInLastPacket)
        {
            DataPacketsPacketized++;
            NumPacketsRemaining--;
        }

        //
        // Update the Send buffer information
        //
        if (!Buffer1Packets)
        {
            Buffer2Packets--;
        }
        else if (0 == --Buffer1Packets)
        {
            ASSERT (((Buffer2Packets == 0) && (TrailingWindowOffset != 0)) ||
                    (LeadingWindowOffset == pSender->MaxDataFileSize));

            if (LeadingWindowOffset == pSender->MaxDataFileSize)
            {
                LeadingWindowOffset = 0;
            }
        }

        //
        // Update the Send data information
        //
        BytesToPacketize -= DataBytesInLastPacket;

        //
        // See if we are at a group boundary
        //
        if (!--PacketsLeftInGroup)
        {
            PacketsLeftInGroup = pSend->FECGroupSize;
        }
    }

    ASSERT ((Buffer1Packets || Buffer2Packets) ||
            (BufferSizeAvailable < (pSender->PacketBufferSize * pSend->FECGroupSize)));

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PacketizeMessage",
        "TotalBytesPacketized=<%d/%d>, BytesToP=<%d==>%d>\n",
            BytesPacketized, pSendContext->BytesInSend, *pBytesToPacketize, BytesToPacketize);

    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);
    PgmLock (pSend, *pOldIrq);

    //
    // Set the state variables
    //
    *pBytesToPacketize = BytesToPacketize;
    *pLeadingWindowOffset = LeadingWindowOffset;
    *pBufferSize = (*pBufferSize - BufferSizeAvailable);
    *pNextODataSequenceNumber = NextODataSequenceNumber;
    *pBytesPacketized = BytesPacketized;
    *pNextDataOffsetInMdl = NextDataOffsetInMdl;
    *pDataPacketsPacketized = DataPacketsPacketized;
    *pDataBytesInLastPacket = DataBytesInLastPacket;

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmPacketizeSend(
    IN  tSEND_SESSION           *pSend,
    IN  tCLIENT_SEND_REQUEST    *pSendContext,
    IN  PGMLockHandle           *pOldIrq
    )
/*++

Routine Description:

    This routine is called to prepare the next set of packets
    for sending on the wire
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pOldIrq     -- pSend's OldIrq

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    ULONG                       BytesToPacketize = 0;
    ULONGLONG                   LeadingWindowOffset;
    ULONGLONG                   TrailingWindowOffset;
    ULONGLONG                   BufferSize;
    SEQ_TYPE                    NextODataSequenceNumber;
    PVOID                       pLastVariableTGPacket;
    ULONG                       BytesPacketized;
    ULONG                       NextDataOffsetInMdl;
    ULONG                       DataPacketsPacketized;
    ULONG                       DataBytesInLastPacket;
    NTSTATUS                    status = STATUS_SUCCESS;
    LIST_ENTRY                  *pEntry;

    if (pSendContext->BytesLeftToPacketize == pSendContext->BytesInSend)
    {
        pSendContext->NextPacketOffset = pSend->pSender->LeadingWindowOffset;       // First packet's offset
        pSendContext->StartSequenceNumber = pSend->pSender->NextODataSequenceNumber;
        pSendContext->EndSequenceNumber = pSend->pSender->NextODataSequenceNumber;  // temporary

        if (pSendContext->LastMessageOffset)
        {
            pSendContext->MessageFirstSequenceNumber = pSend->pSender->LastMessageFirstSequence;
        }
        else
        {
            pSendContext->MessageFirstSequenceNumber = pSendContext->StartSequenceNumber;
            pSend->pSender->LastMessageFirstSequence = pSendContext->StartSequenceNumber;
        }
    }

    BytesToPacketize = pSendContext->BytesLeftToPacketize;

    //
    // Since we have a wrap around buffer to be copied into, we also need to
    // determine the # of packets that can be copied contiguously
    //
    ASSERT (pSend->pSender->LeadingWindowOffset < pSend->pSender->MaxDataFileSize);
    ASSERT (pSend->pSender->TrailingWindowOffset < pSend->pSender->MaxDataFileSize);

    PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmPacketizeSend",
        "TotalBytes=<%d>, BytesToPacketize=<%d>\n",
            pSendContext->BytesInSend, BytesToPacketize);

    LeadingWindowOffset = pSend->pSender->LeadingWindowOffset;
    NextODataSequenceNumber = pSend->pSender->NextODataSequenceNumber;
    BytesPacketized = pSendContext->BytesInSend - pSendContext->BytesLeftToPacketize;
    NextDataOffsetInMdl = pSendContext->NextDataOffsetInMdl;
    DataBytesInLastPacket = pSendContext->DataBytesInLastPacket;

    //
    // Since some packet headers may have different lengths (based on options),
    // we cannot always compute the exact number of packets needed, so will
    // attempt to packetize sequentially keeping the limits in mind
    //
    //
    // First fill in any packets from the first Message
    //
    if (BytesToPacketize)
    {
        pLastVariableTGPacket = (PVOID) -1;
        DataPacketsPacketized = 0;
        BufferSize = pSend->pSender->BufferSizeAvailable;
        TrailingWindowOffset = pSend->pSender->TrailingWindowOffset;
        status = PacketizeMessage (pSend,
                                   pOldIrq,
                                   pSendContext,
                                   &BytesToPacketize,
                                   &LeadingWindowOffset,
                                   &TrailingWindowOffset,
                                   &BufferSize,
                                   &NextODataSequenceNumber,
                                   &BytesPacketized,
                                   &NextDataOffsetInMdl,
                                   &DataPacketsPacketized,
                                   &DataBytesInLastPacket,
                                   &pLastVariableTGPacket);

        if (NT_SUCCESS (status))
        {
            //
            // Save all the state information
            //
            pSend->pSender->LeadingWindowOffset = LeadingWindowOffset;
            pSend->pSender->BufferSizeAvailable -= BufferSize;
            pSend->pSender->NumPacketsRemaining -= DataPacketsPacketized;

            pSend->pSender->NextODataSequenceNumber = NextODataSequenceNumber;
            pSendContext->BytesLeftToPacketize = pSendContext->BytesInSend - BytesPacketized;
            pSendContext->NextDataOffsetInMdl = NextDataOffsetInMdl;
            pSendContext->DataBytesInLastPacket = DataBytesInLastPacket;
            pSendContext->DataPacketsPacketized += DataPacketsPacketized;
            pSendContext->NumPacketsRemaining -= DataPacketsPacketized;

            if (BytesToPacketize)
            {
                //
                // We must have run out of Buffer space to copy the entire
                // message, which is not an error -- so just return gracefully
                //
                pSendContext->EndSequenceNumber = pSend->pSender->NextODataSequenceNumber - 1;

                PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmPacketizeSend",
                    "PacketizeMessage[1] SUCCEEDed, but BytesToPacketize=<%d>\n", BytesToPacketize);
                return (STATUS_SUCCESS);
            }
            pSendContext->pLastMessageVariableTGPacket = pLastVariableTGPacket;
        }
        else
        {
            //
            // The function will ensure that Buffer1Packets != 0 on error
            //
            ASSERT (BytesToPacketize);
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmPacketizeSend",
                "PacketizeMessage[1] returned <%x>\n", status);
        }
    }

    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmPacketizeSend",
            "status=<%x>, pSend=<%p>, pSendContext=<%p>, pIrp=<%p>\n",
                status, pSend, pSendContext, pSendContext->pIrp);

        //
        // Mark the remainder of this send as invalid!
        //
        pSendContext->BytesLeftToPacketize = 0;
//        pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_RST;    // ISSUE:  Do we set this here ?

        //
        // We failed to packetize the last send, so see if we can complete the Irp here
        //
        RemoveEntryList (&pSendContext->Linkage);
        pSend->pSender->NumODataRequestsPending--;
        pSend->pSender->NumPacketsRemaining -= pSendContext->NumPacketsRemaining;

        ASSERT (pSendContext->pIrp);
        if (pSendContext->NumSendsPending == 0)
        {
            if (pSendContext->pIrpToComplete)
            {
                ASSERT (pSendContext == pSendContext->pMessage2Request->pMessage2Request);
                if (pSendContext->pMessage2Request)
                {
                    ASSERT (!pSendContext->pMessage2Request->pIrpToComplete);
                    pSendContext->pMessage2Request->pIrpToComplete = pSendContext->pIrpToComplete;
                    pSendContext->pIrpToComplete = NULL;
                }

                pSendContext->pMessage2Request->pMessage2Request = NULL;
                pSendContext->pMessage2Request = NULL;
            }

            PgmUnlock (pSend, *pOldIrq);
            PgmReleaseResource (&pSend->pSender->Resource);

            if (pSendContext->pIrpToComplete)
            {
                PgmIoComplete (pSendContext->pIrpToComplete, STATUS_UNSUCCESSFUL, 0);
            }
            PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);

            PgmAcquireResourceExclusive (&pSend->pSender->Resource, TRUE);
            PgmLock (pSend, *pOldIrq);
            ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext);
        }
        else
        {
            pSendContext->DataPacketsPacketized = pSendContext->NumDataPacketsSent;
            InsertTailList (&pSend->pSender->CompletedSendsInWindow, &pSendContext->Linkage);
        }
        return (status);
    }

    pSendContext->EndSequenceNumber = NextODataSequenceNumber - 1;

    if ((pSendContext->bLastSend) &&
        (!pSendContext->BytesLeftToPacketize))
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmPacketizeSend",
            "Calling PgmSetFin since bLastSend set for last packet!\n");

        pSendContext->bLastSend = FALSE;
        //
        // We have finished packetizing all the packets, but
        // since this is the last send we also need to set the
        // FIN on the last packet
        //
        PgmSetFin (pSend, pSendContext, pOldIrq);
    }

    ASSERT (!pSendContext->BytesLeftToPacketize);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmPacketizeSend",
        "TotalBytes=<%d>, BytesToPacketize=<%d>, SeqNums=[%d--%d]\n",
            pSendContext->BytesInSend, BytesToPacketize,
            (ULONG) pSendContext->StartSequenceNumber, (ULONG) pSendContext->EndSequenceNumber);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

VOID
PgmPrepareNextSend(
    IN  tSEND_SESSION       *pSend,
    IN  PGMLockHandle       *pOldIrq,
    IN  BOOLEAN             fPacketizeAll,
    IN  BOOLEAN             fResourceLockHeld
    )
/*++

Routine Description:

    This routine is called to prepare the next set of packets
    for sending on the wire
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pOldIrq     -- pSend's OldIrq

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    LIST_ENTRY                  *pEntry;
    tCLIENT_SEND_REQUEST        *pSendContext;
    NTSTATUS                    status;

    //
    // See if we need to packetize all pending sends or just ensure
    // that we have at least 1 send avaialble
    //
    if ((!fPacketizeAll) &&
        (!IsListEmpty (&pSend->pSender->PendingPacketizedSends)))
    {
        pSendContext = CONTAINING_RECORD (pSend->pSender->PendingPacketizedSends.Flink, tCLIENT_SEND_REQUEST, Linkage);
        if (pSendContext->NumDataPacketsSent < pSendContext->DataPacketsPacketized)
        {
            //
            // We have more packets to send!
            //
            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmPrepareNextSend",
                "Have more packets -- returning since caller preferred not to packetize!\n");
            return;
        }
    }

    if (!fResourceLockHeld)
    {
        PgmUnlock (pSend, *pOldIrq);
        PgmAcquireResourceExclusive (&pSend->pSender->Resource, TRUE);
        PgmLock (pSend, *pOldIrq);
    }

    pSendContext = NULL;
    if (!IsListEmpty (&pSend->pSender->PendingPacketizedSends))
    {
        //
        // See if we need to packetize the remaining bytes of the last send
        //
        pSendContext = CONTAINING_RECORD (pSend->pSender->PendingPacketizedSends.Blink, tCLIENT_SEND_REQUEST, Linkage);
        if (!pSendContext->BytesLeftToPacketize)
        {
            pSendContext = NULL;
        }
    }

    while (pSend->pSender->BufferSizeAvailable)
    {
        //
        // If we already have a send pending, see if we need to packetize
        // any more packets
        //
        if ((!pSendContext) &&
            (!IsListEmpty (&pSend->pSender->PendingSends)))
        {
            pEntry = RemoveHeadList (&pSend->pSender->PendingSends);
            InsertTailList (&pSend->pSender->PendingPacketizedSends, pEntry);
            pSendContext = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        }

        if (!pSendContext)
        {
            //
            // We have no more packets to packetize!
            //
            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmPrepareNextSend",
                "No more sends Pending!\n");

            break;
        }

        status = PgmPacketizeSend (pSend, pSendContext, pOldIrq);
        if (!NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmPrepareNextSend",
                "PgmPacketizeSend returned <%x>\n", status);
        }
        else if (pSendContext->BytesLeftToPacketize)
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmPrepareNextSend",
                "WARNING Packetizing buffer full!\n");

            ASSERT (pSend->pSender->BufferSizeAvailable <
                    (pSend->pSender->PacketBufferSize * pSend->FECGroupSize));
            break;
        }
        pSendContext = NULL;
    }

    if (!fResourceLockHeld)
    {
        PgmUnlock (pSend, *pOldIrq);
        PgmReleaseResource (&pSend->pSender->Resource);
        PgmLock (pSend, *pOldIrq);
    }

    return;
}


//----------------------------------------------------------------------------

VOID
PgmSendODataCompletion(
    IN  tCLIENT_SEND_REQUEST        *pSendContext,
    IN  tBASIC_DATA_PACKET_HEADER   *pODataBuffer,
    IN  NTSTATUS                    status
    )
/*++

Routine Description:

    This routine is called by the transport when the OData send has been completed

Arguments:

    IN  pSendContext    -- Pgm's Send context
    IN  pUnused         -- not used
    IN  status          --

Return Value:

    NONE

--*/
{
    ULONG                       SendLength;
    PGMLockHandle               OldIrq;
    PIRP                        pIrpCurrentSend = NULL;
    PIRP                        pIrpToComplete = NULL;
    tSEND_SESSION               *pSend = pSendContext->pSend;

    PgmLock (pSend, OldIrq);

    if (NT_SUCCESS (status))
    {
        //
        // Set the Ncf statistics
        //
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendODataCompletion",
            "SUCCEEDED\n");

        if (!(pODataBuffer->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY))
        {
            pSendContext->NumDataPacketsSentSuccessfully++;
        }
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendODataCompletion",
            "status=<%x>\n", status);
    }

    //
    // If all the OData has been sent, we may need to complete the Irp
    // Since we don't know whether we are on the CurrentSend or Completed
    // Sends list, we will need to also check the Bytes
    //
    if ((--pSendContext->NumSendsPending == 0) &&                       // No other sends pending
        (pSendContext->NumParityPacketsToSend == 0) &&                  // No parity packets pending
        (!pSendContext->BytesLeftToPacketize) &&                        // All bytes have been packetized
        (pSendContext->NumDataPacketsSent == pSendContext->DataPacketsPacketized))  // Pkts sent == total Pkts
    {
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendODataCompletion",
            "Completing Send#=<%d>, pIrp=<%p> for <%d> packets, Seq=[%d, %d]\n",
                pSendContext->SendNumber, pSendContext->pIrp, pSendContext->DataPacketsPacketized,
                (ULONG) pSendContext->StartSequenceNumber, (ULONG) pSendContext->EndSequenceNumber);

        pSend->DataBytes += pSendContext->BytesInSend;
        if (pIrpCurrentSend = pSendContext->pIrp)
        {
            if (pSendContext->NumDataPacketsSentSuccessfully == pSendContext->NumDataPacketsSent)
            {
                status = STATUS_SUCCESS;
                SendLength = pSendContext->BytesInSend;

                PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmSendODataCompletion",
                    "pIrp=<%p -- %p>, pSendContext=<%p>, NumPackets sent successfully = <%d/%d>\n",
                        pSendContext->pIrp, pSendContext->pIrpToComplete, pSendContext,
                        pSendContext->NumDataPacketsSentSuccessfully, pSendContext->NumDataPacketsSent);
            }
            else
            {
                PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendODataCompletion",
                    "pIrp=<%p -- %p>, pSendContext=<%p>, NumPackets sent successfully = <%d/%d>\n",
                        pSendContext->pIrp, pSendContext->pIrpToComplete, pSendContext,
                        pSendContext->NumDataPacketsSentSuccessfully, pSendContext->NumDataPacketsSent);

                status = STATUS_UNSUCCESSFUL;
                SendLength = 0;
            }

            pSendContext->pIrp = NULL;
            pIrpToComplete = pSendContext->pIrpToComplete;
        }
        else
        {
            ASSERT (0);     // To verify there is no double completion!
        }

        if (pSendContext->pMessage2Request)
        {
            //
            // We could have a situation where the send was split into 2, and
            // the second send could either be in the PendingSends list or
            // the PendingPacketizedSends list, or the CompletedSendsInWindow list
            //
            // We should have the other send complete the Irp and delink ourselves
            //
            ASSERT (pSendContext == pSendContext->pMessage2Request->pMessage2Request);

            if (pIrpToComplete)
            {
                ASSERT (!pSendContext->pMessage2Request->pIrpToComplete);
                pSendContext->pMessage2Request->pIrpToComplete = pSendContext->pIrpToComplete;
                pIrpToComplete = pSendContext->pIrpToComplete = NULL;
            }

            pSendContext->pMessage2Request->pMessage2Request = NULL;
            pSendContext->pMessage2Request = NULL;
        }
    }

    PgmUnlock (pSend, OldIrq);

    if (pODataBuffer)
    {
        ExFreeToNPagedLookasideList (&pSend->pSender->SenderBufferLookaside, pODataBuffer);
    }

    if (pIrpCurrentSend)
    {
        if (pIrpToComplete)
        {
            PgmIoComplete (pIrpToComplete, status, SendLength);
        }
        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
    }
}


//----------------------------------------------------------------------------

VOID
PgmBuildDataPacket(
    IN  tSEND_SESSION               *pSend,
    IN  tCLIENT_SEND_REQUEST        *pSendContext,
    IN  tPACKET_BUFFER              *pPacketBuffer,
    IN  PUCHAR                      pSendBuffer,
    IN  USHORT                      *pSendBufferLength
    )
{
    ULONG                               i;
    ULONG                               LateJoinerSequence;
    SEQ_TYPE                            FECGroupMask = pSend->FECGroupSize-1;
    tSEND_CONTEXT                       *pSender = pSend->pSender;
    tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader;
    tBASIC_DATA_PACKET_HEADER UNALIGNED *pODataBuffer = (tBASIC_DATA_PACKET_HEADER UNALIGNED *)
                                                        &pPacketBuffer->DataPacket;

    //
    // Get the SendLength and fill in the remaining fields of this send (Trailing edge + checksum)
    //
    *pSendBufferLength = pPacketBuffer->PacketOptions.TotalPacketLength;
    if (pPacketBuffer->PacketOptions.OptionsFlags & PGM_OPTION_FLAG_JOIN)
    {
        ASSERT (pODataBuffer->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT);
        if (pPacketBuffer->PacketOptions.LateJoinerOptionOffset)
        {
            if (SEQ_GT (pSend->pSender->LastODataSentSequenceNumber, (pSend->pSender->TrailingGroupSequenceNumber +
                                                                      pSend->pSender->LateJoinSequenceNumbers)))
            {
                LateJoinerSequence = (ULONG) (SEQ_TYPE) (pSend->pSender->LastODataSentSequenceNumber -
                                                         pSend->pSender->LateJoinSequenceNumbers);
            }
            else
            {
                LateJoinerSequence = (ULONG) (SEQ_TYPE) pSend->pSender->TrailingGroupSequenceNumber;
            }
            pPacketBuffer->PacketOptions.LateJoinerSequence = LateJoinerSequence;

            pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &((PUCHAR) (pODataBuffer + 1)) [pPacketBuffer->PacketOptions.LateJoinerOptionOffset];

            LateJoinerSequence =  htonl (LateJoinerSequence);
            PgmCopyMemory ((pOptionHeader + 1), &LateJoinerSequence, (sizeof(ULONG)));
        }
        else
        {
            ASSERT (0);
        }
    }

    PgmCopyMemory (pSendBuffer, pODataBuffer, *pSendBufferLength);

    //
    // Now, see if we need to build the parity context for the first
    // pro-active parity packet following this one
    //
    if ((pSend->FECProActivePackets) &&                                // Need to send FEC pro-active packets
        (pSendContext->NumParityPacketsToSend == pSend->FECProActivePackets))
    {
        //
        // Start from the Group leader packet
        //
        ASSERT (pSender->pLastProActiveGroupLeader);
        pPacketBuffer = pSender->pLastProActiveGroupLeader;
        pSendBuffer = (PUCHAR) pPacketBuffer;

        pSender->pProActiveParityContext->OptionsFlags = 0;
        pSender->pProActiveParityContext->NumPacketsInThisGroup = 0;

        for (i=0; i<pSend->FECGroupSize; i++)
        {
            pSender->pProActiveParityContext->pDataBuffers[i] = &((PUCHAR) &pPacketBuffer->DataPacket)[sizeof (tBASIC_DATA_PACKET_HEADER) +
                                                                                                      pPacketBuffer->PacketOptions.OptionsLength];
            pSender->pProActiveParityContext->OptionsFlags |= pPacketBuffer->PacketOptions.OptionsFlags &
                                                              (PGM_OPTION_FLAG_SYN |
                                                               PGM_OPTION_FLAG_FIN |
                                                               PGM_OPTION_FLAG_FRAGMENT |
                                                               PGM_OPTION_FLAG_PARITY_CUR_TGSIZE);

            if (pPacketBuffer->PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
            {
                ASSERT (!pSender->pProActiveParityContext->NumPacketsInThisGroup);
                ASSERT (pPacketBuffer->PacketOptions.FECContext.NumPacketsInThisGroup);
                pSender->pProActiveParityContext->NumPacketsInThisGroup = pPacketBuffer->PacketOptions.FECContext.NumPacketsInThisGroup;
            }

            pSendBuffer += pSender->PacketBufferSize;
            pPacketBuffer = (tPACKET_BUFFER *) pSendBuffer;
        }

        if (!(pSender->pProActiveParityContext->OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE))
        {
            ASSERT (!pSender->pProActiveParityContext->NumPacketsInThisGroup);
            pSender->pProActiveParityContext->NumPacketsInThisGroup = pSend->FECGroupSize;
        }
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendNextOData(
    IN  tSEND_SESSION       *pSend,
    IN  PGMLockHandle       *pOldIrq,
    OUT ULONG               *pBytesSent
    )
/*++

Routine Description:

    This routine is called to send a Data (OData) packet
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pOldIrq     -- pSend's OldIrq
    OUT pBytesSent  -- Set if send succeeded (used for calculating throughput)

Return Value:

    NTSTATUS - Final status of the send request

--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    ULONG                       i, XSum;
    USHORT                      SendBufferLength;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached;
    BOOLEAN                     fSendingFECPacket = FALSE;
    BOOLEAN                     fResetOptions = FALSE;
    tBASIC_DATA_PACKET_HEADER   *pODataBuffer = NULL;
    PUCHAR                      pSendBuffer = NULL;
    tCLIENT_SEND_REQUEST        *pSendContext;
    tPACKET_OPTIONS             PacketOptions;
    tPACKET_BUFFER              *pPacketBuffer;
    ULONG                       OptionValue;
    SEQ_TYPE                    FECGroupMask = pSend->FECGroupSize-1;
    UCHAR                       EmptyPackets = 0;
    tSEND_CONTEXT               *pSender = pSend->pSender;

    *pBytesSent = 0;        // Initialize
    pODataBuffer = NULL;

    if (IsListEmpty (&pSender->PendingPacketizedSends))
    {
        ASSERT (!IsListEmpty (&pSender->PendingSends));

        PgmPrepareNextSend (pSend, pOldIrq, FALSE, FALSE);

        return (STATUS_SUCCESS);
    }

    pSendContext = CONTAINING_RECORD (pSender->PendingPacketizedSends.Flink, tCLIENT_SEND_REQUEST, Linkage);

    //
    // This routine is called only if we have a packet to send, so
    // set pODataBuffer to the packet to be sent
    // NumDataPacketsSent and DataPacketsPacketized should both be 0 for a fresh send
    // They will be equal if we had run out of Buffer space for the last
    // packetization (i.e. Send length > available buffer space)
    //

    SendBufferLength = PGM_MAX_FEC_DATA_HEADER_LENGTH + (USHORT) pSender->MaxPayloadSize;
    if (!(pSendBuffer = ExAllocateFromNPagedLookasideList (&pSender->SenderBufferLookaside)))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendNextOData",
            "STATUS_INSUFFICIENT_RESOURCES\n");
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // See if we need to set the FIN flag
    //
    if ((pSendContext->bLastSend) &&
        (!pSendContext->BytesLeftToPacketize))
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmSendNextOData",
            "Calling PgmSetFin since bLastSend set for last packet!\n");

        pSendContext->bLastSend = FALSE;
        //
        // We have finished packetizing all the packets, but
        // since this is the last send we also need to set the
        // FIN on the last packet
        //
        PgmSetFin (pSend, pSendContext, pOldIrq);
    }

    if (pSendContext->NumParityPacketsToSend)
    {
        //
        // Release the Send lock and attach to the SectionMap process
        // to compute the parity packet
        //
        PgmUnlock (pSend, *pOldIrq);
        PgmAttachToProcessForVMAccess (pSend->Process, &ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);

        status = PgmBuildParityPacket (pSend,
                                       pSend->pSender->pLastProActiveGroupLeader,
                                       pSender->pProActiveParityContext,
                                       (PUCHAR) pSendBuffer,
                                       &SendBufferLength,
                                       PACKET_TYPE_ODATA);

        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);
        PgmLock (pSend, *pOldIrq);

        if (!NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendNextOData",
                "PgmBuildParityPacket returned <%x>\n", status);

            ExFreeToNPagedLookasideList (&pSender->SenderBufferLookaside, pSendBuffer);
            return (STATUS_SUCCESS);
        }

        pODataBuffer = (tBASIC_DATA_PACKET_HEADER *) pSendBuffer;
        ASSERT (SendBufferLength <= (PGM_MAX_FEC_DATA_HEADER_LENGTH +
                                    htons (pODataBuffer->CommonHeader.TSDULength)));
        fSendingFECPacket = TRUE;

        pSendContext->NumParityPacketsToSend--;
        pSendContext->NumSendsPending++;
    }
    else if (pSendContext->NumDataPacketsSent < pSendContext->DataPacketsPacketized)
    {
        //
        // Verify that this send has already been packetized
        //
        ASSERT (pSendContext->BytesLeftToPacketize < pSendContext->BytesInSend);

        //
        // Get the current send packet and send length
        //
        pPacketBuffer = (tPACKET_BUFFER *) (pSender->SendDataBufferMapping + pSendContext->NextPacketOffset);
        pODataBuffer = &pPacketBuffer->DataPacket;
        pSendContext->NumSendsPending++;
        if (0 == pSendContext->NumDataPacketsSent++)
        {
            pSendContext->SendStartTime = pSend->pSender->TimerTickCount;
        }

        //
        // Update the sender parameters
        //
        pSender->LastODataSentSequenceNumber++;

        if (pSend->FECOptions)              // Need to send FEC pro-active packets
        {
            //
            // See if we are at the end of a variable TG send
            //
            if (pODataBuffer == pSendContext->pLastMessageVariableTGPacket)
            {
                pSender->LastVariableTGPacketSequenceNumber = pSender->LastODataSentSequenceNumber;
                EmptyPackets = (UCHAR) (FECGroupMask - (pSender->LastODataSentSequenceNumber & FECGroupMask));
                pSendContext->NumParityPacketsToSend = pSend->FECProActivePackets;
            }
            //
            // Otherwise see if the next send needs to be for pro-active parity
            //
            else if ((pSend->FECProActivePackets) &&                                // Need to send FEC pro-active packets
                     (FECGroupMask == (pSender->LastODataSentSequenceNumber & FECGroupMask)))    // Last Packet In Group
            {
                pSendContext->NumParityPacketsToSend = pSend->FECProActivePackets;
            }

            //
            // If this is the GroupLeader packet, and we have pro-active parity enabled,
            // then we need to set the buffer information for computing the FEC packets
            //
            if ((pSend->FECProActivePackets) &&         // Need to send FEC pro-active packets
                (0 == (pSender->LastODataSentSequenceNumber & FECGroupMask)))    // GroupLeader
            {
                pSender->pLastProActiveGroupLeader = pPacketBuffer;
            }
        }

        //
        // Since we will be accessing the buffer, we will need to release the
        // lock to get at passive Irql + attach to the process
        //
        PgmUnlock (pSend, *pOldIrq);
        PgmAttachToProcessForVMAccess (pSend->Process, &ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);

        PgmBuildDataPacket (pSend, pSendContext, pPacketBuffer, pSendBuffer, &SendBufferLength);

        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);
        PgmLock (pSend, *pOldIrq);

        pODataBuffer = (tBASIC_DATA_PACKET_HEADER *) pSendBuffer;

        //
        // Verify that the packet we are sending is what we think we are sending!
        //
        ASSERT (ntohl(pODataBuffer->DataSequenceNumber) == (LONG) pSender->LastODataSentSequenceNumber);

        pSender->EmptySequencesForLastSend = EmptyPackets;
        pSender->LastODataSentSequenceNumber += EmptyPackets;

    }
    else
    {
        ExFreeToNPagedLookasideList (&pSender->SenderBufferLookaside, pSendBuffer);
        pSendBuffer = NULL;
    }

    //
    // Now, set the parameters for the next send
    //
    if ((pSendBuffer) &&
        (!pSendContext->NumParityPacketsToSend))    // Verify no pro-active parity packets following this
    {
        pSendContext->NextPacketOffset += ((1 + EmptyPackets) * pSender->PacketBufferSize);
        if (pSendContext->NextPacketOffset >= pSender->MaxDataFileSize)
        {
            pSendContext->NextPacketOffset = 0;                                 // We need to wrap around!
        }
    }

    //
    // If we have sent all the data for this Send (or however many bytes
    // we had packetized from this send), we need to packetize more packets
    //
    if ((pSendContext->NumDataPacketsSent == pSendContext->DataPacketsPacketized) &&
        (!pSendContext->NumParityPacketsToSend))
    {
        //
        // If we are done with this send, move it to the CompletedSends list
        // The last send completion will complete the Send Irp
        //
        if (!pSendContext->BytesLeftToPacketize)
        {
            ASSERT (pSend->pSender->LastODataSentSequenceNumber == pSendContext->EndSequenceNumber);
            ASSERT (pSendContext->NumSendsPending);

            RemoveEntryList (&pSendContext->Linkage);
            InsertTailList (&pSender->CompletedSendsInWindow, &pSendContext->Linkage);
            pSender->NumODataRequestsPending--;
            //
            // If the last packet on this Send had a FIN, we will need to
            // follow this send with an Ambient SPM including the FIN flag
            //
            ASSERT (!pSendContext->bLastSend);
            if (pSendContext->DataOptions & PGM_OPTION_FLAG_FIN)
            {
                PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmSendNextOData",
                    "Setting FIN since client closed session!\n");

                pSender->SpmOptions |= PGM_OPTION_FLAG_FIN;
                pSender->CurrentSPMTimeout = pSender->AmbientSPMTimeout;
                pSend->SessionFlags |= PGM_SESSION_FLAG_SEND_AMBIENT_SPM;
            }
        }

        PgmPrepareNextSend (pSend, pOldIrq, FALSE, FALSE);
    }

    if (!pSendBuffer)
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmSendNextOData",
            "Setting FIN since client closed session!\n");
        //
        // This was the case of a new Send waiting to be packetized
        // Return success here, and we should get called again for the
        // actual send
        //
        return (STATUS_SUCCESS);
    }

    PgmUnlock (pSend, *pOldIrq);

    pODataBuffer->TrailingEdgeSequenceNumber = htonl ((ULONG) pSender->TrailingGroupSequenceNumber);
    XSum = 0;
    pODataBuffer->CommonHeader.Checksum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pODataBuffer, SendBufferLength);       // Compute the Checksum
    pODataBuffer->CommonHeader.Checksum = (USHORT) (~XSum);

    status = TdiSendDatagram (pSender->pAddress->pFileObject,
                              pSender->pAddress->pDeviceObject,
                              pODataBuffer,
                              (ULONG) SendBufferLength,
                              PgmSendODataCompletion,   // Completion
                              pSendContext,             // Context1
                              pODataBuffer,             // Context2
                              pSender->DestMCastIpAddress,
                              pSender->DestMCastPort);

    ASSERT (NT_SUCCESS (status));

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendNextOData",
        "[%d-%d] -- Sent <%d> bytes to <%x:%d>\n",
            (ULONG) pSender->TrailingGroupSequenceNumber,
            (ULONG) pSender->LastODataSentSequenceNumber,
            SendBufferLength, pSender->DestMCastIpAddress, pSender->DestMCastPort);

    PgmLock (pSend, *pOldIrq);

    *pBytesSent = SendBufferLength;
    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmCancelAllSends(
    IN  tSEND_SESSION           *pSend,
    IN  LIST_ENTRY              *pListEntry,
    IN  PIRP                    pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Send Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    None

--*/
{
    PLIST_ENTRY             pEntry;
    tCLIENT_SEND_REQUEST    *pSendContext;
    PIRP                    pIrpToComplete = NULL;
    SEQ_TYPE                HighestLeadSeq;
    ULONG                   NumExSequencesInOldWindow, NumRequests = 0;
    ULONGLONG               BufferSpaceFreed;

    //
    // Now cancel all the remaining send requests because the integrity
    // of the data cannot be guaranteed
    // We also have to deal with the fact that some Irps may have
    // data in the transport (i.e. possibly the first send on the Packetized
    // list, or the last send of the completed list)
    //
    // We will start with the unpacketized requests
    //
    while (!IsListEmpty (&pSend->pSender->PendingSends))
    {
        pEntry = RemoveHeadList (&pSend->pSender->PendingSends);
        pSendContext = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        InsertTailList (pListEntry, pEntry);
        NumRequests++;

        ASSERT (!pSendContext->NumSendsPending);

        //
        // If this is a partial send, we will mark the Irp for completion
        // initially to the companion send request (to avoid complications
        // of Sends pending in the transport here)
        //
        if (pSendContext->pMessage2Request)
        {
            //
            // pMessage2Request could either be on the PendingPacketizedSends
            // list or on the Completed Sends list (awaiting a send completion)
            //
            ASSERT (pSendContext->pMessage2Request->pIrp);
            if (pSendContext->pIrpToComplete)
            {
                ASSERT (!pSendContext->pMessage2Request->pIrpToComplete);
                pSendContext->pMessage2Request->pIrpToComplete = pSendContext->pIrpToComplete;
                pSendContext->pIrpToComplete = NULL;
            }

            pSendContext->pMessage2Request->pMessage2Request = NULL;
            pSendContext->pMessage2Request = NULL;
        }

        ASSERT (pSendContext->BytesLeftToPacketize == pSendContext->BytesInSend);
        pSend->pSender->NumODataRequestsPending--;
        pSend->pSender->NumPacketsRemaining -= pSendContext->NumPacketsRemaining;
    }

    //
    // Now, go through all the sends which have already been packetized
    // except for the first one which we will handle below
    //
    HighestLeadSeq = pSend->pSender->NextODataSequenceNumber;
    pEntry = pSend->pSender->PendingPacketizedSends.Flink;
    while ((pEntry = pEntry->Flink) != &pSend->pSender->PendingPacketizedSends)
    {
        pSendContext = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        pEntry = pEntry->Blink;
        RemoveEntryList (&pSendContext->Linkage);
        InsertTailList (pListEntry, &pSendContext->Linkage);
        pSend->pSender->NumODataRequestsPending--;
        pSend->pSender->NumPacketsRemaining -= pSendContext->NumPacketsRemaining;
        NumRequests++;

        if (SEQ_LT (pSendContext->StartSequenceNumber, HighestLeadSeq))
        {
            HighestLeadSeq = pSendContext->StartSequenceNumber;
        }

        ASSERT ((!pSendContext->NumDataPacketsSent) && (!pSendContext->NumSendsPending));
        if (pSendContext->pMessage2Request)
        {
            //
            // pMessage2Request could either be on the PendingPacketizedSends
            // list or on the Completed Sends list (awaiting a send completion)
            //
            ASSERT (pSendContext->pMessage2Request->pIrp);
            if (pSendContext->pIrpToComplete)
            {
                ASSERT (!pSendContext->pMessage2Request->pIrpToComplete);
                pSendContext->pMessage2Request->pIrpToComplete = pSendContext->pIrpToComplete;
                pSendContext->pIrpToComplete = NULL;
            }

            pSendContext->pMessage2Request->pMessage2Request = NULL;
            pSendContext->pMessage2Request = NULL;
        }
    }

    //
    // Terminate the first PendingPacketizedSend only if we have not
    // yet started sending it or this Cancel was meant for that request
    // (Try to protect data integrity as much as possible)
    //
    if (!IsListEmpty (&pSend->pSender->PendingPacketizedSends))
    {
        pSendContext = CONTAINING_RECORD (pSend->pSender->PendingPacketizedSends.Flink, tCLIENT_SEND_REQUEST, Linkage);
        if ((!pSendContext->NumDataPacketsSent) ||
            (!pIrp || (pSendContext->pIrp == pIrp)))
        {
            RemoveEntryList (&pSendContext->Linkage);
            ASSERT (IsListEmpty (&pSend->pSender->PendingPacketizedSends));
            NumRequests++;

            //
            // If we have some data pending in the transport,
            // then we will have to let the SendCompletion handle that
            //
            ASSERT ((pSendContext->NumDataPacketsSent < pSendContext->DataPacketsPacketized) ||
                    (pSendContext->NumParityPacketsToSend));

            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmCancelAllSends",
                "Partial Send, pIrp=<%p>, BytesLeftToPacketize=<%d/%d>, PacketsSent=<%d/%d>, Pending=<%d>\n",
                    pSendContext->pIrp, pSendContext->BytesLeftToPacketize,
                    pSendContext->BytesInSend, pSendContext->NumDataPacketsSent,
                    pSendContext->DataPacketsPacketized, pSendContext->NumSendsPending);

            pSendContext->BytesLeftToPacketize = 0;
            pSendContext->DataPacketsPacketized = pSendContext->NumDataPacketsSent;
            pSendContext->NumParityPacketsToSend = 0;

            pSend->pSender->NumODataRequestsPending--;
            pSend->pSender->NumPacketsRemaining -= pSendContext->NumPacketsRemaining;

            if (pSendContext->NumSendsPending)
            {
                InsertTailList (&pSend->pSender->CompletedSendsInWindow, &pSendContext->Linkage);
            }
            else
            {
                //
                // If we have a companion partial, then it must be in the completed list
                // awaiting SendCompletion
                //
                if (pSendContext->pMessage2Request)
                {
                    ASSERT (pSendContext->pMessage2Request->pIrp);
                    if (pSendContext->pIrpToComplete)
                    {
                        ASSERT (!pSendContext->pMessage2Request->BytesLeftToPacketize);
                        ASSERT (!pSendContext->pMessage2Request->pIrpToComplete);
                        pSendContext->pMessage2Request->pIrpToComplete = pSendContext->pIrpToComplete;
                        pSendContext->pIrpToComplete = NULL;
                    }

                    pSendContext->pMessage2Request->pMessage2Request = NULL;
                    pSendContext->pMessage2Request = NULL;
                }

                InsertTailList (pListEntry, &pSendContext->Linkage);
            }

            pSendContext->EndSequenceNumber = pSend->pSender->LastODataSentSequenceNumber;
            HighestLeadSeq = pSend->pSender->LastODataSentSequenceNumber + 1;
        }
    }

    NumExSequencesInOldWindow = (ULONG) (SEQ_TYPE) (pSend->pSender->NextODataSequenceNumber-HighestLeadSeq);
    BufferSpaceFreed = NumExSequencesInOldWindow * pSend->pSender->PacketBufferSize;
    if (NumExSequencesInOldWindow)
    {
        pSend->SessionFlags |= PGM_SESSION_SENDS_CANCELLED;

        PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmCancelAllSends",
            "[%d]: NumSeqs=<%d>, NextOData=<%d-->%d>, BuffFreeed=<%d>, LeadingOffset=<%d-->%d>\n",
                NumRequests, NumExSequencesInOldWindow,
                (ULONG) pSend->pSender->NextODataSequenceNumber, (ULONG) HighestLeadSeq,
                (ULONG) BufferSpaceFreed, (ULONG) pSend->pSender->LeadingWindowOffset,
                (ULONG) (pSend->pSender->LeadingWindowOffset - BufferSpaceFreed));
    }

    pSend->pSender->NextODataSequenceNumber = HighestLeadSeq;

    pSend->pSender->BufferSizeAvailable += BufferSpaceFreed;
    ASSERT (pSend->pSender->BufferSizeAvailable <= pSend->pSender->MaxDataFileSize);
    if (pSend->pSender->LeadingWindowOffset >= BufferSpaceFreed)
    {
        pSend->pSender->LeadingWindowOffset -= BufferSpaceFreed;
    }
    else
    {
        pSend->pSender->LeadingWindowOffset = pSend->pSender->MaxDataFileSize - (BufferSpaceFreed - pSend->pSender->LeadingWindowOffset);
    }
}


//----------------------------------------------------------------------------

ULONG
AdvanceWindow(
    IN  tSEND_SESSION       *pSend
    )
/*++

Routine Description:

    This routine is called to check if we need to advance the
    trailing window, and does so as appropriate
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context

Return Value:

    TRUE if the send window buffer is empty, FALSE otherwise

--*/
{
    LIST_ENTRY              *pEntry;
    tCLIENT_SEND_REQUEST    *pSendContextLast;
    tCLIENT_SEND_REQUEST    *pSendContext1;
    tSEND_RDATA_CONTEXT     *pRDataContext;
    SEQ_TYPE                HighestTrailSeq, MaxSequencesToAdvance, SequencesInSend;
    ULONGLONG               PreferredTrailTime = 0;
    ULONG                   NumExSequencesInOldWindow = 0;

    //
    // See if we need to increment the Trailing edge of our transmit window
    //
    if (pSend->pSender->TimerTickCount > pSend->pSender->NextWindowAdvanceTime)
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "AdvanceWindow",
            "Advancing NextWindowAdvanceTime -- TimerTC = [%d:%d] >= NextWinAdvT [%d:%d]\n",
                pSend->pSender->TimerTickCount, pSend->pSender->NextWindowAdvanceTime);

        pSend->pSender->NextWindowAdvanceTime = pSend->pSender->TimerTickCount +
                                                pSend->pSender->WindowAdvanceDeltaTime;
    }

    PreferredTrailTime = (pSend->pSender->NextWindowAdvanceTime - pSend->pSender->WindowAdvanceDeltaTime) -
                        pSend->pSender->WindowSizeTime;

    //
    // Determine the maximum sequences we can advance by (initially all seqs in window)
    //
    MaxSequencesToAdvance = pSend->pSender->LastODataSentSequenceNumber -
                            pSend->pSender->TrailingEdgeSequenceNumber + 1;
    //
    // If we are required to advance the window on-demand, then we
    // will need to limit the Maximum sequences we can advance by
    //
    if ((pSend->pSender->pAddress->Flags & PGM_ADDRESS_USE_WINDOW_AS_DATA_CACHE) &&
        !(pSend->SessionFlags & PGM_SESSION_DISCONNECT_INDICATED))
    {
        if (MaxSequencesToAdvance > (pSend->pSender->MaxPacketsInBuffer >> 1))
        {
            MaxSequencesToAdvance -= (ULONG) (pSend->pSender->MaxPacketsInBuffer >> 1);
        }
        else
        {
            MaxSequencesToAdvance = 0;
        }
    }

    if ((MaxSequencesToAdvance) &&
        (PreferredTrailTime >= pSend->pSender->TrailingEdgeTime))   // need to reset our current trailing edge
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "AdvanceWindow",
            "PreferredTrail=[%d:%d] > TrailingEdge=[%d:%d], WinAdvMSecs=<%d:%d>, WinSizeMSecs=<%d:%d>\n",
                PreferredTrailTime, pSend->pSender->TrailingEdgeTime, pSend->pSender->WindowAdvanceDeltaTime,
                pSend->pSender->WindowSizeTime);

        //
        // First determine what is the maximum limit we can advance the
        // window to (dependent on pending RData and send completions)
        //
        HighestTrailSeq = pSend->pSender->NextODataSequenceNumber & ~((SEQ_TYPE) pSend->FECGroupSize-1);       // Init

        // Start with pending RData requests
        if (!IsListEmpty (&pSend->pSender->PendingRDataRequests))
        {
            //
            // This list is ordered, so just compare with the first entry
            //
            pEntry = pSend->pSender->PendingRDataRequests.Flink;
            pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
            if (SEQ_LT (pRDataContext->RDataSequenceNumber, HighestTrailSeq))
            {
                HighestTrailSeq = pRDataContext->RDataSequenceNumber;
            }
        }
        // Now, verify that the handled RData requests do not need this
        // buffer memory (i.e. the Sends have completed)
        pEntry = &pSend->pSender->HandledRDataRequests;
        while ((pEntry = pEntry->Flink) != &pSend->pSender->HandledRDataRequests)
        {
            pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
            if ((!pRDataContext->CleanupTime) &&    // CleanupTime is 0 for pending sends
                SEQ_LT (pRDataContext->RDataSequenceNumber, HighestTrailSeq))
            {
                HighestTrailSeq = pRDataContext->RDataSequenceNumber;
            }
        }

        // Now, check the completed sends list
        pSendContextLast = pSendContext1 = NULL;
        pEntry = &pSend->pSender->CompletedSendsInWindow;
        while ((pEntry = pEntry->Flink) != &pSend->pSender->CompletedSendsInWindow)
        {
            pSendContext1 = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
            ASSERT (SEQ_GEQ (pSendContext1->EndSequenceNumber, pSend->pSender->TrailingEdgeSequenceNumber));
            if (SEQ_GT (pSend->pSender->TrailingEdgeSequenceNumber, pSendContext1->StartSequenceNumber))
            {
                SequencesInSend = pSendContext1->EndSequenceNumber - pSend->pSender->TrailingEdgeSequenceNumber + 1;
            }
            else
            {
                SequencesInSend = pSendContext1->EndSequenceNumber - pSendContext1->StartSequenceNumber + 1;
            }

            if ((pSendContext1->NumSendsPending) ||         // Cannot advance if completions are pending
                (pSendContext1->SendStartTime >= PreferredTrailTime) ||
                (MaxSequencesToAdvance < SequencesInSend))
            {
                if (SEQ_LT (pSendContext1->StartSequenceNumber, HighestTrailSeq))
                {
                    HighestTrailSeq = pSendContext1->StartSequenceNumber;
                }
                break;
            }
            else if (SEQ_GEQ (pSendContext1->StartSequenceNumber, HighestTrailSeq))
            {
                break;
            }

            ASSERT (MaxSequencesToAdvance);
            if (pSendContextLast)
            {
                MaxSequencesToAdvance -= (pSendContextLast->EndSequenceNumber -
                                          pSendContextLast->StartSequenceNumber + 1);

                // Remove the send that is definitely out of the new window
                RemoveEntryList (&pSendContextLast->Linkage);
                ASSERT ((!pSendContextLast->pMessage2Request) && (!pSendContextLast->pIrp));
                ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside,pSendContextLast);
            }
            pSendContextLast = pSendContext1;
        }

        //
        // pSendContext1 will be NULL if there are no completed sends,
        // in which case we may have 1 huge current send that could be hogging
        // our buffer, so check that then!
        //
        if ((!pSendContext1) &&
            (!IsListEmpty (&pSend->pSender->PendingPacketizedSends)))
        {
            pSendContextLast = CONTAINING_RECORD (pSend->pSender->PendingPacketizedSends.Flink, tCLIENT_SEND_REQUEST, Linkage);
            if ((pSendContextLast->NumSendsPending) ||   // Ensure no sends pending
                (pSendContextLast->NumParityPacketsToSend) ||   // No parity packets left to send
                (!pSendContextLast->NumDataPacketsSent) || // No packets sent yet
                (pSendContextLast->DataPacketsPacketized != pSendContextLast->NumDataPacketsSent))
            {
                pSendContextLast = NULL;
            }
        }

        //
        // pSendContextLast will be non-NULL if we need to advance
        // the Trailing edge
        //
        if (pSendContextLast)
        {
            //
            // Do some sanity checks!
            //
            ASSERT (PreferredTrailTime >= pSendContextLast->SendStartTime);
            ASSERT (SEQ_GEQ (pSendContextLast->EndSequenceNumber,pSend->pSender->TrailingEdgeSequenceNumber));
            ASSERT (SEQ_GEQ (HighestTrailSeq, pSendContextLast->StartSequenceNumber));
            ASSERT (SEQ_GEQ (HighestTrailSeq, pSend->pSender->TrailingEdgeSequenceNumber));

            //
            // See if this send is partially in or out of the window now!
            // Calculate the offset of sequences in this Send request for the
            // preferred trail time
            //
            NumExSequencesInOldWindow = (ULONG) (SEQ_TYPE) (((PreferredTrailTime-pSendContextLast->SendStartTime)*
                                                             BASIC_TIMER_GRANULARITY_IN_MSECS * pSend->pSender->pAddress->RateKbitsPerSec) /
                                                            (pSend->pSender->pAddress->OutIfMTU * BITS_PER_BYTE));

            //
            // Now, adjust this offset to the trailing edge
            //
            if (SEQ_GT ((pSendContextLast->StartSequenceNumber + NumExSequencesInOldWindow),
                        pSend->pSender->TrailingEdgeSequenceNumber))
            {
                NumExSequencesInOldWindow = pSendContextLast->StartSequenceNumber +
                                            NumExSequencesInOldWindow -
                                            pSend->pSender->TrailingEdgeSequenceNumber;
            }
            else
            {
                ASSERT (pSend->pSender->TrailingEdgeSequenceNumber ==
                        (pSendContextLast->StartSequenceNumber + NumExSequencesInOldWindow));

                NumExSequencesInOldWindow = 0;
            }

            //
            // Now, limit the # sequences to advance with the window size
            //
            if (NumExSequencesInOldWindow > MaxSequencesToAdvance)
            {
                NumExSequencesInOldWindow = MaxSequencesToAdvance;
            }

            //
            // Finally, see if we need to limit the advance based on the RData pending requests
            //
            if (SEQ_GT (HighestTrailSeq, (pSend->pSender->TrailingEdgeSequenceNumber +
                                          NumExSequencesInOldWindow)))
            {
                HighestTrailSeq = (SEQ_TYPE) (pSend->pSender->TrailingEdgeSequenceNumber + NumExSequencesInOldWindow);
            }
            else if (SEQ_GEQ (HighestTrailSeq, pSend->pSender->TrailingEdgeSequenceNumber))
            {
                //
                // We are limited by the pending RData
                // So, recalculate the PreferredTrailTime (to set the actual trail time)!
                //
                NumExSequencesInOldWindow = (ULONG) (SEQ_TYPE) (HighestTrailSeq - pSend->pSender->TrailingEdgeSequenceNumber);
                PreferredTrailTime = (NumExSequencesInOldWindow * pSend->pSender->pAddress->OutIfMTU * BITS_PER_BYTE) /
                                     (pSend->pSender->pAddress->RateKbitsPerSec * BASIC_TIMER_GRANULARITY_IN_MSECS);
                PreferredTrailTime += pSend->pSender->TrailingEdgeTime;
            }

            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "AdvanceWindow",
                "LastSend: NumExSeq=<%d>, HighestTrailSeq=<%d>, PreferredTrailTime=<%d:%d>\n",
                    (ULONG) NumExSequencesInOldWindow, (ULONG) HighestTrailSeq, PreferredTrailTime);

            if (SEQ_GT (HighestTrailSeq, pSendContextLast->EndSequenceNumber) &&
                (!pSendContextLast->BytesLeftToPacketize))
            {
                //
                // We can drop this whole send since it is outside of our window
                // Set the new trailing edge based on whether we have a following
                // send or not!
                //
                if ((pSendContext1) &&
                    (pSendContext1 != pSendContextLast))
                {
                    //
                    // Readjust the trailing time to the next send
                    //
                    PreferredTrailTime = pSendContext1->SendStartTime;
                }
                HighestTrailSeq = pSendContextLast->EndSequenceNumber + 1;

                // Remove this send and free it!
                ASSERT ((!pSendContextLast->pMessage2Request) && (!pSendContextLast->pIrp));
                RemoveEntryList (&pSendContextLast->Linkage);
                ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside,pSendContextLast);
            }

            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "AdvanceWindow",
                "Window Adv: NumSeq=<%d>, TrailSeqNum=<%d>==><%d>, TrailTime=<%d:%d>==><%d:%d>\n",
                    (ULONG) NumExSequencesInOldWindow, (ULONG) pSend->pSender->TrailingGroupSequenceNumber,
                    (ULONG) HighestTrailSeq, pSend->pSender->TrailingEdgeTime, PreferredTrailTime);

            //
            // Now, adjust the buffer settings
            //
            ASSERT (SEQ_GEQ (HighestTrailSeq, pSend->pSender->TrailingEdgeSequenceNumber));
            NumExSequencesInOldWindow = (ULONG) (SEQ_TYPE) (HighestTrailSeq - pSend->pSender->TrailingEdgeSequenceNumber);
            pSend->pSender->BufferSizeAvailable += (NumExSequencesInOldWindow * pSend->pSender->PacketBufferSize);
            ASSERT (pSend->pSender->BufferSizeAvailable <= pSend->pSender->MaxDataFileSize);
            pSend->pSender->TrailingWindowOffset += (NumExSequencesInOldWindow * pSend->pSender->PacketBufferSize);
            if (pSend->pSender->TrailingWindowOffset >= pSend->pSender->MaxDataFileSize)
            {
                // Wrap around case!
                pSend->pSender->TrailingWindowOffset -= pSend->pSender->MaxDataFileSize;
            }
            ASSERT (pSend->pSender->TrailingWindowOffset < pSend->pSender->MaxDataFileSize);
            pSend->pSender->TrailingEdgeSequenceNumber = HighestTrailSeq;
            pSend->pSender->TrailingGroupSequenceNumber = (HighestTrailSeq+pSend->FECGroupSize-1) &
                                                          ~((SEQ_TYPE) pSend->FECGroupSize-1);
            pSend->pSender->TrailingEdgeTime = PreferredTrailTime;
        } // else nothing to advance!
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "AdvanceWindow",
        "Transmit Window Range=[%d, %d], TimerTC=[%d:%d]\n",
            (ULONG) pSend->pSender->TrailingEdgeSequenceNumber,
            (ULONG) (pSend->pSender->NextODataSequenceNumber-1),
            pSend->pSender->TimerTickCount);

    return (NumExSequencesInOldWindow);
}


//----------------------------------------------------------------------------

BOOLEAN
CheckForTermination(
    IN  tSEND_SESSION       *pSend,
    IN  PGMLockHandle       *pOldIrq
    )
/*++

Routine Description:

    This routine is called to check and terminate the session
    if necessary.
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context

Return Value:

    TRUE if the send window buffer is empty, FALSE otherwise

--*/
{
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              ListEntry;
    tCLIENT_SEND_REQUEST    *pSendContext;
    tSEND_RDATA_CONTEXT     *pRDataContext;
    PIRP                    pIrp;
    ULONG                   NumSequences;

    if (!(PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_DOWN)) &&
        !(PGM_VERIFY_HANDLE (pSend->pSender->pAddress, PGM_VERIFY_ADDRESS_DOWN)) &&
        !(pSend->SessionFlags & PGM_SESSION_CLIENT_DISCONNECTED))
    {
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_CONNECT, "CheckForTermination",
            "Session for pSend=<%p> does not need to be terminated\n", pSend);

        return (FALSE);
    }

    //
    // See if we have processed the disconnect for the first time yet
    //
    if (!(pSend->SessionFlags & PGM_SESSION_DISCONNECT_INDICATED))
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_CONNECT, "CheckForTermination",
            "Session is going down!, Packets remaining=<%d>\n", pSend->pSender->NumPacketsRemaining);

        pSend->SessionFlags |= PGM_SESSION_DISCONNECT_INDICATED;

        //
        // We have to set the FIN on the Data as well as SPM packets.
        // Thus, there are 2 situations -- either we have finished sending
        // all the Data packets, or we are still in the midst of sending
        //
        // If there are no more sends pending, we will have to
        // modify the last packet ourselves to set the FIN option
        //
        if (!IsListEmpty (&pSend->pSender->PendingSends))
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_CONNECT, "CheckForTermination",
                "Send pending on list -- setting bLastSend for FIN on last Send\n");

            pSendContext = CONTAINING_RECORD (pSend->pSender->PendingSends.Blink, tCLIENT_SEND_REQUEST,Linkage);

            //
            // We will just set a flag here, so that when the last packet
            // is packetized, the FIN flags are set
            //
            pSendContext->bLastSend = TRUE;
        }
        else if (pSend->pSender->NumODataRequestsPending)
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_CONNECT, "CheckForTermination",
                "Last Send in progress -- setting bLastSend for FIN on this Send\n");

            //
            // If have already packetized the last send, but have not yet
            // sent it out, then PgmSendNextOData will put the FIN in the data packet
            // otherwise, if we have not yet packetized the packet, then we will set the
            // FIN option while preparing the last packet
            //
            pSendContext = CONTAINING_RECORD (pSend->pSender->PendingPacketizedSends.Blink, tCLIENT_SEND_REQUEST,Linkage);
            pSendContext->bLastSend = TRUE;
        }
        else
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_CONNECT, "CheckForTermination",
                "No Sends in progress -- setting FIN for next SPM\n");

            //
            // We have finished packetizing and sending all the packets,
            // so set the FIN flag on the SPMs and also modify the last
            // RData packet (if still in the window) for the FIN -- this
            // will be done when the next RData packet is sent out
            //
            if (pSend->SessionFlags & PGM_SESSION_SENDS_CANCELLED)
            {
                pSend->pSender->SpmOptions &= ~PGM_OPTION_FLAG_FIN;
                pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_RST;
            }
            else
            {
                pSend->pSender->SpmOptions &= ~PGM_OPTION_FLAG_RST;
                pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_FIN;
            }

            //
            // We also need to send an SPM immediately
            //
            pSend->pSender->CurrentSPMTimeout = pSend->pSender->AmbientSPMTimeout;
            pSend->SessionFlags |= PGM_SESSION_FLAG_SEND_AMBIENT_SPM;
        }

        return (FALSE);
    }

    //
    // If we have a (graceful) disconnect Irp to complete, we should complete
    // it if we have timed out, or are ready to do so now
    //
    if ((pIrp = pSend->pIrpDisconnect) &&                               // Disconnect Irp pending
        (((pSend->pSender->DisconnectTimeInTicks) && (pSend->pSender->TimerTickCount >
                                                      pSend->pSender->DisconnectTimeInTicks)) ||
         ((IsListEmpty (&pSend->pSender->PendingSends)) &&              // No Unpacketized Sends pending
          (IsListEmpty (&pSend->pSender->PendingPacketizedSends)) &&    // No Packetized sends pending
          (IsListEmpty (&pSend->pSender->PendingRDataRequests))   &&    // No Pending RData requests
          (IsListEmpty (&pSend->pSender->CompletedSendsInWindow)) &&    // Window is Empty
          (pSend->pSender->SpmOptions & (PGM_OPTION_FLAG_FIN |          // FIN | RST | RST_N set on SPMs
                                         PGM_OPTION_FLAG_RST |
                                         PGM_OPTION_FLAG_RST_N))   &&
          !(pSend->SessionFlags & PGM_SESSION_FLAG_SEND_AMBIENT_SPM)))) // No  Ambient Spm pending
    {
        pSend->pIrpDisconnect = NULL;
        PgmUnlock (pSend, *pOldIrq);

        PgmLog (PGM_LOG_INFORM_STATUS, DBG_CONNECT, "CheckForTermination",
            "Completing Graceful disconnect pIrp=<%p>\n", pIrp);

        PgmIoComplete (pIrp, STATUS_SUCCESS, 0);

        PgmLock (pSend, *pOldIrq);
        return (FALSE);
    }

    //
    // Do the final cleanup only if the handles have been closed
    // or the disconnect has timed out
    //
    if (!(PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_DOWN)) &&
        !(PGM_VERIFY_HANDLE (pSend->pSender->pAddress, PGM_VERIFY_ADDRESS_DOWN)) &&
        ((!pSend->pSender->DisconnectTimeInTicks) || (pSend->pSender->TimerTickCount <
                                                      pSend->pSender->DisconnectTimeInTicks)))
    {
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_CONNECT, "CheckForTermination",
            "Handles have not yet been closed for pSend=<%p>, TC=<%x:%x>, DisconnectTime=<%x:%x>\n",
                pSend, pSend->pSender->TimerTickCount, pSend->pSender->DisconnectTimeInTicks);

        return (FALSE);
    }

    // *****************************************************************
    //      We will reach here only if we need to cleanup ASAP
    // *****************************************************************

    //
    // First, cleanup all handled RData requests (which have completed)
    //
    pEntry = &pSend->pSender->HandledRDataRequests;
    while ((pEntry = pEntry->Flink) != &pSend->pSender->HandledRDataRequests)
    {
        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);

        ASSERT (!pRDataContext->NumNaks);
        if (!pRDataContext->NumPacketsInTransport)
        {
            pEntry = pEntry->Blink;     // Set this because this pEntry will not be valid any more!
            RemoveEntryList (&pRDataContext->Linkage);
            PgmFreeMem (pRDataContext);
        }
    }

    //
    // Now, remove all pending RData requests (since this is an Abort scenario)
    // If they have any sends pending, we will put them on the handled
    // list now and cleanup later
    //
    pEntry = &pSend->pSender->PendingRDataRequests;
    while ((pEntry = pEntry->Flink) != &pSend->pSender->PendingRDataRequests)
    {
        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
        pEntry = pEntry->Blink;     // Set this because this pEntry will not be valid any more!

        ASSERT (pRDataContext->NumNaks);
        pRDataContext->NumNaks = 0;
        RemoveEntryList (&pRDataContext->Linkage);
        pSend->pSender->NumRDataRequestsPending--;

        if (pRDataContext->NumPacketsInTransport)
        {
            InsertTailList (&pSend->pSender->HandledRDataRequests, &pRDataContext->Linkage);
        }
        else
        {
            PgmFreeMem (pRDataContext);
        }
    }


    //
    // Now, Cancel and Complete all the send requests which are pending
    //
    InitializeListHead (&ListEntry);
    PgmCancelAllSends (pSend, &ListEntry, NULL);
    while (!IsListEmpty (&ListEntry))
    {
        pEntry = RemoveHeadList (&ListEntry);
        pSendContext = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        ASSERT (!pSendContext->pMessage2Request);

        PgmUnlock (pSend, *pOldIrq);
        if (pSendContext->pIrpToComplete)
        {
            ASSERT (pSendContext->pIrpToComplete == pSendContext->pIrp);
            PgmIoComplete (pSendContext->pIrpToComplete, STATUS_CANCELLED, 0);
        }
        else
        {
            ASSERT (pSendContext->pIrp);
        }

        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
        PgmLock (pSend, *pOldIrq);

        ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext);
    }

    //
    // Verify that at least 1 SPM with the FIN or RST or RST_N flag
    // has been sent
    //
    if (!(pSend->pSender->SpmOptions & (PGM_OPTION_FLAG_FIN |
                                        PGM_OPTION_FLAG_RST |
                                        PGM_OPTION_FLAG_RST_N)))
    {
        if (pSend->SessionFlags & PGM_SESSION_SENDS_CANCELLED)
        {
            pSend->pSender->SpmOptions &= ~PGM_OPTION_FLAG_FIN;
            pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_RST;
        }
        else
        {
            pSend->pSender->SpmOptions &= ~PGM_OPTION_FLAG_RST;
            pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_FIN;
        }

        pSend->SessionFlags |= PGM_SESSION_FLAG_SEND_AMBIENT_SPM;

        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_CONNECT, "CheckForTermination",
            "SPM with FIN|RST|RST_N has not yet been sent for pSend=<%p>\n", pSend);

        return (FALSE);
    }

    //
    // Verify that there are no SPMs pending
    //
    if (pSend->SessionFlags & PGM_SESSION_FLAG_SEND_AMBIENT_SPM)
    {
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_CONNECT, "CheckForTermination",
            "Cannot cleanup pSend=<%p> since we have Ambient SPM pending!\n", pSend);

        return (FALSE);
    }

    //
    // Verify that we do not have any completions pending also since
    // Ip would need to reference the data buffer otherwise
    //
    while (!IsListEmpty (&pSend->pSender->CompletedSendsInWindow))
    {
        pSendContext = CONTAINING_RECORD (pSend->pSender->CompletedSendsInWindow.Flink, tCLIENT_SEND_REQUEST, Linkage);
        if (pSendContext->NumSendsPending)
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_SEND, "CheckForTermination",
                "Session has terminated, but cannot continue cleanup since Sends are still pending!\n");

            break;
        }

        //
        // Now, set the buffer settings
        //
        ASSERT (SEQ_GEQ (pSend->pSender->TrailingEdgeSequenceNumber, pSendContext->StartSequenceNumber) &&
                SEQ_LEQ (pSend->pSender->TrailingEdgeSequenceNumber, pSendContext->EndSequenceNumber));

        NumSequences = (ULONG) (SEQ_TYPE) (pSendContext->EndSequenceNumber-pSend->pSender->TrailingEdgeSequenceNumber) +1;
        pSend->pSender->BufferSizeAvailable += (NumSequences * pSend->pSender->PacketBufferSize);
        ASSERT (pSend->pSender->BufferSizeAvailable <= pSend->pSender->MaxDataFileSize);
        pSend->pSender->TrailingWindowOffset += (NumSequences * pSend->pSender->PacketBufferSize);
        if (pSend->pSender->TrailingWindowOffset >= pSend->pSender->MaxDataFileSize)
        {
            // Wrap around case!
            pSend->pSender->TrailingWindowOffset -= pSend->pSender->MaxDataFileSize;
        }
        ASSERT (pSend->pSender->TrailingWindowOffset < pSend->pSender->MaxDataFileSize);
        pSend->pSender->TrailingEdgeSequenceNumber += (SEQ_TYPE) NumSequences;

        ASSERT ((!pSendContext->pMessage2Request) && (!pSendContext->pIrp));
        RemoveEntryList (&pSendContext->Linkage);
        ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext);
    }

    //
    // If any sends are pending, return False
    //
    if ((pSend->pIrpDisconnect) ||
        !(IsListEmpty (&pSend->pSender->CompletedSendsInWindow)) ||
        !(IsListEmpty (&pSend->pSender->PendingSends)) ||
        !(IsListEmpty (&pSend->pSender->PendingPacketizedSends)) ||
        !(IsListEmpty (&pSend->pSender->PendingRDataRequests))   ||
        !(IsListEmpty (&pSend->pSender->HandledRDataRequests)))
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_SEND, "CheckForTermination",
            "Cannot cleanup completely since transmit Window=[%d--%d] still has pending Sends!\n",
                (ULONG) pSend->pSender->TrailingEdgeSequenceNumber,
                (ULONG) (pSend->pSender->NextODataSequenceNumber-1));

        return (FALSE);
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "CheckForTermination",
        "Transmit Window has no pending Sends!  TimerTC=[%d:%d]\n", pSend->pSender->TimerTickCount);

    ASSERT (!pSend->pIrpDisconnect);
    return (TRUE);
}


//----------------------------------------------------------------------------

BOOLEAN
SendNextPacket(
    IN  tSEND_SESSION       *pSend
    )
/*++

Routine Description:

    This routine is queued by the timer to send Data/Spm packets
    based on available throughput

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  Unused1
    IN  Unused2

Return Value:

    NONE

--*/
{
    ULONG                   BytesSent;
    ULONG                   NumSequences;
    PGMLockHandle           OldIrq;
    BOOLEAN                 fTerminateSession = FALSE;
    LIST_ENTRY              *pEntry;
    tSEND_RDATA_CONTEXT     *pRDataContext, *pRDataToSend;
    BOOLEAN                 fSendRData = TRUE;

    PgmLock (pSend, OldIrq);
    //
    // pSend->pSender->CurrentBytesSendable applies to OData, RData and SPMs only
    //
    while (pSend->pSender->CurrentBytesSendable >= pSend->pSender->pAddress->OutIfMTU)
    {
        BytesSent = 0;

        //
        // See if we need to send any Ambient SPMs
        //
        if ((pSend->SessionFlags & PGM_SESSION_FLAG_SEND_AMBIENT_SPM) &&
            ((pSend->pSender->PacketsSentSinceLastSpm > MAX_DATA_PACKETS_BEFORE_SPM) ||
             (pSend->pSender->CurrentSPMTimeout >= pSend->pSender->AmbientSPMTimeout)))
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "DelayedSendNextPacket",
                "Send Ambient SPM, TC=[%d:%d], BS=<%d>\n",
                    pSend->pSender->TimerTickCount, pSend->pSender->CurrentBytesSendable);
            //
            // Some data packet was sent recently, so we are in Ambient SPM mode
            //
            PgmSendSpm (pSend, &OldIrq, &BytesSent);

            pSend->pSender->CurrentSPMTimeout = 0;    // Reset the SPM timeout
            pSend->pSender->HeartbeatSPMTimeout = pSend->pSender->InitialHeartbeatSPMTimeout;
            pSend->SessionFlags &= ~PGM_SESSION_FLAG_SEND_AMBIENT_SPM;
            pSend->pSender->PacketsSentSinceLastSpm = 0;
        }
        //
        // Otherwise see if we need to send any Heartbeat SPMs
        //
        else if ((!(pSend->SessionFlags & PGM_SESSION_FLAG_SEND_AMBIENT_SPM)) &&
                 (pSend->pSender->CurrentSPMTimeout >= pSend->pSender->HeartbeatSPMTimeout))
        {
            //
            // No data packet was sent recently, so we need to send a Heartbeat SPM
            //
            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "DelayedSendNextPacket",
                "Send Heartbeat SPM, TC=[%d:%d], BS=<%d>\n",
                    pSend->pSender->TimerTickCount, pSend->pSender->CurrentBytesSendable);

            //
            // (Send Heartbeat SPM Packet)
            //
            PgmSendSpm (pSend, &OldIrq, &BytesSent);

            pSend->pSender->CurrentSPMTimeout = 0;    // Reset the SPM timeout
            pSend->pSender->HeartbeatSPMTimeout *= 2;
            if (pSend->pSender->HeartbeatSPMTimeout > pSend->pSender->MaxHeartbeatSPMTimeout)
            {
                pSend->pSender->HeartbeatSPMTimeout = pSend->pSender->MaxHeartbeatSPMTimeout;
            }
            pSend->pSender->PacketsSentSinceLastSpm = 0;
        }
        //
        // Next, see if we need to send any RData
        //
        else if ((pSend->pSender->NumRDataRequestsPending) || (pSend->pSender->NumODataRequestsPending))
        {
            //
            // See if we need to send an RData packet now
            //
            pRDataToSend = NULL;
            if ((pSend->pSender->NumRDataRequestsPending) &&
                (fSendRData || !pSend->pSender->NumODataRequestsPending))
            {
                pEntry = &pSend->pSender->PendingRDataRequests;
                while ((pEntry = pEntry->Flink) != &pSend->pSender->PendingRDataRequests)
                {
                    pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
                    if (pSend->pSender->TimerTickCount >= pRDataContext->EarliestRDataSendTime)
                    {
                        pRDataToSend = pRDataContext;
                        break;
                    }
                }

                if (pRDataToSend)
                {
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "DelayedSendNextPacket",
                        "Send RData[%d] -- TC=[%d:%d], BS=<%d>, MTU=<%d>\n",
                            pRDataContext->RDataSequenceNumber, pSend->pSender->TimerTickCount,
                            pSend->pSender->CurrentBytesSendable, pSend->pSender->pAddress->OutIfMTU);

                    PgmSendRData (pSend, pRDataToSend, &OldIrq, &BytesSent);
                }
                else if (!pSend->pSender->NumODataRequestsPending)
                {
                    //
                    // Since we don't have any OData pending, send the next RData anyway!
                    //
                    pRDataToSend = CONTAINING_RECORD (pSend->pSender->PendingRDataRequests.Flink, tSEND_RDATA_CONTEXT, Linkage);
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "DelayedSendNextPacket",
                        "No OData!  Send RData[%d] -- TC=[%d:%d], BS=<%d>, MTU=<%d>\n",
                            pRDataContext->RDataSequenceNumber, pSend->pSender->TimerTickCount,
                            pSend->pSender->CurrentBytesSendable, pSend->pSender->pAddress->OutIfMTU);

                    PgmSendRData (pSend, pRDataToSend, &OldIrq, &BytesSent);
                }
                else
                {
                    //
                    // We will not attempt to send any more RData at this time
                    //
                    fSendRData = FALSE;
                }
            }

            if ((!pRDataToSend) &&
                pSend->pSender->NumODataRequestsPending)
            {
                PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "DelayedSendNextPacket",
                    "Send OData -- TC=[%d:%d], BS=<%d>, MTU=<%d>\n",
                        pSend->pSender->TimerTickCount, pSend->pSender->CurrentBytesSendable,
                        pSend->pSender->pAddress->OutIfMTU);

                //
                // Send OData
                //
                PgmSendNextOData (pSend, &OldIrq, &BytesSent);
            }

            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "DelayedSendNextPacket",
                "Sent <%d> Data bytes\n", BytesSent);

            if (BytesSent == 0)
            {
                //
                // We may not have enough buffer space to packetize and send
                // more data, or we have no data to send at this time, so just
                // break out and see if we can advance the trailing window!
                //
                if (pSend->pSender->CurrentBytesSendable >
                    (NUM_LEAKY_BUCKETS * pSend->pSender->IncrementBytesOnSendTimeout))
                {
                    pSend->pSender->CurrentBytesSendable = NUM_LEAKY_BUCKETS *
                                                           pSend->pSender->IncrementBytesOnSendTimeout;
                }

                break;
            }

            pSend->SessionFlags |= PGM_SESSION_FLAG_SEND_AMBIENT_SPM;
            pSend->pSender->PacketsSentSinceLastSpm++;
        }

        //
        //  We do not have any more packets to send, so reset
        //  BytesSendable so that we don't exceed the rate on
        //  the next send
        //
        else
        {
            if (pSend->pSender->CurrentBytesSendable >
                (NUM_LEAKY_BUCKETS * pSend->pSender->IncrementBytesOnSendTimeout))
            {
                pSend->pSender->CurrentBytesSendable = NUM_LEAKY_BUCKETS *
                                                       pSend->pSender->IncrementBytesOnSendTimeout;
            }

            break;
        }

        pSend->TotalBytes += BytesSent;
        pSend->pSender->CurrentBytesSendable -= BytesSent;
    }   // while (CurrentBytesSendable >= pSend->pSender->pAddress->OutIfMTU)

    //
    // See if we need to scavenge completed RData requests
    //
    pEntry = &pSend->pSender->HandledRDataRequests;
    while ((pEntry = pEntry->Flink) != &pSend->pSender->HandledRDataRequests)
    {
        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
        if ((pRDataContext->CleanupTime) &&
            (pSend->pSender->TimerTickCount > pRDataContext->CleanupTime))
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "DelayedSendNextPacket",
                "Removing lingering RData for SeqNum=<%d>\n", (ULONG) pRDataContext->RDataSequenceNumber);

            pEntry = pEntry->Blink;     // Set this because this pEntry will not be valid any more!
            RemoveEntryList (&pRDataContext->Linkage);
            PgmFreeMem (pRDataContext);
        }
    }

    //
    // See if we need to increment the Trailing Window -- returns number of Sequences advanced
    //
    NumSequences = AdvanceWindow (pSend);

    //
    // Now check if we need to terminate this session
    //
    fTerminateSession = CheckForTermination (pSend, &OldIrq);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "DelayedSendNextPacket",
        "Sent <%d> total bytes, fTerminateSession=<%x>\n", pSend->TotalBytes, fTerminateSession);

    //
    // Clear the WorkerRunning flag so that the next Worker
    // routine can be queued
    //
    pSend->SessionFlags &= ~PGM_SESSION_FLAG_WORKER_RUNNING;
    PgmUnlock (pSend, OldIrq);

    return (fTerminateSession);
}


//----------------------------------------------------------------------------

VOID
SendSessionTimeout(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
    )
/*++

Routine Description:

    This routine is the timout that gets called every BASIC_TIMER_GRANULARITY_IN_MSECS
    to schedule the next Send request

Arguments:

    IN  Dpc
    IN  DeferredContext -- Our context for this timer
    IN  SystemArg1
    IN  SystemArg2

Return Value:

    NONE

--*/
{
    NTSTATUS            status;
    tADDRESS_CONTEXT    *pAddress;
    PGMLockHandle       OldIrq;
    tSEND_SESSION       *pSend = (tSEND_SESSION *) DeferredContext;
    LARGE_INTEGER       Now, Frequency;
    LARGE_INTEGER       DeltaTime, GranularTimeElapsed, TimeoutGranularity;
    ULONG               NumTimeouts;
    SEQ_TYPE            NumSequencesInWindow;

    Now = KeQueryPerformanceCounter (&Frequency);

    PgmLock (pSend, OldIrq);

    //
    // First check if we have been told to stop the timer
    //
    if (pSend->SessionFlags & PGM_SESSION_FLAG_STOP_TIMER)
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_SEND, "SendSessionTimeout",
            "Session has terminated -- will deref and not restart timer!\n");

        //
        // Deref for the timer reference
        //
        pAddress = pSend->pSender->pAddress;
        pSend->pSender->pAddress = NULL;
        PgmUnlock (pSend, OldIrq);
        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_TIMER_RUNNING);
        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SEND_IN_PROGRESS);
        return;
    }

    DeltaTime.QuadPart = Now.QuadPart - pSend->pSender->LastTimeout.QuadPart;
    TimeoutGranularity.QuadPart = pSend->pSender->TimeoutGranularity.QuadPart;
    for (GranularTimeElapsed.QuadPart = 0, NumTimeouts = 0;
         DeltaTime.QuadPart > TimeoutGranularity.QuadPart;
         NumTimeouts++)
    {
        GranularTimeElapsed.QuadPart += TimeoutGranularity.QuadPart;
        DeltaTime.QuadPart -= TimeoutGranularity.QuadPart;
    }

    if (NumTimeouts)
    {
        pSend->RateCalcTimeout += NumTimeouts;
        if (pSend->RateCalcTimeout >=
            (INTERNAL_RATE_CALCULATION_FREQUENCY/BASIC_TIMER_GRANULARITY_IN_MSECS))
        {
            pSend->RateKBitsPerSecOverall = (pSend->TotalBytes << LOG2_BITS_PER_BYTE) /
                                            (pSend->pSender->TimerTickCount * BASIC_TIMER_GRANULARITY_IN_MSECS);

            pSend->RateKBitsPerSecLast = (pSend->TotalBytes - pSend->TotalBytesAtLastInterval) >>
                                         (LOG2_INTERNAL_RATE_CALCULATION_FREQUENCY - LOG2_BITS_PER_BYTE);

            pSend->DataBytesAtLastInterval = pSend->DataBytes;
            pSend->TotalBytesAtLastInterval = pSend->TotalBytes;
            pSend->RateCalcTimeout = 0;
        }

        pSend->pSender->LastTimeout.QuadPart += GranularTimeElapsed.QuadPart;

        //
        // Increment the absolute timer, and check for overflow
        //
        pSend->pSender->TimerTickCount += NumTimeouts;

        //
        // If the SPMTimeout value is less than the HeartbeatTimeout, increment it
        //
        if (pSend->pSender->CurrentSPMTimeout <= pSend->pSender->HeartbeatSPMTimeout)
        {
            pSend->pSender->CurrentSPMTimeout += NumTimeouts;
        }

        //
        // See if we can send anything
        //
        ASSERT (pSend->pSender->CurrentTimeoutCount);
        ASSERT (pSend->pSender->SendTimeoutCount);
        if (pSend->pSender->CurrentTimeoutCount > NumTimeouts)
        {
            pSend->pSender->CurrentTimeoutCount -= NumTimeouts;
        }
        else
        {
            //
            // We got here because NumTimeouts >= pSend->pSender->CurrentTimeoutCount
            //
            pSend->pSender->CurrentBytesSendable += (ULONG) pSend->pSender->IncrementBytesOnSendTimeout;
            if (NumTimeouts != pSend->pSender->CurrentTimeoutCount)
            {
                if (1 == pSend->pSender->SendTimeoutCount)
                {
                    pSend->pSender->CurrentBytesSendable += (ULONG) ((NumTimeouts - pSend->pSender->CurrentTimeoutCount)
                                                                        * pSend->pSender->IncrementBytesOnSendTimeout);
                }
                else
                {
                    //
                    // This path will get taken on a slow receiver when the timer
                    // fires at a lower granularity than that requested
                    //
                    pSend->pSender->CurrentBytesSendable += (ULONG) (((NumTimeouts - pSend->pSender->CurrentTimeoutCount)
                                                                      * pSend->pSender->IncrementBytesOnSendTimeout) /
                                                                     pSend->pSender->SendTimeoutCount);
                }
            }
            pSend->pSender->CurrentTimeoutCount = pSend->pSender->SendTimeoutCount;

            //
            // Send a synchronization event to the sender thread to
            // send the next available data
            //
            KeSetEvent (&pSend->pSender->SendEvent, 0, FALSE);
        }
    }

    PgmUnlock (pSend, OldIrq);

    //
    // Now, restart the timer
    //
    PgmInitTimer (&pSend->SessionTimer);
    PgmStartTimer (&pSend->SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, SendSessionTimeout, pSend);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "SendSessionTimeout",
        "TickCount=<%d:%d>, CurrentTimeoutCount=<%d:%d>, CurrentSPMTimeout=<%d:%d>, Worker %srunning\n",
            pSend->pSender->TimerTickCount, pSend->pSender->CurrentTimeoutCount,
            pSend->pSender->CurrentSPMTimeout,
            ((pSend->SessionFlags & PGM_SESSION_FLAG_WORKER_RUNNING) ? "" : "NOT "));
}


//----------------------------------------------------------------------------

VOID
SenderWorkerThread(
    IN  tSEND_SESSION       *pSend
    )
{
    BOOLEAN         fTerminateSends;
    PGMLockHandle   OldIrq;
    NTSTATUS        status;

    do
    {
        status = KeWaitForSingleObject (&pSend->pSender->SendEvent,  // Object to wait on.
                                        Executive,                   // Reason for waiting
                                        KernelMode,                  // Processor mode
                                        FALSE,                       // Alertable
                                        NULL);                       // Timeout
        ASSERT (NT_SUCCESS (status));

        fTerminateSends = SendNextPacket (pSend);
    }
    while (!fTerminateSends);

    PgmLock (pSend, OldIrq);
    pSend->SessionFlags |= PGM_SESSION_FLAG_STOP_TIMER; // To ensure timer does last deref and stops
    PgmUnlock (pSend, OldIrq);

//    PsTerminateSystemThread (STATUS_SUCCESS);
    return;
}


//----------------------------------------------------------------------------

VOID
PgmCancelSendIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Send Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    None

--*/
{
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation (pIrp);
    tSEND_SESSION           *pSend = (tSEND_SESSION *) pIrpSp->FileObject->FsContext;
    PGMLockHandle           OldIrq;
    PLIST_ENTRY             pEntry;
    LIST_ENTRY              ListEntry;
    tCLIENT_SEND_REQUEST    *pSendContext1;
    tCLIENT_SEND_REQUEST    *pSendContext2 = NULL;
    ULONG                   NumRequests;

    if (!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND))
    {
        IoReleaseCancelSpinLock (pIrp->CancelIrql);

        PgmLog (PGM_LOG_ERROR, (DBG_SEND | DBG_ADDRESS | DBG_CONNECT), "PgmCancelSendIrp",
            "pIrp=<%p> pSend=<%p>, pAddress=<%p>\n", pIrp, pSend, pSend->pAssociatedAddress);
        return;
    }

    PgmLock (pSend, OldIrq);

    //
    // First, see if the Irp is on any of our lists
    //
    pEntry = &pSend->pSender->PendingSends;
    while ((pEntry = pEntry->Flink) != &pSend->pSender->PendingSends)
    {
        pSendContext1 = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        if (pSendContext1->pIrp == pIrp)
        {
            pSendContext2 = pSendContext1;
            break;
        }
    }

    if (!pSendContext2)
    {
        //
        // Now, search the packetized list
        //
        pEntry = &pSend->pSender->PendingPacketizedSends;
        while ((pEntry = pEntry->Flink) != &pSend->pSender->PendingPacketizedSends)
        {
            pSendContext1 = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
            if (pSendContext1->pIrp == pIrp)
            {
                pSendContext2 = pSendContext1;
                break;
            }
        }

        if (!pSendContext2)
        {
            //
            // We did not find the irp -- either it was just being completed
            // (or waiting for a send-complete), or the Irp was bad ?
            //
            PgmUnlock (pSend, OldIrq);
            IoReleaseCancelSpinLock (pIrp->CancelIrql);

            PgmLog (PGM_LOG_INFORM_PATH, DBG_CONNECT, "PgmCancelSendIrp",
                "Did not find Cancel Irp=<%p>\n", pIrp);

            return;
        }
    }

    InitializeListHead (&ListEntry);
    PgmCancelAllSends (pSend, &ListEntry, pIrp);

    PgmUnlock (pSend, OldIrq);
    IoReleaseCancelSpinLock (pIrp->CancelIrql);

    //
    // Now, complete all the sends which we removed
    //
    NumRequests = 0;
    while (!IsListEmpty (&ListEntry))
    {
        pEntry = RemoveHeadList (&ListEntry);
        pSendContext1 = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        ASSERT (!pSendContext1->pMessage2Request);

        if (pSendContext1->pIrpToComplete)
        {
            NumRequests++;
            ASSERT (pSendContext1->pIrpToComplete == pSendContext1->pIrp);
            PgmIoComplete (pSendContext1->pIrpToComplete, STATUS_CANCELLED, 0);
        }
        else
        {
            ASSERT (pSendContext1->pIrp);
        }

        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
        ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext1);
    }

    PgmLog (PGM_LOG_INFORM_PATH, DBG_CONNECT, "PgmCancelSendIrp",
        "Cancelled <%d> Irps for pIrp=<%p>\n", NumRequests, pIrp);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendRequestFromClient(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called via dispatch by the client to post a Send pIrp

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    NTSTATUS                    status;
    PGMLockHandle               OldIrq1, OldIrq2, OldIrq3, OldIrq4;
    tADDRESS_CONTEXT            *pAddress = NULL;
    tCLIENT_SEND_REQUEST        *pSendContext1;
    tCLIENT_SEND_REQUEST        *pSendContext2 = NULL;
    ULONG                       BytesLeftInMessage;
    tSEND_SESSION               *pSend = (tSEND_SESSION *) pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL_SEND    pTdiRequest = (PTDI_REQUEST_KERNEL_SEND) &pIrpSp->Parameters;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fFirstSend, fResourceAcquired, fAttached;
    LARGE_INTEGER               Frequency;
    LIST_ENTRY                  ListEntry;

    PgmLock (&PgmDynamicConfig, OldIrq1);

    //
    // Verify that the connection is valid and is associated with an address
    //
    if ((!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND)) ||
        (!(pAddress = pSend->pAssociatedAddress)) ||
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)) ||
        (pSend->SessionFlags & (PGM_SESSION_CLIENT_DISCONNECTED | PGM_SESSION_SENDS_CANCELLED)) ||
        (pAddress->Flags & PGM_ADDRESS_FLAG_INVALID_OUT_IF))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_SEND | DBG_ADDRESS | DBG_CONNECT), "PgmSend",
            "Invalid Handles pSend=<%p>, pAddress=<%p>\n", pSend, pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq1);
        return (STATUS_INVALID_HANDLE);
    }

    if (!pSend->pSender->DestMCastIpAddress)
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSend",
            "Destination address not specified for pSend=<%p>\n", pSend);

        PgmUnlock (&PgmDynamicConfig, OldIrq1);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    if (!pTdiRequest->SendLength)
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_SEND, "PgmSend",
            "pIrp=<%p> for pSend=<%p> is of length 0!\n", pIrp, pSend);

        PgmUnlock (&PgmDynamicConfig, OldIrq1);
        return (STATUS_SUCCESS);
    }

    PgmLock (pAddress, OldIrq2);
    PgmLock (pSend, OldIrq3);

    if (!(pSendContext1 = ExAllocateFromNPagedLookasideList (&pSend->pSender->SendContextLookaside)))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSend",
            "STATUS_INSUFFICIENT_RESOURCES allocating pSendContext1\n");

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If we have more that 1 message data in this request,
    // we will need another send context
    //
    if ((pSend->pSender->ThisSendMessageLength) &&          // Client has specified current message length
        (BytesLeftInMessage = pSend->pSender->ThisSendMessageLength - pSend->pSender->BytesSent) &&
        (BytesLeftInMessage < pTdiRequest->SendLength) &&   // ==> Have some extra data in this request
        (!(pSendContext2 = ExAllocateFromNPagedLookasideList (&pSend->pSender->SendContextLookaside))))
    {
        ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext1);
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSend",
            "STATUS_INSUFFICIENT_RESOURCES allocating pSendContext1\n");

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    //
    // Zero the SendDataContext structure(s)
    //
    PgmZeroMemory (pSendContext1, sizeof (tCLIENT_SEND_REQUEST));
    InitializeListHead (&pSendContext1->Linkage);
    if (pSendContext2)
    {
        PgmZeroMemory (pSendContext2, sizeof (tCLIENT_SEND_REQUEST));
        InitializeListHead (&pSendContext2->Linkage);
    }

    if (pSend->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET)
    {
        fFirstSend = TRUE;
    }
    else
    {
        fFirstSend = FALSE;
    }

    //
    // Reference the Address and Connection so that they cannot go away
    // while we are processing!
    //
    PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW, TRUE);

    PgmUnlock (pSend, OldIrq3);
    PgmUnlock (pAddress, OldIrq2);
    PgmUnlock (&PgmDynamicConfig, OldIrq1);

    if (PgmGetCurrentIrql())
    {
        fResourceAcquired = FALSE;
    }
    else
    {
        fResourceAcquired = TRUE;
        PgmAcquireResourceExclusive (&pSend->pSender->Resource, TRUE);
    }

    if (fFirstSend)
    {
        //
        // Don't start the timer yet, but start the sender thread
        //
        PgmAttachToProcessForVMAccess (pSend, &ApcState, &fAttached, REF_PROCESS_ATTACH_START_SENDER_THREAD);

        status = PsCreateSystemThread (&pSend->pSender->SendHandle,
                                       PROCESS_ALL_ACCESS,
                                       NULL,
                                       NULL,
                                       NULL,
                                       SenderWorkerThread,
                                       pSend);

        if (!NT_SUCCESS (status))
        {
            PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_START_SENDER_THREAD);
            if (fResourceAcquired)
            {
                PgmReleaseResource (&pSend->pSender->Resource);
            }

            ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext1);
            if (pSendContext2)
            {
                ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext2);
            }
            PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);

            PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSend",
                "status=<%x> starting sender thread\n", status);

            return (status);
        }

        //
        // Close the handle to the thread so that it goes away when the
        // thread terminates
        //
        ZwClose (pSend->pSender->SendHandle);
        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_START_SENDER_THREAD);

        PgmLock (&PgmDynamicConfig, OldIrq1);
        IoAcquireCancelSpinLock (&OldIrq2);
        PgmLock (pAddress, OldIrq3);
        PgmLock (pSend, OldIrq4);

        pSend->SessionFlags &= ~PGM_SESSION_FLAG_FIRST_PACKET;
        pSend->pSender->pAddress = pAddress;
        pSend->pSender->LastODataSentSequenceNumber = -1;

        //
        // Set the SYN flag for the first packet
        //
        pSendContext1->DataOptions |= PGM_OPTION_FLAG_SYN;   // First packet only
        pSendContext1->DataOptionsLength += PGM_PACKET_OPT_SYN_LENGTH;

        PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_TIMER_RUNNING, TRUE);
        PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SEND_IN_PROGRESS, TRUE);

        //
        // Now, set and start the timer
        //
        pSend->pSender->LastTimeout = KeQueryPerformanceCounter (&Frequency);
        pSend->pSender->TimeoutGranularity.QuadPart = (Frequency.QuadPart * BASIC_TIMER_GRANULARITY_IN_MSECS) / 1000;
        pSend->pSender->TimerTickCount = 1;
        PgmInitTimer (&pSend->SessionTimer);
        PgmStartTimer (&pSend->SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, SendSessionTimeout, pSend);
    }
    else
    {
        PgmLock (&PgmDynamicConfig, OldIrq1);
        IoAcquireCancelSpinLock (&OldIrq2);
        PgmLock (pAddress, OldIrq3);
        PgmLock (pSend, OldIrq4);
    }

    pSendContext1->pSend = pSend;
    pSendContext1->pIrp = pIrp;
    pSendContext1->pIrpToComplete = pIrp;
    pSendContext1->NextDataOffsetInMdl = 0;
    pSendContext1->SendNumber = pSend->pSender->NextSendNumber++;
    pSendContext1->DataPayloadSize = pSend->pSender->MaxPayloadSize;
    pSendContext1->DataOptions |= pSend->pSender->DataOptions;   // Attach options common for every send
    pSendContext1->DataOptionsLength += pSend->pSender->DataOptionsLength;
    pSendContext1->pLastMessageVariableTGPacket = (PVOID) -1;       // FEC-specific

    if (pSend->pSender->ThisSendMessageLength)
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmSend",
            "Send # [%d]: MessageLength=<%d>, BytesSent=<%d>, BytesInSend=<%d>\n",
                pSendContext1->SendNumber, pSend->pSender->ThisSendMessageLength,
                pSend->pSender->BytesSent, pTdiRequest->SendLength);

        pSendContext1->ThisMessageLength = pSend->pSender->ThisSendMessageLength;
        pSendContext1->LastMessageOffset = pSend->pSender->BytesSent;
        if (pSendContext2)
        {
            //
            // First, set the parameters for SendDataContext1
            //
            pSendContext1->BytesInSend = BytesLeftInMessage;
            pSendContext1->pIrpToComplete = NULL;        // This Irp will be completed by the Context2

            //
            // Now, set the parameters for SendDataContext1
            //
            pSendContext2->pSend = pSend;
            pSendContext2->pIrp = pIrp;
            pSendContext2->pIrpToComplete = pIrp;
            pSendContext2->SendNumber = pSend->pSender->NextSendNumber++;
            pSendContext2->DataPayloadSize = pSend->pSender->MaxPayloadSize;
            pSendContext2->DataOptions |= pSend->pSender->DataOptions;   // Attach options common for every send
            pSendContext2->DataOptionsLength += pSend->pSender->DataOptionsLength;
            pSendContext2->pLastMessageVariableTGPacket = (PVOID) -1;       // FEC-specific

            pSendContext2->ThisMessageLength = pTdiRequest->SendLength - BytesLeftInMessage;
            pSendContext2->BytesInSend = pSendContext2->ThisMessageLength;
            pSendContext2->NextDataOffsetInMdl = BytesLeftInMessage;
        }
        else
        {
            pSendContext1->BytesInSend = pTdiRequest->SendLength;
        }

        pSend->pSender->BytesSent += pSendContext1->BytesInSend;
        if (pSend->pSender->BytesSent == pSend->pSender->ThisSendMessageLength)
        {
            pSend->pSender->BytesSent = pSend->pSender->ThisSendMessageLength = 0;
        }
    }
    else
    {
        pSendContext1->ThisMessageLength = pTdiRequest->SendLength;
        pSendContext1->BytesInSend = pTdiRequest->SendLength;
    }

    // If the total Message length exceeds that of PayloadSize/Packet, then we need to fragment
    if ((pSendContext1->ThisMessageLength > pSendContext1->DataPayloadSize) ||
        (pSendContext1->ThisMessageLength > pSendContext1->BytesInSend))
    {
        pSendContext1->DataOptions |= PGM_OPTION_FLAG_FRAGMENT;
        pSendContext1->DataOptionsLength += PGM_PACKET_OPT_FRAGMENT_LENGTH;

        pSendContext1->NumPacketsRemaining = (pSendContext1->BytesInSend +
                                                 (pSend->pSender->MaxPayloadSize - 1)) /
                                                pSend->pSender->MaxPayloadSize;
        ASSERT (pSendContext1->NumPacketsRemaining >= 1);
    }
    else
    {
        pSendContext1->NumPacketsRemaining = 1;
    }
    pSend->pSender->NumPacketsRemaining += pSendContext1->NumPacketsRemaining;

    // Adjust the OptionsLength for the Packet Extension and determine
    if (pSendContext1->DataOptions)
    {
        pSendContext1->DataOptionsLength += PGM_PACKET_EXTENSION_LENGTH;
    }

    pSendContext1->BytesLeftToPacketize = pSendContext1->BytesInSend;
    InsertTailList (&pSend->pSender->PendingSends, &pSendContext1->Linkage);
    pSend->pSender->NumODataRequestsPending++;

    //
    // Do the same for Context2, if applicable
    if (pSendContext2)
    {
        //
        // Interlink the 2 Send requests
        //
        pSendContext2->pMessage2Request = pSendContext1;
        pSendContext1->pMessage2Request = pSendContext2;

        PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW, TRUE);

        if (pSendContext2->ThisMessageLength > pSendContext1->DataPayloadSize)
        {
            pSendContext2->DataOptions |= PGM_OPTION_FLAG_FRAGMENT;
            pSendContext2->DataOptionsLength += PGM_PACKET_OPT_FRAGMENT_LENGTH;

            pSendContext2->NumPacketsRemaining = (pSendContext2->BytesInSend +
                                                      (pSend->pSender->MaxPayloadSize - 1)) /
                                                     pSend->pSender->MaxPayloadSize;
            ASSERT (pSendContext2->NumPacketsRemaining >= 1);
        }
        else
        {
            pSendContext2->NumPacketsRemaining = 1;
        }
        pSend->pSender->NumPacketsRemaining += pSendContext2->NumPacketsRemaining;

        // Adjust the OptionsLength for the Packet Extension and determine
        if (pSendContext2->DataOptions)
        {
            pSendContext2->DataOptionsLength += PGM_PACKET_EXTENSION_LENGTH;
        }

        pSendContext2->BytesLeftToPacketize = pSendContext2->BytesInSend;
        InsertTailList (&pSend->pSender->PendingSends, &pSendContext2->Linkage);
        pSend->pSender->NumODataRequestsPending++;
    }

    if (!NT_SUCCESS (PgmCheckSetCancelRoutine (pIrp, PgmCancelSendIrp, TRUE)))
    {
        pSend->SessionFlags |= PGM_SESSION_SENDS_CANCELLED;

        pSend->pSender->NumODataRequestsPending--;
        pSend->pSender->NumPacketsRemaining -= pSendContext1->NumPacketsRemaining;
        RemoveEntryList (&pSendContext1->Linkage);
        ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext1);

        if (pSendContext2)
        {
            pSend->pSender->NumODataRequestsPending--;
            pSend->pSender->NumPacketsRemaining -= pSendContext2->NumPacketsRemaining;
            RemoveEntryList (&pSendContext2->Linkage);
            ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext2);
        }

        PgmUnlock (pSend, OldIrq4);
        PgmUnlock (pAddress, OldIrq3);
        IoReleaseCancelSpinLock (OldIrq2);
        PgmUnlock (&PgmDynamicConfig, OldIrq1);

        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
        if (pSendContext2)
        {
            PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
        }

        PgmLog (PGM_LOG_ERROR, (DBG_RECEIVE | DBG_ADDRESS | DBG_CONNECT), "PgmReceive",
            "Could not set Cancel routine on Send Irp=<%p>, pSend=<%p>, pAddress=<%p>\n",
                pIrp, pSend, pAddress);

        return (STATUS_CANCELLED);
    }

    IoReleaseCancelSpinLock (OldIrq4);

    PgmUnlock (pAddress, OldIrq3);
    PgmUnlock (&PgmDynamicConfig, OldIrq2);

    if (fResourceAcquired)
    {
//        PgmPrepareNextSend (pSend, &OldIrq1, TRUE, TRUE);
    }

    if (pSend->pSender->CurrentBytesSendable >= pAddress->OutIfMTU)
    {
        //
        // Send a synchronization event to the sender thread to
        // send the next available data
        //
        KeSetEvent (&pSend->pSender->SendEvent, 0, FALSE);
    }

    PgmUnlock (pSend, OldIrq1);

    if (fResourceAcquired)
    {
        PgmReleaseResource (&pSend->pSender->Resource);
    }

    PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmSend",
        "[%d] Send pending for pIrp=<%p>, pSendContext=<%p -- %p>\n",
            pSendContext1->SendNumber, pIrp, pSendContext1, pSendContext2);

    return (STATUS_PENDING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\receive.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Receive.c

Abstract:

    This module implements Receive handlers and other routines
    the PGM Transport and other routines that are specific to the
    NT implementation of a driver.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"


typedef struct in_pktinfo {
    tIPADDRESS  ipi_addr;       // destination IPv4 address
    UINT        ipi_ifindex;    // received interface index
} IP_PKTINFO;

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------
VOID
RemovePendingIrps(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  LIST_ENTRY          *pIrpsList
    )
{
    PIRP        pIrp;

    if (pIrp = pReceive->pReceiver->pIrpReceive)
    {
        pReceive->pReceiver->pIrpReceive = NULL;

        pIrp->IoStatus.Information = pReceive->pReceiver->BytesInMdl;
        InsertTailList (pIrpsList, &pIrp->Tail.Overlay.ListEntry);
    }

    while (!IsListEmpty (&pReceive->pReceiver->ReceiveIrpsList))
    {
        pIrp = CONTAINING_RECORD (pReceive->pReceiver->ReceiveIrpsList.Flink, IRP, Tail.Overlay.ListEntry);

        RemoveEntryList (&pIrp->Tail.Overlay.ListEntry);
        InsertTailList (pIrpsList, &pIrp->Tail.Overlay.ListEntry);
        pIrp->IoStatus.Information = 0;
    }
}


//----------------------------------------------------------------------------

VOID
FreeNakContext(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  tNAK_FORWARD_DATA       *pNak
    )
/*++

Routine Description:

    This routine free's the context used for tracking missing sequences

Arguments:

    IN  pReceive    -- Receive context
    IN  pNak        -- Nak Context to be free'ed

Return Value:

    NONE

--*/
{
    UCHAR   i, j, k, NumPackets;

    //
    // Free any memory for non-parity data
    //
    j = k = 0;
    NumPackets = pNak->NumDataPackets + pNak->NumParityPackets;
    for (i=0; i<NumPackets; i++)
    {
        ASSERT (pNak->pPendingData[i].pDataPacket);
        if (pNak->pPendingData[i].PacketIndex < pReceive->FECGroupSize)
        {
            j++;
        }
        else
        {
            k++;
        }
        PgmFreeMem (pNak->pPendingData[i].pDataPacket);
    }
    ASSERT (j == pNak->NumDataPackets);
    ASSERT (k == pNak->NumParityPackets);

    //
    // Return the pNak memory based on whether it was allocated
    // from the parity or non-parity lookaside list
    //
    if (pNak->OriginalGroupSize > 1)
    {
        ExFreeToNPagedLookasideList (&pReceive->pReceiver->ParityContextLookaside, pNak);
    }
    else
    {
        ExFreeToNPagedLookasideList (&pReceive->pReceiver->NonParityContextLookaside, pNak);
    }
}


//----------------------------------------------------------------------------

VOID
CleanupPendingNaks(
    IN  tRECEIVE_SESSION                *pReceive,
    IN  PVOID                           fDerefReceive,
    IN  PVOID                           UnUsed
    )
{
    LIST_ENTRY              NaksList, DataList;
    tNAK_FORWARD_DATA       *pNak;
    LIST_ENTRY              *pEntry;
    ULONG                   NumBufferedData = 0;
    ULONG                   NumNaks = 0;
    PGMLockHandle           OldIrq;

    ASSERT (pReceive->pReceiver);

    PgmLock (pReceive, OldIrq);

    DataList.Flink = pReceive->pReceiver->BufferedDataList.Flink;
    DataList.Blink = pReceive->pReceiver->BufferedDataList.Blink;
    pReceive->pReceiver->BufferedDataList.Flink->Blink = &DataList;
    pReceive->pReceiver->BufferedDataList.Blink->Flink = &DataList;
    InitializeListHead (&pReceive->pReceiver->BufferedDataList);

    NaksList.Flink = pReceive->pReceiver->NaksForwardDataList.Flink;
    NaksList.Blink = pReceive->pReceiver->NaksForwardDataList.Blink;
    pReceive->pReceiver->NaksForwardDataList.Flink->Blink = &NaksList;
    pReceive->pReceiver->NaksForwardDataList.Blink->Flink = &NaksList;
    InitializeListHead (&pReceive->pReceiver->NaksForwardDataList);

    while (!IsListEmpty (&pReceive->pReceiver->PendingNaksList))
    {
        pEntry = RemoveHeadList (&pReceive->pReceiver->PendingNaksList);
        InitializeListHead (pEntry);
    }

    PgmUnlock (pReceive, OldIrq);

    //
    // Cleanup any pending Nak entries
    //
    while (!IsListEmpty (&DataList))
    {
        pEntry = RemoveHeadList (&DataList);
        pNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);
        FreeNakContext (pReceive, pNak);
        NumBufferedData++;
    }

    while (!IsListEmpty (&NaksList))
    {
        pEntry = RemoveHeadList (&NaksList);
        pNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);
        FreeNakContext (pReceive, pNak);
        NumNaks++;
    }

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_SEND, "CleanupPendingNaks",
        "pReceive=<%p>, NumBufferedData=<%d=%d>, TotalDataPackets=<%d>, NumNaks=<%d * %d>\n",
        pReceive,
        (ULONG) pReceive->pReceiver->NumPacketGroupsPendingClient, NumBufferedData,
        (ULONG) pReceive->pReceiver->TotalDataPacketsBuffered, NumNaks, (ULONG) pReceive->FECGroupSize);

//    ASSERT (NumBufferedData == pReceive->pReceiver->NumPacketGroupsPendingClient);
    pReceive->pReceiver->NumPacketGroupsPendingClient = 0;

    if (fDerefReceive)
    {
        PGM_DEREFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_CLEANUP_NAKS);
    }
}


//----------------------------------------------------------------------------

BOOLEAN
CheckIndicateDisconnect(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tRECEIVE_SESSION    *pReceive,
    IN  PGMLockHandle       *pOldIrqAddress,
    IN  PGMLockHandle       *pOldIrqReceive,
    IN  BOOLEAN             fAddressLockHeld
    )
{
    ULONG       DisconnectFlag;
    NTSTATUS    status;
    BOOLEAN     fDisconnectIndicated = FALSE;
    LIST_ENTRY  PendingIrpsList;
    PIRP        pIrp;

    //
    // Don't abort if we are currently indicating, or if we have
    // already aborted!
    //
    if (pReceive->SessionFlags & (PGM_SESSION_FLAG_IN_INDICATE | PGM_SESSION_DISCONNECT_INDICATED))
    {
        return (TRUE);
    }

    if ((pReceive->SessionFlags & PGM_SESSION_TERMINATED_ABORT) ||
        ((pReceive->SessionFlags & PGM_SESSION_TERMINATED_GRACEFULLY) &&
         (IsListEmpty (&pReceive->pReceiver->BufferedDataList)) &&
         SEQ_GEQ (pReceive->pReceiver->FirstNakSequenceNumber, (pReceive->pReceiver->FinDataSequenceNumber+1))))
    {
        //
        // The session has terminated, so let the client know
        //
        if (pReceive->SessionFlags & PGM_SESSION_TERMINATED_ABORT)
        {
            DisconnectFlag = TDI_DISCONNECT_ABORT;
        }
        else
        {
            DisconnectFlag = TDI_DISCONNECT_RELEASE;
        }

        pReceive->SessionFlags |= PGM_SESSION_DISCONNECT_INDICATED;

        InitializeListHead (&PendingIrpsList);
        RemovePendingIrps (pReceive, &PendingIrpsList);

        PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_CLEANUP_NAKS, TRUE);

        PgmUnlock (pReceive, *pOldIrqReceive);
        if (fAddressLockHeld)
        {
            PgmUnlock (pAddress, *pOldIrqAddress);
        }

        while (!IsListEmpty (&PendingIrpsList))
        {
            pIrp = CONTAINING_RECORD (PendingIrpsList.Flink, IRP, Tail.Overlay.ListEntry);
            PgmCancelCancelRoutine (pIrp);
            RemoveEntryList (&pIrp->Tail.Overlay.ListEntry);

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        }

        PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "CheckIndicateDisconnect",
            "Disconnecting pReceive=<%p:%p>, with %s\n",
                pReceive, pReceive->ClientSessionContext,
                (DisconnectFlag == TDI_DISCONNECT_RELEASE ? "TDI_DISCONNECT_RELEASE":"TDI_DISCONNECT_ABORT"));

        status = (*pAddress->evDisconnect) (pAddress->DiscEvContext,
                                            pReceive->ClientSessionContext,
                                            0,
                                            NULL,
                                            0,
                                            NULL,
                                            DisconnectFlag);


        fDisconnectIndicated = TRUE;

        //
        // See if we can Enqueue the Nak cleanup request to a Worker thread
        //
        if (STATUS_SUCCESS != PgmQueueForDelayedExecution (CleanupPendingNaks,
                                                           pReceive,
                                                           (PVOID) TRUE,
                                                           NULL,
                                                           FALSE))
        {
            CleanupPendingNaks (pReceive, (PVOID) TRUE, NULL);
        }

        if (fAddressLockHeld)
        {
            PgmLock (pAddress, *pOldIrqAddress);
        }
        PgmLock (pReceive, *pOldIrqReceive);
    }

    return (fDisconnectIndicated);
}


//----------------------------------------------------------------------------

VOID
ProcessNakOption(
    IN  tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader,
    OUT tNAKS_LIST                          *pNaksList
    )
/*++

Routine Description:

    This routine processes the Nak list option in the Pgm packet

Arguments:

    IN  pOptionHeader       -- The Nak List option ptr
    OUT pNaksList           -- The parameters extracted (i.e. list of Nak sequences)

Return Value:

    NONE

--*/
{
    UCHAR       i, NumNaks;
    ULONG       pPacketNaks[MAX_SEQUENCES_PER_NAK_OPTION];

    NumNaks = (pOptionHeader->OptionLength - 4) / 4;
    ASSERT (NumNaks <= MAX_SEQUENCES_PER_NAK_OPTION);

    PgmCopyMemory (pPacketNaks, (pOptionHeader + 1), (pOptionHeader->OptionLength - 4));
    for (i=0; i < NumNaks; i++)
    {
        //
        // Do not fill in the 0th entry, since that is from the packet header itself
        //
        pNaksList->pNakSequences[i+1] = (SEQ_TYPE) ntohl (pPacketNaks[i]);
    }
    pNaksList->NumSequences = (USHORT) i;
}


//----------------------------------------------------------------------------

NTSTATUS
ProcessOptions(
    IN  tPACKET_OPTION_LENGTH UNALIGNED *pPacketExtension,
    IN  ULONG                           BytesAvailable,
    IN  ULONG                           PacketType,
    OUT tPACKET_OPTIONS                 *pPacketOptions,
    OUT tNAKS_LIST                      *pNaksList
    )
/*++

Routine Description:

    This routine processes the options fields on an incoming Pgm packet
    and returns the options information extracted in the OUT parameters

Arguments:

    IN  pPacketExtension    -- Options section of the packet
    IN  BytesAvailable      -- from the start of the options
    IN  PacketType          -- Whether Data or Spm packet, etc
    OUT pPacketOptions      -- Structure containing the parameters from the options

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader;
    ULONG                               BytesLeft = BytesAvailable;
    UCHAR                               i;
    ULONG                               MessageFirstSequence, MessageLength, MessageOffset;
    ULONG                               pOptionsData[3];
    ULONG                               OptionsFlags = 0;
    ULONG                               NumOptionsProcessed = 0;
    USHORT                              TotalOptionsLength = 0;
    NTSTATUS                            status = STATUS_UNSUCCESSFUL;

    pPacketOptions->OptionsLength = 0;      // Init
    pPacketOptions->OptionsFlags = 0;       // Init

    if (BytesLeft > sizeof(tPACKET_OPTION_LENGTH))
    {
        PgmCopyMemory (&TotalOptionsLength, &pPacketExtension->TotalOptionsLength, sizeof (USHORT));
        TotalOptionsLength = ntohs (TotalOptionsLength);
    }

    //
    // First process the Option extension
    //
    if ((BytesLeft < ((sizeof(tPACKET_OPTION_LENGTH) + sizeof(tPACKET_OPTION_GENERIC)))) || // Ext+opt
        (pPacketExtension->Type != PACKET_OPTION_LENGTH) ||
        (pPacketExtension->Length != 4) ||
        (BytesLeft < TotalOptionsLength))       // Verify length
    {
        //
        // Need to get at least our header from transport!
        //
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
            "BytesLeft=<%d> < Min=<%d>, TotalOptionsLength=<%d>, ExtLength=<%d>, ExtType=<%x>\n",
                BytesLeft, ((sizeof(tPACKET_OPTION_LENGTH) + sizeof(tPACKET_OPTION_GENERIC))),
                (ULONG) TotalOptionsLength, pPacketExtension->Length, pPacketExtension->Type);

        return (status);
    }

    //
    // Now, process each option
    //
    pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) (pPacketExtension + 1);
    BytesLeft -= sizeof(tPACKET_OPTION_LENGTH);
    NumOptionsProcessed = 0;

    do
    {
        if (pOptionHeader->OptionLength > BytesLeft)
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                "Incorrectly formatted Options: OptionLength=<%d> > BytesLeft=<%d>, NumProcessed=<%d>\n",
                    pOptionHeader->OptionLength, BytesLeft, NumOptionsProcessed);

            status = STATUS_UNSUCCESSFUL;
            break;
        }

        status = STATUS_SUCCESS;            // By default

        switch (pOptionHeader->E_OptionType & ~PACKET_OPTION_TYPE_END_BIT)
        {
            case (PACKET_OPTION_NAK_LIST):
            {
                if (((PacketType == PACKET_TYPE_NAK) ||
                     (PacketType == PACKET_TYPE_NCF) ||
                     (PacketType == PACKET_TYPE_NNAK)) &&
                    ((pOptionHeader->OptionLength >= PGM_PACKET_OPT_MIN_NAK_LIST_LENGTH) &&
                     (pOptionHeader->OptionLength <= PGM_PACKET_OPT_MAX_NAK_LIST_LENGTH)))
                {
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessOptions",
                        "NAK_LIST:  Num Naks=<%d>\n", (pOptionHeader->OptionLength-4)/4);

                    if (pNaksList)
                    {
                        ProcessNakOption (pOptionHeader, pNaksList);
                    }
                    else
                    {
                        ASSERT (0);
                    }
                    OptionsFlags |= PGM_OPTION_FLAG_NAK_LIST;
                }
                else
                {
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                        "NAK_LIST:  PacketType=<%x>, Length=<0x%x>, pPacketOptions=<%x>\n",
                            PacketType, pOptionHeader->OptionLength, pPacketOptions);

                    status = STATUS_UNSUCCESSFUL;
                }

                break;
            }

/*
// Not supported for now!
            case (PACKET_OPTION_REDIRECT):
            {
                ASSERT (pOptionHeader->OptionLength > 4);     // 4 + sizeof(NLA)
                break;
            }
*/

            case (PACKET_OPTION_FRAGMENT):
            {
                status = STATUS_UNSUCCESSFUL;
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_FRAGMENT_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), (3 * sizeof(ULONG)));
                    if (pOptionHeader->Reserved_F_Opx & PACKET_OPTION_RES_F_OPX_ENCODED_BIT)
                    {
                        pPacketOptions->MessageFirstSequence = pOptionsData[0];
                        pPacketOptions->MessageOffset = pOptionsData[1];
                        pPacketOptions->MessageLength = pOptionsData[2];
                        pPacketOptions->FECContext.FragmentOptSpecific = pOptionHeader->U_OptSpecific;

                        status = STATUS_SUCCESS;
                        OptionsFlags |= PGM_OPTION_FLAG_FRAGMENT;
                    }
                    else
                    {
                        MessageFirstSequence = ntohl (pOptionsData[0]);
                        MessageOffset = ntohl (pOptionsData[1]);
                        MessageLength = ntohl (pOptionsData[2]);
                        if ((MessageLength) && (MessageOffset <= MessageLength))
                        {
                            PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessOptions",
                                "FRAGMENT:  MsgOffset/Length=<%d/%d>\n", MessageOffset, MessageLength);

                            if (pPacketOptions)
                            {
                                pPacketOptions->MessageFirstSequence = MessageFirstSequence;
                                pPacketOptions->MessageOffset = MessageOffset;
                                pPacketOptions->MessageLength = MessageLength;
//                                pPacketOptions->FECContext.FragmentOptSpecific = PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT;
                            }

                            status = STATUS_SUCCESS;
                            OptionsFlags |= PGM_OPTION_FLAG_FRAGMENT;
                        }
                        else
                        {
                            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                                "FRAGMENT:  MsgOffset/Length=<%d/%d>\n", MessageOffset, MessageLength);
                        }
                    }
                }
                else
                {
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                        "FRAGMENT:  OptionLength=<%d> != PGM_PACKET_OPT_FRAGMENT_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_FRAGMENT_LENGTH);
                }

                break;
            }

            case (PACKET_OPTION_JOIN):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_JOIN_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), sizeof(ULONG));
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessOptions",
                        "JOIN:  LateJoinerSeq=<%d>\n", ntohl (pOptionsData[0]));

                    if (pPacketOptions)
                    {
                        pPacketOptions->LateJoinerSequence = ntohl (pOptionsData[0]);
                    }

                    OptionsFlags |= PGM_OPTION_FLAG_JOIN;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                        "JOIN:  OptionLength=<%d> != PGM_PACKET_OPT_JOIN_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_JOIN_LENGTH);
                }

                break;
            }

            case (PACKET_OPTION_SYN):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_SYN_LENGTH)
                {
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessOptions",
                        "SYN\n");

                    OptionsFlags |= PGM_OPTION_FLAG_SYN;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                        "SYN:  OptionLength=<%d> != PGM_PACKET_OPT_SYN_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_SYN_LENGTH);
                }

                break;
            }

            case (PACKET_OPTION_FIN):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_FIN_LENGTH)
                {
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessOptions",
                        "FIN\n");

                    OptionsFlags |= PGM_OPTION_FLAG_FIN;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                        "FIN:  OptionLength=<%d> != PGM_PACKET_OPT_FIN_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_FIN_LENGTH);
                }

                break;
            }

            case (PACKET_OPTION_RST):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_RST_LENGTH)
                {
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessOptions",
                        "RST\n");

                    OptionsFlags |= PGM_OPTION_FLAG_RST;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                        "RST:  OptionLength=<%d> != PGM_PACKET_OPT_RST_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_RST_LENGTH);
                }

                break;
            }

            //
            // FEC options
            //
            case (PACKET_OPTION_PARITY_PRM):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_PARITY_PRM_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), sizeof(ULONG));
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessOptions",
                        "PARITY_PRM:  OptionsSpecific=<%x>, FECGroupInfo=<%d>\n",
                            pOptionHeader->U_OptSpecific, ntohl (pOptionsData[0]));

                    if (pPacketOptions)
                    {
                        pOptionsData[0] = ntohl (pOptionsData[0]);
                        ASSERT (((UCHAR) pOptionsData[0]) == pOptionsData[0]);
                        pPacketOptions->FECContext.ReceiverFECOptions = pOptionHeader->U_OptSpecific;
                        pPacketOptions->FECContext.FECGroupInfo = (UCHAR) pOptionsData[0];
                    }

                    OptionsFlags |= PGM_OPTION_FLAG_PARITY_PRM;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                        "PARITY_PRM:  OptionLength=<%d> != PGM_PACKET_OPT_PARITY_PRM_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_PARITY_PRM_LENGTH);
                }

                break;
            }

            case (PACKET_OPTION_PARITY_GRP):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_PARITY_GRP_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), sizeof(ULONG));
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessOptions",
                        "PARITY_GRP:  FECGroupInfo=<%d>\n",
                            ntohl (pOptionsData[0]));

                    if (pPacketOptions)
                    {
                        pOptionsData[0] = ntohl (pOptionsData[0]);
                        ASSERT (((UCHAR) pOptionsData[0]) == pOptionsData[0]);
                        pPacketOptions->FECContext.FECGroupInfo = (UCHAR) pOptionsData[0];
                    }

                    OptionsFlags |= PGM_OPTION_FLAG_PARITY_GRP;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                        "PARITY_GRP:  OptionLength=<%d> != PGM_PACKET_OPT_PARITY_GRP_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_PARITY_GRP_LENGTH);
                }

                break;
            }

            case (PACKET_OPTION_CURR_TGSIZE):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), sizeof(ULONG));
                    PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessOptions",
                        "CURR_TGSIZE:  NumPacketsInThisGroup=<%d>\n",
                            ntohl (pOptionsData[0]));

                    if (pPacketOptions)
                    {
                        pPacketOptions->FECContext.NumPacketsInThisGroup = (UCHAR) (ntohl (pOptionsData[0]));
                    }

                    OptionsFlags |= PGM_OPTION_FLAG_PARITY_CUR_TGSIZE;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                        "PARITY_GRP:  OptionLength=<%d> != PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH);
                }

                break;
            }

            case (PACKET_OPTION_REDIRECT):
            case (PACKET_OPTION_CR):
            case (PACKET_OPTION_CRQST):
            case (PACKET_OPTION_NAK_BO_IVL):
            case (PACKET_OPTION_NAK_BO_RNG):
            case (PACKET_OPTION_NBR_UNREACH):
            case (PACKET_OPTION_PATH_NLA):
            case (PACKET_OPTION_INVALID):
            {
                PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ProcessOptions",
                    "WARNING:  PacketType=<%x>:  Unhandled Option=<%x>, OptionLength=<%d>\n",
                        PacketType, (pOptionHeader->E_OptionType & ~PACKET_OPTION_TYPE_END_BIT), pOptionHeader->OptionLength);

                OptionsFlags |= PGM_OPTION_FLAG_UNRECOGNIZED;
                break;
            }

            default:
            {
                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                    "PacketType=<%x>:  Unrecognized Option=<%x>, OptionLength=<%d>\n",
                        PacketType, (pOptionHeader->E_OptionType & ~PACKET_OPTION_TYPE_END_BIT), pOptionHeader->OptionLength);
                ASSERT (0);     // We do not recognize this option, but we will continue anyway!

                OptionsFlags |= PGM_OPTION_FLAG_UNRECOGNIZED;
                status = STATUS_UNSUCCESSFUL;
                break;
            }
        }

        if (!NT_SUCCESS (status))
        {
            break;
        }

        NumOptionsProcessed++;
        BytesLeft -= pOptionHeader->OptionLength;

        if (pOptionHeader->E_OptionType & PACKET_OPTION_TYPE_END_BIT)
        {
            break;
        }

        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *)
                            (((UCHAR *) pOptionHeader) + pOptionHeader->OptionLength);

        status = STATUS_UNSUCCESSFUL;   // Init for next option!
    } while (BytesLeft >= sizeof(tPACKET_OPTION_GENERIC));

    ASSERT (NT_SUCCESS (status));
    if (NT_SUCCESS (status))
    {
        if ((BytesLeft + TotalOptionsLength) == BytesAvailable)
        {
            pPacketOptions->OptionsLength = TotalOptionsLength;
            pPacketOptions->OptionsFlags = OptionsFlags;
        }
        else
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessOptions",
                "BytesLeft=<%d> + TotalOptionsLength=<%d> != BytesAvailable=<%d>\n",
                    BytesLeft, TotalOptionsLength, BytesAvailable);

            status = STATUS_INVALID_BUFFER_SIZE;
        }
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "ProcessOptions",
        "Processed <%d> options, TotalOptionsLength=<%d>\n", NumOptionsProcessed, TotalOptionsLength);

    return (status);
}


//----------------------------------------------------------------------------

ULONG
AdjustReceiveBufferLists(
    IN  tRECEIVE_SESSION        *pReceive
    )
{
    tNAK_FORWARD_DATA           *pNak;
    UCHAR                       TotalPackets, i;
    ULONG                       NumMoved = 0;
    ULONG                       DataPacketsMoved = 0;

    //
    // Assume we have no Naks pending
    //
    pReceive->pReceiver->FirstNakSequenceNumber = pReceive->pReceiver->FurthestKnownGroupSequenceNumber
                                                  + pReceive->FECGroupSize;
    while (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList))
    {
        //
        // Move any Naks contexts for which the group is complete
        // to the BufferedDataList
        //
        pNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Flink, tNAK_FORWARD_DATA, Linkage);
        if (((pNak->NumDataPackets + pNak->NumParityPackets) < pNak->PacketsInGroup) &&
            ((pNak->NextIndexToIndicate + pNak->NumDataPackets) < pNak->PacketsInGroup))
        {
            pReceive->pReceiver->FirstNakSequenceNumber = pNak->SequenceNumber;
            break;
        }

        //
        // If this is a partial group with extraneous parity packets,
        // remove the parity packets
        //
        if ((pNak->NextIndexToIndicate) &&
            (pNak->NumParityPackets) &&
            ((pNak->NextIndexToIndicate + pNak->NumDataPackets) >= pNak->PacketsInGroup))
        {
            //
            // Start from the end and go backwards
            //
            i = TotalPackets = pNak->NumDataPackets + pNak->NumParityPackets;
            while (i && pNak->NumParityPackets)
            {
                i--;    // Convert from packet # to index
                if (pNak->pPendingData[i].PacketIndex >= pNak->OriginalGroupSize)
                {
                    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "AdjustReceiveBufferLists",
                        "Extraneous parity [%d] -- NextIndex=<%d>, Data=<%d>, Parity=<%d>, PktsInGrp=<%d>\n",
                            i, (ULONG) pNak->NextIndexToIndicate, (ULONG) pNak->NumDataPackets,
                            (ULONG) pNak->NumParityPackets, (ULONG) pNak->PacketsInGroup);

                    PgmFreeMem (pNak->pPendingData[i].pDataPacket);
                    if (i != (TotalPackets - 1))
                    {
                        PgmCopyMemory (&pNak->pPendingData[i], &pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
                    }
                    PgmZeroMemory (&pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
                    pNak->NumParityPackets--;

                    TotalPackets--;

                    pReceive->pReceiver->DataPacketsPendingNaks--;
                    pReceive->pReceiver->TotalDataPacketsBuffered--;
                }
            }

            //
            // Re-Init all the indices
            //
            for (i=0; i<pNak->OriginalGroupSize; i++)
            {
                pNak->pPendingData[i].ActualIndexOfDataPacket = pNak->OriginalGroupSize;
            }

            //
            // Set the indices only for the data packets
            //
            for (i=0; i<TotalPackets; i++)
            {
                if (pNak->pPendingData[i].PacketIndex < pNak->OriginalGroupSize)
                {
                    pNak->pPendingData[pNak->pPendingData[i].PacketIndex].ActualIndexOfDataPacket = i;
                }
            }
        }

        RemoveEntryList (&pNak->Linkage);
        InsertTailList (&pReceive->pReceiver->BufferedDataList, &pNak->Linkage);
        NumMoved++;
        DataPacketsMoved += (pNak->NumDataPackets + pNak->NumParityPackets);
    }

    pReceive->pReceiver->NumPacketGroupsPendingClient += NumMoved;
    pReceive->pReceiver->DataPacketsPendingIndicate += DataPacketsMoved;
    pReceive->pReceiver->DataPacketsPendingNaks -= DataPacketsMoved;

    ASSERT (pReceive->pReceiver->TotalDataPacketsBuffered == (pReceive->pReceiver->DataPacketsPendingIndicate +
                                                              pReceive->pReceiver->DataPacketsPendingNaks));

    return (NumMoved);
}


//----------------------------------------------------------------------------

VOID
AdjustNcfRDataResponseTimes(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  PNAK_FORWARD_DATA       pLastNak
    )
{
    ULONGLONG               NcfRDataTickCounts;

    NcfRDataTickCounts = PgmDynamicConfig.ReceiversTimerTickCount - pLastNak->FirstNcfTickCount;
    pReceive->pReceiver->StatSumOfNcfRDataTicks += NcfRDataTickCounts;
    pReceive->pReceiver->NumNcfRDataTicksSamples++;

    if (!pReceive->pReceiver->NumNcfRDataTicksSamples)
    {
        //
        // This will be the divisor below, so it has to be non-zero!
        //
        ASSERT (0);
        return;
    }

    if ((NcfRDataTickCounts > pReceive->pReceiver->MaxOutstandingNakTimeout) &&
        (pReceive->pReceiver->MaxOutstandingNakTimeout !=
         pReceive->pReceiver->MaxRDataResponseTCFromWindow))
    {
        if (pReceive->pReceiver->MaxRDataResponseTCFromWindow &&
            NcfRDataTickCounts > pReceive->pReceiver->MaxRDataResponseTCFromWindow)
        {
            pReceive->pReceiver->MaxOutstandingNakTimeout = pReceive->pReceiver->MaxRDataResponseTCFromWindow;
        }
        else
        {
            pReceive->pReceiver->MaxOutstandingNakTimeout = NcfRDataTickCounts;
        }

        //
        // Since we just updated the Max value, we should also
        // recalculate the default timeout
        //
        pReceive->pReceiver->AverageNcfRDataResponseTC = pReceive->pReceiver->StatSumOfNcfRDataTicks /
                                                         pReceive->pReceiver->NumNcfRDataTicksSamples;
        NcfRDataTickCounts = (pReceive->pReceiver->AverageNcfRDataResponseTC +
                              pReceive->pReceiver->MaxOutstandingNakTimeout) >> 1;
        if (NcfRDataTickCounts > (pReceive->pReceiver->AverageNcfRDataResponseTC << 1))
        {
            NcfRDataTickCounts = pReceive->pReceiver->AverageNcfRDataResponseTC << 1;
        }

        if (NcfRDataTickCounts > pReceive->pReceiver->OutstandingNakTimeout)
        {
            pReceive->pReceiver->OutstandingNakTimeout = NcfRDataTickCounts;
        }
    }
}


//----------------------------------------------------------------------------
VOID
UpdateSpmIntervalInformation(
    IN  tRECEIVE_SESSION        *pReceive
    )
{
    ULONG   LastIntervalTickCount = (ULONG) (PgmDynamicConfig.ReceiversTimerTickCount -
                                             pReceive->pReceiver->LastSpmTickCount);

    if (!LastIntervalTickCount)
    {
        return;
    }

    pReceive->pReceiver->LastSpmTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
    if (LastIntervalTickCount > pReceive->pReceiver->MaxSpmInterval)
    {
        pReceive->pReceiver->MaxSpmInterval = LastIntervalTickCount;
    }

/*
    if (pReceive->pReceiver->NumSpmIntervalSamples)
    {
        pReceive->pReceiver->StatSumOfSpmIntervals += pReceive->pReceiver->LastSpmTickCount;
        pReceive->pReceiver->NumSpmIntervalSamples++;
        pReceive->pReceiver->AverageSpmInterval = pReceive->pReceiver->StatSumOfSpmIntervals /
                                                  pReceive->pReceiver->NumSpmIntervalSamples;
    }
*/
}

//----------------------------------------------------------------------------


VOID
UpdateRealTimeWindowInformation(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  SEQ_TYPE                LeadingEdgeSeqNumber,
    IN  SEQ_TYPE                TrailingEdgeSeqNumber
    )
{
    SEQ_TYPE    SequencesInWindow = 1 + LeadingEdgeSeqNumber - TrailingEdgeSeqNumber;

    if (SEQ_GT (SequencesInWindow, pReceive->pReceiver->MaxSequencesInWindow))
    {
        pReceive->pReceiver->MaxSequencesInWindow = SequencesInWindow;
    }

    if (TrailingEdgeSeqNumber)
    {
        if ((!pReceive->pReceiver->MinSequencesInWindow) ||
            SEQ_LT (SequencesInWindow, pReceive->pReceiver->MinSequencesInWindow))
        {
            pReceive->pReceiver->MinSequencesInWindow = SequencesInWindow;
        }

        pReceive->pReceiver->StatSumOfWindowSeqs += SequencesInWindow;
        pReceive->pReceiver->NumWindowSamples++;
    }
}

VOID
UpdateSampleTimeWindowInformation(
    IN  tRECEIVE_SESSION        *pReceive
    )
{
    ULONGLONG           NcfRDataTimeout;

    //
    // No need to update if there is no data
    //
    if (!pReceive->RateKBitsPerSecLast ||
        !pReceive->pReceiver->NumWindowSamples ||       // Avoid divide by 0 error
        !pReceive->TotalPacketsInLastInterval)          // Avoid divide by 0 error
    {
        return;
    }
    ASSERT (INITIAL_NAK_OUTSTANDING_TIMEOUT_MSECS >= BASIC_TIMER_GRANULARITY_IN_MSECS);

    //
    // Now, update the window information
    //
    if (pReceive->pReceiver->StatSumOfWindowSeqs)
    {
        pReceive->pReceiver->AverageSequencesInWindow = pReceive->pReceiver->StatSumOfWindowSeqs /
                                                        pReceive->pReceiver->NumWindowSamples;
    }

    if (pReceive->pReceiver->AverageSequencesInWindow)
    {
        pReceive->pReceiver->WindowSizeLastInMSecs = ((pReceive->pReceiver->AverageSequencesInWindow *
                                                       pReceive->TotalBytes) << LOG2_BITS_PER_BYTE) /
                                                     (pReceive->TotalPacketsInLastInterval *
                                                      pReceive->RateKBitsPerSecLast);
    }
    else
    {
        pReceive->pReceiver->WindowSizeLastInMSecs = ((pReceive->pReceiver->MaxSequencesInWindow *
                                                       pReceive->TotalBytes) << LOG2_BITS_PER_BYTE) /
                                                     (pReceive->TotalPacketsInLastInterval *
                                                      pReceive->RateKBitsPerSecLast);
    }
    pReceive->pReceiver->MaxRDataResponseTCFromWindow = pReceive->pReceiver->WindowSizeLastInMSecs /
                                                        (NCF_WAITING_RDATA_MAX_RETRIES * BASIC_TIMER_GRANULARITY_IN_MSECS);

    //
    // Now, update the NcfRData timeout information
    //
    if (pReceive->pReceiver->StatSumOfNcfRDataTicks &&
        pReceive->pReceiver->NumNcfRDataTicksSamples)
    {
        pReceive->pReceiver->AverageNcfRDataResponseTC = pReceive->pReceiver->StatSumOfNcfRDataTicks /
                                                         pReceive->pReceiver->NumNcfRDataTicksSamples;
    }

    if (pReceive->pReceiver->AverageNcfRDataResponseTC)
    {
        NcfRDataTimeout = (pReceive->pReceiver->AverageNcfRDataResponseTC +
                           pReceive->pReceiver->MaxOutstandingNakTimeout) >> 1;
        if (NcfRDataTimeout > (pReceive->pReceiver->AverageNcfRDataResponseTC << 1))
        {
            NcfRDataTimeout = pReceive->pReceiver->AverageNcfRDataResponseTC << 1;
        }
        if (NcfRDataTimeout >
            INITIAL_NAK_OUTSTANDING_TIMEOUT_MSECS/BASIC_TIMER_GRANULARITY_IN_MSECS)
        {
            pReceive->pReceiver->OutstandingNakTimeout = NcfRDataTimeout;
        }
        else
        {
            pReceive->pReceiver->OutstandingNakTimeout = INITIAL_NAK_OUTSTANDING_TIMEOUT_MSECS /
                                                         BASIC_TIMER_GRANULARITY_IN_MSECS;
        }
    }
}


//----------------------------------------------------------------------------
VOID
RemoveRedundantNaks(
    IN  tNAK_FORWARD_DATA       *pNak,
    IN  BOOLEAN                 fEliminateExtraParityPackets
    )
{
    UCHAR   i, TotalPackets;

    ASSERT (fEliminateExtraParityPackets || !pNak->NumParityPackets);
    TotalPackets = pNak->NumDataPackets + pNak->NumParityPackets;

    //
    // First, eliminate the NULL Packets
    //
    if (pNak->PacketsInGroup < pNak->OriginalGroupSize)
    {
        i = 0;
        while (i < pNak->OriginalGroupSize)
        {
            if ((pNak->pPendingData[i].PacketIndex < pNak->PacketsInGroup) ||       // Non-NULL Data packet
                (pNak->pPendingData[i].PacketIndex >= pNak->OriginalGroupSize))     // Parity packet
            {
                //
                // Ignore for now!
                //
                i++;
                continue;
            }

            PgmFreeMem (pNak->pPendingData[i].pDataPacket);
            if (i != (TotalPackets-1))
            {
                PgmCopyMemory (&pNak->pPendingData[i], &pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
            }
            PgmZeroMemory (&pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
            pNak->NumDataPackets--;
            TotalPackets--;
        }
        ASSERT (pNak->NumDataPackets <= TotalPackets);

        if (fEliminateExtraParityPackets)
        {
            //  
            // If we still have extra parity packets, free those also
            //
            i = 0;
            while ((i < TotalPackets) &&
                   (TotalPackets > pNak->PacketsInGroup))
            {
                ASSERT (pNak->NumParityPackets);
                if (pNak->pPendingData[i].PacketIndex < pNak->OriginalGroupSize)
                {
                    //
                    // Ignore data packets
                    //
                    i++;
                    continue;
                }

                PgmFreeMem (pNak->pPendingData[i].pDataPacket);
                if (i != (TotalPackets-1))
                {
                    PgmCopyMemory (&pNak->pPendingData[i], &pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
                }
                PgmZeroMemory (&pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
                pNak->NumParityPackets--;
                TotalPackets--;
            }

            ASSERT (TotalPackets <= pNak->PacketsInGroup);
        }
    }

    //
    // Re-Init all the indices
    //
    for (i=0; i<pNak->OriginalGroupSize; i++)
    {
        pNak->pPendingData[i].ActualIndexOfDataPacket = pNak->OriginalGroupSize;
    }

    //
    // Set the indices only for the data packets
    //
    for (i=0; i<TotalPackets; i++)
    {
        if (pNak->pPendingData[i].PacketIndex < pNak->OriginalGroupSize)
        {
            pNak->pPendingData[pNak->pPendingData[i].PacketIndex].ActualIndexOfDataPacket = i;
        }
    }

    if (((pNak->NumDataPackets + pNak->NumParityPackets) >= pNak->PacketsInGroup) ||
        ((pNak->NextIndexToIndicate + pNak->NumDataPackets) >= pNak->PacketsInGroup))
    {
        ASSERT ((!fEliminateExtraParityPackets) ||
                (!IsListEmpty (&pNak->PendingLinkage)));

        RemoveEntryList (&pNak->PendingLinkage);
        InitializeListHead (&pNak->PendingLinkage);
    }
}


//----------------------------------------------------------------------------

VOID
PgmSendNakCompletion(
    IN  tRECEIVE_SESSION                *pReceive,
    IN  tNAK_CONTEXT                    *pNakContext,
    IN  NTSTATUS                        status
    )
/*++

Routine Description:

    This is the Completion routine called by IP on completing a NakSend

Arguments:

    IN  pReceive    -- Receive context
    IN  pNakContext -- Nak Context to be free'ed
    IN  status      -- status of send from tansport

Return Value:

    NONE

--*/
{
    PGMLockHandle               OldIrq;

    PgmLock (pReceive, OldIrq);
    if (NT_SUCCESS (status))
    {
        //
        // Set the Receiver Nak statistics
        //
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_SEND, "PgmSendNakCompletion",
            "SUCCEEDED\n");
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendNakCompletion",
            "status=<%x>\n", status);
    }

    if (!(--pNakContext->RefCount))
    {
        PgmUnlock (pReceive, OldIrq);

        //
        // Free the Memory and deref the Session context for this Nak
        //
        PgmFreeMem (pNakContext);
        PGM_DEREFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_SEND_NAK);
    }
    else
    {
        PgmUnlock (pReceive, OldIrq);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendNak(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  tNAKS_CONTEXT           *pNakSequences
    )
/*++

Routine Description:

    This routine sends a Nak packet with the number of sequences specified

Arguments:

    IN  pReceive        -- Receive context
    IN  pNakSequences   -- List of Sequence #s

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    tBASIC_NAK_NCF_PACKET_HEADER    *pNakPacket;
    tNAK_CONTEXT                    *pNakContext;
    tPACKET_OPTION_LENGTH           *pPacketExtension;
    tPACKET_OPTION_GENERIC          *pOptionHeader;
    ULONG                           i;
    ULONG                           XSum;
    USHORT                          OptionsLength = 0;
    NTSTATUS                        status;

    if ((!pNakSequences->NumSequences) ||
        (pNakSequences->NumSequences > (MAX_SEQUENCES_PER_NAK_OPTION+1)) ||
        (!(pNakContext = PgmAllocMem ((2*sizeof(ULONG)+PGM_MAX_NAK_NCF_HEADER_LENGTH), PGM_TAG('2')))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "PgmSendNak",
            "STATUS_INSUFFICIENT_RESOURCES allocating pNakContext\n");
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    PgmZeroMemory (pNakContext, (2*sizeof(ULONG)+PGM_MAX_NAK_NCF_HEADER_LENGTH));

    pNakContext->RefCount = 2;              // 1 for the unicast, and the other for the MCast Nak
    pNakPacket = &pNakContext->NakPacket;
    pNakPacket->CommonHeader.SrcPort = htons (pReceive->pReceiver->ListenMCastPort);
    pNakPacket->CommonHeader.DestPort = htons (pReceive->TSIPort);
    pNakPacket->CommonHeader.Type = PACKET_TYPE_NAK;

    if (pNakSequences->NakType == NAK_TYPE_PARITY)
    {
        pNakPacket->CommonHeader.Options = PACKET_HEADER_OPTIONS_PARITY;
        pReceive->pReceiver->TotalParityNaksSent += pNakSequences->NumSequences;
    }
    else
    {
        pNakPacket->CommonHeader.Options = 0;
        pReceive->pReceiver->TotalSelectiveNaksSent += pNakSequences->NumSequences;
    }
    PgmCopyMemory (&pNakPacket->CommonHeader.gSourceId, &pReceive->GSI, SOURCE_ID_LENGTH);

    pNakPacket->RequestedSequenceNumber = htonl ((ULONG) pNakSequences->Sequences[0]);
    pNakPacket->SourceNLA.NLA_AFI = htons (IPV4_NLA_AFI);
    pNakPacket->SourceNLA.IpAddress = htonl (pReceive->pReceiver->SenderIpAddress);
    pNakPacket->MCastGroupNLA.NLA_AFI = htons (IPV4_NLA_AFI);
    pNakPacket->MCastGroupNLA.IpAddress = htonl (pReceive->pReceiver->ListenMCastIpAddress);

    PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmSendNak",
        "Sending Naks for:\n\t[%d]\n", (ULONG) pNakSequences->Sequences[0]);

    if (pNakSequences->NumSequences > 1)
    {
        pPacketExtension = (tPACKET_OPTION_LENGTH *) (pNakPacket + 1);
        pPacketExtension->Type = PACKET_OPTION_LENGTH;
        pPacketExtension->Length = PGM_PACKET_EXTENSION_LENGTH;
        OptionsLength += PGM_PACKET_EXTENSION_LENGTH;

        pOptionHeader = (tPACKET_OPTION_GENERIC *) (pPacketExtension + 1);
        pOptionHeader->E_OptionType = PACKET_OPTION_NAK_LIST;
        pOptionHeader->OptionLength = 4 + (UCHAR) ((pNakSequences->NumSequences-1) * sizeof(ULONG));
        for (i=1; i<pNakSequences->NumSequences; i++)
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_SEND, "PgmSendNak",
                "\t[%d]\n", (ULONG) pNakSequences->Sequences[i]);

            ((PULONG) (pOptionHeader))[i] = htonl ((ULONG) pNakSequences->Sequences[i]);
        }

        pOptionHeader->E_OptionType |= PACKET_OPTION_TYPE_END_BIT;    // One and only (last) opt
        pNakPacket->CommonHeader.Options |=(PACKET_HEADER_OPTIONS_PRESENT |
                                            PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT);
        OptionsLength = PGM_PACKET_EXTENSION_LENGTH + pOptionHeader->OptionLength;
        pPacketExtension->TotalOptionsLength = htons (OptionsLength);
    }

    OptionsLength += sizeof(tBASIC_NAK_NCF_PACKET_HEADER);  // Now is whole pkt
    pNakPacket->CommonHeader.Checksum = 0;
    XSum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pNakPacket, OptionsLength); 
    pNakPacket->CommonHeader.Checksum = (USHORT) (~XSum);

    PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_SEND_NAK, FALSE);

    //
    // First multicast the Nak
    //
    status = TdiSendDatagram (pReceive->pReceiver->pAddress->pFileObject,
                              pReceive->pReceiver->pAddress->pDeviceObject,
                              pNakPacket,
                              OptionsLength,
                              PgmSendNakCompletion,     // Completion
                              pReceive,                 // Context1
                              pNakContext,              // Context2
                              pReceive->pReceiver->ListenMCastIpAddress,
                              pReceive->pReceiver->ListenMCastPort);

    ASSERT (NT_SUCCESS (status));

    //
    // Now, Unicast the Nak
    //
    status = TdiSendDatagram (pReceive->pReceiver->pAddress->pFileObject,
                              pReceive->pReceiver->pAddress->pDeviceObject,
                              pNakPacket,
                              OptionsLength,
                              PgmSendNakCompletion,     // Completion
                              pReceive,                 // Context1
                              pNakContext,              // Context2
                              pReceive->pReceiver->LastSpmSource,
                              IPPROTO_RM);

    ASSERT (NT_SUCCESS (status));

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "PgmSendNak",
        "Sent %s Nak for <%d> Sequences [%d--%d] to <%x:%d>\n",
            (pNakSequences->NakType == NAK_TYPE_PARITY ? "PARITY" : "SELECTIVE"),
            pNakSequences->NumSequences, (ULONG) pNakSequences->Sequences[0],
            (ULONG) pNakSequences->Sequences[pNakSequences->NumSequences-1],
            pReceive->pReceiver->SenderIpAddress, IPPROTO_RM);

    return (status);
}


//----------------------------------------------------------------------------

VOID
CheckSendPendingNaks(
    IN  tADDRESS_CONTEXT        *pAddress,
    IN  tRECEIVE_SESSION        *pReceive,
    IN  PGMLockHandle           *pOldIrq
    )
/*++

Routine Description:

    This routine checks if any Naks need to be sent and sends them
    as required

    The PgmDynamicConfig lock is held on entry and exit from
    this routine

Arguments:

    IN  pAddress    -- Address object context
    IN  pReceive    -- Receive context
    IN  pOldIrq     -- Irq for PgmDynamicConfig

Return Value:

    NONE

--*/
{
    tNAKS_CONTEXT               *pNakContext, *pSelectiveNaks = NULL;
    tNAKS_CONTEXT               *pParityNaks = NULL;
    LIST_ENTRY                  NaksList;
    LIST_ENTRY                  *pEntry;
    tNAK_FORWARD_DATA           *pNak;
    SEQ_TYPE                    LastSequenceNumber;
    PGMLockHandle               OldIrq, OldIrq1;
    ULONG                       NumMissingPackets, TotalSeqsNacked = 0;
    BOOLEAN                     fSendSelectiveNak, fSendParityNak;
    UCHAR                       i, j;
    ULONG                       NumPendingNaks = 0;
    ULONG                       NumOutstandingNaks = 0;

    if ((!pReceive->pReceiver->LastSpmSource) ||
        ((pReceive->pReceiver->DataPacketsPendingNaks <= OUT_OF_ORDER_PACKETS_BEFORE_NAK) &&
         ((pReceive->pReceiver->LastNakSendTime + (NAK_MAX_WAIT_TIMEOUT_MSECS/BASIC_TIMER_GRANULARITY_IN_MSECS)) >
          PgmDynamicConfig.ReceiversTimerTickCount)))
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "CheckSendPendingNaks",
            "No Naks to send for pReceive=<%p>, LastSpmSource=<%x>, NumDataPackets=<%d>, LastSendTime=<%d:%d>, Current=<%d:%d>\n",
                pReceive, pReceive->pReceiver->LastSpmSource,
                pReceive->pReceiver->DataPacketsPendingNaks,
                pReceive->pReceiver->LastNakSendTime+(NAK_MAX_WAIT_TIMEOUT_MSECS/BASIC_TIMER_GRANULARITY_IN_MSECS),
                PgmDynamicConfig.ReceiversTimerTickCount);

        return;
    }

    InitializeListHead (&NaksList);
    if (!(pSelectiveNaks = PgmAllocMem (sizeof (tNAKS_CONTEXT), PGM_TAG('5'))) ||
        !(pParityNaks = PgmAllocMem (sizeof (tNAKS_CONTEXT), PGM_TAG('6'))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_SEND, "CheckSendPendingNaks",
            "STATUS_INSUFFICIENT_RESOURCES allocating pNakContext\n");

        if (pSelectiveNaks)
        {
            PgmFreeMem (pSelectiveNaks);
        }

        return;
    }

    PgmZeroMemory (pSelectiveNaks, sizeof (tNAKS_CONTEXT));
    PgmZeroMemory (pParityNaks, sizeof (tNAKS_CONTEXT));
    pParityNaks->NakType = NAK_TYPE_PARITY;
    pSelectiveNaks->NakType = NAK_TYPE_SELECTIVE;
    InsertTailList (&NaksList, &pParityNaks->Linkage);
    InsertTailList (&NaksList, &pSelectiveNaks->Linkage);

    PgmLock (pAddress, OldIrq);
    PgmLock (pReceive, OldIrq1);

    AdjustReceiveBufferLists (pReceive);

    fSendSelectiveNak = fSendParityNak = FALSE;
    pEntry = &pReceive->pReceiver->PendingNaksList;
    while ((pEntry = pEntry->Flink) != &pReceive->pReceiver->PendingNaksList)
    {
        pNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, PendingLinkage);

        NumMissingPackets = pNak->PacketsInGroup - (pNak->NumDataPackets + pNak->NumParityPackets);
        ASSERT (NumMissingPackets);

        //
        // if this Nak is outside the trailing window, then we are hosed!
        //
        if (SEQ_GT (pReceive->pReceiver->LastTrailingEdgeSeqNum, pNak->SequenceNumber))
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "CheckSendPendingNaks",
                "Sequence # [%d] out of trailing edge <%d>, NumNcfs received=<%d>\n",
                    (ULONG) pNak->SequenceNumber,
                    (ULONG) pReceive->pReceiver->LastTrailingEdgeSeqNum,
                    pNak->WaitingRDataRetries);
            pReceive->SessionFlags |= PGM_SESSION_FLAG_NAK_TIMED_OUT;
            break;
        }

        //
        // See if we are currently in NAK pending mode
        //
        if (pNak->PendingNakTimeout)
        {
            NumPendingNaks += NumMissingPackets;
            if (PgmDynamicConfig.ReceiversTimerTickCount > pNak->PendingNakTimeout)
            {
                //
                // Time out Naks only after we have received a FIN!
                //
                if (pNak->WaitingNcfRetries++ >= NAK_WAITING_NCF_MAX_RETRIES)
                {
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "CheckSendPendingNaks",
                        "Pending Nak for Sequence # [%d] Timed out!  Num Ncfs received=<%d>, Window=<%d--%d> ( %d seqs)\n",
                            (ULONG) pNak->SequenceNumber, pNak->WaitingNcfRetries,
                            (ULONG) pReceive->pReceiver->LastTrailingEdgeSeqNum,
                            (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                            (ULONG) (1+pReceive->pReceiver->FurthestKnownGroupSequenceNumber-
                                       pReceive->pReceiver->LastTrailingEdgeSeqNum));
                    pReceive->SessionFlags |= PGM_SESSION_FLAG_NAK_TIMED_OUT;
                    break;
                }

                if ((pNak->PacketsInGroup > 1) &&
                    (pReceive->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT))
                {
                    ASSERT (NumMissingPackets <= pReceive->FECGroupSize);
                    pParityNaks->Sequences[pParityNaks->NumSequences] = (SEQ_TYPE) (pNak->SequenceNumber + NumMissingPackets - 1);

                    if (++pParityNaks->NumSequences == (MAX_SEQUENCES_PER_NAK_OPTION+1))
                    {
                        fSendParityNak = TRUE;
                    }
                    pNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                              ((NAK_REPEAT_INTERVAL_MSECS + (NAK_RANDOM_BACKOFF_MSECS/NumMissingPackets)) /
                                               BASIC_TIMER_GRANULARITY_IN_MSECS);
                    TotalSeqsNacked += NumMissingPackets;
                    NumMissingPackets = 0;
                }
                else
                {
                    for (i=pNak->NextIndexToIndicate; i<pNak->PacketsInGroup; i++)
                    {
                        if ((pNak->pPendingData[i].ActualIndexOfDataPacket >= pNak->OriginalGroupSize) &&
                            (!pNak->pPendingData[i].NcfsReceivedForActualIndex))
                        {
                            pSelectiveNaks->Sequences[pSelectiveNaks->NumSequences++] = pNak->SequenceNumber+i;
                            TotalSeqsNacked++;
                            if ((!--NumMissingPackets) ||
                                (pSelectiveNaks->NumSequences == (MAX_SEQUENCES_PER_NAK_OPTION+1)))
                            {
                                LastSequenceNumber = pNak->SequenceNumber+i;
                                break;
                            }
                        }
                    }

                    if (!NumMissingPackets)
                    {
                        pNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                                  ((NAK_REPEAT_INTERVAL_MSECS + NAK_RANDOM_BACKOFF_MSECS) /
                                                   BASIC_TIMER_GRANULARITY_IN_MSECS);
                    }

                    if (pSelectiveNaks->NumSequences == (MAX_SEQUENCES_PER_NAK_OPTION+1))
                    {
                        fSendSelectiveNak = TRUE;
                    }
                }
            }
        }
        else if (pNak->OutstandingNakTimeout)
        {
            NumOutstandingNaks += NumMissingPackets;
            if (PgmDynamicConfig.ReceiversTimerTickCount > pNak->OutstandingNakTimeout)
            {
                //
                // We have timed-out waiting for RData -- Reset the Timeout to send
                // a Nak after the Random Backoff (if we have not exceeded the Data retries)
                //
                if (pNak->WaitingRDataRetries++ == NCF_WAITING_RDATA_MAX_RETRIES)
                {
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "CheckSendPendingNaks",
                        "Outstanding Nak for Sequence # [%d] Timed out!, Window=<%d--%d> ( %d seqs), Ncfs=<%d>, FirstNak=<%d>\n",
                            (ULONG) pNak->SequenceNumber, (ULONG) pReceive->pReceiver->LastTrailingEdgeSeqNum,
                            (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                            (ULONG) (1+pReceive->pReceiver->FurthestKnownGroupSequenceNumber-pReceive->pReceiver->LastTrailingEdgeSeqNum),
                            pNak->WaitingRDataRetries, (ULONG) pReceive->pReceiver->FirstNakSequenceNumber);

                    pReceive->SessionFlags |= PGM_SESSION_FLAG_NAK_TIMED_OUT;
                    break;
                }

                pNak->WaitingNcfRetries = 0;
                pNak->OutstandingNakTimeout = 0;
                pNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                          ((NAK_RANDOM_BACKOFF_MSECS/NumMissingPackets) /
                                           BASIC_TIMER_GRANULARITY_IN_MSECS);

                for (i=0; i<pNak->PacketsInGroup; i++)
                {
                    pNak->pPendingData[i].NcfsReceivedForActualIndex = 0;
                }

                NumMissingPackets = 0;
            }
        }

        while (fSendSelectiveNak || fSendParityNak)
        {
            if (fSendSelectiveNak)
            {
                if (!(pSelectiveNaks = PgmAllocMem (sizeof (tNAKS_CONTEXT), PGM_TAG('5'))))
                {
                    PgmLog (PGM_LOG_ERROR, DBG_SEND, "CheckSendPendingNaks",
                        "STATUS_INSUFFICIENT_RESOURCES allocating pSelectiveNaks\n");

                    pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                    break;
                }

                PgmZeroMemory (pSelectiveNaks, sizeof (tNAKS_CONTEXT));
                pSelectiveNaks->NakType = NAK_TYPE_SELECTIVE;
                InsertTailList (&NaksList, &pSelectiveNaks->Linkage);
                fSendSelectiveNak = FALSE;
            }

            if (fSendParityNak)
            {
                if (!(pParityNaks = PgmAllocMem (sizeof (tNAKS_CONTEXT), PGM_TAG('6'))))
                {
                    PgmLog (PGM_LOG_ERROR, DBG_SEND, "CheckSendPendingNaks",
                        "STATUS_INSUFFICIENT_RESOURCES allocating pParityNaks\n");

                    pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                    break;
                }

                PgmZeroMemory (pParityNaks, sizeof (tNAKS_CONTEXT));
                pParityNaks->NakType = NAK_TYPE_PARITY;
                InsertTailList (&NaksList, &pParityNaks->Linkage);
                fSendParityNak = FALSE;
            }

            //
            // If we had some packets left to be sent from the
            // last Nak, include those sequences now
            //
            if (NumMissingPackets)
            {
                for (i=(UCHAR) (1+LastSequenceNumber-pNak->SequenceNumber); i<pNak->PacketsInGroup; i++)
                {
                    if (pNak->pPendingData[i].ActualIndexOfDataPacket >= pNak->OriginalGroupSize)
                    {
                        pSelectiveNaks->Sequences[pSelectiveNaks->NumSequences++] = pNak->SequenceNumber+i;
                        TotalSeqsNacked++;
                        if ((!--NumMissingPackets) ||
                            (pSelectiveNaks->NumSequences == (MAX_SEQUENCES_PER_NAK_OPTION+1)))
                        {
                            LastSequenceNumber = pNak->SequenceNumber+i;
                            break;
                        }
                    }
                }

                //
                // We could encounter a situation where we could have received
                // a packet while sending the Nak, so we should reset our MissingPacket
                // count accordingly
                //
                if (i >= pNak->PacketsInGroup)
                {
                    NumMissingPackets = 0;
                }

                if (!NumMissingPackets)
                {
                    pNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                              ((NAK_REPEAT_INTERVAL_MSECS + NAK_RANDOM_BACKOFF_MSECS) /
                                               BASIC_TIMER_GRANULARITY_IN_MSECS);
                }

                if (pSelectiveNaks->NumSequences == (MAX_SEQUENCES_PER_NAK_OPTION+1))
                {
                    fSendSelectiveNak = TRUE;
                }
            }
        }

        if (pReceive->SessionFlags & PGM_SESSION_TERMINATED_ABORT)
        {
            break;
        }
    }

    pReceive->pReceiver->NumPendingNaks = NumPendingNaks;
    pReceive->pReceiver->NumOutstandingNaks = NumOutstandingNaks;

    if (!IsListEmpty (&NaksList))
    {
        pReceive->pReceiver->LastNakSendTime = PgmDynamicConfig.ReceiversTimerTickCount;
    }

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (pAddress, OldIrq);
    PgmUnlock (&PgmDynamicConfig, *pOldIrq);

    while (!IsListEmpty (&NaksList))
    {
        pNakContext = CONTAINING_RECORD (NaksList.Flink, tNAKS_CONTEXT, Linkage);

        if (pNakContext->NumSequences &&
            !(pReceive->SessionFlags & (PGM_SESSION_FLAG_NAK_TIMED_OUT | PGM_SESSION_TERMINATED_ABORT)))
        {
            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "CheckSendPendingNaks",
                "Sending %s Nak for <%d> sequences, [%d -- %d]!\n",
                    (pNakContext->NakType == NAK_TYPE_PARITY ? "Parity" : "Selective"),
                    pNakContext->NumSequences, (ULONG) pNakContext->Sequences[0],
                    (ULONG) pNakContext->Sequences[MAX_SEQUENCES_PER_NAK_OPTION]);

            PgmSendNak (pReceive, pNakContext);
        }

        RemoveEntryList (&pNakContext->Linkage);
        PgmFreeMem (pNakContext);
    }

    PgmLock (&PgmDynamicConfig, *pOldIrq);
}


//----------------------------------------------------------------------------

VOID
ReceiveTimerTimeout(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
    )
/*++

Routine Description:

    This timeout routine is called periodically to cycle through the
    list of active receivers and send any Naks if required

Arguments:

    IN  Dpc
    IN  DeferredContext -- Our context for this timer
    IN  SystemArg1
    IN  SystemArg2

Return Value:

    NONE

--*/
{
    LIST_ENTRY          *pEntry;
    PGMLockHandle       OldIrq, OldIrq1;
    tRECEIVE_CONTEXT    *pReceiver;
    tRECEIVE_SESSION    *pReceive;
    NTSTATUS            status;
    LARGE_INTEGER       Now, Frequency;
    LARGE_INTEGER       DeltaTime, GranularTimeElapsed;
    ULONG               NumTimeouts;
    ULONG               LastSessionInterval;

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (IsListEmpty (&PgmDynamicConfig.CurrentReceivers))
    {
        //
        // Stop the timer if we don't have any receivers currently
        //
        PgmDynamicConfig.GlobalFlags &= ~PGM_CONFIG_FLAG_RECEIVE_TIMER_RUNNING;
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ReceiveTimerTimeout",
            "Not restarting Timer since no Receivers currently active!\n");

        return;
    }

    Now = KeQueryPerformanceCounter (&Frequency);
    DeltaTime.QuadPart = Now.QuadPart - PgmDynamicConfig.LastReceiverTimeout.QuadPart;
    for (GranularTimeElapsed.QuadPart = 0, NumTimeouts = 0;
         DeltaTime.QuadPart > PgmDynamicConfig.TimeoutGranularity.QuadPart;
         NumTimeouts++)
    {
        GranularTimeElapsed.QuadPart += PgmDynamicConfig.TimeoutGranularity.QuadPart;
        DeltaTime.QuadPart -= PgmDynamicConfig.TimeoutGranularity.QuadPart;
    }

    if (!NumTimeouts)
    {
        PgmInitTimer (&PgmDynamicConfig.SessionTimer);
        PgmStartTimer (&PgmDynamicConfig.SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, ReceiveTimerTimeout, NULL);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return;
    }

    PgmDynamicConfig.ReceiversTimerTickCount += NumTimeouts;
    PgmDynamicConfig.LastReceiverTimeout.QuadPart += GranularTimeElapsed.QuadPart;

    pEntry = &PgmDynamicConfig.CurrentReceivers;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.CurrentReceivers)
    {
        pReceiver = CONTAINING_RECORD (pEntry, tRECEIVE_CONTEXT, Linkage);
        pReceive = pReceiver->pReceive;

        PgmLock (pReceive, OldIrq1);

        LastSessionInterval = (ULONG) (PgmDynamicConfig.ReceiversTimerTickCount -
                                       pReceiver->LastSessionTickCount);
        if ((LastSessionInterval > MAX_SPM_INTERVAL_MSECS/BASIC_TIMER_GRANULARITY_IN_MSECS) &&
            (LastSessionInterval > (pReceiver->MaxSpmInterval << 5)))   // (32 * MaxSpmInterval)
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ReceiveTimerTimeout",
                "Disconnecting session because no SPMs received for <%x:%x> Msecs\n",
                    LastSessionInterval);

            pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
        }

        if (pReceive->SessionFlags & (PGM_SESSION_FLAG_NAK_TIMED_OUT | PGM_SESSION_TERMINATED_ABORT))
        {
            pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            pReceive->SessionFlags &= ~PGM_SESSION_ON_TIMER;
        }

        if (pReceive->SessionFlags & PGM_SESSION_ON_TIMER)
        {
            pReceive->RateCalcTimeout += NumTimeouts;

            if ((pReceive->RateCalcTimeout >=
                 (INTERNAL_RATE_CALCULATION_FREQUENCY/BASIC_TIMER_GRANULARITY_IN_MSECS)) &&
                (pReceiver->StartTickCount != PgmDynamicConfig.ReceiversTimerTickCount))    // Avoid Div by 0
            {
                pReceive->RateKBitsPerSecOverall = (pReceive->TotalBytes << LOG2_BITS_PER_BYTE) /
                                                   ((PgmDynamicConfig.ReceiversTimerTickCount-pReceiver->StartTickCount) * BASIC_TIMER_GRANULARITY_IN_MSECS);

                pReceive->RateKBitsPerSecLast = (pReceive->TotalBytes - pReceive->TotalBytesAtLastInterval) >>
                                                (LOG2_INTERNAL_RATE_CALCULATION_FREQUENCY-LOG2_BITS_PER_BYTE);

                //
                // Now, Reset for next calculations
                //
                pReceive->DataBytesAtLastInterval = pReceive->DataBytes;
                pReceive->TotalBytesAtLastInterval = pReceive->TotalBytes;
                pReceive->RateCalcTimeout = 0;

                //
                // Now, update the window information, if applicable
                //
                if (pReceive->RateKBitsPerSecLast)
                {
                    UpdateSampleTimeWindowInformation (pReceive);
                }
                pReceive->pReceiver->StatSumOfWindowSeqs = pReceive->pReceiver->NumWindowSamples = 0;
//                pReceive->pReceiver->StatSumOfNcfRDataTicks = pReceive->pReceiver->NumNcfRDataTicksSamples = 0;
            }

            PgmUnlock (pReceive, OldIrq1);

            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "ReceiveTimerTimeout",
                "Checking for pending Naks for pReceive=<%p>, Addr=<%x>\n",
                    pReceive, pReceiver->ListenMCastIpAddress);

            CheckSendPendingNaks (pReceiver->pAddress, pReceive, &OldIrq);
        }
        else
        {
            pEntry = pEntry->Blink;
            RemoveEntryList (&pReceiver->Linkage);

            PgmUnlock (&PgmDynamicConfig, OldIrq1);

            CheckIndicateDisconnect (pReceiver->pAddress, pReceive, NULL, &OldIrq1, FALSE);

            PgmUnlock (pReceive, OldIrq);

            PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ReceiveTimerTimeout",
                "PGM_SESSION_ON_TIMER flag cleared for pReceive=<%p>, Addr=<%x>\n",
                    pReceive, pReceiver->ListenMCastIpAddress);

            PGM_DEREFERENCE_ADDRESS (pReceiver->pAddress, REF_ADDRESS_RECEIVE_ACTIVE);
            PGM_DEREFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_TIMER_RUNNING);

            PgmLock (&PgmDynamicConfig, OldIrq);
        }
    }

    PgmInitTimer (&PgmDynamicConfig.SessionTimer);
    PgmStartTimer (&PgmDynamicConfig.SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, ReceiveTimerTimeout, NULL);

    PgmUnlock (&PgmDynamicConfig, OldIrq);
}


//----------------------------------------------------------------------------

NTSTATUS
ExtractNakNcfSequences(
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakNcfPacket,
    IN  ULONG                                   BytesAvailable,
    OUT tNAKS_LIST                              *pNakNcfList,
    IN  UCHAR                                   FECGroupSize
    )
/*++

Routine Description:

    This routine is called to process a Nak/Ncf packet and extract all
    the Sequences specified therein into a list.
    It also verifies that the sequences are unique and sorted

Arguments:

    IN  pNakNcfPacket           -- Nak/Ncf packet
    IN  BytesAvailable          -- PacketLength
    OUT pNakNcfList             -- List of sequences returned on success

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    NTSTATUS        status;
    ULONG           i;
    tPACKET_OPTIONS PacketOptions;
    SEQ_TYPE        LastSequenceNumber;
    SEQ_TYPE        FECSequenceMask = FECGroupSize - 1;
    SEQ_TYPE        FECGroupMask = ~FECSequenceMask;

// Must be called with the Session lock held!

    PgmZeroMemory (pNakNcfList, sizeof (tNAKS_LIST));
    if (pNakNcfPacket->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY)
    {
        pNakNcfList->NakType = NAK_TYPE_PARITY;
    }
    else
    {
        pNakNcfList->NakType = NAK_TYPE_SELECTIVE;
    }

    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));
    if (pNakNcfPacket->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT)
    {
        status = ProcessOptions ((tPACKET_OPTION_LENGTH *) (pNakNcfPacket + 1),
                                 BytesAvailable,
                                 (pNakNcfPacket->CommonHeader.Type & 0x0f),
                                 &PacketOptions,
                                 pNakNcfList);

        if (!NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ExtractNakNcfSequences",
                "ProcessOptions returned <%x>\n", status);

            return (STATUS_DATA_NOT_ACCEPTED);
        }
        ASSERT (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_NAK_LIST);
    }

    pNakNcfList->pNakSequences[0] = (SEQ_TYPE) ntohl (pNakNcfPacket->RequestedSequenceNumber);
    pNakNcfList->NumSequences += 1;

    //
    // Now, adjust the sequences according to our local relative sequence number
    // (This is to account for wrap-arounds)
    //
    LastSequenceNumber = pNakNcfList->pNakSequences[0] - FECGroupSize;
    for (i=0; i < pNakNcfList->NumSequences; i++)
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ExtractNakNcfSequences",
            "[%d] Sequence# = <%d>\n", i, (ULONG) pNakNcfList->pNakSequences[i]);

        //
        // If this is a parity Nak, then we need to separate the TG_SQN from the PKT_SQN
        //
        if (pNakNcfList->NakType == NAK_TYPE_PARITY)
        {
            pNakNcfList->NumNaks[i] = (USHORT) (pNakNcfList->pNakSequences[i] & FECSequenceMask) + 1;
            ASSERT (pNakNcfList->NumNaks[i] <= FECGroupSize);
            pNakNcfList->pNakSequences[i] &= FECGroupMask;
        }
        else
        {
            pNakNcfList->NumNaks[i] = 1;
        }

        if (SEQ_LEQ (pNakNcfList->pNakSequences[i], LastSequenceNumber))
        {
            //
            // This list is not ordered, so just bail!
            //
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ExtractNakNcfSequences",
                "[%d] Unordered list! Sequence#<%d> before <%d>\n",
                i, (ULONG) LastSequenceNumber, (ULONG) pNakNcfList->pNakSequences[i]);

            return (STATUS_DATA_NOT_ACCEPTED);
        }
        LastSequenceNumber = pNakNcfList->pNakSequences[i];
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
CheckAndAddNakRequests(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  SEQ_TYPE            *pLatestSequenceNumber,
    OUT tNAK_FORWARD_DATA   **ppThisNak,
    IN  enum eNAK_TIMEOUT   NakTimeoutType
    )
{
    tNAK_FORWARD_DATA   *pOldNak;
    tNAK_FORWARD_DATA   *pLastNak;
    SEQ_TYPE            MidSequenceNumber;
    SEQ_TYPE            FECGroupMask = pReceive->FECGroupSize-1;
    SEQ_TYPE            ThisSequenceNumber = *pLatestSequenceNumber;
    SEQ_TYPE            ThisGroupSequenceNumber = ThisSequenceNumber & ~FECGroupMask;
    SEQ_TYPE            FurthestGroupSequenceNumber = pReceive->pReceiver->FurthestKnownGroupSequenceNumber;
    ULONG               NakRequestSize = sizeof(tNAK_FORWARD_DATA) +
                                         ((pReceive->FECGroupSize-1) * sizeof(tPENDING_DATA));
    ULONGLONG           Pending0NakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 2;
    LIST_ENTRY          *pEntry;
    UCHAR               i;

    //
    // Verify that the FurthestKnownGroupSequenceNumber is on a Group boundary
    //
    ASSERT (!(FurthestGroupSequenceNumber & FECGroupMask));

    if (SEQ_LT (ThisSequenceNumber, pReceive->pReceiver->FirstNakSequenceNumber))
    {
        if (ppThisNak)
        {
            ASSERT (0);
            *ppThisNak = NULL;
        }

        return (STATUS_SUCCESS);
    }

    if (SEQ_GT (ThisGroupSequenceNumber, (FurthestGroupSequenceNumber + 1000)) &&
        !(pReceive->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET))
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "CheckAndAddNakRequests",
            "WARNING!!! Too many successive packets lost =<%d>!!! Expecting Next=<%d>, FurthestKnown=<%d>, This=<%d>\n",
                (ULONG) (ThisGroupSequenceNumber - FurthestGroupSequenceNumber),
                (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                (ULONG) FurthestGroupSequenceNumber,
                (ULONG) ThisGroupSequenceNumber);
    }

    //
    // Add any Nak requests if necessary!
    // FurthestGroupSequenceNumber must be a multiple of the FECGroupSize (if applicable)
    //
    pLastNak = NULL;
    while (SEQ_LT (FurthestGroupSequenceNumber, ThisGroupSequenceNumber))
    {
        if (pReceive->FECOptions)
        {
            pLastNak = ExAllocateFromNPagedLookasideList (&pReceive->pReceiver->ParityContextLookaside);
        }
        else
        {
            pLastNak = ExAllocateFromNPagedLookasideList (&pReceive->pReceiver->NonParityContextLookaside);
        }

        if (!pLastNak)
        {
            pReceive->pReceiver->FurthestKnownGroupSequenceNumber = FurthestGroupSequenceNumber;

            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "CheckAndAddNakRequests",
                "STATUS_INSUFFICIENT_RESOURCES allocating tNAK_FORWARD_DATA, Size=<%d>, Seq=<%d>\n",
                    NakRequestSize, (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber);

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        PgmZeroMemory (pLastNak, NakRequestSize);

        if (pReceive->FECOptions)
        {
            pLastNak->OriginalGroupSize = pLastNak->PacketsInGroup = pReceive->FECGroupSize;
        }
        else
        {
            pLastNak->OriginalGroupSize = pLastNak->PacketsInGroup = 1;
        }

        for (i=0; i<pLastNak->OriginalGroupSize; i++)
        {
            pLastNak->pPendingData[i].ActualIndexOfDataPacket = pLastNak->OriginalGroupSize;
        }

        FurthestGroupSequenceNumber += pReceive->FECGroupSize;
        pLastNak->SequenceNumber = FurthestGroupSequenceNumber;
        pLastNak->MinPacketLength = pReceive->MaxFECPacketLength;

        if (NakTimeoutType == NAK_OUTSTANDING)
        {
            pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                              pReceive->pReceiver->OutstandingNakTimeout;
            pLastNak->PendingNakTimeout = 0;
            pLastNak->WaitingNcfRetries = 0;
        }
        else
        {
            switch (NakTimeoutType)
            {
                case (NAK_PENDING_0):
                {
                    pLastNak->PendingNakTimeout = Pending0NakTimeout;
                    pLastNak->OutstandingNakTimeout = 0;

                    break;
                }

                case (NAK_PENDING_RB):
                {
                    pLastNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                                  ((NAK_RANDOM_BACKOFF_MSECS/pReceive->FECGroupSize) /
                                                   BASIC_TIMER_GRANULARITY_IN_MSECS);
                    pLastNak->OutstandingNakTimeout = 0;

                    break;
                }

                case (NAK_PENDING_RPT_RB):
                {
                    pLastNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                                  ((NAK_REPEAT_INTERVAL_MSECS +(NAK_RANDOM_BACKOFF_MSECS/pReceive->FECGroupSize))/
                                                   BASIC_TIMER_GRANULARITY_IN_MSECS);
                    pLastNak->OutstandingNakTimeout = 0;

                    break;
                }

                default:
                {
                    ASSERT (0);
                }
            }
        }

        InsertTailList (&pReceive->pReceiver->NaksForwardDataList, &pLastNak->Linkage);
        InsertTailList (&pReceive->pReceiver->PendingNaksList, &pLastNak->PendingLinkage);

        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "CheckAndAddNakRequests",
            "ADDing NAK request for SeqNum=<%d>, Furthest=<%d>\n",
                (ULONG) pLastNak->SequenceNumber, (ULONG) FurthestGroupSequenceNumber);
    }

    pReceive->pReceiver->FurthestKnownGroupSequenceNumber = FurthestGroupSequenceNumber;

    if (pLastNak)
    {
        pLastNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                      NAK_REPEAT_INTERVAL_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS;
    }
    else if ((ppThisNak) && (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList)))
    {
        //
        // We need to extract the Nak entry for this packet
        // If this sequence is nearer to the tail end, we will search
        // from the tail end, otherwise we will search from the head end
        //
        MidSequenceNumber = pReceive->pReceiver->FirstNakSequenceNumber +
                            ((pReceive->pReceiver->FurthestKnownGroupSequenceNumber -
                              pReceive->pReceiver->FirstNakSequenceNumber) >> 1);
        if (SEQ_GT (ThisSequenceNumber, MidSequenceNumber))
        {
            //
            // Search backwards starting from the tail end
            //
            pEntry = &pReceive->pReceiver->PendingNaksList;
            while ((pEntry = pEntry->Blink) != &pReceive->pReceiver->PendingNaksList)
            {
                pLastNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, PendingLinkage);
                if (SEQ_LEQ (pLastNak->SequenceNumber, ThisGroupSequenceNumber))
                {
                    break;
                }
            }
        }
        else
        {
            //
            // Search from the head
            //
            pEntry = &pReceive->pReceiver->PendingNaksList;
            while ((pEntry = pEntry->Flink) != &pReceive->pReceiver->PendingNaksList)
            {
                pLastNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, PendingLinkage);
                if (SEQ_GEQ (pLastNak->SequenceNumber, ThisGroupSequenceNumber))
                {
                    break;
                }
            }
        }

        ASSERT (pLastNak);
        if (pLastNak->SequenceNumber != ThisGroupSequenceNumber)
        {
            pLastNak = NULL;
        }
    }

    if (ppThisNak)
    {
        *ppThisNak = pLastNak;
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
ReceiverProcessNakNcfPacket(
    IN  tADDRESS_CONTEXT                        *pAddress,
    IN  tRECEIVE_SESSION                        *pReceive,
    IN  ULONG                                   PacketLength,
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakNcfPacket,
    IN  UCHAR                                   PacketType
    )
/*++

Routine Description:

    This is the common routine for processing Nak or Ncf packets

Arguments:

    IN  pAddress        -- Address object context
    IN  pReceive        -- Receive context
    IN  PacketLength    -- Length of packet received from the wire
    IN  pNakNcfPacket   -- Nak/Ncf packet
    IN  PacketType      -- whether Nak or Ncf

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    PGMLockHandle                   OldIrq;
    ULONG                           i, j, PacketIndex;
    tNAKS_LIST                      NakNcfList;
    SEQ_TYPE                        LastSequenceNumber, FECGroupMask;
    NTSTATUS                        status;
    LIST_ENTRY                      *pEntry;
    tNAK_FORWARD_DATA               *pLastNak;
    ULONG                           NumMissingPackets;
    BOOLEAN                         fFECWithNoParityNak = FALSE;

    if (PacketLength < sizeof(tBASIC_NAK_NCF_PACKET_HEADER))
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ReceiverProcessNakNcfPacket",
            "PacketLength=<%d>, Min=<%d>, ...\n",
                PacketLength, sizeof(tBASIC_NAK_NCF_PACKET_HEADER));

        return (STATUS_DATA_NOT_ACCEPTED);
    }

    ASSERT (!pNakNcfPacket->CommonHeader.TSDULength);

    PgmZeroMemory (&NakNcfList, sizeof (tNAKS_LIST));
    PgmLock (pReceive, OldIrq);

    status = ExtractNakNcfSequences (pNakNcfPacket,
                                     (PacketLength - sizeof(tBASIC_NAK_NCF_PACKET_HEADER)),
                                     &NakNcfList,
                                     pReceive->FECGroupSize);
    if (!NT_SUCCESS (status))
    {
        PgmUnlock (pReceive, OldIrq);
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ReceiverProcessNakNcfPacket",
            "ExtractNakNcfSequences returned <%x>\n", status);

        return (status);
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "ReceiverProcessNakNcfPacket",
        "NumSequences=[%d] Range=<%d--%d>, Furthest=<%d>\n",
            NakNcfList.NumSequences,
            (ULONG) NakNcfList.pNakSequences[0], (ULONG) NakNcfList.pNakSequences[NakNcfList.NumSequences-1],
            (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber);

    //
    // Compares apples to apples and oranges to oranges
    // i.e. Process parity Naks only if we are parity-aware, and vice-versa
    //
    if (pReceive->pReceiver->SessionNakType != NakNcfList.NakType)
    {
        PgmUnlock (pReceive, OldIrq);
        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ReceiverProcessNakNcfPacket",
            "Received a %s Nak!  Not processing ... \n",
            ((pReceive->FECGroupSize > 1) ? "Non-parity" : "Parity"));

        return (STATUS_SUCCESS);
    }

    //
    // Special case:  If we have FEC enabled, but not with OnDemand parity,
    // then we will process Ncf requests only
    //
    pEntry = &pReceive->pReceiver->PendingNaksList;

    fFECWithNoParityNak = pReceive->FECOptions &&
                          !(pReceive->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT);
    if (fFECWithNoParityNak && (PacketType == PACKET_TYPE_NAK))
    {
        pEntry = pEntry->Blink;
    }

    i = 0;
    FECGroupMask = pReceive->FECGroupSize - 1;
    while ((pEntry = pEntry->Flink) != &pReceive->pReceiver->PendingNaksList)
    {
        pLastNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, PendingLinkage);
        while (SEQ_LT (NakNcfList.pNakSequences[i], pLastNak->SequenceNumber))
        {
            if (++i == NakNcfList.NumSequences)
            {
                PgmUnlock (pReceive, OldIrq);
                PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ReceiverProcessNakNcfPacket",
                    "Received Ncf for <%d> Sequences -- none in our range\n", i);
                return (STATUS_SUCCESS);
            }
        }

        LastSequenceNumber = NakNcfList.pNakSequences[i] & ~FECGroupMask;
        if (SEQ_GT (LastSequenceNumber, pLastNak->SequenceNumber))
        {
            continue;
        }

        NumMissingPackets = pLastNak->PacketsInGroup - (pLastNak->NumDataPackets + pLastNak->NumParityPackets);
        ASSERT (pLastNak->SequenceNumber == LastSequenceNumber);
        ASSERT (NumMissingPackets);
        PacketIndex = (ULONG) (NakNcfList.pNakSequences[i] & FECGroupMask);

        if (PacketType == PACKET_TYPE_NAK)
        {
            //
            // If we are currently waiting for a Nak or Ncf, we need to
            // reset the timeout for either of the 2 scenarios
            //
            if (pLastNak->PendingNakTimeout)    // We are waiting for a Nak
            {
                pLastNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                              ((NAK_REPEAT_INTERVAL_MSECS + (NAK_RANDOM_BACKOFF_MSECS/NumMissingPackets))/
                                               BASIC_TIMER_GRANULARITY_IN_MSECS);
            }
            else
            {
                    ASSERT (pLastNak->OutstandingNakTimeout);

                pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 
                                                  (pReceive->pReceiver->OutstandingNakTimeout <<
                                                   pLastNak->WaitingRDataRetries);

                if ((pLastNak->WaitingRDataRetries >= (NCF_WAITING_RDATA_MAX_RETRIES >> 1)) &&
                    ((pReceive->pReceiver->OutstandingNakTimeout << pLastNak->WaitingRDataRetries) <
                     pReceive->pReceiver->MaxRDataResponseTCFromWindow))
                {
                    pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 
                                                      (pReceive->pReceiver->MaxRDataResponseTCFromWindow<<1);
                }
            }
        }
        // NCF case -- check if we have this data packet!
        else if ((fFECWithNoParityNak &&
                  (pLastNak->pPendingData[PacketIndex].ActualIndexOfDataPacket >= pLastNak->OriginalGroupSize)) ||
                 (!fFECWithNoParityNak &&
                  (NakNcfList.NumNaks[i] >= NumMissingPackets)))
        {
            if (!pLastNak->FirstNcfTickCount)
            {
                pLastNak->FirstNcfTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
            }

            if (fFECWithNoParityNak)
            {
                pLastNak->pPendingData[PacketIndex].NcfsReceivedForActualIndex++;
                for (j=0; j<pLastNak->PacketsInGroup; j++)
                {
                    if ((pLastNak->pPendingData[j].ActualIndexOfDataPacket >= pLastNak->OriginalGroupSize) &&
                        (!pLastNak->pPendingData[j].NcfsReceivedForActualIndex))
                    {
                        break;
                    }
                }
            }

            if (!fFECWithNoParityNak ||
                (j >= pLastNak->PacketsInGroup))
            {
                pLastNak->PendingNakTimeout = 0;
                pLastNak->WaitingNcfRetries = 0;

                pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 
                                                  (pReceive->pReceiver->OutstandingNakTimeout <<
                                                   pLastNak->WaitingRDataRetries);

                if ((pLastNak->WaitingRDataRetries >= (NCF_WAITING_RDATA_MAX_RETRIES >> 1)) &&
                    ((pReceive->pReceiver->OutstandingNakTimeout << pLastNak->WaitingRDataRetries) <
                     pReceive->pReceiver->MaxRDataResponseTCFromWindow))
                {
                    pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 
                                                      (pReceive->pReceiver->MaxRDataResponseTCFromWindow<<1);
                }
            }
        }

        if (fFECWithNoParityNak)
        {
            pEntry = pEntry->Blink;     // There may be more Ncfs for the same group!
        }

        if (++i == NakNcfList.NumSequences)
        {
            PgmUnlock (pReceive, OldIrq);
            PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ReceiverProcessNakNcfPacket",
                "Received Ncf for <%d> Sequences, some in our list\n", i);
            return (STATUS_SUCCESS);
        }
    }

    //
    // So, we need to create new Nak contexts for the remaining Sequences
    // Since the Sequences are ordered, just pick the highest one, and
    // create Naks for all up to that
    //
    if (PacketType == PACKET_TYPE_NAK)
    {
        status = CheckAndAddNakRequests (pReceive,&NakNcfList.pNakSequences[NakNcfList.NumSequences-1], NULL, NAK_PENDING_RPT_RB);
    }
    else    // PacketType == PACKET_TYPE_NCF
    {
        status = CheckAndAddNakRequests (pReceive, &NakNcfList.pNakSequences[NakNcfList.NumSequences-1], NULL, NAK_OUTSTANDING);
    }

    PgmUnlock (pReceive, OldIrq);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
CoalesceSelectiveNaksIntoGroups(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  UCHAR               GroupSize
    )
{
    PNAK_FORWARD_DATA   pOldNak, pNewNak;
    LIST_ENTRY          NewNaksList;
    LIST_ENTRY          OldNaksList;
    LIST_ENTRY          *pEntry;
    SEQ_TYPE            FirstGroupSequenceNumber, LastGroupSequenceNumber, LastSequenceNumber;
    SEQ_TYPE            GroupMask = GroupSize - 1;
    ULONG               NakRequestSize = sizeof(tNAK_FORWARD_DATA) + ((GroupSize-1) * sizeof(tPENDING_DATA));
    USHORT              MinPacketLength;
    UCHAR               i;
    NTSTATUS            status = STATUS_SUCCESS;

    ASSERT (pReceive->FECGroupSize == 1);
    ASSERT (GroupSize > 1);

    //
    // First, call AdjustReceiveBufferLists to ensure that FirstNakSequenceNumber is current
    //
    AdjustReceiveBufferLists (pReceive);

    FirstGroupSequenceNumber = pReceive->pReceiver->FirstNakSequenceNumber & ~GroupMask;
    LastGroupSequenceNumber = pReceive->pReceiver->FurthestKnownGroupSequenceNumber & ~GroupMask;

    //
    // If the next packet seq we are expecting is > the furthest known sequence #,
    // then we don't need to do anything
    //
    LastSequenceNumber = LastGroupSequenceNumber + (GroupSize-1);
    //
    // First, add Nak requests for the missing packets in furthest group!
    //
    status = CheckAndAddNakRequests (pReceive, &LastSequenceNumber, NULL, NAK_PENDING_RB);
    if (!NT_SUCCESS (status))
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "CoalesceSelectiveNaksIntoGroups",
            "CheckAndAddNakRequests returned <%x>\n", status);

        return (status);
    }

    ASSERT (LastSequenceNumber == pReceive->pReceiver->FurthestKnownGroupSequenceNumber);
    ExInitializeNPagedLookasideList (&pReceive->pReceiver->ParityContextLookaside,
                                     NULL,
                                     NULL,
                                     0,
                                     NakRequestSize,
                                     PGM_TAG('2'),
                                     PARITY_CONTEXT_LOOKASIDE_DEPTH);

    if (SEQ_GT (pReceive->pReceiver->FirstNakSequenceNumber, LastSequenceNumber))
    {
        pReceive->pReceiver->FurthestKnownGroupSequenceNumber = LastGroupSequenceNumber;

        ASSERT (IsListEmpty (&pReceive->pReceiver->NaksForwardDataList));

        PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "CoalesceSelectiveNaksIntoGroups",
            "[1] NextOData=<%d>, FirstNak=<%d>, FirstGroup=<%d>, LastGroup=<%d>, no Naks pending!\n",
                (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
                (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                (ULONG) FirstGroupSequenceNumber,
                (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber);

        return (STATUS_SUCCESS);
    }

    //
    // We will start coalescing from the end of the list in case we run
    // into failures
    // Also, we will ignore the first Group since it may be a partial group,
    // or we may have indicated some of the data already, so we may not know
    // the exact data length
    //
    pOldNak = pNewNak = NULL;
    InitializeListHead (&NewNaksList);
    InitializeListHead (&OldNaksList);
    while (SEQ_GEQ (LastGroupSequenceNumber, FirstGroupSequenceNumber))
    {
        if (!(pNewNak = ExAllocateFromNPagedLookasideList (&pReceive->pReceiver->ParityContextLookaside)))
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "CoalesceSelectiveNaksIntoGroups",
                "STATUS_INSUFFICIENT_RESOURCES allocating tNAK_FORWARD_DATA\n");

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        PgmZeroMemory (pNewNak, NakRequestSize);
        InitializeListHead (&pNewNak->PendingLinkage);

        pNewNak->OriginalGroupSize = pNewNak->PacketsInGroup = GroupSize;
        pNewNak->SequenceNumber = LastGroupSequenceNumber;
        MinPacketLength = pReceive->MaxFECPacketLength;

        for (i=0; i<pNewNak->OriginalGroupSize; i++)
        {
            pNewNak->pPendingData[i].ActualIndexOfDataPacket = pNewNak->OriginalGroupSize;
        }

        i = 0;
        while (SEQ_GEQ (LastSequenceNumber, LastGroupSequenceNumber) &&
               (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList)))
        {
            pEntry = RemoveTailList (&pReceive->pReceiver->NaksForwardDataList);
            pOldNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);

            if (!pOldNak->NumDataPackets)
            {
                ASSERT (!IsListEmpty (&pOldNak->PendingLinkage));
                RemoveEntryList (&pOldNak->PendingLinkage);
                InitializeListHead (&pOldNak->PendingLinkage);
            }
            else
            {
                ASSERT (pOldNak->NumDataPackets == 1);
                ASSERT (IsListEmpty (&pOldNak->PendingLinkage));
            }

            ASSERT (pOldNak->SequenceNumber == LastSequenceNumber);
            ASSERT (pOldNak->OriginalGroupSize == 1);

            if (pOldNak->pPendingData[0].pDataPacket)
            {
                ASSERT (pOldNak->NumDataPackets == 1);

                pNewNak->NumDataPackets++;
                PgmCopyMemory (&pNewNak->pPendingData[i], &pOldNak->pPendingData[0], sizeof (tPENDING_DATA));
                pNewNak->pPendingData[i].PacketIndex = (UCHAR) (LastSequenceNumber - LastGroupSequenceNumber);
                pNewNak->pPendingData[LastSequenceNumber-LastGroupSequenceNumber].ActualIndexOfDataPacket = i;
                i++;

                pOldNak->pPendingData[0].pDataPacket = NULL;
                pOldNak->NumDataPackets--;

                if (pOldNak->MinPacketLength < MinPacketLength)
                {
                    MinPacketLength = pOldNak->MinPacketLength;
                }

                if ((pOldNak->ThisGroupSize) &&
                    (pOldNak->ThisGroupSize < GroupSize))
                {
                    if (pNewNak->PacketsInGroup == GroupSize)
                    {
                        pNewNak->PacketsInGroup = pOldNak->ThisGroupSize;
                    }
                    else
                    {
                        ASSERT (pNewNak->PacketsInGroup == pOldNak->ThisGroupSize);
                    }
                }
            }

            InsertHeadList (&OldNaksList, &pOldNak->Linkage);
            LastSequenceNumber--;
        }

        pNewNak->MinPacketLength = MinPacketLength;

        //
        // See if we need to get rid of any excess (NULL) data packets
        //
        RemoveRedundantNaks (pNewNak, FALSE);

        ASSERT (!pNewNak->NumParityPackets);
        if (pNewNak->NumDataPackets < pNewNak->PacketsInGroup)  // No parity packets yet!
        {
            pNewNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                         ((NAK_RANDOM_BACKOFF_MSECS/(pNewNak->PacketsInGroup-pNewNak->NumDataPackets))/
                                          BASIC_TIMER_GRANULARITY_IN_MSECS);
        }

        InsertHeadList (&NewNaksList, &pNewNak->Linkage);
        LastGroupSequenceNumber -= GroupSize;
    }

    //
    // If we succeeded in allocating all NewNaks above, set the
    // NextIndexToIndicate for the first group.
    // We may also need to adjust FirstNakSequenceNumber and NextODataSequenceNumber
    //
    if ((pNewNak) &&
        (pNewNak->SequenceNumber == FirstGroupSequenceNumber))
    {
        if (SEQ_GT (pReceive->pReceiver->FirstNakSequenceNumber, pNewNak->SequenceNumber))
        {
            pNewNak->NextIndexToIndicate = (UCHAR) (pReceive->pReceiver->FirstNakSequenceNumber -
                                                    pNewNak->SequenceNumber);
            pReceive->pReceiver->FirstNakSequenceNumber = pNewNak->SequenceNumber;
            ASSERT (pNewNak->NextIndexToIndicate < GroupSize);
            ASSERT ((pNewNak->NextIndexToIndicate + pNewNak->NumDataPackets) <= pNewNak->PacketsInGroup);
        }
        ASSERT (pReceive->pReceiver->FirstNakSequenceNumber == pNewNak->SequenceNumber);

        //
        // We may have data available for this group already in the buffered
        // list (if it has not been indicated already) -- we should move it here
        //
        while ((pNewNak->NextIndexToIndicate) &&
               (!IsListEmpty (&pReceive->pReceiver->BufferedDataList)))
        {
            ASSERT (pNewNak->NumDataPackets < pNewNak->OriginalGroupSize);

            pEntry = RemoveTailList (&pReceive->pReceiver->BufferedDataList);
            pOldNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);

            pReceive->pReceiver->NumPacketGroupsPendingClient--;
            pReceive->pReceiver->DataPacketsPendingIndicate--;
            pReceive->pReceiver->DataPacketsPendingNaks++;
            pNewNak->NextIndexToIndicate--;

            ASSERT (pOldNak->pPendingData[0].pDataPacket);
            ASSERT ((pOldNak->NumDataPackets == 1) && (pOldNak->OriginalGroupSize == 1));
            ASSERT (pOldNak->SequenceNumber == (pNewNak->SequenceNumber + pNewNak->NextIndexToIndicate));

            PgmCopyMemory (&pNewNak->pPendingData[pNewNak->NumDataPackets], &pOldNak->pPendingData[0], sizeof (tPENDING_DATA));
            pNewNak->pPendingData[pNewNak->NumDataPackets].PacketIndex = pNewNak->NextIndexToIndicate;
            pNewNak->pPendingData[pNewNak->NextIndexToIndicate].ActualIndexOfDataPacket = pNewNak->NumDataPackets;
            pNewNak->NumDataPackets++;

            if (pOldNak->MinPacketLength < pNewNak->MinPacketLength)
            {
                pNewNak->MinPacketLength = pOldNak->MinPacketLength;
            }

            if ((pOldNak->ThisGroupSize) &&
                (pOldNak->ThisGroupSize < GroupSize))
            {
                if (pNewNak->PacketsInGroup == GroupSize)
                {
                    pNewNak->PacketsInGroup = pOldNak->ThisGroupSize;
                }
                else
                {
                    ASSERT (pNewNak->PacketsInGroup == pOldNak->ThisGroupSize);
                }
            }

            pOldNak->pPendingData[0].pDataPacket = NULL;
            pOldNak->NumDataPackets--;
            InsertHeadList (&OldNaksList, &pOldNak->Linkage);
        }

        if (SEQ_GEQ (pReceive->pReceiver->NextODataSequenceNumber, pNewNak->SequenceNumber))
        {
            ASSERT (pReceive->pReceiver->NextODataSequenceNumber ==
                    (pReceive->pReceiver->FirstNakSequenceNumber + pNewNak->NextIndexToIndicate));
            ASSERT (IsListEmpty (&pReceive->pReceiver->BufferedDataList));

            pReceive->pReceiver->NextODataSequenceNumber = pNewNak->SequenceNumber;
        }
        else
        {
            ASSERT ((0 == pNewNak->NextIndexToIndicate) &&
                    !(IsListEmpty (&pReceive->pReceiver->BufferedDataList)));
        }

        if (SEQ_GT (pReceive->pReceiver->LastTrailingEdgeSeqNum, pReceive->pReceiver->FirstNakSequenceNumber))
        {
            pReceive->pReceiver->LastTrailingEdgeSeqNum = pReceive->pReceiver->FirstNakSequenceNumber;
        }

        RemoveRedundantNaks (pNewNak, FALSE);

        if ((pNewNak->NextIndexToIndicate + pNewNak->NumDataPackets) >= pNewNak->PacketsInGroup)
        {
            // This entry will be moved automatically to the buffered data list
            // when we call AdjustReceiveBufferLists below
            pNewNak->PendingNakTimeout = 0;
        }
        else
        {
            pNewNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                         ((NAK_RANDOM_BACKOFF_MSECS/(pNewNak->PacketsInGroup-(pNewNak->NextIndexToIndicate+pNewNak->NumDataPackets)))/
                                          BASIC_TIMER_GRANULARITY_IN_MSECS);
        }
    }

    ASSERT (IsListEmpty (&pReceive->pReceiver->NaksForwardDataList));
    ASSERT (IsListEmpty (&pReceive->pReceiver->PendingNaksList));

    if (!IsListEmpty (&NewNaksList))
    {
        //
        // Now, move the new list to the end of the current list
        //
        NewNaksList.Flink->Blink = pReceive->pReceiver->NaksForwardDataList.Blink;
        NewNaksList.Blink->Flink = &pReceive->pReceiver->NaksForwardDataList;
        pReceive->pReceiver->NaksForwardDataList.Blink->Flink = NewNaksList.Flink;
        pReceive->pReceiver->NaksForwardDataList.Blink = NewNaksList.Blink;
    }

    while (!IsListEmpty (&OldNaksList))
    {
        pEntry = RemoveHeadList (&OldNaksList);
        pOldNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);

        FreeNakContext (pReceive, pOldNak);
    }

    //
    // Put the pending Naks in the PendingNaks list
    //
    pEntry = &pReceive->pReceiver->NaksForwardDataList;
    while ((pEntry = pEntry->Flink) != &pReceive->pReceiver->NaksForwardDataList)
    {
        pNewNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);
        if (((pNewNak->NumDataPackets + pNewNak->NumParityPackets) < pNewNak->PacketsInGroup) &&
            ((pNewNak->NextIndexToIndicate + pNewNak->NumDataPackets) < pNewNak->PacketsInGroup))
        {
            InsertTailList (&pReceive->pReceiver->PendingNaksList, &pNewNak->PendingLinkage);
        }
    }

    AdjustReceiveBufferLists (pReceive);

    //
    // Now, set the FirstKnownGroupSequenceNumber
    //
    pNewNak = NULL;
    if (!(IsListEmpty (&pReceive->pReceiver->NaksForwardDataList)))
    {
        //
        // For the last context, set the Nak timeout appropriately
        //
        pNewNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Blink, tNAK_FORWARD_DATA, Linkage);
        if (pNewNak->NumDataPackets < pNewNak->PacketsInGroup)
        {
            pNewNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                         ((NAK_REPEAT_INTERVAL_MSECS +
                                           (NAK_RANDOM_BACKOFF_MSECS /
                                            (pNewNak->PacketsInGroup-pNewNak->NumDataPackets))) /
                                          BASIC_TIMER_GRANULARITY_IN_MSECS);
        }
    }
    else if (!(IsListEmpty (&pReceive->pReceiver->BufferedDataList)))
    {
        pNewNak = CONTAINING_RECORD (pReceive->pReceiver->BufferedDataList.Blink, tNAK_FORWARD_DATA, Linkage);
    }

    if (pNewNak)
    {
        pReceive->pReceiver->FurthestKnownGroupSequenceNumber = pNewNak->SequenceNumber;
    }
    else
    {
        pReceive->pReceiver->FurthestKnownGroupSequenceNumber &= ~GroupMask;
    }

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "CoalesceSelectiveNaksIntoGroups",
        "[2] NextOData=<%d>, FirstNak=<%d->%d>, FirstGroup=<%d>, LastGroup=<%d>\n",
            (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
            (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
            (pNewNak ? (ULONG) pNewNak->NextIndexToIndicate : (ULONG) 0),
            (ULONG) FirstGroupSequenceNumber,
            (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmIndicateToClient(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tRECEIVE_SESSION    *pReceive,
    IN  ULONG               BytesAvailable,
    IN  PUCHAR              pDataBuffer,
    IN  ULONG               MessageOffset,
    IN  ULONG               MessageLength,
    OUT ULONG               *pBytesTaken,
    IN  PGMLockHandle       *pOldIrqAddress,
    IN  PGMLockHandle       *pOldIrqReceive
    )
/*++

Routine Description:

    This routine tries to indicate the Data packet provided to the client
    It is called with the pAddress and pReceive locks held

Arguments:

    IN  pAddress            -- Address object context
    IN  pReceive            -- Receive context
    IN  BytesAvailableToIndicate        -- Length of packet received from the wire
    IN  pPgmDataHeader      -- Data packet
    IN  pOldIrqAddress      -- OldIrq for the Address lock
    IN  pOldIrqReceive      -- OldIrq for the Receive lock

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    ULONG                       ReceiveFlags;
    ULONG                       BytesLeftInMessage, ClientBytesTaken;
    PIO_STACK_LOCATION          pIrpSp;
    PTDI_REQUEST_KERNEL_RECEIVE pClientParams;
    PTDI_IND_RECEIVE            evReceive = NULL;
    PVOID                       RcvEvContext = NULL;
    CONNECTION_CONTEXT          ClientSessionContext;
    PIRP                        pIrpReceive;
    ULONG                       BytesAvailableToIndicate = BytesAvailable;
    ULONG                       BytesToCopy;

    ASSERT ((!pReceive->pReceiver->CurrentMessageLength) || (pReceive->pReceiver->CurrentMessageLength == MessageLength));
    ASSERT (pReceive->pReceiver->CurrentMessageProcessed == MessageOffset);

    pReceive->pReceiver->CurrentMessageLength = MessageLength;
    pReceive->pReceiver->CurrentMessageProcessed = MessageOffset;

    BytesLeftInMessage = MessageLength - MessageOffset;

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "PgmIndicateToClient",
        "MessageLen=<%d/%d>, MessageOff=<%d>, CurrentML=<%d>, CurrentMP=<%d>\n",
            BytesAvailableToIndicate, MessageLength, MessageOffset,
            pReceive->pReceiver->CurrentMessageLength, pReceive->pReceiver->CurrentMessageProcessed);

    //
    // We may have a receive Irp pending from a previous indication,
    // so see if need to fill that first!
    //
    while ((BytesAvailableToIndicate) &&
           ((pIrpReceive = pReceive->pReceiver->pIrpReceive) ||
            (!IsListEmpty (&pReceive->pReceiver->ReceiveIrpsList))))
    {
        if (!pIrpReceive)
        {
            //
            // The client had posted a receive Irp, so use it now!
            //
            pIrpReceive = CONTAINING_RECORD (pReceive->pReceiver->ReceiveIrpsList.Flink,
                                             IRP, Tail.Overlay.ListEntry);
            RemoveEntryList (&pIrpReceive->Tail.Overlay.ListEntry);

            pIrpSp = IoGetCurrentIrpStackLocation (pIrpReceive);
            pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE) &pIrpSp->Parameters;

            pReceive->pReceiver->pIrpReceive = pIrpReceive;
            pReceive->pReceiver->TotalBytesInMdl = pClientParams->ReceiveLength;
            pReceive->pReceiver->BytesInMdl = 0;
        }

        //
        // Copy whatever bytes we can into it
        //
        if (BytesAvailableToIndicate >
            (pReceive->pReceiver->TotalBytesInMdl - pReceive->pReceiver->BytesInMdl))
        {
            BytesToCopy = pReceive->pReceiver->TotalBytesInMdl - pReceive->pReceiver->BytesInMdl;
        }
        else
        {
            BytesToCopy = BytesAvailableToIndicate;
        }

        ClientBytesTaken = 0;
        status = TdiCopyBufferToMdl (pDataBuffer,
                                     0,
                                     BytesToCopy,
                                     pReceive->pReceiver->pIrpReceive->MdlAddress,
                                     pReceive->pReceiver->BytesInMdl,
                                     &ClientBytesTaken);

        pReceive->pReceiver->BytesInMdl += ClientBytesTaken;
        pReceive->pReceiver->CurrentMessageProcessed += ClientBytesTaken;

        BytesLeftInMessage -= ClientBytesTaken;
        BytesAvailableToIndicate -= ClientBytesTaken;
        pDataBuffer += ClientBytesTaken;

        if ((!ClientBytesTaken) ||
            (pReceive->pReceiver->BytesInMdl >= pReceive->pReceiver->TotalBytesInMdl) ||
            (!BytesLeftInMessage))
        {
            //
            // The Irp is full, so complete the Irp!
            //
            pIrpReceive = pReceive->pReceiver->pIrpReceive;
            pIrpReceive->IoStatus.Information = pReceive->pReceiver->BytesInMdl;
            if (BytesLeftInMessage)
            {
                pIrpReceive->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
            }
            else
            {
                ASSERT (pReceive->pReceiver->CurrentMessageLength == pReceive->pReceiver->CurrentMessageProcessed);
                pIrpReceive->IoStatus.Status = STATUS_SUCCESS;
            }

            //
            // Before releasing the lock, set the parameters for the next receive
            //
            pReceive->pReceiver->pIrpReceive = NULL;
            pReceive->pReceiver->TotalBytesInMdl = pReceive->pReceiver->BytesInMdl = 0;

            PgmUnlock (pReceive, *pOldIrqReceive);
            PgmUnlock (pAddress, *pOldIrqAddress);

            PgmCancelCancelRoutine (pIrpReceive);

            PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "PgmIndicateToClient",
                "Completing prior pIrp=<%p>, Bytes=<%d>, BytesLeft=<%d>\n",
                    pIrpReceive, pIrpReceive->IoStatus.Information, BytesAvailableToIndicate);

            IoCompleteRequest (pIrpReceive, IO_NETWORK_INCREMENT);

            PgmLock (pAddress, *pOldIrqAddress);
            PgmLock (pReceive, *pOldIrqReceive);
        }
    }

    //
    // If there are no more bytes left to indicate, return
    //
    if (BytesAvailableToIndicate == 0)
    {
        if (!BytesLeftInMessage)
        {
            ASSERT (pReceive->pReceiver->CurrentMessageLength == pReceive->pReceiver->CurrentMessageProcessed);
            pReceive->pReceiver->CurrentMessageLength = pReceive->pReceiver->CurrentMessageProcessed = 0;
        }

        *pBytesTaken = BytesAvailable - BytesAvailableToIndicate;
        return (STATUS_SUCCESS);
    }


    // call the Client Event Handler
    pIrpReceive = NULL;
    ClientBytesTaken = 0;
    evReceive = pAddress->evReceive;
    ClientSessionContext = pReceive->ClientSessionContext;
    RcvEvContext = pAddress->RcvEvContext;
    ASSERT (RcvEvContext);

    PgmUnlock (pReceive, *pOldIrqReceive);
    PgmUnlock (pAddress, *pOldIrqAddress);

    ReceiveFlags = TDI_RECEIVE_NORMAL;

    if (PgmGetCurrentIrql())
    {
        ReceiveFlags |= TDI_RECEIVE_AT_DISPATCH_LEVEL;
    }

#if 0
    if (BytesLeftInMessage == BytesAvailableToIndicate)
    {
        ReceiveFlags |= TDI_RECEIVE_ENTIRE_MESSAGE;
    }

    status = (*evReceive) (RcvEvContext,
                           ClientSessionContext,
                           ReceiveFlags,
                           BytesAvailableToIndicate,
                           BytesAvailableToIndicate,
                           &ClientBytesTaken,
                           pDataBuffer,
                           &pIrpReceive);
#else
    ReceiveFlags |= TDI_RECEIVE_ENTIRE_MESSAGE;

    status = (*evReceive) (RcvEvContext,
                           ClientSessionContext,
                           ReceiveFlags,
                           BytesAvailableToIndicate,
                           BytesLeftInMessage,
                           &ClientBytesTaken,
                           pDataBuffer,
                           &pIrpReceive);
#endif  // 0

    PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "PgmIndicateToClient",
        "Client's evReceive returned status=<%x>, ReceiveFlags=<%x>, Client took <%d/%d|%d>, pIrp=<%p>\n",
            status, ReceiveFlags, ClientBytesTaken, BytesAvailableToIndicate, BytesLeftInMessage, pIrpReceive);

    if (ClientBytesTaken > BytesAvailableToIndicate)
    {
        ClientBytesTaken = BytesAvailableToIndicate;
    }

    ASSERT (ClientBytesTaken <= BytesAvailableToIndicate);
    BytesAvailableToIndicate -= ClientBytesTaken;
    BytesLeftInMessage -= ClientBytesTaken;
    pDataBuffer = pDataBuffer + ClientBytesTaken;

    if ((status == STATUS_MORE_PROCESSING_REQUIRED) &&
        (pIrpReceive) &&
        (!NT_SUCCESS (PgmCheckSetCancelRoutine (pIrpReceive, PgmCancelReceiveIrp, FALSE))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmIndicateToClient",
            "pReceive=<%p>, pIrp=<%p> Cancelled during Receive!\n", pReceive, pIrpReceive);

        PgmIoComplete (pIrpReceive, STATUS_CANCELLED, 0);

        PgmLock (pAddress, *pOldIrqAddress);
        PgmLock (pReceive, *pOldIrqReceive);

        pReceive->pReceiver->CurrentMessageProcessed += ClientBytesTaken;

        *pBytesTaken = BytesAvailable - BytesAvailableToIndicate;
        return (STATUS_UNSUCCESSFUL);
    }

    PgmLock (pAddress, *pOldIrqAddress);
    PgmLock (pReceive, *pOldIrqReceive);

    pReceive->pReceiver->CurrentMessageProcessed += ClientBytesTaken;

    if (!pReceive->pReceiver->pAddress)
    {
        // the connection was disassociated in the interim so do nothing.
        if (status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            PgmUnlock (pReceive, *pOldIrqReceive);
            PgmUnlock (pAddress, *pOldIrqAddress);

            PgmIoComplete (pIrpReceive, STATUS_CANCELLED, 0);

            PgmLock (pAddress, *pOldIrqAddress);
            PgmLock (pReceive, *pOldIrqReceive);
        }

        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmIndicateToClient",
            "pReceive=<%p> disassociated during Receive!\n", pReceive);

        *pBytesTaken = BytesAvailable - BytesAvailableToIndicate;
        return (STATUS_UNSUCCESSFUL);
    }

    if (status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        ASSERT (pIrpReceive);
        ASSERT (pIrpReceive->MdlAddress);

        pIrpSp = IoGetCurrentIrpStackLocation (pIrpReceive);
        pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE) &pIrpSp->Parameters;
        ASSERT (pClientParams->ReceiveLength);
        ClientBytesTaken = 0;

        if (pClientParams->ReceiveLength < BytesAvailableToIndicate)
        {
            BytesToCopy = pClientParams->ReceiveLength;
        }
        else
        {
            BytesToCopy = BytesAvailableToIndicate;
        }

        status = TdiCopyBufferToMdl (pDataBuffer,
                                     0,
                                     BytesToCopy,
                                     pIrpReceive->MdlAddress,
                                     pReceive->pReceiver->BytesInMdl,
                                     &ClientBytesTaken);

        BytesLeftInMessage -= ClientBytesTaken;
        BytesAvailableToIndicate -= ClientBytesTaken;
        pDataBuffer = pDataBuffer + ClientBytesTaken;
        pReceive->pReceiver->CurrentMessageProcessed += ClientBytesTaken;

        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "PgmIndicateToClient",
            "Client's evReceive returned pIrp=<%p>, BytesInIrp=<%d>, Copied <%d> bytes\n",
                pIrpReceive, pClientParams->ReceiveLength, ClientBytesTaken);

        if ((!ClientBytesTaken) ||
            (ClientBytesTaken >= pClientParams->ReceiveLength) ||
            (pReceive->pReceiver->CurrentMessageLength == pReceive->pReceiver->CurrentMessageProcessed))
        {
            //
            // The Irp is full, so complete the Irp!
            //
            pIrpReceive->IoStatus.Information = ClientBytesTaken;
            if (pReceive->pReceiver->CurrentMessageLength == pReceive->pReceiver->CurrentMessageProcessed)
            {
                pIrpReceive->IoStatus.Status = STATUS_SUCCESS;
            }
            else
            {
                pIrpReceive->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            // Before releasing the lock, set the parameters for the next receive
            //
            pReceive->pReceiver->TotalBytesInMdl = pReceive->pReceiver->BytesInMdl = 0;

            PgmUnlock (pReceive, *pOldIrqReceive);
            PgmUnlock (pAddress, *pOldIrqAddress);

            PgmCancelCancelRoutine (pIrpReceive);
            IoCompleteRequest (pIrpReceive, IO_NETWORK_INCREMENT);

            PgmLock (pAddress, *pOldIrqAddress);
            PgmLock (pReceive, *pOldIrqReceive);
        }
        else
        {
            pReceive->pReceiver->TotalBytesInMdl = pClientParams->ReceiveLength;
            pReceive->pReceiver->BytesInMdl = ClientBytesTaken;
            pReceive->pReceiver->pIrpReceive = pIrpReceive;
        }

        status = STATUS_SUCCESS;
    }
    else if (status == STATUS_DATA_NOT_ACCEPTED)
    {
        //
        // An Irp could have been posted in the interval
        // between the indicate and acquiring the SpinLocks,
        // so check for that here
        //
        if ((pReceive->pReceiver->pIrpReceive) ||
            (!IsListEmpty (&pReceive->pReceiver->ReceiveIrpsList)))
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            pReceive->SessionFlags |= PGM_SESSION_WAIT_FOR_RECEIVE_IRP;
        }
    }

    if (pReceive->pReceiver->CurrentMessageLength == pReceive->pReceiver->CurrentMessageProcessed)
    {
        pReceive->pReceiver->CurrentMessageLength = pReceive->pReceiver->CurrentMessageProcessed = 0;
    }

    if ((NT_SUCCESS (status)) ||
        (status == STATUS_DATA_NOT_ACCEPTED))
    {
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "PgmIndicateToClient",
            "status=<%x>, pReceive=<%p>, Taken=<%d>, Available=<%d>\n",
                status, pReceive, ClientBytesTaken, BytesLeftInMessage);
        //
        // since some bytes were taken (i.e. the session hdr) so
        // return status success. (otherwise the status is
        // statusNotAccpeted).
        //
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmIndicateToClient",
            "Unexpected status=<%x>\n", status);

        ASSERT (0);
    }

    *pBytesTaken = BytesAvailable - BytesAvailableToIndicate;
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmIndicateGroup(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tRECEIVE_SESSION    *pReceive,
    IN  PGMLockHandle       *pOldIrqAddress,
    IN  PGMLockHandle       *pOldIrqReceive,
    IN  tNAK_FORWARD_DATA   *pNak
    )
{
    UCHAR       i, j;
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       BytesTaken, DataBytes, MessageLength;

    ASSERT (pNak->SequenceNumber == pReceive->pReceiver->NextODataSequenceNumber);

    j = pNak->NextIndexToIndicate;
    while ((j < pNak->PacketsInGroup) &&
            !(pReceive->SessionFlags & PGM_SESSION_DISCONNECT_INDICATED))
    {
        i = pNak->pPendingData[j].ActualIndexOfDataPacket;
        ASSERT (i < pNak->OriginalGroupSize);

        if (pReceive->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET)
        {
            //
            // pReceive->pReceiver->CurrentMessageProcessed would have been set
            // if we were receiving a fragmented message
            // or if we had only accounted for a partial message earlier
            //
            ASSERT (!(pReceive->pReceiver->CurrentMessageProcessed) &&
                    !(pReceive->pReceiver->CurrentMessageLength));

            if (pNak->pPendingData[i].MessageOffset)
            {
                PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "PgmIndicateGroup",
                    "Dropping SeqNum=[%d] since it's a PARTIAL message [%d / %d]!\n",
                        (ULONG) (pReceive->pReceiver->NextODataSequenceNumber + j),
                        pNak->pPendingData[i].MessageOffset, pNak->pPendingData[i].MessageLength);

                j++;
                pNak->NextIndexToIndicate++;
                continue;
            }

            pReceive->SessionFlags &= ~PGM_SESSION_FLAG_FIRST_PACKET;
        }
        else if ((pReceive->pReceiver->CurrentMessageProcessed !=
                        pNak->pPendingData[i].MessageOffset) ||   // Check Offsets
                 ((pReceive->pReceiver->CurrentMessageProcessed) &&         // in the midst of a Message, and
                  (pReceive->pReceiver->CurrentMessageLength !=
                        pNak->pPendingData[i].MessageLength)))  // Check MessageLength
        {
            //
            // Our state expects us to be in the middle of a message, but
            // the current packets do not show this
            //
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmIndicateGroup",
                "SeqNum=[%d] Expecting MsgLen=<%d>, MsgOff=<%d>, have MsgLen=<%d>, MsgOff=<%d>\n",
                    (ULONG) (pReceive->pReceiver->NextODataSequenceNumber + j),
                    pReceive->pReceiver->CurrentMessageLength, pReceive->pReceiver->CurrentMessageProcessed,
                    pNak->pPendingData[i].MessageLength,
                    pNak->pPendingData[i].MessageOffset);

            ASSERT (0);
            return (STATUS_UNSUCCESSFUL);
        }

        DataBytes = pNak->pPendingData[i].PacketLength - pNak->pPendingData[i].DataOffset;
        if (!DataBytes)
        {
            //
            // No need to process empty data packets (can happen if the client
            // picks up partial FEC group)
            //
            j++;
            pNak->NextIndexToIndicate++;
            continue;
        }

        if (DataBytes > (pNak->pPendingData[i].MessageLength - pNak->pPendingData[i].MessageOffset))
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmIndicateGroup",
                "[%d]  DataBytes=<%d> > MsgLen=<%d> - MsgOff=<%d> = <%d>\n",
                    (ULONG) (pReceive->pReceiver->NextODataSequenceNumber + j),
                    DataBytes, pNak->pPendingData[i].MessageLength,
                    pNak->pPendingData[i].MessageOffset,
                    (pNak->pPendingData[i].MessageLength - pNak->pPendingData[i].MessageOffset));

            ASSERT (0);
            return (STATUS_UNSUCCESSFUL);
        }

        BytesTaken = 0;
        status = PgmIndicateToClient (pAddress,
                                      pReceive,
                                      DataBytes,
                                      (pNak->pPendingData[i].pDataPacket + pNak->pPendingData[i].DataOffset),
                                      pNak->pPendingData[i].MessageOffset,
                                      pNak->pPendingData[i].MessageLength,
                                      &BytesTaken,
                                      pOldIrqAddress,
                                      pOldIrqReceive);

        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "PgmIndicateGroup",
            "SeqNum=[%d]: PgmIndicate returned<%x>\n",
                (ULONG) pNak->SequenceNumber, status);

        ASSERT (BytesTaken <= DataBytes);

        pNak->pPendingData[i].MessageOffset += BytesTaken;
        pNak->pPendingData[i].DataOffset += (USHORT) BytesTaken;

        if (BytesTaken == DataBytes)
        {
            //
            // Go to the next packet
            //
            j++;
            pNak->NextIndexToIndicate++;
            pReceive->pReceiver->DataPacketsIndicated++;
            status = STATUS_SUCCESS;
        }
        else if (!NT_SUCCESS (status))
        {
            //
            // We failed, and if the status was STATUS_DATA_NOT_ACCEPTED,
            // we also don't have any ReceiveIrps pending either
            //
            break;
        }
        //
        // else retry indicating this data until we get an error
        //
    }

    //
    // If the status is anything other than STATUS_DATA_NOT_ACCEPTED (whether
    // success or failure), then it means we are done with this data!
    //
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
DecodeParityPackets(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  tNAK_FORWARD_DATA   *pNak
    )
{
    NTSTATUS                    status;
    USHORT                      MinBufferSize;
    USHORT                      DataBytes, FprOffset;
    UCHAR                       i;
    PUCHAR                      pDataBuffer;
    tPOST_PACKET_FEC_CONTEXT    FECContext;

    PgmZeroMemory (&FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));

    //
    // Verify that the our buffer is large enough to hold the data
    //
    ASSERT (pReceive->MaxMTULength > pNak->ParityDataSize);
    MinBufferSize = pNak->ParityDataSize + sizeof(tPOST_PACKET_FEC_CONTEXT) - sizeof(USHORT);

    ASSERT (pNak->PacketsInGroup == pNak->NumDataPackets + pNak->NumParityPackets);
    //
    // Now, copy the data into the DecodeBuffers
    //
    FprOffset = pNak->ParityDataSize - sizeof(USHORT) +
                FIELD_OFFSET (tPOST_PACKET_FEC_CONTEXT, FragmentOptSpecific);
    pDataBuffer = pReceive->pFECBuffer;
    for (i=0; i<pReceive->FECGroupSize; i++)
    {
        //
        // See if this is a NULL buffer (for partial groups!)
        //
        if (i >= pNak->PacketsInGroup)
        {
            ASSERT (!pNak->pPendingData[i].PacketIndex);
            ASSERT (!pNak->pPendingData[i].pDataPacket);
            DataBytes = pNak->ParityDataSize - sizeof(USHORT) + sizeof (tPOST_PACKET_FEC_CONTEXT);
            pNak->pPendingData[i].PacketIndex = i;
            pNak->pPendingData[i].PacketLength = DataBytes;
            pNak->pPendingData[i].DataOffset = 0;

            PgmZeroMemory (pDataBuffer, DataBytes);
            pDataBuffer [FprOffset] = PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT;
            pNak->pPendingData[i].DecodeBuffer = pDataBuffer;
            pDataBuffer += DataBytes;

            PgmZeroMemory (pDataBuffer, DataBytes);
            pNak->pPendingData[i].pDataPacket = pDataBuffer;
            pDataBuffer += DataBytes;

            continue;
        }

        //
        // See if this is a parity packet!
        //
        if (pNak->pPendingData[i].PacketIndex >= pReceive->FECGroupSize)
        {
            DataBytes = pNak->pPendingData[i].PacketLength - pNak->pPendingData[i].DataOffset;
            ASSERT (DataBytes == pNak->ParityDataSize);
            PgmCopyMemory (pDataBuffer,
                           pNak->pPendingData[i].pDataPacket + pNak->pPendingData[i].DataOffset,
                           DataBytes);
            pNak->pPendingData[i].DecodeBuffer = pDataBuffer;

            pDataBuffer += (pNak->ParityDataSize - sizeof(USHORT));
            PgmCopyMemory (&FECContext.EncodedTSDULength, pDataBuffer, sizeof (USHORT));
            FECContext.FragmentOptSpecific = pNak->pPendingData[i].FragmentOptSpecific;
            FECContext.EncodedFragmentOptions.MessageFirstSequence = pNak->pPendingData[i].MessageFirstSequence;
            FECContext.EncodedFragmentOptions.MessageOffset = pNak->pPendingData[i].MessageOffset;
            FECContext.EncodedFragmentOptions.MessageLength = pNak->pPendingData[i].MessageLength;

            PgmCopyMemory (pDataBuffer, &FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));
            pDataBuffer += sizeof (tPOST_PACKET_FEC_CONTEXT);

            continue;
        }

        //
        // This is a Data packet
        //
        ASSERT (pNak->pPendingData[i].PacketIndex < pNak->PacketsInGroup);

        DataBytes = pNak->pPendingData[i].PacketLength - pNak->pPendingData[i].DataOffset;
        ASSERT ((DataBytes+sizeof(USHORT)) <= pNak->ParityDataSize);

        // Copy the data
        PgmCopyMemory (pDataBuffer,
                       pNak->pPendingData[i].pDataPacket + pNak->pPendingData[i].DataOffset,
                       DataBytes);

        //
        // Verify that the Data Buffer length is sufficient for the output data
        //
        if ((pNak->MinPacketLength < MinBufferSize) &&
            (pNak->pPendingData[i].PacketLength < pNak->ParityDataSize))
        {
            if (!(pNak->pPendingData[i].DecodeBuffer = PgmAllocMem (MinBufferSize, PGM_TAG('3'))))
            {
                ASSERT (0);
                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "DecodeParityPackets",
                    "STATUS_INSUFFICIENT_RESOURCES[2] ...\n");

                return (STATUS_INSUFFICIENT_RESOURCES);
            }

            PgmFreeMem (pNak->pPendingData[i].pDataPacket);
            pNak->pPendingData[i].pDataPacket = pNak->pPendingData[i].DecodeBuffer;
        }
        pNak->pPendingData[i].DecodeBuffer = pDataBuffer;

        //
        // Zero the remaining buffer
        //
        PgmZeroMemory ((pDataBuffer + DataBytes), (pNak->ParityDataSize - DataBytes));
        pDataBuffer += (pNak->ParityDataSize - sizeof(USHORT));

        FECContext.EncodedTSDULength = htons (DataBytes);
        FECContext.FragmentOptSpecific = pNak->pPendingData[i].FragmentOptSpecific;
        if (FECContext.FragmentOptSpecific & PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT)
        {
            //
            // This bit is set if the option did not exist in the original packet
            //
            FECContext.EncodedFragmentOptions.MessageFirstSequence = 0;
            FECContext.EncodedFragmentOptions.MessageOffset = 0;
            FECContext.EncodedFragmentOptions.MessageLength = 0;
        }
        else
        {
            FECContext.EncodedFragmentOptions.MessageFirstSequence = htonl (pNak->pPendingData[i].MessageFirstSequence);
            FECContext.EncodedFragmentOptions.MessageOffset = htonl (pNak->pPendingData[i].MessageOffset);
            FECContext.EncodedFragmentOptions.MessageLength = htonl (pNak->pPendingData[i].MessageLength);
        }

        PgmCopyMemory (pDataBuffer, &FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));
        pDataBuffer += sizeof (tPOST_PACKET_FEC_CONTEXT);
    }

    DataBytes = pNak->ParityDataSize - sizeof(USHORT) + sizeof (tPOST_PACKET_FEC_CONTEXT);
    status = FECDecode (&pReceive->FECContext,
                        &(pNak->pPendingData[0]),
                        DataBytes,
                        pNak->PacketsInGroup);

    //
    // Before we do anything else, we should NULL out the dummy DataBuffer
    // ptrs so that they don't get Free'ed accidentally!
    //
    for (i=0; i<pReceive->FECGroupSize; i++)
    {
        pNak->pPendingData[i].DecodeBuffer = NULL;
        if (i >= pNak->PacketsInGroup)
        {
            pNak->pPendingData[i].pDataPacket = NULL;
        }
        pNak->pPendingData[i].ActualIndexOfDataPacket = i;
    }

    if (NT_SUCCESS (status))
    {
        pNak->NumDataPackets = pNak->PacketsInGroup;
        pNak->NumParityPackets = 0;

        DataBytes -= sizeof (tPOST_PACKET_FEC_CONTEXT);
        for (i=0; i<pNak->PacketsInGroup; i++)
        {
            PgmCopyMemory (&FECContext,
                           &(pNak->pPendingData[i].pDataPacket) [DataBytes],
                           sizeof (tPOST_PACKET_FEC_CONTEXT));

            pNak->pPendingData[i].PacketLength = ntohs (FECContext.EncodedTSDULength);
            if (pNak->pPendingData[i].PacketLength > DataBytes)
            {
                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "DecodeParityPackets",
                    "[%d] PacketLength=<%d> > MaxDataBytes=<%d>\n",
                    (ULONG) i, (ULONG) pNak->pPendingData[i].PacketLength, (ULONG) DataBytes);

                ASSERT (0);
                return (STATUS_UNSUCCESSFUL);
            }
            pNak->pPendingData[i].DataOffset = 0;
            pNak->pPendingData[i].PacketIndex = i;

            ASSERT ((pNak->AllOptionsFlags & PGM_OPTION_FLAG_FRAGMENT) ||
                    (!FECContext.EncodedFragmentOptions.MessageLength));

            if (!(pNak->AllOptionsFlags & PGM_OPTION_FLAG_FRAGMENT) ||
                (FECContext.FragmentOptSpecific & PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT))
            {
                //
                // This is not a packet fragment
                //
                pNak->pPendingData[i].MessageFirstSequence = (ULONG) (SEQ_TYPE) (pNak->SequenceNumber + i);
                pNak->pPendingData[i].MessageOffset = 0;
                pNak->pPendingData[i].MessageLength = pNak->pPendingData[i].PacketLength;
            }
            else
            {
                pNak->pPendingData[i].MessageFirstSequence = ntohl (FECContext.EncodedFragmentOptions.MessageFirstSequence);
                pNak->pPendingData[i].MessageOffset = ntohl (FECContext.EncodedFragmentOptions.MessageOffset);
                pNak->pPendingData[i].MessageLength = ntohl (FECContext.EncodedFragmentOptions.MessageLength);
            }
        }
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "DecodeParityPackets",
            "FECDecode returned <%x>\n", status);

        ASSERT (0);
        status = STATUS_UNSUCCESSFUL;
    }

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
CheckIndicatePendedData(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tRECEIVE_SESSION    *pReceive,
    IN  PGMLockHandle       *pOldIrqAddress,
    IN  PGMLockHandle       *pOldIrqReceive
    )
/*++

Routine Description:

    This routine is typically called if the client signalled an
    inability to handle indicated data -- it will reattempt to
    indicate the data to the client

    It is called with the pAddress and pReceive locks held

Arguments:

    IN  pAddress            -- Address object context
    IN  pReceive            -- Receive context
    IN  pOldIrqAddress      -- OldIrq for the Address lock
    IN  pOldIrqReceive      -- OldIrq for the Receive lock

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    tNAK_FORWARD_DATA                   *pNextNak;
    tPACKET_OPTIONS                     PacketOptions;
    ULONG                               PacketsIndicated;
    tBASIC_DATA_PACKET_HEADER UNALIGNED *pPgmDataHeader;
    NTSTATUS                            status = STATUS_SUCCESS;

    //
    // If we are already indicating data on another thread, or
    // waiting for the client to post a receive irp, just return
    //
    if ((pReceive->SessionFlags & (PGM_SESSION_FLAG_IN_INDICATE | PGM_SESSION_WAIT_FOR_RECEIVE_IRP)) ||
        (IsListEmpty (&pReceive->pReceiver->BufferedDataList)))
    {
        return (STATUS_SUCCESS);
    }

    pReceive->SessionFlags |= PGM_SESSION_FLAG_IN_INDICATE;

    pNextNak = CONTAINING_RECORD (pReceive->pReceiver->BufferedDataList.Flink, tNAK_FORWARD_DATA, Linkage);
    ASSERT (pNextNak->SequenceNumber == pReceive->pReceiver->NextODataSequenceNumber);

    do
    {
        //
        // If we do not have all the data packets, we will need to decode them now
        //
        if (pNextNak->NumParityPackets)
        {
            ASSERT ((pNextNak->NumParityPackets + pNextNak->NumDataPackets) == pNextNak->PacketsInGroup);
            status = DecodeParityPackets (pReceive, pNextNak);
        }
        else
        {
            ASSERT ((pNextNak->NextIndexToIndicate + pNextNak->NumDataPackets) >= pNextNak->PacketsInGroup);
            // The above assertion can be greater if we have only partially indicated a group
            status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS (status))
        {
            status = PgmIndicateGroup (pAddress, pReceive, pOldIrqAddress, pOldIrqReceive, pNextNak);
        }
        else
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "CheckIndicatePendedData",
                "DecodeParityPackets returned <%x>\n", status);
        }

        if (!NT_SUCCESS (status))
        {
            //
            // If the client cannot accept any more data at this time, so
            // we will try again later, otherwise terminate this session!
            //
            if (status != STATUS_DATA_NOT_ACCEPTED)
            {
                ASSERT (0);
                pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            }

            break;
        }

        PacketsIndicated = pNextNak->NumDataPackets + pNextNak->NumParityPackets;
        pReceive->pReceiver->TotalDataPacketsBuffered -= PacketsIndicated;
        pReceive->pReceiver->DataPacketsPendingIndicate -= PacketsIndicated;
        pReceive->pReceiver->NumPacketGroupsPendingClient--;
        ASSERT (pReceive->pReceiver->TotalDataPacketsBuffered >= pReceive->pReceiver->NumPacketGroupsPendingClient);

        //
        // Advance to the next group boundary
        //
        pReceive->pReceiver->NextODataSequenceNumber += pNextNak->OriginalGroupSize;

        RemoveEntryList (&pNextNak->Linkage);
        FreeNakContext (pReceive, pNextNak);

        if (IsListEmpty (&pReceive->pReceiver->BufferedDataList))
        {
            break;
        }
        ASSERT (pReceive->pReceiver->NumPacketGroupsPendingClient);

        pNextNak = CONTAINING_RECORD (pReceive->pReceiver->BufferedDataList.Flink, tNAK_FORWARD_DATA, Linkage);
        ASSERT (pNextNak->SequenceNumber == pReceive->pReceiver->NextODataSequenceNumber);
        pReceive->pReceiver->NextODataSequenceNumber = pNextNak->SequenceNumber;

        if (SEQ_LT(pReceive->pReceiver->FirstNakSequenceNumber, pReceive->pReceiver->NextODataSequenceNumber))
        {
            pReceive->pReceiver->FirstNakSequenceNumber = pReceive->pReceiver->NextODataSequenceNumber;
        }
    } while (1);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "CheckIndicatePendedData",
        "status=<%x>, pReceive=<%p>, SessionFlags=<%x>\n",
            status, pReceive, pReceive->SessionFlags);

    pReceive->SessionFlags &= ~PGM_SESSION_FLAG_IN_INDICATE;
    CheckIndicateDisconnect (pAddress, pReceive, pOldIrqAddress, pOldIrqReceive, TRUE);

    return (STATUS_SUCCESS);
}



#ifdef MAX_BUFF_DBG
ULONG   MaxPacketGroupsPendingClient = 0;
ULONG   MaxPacketsBuffered = 0;
ULONG   MaxPacketsPendingIndicate = 0;
ULONG   MaxPacketsPendingNaks = 0;
#endif  // MAX_BUFF_DBG

//----------------------------------------------------------------------------

NTSTATUS
PgmHandleNewData(
    IN  SEQ_TYPE                            *pThisDataSequenceNumber,
    IN  tADDRESS_CONTEXT                    *pAddress,
    IN  tRECEIVE_SESSION                    *pReceive,
    IN  USHORT                              PacketLength,
    IN  tBASIC_DATA_PACKET_HEADER UNALIGNED *pOData,
    IN  UCHAR                               PacketType,
    IN  PGMLockHandle                       *pOldIrqAddress,
    IN  PGMLockHandle                       *pOldIrqReceive
    )
/*++

Routine Description:

    This routine buffers data packets received out-of-order

Arguments:

    IN  pThisDataSequenceNumber -- Sequence # of unordered data packet
    IN  pAddress                -- Address object context
    IN  pReceive                -- Receive context
    IN  PacketLength            -- Length of packet received from the wire
    IN  pODataBuffer            -- Data packet
    IN  PacketType              -- Type of Pgm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    SEQ_TYPE                ThisDataSequenceNumber = *pThisDataSequenceNumber;
    LIST_ENTRY              *pEntry;
    PNAK_FORWARD_DATA       pOldNak, pLastNak = NULL;
    ULONG                   MessageLength, DataOffset, BytesTaken, DataBytes;
    ULONGLONG               NcfRDataTickCounts;
    NTSTATUS                status;
    USHORT                  TSDULength;
    tPACKET_OPTIONS         PacketOptions;
    UCHAR                   i, PacketIndex, NakIndex;
    BOOLEAN                 fIsParityPacket;
    PUCHAR                  pDataBuffer;

    fIsParityPacket = pOData->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY;

    ASSERT (PacketLength <= pReceive->MaxMTULength);

    //
    // Extract all the information that we need from the packet options right now!
    //
    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));
    if (pOData->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT)
    {
        status = ProcessOptions ((tPACKET_OPTION_LENGTH *) (pOData + 1),
                                 (PacketLength - sizeof(tBASIC_DATA_PACKET_HEADER)),
                                 (pOData->CommonHeader.Type & 0x0f),
                                 &PacketOptions,
                                 NULL);

        if (!NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmHandleNewData",
                "ProcessOptions returned <%x>, SeqNum=[%d]: NumOutOfOrder=<%d> ...\n",
                    status, (ULONG) ThisDataSequenceNumber, pReceive->pReceiver->TotalDataPacketsBuffered);

            ASSERT (0);

            pReceive->pReceiver->NumDataPacketsDropped++;
            return (status);
        }
    }

    PgmCopyMemory (&TSDULength, &pOData->CommonHeader.TSDULength, sizeof (USHORT));
    TSDULength = ntohs (TSDULength);
    if (PacketLength != (sizeof(tBASIC_DATA_PACKET_HEADER) + PacketOptions.OptionsLength + TSDULength))
    {
        ASSERT (0);
        pReceive->pReceiver->NumDataPacketsDropped++;
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    DataOffset = sizeof (tBASIC_DATA_PACKET_HEADER) + PacketOptions.OptionsLength;
    DataBytes = TSDULength;

    ASSERT ((PacketOptions.OptionsFlags & ~PGM_VALID_DATA_OPTION_FLAGS) == 0);
    pLastNak = NULL;
    BytesTaken = 0;

    //
    // If we are not parity-enabled, and this is the next expected data packet,
    // we can try to indicate this data over here only
    //
    if ((!pReceive->FECOptions) &&
        ((ULONG) ThisDataSequenceNumber == (ULONG) pReceive->pReceiver->NextODataSequenceNumber) &&
        (IsListEmpty (&pReceive->pReceiver->BufferedDataList)) &&
        (!fIsParityPacket) &&
        !(pReceive->SessionFlags & (PGM_SESSION_FLAG_IN_INDICATE |
                                    PGM_SESSION_WAIT_FOR_RECEIVE_IRP |
                                    PGM_SESSION_DISCONNECT_INDICATED |
                                    PGM_SESSION_TERMINATED_ABORT)))
    {
        ASSERT (!pReceive->pReceiver->NumPacketGroupsPendingClient);
        if (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList))
        {
            pLastNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Flink, tNAK_FORWARD_DATA, Linkage);
            ASSERT ((pLastNak->SequenceNumber == ThisDataSequenceNumber) &&
                    (!pLastNak->pPendingData[0].pDataPacket));
        }

        if (PacketOptions.MessageLength)
        {
            MessageLength = PacketOptions.MessageLength;
            ASSERT (DataBytes <= MessageLength - PacketOptions.MessageOffset);
        }
        else
        {
            MessageLength = DataBytes;
            ASSERT (!PacketOptions.MessageOffset);
        }

        //
        // If we have a NULL packet, then skip it
        //
        if ((!DataBytes) ||
            (PacketOptions.MessageOffset == MessageLength))
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "PgmHandleNewData",
                "Dropping SeqNum=[%d] since it's a NULL message [%d / %d]!\n",
                    (ULONG) (pReceive->pReceiver->NextODataSequenceNumber),
                    PacketOptions.MessageOffset, PacketOptions.MessageLength);

            BytesTaken = DataBytes;
            status = STATUS_SUCCESS;
        }
        //
        // If we are starting receiving in the midst of a message, we should also ignore
        //
        else if ((pReceive->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET) &&
                 (PacketOptions.MessageOffset))
        {
            //
            // pReceive->pReceiver->CurrentMessageProcessed would have been set
            // if we were receiving a fragmented message
            // or if we had only accounted for a partial message earlier
            //
            ASSERT (!(pReceive->pReceiver->CurrentMessageProcessed) &&
                    !(pReceive->pReceiver->CurrentMessageLength));

            PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "PgmHandleNewData",
                "Dropping SeqNum=[%d] since it's a PARTIAL message [%d / %d]!\n",
                    (ULONG) (pReceive->pReceiver->NextODataSequenceNumber),
                    PacketOptions.MessageOffset, PacketOptions.MessageLength);

            BytesTaken = DataBytes;
            status = STATUS_SUCCESS;
        }
        else if ((pReceive->pReceiver->CurrentMessageProcessed != PacketOptions.MessageOffset) ||
                 ((pReceive->pReceiver->CurrentMessageProcessed) &&
                  (pReceive->pReceiver->CurrentMessageLength != PacketOptions.MessageLength)))
        {
            //
            // Our state expects us to be in the middle of a message, but
            // the current packets do not show this
            //
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmHandleNewData",
                "SeqNum=[%d] Expecting MsgLen=<%d>, MsgOff=<%d>, have MsgLen=<%d>, MsgOff=<%d>\n",
                    (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
                    pReceive->pReceiver->CurrentMessageLength,
                    pReceive->pReceiver->CurrentMessageProcessed,
                    PacketOptions.MessageLength, PacketOptions.MessageOffset);
    
            ASSERT (0);
            BytesTaken = DataBytes;
            pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            pReceive->SessionFlags |= PGM_SESSION_FLAG_IN_INDICATE;

            status = PgmIndicateToClient (pAddress,
                                          pReceive,
                                          DataBytes,
                                          (((PUCHAR) pOData) + DataOffset),
                                          PacketOptions.MessageOffset,
                                          MessageLength,
                                          &BytesTaken,
                                          pOldIrqAddress,
                                          pOldIrqReceive);

            pReceive->SessionFlags &= ~(PGM_SESSION_FLAG_IN_INDICATE | PGM_SESSION_FLAG_FIRST_PACKET);
            pReceive->DataBytes += BytesTaken;

            PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "PgmHandleNewData",
                "SeqNum=[%d]: PgmIndicate returned<%x>\n",
                    (ULONG) ThisDataSequenceNumber, status);

            ASSERT (BytesTaken <= DataBytes);

            if (!NT_SUCCESS (status))
            {
                //
                // If the client cannot accept any more data at this time, so
                // we will try again later, otherwise terminate this session!
                //
                if (status != STATUS_DATA_NOT_ACCEPTED)
                {
                    ASSERT (0);
                    pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                    BytesTaken = DataBytes;
                }
            }
        }


        if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_FIN)
        {
            pReceive->pReceiver->FinDataSequenceNumber = ThisDataSequenceNumber;
            pReceive->SessionFlags |= PGM_SESSION_TERMINATED_GRACEFULLY;
        }

        if (BytesTaken == DataBytes)
        {
            if (pLastNak)
            {
                if ((PacketType == PACKET_TYPE_RDATA) &&
                    (pLastNak->FirstNcfTickCount))
                {
                    AdjustNcfRDataResponseTimes (pReceive, pLastNak);
                }

                ASSERT (!IsListEmpty (&pLastNak->PendingLinkage));
                RemoveEntryList (&pLastNak->PendingLinkage);
                InitializeListHead (&pLastNak->PendingLinkage);

                RemoveEntryList (&pLastNak->Linkage);
                FreeNakContext (pReceive, pLastNak);
            }
            else
            {
                pReceive->pReceiver->FurthestKnownGroupSequenceNumber++;
            }

            pReceive->pReceiver->NextODataSequenceNumber++;
            pReceive->pReceiver->FirstNakSequenceNumber = pReceive->pReceiver->NextODataSequenceNumber;
            if (pLastNak)
            {
                //
                // Now, move any Naks contexts for which the group is complete
                // to the BufferedDataList
                //
                AdjustReceiveBufferLists (pReceive);
            }

            return (status);
        }
    }

    //
    // First, ensure we have a Nak context available for this data
    //
    status = CheckAndAddNakRequests (pReceive, &ThisDataSequenceNumber, &pLastNak, NAK_PENDING_RB);
    if ((!NT_SUCCESS (status)) ||
        (!pLastNak))
    {
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "PgmHandleNewData",
            "CheckAndAddNakRequests for <%d> returned <%x>, pLastNak=<%p>\n",
                ThisDataSequenceNumber, status, pLastNak);

        if (NT_SUCCESS (status))
        {
            pReceive->pReceiver->NumDupPacketsBuffered++;
        }
        else
        {
            pReceive->pReceiver->NumDataPacketsDropped++;
        }
        return (status);
    }

    //
    // If this group has a different GroupSize, set that now
    //
    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
    {
        if (!(PacketOptions.FECContext.NumPacketsInThisGroup) ||
             (pReceive->FECOptions &&
              (PacketOptions.FECContext.NumPacketsInThisGroup >= pReceive->FECGroupSize)))
        {
            //
            // Bad Packet!
            //
            ASSERT (0);
            status = STATUS_DATA_NOT_ACCEPTED;
        }
        else if (pLastNak->OriginalGroupSize == 1)
        {
            //
            // This path will be used if we have not yet received
            // an SPM (so don't know group size, etc), but have a
            // data packet from a partial group
            //
            pLastNak->ThisGroupSize = PacketOptions.FECContext.NumPacketsInThisGroup;
        }
        //
        // If we have already received all the data packets, don't do anything here
        //
        else if (pLastNak->PacketsInGroup == pReceive->FECGroupSize)
        {
            pLastNak->PacketsInGroup = PacketOptions.FECContext.NumPacketsInThisGroup;
            //
            // Get rid of any of the excess (NULL) data packets
            //
            RemoveRedundantNaks (pLastNak, TRUE);
        }
        else if (pLastNak->PacketsInGroup != PacketOptions.FECContext.NumPacketsInThisGroup)
        {
            ASSERT (0);
            status = STATUS_DATA_NOT_ACCEPTED;
        }
    }

    if (status == STATUS_DATA_NOT_ACCEPTED)
    {
        pReceive->pReceiver->NumDataPacketsDropped++;
        return (status);
    }

    //
    //
    // See if we even need this packet!
    //
    if (fIsParityPacket)
    {
        //
        // Do not handle parity packets if we are not aware of FEC,
        // or it is a partial group size = 1 packet
        //
        if ((pLastNak->PacketsInGroup == 1) ||    // Do not handle parity packets if we are not aware of FEC
            ((pLastNak->NumDataPackets+pLastNak->NumParityPackets) >= pLastNak->PacketsInGroup) ||
            ((pLastNak->NextIndexToIndicate + pLastNak->NumDataPackets) >= pLastNak->PacketsInGroup))
        {
            pReceive->pReceiver->NumDupPacketsBuffered++;
            status = STATUS_DATA_NOT_ACCEPTED;
        }
        else
        {
            //
            // Determine the ParityPacket Index
            //
            PacketIndex = (UCHAR) (ThisDataSequenceNumber & (pReceive->FECGroupSize-1));
            if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_GRP)
            {
                ASSERT (((pOData->CommonHeader.Type & 0x0f) == PACKET_TYPE_RDATA) ||
                        ((pOData->CommonHeader.Type & 0x0f) == PACKET_TYPE_ODATA));
                ASSERT (PacketOptions.FECContext.FECGroupInfo);
                PacketIndex += ((USHORT) PacketOptions.FECContext.FECGroupInfo * pReceive->FECGroupSize);
            }
        }
    }
    else        // This is a non-parity packet
    {
        PacketIndex = (UCHAR) (ThisDataSequenceNumber & (pReceive->FECGroupSize-1));

        if ((PacketIndex >= pLastNak->PacketsInGroup) ||
            (PacketIndex < pLastNak->NextIndexToIndicate))
        {
            //
            // We don't need this Packet!
            //
            pReceive->pReceiver->NumDupPacketsBuffered++;
            status = STATUS_DATA_NOT_ACCEPTED;
        }
    }

    if (status != STATUS_DATA_NOT_ACCEPTED)
    {
        //
        // Verify that this is not a duplicate of a packet we
        // may have already received
        //
        for (i=0; i < (pLastNak->NumDataPackets+pLastNak->NumParityPackets); i++)
        {
            if (pLastNak->pPendingData[i].PacketIndex == PacketIndex)
            {
                ASSERT (!fIsParityPacket);
                pReceive->pReceiver->NumDupPacketsBuffered++;
                status = STATUS_DATA_NOT_ACCEPTED;
                break;
            }
        }
    }

    if (status == STATUS_DATA_NOT_ACCEPTED)
    {
        AdjustReceiveBufferLists (pReceive);    // In case this became a partial group
        return (status);
    }

#ifdef MAX_BUFF_DBG
{
    if (pReceive->pReceiver->NumPacketGroupsPendingClient > MaxPacketGroupsPendingClient)
    {
        MaxPacketGroupsPendingClient = pReceive->pReceiver->NumPacketGroupsPendingClient;
    }
    if (pReceive->pReceiver->TotalDataPacketsBuffered >= MaxPacketsBuffered)
    {
        MaxPacketsBuffered = pReceive->pReceiver->TotalDataPacketsBuffered;
    }
    if (pReceive->pReceiver->DataPacketsPendingIndicate >= MaxPacketsPendingIndicate)
    {
        MaxPacketsPendingIndicate = pReceive->pReceiver->DataPacketsPendingIndicate;
    }
    if (pReceive->pReceiver->DataPacketsPendingNaks >= MaxPacketsPendingNaks)
    {
        MaxPacketsPendingNaks = pReceive->pReceiver->DataPacketsPendingNaks;
    }
    ASSERT (pReceive->pReceiver->TotalDataPacketsBuffered == (pReceive->pReceiver->DataPacketsPendingIndicate +
                                                              pReceive->pReceiver->DataPacketsPendingNaks));
}
#endif  // MAX_BUFF_DBG

    if (pReceive->pReceiver->TotalDataPacketsBuffered >= MAX_PACKETS_BUFFERED)
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmHandleNewData",
            "[%d]:  Excessive number of packets buffered=<%d> > <%d>, Aborting ...\n",
                (ULONG) ThisDataSequenceNumber,
                (ULONG) pReceive->pReceiver->TotalDataPacketsBuffered,
                (ULONG) MAX_PACKETS_BUFFERED);

        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_FIN)
    {
        pReceive->pReceiver->FinDataSequenceNumber = pLastNak->SequenceNumber + (pLastNak->NumDataPackets - 1);
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_GRACEFULLY;

        PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "PgmHandleNewData",
            "SeqNum=[%d]:  Got a FIN!!!\n", (ULONG) pReceive->pReceiver->FinDataSequenceNumber);
    }

    if ((PacketType == PACKET_TYPE_RDATA) &&
        (pLastNak->FirstNcfTickCount) &&
         (((pLastNak->NumDataPackets + pLastNak->NumParityPackets) >= pLastNak->PacketsInGroup) ||
          ((pLastNak->NextIndexToIndicate + pLastNak->NumDataPackets) >= pLastNak->PacketsInGroup)))
    {
        AdjustNcfRDataResponseTimes (pReceive, pLastNak);
    }

    //
    // First, check if we are a data packet
    // (save unique data packets even if we have extra parity packets)
    // This can help save CPU!
    //
    pDataBuffer = NULL;
    NakIndex = pLastNak->NumDataPackets + pLastNak->NumParityPackets;
    if (!fIsParityPacket)
    {
        ASSERT (PacketIndex < pReceive->FECGroupSize);
        ASSERT (pLastNak->pPendingData[PacketIndex].ActualIndexOfDataPacket == pLastNak->OriginalGroupSize);

        if ((PacketLength + sizeof (tPOST_PACKET_FEC_CONTEXT)) <= pLastNak->MinPacketLength)
        {
            pDataBuffer = PgmAllocMem (pLastNak->MinPacketLength, PGM_TAG('D'));
        }
        else
        {
            pDataBuffer = PgmAllocMem ((PacketLength+sizeof(tPOST_PACKET_FEC_CONTEXT)), PGM_TAG('D'));
        }

        if (!pDataBuffer)
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmHandleNewData",
                "[%d]:  STATUS_INSUFFICIENT_RESOURCES <%d> bytes, NumDataPackets=<%d>, Aborting ...\n",
                    (ULONG) ThisDataSequenceNumber, pLastNak->MinPacketLength,
                    (ULONG) pReceive->pReceiver->TotalDataPacketsBuffered);

            pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        PgmCopyMemory (pDataBuffer, pOData, PacketLength);

        //
        // If we have some un-needed parity packets, we
        // can free that memory now
        //
        if (NakIndex >= pLastNak->PacketsInGroup)
        {
            ASSERT (pLastNak->NumParityPackets);
            for (i=0; i<pLastNak->PacketsInGroup; i++)
            {
                if (pLastNak->pPendingData[i].PacketIndex >= pLastNak->OriginalGroupSize)
                {
                    PgmFreeMem (pLastNak->pPendingData[i].pDataPacket);
                    pLastNak->pPendingData[i].pDataPacket = NULL;
                    pLastNak->pPendingData[i].PacketLength = pLastNak->pPendingData[i].DataOffset = 0;

                    break;
                }
            }
            ASSERT (i < pLastNak->PacketsInGroup);
            pLastNak->NumParityPackets--;
            NakIndex = i;
        }
        ASSERT (!pLastNak->pPendingData[NakIndex].pDataPacket);
        pLastNak->pPendingData[NakIndex].pDataPacket = pDataBuffer;

        pLastNak->pPendingData[NakIndex].PacketLength = PacketLength;
        pLastNak->pPendingData[NakIndex].DataOffset = (USHORT) (DataOffset + BytesTaken);

        pLastNak->pPendingData[NakIndex].PacketIndex = PacketIndex;
        pLastNak->pPendingData[PacketIndex].ActualIndexOfDataPacket = NakIndex;

        pLastNak->NumDataPackets++;
        pReceive->DataBytes += PacketLength - (DataOffset + BytesTaken);

        ASSERT (!(PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_GRP));

        //
        // Save some options for future reference
        //
        if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_FRAGMENT)
        {
            pLastNak->pPendingData[NakIndex].FragmentOptSpecific = 0;
            pLastNak->pPendingData[NakIndex].MessageFirstSequence = PacketOptions.MessageFirstSequence;
            pLastNak->pPendingData[NakIndex].MessageLength = PacketOptions.MessageLength;
            pLastNak->pPendingData[NakIndex].MessageOffset = PacketOptions.MessageOffset + BytesTaken;
        }
        else
        {
            //
            // This is not a fragment
            //
            pLastNak->pPendingData[NakIndex].FragmentOptSpecific = PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT;

            pLastNak->pPendingData[NakIndex].MessageFirstSequence = (ULONG) (SEQ_TYPE) (pLastNak->SequenceNumber + PacketIndex);
            pLastNak->pPendingData[NakIndex].MessageOffset = BytesTaken;
            pLastNak->pPendingData[NakIndex].MessageLength = PacketLength - DataOffset;
        }
    }
    else
    {
        ASSERT (PacketIndex >= pLastNak->OriginalGroupSize);
        ASSERT (NakIndex < pLastNak->PacketsInGroup);
        ASSERT (!pLastNak->pPendingData[NakIndex].pDataPacket);

        pDataBuffer = PgmAllocMem ((PacketLength+sizeof(tPOST_PACKET_FEC_CONTEXT)-sizeof(USHORT)), PGM_TAG('P'));
        if (!pDataBuffer)
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmHandleNewData",
                "[%d -- Parity]:  STATUS_INSUFFICIENT_RESOURCES <%d> bytes, NumDataPackets=<%d>, Aborting ...\n",
                    (ULONG) ThisDataSequenceNumber, PacketLength,
                    (ULONG) pReceive->pReceiver->TotalDataPacketsBuffered);

            pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        pLastNak->pPendingData[NakIndex].pDataPacket = pDataBuffer;

        //
        // This is a new parity packet
        //
        PgmCopyMemory (pDataBuffer, pOData, PacketLength);
        pLastNak->pPendingData[NakIndex].PacketIndex = PacketIndex;
        pLastNak->pPendingData[NakIndex].PacketLength = PacketLength;
        pLastNak->pPendingData[NakIndex].DataOffset = (USHORT) DataOffset;

        pLastNak->pPendingData[NakIndex].FragmentOptSpecific = PacketOptions.FECContext.FragmentOptSpecific;
        pLastNak->pPendingData[NakIndex].MessageFirstSequence = PacketOptions.MessageFirstSequence;
        pLastNak->pPendingData[NakIndex].MessageLength = PacketOptions.MessageLength;
        pLastNak->pPendingData[NakIndex].MessageOffset = PacketOptions.MessageOffset + BytesTaken;

        pLastNak->NumParityPackets++;
        pReceive->DataBytes += PacketLength - DataOffset;

        if (!pLastNak->ParityDataSize)
        {
            pLastNak->ParityDataSize = (USHORT) (PacketLength - DataOffset);
        }
        else
        {
            ASSERT (pLastNak->ParityDataSize == (USHORT) (PacketLength - DataOffset));
        }
    }

    pLastNak->AllOptionsFlags |= PacketOptions.OptionsFlags;

    pReceive->pReceiver->TotalDataPacketsBuffered++;
    pReceive->pReceiver->DataPacketsPendingNaks++;

    //
    // See if this group is complete
    //
    if (((pLastNak->NumDataPackets + pLastNak->NumParityPackets) >= pLastNak->PacketsInGroup) ||
        ((pLastNak->NextIndexToIndicate + pLastNak->NumDataPackets) >= pLastNak->PacketsInGroup))
    {
        ASSERT (!IsListEmpty (&pLastNak->PendingLinkage));

        RemoveEntryList (&pLastNak->PendingLinkage);
        InitializeListHead (&pLastNak->PendingLinkage);

        AdjustReceiveBufferLists (pReceive);
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "PgmHandleNewData",
        "SeqNum=[%d]: NumOutOfOrder=<%d> ...\n",
            (ULONG) ThisDataSequenceNumber, pReceive->pReceiver->TotalDataPacketsBuffered);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
ProcessDataPacket(
    IN  tADDRESS_CONTEXT                    *pAddress,
    IN  tRECEIVE_SESSION                    *pReceive,
    IN  INT                                 SourceAddressLength,
    IN  PVOID                               pSourceAddress,
    IN  ULONG                               PacketLength,
    IN  tBASIC_DATA_PACKET_HEADER UNALIGNED *pODataBuffer,
    IN  UCHAR                               PacketType
    )
/*++

Routine Description:

    This routine looks at the data packet received from the wire
    and handles it appropriately depending on whether it is in order
    or not

Arguments:

    IN  pAddress                -- Address object context
    IN  pReceive                -- Receive context
    IN  SourceAddressLength     -- Length of source address
    IN  pSourceAddress          -- Address of remote host
    IN  PacketLength            -- Length of packet received from the wire
    IN  pODataBuffer            -- Data packet
    IN  PacketType              -- Type of Pgm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    NTSTATUS                    status;
    SEQ_TYPE                    ThisPacketSequenceNumber;
    SEQ_TYPE                    ThisTrailingEdge;
    tNAK_FORWARD_DATA           *pNextNak;
    ULONG                       DisconnectFlag;
    PGMLockHandle               OldIrq, OldIrq1;
    ULONG                       ulData;

    if (PacketLength < sizeof(tBASIC_DATA_PACKET_HEADER))
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessDataPacket",
            "PacketLength=<%d> < tBASIC_DATA_PACKET_HEADER=<%d>\n",
                PacketLength, sizeof(tBASIC_DATA_PACKET_HEADER));
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    PgmLock (pAddress, OldIrq);
    PgmLock (pReceive, OldIrq1);

    PgmCopyMemory (&ulData, &pODataBuffer->DataSequenceNumber, sizeof(ULONG));
    ThisPacketSequenceNumber = (SEQ_TYPE) ntohl (ulData);

    PgmCopyMemory (&ulData, &pODataBuffer->TrailingEdgeSequenceNumber, sizeof(ULONG));
    ThisTrailingEdge = (SEQ_TYPE) ntohl (ulData);

    ASSERT (ntohl (ulData) == (ULONG) ThisTrailingEdge);

    //
    // Update our Window information (use offset from Leading edge to account for wrap-around)
    //
    if (SEQ_GT (ThisTrailingEdge, pReceive->pReceiver->LastTrailingEdgeSeqNum))
    {
        pReceive->pReceiver->LastTrailingEdgeSeqNum = ThisTrailingEdge;
    }

    //
    // If the next packet we are expecting is out-of-range, then we
    // should terminate the session
    //
    if (SEQ_LT (pReceive->pReceiver->FirstNakSequenceNumber, pReceive->pReceiver->LastTrailingEdgeSeqNum))
    {
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
        if (SEQ_GT (pReceive->pReceiver->LastTrailingEdgeSeqNum, (1 + pReceive->pReceiver->FurthestKnownGroupSequenceNumber)))
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ProcessDataPacket",
                "NETWORK problems -- data loss=<%d> packets > window size!\n\tExpecting=<%d>, FurthestKnown=<%d>, Trail=<%d>, Window=[%d--%d] =< %d > seqs\n",
                    (ULONG) (1 + ThisPacketSequenceNumber -
                             pReceive->pReceiver->FurthestKnownGroupSequenceNumber),
                    (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                    (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                    (ULONG) ThisTrailingEdge, (ULONG) ThisPacketSequenceNumber,
                    (ULONG) (1+ThisPacketSequenceNumber-ThisTrailingEdge));
        }
        else
        {
            ASSERT (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList));
            pNextNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Flink, tNAK_FORWARD_DATA, Linkage);

            PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ProcessDataPacket",
                "Session window has past TrailingEdge -- Expecting=<%d==%d>, NumNcfs=<%d>, FurthestKnown=<%d>, Window=[%d--%d] = < %d > seqs\n",
                    (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                    (ULONG) pNextNak->SequenceNumber,
                    pNextNak->WaitingRDataRetries,
                    (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                    (ULONG) pReceive->pReceiver->LastTrailingEdgeSeqNum,
                    (ULONG) ThisTrailingEdge, (ULONG) ThisPacketSequenceNumber,
                    (ULONG) (1+ThisPacketSequenceNumber-ThisTrailingEdge));
        }
    }
    else if (SEQ_GT (pReceive->pReceiver->FirstNakSequenceNumber, ThisPacketSequenceNumber))
    {
        //
        // Drop this packet since it is earlier than our window
        //
        pReceive->pReceiver->NumDupPacketsOlderThanWindow++;

        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessDataPacket",
            "Dropping this packet, SeqNum=[%d] < NextOData=[%d]\n",
                (ULONG) ThisPacketSequenceNumber, (ULONG) pReceive->pReceiver->FirstNakSequenceNumber);
    }
    else
    {
        if (PacketType == PACKET_TYPE_ODATA)
        {
            UpdateRealTimeWindowInformation (pReceive, ThisPacketSequenceNumber, ThisTrailingEdge);
        }

        status = PgmHandleNewData (&ThisPacketSequenceNumber,
                                   pAddress,
                                   pReceive,
                                   (USHORT) PacketLength,
                                   pODataBuffer,
                                   PacketType,
                                   &OldIrq,
                                   &OldIrq1);

        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessDataPacket",
            "PgmHandleNewData returned <%x>, SeqNum=[%d] < NextOData=[%d]\n",
                status, (ULONG) ThisPacketSequenceNumber, (ULONG) pReceive->pReceiver->NextODataSequenceNumber);

        //
        // Now, try to indicate any data which may still be pending
        //
        status = CheckIndicatePendedData (pAddress, pReceive, &OldIrq, &OldIrq1);
    }

    CheckIndicateDisconnect (pAddress, pReceive, &OldIrq, &OldIrq1, TRUE);

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (pAddress, OldIrq);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
ProcessSpmPacket(
    IN  tADDRESS_CONTEXT                    *pAddress,
    IN  tRECEIVE_SESSION                    *pReceive,
    IN  ULONG                               PacketLength,
    IN  tBASIC_SPM_PACKET_HEADER UNALIGNED  *pSpmPacket
    )
/*++

Routine Description:

    This routine processes Spm packets

Arguments:

    IN  pAddress        -- Address object context
    IN  pReceive        -- Receive context
    IN  PacketLength    -- Length of packet received from the wire
    IN  pSpmPacket      -- Spm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    SEQ_TYPE                        SpmSequenceNumber, LeadingEdgeSeqNumber, TrailingEdgeSeqNumber;
    LIST_ENTRY                      *pEntry;
    ULONG                           DisconnectFlag;
    NTSTATUS                        status;
    PGMLockHandle                   OldIrq, OldIrq1;
    tPACKET_OPTIONS                 PacketOptions;
    PNAK_FORWARD_DATA               pNak;
    USHORT                          TSDULength;
    tNLA                            PathNLA;
    BOOLEAN                         fFirstSpm;
    ULONG                           ulData;

    ASSERT (PacketLength >= sizeof(tBASIC_SPM_PACKET_HEADER));

    //
    // First process the options
    //
    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));
    if (pSpmPacket->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT)
    {
        status = ProcessOptions ((tPACKET_OPTION_LENGTH *) (pSpmPacket + 1),
                                 (PacketLength - sizeof(tBASIC_SPM_PACKET_HEADER)),
                                 (pSpmPacket->CommonHeader.Type & 0x0f),
                                 &PacketOptions,
                                 NULL);

        if (!NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessSpmPacket",
                "ProcessOptions returned <%x>\n", status);

            return (STATUS_DATA_NOT_ACCEPTED);
        }
    }
    ASSERT ((PacketOptions.OptionsFlags & ~PGM_VALID_SPM_OPTION_FLAGS) == 0);

    PgmCopyMemory (&PathNLA, &pSpmPacket->PathNLA, sizeof (tNLA));
    PgmCopyMemory (&TSDULength, &pSpmPacket->CommonHeader.TSDULength, sizeof (USHORT));
    TSDULength = ntohs (TSDULength);
    ASSERT (!TSDULength);
    ASSERT (PathNLA.IpAddress);

    PgmCopyMemory (&ulData, &pSpmPacket->SpmSequenceNumber, sizeof (ULONG));
    SpmSequenceNumber = (SEQ_TYPE) ntohl (ulData);
    PgmCopyMemory (&ulData, &pSpmPacket->LeadingEdgeSeqNumber, sizeof (ULONG));
    LeadingEdgeSeqNumber = (SEQ_TYPE) ntohl (ulData);
    PgmCopyMemory (&ulData, &pSpmPacket->TrailingEdgeSeqNumber, sizeof (ULONG));
    TrailingEdgeSeqNumber = (SEQ_TYPE) ntohl (ulData);

    //
    // Verify Packet length
    //
    if ((sizeof(tBASIC_SPM_PACKET_HEADER) + PacketOptions.OptionsLength) != PacketLength)
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessSpmPacket",
            "Bad PacketLength=<%d>, OptionsLength=<%d>, TSDULength=<%d>\n",
                PacketLength, PacketOptions.OptionsLength, (ULONG) TSDULength);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    PgmLock (pAddress, OldIrq);

    if (!pReceive)
    {
        //
        // Since we do not have a live connection yet, we will
        // have to store some state in the Address context
        //
        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessSpmPacket",
            "[%d] Received SPM before OData for session, LastSpmSource=<%x>, FEC %sabled, Window=[%d - %d]\n",
                SpmSequenceNumber, PathNLA.IpAddress,
                (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_PRM ? "EN" : "DIS"),
                (ULONG) TrailingEdgeSeqNumber, (ULONG) LeadingEdgeSeqNumber);

        if ((ntohs (PathNLA.NLA_AFI) == IPV4_NLA_AFI) &&
            (PathNLA.IpAddress))
        {
            pAddress->LastSpmSource = ntohl (PathNLA.IpAddress);
        }

        //
        // Check if the sender is FEC-enabled
        //
        if ((PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_PRM) &&
            (PacketOptions.FECContext.ReceiverFECOptions) &&
            (PacketOptions.FECContext.FECGroupInfo > 1))
        {
            pAddress->FECOptions = PacketOptions.FECContext.ReceiverFECOptions;
            pAddress->FECGroupSize = (UCHAR) PacketOptions.FECContext.FECGroupInfo;
            ASSERT (PacketOptions.FECContext.FECGroupInfo == pAddress->FECGroupSize);
        }

        PgmUnlock (pAddress, OldIrq);
        return (STATUS_SUCCESS);
    }

    PgmLock (pReceive, OldIrq1);
    UpdateSpmIntervalInformation (pReceive);

    //
    // If this is not the first SPM packet (LastSpmSource is not NULL), see if it is out-of-sequence,
    // otherwise take this as the first packet
    //
    if ((pReceive->pReceiver->LastSpmSource) &&
        (SEQ_LEQ (SpmSequenceNumber, pReceive->pReceiver->LastSpmSequenceNumber)))
    {
        PgmUnlock (pReceive, OldIrq1);
        PgmUnlock (pAddress, OldIrq);

        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "ProcessSpmPacket",
            "Out-of-sequence SPM Packet received!\n");

        return (STATUS_DATA_NOT_ACCEPTED);
    }
    pReceive->pReceiver->LastSpmSequenceNumber = SpmSequenceNumber;

    //
    // Save the last Sender NLA
    //
    if ((ntohs(PathNLA.NLA_AFI) == IPV4_NLA_AFI) &&
        (PathNLA.IpAddress))
    {
        pReceive->pReceiver->LastSpmSource = ntohl (PathNLA.IpAddress);
    }
    else
    {
        pReceive->pReceiver->LastSpmSource = pReceive->pReceiver->SenderIpAddress;
    }

    UpdateRealTimeWindowInformation (pReceive, LeadingEdgeSeqNumber, TrailingEdgeSeqNumber);

    //
    // Update the trailing edge if this is more ahead
    //
    if (SEQ_GT (TrailingEdgeSeqNumber, pReceive->pReceiver->LastTrailingEdgeSeqNum))
    {
        pReceive->pReceiver->LastTrailingEdgeSeqNum = TrailingEdgeSeqNumber;
    }

    if (SEQ_GT (pReceive->pReceiver->LastTrailingEdgeSeqNum, pReceive->pReceiver->FirstNakSequenceNumber))
    {
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
        if (SEQ_GT (pReceive->pReceiver->LastTrailingEdgeSeqNum, (1 + pReceive->pReceiver->FurthestKnownGroupSequenceNumber)))
        {
            PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ProcessSpmPacket",
                "NETWORK problems -- data loss=<%d> packets > window size!\n\tExpecting=<%d>, FurthestKnown=<%d>, Window=[%d--%d] = < %d > seqs\n",
                    (ULONG) (1 + LeadingEdgeSeqNumber -
                             pReceive->pReceiver->FurthestKnownGroupSequenceNumber),
                    (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                    (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                    (ULONG) pReceive->pReceiver->LastTrailingEdgeSeqNum, LeadingEdgeSeqNumber,
                    (ULONG) (1+LeadingEdgeSeqNumber-pReceive->pReceiver->LastTrailingEdgeSeqNum));
        }
        else
        {
            ASSERT (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList));
            pNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Flink, tNAK_FORWARD_DATA, Linkage);

            PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ProcessSpmPacket",
                "Session window has past TrailingEdge -- Expecting <%d==%d>, NumNcfs=<%d>, FurthestKnown=<%d>, Window=[%d--%d] = < %d > seqs\n",
                    (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                    (ULONG) pNak->SequenceNumber,
                    pNak->WaitingRDataRetries,
                    (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                    (ULONG) pReceive->pReceiver->LastTrailingEdgeSeqNum, LeadingEdgeSeqNumber,
                    (ULONG) (1+LeadingEdgeSeqNumber-pReceive->pReceiver->LastTrailingEdgeSeqNum));
        }
    }

    //
    // Now, process all the options
    //
    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_RST_N)
    {
        pReceive->pReceiver->FinDataSequenceNumber = pReceive->pReceiver->FurthestKnownGroupSequenceNumber;
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;

        PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ProcessSpmPacket",
            "Got an RST_N!  FinSeq=<%d>, NextODataSeq=<%d>, FurthestData=<%d>\n",
                (ULONG) pReceive->pReceiver->FinDataSequenceNumber,
                (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
                (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber);
    }
    else if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_RST)
    {
        pReceive->pReceiver->FinDataSequenceNumber = LeadingEdgeSeqNumber;
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;

        PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ProcessSpmPacket",
            "Got an RST!  FinSeq=<%d>, NextODataSeq=<%d>, FurthestData=<%d>\n",
                (ULONG) pReceive->pReceiver->FinDataSequenceNumber,
                (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
                (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber);
    }
    else if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_FIN)
    {
        pReceive->pReceiver->FinDataSequenceNumber = LeadingEdgeSeqNumber;
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_GRACEFULLY;

        PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "ProcessSpmPacket",
            "Got a FIN!  FinSeq=<%d>, NextODataSeq=<%d>, FurthestData=<%d>\n",
                (ULONG) pReceive->pReceiver->FinDataSequenceNumber,
                (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
                (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber);
    }

    //
    // See if we need to abort
    //
    if (CheckIndicateDisconnect (pAddress, pReceive, &OldIrq, &OldIrq1, TRUE))
    {
        PgmUnlock (pReceive, OldIrq1);
        PgmUnlock (pAddress, OldIrq);

        return (STATUS_SUCCESS);
    }

    //
    // If the Leading edge is > our current leading edge, then
    // we need to send NAKs for the missing data Packets
    //
    status = CheckAndAddNakRequests (pReceive, &LeadingEdgeSeqNumber, NULL, NAK_PENDING_RB);
    if (!NT_SUCCESS (status))
    {
        PgmUnlock (pReceive, OldIrq1);
        PgmUnlock (pAddress, OldIrq);

        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessSpmPacket",
            "CheckAndAddNakRequests returned <%x>\n", status);

        return (status);
    }

    //
    // Check if the sender is FEC-enabled
    //
    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_PRM)
    {
        if ((pReceive->FECGroupSize == 1) &&
            (PacketOptions.FECContext.ReceiverFECOptions) &&
            (PacketOptions.FECContext.FECGroupInfo > 1))
        {
            ASSERT (!pReceive->pFECBuffer);

            if (!(pReceive->pFECBuffer = PgmAllocMem ((pReceive->MaxFECPacketLength * PacketOptions.FECContext.FECGroupInfo*2), PGM_TAG('3'))))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;

                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessSpmPacket",
                    "STATUS_INSUFFICIENT_RESOURCES -- MaxFECPacketLength = <%d>, GroupSize=<%d>\n",
                        pReceive->MaxFECPacketLength, PacketOptions.FECContext.FECGroupInfo);

            }
            else if (!NT_SUCCESS (status = CreateFECContext (&pReceive->FECContext, PacketOptions.FECContext.FECGroupInfo, FEC_MAX_BLOCK_SIZE, TRUE)))
            {
                PgmFreeMem (pReceive->pFECBuffer);
                pReceive->pFECBuffer = NULL;

                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessSpmPacket",
                    "CreateFECContext returned <%x>\n", status);
            }
            else if (!NT_SUCCESS (status = CoalesceSelectiveNaksIntoGroups (pReceive, (UCHAR) PacketOptions.FECContext.FECGroupInfo)))
            {
                DestroyFECContext (&pReceive->FECContext);

                PgmFreeMem (pReceive->pFECBuffer);
                pReceive->pFECBuffer = NULL;

                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessSpmPacket",
                    "CoalesceSelectiveNaksIntoGroups returned <%x>\n", status);
            }
            else
            {
                pReceive->FECOptions = PacketOptions.FECContext.ReceiverFECOptions;
                pReceive->FECGroupSize = (UCHAR) PacketOptions.FECContext.FECGroupInfo;
                if (pReceive->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT)
                {
                    pReceive->pReceiver->SessionNakType = NAK_TYPE_PARITY;
                }
                ASSERT (PacketOptions.FECContext.FECGroupInfo == pReceive->FECGroupSize);
            }


            if (!NT_SUCCESS (status))
            {
                PgmUnlock (pReceive, OldIrq1);
                PgmUnlock (pAddress, OldIrq);
                return (STATUS_DATA_NOT_ACCEPTED);
            }

            fFirstSpm = TRUE;
        }
        else
        {
            fFirstSpm = FALSE;
        }

        if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
        {
            //
            // The Leading edge Packet belongs to a Variable sized group
            // so set that information appropriately
            // Determine the group to which this leading edge belongs to
            //
            LeadingEdgeSeqNumber &= ~((SEQ_TYPE) (pReceive->FECGroupSize-1));

            if ((PacketOptions.FECContext.NumPacketsInThisGroup) &&
                (PacketOptions.FECContext.NumPacketsInThisGroup < pReceive->FECGroupSize) &&
                SEQ_GEQ (LeadingEdgeSeqNumber, pReceive->pReceiver->FirstNakSequenceNumber))
            {
                //
                // We will proceed backwards from the end since we have a higher
                // probability of finding the leading edge group near the end!
                //
                pEntry = &pReceive->pReceiver->PendingNaksList;
                while ((pEntry = pEntry->Blink) != &pReceive->pReceiver->PendingNaksList)
                {
                    pNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, PendingLinkage);
                    if (SEQ_GT (pNak->SequenceNumber, LeadingEdgeSeqNumber))
                    {
                        continue;
                    }

                    if ((pNak->SequenceNumber == LeadingEdgeSeqNumber) &&
                        (pNak->PacketsInGroup == pReceive->FECGroupSize))
                    {
                        //
                        // We have already coalesced the list, so the packets should
                        // be ordered into groups!
                        //
                        pNak->PacketsInGroup = PacketOptions.FECContext.NumPacketsInThisGroup;
                        RemoveRedundantNaks (pNak, TRUE);
                    }

                    break;
                }
            }
            else
            {
                PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "ProcessSpmPacket",
                    "WARNING .. PARITY_CUR_TGSIZE ThisGroupSize=<%x>, FECGroupSize=<%x>\n",
                        PacketOptions.FECContext.NumPacketsInThisGroup, pReceive->FECGroupSize);
            }
        }

        if (fFirstSpm)
        {
            status = CheckIndicatePendedData (pAddress, pReceive, &OldIrq, &OldIrq1);
        }
    }

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (pAddress, OldIrq);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "ProcessSpmPacket",
        "NextOData=<%d>, FinDataSeq=<%d> \n",
            (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
            (ULONG) pReceive->pReceiver->FinDataSequenceNumber);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmProcessIncomingPacket(
    IN  tADDRESS_CONTEXT            *pAddress,
    IN  tCOMMON_SESSION_CONTEXT     *pSession,
    IN  INT                         SourceAddressLength,
    IN  PVOID                       pSourceAddress,
    IN  ULONG                       PacketLength,
    IN  tCOMMON_HEADER UNALIGNED    *pPgmHeader,
    IN  UCHAR                       PacketType
    )
/*++

Routine Description:

    This routine process an incoming packet and calls the
    appropriate handler depending on whether is a data packet
    packet, etc.

Arguments:

    IN  pAddress            -- Address object context
    IN  pReceive            -- Receive context
    IN  SourceAddressLength -- Length of source address
    IN  pSourceAddress      -- Address of remote host
    IN  PacketLength        -- Length of packet received from the wire
    IN  pPgmHeader          -- Pgm packet
    IN  PacketType          -- Type of Pgm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    tIPADDRESS      SrcIpAddress;
    TA_IP_ADDRESS   *pRemoteAddress = (PTA_IP_ADDRESS) pSourceAddress;

    //
    // We have an active connection for this TSI, so process the data appropriately
    //
    switch (PacketType)
    {
        case (PACKET_TYPE_SPM):
        {
            if (PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_RECEIVE))
            {
                pSession->TotalBytes += PacketLength;
                pSession->TotalPacketsInLastInterval++;
                pSession->pReceiver->LastSessionTickCount = PgmDynamicConfig.ReceiversTimerTickCount;

                status = ProcessSpmPacket (pAddress,
                                           pSession,
                                           PacketLength,
                                           (tBASIC_SPM_PACKET_HEADER UNALIGNED *) pPgmHeader);
            }
            else
            {
                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmProcessIncomingPacket",
                    "Received SPM packet, not on Receiver session!  pSession=<%p>\n", pSession);
                status = STATUS_DATA_NOT_ACCEPTED;
            }

            break;
        }

        case (PACKET_TYPE_ODATA):
        case (PACKET_TYPE_RDATA):
        {
            if (PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_RECEIVE))
            {
                if (PacketType == PACKET_TYPE_ODATA)
                {
                    pSession->pReceiver->NumODataPacketsReceived++;
                    pSession->pReceiver->LastSessionTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
                }
                else
                {
                    pSession->pReceiver->NumRDataPacketsReceived++;
                }
                pSession->TotalBytes += PacketLength;
                pSession->TotalPacketsInLastInterval++;
                status = ProcessDataPacket (pAddress,
                                            pSession,
                                            SourceAddressLength,
                                            pSourceAddress,
                                            PacketLength,
                                            (tBASIC_DATA_PACKET_HEADER UNALIGNED *) pPgmHeader,
                                            PacketType);
            }
            else
            {
                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmProcessIncomingPacket",
                    "Received Data packet, not on Receiver session!  pSession=<%p>\n", pSession);
                status = STATUS_DATA_NOT_ACCEPTED;
            }

            break;
        }

        case (PACKET_TYPE_NCF):
        {
            if (PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_RECEIVE))
            {
                status = ReceiverProcessNakNcfPacket (pAddress,
                                                      pSession,
                                                      PacketLength,
                                                      (tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED *) pPgmHeader,
                                                      PacketType);
            }
            else
            {
                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmProcessIncomingPacket",
                    "Received Ncf packet, not on Receiver session!  pSession=<%p>\n", pSession);
                status = STATUS_DATA_NOT_ACCEPTED;
            }

            break;
        }

        case (PACKET_TYPE_NAK):
        {
            if (pSession->pSender)
            {
                ASSERT (!pSession->pReceiver);
                status = SenderProcessNakPacket (pAddress,
                                                 pSession,
                                                 PacketLength,
                                                 (tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED *) pPgmHeader);
            }
            else
            {
                ASSERT (pSession->pReceiver);

                //
                // If the Nak was sent by us, then we can ignore it!
                //
                SrcIpAddress = ntohl (((PTDI_ADDRESS_IP) &pRemoteAddress->Address[0].Address)->in_addr);
                if (!SrcIsUs (SrcIpAddress))
                {
                    status = ReceiverProcessNakNcfPacket (pAddress,
                                                          pSession,
                                                          PacketLength,
                                                          (tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED*)pPgmHeader,
                                                          PacketType);
                }

                ASSERT (NT_SUCCESS (status));
            }

            break;
        }

        default:
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmProcessIncomingPacket",
                "Unknown PacketType=<%x>, PacketLength=<%d>\n", PacketType, PacketLength);

            ASSERT (0);
            return (STATUS_DATA_NOT_ACCEPTED);
        }
    }

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "PgmProcessIncomingPacket",
        "PacketType=<%x> for pSession=<%p> PacketLength=<%d>, status=<%x>\n",
            PacketType, pSession, PacketLength, status);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmNewInboundConnection(
    IN tADDRESS_CONTEXT                     *pAddress,
    IN INT                                  SourceAddressLength,
    IN PVOID                                pSourceAddress,
    IN ULONG                                ReceiveDatagramFlags,
    IN  tBASIC_DATA_PACKET_HEADER UNALIGNED *pPgmHeader,
    IN ULONG                                PacketLength,
    OUT tRECEIVE_SESSION                    **ppReceive
    )
/*++

Routine Description:

    This routine processes a new incoming connection

Arguments:

    IN  pAddress            -- Address object context
    IN  SourceAddressLength -- Length of source address
    IN  pSourceAddress      -- Address of remote host
    IN  ReceiveDatagramFlags-- Flags set by the transport for this packet
    IN  pPgmHeader          -- Pgm packet
    IN  PacketLength        -- Length of packet received from the wire
    OUT ppReceive           -- pReceive context for this session returned by the client (if successful)

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    NTSTATUS                    status;
    tRECEIVE_SESSION            *pReceive;
    CONNECTION_CONTEXT          ConnectId;
    PIO_STACK_LOCATION          pIrpSp;
    TA_IP_ADDRESS               RemoteAddress;
    INT                         RemoteAddressSize;
    PTDI_IND_CONNECT            evConnect = NULL;
    PVOID                       ConEvContext = NULL;
    PGMLockHandle               OldIrq, OldIrq1, OldIrq2;
    PIRP                        pIrp = NULL;
    ULONG                       ulData;
    USHORT                      PortNum;
    SEQ_TYPE                    FirstODataSequenceNumber;
    tPACKET_OPTIONS             PacketOptions;
    LARGE_INTEGER               Frequency;

    //
    // We need to set the Next expected sequence number, so first see if
    // there is a late joiner option
    //
    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));
    if (pPgmHeader->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT)
    {
        status = ProcessOptions ((tPACKET_OPTION_LENGTH *) (pPgmHeader + 1),
                                 (PacketLength - sizeof(tBASIC_DATA_PACKET_HEADER)),
                                 (pPgmHeader->CommonHeader.Type & 0x0f),
                                 &PacketOptions,
                                 NULL);

        if (!NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmNewInboundConnection",
                "ProcessOptions returned <%x>\n", status);
            return (STATUS_DATA_NOT_ACCEPTED);
        }
        ASSERT ((PacketOptions.OptionsFlags & ~PGM_VALID_DATA_OPTION_FLAGS) == 0);
    }

    PgmCopyMemory (&ulData, &pPgmHeader->DataSequenceNumber, sizeof (ULONG));
    FirstODataSequenceNumber = (SEQ_TYPE) ntohl (ulData);
    PgmLock (pAddress, OldIrq1);
    //
    // The Address is already referenced in the calling routine,
    // so we don not need to reference it here again!
    //
#if 0
    if (!IsListEmpty(&pAddress->ListenHead))
    {
        //
        // Ignore this for now  since we have not encountered posted listens! (Is this an ISSUE ?)
    }
#endif  // 0

    if (!(ConEvContext = pAddress->ConEvContext))
    {
        //
        // Client has not yet posted a Listen!
        // take all of the data so that a disconnect will not be held up
        // by data still in the transport.
        //
        PgmUnlock (pAddress, OldIrq1);

        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmNewInboundConnection",
            "No Connect handler, pAddress=<%p>\n", pAddress);

        return (STATUS_DATA_NOT_ACCEPTED);
    }

    RemoteAddressSize = offsetof (TA_IP_ADDRESS, Address[0].Address) + sizeof(TDI_ADDRESS_IP);
    ASSERT (SourceAddressLength <= RemoteAddressSize);
    PgmCopyMemory (&RemoteAddress, pSourceAddress, RemoteAddressSize);
    PgmCopyMemory (&((PTDI_ADDRESS_IP) &RemoteAddress.Address[0].Address)->sin_port,
                   &pPgmHeader->CommonHeader.SrcPort, sizeof (USHORT));
    RemoteAddress.TAAddressCount = 1;
    evConnect = pAddress->evConnect;

    PgmUnlock (pAddress, OldIrq1);

    status = (*evConnect) (ConEvContext,
                           RemoteAddressSize,
                           &RemoteAddress,
                           0,
                           NULL,
                           0,          // options length
                           NULL,       // Options
                           &ConnectId,
                           &pIrp);

    if ((status != STATUS_MORE_PROCESSING_REQUIRED) ||
        (pIrp == NULL))
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "PgmNewInboundConnection",
            "Client REJECTed incoming session: status=<%x>, pAddress=<%p>, evConn=<%p>\n",
                status, pAddress, pAddress->evConnect);

        *ppReceive = NULL;
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);
    PgmLock (pAddress, OldIrq1);

    //
    // the pReceive ptr was stored in the FsContext value when the connection
    // was initially created.
    //
    pIrpSp = IoGetCurrentIrpStackLocation (pIrp);
    pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    if ((!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE)) ||
        (pReceive->pAssociatedAddress != pAddress))
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmNewInboundConnection",
            "Invalid Connection Handle=<%p>\n", pReceive);

        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        *ppReceive = NULL;
        return (STATUS_INTERNAL_ERROR);
    }
    ASSERT (ConnectId == pReceive->ClientSessionContext);

    PgmLock (pReceive, OldIrq2);

    pReceive->pReceiver->SenderIpAddress = ntohl (((PTDI_ADDRESS_IP)&RemoteAddress.Address[0].Address)->in_addr);
    pReceive->MaxMTULength = (USHORT) PgmDynamicConfig.MaxMTU;
    pReceive->MaxFECPacketLength = pReceive->MaxMTULength +
                                   sizeof (tPOST_PACKET_FEC_CONTEXT) - sizeof (USHORT);
    ASSERT (!pReceive->pFECBuffer);

    //
    // If we had received an Spm earlier, then we may need to set
    // some of the Spm-specific options
    //
    pReceive->FECGroupSize = 1;         // Default to non-parity mode
    pReceive->pReceiver->SessionNakType = NAK_TYPE_SELECTIVE;
    if ((pAddress->LastSpmSource) ||
        (pAddress->FECOptions))
    {
        if (pAddress->LastSpmSource)
        {
            pReceive->pReceiver->LastSpmSource = pAddress->LastSpmSource;
        }
        else
        {
            pReceive->pReceiver->LastSpmSource = pReceive->pReceiver->SenderIpAddress;
        }

        if (pAddress->FECOptions)
        {
            if (!(pReceive->pFECBuffer = PgmAllocMem ((pReceive->MaxFECPacketLength * pAddress->FECGroupSize * 2), PGM_TAG('3'))))
            {
                PgmUnlock (pReceive, OldIrq2);
                PgmUnlock (pAddress, OldIrq1);
                PgmUnlock (&PgmDynamicConfig, OldIrq);
                *ppReceive = NULL;

                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmNewInboundConnection",
                    "STATUS_INSUFFICIENT_RESOURCES allocating pFECBuffer, %d bytes\n",
                        (pReceive->MaxFECPacketLength * pAddress->FECGroupSize * 2));

                return (STATUS_INSUFFICIENT_RESOURCES);
            }
            else if (!NT_SUCCESS (status = CreateFECContext (&pReceive->FECContext, pAddress->FECGroupSize, FEC_MAX_BLOCK_SIZE, TRUE)))
            {
                PgmFreeMem (pReceive->pFECBuffer);
                pReceive->pFECBuffer = NULL;

                PgmUnlock (pReceive, OldIrq2);
                PgmUnlock (pAddress, OldIrq1);
                PgmUnlock (&PgmDynamicConfig, OldIrq);
                *ppReceive = NULL;

                PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "PgmNewInboundConnection",
                    "CreateFECContext returned <%x>\n", status);

                return (status);
            }

            ASSERT (pAddress->FECGroupSize > 1);
            pReceive->FECGroupSize = pAddress->FECGroupSize;
            pReceive->FECOptions = pAddress->FECOptions;
            if (pReceive->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT)
            {
                pReceive->pReceiver->SessionNakType = NAK_TYPE_PARITY;
            }

            ExInitializeNPagedLookasideList (&pReceive->pReceiver->ParityContextLookaside,
                                             NULL,
                                             NULL,
                                             0,
                                             (sizeof(tNAK_FORWARD_DATA) +
                                              ((pReceive->FECGroupSize-1) * sizeof(tPENDING_DATA))),
                                             PGM_TAG('2'),
                                             PARITY_CONTEXT_LOOKASIDE_DEPTH);
        }

        pAddress->LastSpmSource = pAddress->FECOptions = pAddress->FECGroupSize = 0;
    }

    //
    // Initialize our Connect info
    // Save the SourceId and Src port for this connection
    //
    PgmCopyMemory (pReceive->GSI, pPgmHeader->CommonHeader.gSourceId, SOURCE_ID_LENGTH);
    PgmCopyMemory (&PortNum, &pPgmHeader->CommonHeader.SrcPort, sizeof (USHORT));
    pReceive->TSIPort = ntohs (PortNum);

    PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_TDI_RCV_HANDLER, TRUE);
    PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_TIMER_RUNNING, TRUE);

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_RECEIVE_ACTIVE, TRUE);
    pReceive->SessionFlags |= (PGM_SESSION_ON_TIMER | PGM_SESSION_FLAG_FIRST_PACKET);
    pReceive->pReceiver->pAddress = pAddress;

    ExInitializeNPagedLookasideList (&pReceive->pReceiver->NonParityContextLookaside,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof (tNAK_FORWARD_DATA),
                                     PGM_TAG ('2'),
                                     NON_PARITY_CONTEXT_LOOKASIDE_DEPTH);
    //
    // Set the NextODataSequenceNumber and FurthestKnownGroupSequenceNumber based
    // on this packet's Sequence # and the lateJoin option (if present)
    // Make sure all of the Sequence numbers are on group boundaries (if not,
    // set them at the start of the next group)
    //
    FirstODataSequenceNumber &= ~((SEQ_TYPE) pReceive->FECGroupSize - 1);
    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_JOIN)
    {
        PacketOptions.LateJoinerSequence += (pReceive->FECGroupSize - 1);
        PacketOptions.LateJoinerSequence &= ~((SEQ_TYPE) pReceive->FECGroupSize - 1);

        pReceive->pReceiver->NextODataSequenceNumber = (SEQ_TYPE) PacketOptions.LateJoinerSequence;
    }
    else
    {
        //
        // There is no late joiner option
        //
        pReceive->pReceiver->NextODataSequenceNumber = FirstODataSequenceNumber;
    }
    pReceive->pReceiver->LastTrailingEdgeSeqNum = pReceive->pReceiver->FirstNakSequenceNumber =
                                            pReceive->pReceiver->NextODataSequenceNumber;
    pReceive->pReceiver->OutstandingNakTimeout = INITIAL_NAK_OUTSTANDING_TIMEOUT_MSECS/BASIC_TIMER_GRANULARITY_IN_MSECS;
    pReceive->pReceiver->MaxOutstandingNakTimeout = pReceive->pReceiver->OutstandingNakTimeout;

    //
    // Set the FurthestKnown Sequence # and Allocate Nak contexts
    //
    pReceive->pReceiver->FurthestKnownGroupSequenceNumber = (pReceive->pReceiver->NextODataSequenceNumber-
                                                             pReceive->FECGroupSize) &
                                                            ~((SEQ_TYPE) pReceive->FECGroupSize - 1);

    //
    // Since this is the first receive for this session, see if we need to
    // start the receive timer
    //
    KeQueryPerformanceCounter (&Frequency);
    PgmDynamicConfig.TimeoutGranularity.QuadPart =  (Frequency.QuadPart * BASIC_TIMER_GRANULARITY_IN_MSECS) / 1000;
    InsertTailList (&PgmDynamicConfig.CurrentReceivers, &pReceive->pReceiver->Linkage);
    if (!(PgmDynamicConfig.GlobalFlags & PGM_CONFIG_FLAG_RECEIVE_TIMER_RUNNING))
    {
        PgmDynamicConfig.GlobalFlags |= PGM_CONFIG_FLAG_RECEIVE_TIMER_RUNNING;
        PgmDynamicConfig.LastReceiverTimeout = KeQueryPerformanceCounter (NULL);
        pReceive->pReceiver->StartTickCount = PgmDynamicConfig.ReceiversTimerTickCount = 1;

        PgmInitTimer (&PgmDynamicConfig.SessionTimer);
        PgmStartTimer (&PgmDynamicConfig.SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, ReceiveTimerTimeout, NULL);
    }
    else
    {
        pReceive->pReceiver->StartTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
    }
    CheckAndAddNakRequests (pReceive, &FirstODataSequenceNumber, NULL, NAK_PENDING_0);

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_RECEIVE, "PgmNewInboundConnection",
        "New incoming connection, pAddress=<%p>, pReceive=<%p>, ThisSeq=<%d==>%d> (%sparity), StartSeq=<%d>\n",
            pAddress, pReceive, ntohl(ulData), (ULONG) FirstODataSequenceNumber,
            (pPgmHeader->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY ? "" : "non-"),
            (ULONG) pReceive->pReceiver->NextODataSequenceNumber);

    PgmUnlock (pReceive, OldIrq2);
    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    //
    // We are ready to proceed!  So, complete the client's Accept Irp
    //
    PgmIoComplete (pIrp, STATUS_SUCCESS, 0);

    //
    // If we had failed, we would already have returned before now!
    //
    *ppReceive = pReceive;
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
ProcessReceiveCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
    )
/*++

Routine Description:

    This routine handles the case when a datagram is too
    short and and Irp has to be passed back to the transport to get the
    rest of the datagram.  The irp completes through here when full.

Arguments:

    IN  DeviceObject - unused.
    IN  Irp - Supplies Irp that the transport has finished processing.
    IN  Context - Supplies the pReceive - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    NTSTATUS                status;
    PIRP                    pIoRequestPacket;
    ULONG                   BytesTaken;
    tRCV_COMPLETE_CONTEXT   *pRcvContext = (tRCV_COMPLETE_CONTEXT *) Context;
    ULONG                   Offset = pRcvContext->BytesAvailable;
    PVOID                   pBuffer;
    ULONG                   SrcAddressLength;
    PVOID                   pSrcAddress;

    if (pBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))
    {
        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "ProcessReceiveCompletionRoutine",
            "pIrp=<%p>, pRcvBuffer=<%p>, Status=<%x> Length=<%d>\n",
                pIrp, Context, pIrp->IoStatus.Status, pIrp->IoStatus.Information);

        SrcAddressLength = pRcvContext->SrcAddressLength;
        pSrcAddress = pRcvContext->pSrcAddress;

        //
        // just call the regular indication routine as if UDP had done it.
        //
        TdiRcvDatagramHandler (pRcvContext->pAddress,
                               SrcAddressLength,
                               pSrcAddress,
                               0,
                               NULL,
                               TDI_RECEIVE_NORMAL,
                               (ULONG) pIrp->IoStatus.Information,
                               (ULONG) pIrp->IoStatus.Information,
                               &BytesTaken,
                               pBuffer,
                               &pIoRequestPacket);
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "ProcessReceiveCompletionRoutine",
            "MmGetSystemA... FAILed, pIrp=<%p>, pLocalBuffer=<%p>\n", pIrp, pRcvContext);
    }

    //
    // Free the Irp and Mdl and Buffer
    //
    IoFreeMdl (pIrp->MdlAddress);
    pIrp->MdlAddress = NULL;
    IoFreeIrp (pIrp);
    PgmFreeMem (pRcvContext);

    return (STATUS_MORE_PROCESSING_REQUIRED);
}


#ifdef DROP_DBG

ULONG   MinDropInterval = 10;
ULONG   MaxDropInterval = 10;
// ULONG   DropCount = 10;
ULONG   DropCount = -1;
#endif  // DROP_DBG

//----------------------------------------------------------------------------

NTSTATUS
TdiRcvDatagramHandler(
    IN PVOID                pDgramEventContext,
    IN INT                  SourceAddressLength,
    IN PVOID                pSourceAddress,
    IN INT                  OptionsLength,
    IN TDI_CMSGHDR          *pControlData,
    IN ULONG                ReceiveDatagramFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN PVOID                pTsdu,
    OUT PIRP                *ppIrp
    )
/*++

Routine Description:

    This routine is the handler for receiving all Pgm packets from
    the transport (protocol == IPPROTO_RM)

Arguments:

    IN  pDgramEventContext      -- Our context (pAddress)
    IN  SourceAddressLength     -- Length of source address
    IN  pSourceAddress          -- Address of remote host
    IN  OptionsLength
    IN  pControlData            -- ControlData from transport
    IN  ReceiveDatagramFlags    -- Flags set by the transport for this packet
    IN  BytesIndicated          -- Bytes in this indicate
    IN  BytesAvailable          -- total bytes available with the transport
    OUT pBytesTaken             -- bytes taken by us
    IN  pTsdu                   -- data packet ptr
    OUT ppIrp                   -- pIrp if more processing required

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    NTSTATUS                            status;
    tCOMMON_HEADER UNALIGNED            *pPgmHeader;
    tBASIC_SPM_PACKET_HEADER UNALIGNED  *pSpmPacket;
    tCOMMON_SESSION_CONTEXT             *pSession;
    PLIST_ENTRY                         pEntry;
    PGMLockHandle                       OldIrq, OldIrq1;
    USHORT                              TSDULength, TSIPort, LocalSessionPort, PacketSessionPort;
    PVOID                               pFECBuffer;
    UCHAR                               PacketType;
    IP_PKTINFO                          *pPktInfo;
    PIRP                                pLocalIrp = NULL;
    PMDL                                pLocalMdl = NULL;
    tRCV_COMPLETE_CONTEXT               *pRcvBuffer = NULL;
    ULONG                               XSum, BufferLength = 0;
    IPV4Header                          *pIp = (IPV4Header *) pTsdu;
    PTA_IP_ADDRESS                      pIpAddress = (PTA_IP_ADDRESS) pSourceAddress;
    tADDRESS_CONTEXT                    *pAddress = (tADDRESS_CONTEXT *) pDgramEventContext;

    *pBytesTaken = 0;   // Initialize the Bytes Taken!
    *ppIrp = NULL;

#ifdef DROP_DBG
//
// Drop OData packets only for now!
//
pPgmHeader = (tCOMMON_HEADER UNALIGNED *) (((PUCHAR)pIp) + (pIp->HeaderLength * 4));
PacketType = pPgmHeader->Type & 0x0f;
if ((PacketType == PACKET_TYPE_ODATA) &&
    !(((tBASIC_DATA_PACKET_HEADER *) pPgmHeader)->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY) &&
    !(--DropCount))
{
    ULONG   SequenceNumber;

    DropCount = GetRandomInteger (MinDropInterval, MaxDropInterval);

/*
    PgmCopyMemory (&SequenceNumber, &((tBASIC_DATA_PACKET_HEADER *) pPgmHeader)->DataSequenceNumber, sizeof (ULONG));
    DbgPrint("TdiRcvDatagramHandler:  Dropping packet, %s SeqNum = %d!\n",
        (((tBASIC_DATA_PACKET_HEADER *) pPgmHeader)->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY ? "PARITY" : "DATA"),
        ntohl (SequenceNumber));
*/
    return (STATUS_DATA_NOT_ACCEPTED);
}
#endif  // DROP_DBG
    ASSERT (BytesAvailable < MAX_RECEIVE_SIZE);

    PgmLock (&PgmDynamicConfig, OldIrq);
    if (BytesIndicated > PgmDynamicConfig.MaxMTU)
    {
        PgmDynamicConfig.MaxMTU = BytesIndicated;
    }

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "TdiRcvDatagramHandler",
            "Invalid Address handle=<%p>\n", pAddress);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Now, Reference the Address so that it cannot go away
    // while we are processing it!
    //
    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER, FALSE);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    //
    // If we do not have the complete datagram, then pass an Irp down to retrieve it
    //
    ASSERT (BytesIndicated <= BytesAvailable);
    if (!(ReceiveDatagramFlags & TDI_RECEIVE_ENTIRE_MESSAGE) &&
         (BytesAvailable != BytesIndicated))
    {
        //
        //
        // Build an irp to do the receive with and attach a buffer to it.
        //
        BufferLength = sizeof (tRCV_COMPLETE_CONTEXT) + BytesAvailable + SourceAddressLength;
        BufferLength = ((BufferLength + 3)/sizeof(ULONG)) * sizeof(ULONG);

        if ((pLocalIrp = IoAllocateIrp (pgPgmDevice->pPgmDeviceObject->StackSize, FALSE)) &&
            (pRcvBuffer = PgmAllocMem (BufferLength, PGM_TAG('3'))) &&
            (pLocalMdl = IoAllocateMdl (&pRcvBuffer->BufferData, BytesAvailable, FALSE, FALSE, NULL)))
        {
            pLocalIrp->MdlAddress = pLocalMdl;
            MmBuildMdlForNonPagedPool (pLocalMdl); // Map the pages in memory...

            TdiBuildReceiveDatagram (pLocalIrp,
                                     pAddress->pDeviceObject,
                                     pAddress->pFileObject,
                                     ProcessReceiveCompletionRoutine,
                                     pRcvBuffer,
                                     pLocalMdl,
                                     BytesAvailable,
                                     NULL,
                                     NULL,
                                     0);        // (ULONG) TDI_RECEIVE_NORMAL) ?

            // make the next stack location the current one.  Normally IoCallDriver
            // would do this but we are not going through IoCallDriver here, since the
            // Irp is just passed back with RcvIndication.
            //
            ASSERT (pLocalIrp->CurrentLocation > 1);
            IoSetNextIrpStackLocation (pLocalIrp);

            //
            // save the source address and length in the buffer for later
            // indication back to this routine.
            //
            pRcvBuffer->pAddress = pAddress;
            pRcvBuffer->SrcAddressLength = SourceAddressLength;
            pRcvBuffer->pSrcAddress = (PVOID) ((PUCHAR)&pRcvBuffer->BufferData + BytesAvailable);
            PgmCopyMemory (pRcvBuffer->pSrcAddress, pSourceAddress, SourceAddressLength);

            *pBytesTaken = 0;
            *ppIrp = pLocalIrp;

            status = STATUS_MORE_PROCESSING_REQUIRED;

            PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "TdiRcvDatagramHandler",
                "BytesI=<%d>, BytesA=<%d>, Flags=<%x>, pIrp=<%p>\n",
                    BytesIndicated, BytesAvailable, ReceiveDatagramFlags, pLocalIrp);
        }
        else
        {
            // Cleanup on failure:
            if (pLocalIrp)
            {
                IoFreeIrp (pLocalIrp);
            }
            if (pRcvBuffer)
            {
                PgmFreeMem (pRcvBuffer);
            }

            status = STATUS_DATA_NOT_ACCEPTED;

            PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "TdiRcvDatagramHandler",
                "INSUFFICIENT_RESOURCES, BuffLen=<%d>, pIrp=<%p>, pBuff=<%p>\n",
                    BufferLength, pLocalIrp, pRcvBuffer);
        }

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
        return (status);
    }

    //
    // Now that we have the complete datagram, verify that it is valid
    // First line of defense against bad packets.
    //
    if ((BytesIndicated < (sizeof(IPV4Header) + sizeof(tCOMMON_HEADER))) ||
        (pIp->Version != 4) ||
        (BytesIndicated < (pIp->HeaderLength*4 + sizeof(tCOMMON_HEADER))) ||
        (pIpAddress->TAAddressCount != 1) ||
        (pIpAddress->Address[0].AddressLength != TDI_ADDRESS_LENGTH_IP) ||
        (pIpAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP))
    {
        //
        // Need to get at least our header from transport!
        //
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "TdiRcvDatagramHandler",
            "IPver=<%d>, BytesI=<%d>, Min=<%d>, AddrType=<%d>\n",
                pIp->Version, BytesIndicated, (sizeof(IPV4Header) + sizeof(tBASIC_DATA_PACKET_HEADER)),
                pIpAddress->Address[0].AddressType);

        ASSERT (0);

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    pPgmHeader = (tCOMMON_HEADER UNALIGNED *) (((PUCHAR)pIp) + (pIp->HeaderLength * 4));
    PgmCopyMemory (&TSDULength, &pPgmHeader->TSDULength, sizeof (USHORT));
    TSDULength = ntohs (TSDULength);

    BytesIndicated -= (pIp->HeaderLength * 4);
    BytesAvailable -= (pIp->HeaderLength * 4);

    ASSERT (BytesIndicated == BytesAvailable);

    //
    // Now, Verify Checksum
    //
    if ((XSum = tcpxsum (0, (CHAR *) pPgmHeader, BytesIndicated)) != 0xffff)
    {
        //
        // Need to get at least our header from transport!
        //
        PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "TdiRcvDatagramHandler",
            "Bad Checksum on Pgm Packet (type=<%x>)!  XSum=<%x> -- Rejecting packet\n",
            pPgmHeader->Type, XSum);

//        ASSERT (0);

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Now, determine the TSI, i.e. GSI (from packet) + TSIPort (below)
    //
    PacketType = pPgmHeader->Type & 0x0f;
    if ((PacketType == PACKET_TYPE_NAK)  ||
        (PacketType == PACKET_TYPE_NNAK) ||
        (PacketType == PACKET_TYPE_SPMR) ||
        (PacketType == PACKET_TYPE_POLR))
    {
        PgmCopyMemory (&TSIPort, &pPgmHeader->DestPort, sizeof (USHORT));
        PgmCopyMemory (&PacketSessionPort, &pPgmHeader->SrcPort, sizeof (USHORT));
    }
    else
    {
        PgmCopyMemory (&TSIPort, &pPgmHeader->SrcPort, sizeof (USHORT));
        PgmCopyMemory (&PacketSessionPort, &pPgmHeader->DestPort, sizeof (USHORT));
    }
    TSIPort = ntohs (TSIPort);
    PacketSessionPort = ntohs (PacketSessionPort);

    //
    // If this packet is for a different session port, drop it
    //
    if (pAddress->ReceiverMCastAddr)
    {
        LocalSessionPort = pAddress->ReceiverMCastPort;
    }
    else
    {
        LocalSessionPort = pAddress->SenderMCastPort;
    }

    if (LocalSessionPort != PacketSessionPort)
    {
        PgmLog (PGM_LOG_INFORM_PATH, DBG_RECEIVE, "TdiRcvDatagramHandler",
            "Dropping packet for different Session port, <%x>!=<%x>!\n", LocalSessionPort, PacketSessionPort);

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Now check if this receive is for an active connection
    //
    pSession = NULL;
    PgmLock (pAddress, OldIrq);        // So that the list cannot change!
    pEntry = &pAddress->AssociatedConnections;
    while ((pEntry = pEntry->Flink) != &pAddress->AssociatedConnections)
    {
        pSession = CONTAINING_RECORD (pEntry, tCOMMON_SESSION_CONTEXT, Linkage);

        PgmLock (pSession, OldIrq1);

        if ((PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_RECEIVE, PGM_VERIFY_SESSION_SEND)) &&
            (0 == strncmp (pSession->GSI, pPgmHeader->gSourceId, SOURCE_ID_LENGTH)) &&
            (TSIPort == pSession->TSIPort) &&
            !(pSession->SessionFlags & (PGM_SESSION_DISCONNECT_INDICATED | PGM_SESSION_TERMINATED_ABORT)))
        {
            if (pSession->pSender)
            {
                PGM_REFERENCE_SESSION_SEND (pSession, REF_SESSION_TDI_RCV_HANDLER, TRUE);
                PgmUnlock (pSession, OldIrq1);
                break;
            }

            ASSERT (pSession->pReceiver);
            PGM_REFERENCE_SESSION_RECEIVE (pSession, REF_SESSION_TDI_RCV_HANDLER, TRUE);

            if ((pSession->FECOptions) &&
                (BytesIndicated > pSession->MaxMTULength))
            {
                if (pFECBuffer = PgmAllocMem (((BytesIndicated+sizeof(tPOST_PACKET_FEC_CONTEXT)-sizeof(USHORT))
                                                *pSession->FECGroupSize*2), PGM_TAG('3')))
                {
                    ASSERT (pSession->pFECBuffer);
                    PgmFreeMem (pSession->pFECBuffer);
                    pSession->pFECBuffer = pFECBuffer;
                    pSession->MaxMTULength = (USHORT) BytesIndicated;
                    pSession->MaxFECPacketLength = pSession->MaxMTULength +
                                                   sizeof (tPOST_PACKET_FEC_CONTEXT) - sizeof (USHORT);
                }
                else
                {
                    PgmLog (PGM_LOG_ERROR, DBG_RECEIVE, "TdiRcvDatagramHandler",
                        "STATUS_INSUFFICIENT_RESOURCES -- pFECBuffer=<%d> bytes\n",
                            (BytesIndicated+sizeof(tPOST_PACKET_FEC_CONTEXT)-sizeof(USHORT)));

                    pSession = NULL;
                    pSession->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                }
            }

            PgmUnlock (pSession, OldIrq1);
            break;
        }

        PgmUnlock (pSession, OldIrq1);
        pSession = NULL;
    }

    PgmUnlock (pAddress, OldIrq);

    if (!pSession)
    {
        // We should drop this packet because we received this either because
        // we may have a loopback session, or we have a listen but this
        // is not an OData packet
        status = STATUS_DATA_NOT_ACCEPTED;

        //
        // New sessions will be accepted only if we are a receiver
        // Also, new sessions will always be initiated only with an OData packet
        // Also, verify that the client has posted a connect handler!
        //
        if ((pAddress->ReceiverMCastAddr) &&
            (pAddress->ConEvContext))
        {
            if ((PacketType == PACKET_TYPE_ODATA) &&
                (!(pPgmHeader->Options & PACKET_HEADER_OPTIONS_PARITY)))
            {
                //
                // This is a new incoming connection, so see if the
                // client accepts it.
                //
                status = PgmNewInboundConnection (pAddress,
                                                  SourceAddressLength,
                                                  pSourceAddress,
                                                  ReceiveDatagramFlags,
                                                  (tBASIC_DATA_PACKET_HEADER UNALIGNED *) pPgmHeader,
                                                  BytesIndicated,
                                                  &pSession);

                if (!NT_SUCCESS (status))
                {
                    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "TdiRcvDatagramHandler",
                        "pAddress=<%p> FAILed to accept new connection, PacketType=<%x>, status=<%x>\n",
                            pAddress, PacketType, status);
                }
            }
            else if (PacketType == PACKET_TYPE_SPM)
            {
                ProcessSpmPacket (pAddress,
                                  NULL,             // This will signify that we do not have a connection yet
                                  BytesIndicated,
                                  (tBASIC_SPM_PACKET_HEADER UNALIGNED *) pPgmHeader);
            }
        }

        if (!NT_SUCCESS (status))
        {
            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
            return (STATUS_DATA_NOT_ACCEPTED);
        }
    }

    if ((pAddress->Flags & PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE) &&
        (pAddress->Flags & PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES) &&
        (ReceiveDatagramFlags & TDI_RECEIVE_CONTROL_INFO))
    {
        //
        // See if we can Enqueue the stop listening request
        //
        PgmLock (&PgmDynamicConfig, OldIrq);
        PgmLock (pAddress, OldIrq1);

        pPktInfo = (IP_PKTINFO*) TDI_CMSG_DATA (pControlData);
        PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING, TRUE);

        if (STATUS_SUCCESS == PgmQueueForDelayedExecution (StopListeningOnAllInterfacesExcept,
                                                           pAddress,
                                                           ULongToPtr (pPktInfo->ipi_ifindex),
                                                           NULL,
                                                           TRUE))
        {
            pAddress->Flags &= ~PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE;

            PgmUnlock (pAddress, OldIrq1);
            PgmUnlock (&PgmDynamicConfig, OldIrq);
        }
        else
        {
            PgmUnlock (pAddress, OldIrq1);
            PgmUnlock (&PgmDynamicConfig, OldIrq);

            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING);
        }
    }

    //
    // Now, handle the packet appropriately
    //
    status = PgmProcessIncomingPacket (pAddress,
                                       pSession,
                                       SourceAddressLength,
                                       pSourceAddress,
                                       BytesIndicated,
                                       pPgmHeader,
                                       PacketType);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_RECEIVE, "TdiRcvDatagramHandler",
        "PacketType=<%x> for pSession=<%p> BytesI=<%d>, BytesA=<%d>, status=<%x>\n",
            PacketType, pSession, BytesIndicated, BytesAvailable, status);

    if (pSession->pSender)
    {
        PGM_DEREFERENCE_SESSION_SEND (pSession, REF_SESSION_TDI_RCV_HANDLER);
    }
    else
    {
        ASSERT (pSession->pReceiver);
        PGM_DEREFERENCE_SESSION_RECEIVE (pSession, REF_SESSION_TDI_RCV_HANDLER);
    }

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);

    //
    // Only acceptable return codes are STATUS_SUCCESS and STATUS_DATA_NOT_ACCPETED
    // (STATUS_MORE_PROCESSING_REQUIRED is not valid here because we have no Irp).
    //
    if (STATUS_SUCCESS != status)
    {
        status = STATUS_DATA_NOT_ACCEPTED;
    }

    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmCancelReceiveIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Receive Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    None

--*/
{
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation (pIrp);
    tRECEIVE_SESSION        *pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    PGMLockHandle           OldIrq;
    PLIST_ENTRY             pEntry;

    if (!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE))
    {
        IoReleaseCancelSpinLock (pIrp->CancelIrql);

        PgmLog (PGM_LOG_ERROR, (DBG_RECEIVE | DBG_ADDRESS | DBG_CONNECT), "PgmCancelReceiveIrp",
            "pIrp=<%p> pReceive=<%p>, pAddress=<%p>\n", pIrp, pReceive, pReceive->pReceiver->pAddress);
        return;
    }

    PgmLock (pReceive, OldIrq);

    //
    // See if we are actively receiving
    //
    if (pIrp == pReceive->pReceiver->pIrpReceive)
    {
        pIrp->IoStatus.Information = pReceive->pReceiver->BytesInMdl;
        pIrp->IoStatus.Status = STATUS_CANCELLED;

        pReceive->pReceiver->BytesInMdl = pReceive->pReceiver->TotalBytesInMdl = 0;
        pReceive->pReceiver->pIrpReceive = NULL;

        PgmUnlock (pReceive, OldIrq);
        IoReleaseCancelSpinLock (pIrp->CancelIrql);

        IoCompleteRequest (pIrp,IO_NETWORK_INCREMENT);
        return;
    }

    //
    // We are not actively receiving, so see if this Irp is
    // in our Irps list
    //
    pEntry = &pReceive->pReceiver->ReceiveIrpsList;
    while ((pEntry = pEntry->Flink) != &pReceive->pReceiver->ReceiveIrpsList)
    {
        if (pEntry == &pIrp->Tail.Overlay.ListEntry)
        {
            RemoveEntryList (pEntry);
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            PgmUnlock (pReceive, OldIrq);
            IoReleaseCancelSpinLock (pIrp->CancelIrql);

            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
            return;
        }
    }

    //
    // If we have reached here, then the Irp must already
    // be in the process of being completed!
    //
    PgmUnlock (pReceive, OldIrq);
    IoReleaseCancelSpinLock (pIrp->CancelIrql);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmReceive(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called via dispatch by the client to post a Receive pIrp

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    NTSTATUS                    status;
    PGMLockHandle               OldIrq, OldIrq1, OldIrq2, OldIrq3;
    tADDRESS_CONTEXT            *pAddress = NULL;
    tRECEIVE_SESSION            *pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL_RECEIVE pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE) &pIrpSp->Parameters;

    PgmLock (&PgmDynamicConfig, OldIrq);
    IoAcquireCancelSpinLock (&OldIrq1);

    //
    // Verify that the connection is valid and is associated with an address
    //
    if ((!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE)) ||
        (!(pAddress = pReceive->pAssociatedAddress)) ||
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)))
    {
        PgmLog (PGM_LOG_ERROR, (DBG_RECEIVE | DBG_ADDRESS | DBG_CONNECT), "PgmReceive",
            "Invalid Handles pReceive=<%p>, pAddress=<%p>\n", pReceive, pAddress);

        status = STATUS_INVALID_HANDLE;
    }
    else if (pReceive->SessionFlags & PGM_SESSION_DISCONNECT_INDICATED)
    {
        PgmLog (PGM_LOG_INFORM_PATH, (DBG_RECEIVE | DBG_ADDRESS | DBG_CONNECT), "PgmReceive",
            "Receive Irp=<%p> was posted after session has been Disconnected, pReceive=<%p>, pAddress=<%p>\n",
            pIrp, pReceive, pAddress);

        status = STATUS_CANCELLED;
    }
    else if (!pClientParams->ReceiveLength)
    {
        ASSERT (0);
        PgmLog (PGM_LOG_ERROR, (DBG_RECEIVE | DBG_ADDRESS | DBG_CONNECT), "PgmReceive",
            "Invalid Handles pReceive=<%p>, pAddress=<%p>\n", pReceive, pAddress);

        status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS (status))
    {
        IoReleaseCancelSpinLock (OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        pIrp->IoStatus.Information = 0;
        return (status);
    }

    PgmLock (pAddress, OldIrq2);
    PgmLock (pReceive, OldIrq3);

    if (!NT_SUCCESS (PgmCheckSetCancelRoutine (pIrp, PgmCancelReceiveIrp, TRUE)))
    {
        PgmUnlock (pReceive, OldIrq3);
        PgmUnlock (pAddress, OldIrq2);
        IoReleaseCancelSpinLock (OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmLog (PGM_LOG_ERROR, (DBG_RECEIVE | DBG_ADDRESS | DBG_CONNECT), "PgmReceive",
            "Could not set Cancel routine on receive Irp=<%p>, pReceive=<%p>, pAddress=<%p>\n",
                pIrp, pReceive, pAddress);

        return (STATUS_CANCELLED);
    }
    IoReleaseCancelSpinLock (OldIrq3);

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_CLIENT_RECEIVE, TRUE);
    PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_CLIENT_RECEIVE, TRUE);

    PgmUnlock (&PgmDynamicConfig, OldIrq2);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, (DBG_RECEIVE | DBG_ADDRESS | DBG_CONNECT), "PgmReceive",
        "Client posted ReceiveIrp = <%p> for pReceive=<%p>\n", pIrp, pReceive);

    InsertTailList (&pReceive->pReceiver->ReceiveIrpsList, &pIrp->Tail.Overlay.ListEntry);
    pReceive->SessionFlags &= ~PGM_SESSION_WAIT_FOR_RECEIVE_IRP;

    //
    // Now, try to indicate any data which may still be pending
    //
    status = CheckIndicatePendedData (pAddress, pReceive, &OldIrq, &OldIrq1);

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (pAddress, OldIrq);

    PGM_DEREFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_CLIENT_RECEIVE);
    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CLIENT_RECEIVE);

    return (STATUS_PENDING);
}


//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\tdi.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Tdi.c

Abstract:

    This module implements Initialization routines
    the PGM Transport and other routines that are specific to the
    NT implementation of a driver.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"
#include <ntddtcp.h>    // for IOCTL_TCP_SET_INFORMATION_EX
#include <tcpinfo.h>    // for TCPSocketOption
#include <tdiinfo.h>    // for TCP_REQUEST_SET_INFORMATION_EX


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TdiOpenAddressHandle)
#pragma alloc_text(PAGE, CloseAddressHandles)
#pragma alloc_text(PAGE, PgmTdiOpenControl)
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
PgmTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the NBT driver that it can proceed (i.e.
    to allow some code that is waiting on a "KeWaitForSingleObject" to
    proceeed.

Arguments:

    IN  DeviceObject    -- unused.
    IN  Irp             -- Supplies Irp that the transport has finished processing.
    IN  Context         -- Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_TDI, "PgmTdiCompletionRoutine",
        "CompletionEvent:  pEvent=<%p>, pIrp=<%p>, DeviceObject=<%p>\n", Context, Irp, DeviceObject);

    KeSetEvent ((PKEVENT )Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//----------------------------------------------------------------------------

NTSTATUS
TdiSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject  -- Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject      -- Supplies the address object's file object.
    IN ULONG EventType,             -- Supplies the type of event.
    IN PVOID EventHandler           -- Supplies the event handler.
    IN PVOID Context                -- Supplies the context passed into the event handler when it runs

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS    Status;
    KEVENT      Event;
    PIRP        pIrp;

    PAGED_CODE();

    if (!(pIrp = IoAllocateIrp (IoGetRelatedDeviceObject (FileObject)->StackSize, FALSE)))
    {
        PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiSetEventHandler",
            "INSUFFICIENT_RESOURCES allocating Irp, StackSize=<%d>\n",
                IoGetRelatedDeviceObject (FileObject)->StackSize);

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler (pIrp, DeviceObject, FileObject,
                             NULL, NULL,
                             EventType, EventHandler, Context);

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    // set the address of the routine to be executed when the IRP
    // finishes.  This routine signals the event and allows the code
    // below to continue (i.e. KeWaitForSingleObject)
    //
    IoSetCompletionRoutine (pIrp,
                            (PIO_COMPLETION_ROUTINE) PgmTdiCompletionRoutine,
                            (PVOID)&Event,
                            TRUE, TRUE, TRUE);

    Status = IoCallDriver (IoGetRelatedDeviceObject (FileObject), pIrp);
    if (Status == STATUS_PENDING)
    {
        Status = KeWaitForSingleObject ((PVOID)&Event, // Object to wait on.
                                        Executive,  // Reason for waiting
                                        KernelMode, // Processor mode
                                        FALSE,      // Alertable
                                        NULL);      // Timeout
        if (NT_SUCCESS(Status))
        {
            Status = pIrp->IoStatus.Status;
        }
    }

    IoFreeIrp (pIrp);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_TDI, "TdiSetEventHandler",
        "Status=<%d>, EventType=<%d>, Hanlder=<%x>\n", Status, EventType, EventHandler);

    return (Status);
}

//----------------------------------------------------------------------------

NTSTATUS
TdiErrorHandler(
    IN PVOID Context,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine is the handler for TDI errors

Arguments:

    IN  Context -- unused
    IN  Status  -- error status

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiErrorHandler",
        "Status=<%x>\n", Status);

    return (STATUS_DATA_NOT_ACCEPTED);
}


//----------------------------------------------------------------------------

NTSTATUS
TdiOpenAddressHandle(
    IN  tPGM_DEVICE     *pPgmDevice,
    IN  PVOID           HandlerContext,
    IN  tIPADDRESS      IpAddress,
    IN  USHORT          PortNumber,
    OUT HANDLE          *pFileHandle,
    OUT PFILE_OBJECT    *ppFileObject,
    OUT PDEVICE_OBJECT  *ppDeviceObject
    )
/*++

Routine Description:

    This routine is called to open an address handle on IP

Arguments:

    IN  pPgmDevice      -- Pgm's Device object context
    IN  HandlerContext  -- pAddress object ptr to be used as context ptr (NULL if don't want to be notified)
    IN  IpAddress       -- local IpAddress on which to open address
    IN  PortNumber      -- IP protocol port
    OUT pFileHandle     -- FileHandle if we succeeded
    OUT ppFileObject    -- FileObject if we succeeded
    OUT ppDeviceObject  -- IP's DeviceObject ptr if we succeeded

Return Value:

    NTSTATUS - Final status of the Open Address operation

--*/
{
    NTSTATUS                    status;
    ULONG                       EaBufferSize;
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    PTRANSPORT_ADDRESS          pTransAddressEa;
    PTRANSPORT_ADDRESS          pTransAddr;
    TDI_ADDRESS_IP              IpAddr;
    OBJECT_ATTRIBUTES           AddressAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    PFILE_OBJECT                pFileObject;
    HANDLE                      FileHandle;
    PDEVICE_OBJECT              pDeviceObject;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached;
    ULONG                       True = TRUE;

    PAGED_CODE();

    EaBufferSize = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                   TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                   sizeof(TRANSPORT_ADDRESS) +
                   sizeof(TDI_ADDRESS_IP);

    if (!(EaBuffer = PgmAllocMem (EaBufferSize, PGM_TAG('1'))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiOpenAddressHandle",
            "[1]:  INSUFFICIENT_RESOURCES allocating <%d> bytes\n", EaBufferSize);

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    // allocate Memory for the transport address
    //
    if (!(pTransAddr = PgmAllocMem (sizeof(TRANSPORT_ADDRESS)+sizeof(TDI_ADDRESS_IP), PGM_TAG('2'))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiOpenAddressHandle",
            "[2]:  INSUFFICIENT_RESOURCES allocating <%d> bytes\n",
                (sizeof(TRANSPORT_ADDRESS)+sizeof(TDI_ADDRESS_IP)));

        PgmFreeMem (EaBuffer);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    EaBuffer->EaValueLength = (USHORT)(sizeof(TRANSPORT_ADDRESS) -1 + sizeof(TDI_ADDRESS_IP));
    PgmMoveMemory (EaBuffer->EaName, TdiTransportAddress, EaBuffer->EaNameLength+1); // "TransportAddress"

    // fill in the IP address and Port number
    //
    IpAddr.sin_port = htons (PortNumber);   // put in network order
    IpAddr.in_addr = htonl (IpAddress);
    RtlFillMemory ((PVOID)&IpAddr.sin_zero, sizeof(IpAddr.sin_zero), 0);    // zero fill the  last component

    // copy the ip address to the end of the structure
    //
    PgmMoveMemory (pTransAddr->Address[0].Address, (CONST PVOID)&IpAddr, sizeof(IpAddr));
    pTransAddr->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    pTransAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pTransAddr->TAAddressCount = 1;

    // copy the ip address to the end of the name in the EA structure
    pTransAddressEa = (TRANSPORT_ADDRESS *)&EaBuffer->EaName[EaBuffer->EaNameLength+1];
    PgmMoveMemory ((PVOID)pTransAddressEa,
                   (CONST PVOID)pTransAddr,
                   sizeof(TDI_ADDRESS_IP) + sizeof(TRANSPORT_ADDRESS)-1);

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_OPEN_ADDR_HANDLE);

    InitializeObjectAttributes (&AddressAttributes,
                                &pPgmDevice->ucBindName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    status = ZwCreateFile (&FileHandle,
                           GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                           &AddressAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           FILE_OPEN_IF,
                           0,
                           (PVOID)EaBuffer,
                           sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                               EaBuffer->EaNameLength + 1 +
                               EaBuffer->EaValueLength);

    PgmFreeMem ((PVOID)pTransAddr);
    PgmFreeMem ((PVOID)EaBuffer);

    if (NT_SUCCESS (status))
    {
        status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS (status))
    {
        //
        // Reference the FileObject to keep device ptr around!
        //
        status = ObReferenceObjectByHandle (FileHandle, (ULONG)0, 0, KernelMode, (PVOID *)&pFileObject, NULL);
        if (!NT_SUCCESS (status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiOpenAddressHandle",
                "FAILed to Reference FileObject: status=<%x>\n", status);

            ZwClose (FileHandle);
        }
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiOpenAddressHandle",
            "FAILed to create handle: status=<%x>, Device:\n\t%wZ\n", status, &pPgmDevice->ucBindName);
    }

    if (!NT_SUCCESS (status))
    {
        PgmDetachFsp (&ApcState, &fAttached, REF_FSP_OPEN_ADDR_HANDLE);
        return (status);
    }

    pDeviceObject = IoGetRelatedDeviceObject (pFileObject);

    //
    // Now set the Event handlers (only if we have the HandlerContext set)!
    //
    if (HandlerContext)
    {
        status = TdiSetEventHandler (pDeviceObject,
                                     pFileObject,
                                     TDI_EVENT_ERROR,
                                     (PVOID) TdiErrorHandler,
                                     HandlerContext);
        if (NT_SUCCESS (status))
        {
            // Datagram Udp Handler
            status = TdiSetEventHandler (pDeviceObject,
                                         pFileObject,
                                         TDI_EVENT_RECEIVE_DATAGRAM,
                                         (PVOID) TdiRcvDatagramHandler,
                                         HandlerContext);
            if (NT_SUCCESS (status))
            {
                status = PgmSetTcpInfo (FileHandle,
                                        AO_OPTION_IP_PKTINFO,
                                        &True,
                                        sizeof (True));

                if (!NT_SUCCESS (status))
                {
                    PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiOpenAddressHandle",
                        "Setting AO_OPTION_IP_PKTINFO, status=<%x>\n", status);
                }
            }
            else
            {
                PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiOpenAddressHandle",
                    "FAILed to set TDI_EVENT_RECEIVE_DATAGRAM handler, status=<%x>\n", status);
            }
        }
        else
        {
            PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiOpenAddressHandle",
                "FAILed to set TDI_EVENT_ERROR handler, status=<%x>\n", status);
        }
    }

    if (NT_SUCCESS(status))
    {
        *pFileHandle = FileHandle;
        *ppFileObject = pFileObject;
        *ppDeviceObject = pDeviceObject;

        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_TDI, "TdiOpenAddressHandle",
            "SUCCEEDed, FileHandle=<%x>, pFileObject=<%x>, pDeviceObject=<%x>\n",
                FileHandle, pFileObject, pDeviceObject);
    }
    else
    {
        //
        // FAILed to set Tdi handlers
        //
        ObDereferenceObject (pFileObject);
        ZwClose (FileHandle);
    }

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_OPEN_ADDR_HANDLE);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
CloseAddressHandles(
    IN  HANDLE          FileHandle,
    IN  PFILE_OBJECT    pFileObject
    )
/*++

Routine Description:

    This routine dereferences any FileObjects as necessary and closes the
    FileHandle that was opened earlier

Arguments:

    IN  FileHandle  -- FileHandle to be closed
    IN  pFileObject -- FileObject to be dereferenced

Return Value:

    NTSTATUS - Final status of the CloseAddress operation

--*/
{
    NTSTATUS    status1 = STATUS_SUCCESS, status2 = STATUS_SUCCESS;
    KAPC_STATE  ApcState;
    BOOLEAN     fAttached;

    PAGED_CODE();

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_CLOSE_ADDRESS_HANDLES);

    if (pFileObject)
    {
        status2 = ObDereferenceObject ((PVOID *) pFileObject);
    }

    if (FileHandle)
    {
        status1 = ZwClose (FileHandle);
    }

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_CLOSE_ADDRESS_HANDLES);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_TDI, "CloseAddressHandles",
        "FileHandle=<%x> ==> status=<%x>, pFileObject=<%x> ==> status=<%x>\n",
            FileHandle, status2, pFileObject, status1);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmTdiOpenControl(
    IN  tPGM_DEVICE         *pPgmDevice
    )
/*++

Routine Description:

    This routine opens a Control channel over Raw IP

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PFILE_FULL_EA_INFORMATION   EaBuffer = NULL;
    IO_STATUS_BLOCK             IoStatusBlock;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached;

    PAGED_CODE();

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_OPEN_CONTROL_HANDLE);

    InitializeObjectAttributes (&ObjectAttributes,
                                &pPgmDevice->ucBindName,
                                0,
                                NULL,
                                NULL);

    Status = ZwCreateFile ((PHANDLE) &pPgmDevice->hControl,
                           GENERIC_READ | GENERIC_WRITE,
                           &ObjectAttributes,     // object attributes.
                           &IoStatusBlock,        // returned status information.
                           NULL,                  // block size (unused).
                           FILE_ATTRIBUTE_NORMAL, // file attributes.
                           0,
                           FILE_CREATE,
                           0,                     // create options.
                           (PVOID)EaBuffer,       // EA buffer.
                           0); // Ea length

    if (NT_SUCCESS (Status))
    {
        Status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS (Status))
    {
        //
        // get a reference to the file object and save it since we can't
        // dereference a file handle at DPC level so we do it now and keep
        // the ptr around for later.
        //
        Status = ObReferenceObjectByHandle (pPgmDevice->hControl,
                                            0L,
                                            NULL,
                                            KernelMode,
                                            (PVOID *) &pPgmDevice->pControlFileObject,
                                            NULL);

        if (!NT_SUCCESS(Status))
        {
            PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmTdiOpenControl",
                "ObReferenceObjectByHandle FAILed status=<%x>\n", Status);

            ZwClose (pPgmDevice->hControl);
        }
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmTdiOpenControl",
            "Failed to Open the Control file, Status=<%x>\n", Status);
    }

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_OPEN_CONTROL_HANDLE);

    if (NT_SUCCESS(Status))
    {
        //
        // We Succeeded!
        //
        pPgmDevice->pControlDeviceObject = IoGetRelatedDeviceObject (pPgmDevice->pControlFileObject);

        PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_TDI, "PgmTdiOpenControl",
            "Opened Control channel on: %wZ\n", &pPgmDevice->ucBindName);
    }
    else
    {
        // set control file object ptr to null so we know that we did not open the control point.
        pPgmDevice->hControl = NULL;
        pPgmDevice->pControlFileObject = NULL;
    }

    return (Status);
}


//----------------------------------------------------------------------------
VOID
PgmDereferenceControl(
    IN  tCONTROL_CONTEXT    *pControlContext,
    IN  ULONG               RefContext
    )
/*++

Routine Description:

    This routine dereferences the control channel oblect over RawIP and
    frees the memory if the RefCount drops to 0

Arguments:

    IN  pControlContext -- Control object context
    IN  RefContext      -- Context for which this control object was referenced earlier

Return Value:

    NONE

--*/
{
    ASSERT (PGM_VERIFY_HANDLE (pControlContext, PGM_VERIFY_CONTROL));
    ASSERT (pControlContext->RefCount);             // Check for too many derefs
    ASSERT (pControlContext->ReferenceContexts[RefContext]--);

    if (--pControlContext->RefCount)
    {
        return;
    }

    PgmLog (PGM_LOG_INFORM_STATUS, DBG_TDI, "PgmDereferenceControl",
        "pControl=<%x> closed\n", pControlContext);
    //
    // Just Free the memory
    //
    PgmFreeMem (pControlContext);
}


//----------------------------------------------------------------------------
NTSTATUS
TdiSendDatagramCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine is called on completion of a DatagramSend

Arguments:

    IN  PDEVICE_OBJECT DeviceObject -- Supplies the device object of the transport provider.
    IN  pIrp                        -- Request
    IN  PVOID Context               -- Supplies the context passed

Return Value:

    NTSTATUS - Final status of the completion which will determine
                how the IO subsystem processes it subsequently

--*/

{
    NTSTATUS            status;
    tTDI_SEND_CONTEXT   *pTdiSendContext = (tTDI_SEND_CONTEXT *) pContext;

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_TDI, "PgmSendDatagramCompletion",
        "status=<%x>, Info=<%d>, pIrp=<%x>\n", pIrp->IoStatus.Status, pIrp->IoStatus.Information, pIrp);

    pTdiSendContext->pClientCompletionRoutine (pTdiSendContext->ClientCompletionContext1,
                                               pTdiSendContext->ClientCompletionContext2,
                                               pIrp->IoStatus.Status);

    //
    // Free the Memory that was allocated for this send
    //
    ExFreeToNPagedLookasideList (&PgmStaticConfig.TdiLookasideList, pTdiSendContext);
    IoFreeMdl (pIrp->MdlAddress);
    IoFreeIrp (pIrp);

    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is no initiating thread - we are the initiator
    return (STATUS_MORE_PROCESSING_REQUIRED);
}


//----------------------------------------------------------------------------
NTSTATUS
TdiSendDatagram(
    IN  PFILE_OBJECT                pTdiFileObject,
    IN  PDEVICE_OBJECT              pTdiDeviceObject,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  pCLIENT_COMPLETION_ROUTINE  pClientCompletionRoutine,
    IN  PVOID                       ClientCompletionContext1,
    IN  PVOID                       ClientCompletionContext2,
    IN  tIPADDRESS                  DestIpAddress,
    IN  USHORT                      DestPort
    )
/*++

Routine Description:

    This routine sends a datagram over RawIp

Arguments:

    IN  pTdiFileObject              -- IP's FileObject for this address
    IN  pTdiDeviceObject            -- DeviceObject for this address
    IN  pBuffer                     -- Data buffer (Pgm packet)
    IN  BufferLength                -- length of pBuffer
    IN  pClientCompletionRoutine    -- SendCompletion to be called
    IN  ClientCompletionContext1    -- Context1 for SendCompletion
    IN  ClientCompletionContext2    -- Context2 for SendCompletion
    IN  DestIpAddress               -- IP address to send datagram to
    IN  DestPort                    -- Port to send to

Return Value:

    NTSTATUS - STATUS_PENDING on success, and also if SendCompletion was specified

--*/
{
    NTSTATUS            status;
    tTDI_SEND_CONTEXT   *pTdiSendContext = NULL;
    PIRP                pIrp = NULL;
    PMDL                pMdl = NULL;

    //
    // Allocate the SendContext, pIrp and pMdl
    //
    if ((!(pTdiSendContext = ExAllocateFromNPagedLookasideList (&PgmStaticConfig.TdiLookasideList))) ||
        (!(pIrp = IoAllocateIrp (pgPgmDevice->pPgmDeviceObject->StackSize, FALSE))) ||
        (!(pMdl = IoAllocateMdl (pBuffer, BufferLength, FALSE, FALSE, NULL))))
    {
        if (pTdiSendContext)
        {
            ExFreeToNPagedLookasideList (&PgmStaticConfig.TdiLookasideList, pTdiSendContext);
        }

        if (pIrp)
        {
            IoFreeIrp (pIrp);
        }

        PgmLog (PGM_LOG_ERROR, DBG_TDI, "TdiSendDatagram",
            "INSUFFICIENT_RESOURCES for TdiSendContext=<%d> bytes\n", sizeof(tTDI_SEND_CONTEXT));

        if (pClientCompletionRoutine)
        {
            pClientCompletionRoutine (ClientCompletionContext1,
                                      ClientCompletionContext2,
                                      STATUS_INSUFFICIENT_RESOURCES);
            status = STATUS_PENDING;
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return (status);
    }

    MmBuildMdlForNonPagedPool (pMdl);
    pIrp->MdlAddress = pMdl;

    // fill in the remote address
    pTdiSendContext->TransportAddress.TAAddressCount = 1;
    pTdiSendContext->TransportAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    pTdiSendContext->TransportAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pTdiSendContext->TransportAddress.Address[0].Address->in_addr  = htonl(DestIpAddress);
    pTdiSendContext->TransportAddress.Address[0].Address->sin_port = htons(DestPort);

    // fill in the connection information
    pTdiSendContext->TdiConnectionInfo.RemoteAddressLength = sizeof(TA_IP_ADDRESS);
    pTdiSendContext->TdiConnectionInfo.RemoteAddress = &pTdiSendContext->TransportAddress;

    // Fill in our completion Context information
    pTdiSendContext->pClientCompletionRoutine = pClientCompletionRoutine;
    pTdiSendContext->ClientCompletionContext1 = ClientCompletionContext1;
    pTdiSendContext->ClientCompletionContext2 = ClientCompletionContext2;

    // Complete the "send datagram" IRP initialization.
    //
    TdiBuildSendDatagram (pIrp,
                          pTdiDeviceObject,
                          pTdiFileObject,
                          (PVOID) TdiSendDatagramCompletion,
                          pTdiSendContext,
                          pIrp->MdlAddress,
                          BufferLength,
                          &pTdiSendContext->TdiConnectionInfo);

    //
    // Tell the I/O manager to pass our IRP to the transport for
    // processing.
    //
    status = IoCallDriver (pTdiDeviceObject, pIrp);
    ASSERT (status == STATUS_PENDING);

    PgmLog (PGM_LOG_INFORM_ALL_FUNCS, DBG_TDI, "TdiSendDatagram",
        "%s Send to <%x:%x>, status=<%x>\n",
            (CLASSD_ADDR(DestIpAddress) ? "MCast" : "Unicast"), DestIpAddress, DestPort, status);

    //
    // IoCallDriver will always result in completion routien being called
    //
    return (STATUS_PENDING);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetTcpInfo(
    IN HANDLE       FileHandle,
    IN ULONG        ToiId,
    IN PVOID        pData,
    IN ULONG        DataLength
    )
/*++

Routine Description:

    This routine is called to set IP-specific options

Arguments:

    IN  FileHandle  -- FileHandle over IP for which to set option
    IN  ToId        -- Option Id
    IN  pData       -- Option data
    IN  DataLength  -- pData length

Return Value:

    NTSTATUS - Final status of the set option operation

--*/
{
    NTSTATUS                        Status, LocStatus;
    ULONG                           BufferLength;
    TCP_REQUEST_SET_INFORMATION_EX  *pTcpInfo;
    IO_STATUS_BLOCK                 IoStatus;
    HANDLE                          event;
    KAPC_STATE                      ApcState;
    BOOLEAN                         fAttached;

    IoStatus.Status = STATUS_SUCCESS;

    BufferLength = sizeof (TCP_REQUEST_SET_INFORMATION_EX) + DataLength;
    if (!(pTcpInfo = (TCP_REQUEST_SET_INFORMATION_EX *) PgmAllocMem (BufferLength, PGM_TAG('2'))))
    {
        PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmSetTcpInfo",
            "INSUFFICIENT_RESOURCES for pTcpInfo=<%d+%d> bytes\n",
                sizeof(TCP_REQUEST_SET_INFORMATION_EX), DataLength);

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    PgmZeroMemory (pTcpInfo, BufferLength);

    pTcpInfo->ID.toi_entity.tei_entity  = CL_TL_ENTITY;
    pTcpInfo->ID.toi_entity.tei_instance= TL_INSTANCE;
    pTcpInfo->ID.toi_class              = INFO_CLASS_PROTOCOL;
    pTcpInfo->ID.toi_type               = INFO_TYPE_ADDRESS_OBJECT;

    //
    // Set the Configured values
    //
    pTcpInfo->ID.toi_id                 = ToiId;
    pTcpInfo->BufferSize                = DataLength;
    PgmCopyMemory (&pTcpInfo->Buffer[0], pData, DataLength);

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_SET_TCP_INFO);

    Status = ZwCreateEvent (&event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE);
    if (NT_SUCCESS(Status))
    {
        //
        // Make the actual TDI call
        //
        Status = ZwDeviceIoControlFile (FileHandle,
                                        event,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_TCP_SET_INFORMATION_EX,
                                        pTcpInfo,
                                        BufferLength,
                                        NULL,
                                        0);

        //
        // If the call pended and we were supposed to wait for completion,
        // then wait.
        //
        if (Status == STATUS_PENDING)
        {
            Status = NtWaitForSingleObject (event, FALSE, NULL);
            ASSERT (NT_SUCCESS(Status));
        }

        if (NT_SUCCESS (Status))
        {
            Status = IoStatus.Status;
            if (!NT_SUCCESS (Status))
            {
                PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmSetTcpInfo",
                    "TcpSetInfoEx request returned Status = <%x>, Id=<0x%x>\n", Status, ToiId);
            }
        }
        else
        {
            PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmSetTcpInfo",
                "ZwDeviceIoControlFile returned Status = <%x>, Id=<0x%x>\n", Status, ToiId);
        }

        LocStatus = ZwClose (event);
        ASSERT (NT_SUCCESS(LocStatus));
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmSetTcpInfo",
            "ZwCreateEvent returned Status = <%x>, Id=<0x%x>\n", Status, ToiId);
    }

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_SET_TCP_INFO);

    if (STATUS_SUCCESS == Status)
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_TDI, "PgmSetTcpInfo",
            "ToiId=<%x>, DataLength=<%d>\n", ToiId, DataLength);
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;   // Once, we received a wierd status!
    }

    PgmFreeMem (pTcpInfo);

    return (Status);
}

//----------------------------------------------------------------------------

NTSTATUS
PgmQueryTcpInfo(
    IN HANDLE       FileHandle,
    IN ULONG        ToiId,
    IN PVOID        pDataIn,
    IN ULONG        DataInLength,
    IN PVOID        pDataOut,
    IN ULONG        DataOutLength
    )
/*++

Routine Description:

    This routine queries IP for transport-specific information

Arguments:

    IN  FileHandle      -- FileHandle over IP for which to set option
    IN  ToId            -- Option Id
    IN  pDataIn         -- Option data
    IN  DataInLength    -- pDataIn length
    IN  pDataOut        -- Buffer for output data
    IN  DataOutLength   -- pDataOut length

Return Value:

    NTSTATUS - Final status of the Query operation

--*/
{
    NTSTATUS                            Status, LocStatus;
    TCP_REQUEST_QUERY_INFORMATION_EX    QueryRequest;
    IO_STATUS_BLOCK                     IoStatus;
    HANDLE                              event;
    KAPC_STATE                          ApcState;
    BOOLEAN                             fAttached;

    IoStatus.Status = STATUS_SUCCESS;

    PgmZeroMemory (&QueryRequest, sizeof (TCP_REQUEST_QUERY_INFORMATION_EX));
    QueryRequest.ID.toi_entity.tei_entity   = CL_NL_ENTITY;
    QueryRequest.ID.toi_entity.tei_instance = 0;
    QueryRequest.ID.toi_class               = INFO_CLASS_PROTOCOL;
    QueryRequest.ID.toi_type                = INFO_TYPE_PROVIDER;

    //
    // Set the Configured values
    //
    QueryRequest.ID.toi_id                  = ToiId;
    PgmCopyMemory (&QueryRequest.Context, pDataIn, DataInLength);

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_SET_TCP_INFO);

    Status = ZwCreateEvent (&event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE);
    if (NT_SUCCESS(Status))
    {
        //
        // Make the actual TDI call
        //
        Status = ZwDeviceIoControlFile (FileHandle,
                                        event,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_TCP_QUERY_INFORMATION_EX,
                                        &QueryRequest,
                                        sizeof (TCP_REQUEST_QUERY_INFORMATION_EX),
                                        pDataOut,
                                        DataOutLength);

        //
        // If the call pended and we were supposed to wait for completion,
        // then wait.
        //
        if (Status == STATUS_PENDING)
        {
            Status = NtWaitForSingleObject (event, FALSE, NULL);
            ASSERT (NT_SUCCESS(Status));
        }

        if (NT_SUCCESS (Status))
        {
            Status = IoStatus.Status;
            if (!NT_SUCCESS (Status))
            {
                PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmQueryTcpInfo",
                    "TcpQueryInfoEx request returned Status = <%x>, Id=<0x%x>, DataOutLength=<%d>\n",
                        Status, ToiId, DataOutLength);
            }
        }
        else
        {
            PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmQueryTcpInfo",
                "ZwDeviceIoControlFile returned Status = <%x>, Id=<0x%x>, DataOutLength=<%d>\n",
                    Status, ToiId, DataOutLength);
        }

        LocStatus = ZwClose (event);
        ASSERT (NT_SUCCESS(LocStatus));
    }
    else
    {
        PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmQueryTcpInfo",
            "ZwCreateEvent returned Status = <%x>, Id=<0x%x>\n", Status, ToiId);
    }

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_SET_TCP_INFO);

    if (NT_SUCCESS(Status))
    {
        PgmLog (PGM_LOG_INFORM_STATUS, DBG_TDI, "PgmQueryTcpInfo",
            "ToiId=<%x>, DataInLength=<%d>, DataOutLength=<%d>\n",
                ToiId, DataInLength, DataOutLength);
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;   // Once, we received a wierd status!
    }

    return (Status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmProcessIPRequest(
    IN ULONG        IOControlCode,
    IN PVOID        pInBuffer,
    IN ULONG        InBufferLen,
    OUT PVOID       *pOutBuffer,
    IN OUT ULONG    *pOutBufferLen
    )

/*++

Routine Description:

    This routine performs IOCTL queries into IP

Arguments:

    IOControlCode   - Ioctl to be made into IP
    pInBuffer       - Buffer containing data to be passed into IP
    InBufferLen     - Length of Input Buffer data
    pOutBuffer      - Returned information
    pOutBufferLen   - Initial expected length of Output Buffer + final length

Return Value:

    NTSTATUS - Final status of the operation

--*/

{
    NTSTATUS                Status;
    HANDLE                  hIP;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UNICODE_STRING          ucDeviceName;
    IO_STATUS_BLOCK         IoStatusBlock;
    ULONG                   OutBufferLen = 0;
    KAPC_STATE              ApcState;
    BOOLEAN                 fAttached;
    HANDLE                  Event = NULL;
    UCHAR                   *pIPInfo = NULL;
    PWSTR                   pNameIP = L"\\Device\\IP";

    PAGED_CODE();

    ucDeviceName.Buffer = pNameIP;
    ucDeviceName.Length = (USHORT) (sizeof (WCHAR) * wcslen (pNameIP));
    ucDeviceName.MaximumLength = ucDeviceName.Length + sizeof (WCHAR);
    
    if (pOutBuffer)
    {
        ASSERT (pOutBufferLen);
        OutBufferLen = *pOutBufferLen;  // Save the initial buffer length
        *pOutBuffer = NULL;
        *pOutBufferLen = 0;     // Initialize the return parameter in case we fail below

        if (!OutBufferLen ||
            !(pIPInfo = PgmAllocMem (OutBufferLen, PGM_TAG('I'))))
        {
            PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmProcessIPRequest",
                "STATUS_INSUFFICIENT_RESOURCES\n");

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    InitializeObjectAttributes (&ObjectAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_PROCESS_IP_REQUEST);

    Status = ZwCreateFile (&hIP,
                           SYNCHRONIZE | GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           FILE_OPEN,
                           0,
                           NULL,
                           0);

    //
    // If we succeeded above, let us also try to create the Event handle
    //
    if ((NT_SUCCESS (Status)) &&
        (!NT_SUCCESS (Status = ZwCreateEvent(&Event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE))))
    {
        ZwClose (hIP);
    }

    if (!NT_SUCCESS (Status))
    {
        PgmDetachFsp (&ApcState, &fAttached, REF_FSP_PROCESS_IP_REQUEST);

        PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmProcessIPRequest",
            "status=<%x> -- ZwCreate\n", Status);

        if (pIPInfo)
        {
            PgmFreeMem (pIPInfo);
        }
        return (Status);
    }

    //
    // At this point, we have succeeded in creating the hIP and Event handles,
    // and possibly also the output buffer memory (pIPInfo)
    //
    do
    {
        Status = ZwDeviceIoControlFile(hIP,                 // g_hIPDriverHandle
                                       Event,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       IOControlCode,       // Ioctl
                                       pInBuffer,
                                       InBufferLen,
                                       pIPInfo,
                                       OutBufferLen);

        if (Status == STATUS_PENDING)
        {
            Status = NtWaitForSingleObject (Event,  FALSE, NULL);
            ASSERT(Status == STATUS_SUCCESS);
        }

        Status = IoStatusBlock.Status;
        if (Status == STATUS_BUFFER_OVERFLOW)
        {
            if (!OutBufferLen)
            {
                PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmProcessIPRequest",
                    "IOControlCode=<%x> => overflow when no data expected\n", IOControlCode);

                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            PgmFreeMem (pIPInfo);
            OutBufferLen *=2;
            if (NULL == (pIPInfo = PgmAllocMem (OutBufferLen, PGM_TAG('I'))))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else if (NT_SUCCESS(Status))
        {
            PgmLog (PGM_LOG_INFORM_PATH, DBG_TDI, "PgmProcessIPRequest",
                "Success, Ioctl=<%x>\n", IOControlCode);
        }
        else
        {
            PgmLog (PGM_LOG_ERROR, DBG_TDI, "PgmProcessIPRequest",
                "IOCTL=<%x> returned Status=<%x>\n", IOControlCode, Status);
        }
    } while (Status == STATUS_BUFFER_OVERFLOW);

    ZwClose (Event);
    ZwClose (hIP);
    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_PROCESS_IP_REQUEST);

    if (NT_SUCCESS(Status))
    {
        if ((pOutBuffer) && (pOutBufferLen))
        {
            *pOutBuffer = pIPInfo;
            *pOutBufferLen = OutBufferLen;
        }
        else if (pIPInfo)
        {
            PgmFreeMem (pIPInfo);
        }
    }
    else
    {
        if (pIPInfo)
        {
            PgmFreeMem (pIPInfo);
        }
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\utils.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Utils.c

Abstract:

    This module implements various Utility routines used by
    the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"
#include <stdio.h>


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

ULONG
GetRandomInteger(
    IN  ULONG   StartRange,
    IN  ULONG   EndRange
    )
/*++

Routine Description:

    This routine returns a random integer calculated using the help of SystemTime

Arguments:

    IN  StartRange  -- Lower bound for range
    IN  EndRange    -- upper bound for range

Return Value:

    Random integer between StartRange and EndRange (inclusive)
    If StartRange >= EndRange, then StartRange is returned

--*/
{
    ULONG           Range = (EndRange - StartRange) + 1;
    LARGE_INTEGER   TimeValue;

    if (StartRange >= EndRange)
    {
        return (StartRange);
    }

    KeQuerySystemTime (&TimeValue);
    // the lower 4 bits appear to be zero always...!!
    return (StartRange + ((TimeValue.LowTime >> 8) % Range));
}


//----------------------------------------------------------------------------

VOID
PgmExecuteWorker(
    IN  PVOID     pContextInfo
    )
/*++

Routine Description:

    This routine handles executing delayed requests at non-Dpc level.  If
    the Driver is currently being unloaded, we let the Unload Handler
    complete the request.

Arguments:
    pContext        - the Context data for this Worker thread

Return Value:

    none

--*/

{
    PGM_WORKER_CONTEXT          *pContext = (PGM_WORKER_CONTEXT *) pContextInfo;
    PPGM_WORKER_ROUTINE         pDelayedWorkerRoutine = (PPGM_WORKER_ROUTINE) pContext->WorkerRoutine;
    PGMLockHandle               OldIrq;

    (*pDelayedWorkerRoutine) (pContext->Context1,
                              pContext->Context2,
                              pContext->Context3);

    PgmFreeMem ((PVOID) pContext);


    PgmLock (&PgmDynamicConfig, OldIrq);
    if ((!--PgmDynamicConfig.NumWorkerThreadsQueued) &&
        (PgmDynamicConfig.GlobalFlags & PGM_CONFIG_FLAG_UNLOADING))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        KeSetEvent(&PgmDynamicConfig.LastWorkerItemEvent, 0, FALSE);
    }
    else
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueueForDelayedExecution(
    IN  PVOID                   DelayedWorkerRoutine,
    IN  PVOID                   Context1,
    IN  PVOID                   Context2,
    IN  PVOID                   Context3,
    IN  BOOLEAN                 fConfigLockHeld
    )
/*++

Routine Description:

    This routine simply queues a request on an excutive worker thread
    for later execution.

Arguments:
    DelayedWorkerRoutine- the routine for the Workerthread to call
    Context1            - Context
    Context2
    Context3

Return Value:

    NTSTATUS    -- Final status of the Queue request

--*/
{
    NTSTATUS            status = STATUS_INSUFFICIENT_RESOURCES;
    PGM_WORKER_CONTEXT  *pContext;
    PGMLockHandle       OldIrq;

    if (!fConfigLockHeld)
    {
        PgmLock (&PgmDynamicConfig, OldIrq);
    }

    if (pContext = (PGM_WORKER_CONTEXT *) PgmAllocMem (sizeof(PGM_WORKER_CONTEXT), PGM_TAG('2')))
    {
        PgmZeroMemory (pContext, sizeof(PGM_WORKER_CONTEXT));
        InitializeListHead(&pContext->PgmConfigLinkage);

        pContext->Context1 = Context1;
        pContext->Context2 = Context2;
        pContext->Context3 = Context3;
        pContext->WorkerRoutine = DelayedWorkerRoutine;

        //
        // Don't Queue this request onto the Worker Queue if we have
        // already started unloading
        //
        if (PgmDynamicConfig.GlobalFlags & PGM_CONFIG_FLAG_UNLOADING)
        {
            InsertTailList (&PgmDynamicConfig.WorkerQList, &pContext->PgmConfigLinkage);
        }
        else
        {
            ++PgmDynamicConfig.NumWorkerThreadsQueued;
            ExInitializeWorkItem (&pContext->Item, PgmExecuteWorker, pContext);
            ExQueueWorkItem (&pContext->Item, DelayedWorkQueue);
        }

        status = STATUS_SUCCESS;
    }

    if (!fConfigLockHeld)
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
    }

    return (status);
}



//----------------------------------------------------------------------------
//
// The following routines are temporary and will be replaced by WMI logging
// in the near future
//
//----------------------------------------------------------------------------
NTSTATUS
_PgmLog(
    IN  enum eSEVERITY_LEVEL    Severity,
    IN  ULONG                   Path,
    IN  PUCHAR                  pszFunctionName,
    IN  PUCHAR                  Format,
    IN  va_list                 Marker
    )
/*++

Routine Description:

    This routine

Arguments:

    IN

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    PUCHAR          pLogBuffer = NULL;

    if ((Path & PgmLogFilePath) && (Severity <= PgmLogFileSeverity))
    {
        ASSERT (0);     // Not implemented yet!
    }

    if ((Path & PgmDebuggerPath) && (Severity <= PgmDebuggerSeverity))
    {
        if (MAX_DEBUG_MESSAGE_LENGTH <= (sizeof ("RMCast.") +
                                         sizeof (": ") +
                                         sizeof ("ERROR -- ") +
                                         strlen (pszFunctionName) + 1))
        {
            DbgPrint ("PgmLog:  FunctionName=<%s> too big to print!\n", pszFunctionName);
            return (STATUS_UNSUCCESSFUL);
        }

        if (!(pLogBuffer = ExAllocateFromNPagedLookasideList (&PgmStaticConfig.DebugMessagesLookasideList)))
        {
            DbgPrint ("PgmLog:  STATUS_INSUFFICIENT_RESOURCES Logging %sMessage from Function=<%s>\n",
                ((Severity == PGM_LOG_ERROR || Severity == PGM_LOG_CRITICAL_ERROR) ? "ERROR " : ""), pszFunctionName);
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        strcpy(pLogBuffer, "RMCast.");
        strcat(pLogBuffer, pszFunctionName);
        strcat(pLogBuffer, ": ");

        if ((Severity == PGM_LOG_ERROR) ||
            (Severity == PGM_LOG_CRITICAL_ERROR))
        {
            strcat(pLogBuffer, "ERROR -- ");
        }

        _vsnprintf (pLogBuffer+strlen(pLogBuffer), MAX_DEBUG_MESSAGE_LENGTH-strlen(pLogBuffer), Format, Marker);
        pLogBuffer[MAX_DEBUG_MESSAGE_LENGTH] = '\0';

        DbgPrint ("%s", pLogBuffer);

        ExFreeToNPagedLookasideList (&PgmStaticConfig.DebugMessagesLookasideList, pLogBuffer);
    }

    return (STATUS_SUCCESS);
}



//----------------------------------------------------------------------------
NTSTATUS
PgmLog(
    IN  enum eSEVERITY_LEVEL    Severity,
    IN  ULONG                   Path,
    IN  PUCHAR                  pszFunctionName,
    IN  PUCHAR                  Format,
    ...
    )
/*++

Routine Description:

    This routine

Arguments:

    IN

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    va_list Marker;

    //
    // Based on our Path and the Flags, see if this Event qualifies
    // for being logged
    //
    if (((Path & PgmDebuggerPath) && (Severity <= PgmDebuggerSeverity)) ||
        ((Path & PgmLogFilePath) && (Severity <= PgmLogFileSeverity)))
    {
        va_start (Marker, Format);

        status =_PgmLog (Severity, Path, pszFunctionName, Format, Marker);

        va_end (Marker);
    }

    return (status);
}

//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\amd64\xsum.asm ===
include xsum.amd64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\i386\xsum.asm ===
.xlist
include xsum.x86
.list
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\sys\ia64\xsum.s ===
#include <xsum.ia64>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acs.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ACS.h
		Defines Common Stuff to ACS 

    FILE HISTORY:
		11/12/97	Wei Jiang	Created
        
*/
#include "stdafx.h"
#include "acshand.h"
#include "acs.h"
///////////////////////////////////////////////////////////////////////////////
// ACS Common Dialogs
IMPLEMENT_DYNCREATE(CACSDialog, CHelpDialog)

BEGIN_MESSAGE_MAP(CACSDialog, CHelpDialog)
	//{{AFX_MSG_MAP(CACSDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////////////////////////////////////////////////////////////
// ACS Common Property Pages
IMPLEMENT_DYNCREATE(CACSPage, CManagedPage)

BEGIN_MESSAGE_MAP(CACSPage, CManagedPage)
	//{{AFX_MSG_MAP(CACSPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CACSSubnetPageManager::~CACSSubnetPageManager()
{
	m_spConfig.Release();
	if(m_pHandle)
		m_pHandle->Release();
};

void CACSSubnetPageManager::SetSubnetData(CACSSubnetConfig* pConfig, CACSSubnetHandle* pHandle)
{
	ASSERT(pConfig && pHandle);
	m_spConfig = pConfig;
	m_pHandle = pHandle;
	if(pHandle)
		pHandle->AddRef();
}

BOOL CACSSubnetPageManager::OnApply()
{
	if(CPageManager::OnApply())
	{
		HRESULT	hr = S_OK;
		ASSERT((CACSSubnetConfig*)m_spConfig);
		hr = m_spConfig->Save(GetFlags());

		if FAILED(hr)
			ReportError(hr, IDS_ERR_SAVESUBNETCONFIG, NULL);
		else
		{
//			AfxMessageBox(IDS_WRN_POLICY_EFFECTIVE_FROM_NEXT_RSVP);
			m_pHandle->UpdateStrings();
		}

		ClearFlags();
		MMCNotify();

		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mcast\pgm\test\rmtest.c ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
// 
// Copyright (C) 2000  Microsoft Corporation.  All Rights Reserved.
//
// Module:
//    RMTest.c
//
// Abstract:
//    This sample shows how to send and receive data using the
//    RMcast driver
//    This sample is post-Windows 2000 only.
//
// Usage:
//    RMTest.exe -i:int -a:IP
//           -i:int              Capture on this interface
//                                This is a zero based index of the 
//                                local interfaces
//           -a:IP               Use this MCast address
//
// Build:
//    cl RMTest.c ws2_32.lib
// 
//       OR
//     
//    nmake.exe
//
// Author:
//    Mohammad Shabbir Alam
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <stdlib.h>

#include <winsock2.h>
#include <wsahelp.h>
#include <wsasetup.h>

#include <mstcpip.h>

#include <ws2tcpip.h>

#include <ws2spi.h>
#include <wsahelp.h>

#include <sys\timeb.h>

#include "wsRm.h"

//
// Globals
//
#define SOCK_RMCAST    SOCK_RDM

struct _timeb   StartTime, CurrentTime, PreviousTime;

//
// User-definable variables
//
BOOL    gSetWinsockInfo         = FALSE;
BOOL    gClearWinsockInfo       = FALSE;
BOOL    gReceiver               = FALSE;

DWORD   gInterface              = 0;
LONG    gRateKbitsPerSec        = 56;
LONG    gMinPktSize             = 500;
LONG    gMaxPktSize             = 100000;
LONG    gNumSends               = 10000;
LONG    gStatusInterval         = 100;
LONG    gMCastTtl               = MAX_MCAST_TTL;
ULONG   gLateJoinerPercentage   = 0;
BOOLEAN gfSetMCastTtl           = FALSE;
BOOLEAN gListenOnAllInterfaces  = FALSE;
BOOLEAN gUseSpecifiedInterface  = FALSE;
BOOLEAN gSetLateJoiner          = FALSE;
BOOLEAN gSetLingerTime          = FALSE;

USHORT  gLingerTime             = 0;

ULONG   gMCastGroupAddr         = 0;
USHORT  gMCastGroupPort         = 0;

ULONG   gAfdBufferSize          = 0;
BOOLEAN gfSetAfdBufferSize      = FALSE;
BOOLEAN gfEnumerateProts        = FALSE;
BOOLEAN gfVerifyData            = FALSE;

// FEC vars:
USHORT  gFECBlockSize           = 255;      // Default
UCHAR   gFECGroupSize           = 0;
USHORT  gFECProActive           = 0;
BOOLEAN gfFECOnDemand           = FALSE;

int
GetInterface(
    int     num,
    ULONG   *pIpAddress,
    BOOL    fPrintInterfaces
    );

//
// Function: usage
// 
// Description:
//    Prints usage information.
//
void usage(char *progname)
{
    WSADATA       wsd;

    // Load Winsock
    //
    if (WSAStartup(MAKEWORD(2,2), &wsd) != 0)
    {
        fprintf(stderr, "WSAStartup() failed: %d\n", GetLastError());
        ExitProcess(-1);
    }

    fprintf (stdout, "usage: %s [-l] [-i:Interface] [-a:MCastIP] [-p:Port] [-r:Rate] ...\n", progname);
    fprintf (stdout, "       -a:MCastIP          Use this MCast address (default is 231.7.8.9)\n");
    fprintf (stdout, "       -b:BufferSize       Override Afd's buffer size\n");
    fprintf (stdout, "       -e                  Enumerate all protocols known to Winsock\n");
    fprintf (stdout, "       -j:LateJoiner       Percentage of Window available for LateJoiner\n");
    fprintf (stdout, "       -min:MinPacketSize  must be >= 4, default = 500\n");
    fprintf (stdout, "       -max:MaxPacketSize  must be <= 10 Mb, default = 100000\n\n");
    fprintf (stdout, "       -p:MCastPort        Port # (default is 0)\n");
    fprintf (stdout, "       -s:StatusInterval   Number of messages between status\n\n");

    fprintf (stdout, "       -L[:a]              Listen for RMcast packets (otherwise we are sender)\n");
    fprintf (stdout, "                           -- option a means listen on all interfaces\n\n");
    fprintf (stdout, "       -v:VerifyData       Verify data integrity on the receiver (receiver only)\n");

    fprintf (stdout, "       -F:FECGroupSize     Use FEC, <= 128, & power of 2      (sender only)\n");
    fprintf (stdout, "       -Fo                 OnDemand FEC (FEC must be set)     (sender only)\n");
    fprintf (stdout, "       -Fp:ProactivePkts   Pro-active FEC (FEC must be set)   (sender only)\n");
    fprintf (stdout, "       -n:NumSends         Number of sends, default = 10000   (sender only)\n");
    fprintf (stdout, "       -r:Rate             Send Rate in Kbits/Sec, default=56 (sender only)\n");
    fprintf (stdout, "       -g:LingerTime       LingerTime in seconds              (sender only)\n");
    fprintf (stdout, "       -t:TTL              Send MCast Ttl, default = max = %d (sender only)\n",
        MAX_MCAST_TTL);

    fprintf (stdout, "       -i:Interface        Interface for Send/Capture, default=0\n");
    fprintf (stdout, "             Available interfaces:\n");
    GetInterface (0, NULL, TRUE);

    WSACleanup();
    ExitProcess(-1);
}

//
// Function: ValidateArgs
// 
// Description:
//    This function parses the command line arguments and
//    sets global variables to indicate how the app should act.
//
void ValidateArgs(int argc, char **argv)
{
    int   i;
    char *ptr;

    for(i=1; i < argc; i++)
    {
        if (strlen(argv[i]) < 2)    // Must have '-' or '/' preceding option!
            continue;

        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (tolower(argv[i][1]))
            {
                case 'a':        // Use this MCast address
                    if (gMCastGroupAddr = inet_addr (&argv[i][3]))
                    {
                        break;
                    }

                    usage(argv[0]);

                case 'b':        // Afd's internal buffer size
                    gAfdBufferSize = atoi(&argv[i][3]);
                    gfSetAfdBufferSize = TRUE;
                    break;

                case 'e':
                    gfEnumerateProts = TRUE;
                    break;

                case 'i':        // interface number
                    gInterface = atoi(&argv[i][3]);
                    gUseSpecifiedInterface = TRUE;
                    break;

                case 'j':        // Late Joiner %
                    gSetLateJoiner = TRUE;
                    gLateJoinerPercentage = atoi(&argv[i][3]);
                    break;

                case 'f':
                    if ((tolower (argv[i][2]) == ':') &&
                        ((gFECGroupSize = (UCHAR) atoi (&argv[i][3])) <= 128))
                    {
                        break;
                    }

                    if ((tolower (argv[i][2]) == 'p') &&
                        ((gFECProActive = (UCHAR) atoi (&argv[i][4])) <= 128))
                    {
                        break;
                    }

                    if (tolower (argv[i][2]) == 'o')
                    {
                        gfFECOnDemand = TRUE;
                        break;
                    }

                    usage(argv[0]);

                case 'g':
                    gLingerTime = (USHORT) atoi (&argv[i][3]);
                    gSetLingerTime = TRUE;
                    break;

                case 'l':
                    gReceiver = TRUE;       // we are receiver, otherwise we would have been sender by default
                    if (((argv[i][2]) == ':') &&
                        (tolower (argv[i][3]) == 'a'))
                    {
                        gListenOnAllInterfaces = TRUE;
                    }
                    break;

                case 'm':
                    if ((tolower (argv[i][2]) == 'i') &&
                        ((gMinPktSize = atoi (&argv[i][5])) >= 4))
                    {
                        break;
                    }

                    if ((tolower (argv[i][2]) == 'a') &&
                        ((gMaxPktSize = atoi (&argv[i][5])) <= 10*1000*1000))
                    {
                        break;
                    }

                    usage(argv[0]);

                case 'n':
                    gNumSends = atoi (&argv[i][3]);
                    break;

                case 'p':        // interface number
                    gMCastGroupPort = (USHORT) atoi (&argv[i][3]);
                    break;

                case 'r':
                    if (gRateKbitsPerSec = atoi (&argv[i][3]))
                    {
                        break;
                    }

                    usage(argv[0]);

                case 's':
                    if (gStatusInterval = atoi(&argv[i][3]))
                    {
                        break;
                    }

                    usage(argv[0]);

                case 't':
                    if ((gMCastTtl = atoi(&argv[i][3])) <= MAX_MCAST_TTL)
                    {
                        gfSetMCastTtl = TRUE;
                        break;
                    }

                    usage(argv[0]);

                case 'v':
                    gfVerifyData = TRUE;
                    break;

                case 'x':
                    gSetWinsockInfo = TRUE;
                    break;

                case 'y':
                    gClearWinsockInfo = TRUE;
                    break;

                default:
                    usage(argv[0]);
            }
        }
    }

    //
    // Check FEC parameters
    //
    if ((gFECGroupSize || gFECProActive || gfFECOnDemand) &&
        ((!gFECGroupSize) || !(gFECProActive || gfFECOnDemand)))
    {
        usage(argv[0]);
    }

    return;
}


//
// Function: GetInterface
//
// Description:
//    This function retrieves a zero based index and returns
//    the IP interface corresponding to that.
//
int
GetInterface(
    int     InterfaceNum,
    ULONG   *pIpAddress,
    BOOL    fPrintInterfaces
    )
{
    SOCKET              s;
    SOCKET_ADDRESS_LIST *slist=NULL;
    char                 buf[2048];
    DWORD                dwBytesRet;
    int                  i, ret;

    s = WSASocket(AF_INET, SOCK_RAW, IPPROTO_IP, NULL, 0, WSA_FLAG_OVERLAPPED);
    if (s == INVALID_SOCKET)
    {
        fprintf(stderr, "WSASocket() failed: %d\n", WSAGetLastError());
        return -1;
    }
    ret = WSAIoctl (s, SIO_ADDRESS_LIST_QUERY, NULL, 0, buf, 2048, &dwBytesRet, NULL, NULL);
    if (ret == SOCKET_ERROR)
    {
        fprintf(stderr, "WSAIoctl(SIO_ADDRESS_LIST_QUERY) failed: %d\n",
            WSAGetLastError());
        closesocket(s);
        return -1;
    }
    slist = (SOCKET_ADDRESS_LIST *)buf;
    closesocket(s);

    if (fPrintInterfaces)
    {
        // Just print all local IP interfaces.
        for(i=0; i < slist->iAddressCount ;i++)
        {
            fprintf(stdout, "               %-2d ........ [%s]\n", i, 
                inet_ntoa(((SOCKADDR_IN *)slist->Address[i].lpSockaddr)->sin_addr));
        }
    }
    else
    {
        if (InterfaceNum >= slist->iAddressCount)
        {
            return -1;
        }

        *pIpAddress = (ULONG) ((SOCKADDR_IN *)slist->Address[InterfaceNum].lpSockaddr)->sin_addr.s_addr;
    }

    return 0;
}

// --------------------------------------------------------------
// ****************************************************************


#define RMCAST_PARAM_KEY   \
    L"System\\CurrentControlSet\\Services\\RMCast\\Parameters"

#define RMCAST_WINSOCK_KEY \
    L"System\\CurrentControlSet\\Services\\RMCast\\Parameters\\Winsock"

#define WINSOCK_PARAMS_KEY  \
    L"System\\CurrentControlSet\\Services\\WinSock\\Parameters"

#define RMCAST_TRANSPORT   \
    L"RMCast"

DWORD
SetHelperDllRegInfo(
    )
{
    DWORD               status;
    DWORD               NameLength, mappingSize, Type;
    HKEY                hKey = NULL;
    LPBYTE              mapping = NULL;
    WCHAR               *wshDllPath = L"%SystemRoot%\\system32\\wshrm.dll";
    ULONG               sockAddrLength = sizeof(SOCKADDR_IN);
    WCHAR               *pTransports;
    HANDLE                      hWshRm;
    PWSH_GET_WINSOCK_MAPPING    pMapFunc = NULL;

    system ("sc create RMCast binPath= %SystemRoot%\\system32\\drivers\\RMCast.sys type= kernel");

    //
    // First, create the keys in HKLM / System / CurrentControlSet / Services / RMCast
    //
    status = RegCreateKeyExW (HKEY_LOCAL_MACHINE,       // hkey
                              RMCAST_PARAM_KEY,            // lpSubKey
                              0,                        // reserved
                              NULL,                     // lpclass
                              REG_OPTION_NON_VOLATILE,  // options
                              KEY_ALL_ACCESS,           // samDesired
                              NULL,                     // lpSecurityAttributes
                              &hKey,                    // phkResult
                              NULL);                    // lpdwDisposition
    if (status != NO_ERROR)
    {
        return (status);
    }
    RegCloseKey(hKey);

    status = RegCreateKeyExW (HKEY_LOCAL_MACHINE,       // hkey
                              RMCAST_WINSOCK_KEY,          // lpSubKey
                              0,                        // reserved
                              NULL,                     // lpclass
                              REG_OPTION_NON_VOLATILE,  // options
                              KEY_ALL_ACCESS,           // samDesired
                              NULL,                     // lpSecurityAttributes
                              &hKey,                    // phkResult
                              NULL);                    // lpdwDisposition

    if (status != NO_ERROR)
    {
        return (status);
    }
    RegCloseKey(hKey);

    if (!(hWshRm = LoadLibrary ("wshrm.dll")) ||
        !(pMapFunc = (PWSH_GET_WINSOCK_MAPPING) GetProcAddress (hWshRm, "WSHGetWinsockMapping")))
    {
        if (hWshRm)
        {
            printf ("FAILed to find proc -- WSHGetWinsockMapping -- in wshrm.dll\n");
            FreeLibrary (hWshRm);
        }
        else
        {
            printf ("FAILed to load wshrm.dll\n");
        }

        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Get the winsock mapping data.
    //
    mappingSize = (*pMapFunc) ((PWINSOCK_MAPPING) mapping, 0);
    mapping = LocalAlloc(LMEM_FIXED, mappingSize);
    if (mapping == NULL)
    {
        FreeLibrary (hWshRm);
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    mappingSize = (*pMapFunc) ((PWINSOCK_MAPPING) mapping, mappingSize);

    FreeLibrary (hWshRm);

    //
    // Open the RMCast winsock parameters registry key
    //
    status = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                            RMCAST_WINSOCK_KEY,
                            0,
                            KEY_WRITE,
                            &hKey);

    if (status != ERROR_SUCCESS)
    {
        LocalFree (mapping);
        return (status);
    }

    //
    // Write the required values
    //
    status = RegSetValueExW (hKey,
                             L"Mapping",
                             0,
                             REG_BINARY,
                             (CONST BYTE *) mapping,
                             mappingSize);

    LocalFree (mapping);

    if (status != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (status);
    }

    status = RegSetValueExW (hKey,
                             L"HelperDllName",
                             0,
                             REG_EXPAND_SZ,
                             (CONST BYTE *) wshDllPath,
                             (lstrlenW(wshDllPath) + 1) * sizeof(WCHAR));

    if (status != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (status);
    }

    status = RegSetValueExW (hKey,
                             L"MinSockaddrLength",
                             0,
                             REG_DWORD,
                             (CONST BYTE *) &sockAddrLength,
                             sizeof(DWORD));

    if (status != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (status);
    }

    status = RegSetValueExW (hKey,
                             L"MaxSockaddrLength",
                             0,
                             REG_DWORD,
                             (CONST BYTE *) &sockAddrLength,
                             sizeof(DWORD));

    RegCloseKey (hKey);

    if (status != ERROR_SUCCESS)
    {
        return (status);
    }

    //
    // Now, set the Winsock parameter key
    //
    status = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                            WINSOCK_PARAMS_KEY,
                            0,
                            MAXIMUM_ALLOWED,
                            &hKey);

    if (status != ERROR_SUCCESS)
    {
        return (status);
    }

    mapping = NULL;
    mappingSize = 0;
    status = RegQueryValueExW (hKey,
                               L"Transports",
                               NULL,
                               &Type,
                               mapping,
                               &mappingSize);

    NameLength = (wcslen (RMCAST_TRANSPORT) + 1) * sizeof(WCHAR);
    if ((status == ERROR_MORE_DATA) ||
        ((status == ERROR_SUCCESS) && (mappingSize)))
    {
        mapping = LocalAlloc(LMEM_FIXED, (mappingSize+NameLength));
        if (mapping == NULL)
        {
            RegCloseKey (hKey);
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Append the RMCast entry to the Transports key
        //
        status = RegQueryValueExW (hKey,
                                   L"Transports",
                                   NULL,
                                   &Type,
                                   mapping,
                                   &mappingSize);

        pTransports = (WCHAR *) &mapping[mappingSize-sizeof(WCHAR)];
        wcscpy (pTransports, RMCAST_TRANSPORT);
        pTransports [wcslen(RMCAST_TRANSPORT)] = 0;
        pTransports [wcslen(RMCAST_TRANSPORT)+1] = 0;
    }
    else
    {
        status = ERROR_MORE_DATA;
    }

    if ((status != ERROR_SUCCESS) ||
        (Type != REG_MULTI_SZ))
    {
        if (mapping)
        {
            LocalFree (mapping);
        }
        RegCloseKey (hKey);
        return (status);
    }

    status = RegSetValueExW (hKey,
                             L"Transports",
                             0,
                             REG_MULTI_SZ,
                             mapping,
                             (mappingSize+NameLength));

    LocalFree (mapping);
    RegCloseKey (hKey);

    return (status);
}



DWORD
ClearHelperDllRegInfo(
    )
{
    DWORD               status;
    HKEY                hKey = NULL;
    DWORD               remainingSize, mappingSize, Type, RMNameLength = wcslen (RMCAST_TRANSPORT) + 1;
    LPBYTE              mapping = NULL;
    DWORD               CurStrLenPlusOne;
    WCHAR               *pTransports;

    //
    // Remove the RMCast transport from the Winsock parameter key
    //
    status = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                            WINSOCK_PARAMS_KEY,
                            0,
                            MAXIMUM_ALLOWED,
                            &hKey);

    if (status != ERROR_SUCCESS)
    {
        return (status);
    }

    mapping = NULL;
    mappingSize = 0;
    status = RegQueryValueExW (hKey,
                               L"Transports",
                               NULL,
                               &Type,
                               mapping,
                               &mappingSize);

    if ((status == ERROR_MORE_DATA) ||
        ((status == ERROR_SUCCESS) && (mappingSize)))
    {
        mapping = LocalAlloc(LMEM_FIXED, mappingSize);
        if (mapping == NULL)
        {
            RegCloseKey (hKey);
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        status = RegQueryValueExW (hKey,
                                   L"Transports",
                                   NULL,
                                   &Type,
                                   mapping,
                                   &mappingSize);
    }
    else
    {
        status = ERROR_MORE_DATA;
    }

    if ((status != ERROR_SUCCESS) ||
        (Type != REG_MULTI_SZ))
    {
        if (mapping)
        {
            LocalFree (mapping);
        }
        RegCloseKey (hKey);
        return (status);
    }

    pTransports = (WCHAR *) mapping;
    remainingSize = mappingSize;
    while (*pTransports != L'\0')
    {
        CurStrLenPlusOne = wcslen(pTransports) + 1;
        if (CurStrLenPlusOne > remainingSize)
        {
            status = ERROR_INVALID_DATA;
            break;
        }

        remainingSize -= (CurStrLenPlusOne * sizeof (WCHAR));   // Decrement the amount of buffer unparsed

        // If this string is RMCast
        if ((CurStrLenPlusOne == RMNameLength) &&
            (_wcsicmp( pTransports, RMCAST_TRANSPORT) == 0))
        {
            // Remove this string from the list
            mappingSize -= (RMNameLength * sizeof(WCHAR));
            MoveMemory (pTransports , pTransports + RMNameLength , remainingSize);
        }
        else
        {
            pTransports += CurStrLenPlusOne;                        // Move to the next string
        }

    } // while: the transport list has not been completely parsed.

    status = RegSetValueExW (hKey,
                             L"Transports",
                             0,
                             REG_MULTI_SZ,
                             mapping,
                             mappingSize);

    LocalFree (mapping);
    RegCloseKey (hKey);

    return (status);
}

// ****************************************************************
ULONGLONG       TotalBytes = 0;
ULONGLONG       DataBytes = 0;

ULONG
GetSenderStats(
    SOCKET  s,
    LONG    count
    )
{
    ULONG           BufferLength;
    RM_SENDER_STATS RmSenderStats;
    time_t          DiffTotalSecs, DiffTotalMSecs;
    time_t          DiffPreviousSecs, DiffPreviousMSecs;
    ULONG           ret;

    //   Add 1 below to MSsecs to avoid div by 0
    DiffTotalSecs = CurrentTime.time - StartTime.time;
    DiffTotalMSecs = (1 + CurrentTime.millitm - StartTime.millitm) + (1000 * DiffTotalSecs);

    DiffPreviousSecs = CurrentTime.time - PreviousTime.time;
    DiffPreviousMSecs = (1 + CurrentTime.millitm - PreviousTime.millitm) + (1000 * DiffPreviousSecs);

    BufferLength = sizeof(RM_SENDER_STATS);
    memset (&RmSenderStats, 0, BufferLength);
    ret = getsockopt (s, IPPROTO_RM, RM_SENDER_STATISTICS, (char *)&RmSenderStats, &BufferLength);
    if (ret != ERROR_SUCCESS)
    {
        fprintf (stderr, "GetSenderStats:  Failed to retrieve sender stats!\n");
        return (ret);
    }

    fprintf (stdout, "MessagesSent=<%d>, Interval=[%d.%d / %d.%d]\n",
        count, DiffPreviousSecs, DiffPreviousMSecs, DiffTotalSecs, DiffTotalMSecs);
    fprintf (stdout, "\tDataBytesSent=<%I64d>,  Rate= %d Kbits / Sec\n",
        RmSenderStats.DataBytesSent, (ULONG) ((RmSenderStats.DataBytesSent*BITS_PER_BYTE) / DiffTotalMSecs));
    fprintf (stdout, "\tTotalBytesSent=<%I64d>,  Rate= %d Kbits / Sec\n",
        RmSenderStats.TotalBytesSent, ((RmSenderStats.TotalBytesSent*BITS_PER_BYTE)/DiffTotalMSecs));
    fprintf (stdout, "\tNaksReceived=<%I64d>\n", RmSenderStats.NaksReceived);
    fprintf (stdout, "\tNaksReceivedTooLate=<%I64d>\n", RmSenderStats.NaksReceivedTooLate);
    fprintf (stdout, "\tNumOutstandingNaks=<%I64d>\n", RmSenderStats.NumOutstandingNaks);
    fprintf (stdout, "\tNumNaksAfterRData=<%I64d>\n", RmSenderStats.NumNaksAfterRData);
    fprintf (stdout, "\tRepairPacketsSent=<%I64d>\n", RmSenderStats.RepairPacketsSent);
    fprintf (stdout, "\tBufferSpaceAvailable=<%I64d> bytes\n\n", RmSenderStats.BufferSpaceAvailable);
    fprintf (stdout, "\tLeadingEdgeSeqId=<%I64d>\n", RmSenderStats.LeadingEdgeSeqId);
    fprintf (stdout, "\tTrailingEdgeSeqId=<%I64d>\n", RmSenderStats.TrailingEdgeSeqId);
    fprintf (stdout, "\tSequences in Window=<%I64d>\n", (RmSenderStats.LeadingEdgeSeqId-RmSenderStats.TrailingEdgeSeqId+1));
    fprintf (stdout, "\tRateKBitsPerSecLast=<%I64d>\n", RmSenderStats.RateKBitsPerSecLast);
    fprintf (stdout, "\tRateKBitsPerSecOverall=<%I64d>\n", RmSenderStats.RateKBitsPerSecOverall);

    fprintf (stdout, "\n\tDataBytesSent in last interval=<%I64d>,  Rate= %d Kbits / Sec\n",
        (RmSenderStats.DataBytesSent-DataBytes),
        (ULONG) (BITS_PER_BYTE * (RmSenderStats.DataBytesSent-DataBytes) / DiffPreviousMSecs));
    fprintf (stdout, "\tTotalBytesSent in last interval=<%I64d>,  Rate= %d Kbits / Sec\n\n",
        (RmSenderStats.TotalBytesSent-TotalBytes),
        (ULONG) (BITS_PER_BYTE * (RmSenderStats.TotalBytesSent-TotalBytes)/DiffPreviousMSecs));

    TotalBytes = RmSenderStats.TotalBytesSent;
    DataBytes = RmSenderStats.DataBytesSent;

    fflush (stdout);
    return (ERROR_SUCCESS);
}

ULONG
GetReceiverStats(
    SOCKET  s,
    LONG    count
    )
{
    ULONG               BufferLength;
    RM_RECEIVER_STATS   RmReceiverStats;
    time_t              DiffTotalSecs, DiffTotalMSecs;
    time_t              DiffPreviousSecs, DiffPreviousMSecs;
    ULONG               ret;

    //   Add 1 below to MSsecs to avoid div by 0
    DiffTotalSecs = CurrentTime.time - StartTime.time;
    DiffTotalMSecs = (1 + CurrentTime.millitm - StartTime.millitm) + (1000 * DiffTotalSecs);

    DiffPreviousSecs = CurrentTime.time - PreviousTime.time;
    DiffPreviousMSecs = (1 + CurrentTime.millitm - PreviousTime.millitm) + (1000 * DiffPreviousSecs);

    BufferLength = sizeof(RM_RECEIVER_STATS);
    memset (&RmReceiverStats, 0, BufferLength);
    ret = getsockopt (s, IPPROTO_RM, RM_RECEIVER_STATISTICS, (char *)&RmReceiverStats, &BufferLength);
    if (ret != ERROR_SUCCESS)
    {
        fprintf (stderr, "GetReceiverStats:  Failed to retrieve Receiver stats, ret=<%d>, LastError=<%x>!\n",
            ret, GetLastError());
        return (ret);
    }

    fprintf (stdout, "MessagesRcvd=<%d>, Interval=[%d.%d / %d.%d]\n",
        count, DiffPreviousSecs, DiffPreviousMSecs, DiffTotalSecs, DiffTotalMSecs);
    fprintf (stdout, "\n\tDataBytesReceived in last interval=<%I64d>,  Rate= %d Kbits / Sec\n",
        (RmReceiverStats.DataBytesReceived-DataBytes),
        (ULONG) (BITS_PER_BYTE * (RmReceiverStats.DataBytesReceived-DataBytes) / DiffPreviousMSecs));
    fprintf (stdout, "\tTotalBytesReceived in last interval=<%I64d>,  Rate= %d Kbits / Sec\n\n",
        (RmReceiverStats.TotalBytesReceived-TotalBytes),
        (ULONG) (BITS_PER_BYTE * (RmReceiverStats.TotalBytesReceived-TotalBytes)/DiffPreviousMSecs));

    fprintf (stdout, "\tTotalDataBytesRcvd=<%I64d>,  Rate= %d Kbits / Sec\n",
        RmReceiverStats.DataBytesReceived, (ULONG) ((RmReceiverStats.DataBytesReceived*BITS_PER_BYTE) / DiffTotalMSecs));
    fprintf (stdout, "\tTotalBytesReceived=<%I64d>,  Rate= %d Kbits / Sec\n",
        RmReceiverStats.TotalBytesReceived, ((RmReceiverStats.TotalBytesReceived*BITS_PER_BYTE)/DiffTotalMSecs));
    fprintf (stdout, "\tRateKBitsPerSecLast=<%I64d>\n", RmReceiverStats.RateKBitsPerSecLast);
    fprintf (stdout, "\tRateKBitsPerSecOverall=<%I64d>\n", RmReceiverStats.RateKBitsPerSecOverall);

    fprintf (stdout, "\tNumODataPacketsReceived=<%I64d>\n", RmReceiverStats.NumODataPacketsReceived);
    fprintf (stdout, "\tNumRDataPacketsReceived=<%I64d>\n", RmReceiverStats.NumRDataPacketsReceived);
    fprintf (stdout, "\tNumDuplicateDataPackets=<%I64d>\n", RmReceiverStats.NumDuplicateDataPackets);
    fprintf (stdout, "\tLeadingEdgeSeqId=<%I64d>\n", RmReceiverStats.LeadingEdgeSeqId);
    fprintf (stdout, "\tTrailingEdgeSeqId=<%I64d>\n", RmReceiverStats.TrailingEdgeSeqId);
    fprintf (stdout, "\tSequences in Window=<%I64d>\n\n", (RmReceiverStats.LeadingEdgeSeqId-RmReceiverStats.TrailingEdgeSeqId+1));

    fprintf (stdout, "\tFirstNakSequenceNumber=<%I64d>\n", RmReceiverStats.FirstNakSequenceNumber);
    fprintf (stdout, "\tNumPendingNaks=<%I64d>\n", RmReceiverStats.NumPendingNaks);
    fprintf (stdout, "\tNumOutstandingNaks=<%I64d>\n", RmReceiverStats.NumOutstandingNaks);
    fprintf (stdout, "\tNumDataPacketsBuffered=<%I64d>\n", RmReceiverStats.NumDataPacketsBuffered);
    fprintf (stdout, "\tTotalSelectiveNaksSent=<%I64d>\n", RmReceiverStats.TotalSelectiveNaksSent);
    fprintf (stdout, "\tTotalParityNaksSent=<%I64d>\n\n", RmReceiverStats.TotalParityNaksSent);

    TotalBytes = RmReceiverStats.TotalBytesReceived;
    DataBytes = RmReceiverStats.DataBytesReceived;

    fflush (stdout);
    return (ERROR_SUCCESS);
}

// --------------------------------------------------------------
EnumerateProtocols(
    )
{
#define BUFFER_SIZE 10*1024
    INT                 NumProts, err             = NO_ERROR;
    CHAR                pBuffer[BUFFER_SIZE];
    WSAPROTOCOL_INFOW*   pwpiProtoInfo   = (WSAPROTOCOL_INFOW *) pBuffer;
    WSAPROTOCOL_INFOW*   pwpiInfo   = pwpiProtoInfo;
    DWORD               dwBuffSize      = BUFFER_SIZE;

    if (NumProts = WSCEnumProtocols (NULL, pwpiProtoInfo, &dwBuffSize, &err))
    {
        // Print all protocols
        printf ("WSHEnumProtocols returned <%d>:\n", NumProts);
        for (err = 0; err < NumProts; err++)
        {
            printf ("\t[%d]:\tType=<%x>, ProtocolId=<%x>, Flags=<%x>\n",
                err, pwpiInfo->iSocketType, pwpiInfo->iProtocol, pwpiInfo->dwServiceFlags1);
            pwpiInfo++;
        }
    }
    else
    {
        printf ("WSCEnumProtocols failed: <%d>, dwBuffSize=<%d>\n", err, dwBuffSize);
    }
}

// --------------------------------------------------------------

//
// Function: main
//
// Description:
//    This function loads Winsock, parses the command line, and
//    begins receiving packets. Once a packet is received they
//    are decoded. Because we are receiving IP datagrams, the
//    receive call will return whole datagrams.
//
int __cdecl
main(int argc, char **argv)
{
    SOCKET        s, sockR;
    WSADATA       wsd;
    SOCKADDR_IN   SrcSockAddr;
    SOCKADDR_IN   SAMulticast;
    SOCKADDR_IN   SASender;
    WSA_SETUP_DISPOSITION   disposition;
    ULONG           IpAddress;

    LONG            ret;
    LONG            count, Length, BufferInfo;
    char            *TestBuffer=NULL;
    char            value;

    struct linger   LingerData;
    RM_SEND_WINDOW  RmWindow;
    RM_FEC_INFO     RmFEC;

    time_t          DiffSecs, DiffMSecs;
    LONG            Flags, BytesRead;
    WSABUF          WsaBuf;

    // Parse the command line
    //
    gMCastGroupAddr = inet_addr ("231.7.8.9");
    ValidateArgs(argc, argv);

    if (gClearWinsockInfo)
    {
        //
        // First, stop the service and delete the RMCast registry keys
        //
        system ("sc stop RMCast");
        system ("sc delete RMCast");

        ret = ClearHelperDllRegInfo ();

        if (ret == ERROR_SUCCESS)
        {
            fprintf (stdout, "ClearHelperDllRegInfo  returned <%x>\n", ret);
            //
            // Poke winsock to update the Winsock2 config
            //
            ret = MigrateWinsockConfiguration (&disposition, NULL, 0);
            if (ret != ERROR_SUCCESS)
            {
                fprintf (stderr, "MigrateWinsockConfiguration FAILed <%x>\n", ret);
            }
        }
        else
        {
            fprintf (stderr, "ClearHelperDllRegInfo FAILed <%x>\n", ret);
        }

        if (ret != ERROR_SUCCESS)
        {
            return -1;
        }

        return 0;
    }

    if (gSetWinsockInfo)
    {
        //
        // First, clear any Registry keys that may still be lying around
        // from any previous installation
        //
        ret = ClearHelperDllRegInfo ();

        //
        // Now, rewrite the keys afresh
        //
        ret = SetHelperDllRegInfo ();

        if (ret == ERROR_SUCCESS)
        {
            fprintf (stdout, "SetHelperDllRegInfo  returned <%x>\n", ret);
            //
            // Poke winsock to update the Winsock2 config
            //
            ret = MigrateWinsockConfiguration (&disposition, NULL, 0);
            if (ret != ERROR_SUCCESS)
            {
                fprintf (stderr, "MigrateWinsockConfiguration FAILed <%x>\n", ret);
            }
        }
        else
        {
            fprintf (stderr, "SetHelperDllRegInfo FAILed <%x>\n", ret);
        }

        if (ret != ERROR_SUCCESS)
        {
            return -1;
        }

        return 0;
    }

    ret = 0;
    //
    // Now, check for validity of the parameters
    //
    if (gMinPktSize > gMaxPktSize)
    {
        fprintf (stderr, "ERROR in parameter specification: MinPktSize=%d > MaxPktSize=%d\n",
            gMinPktSize, gMaxPktSize);
        ret = -1;
    }

    if (ret)
    {
        return (ret);
    }

    // Load Winsock
    //
    if (WSAStartup (MAKEWORD(2,2), &wsd) != 0)
    {
        fprintf(stderr, "WSAStartup() failed: %d\n", GetLastError());
        return -1;
    }

    if (gfEnumerateProts)
    {
        EnumerateProtocols();
    }

    TestBuffer = (char *)HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(BYTE) * gMaxPktSize);
    if (!TestBuffer)
    {
        fprintf(stderr, "HeapAlloc() for %d bytes failed: ERROR=%d\n", gMaxPktSize, GetLastError());
        WSACleanup();
        return -1;
    }

    if (gReceiver)
    {
        memset (TestBuffer, '#', gMaxPktSize);
    }
    else
    {
        value = 0;
        for (count = 0; count < gMaxPktSize; count++)
        {
            TestBuffer[count] = value++;
        }
    }

    // Create an RMCast socket
    if (INVALID_SOCKET == (s = WSASocket(AF_INET,
                                         SOCK_RMCAST, 
                                         IPPROTO_RM, 
                                         NULL, 
                                         0, 
                                         (WSA_FLAG_MULTIPOINT_C_LEAF |
                                          WSA_FLAG_MULTIPOINT_D_LEAF))))
    {
        fprintf(stderr, "socket() failed: %d\n", WSAGetLastError());
        HeapFree(GetProcessHeap(), 0, TestBuffer);
        WSACleanup();
        return -1;
    }
    fprintf(stdout, "socket SUCCEEDED, s=<%d>\n", s);

    SAMulticast.sin_family = AF_INET;
    SAMulticast.sin_port   = htons (gMCastGroupPort);
    SAMulticast.sin_addr.s_addr = gMCastGroupAddr;

    if (gReceiver)
    {
        fprintf(stdout, "We are Receiver!\n");

        if (bind (s, (SOCKADDR *) &SAMulticast, sizeof(SAMulticast)))
        {
            fprintf(stderr, "bind to (%s:%d) FAILed, status=<%x>\n",
                inet_ntoa(SAMulticast.sin_addr), ntohs(SAMulticast.sin_port), WSAGetLastError());
        }
        else
        {
            fprintf (stdout, "Bind to <%s> succeeded! ...\n", inet_ntoa(SAMulticast.sin_addr));

            if (gListenOnAllInterfaces)
            {
                count = 0;
                while (0 == GetInterface (count, &IpAddress, FALSE))
                {
                    SrcSockAddr.sin_addr.s_addr = IpAddress;
                    fprintf (stdout, "\t[%d] Listening on <%s>\n", count, inet_ntoa(SrcSockAddr.sin_addr));

                    setsockopt (s, IPPROTO_RM, RM_ADD_RECEIVE_IF, (char *)&IpAddress, sizeof(IpAddress));

                    count++;
                }
            }
            else if (gUseSpecifiedInterface)
            {
                //
                // Set an interface to receive IP packets on
                //
                if (0 == GetInterface (gInterface, &IpAddress, FALSE))
                {
                    SrcSockAddr.sin_addr.s_addr = IpAddress;
                    fprintf (stdout, "\t[%d] Interface is <%s>\n", gInterface, inet_ntoa(SrcSockAddr.sin_addr));

                    setsockopt (s, IPPROTO_RM, RM_ADD_RECEIVE_IF, (char *)&IpAddress, sizeof(IpAddress));
                }
                else
                {
                    fprintf (stderr, "Unable to obtain an interface from GetInterface\n");
                }
            }

            // listen on the socket
            if (listen (s, 1))
            {
                fprintf(stderr, "listen() FAILed, status=<%x>\n", WSAGetLastError());
            }
            else
            {
                fprintf (stdout, "Listen succeeded! ...\n");

                // join an RMCast session
                Length = sizeof (SOCKADDR);
                sockR = accept (s, (SOCKADDR *) &SASender, &Length);
                if (sockR == INVALID_SOCKET)
                {
                    fprintf(stderr, "accept() failed: %d\n", WSAGetLastError());
                }
                else
                {
                    fprintf(stdout, "Accept succeeded!  s=<%d>, sockR=<%d>, Sender=<%s>\n",
                        s, sockR, inet_ntoa(SASender.sin_addr));

                    // start receiving data
//                    memset (TestBuffer, '@', gMaxPktSize);
                    WsaBuf.buf = TestBuffer;
                    WsaBuf.len = gMaxPktSize;

                    count = 0;
                    Length = gMinPktSize;

                    _ftime (&StartTime);
                    while (TRUE)
                    {
                        * ((PULONG) TestBuffer) = 0;
                        Flags = BytesRead = 0;

/*
                        ret = recv (sockR, TestBuffer, gMaxPktSize, 0);
                        if ((ret==0) || (ret == SOCKET_ERROR))
*/
                        ret = WSARecv (sockR,           // socket
                                       &WsaBuf,         // lpBuffers
                                       1,               // dwBufferCount
                                       &BytesRead,      // lpNumberOfBytesRecvd 
                                       &Flags,          // lpFlags
                                       NULL,            // lpOverlapped
                                       NULL);           // lpCompletionRoutine
                        if (ret)
                        {
                            fprintf(stderr, "WSARecv() FAILed==><%d>, ret=<%d>, count=<%d> BytesRead=<%d>\n",
                                WSAGetLastError(), ret, count, BytesRead);
                            break;
                        }

                        if (Flags)
                        {
                            fprintf(stdout, "[%d : %d] WARNING: BytesRead=<%d>, LastError=<%d>, Flags=<%x>\n",
                                count, Length, BytesRead, WSAGetLastError(), Flags);
                        }

                        TotalBytes += BytesRead;

                        _ftime (&CurrentTime);
                        if (!count++)
                        {
                            PreviousTime = StartTime = CurrentTime;
                        }

                        if (!(count % gStatusInterval))
                        {
                            if (ERROR_SUCCESS == GetReceiverStats (sockR, count))
                            {
                                PreviousTime = CurrentTime;
                            }
                        }

                        if (BytesRead != Length)
                        {
                            fprintf(stderr, "OUT-OF-ORDER:  Expecting <%d>, received <%d>\n",
                                Length, BytesRead);
                            fflush (stdout);
                        }
                        else if (BytesRead != * ((PLONG) TestBuffer))
                        {
                            fprintf(stderr, "BAD-DATA ?  First ULONG=<%d>, BytesRead=<%d>\n",
                                * ((PULONG) TestBuffer), BytesRead);
                            fflush (stdout);
                        }
                        else if (gfVerifyData)
                        {
                            value = TestBuffer[4];
                            for (BufferInfo = 5; BufferInfo < BytesRead; BufferInfo++)
                            {
                                if (++value != TestBuffer[BufferInfo])
                                {
                                    fprintf (stderr, "\tCORRUPT buffer!  Count=<%d>, Offset=<%d/%d> -- ActualValue=<%x>!=<%x>\n",
                                        count, BufferInfo, BytesRead, TestBuffer[BufferInfo], value);
                                    fflush (stdout);
                                    break;
                                }
                            }
                        }

                        Length = BytesRead+1;
                        if (Length > gMaxPktSize)
                        {
                            Length = gMinPktSize;
                        }
                    }

                    fprintf (stdout, "************************ Final Stats ***************************\n");
                    GetReceiverStats (sockR, count);

                    closesocket(sockR);
                }
            }
        }
    }
    else
    {
        fprintf(stdout, "We are Sender!\n");

        // Bind the socket socket
        SrcSockAddr.sin_family = AF_INET;
        SrcSockAddr.sin_port   = htons(0);      // let system pick the port #
        SrcSockAddr.sin_addr.s_addr = 0;        // set default interface = 0 for now
        if (bind (s, (SOCKADDR *)&SrcSockAddr, sizeof(SrcSockAddr)))
        {
            fprintf(stderr, "bind(%s:%d) FAILed: %d\n",
                inet_ntoa(SrcSockAddr.sin_addr), ntohs(SrcSockAddr.sin_port), WSAGetLastError());
        }
        else
        {
            fprintf (stdout, "Bind succeeded! ...\n");

            if (gfSetAfdBufferSize)
            {
                if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char *) &gAfdBufferSize, sizeof (gAfdBufferSize)) < 0)
                {
                    fprintf (stderr, "SO_SNDBUF FAILed -- <%x>\n", WSAGetLastError());
                }
                else
                {
                    fprintf (stdout, "SO_SNDBUF SUCCEEDed\n");
                }
            }

            //
            // Set an interface to send IP packets on
            //
            if (gUseSpecifiedInterface)
            {
                if (0 == GetInterface (gInterface, &IpAddress, FALSE))
                {
                    SrcSockAddr.sin_addr.s_addr = IpAddress;
                    fprintf (stdout, "Interface <%d> is <%s>\n", gInterface,inet_ntoa(SrcSockAddr.sin_addr));

                    setsockopt (s, IPPROTO_RM, RM_SET_SEND_IF, (char *)&IpAddress, sizeof(IpAddress));
                }
                else
                {
                    fprintf (stderr, "Unable to obtain an interface from GetInterface\n");
                }
            }

            //
            // Check if we need to set the Linger time
            //
            if (gSetLingerTime)
            {
                LingerData.l_onoff = 1;
                LingerData.l_linger = gLingerTime;

                if (setsockopt (s, SOL_SOCKET, SO_LINGER, (char *) &LingerData, sizeof (struct linger)) < 0)
                {
                    fprintf (stderr, "SO_LINGER FAILed -- <%x>\n", WSAGetLastError());
                }
                else
                {
                    fprintf (stdout, "SO_LINGER SUCCEEDed, Lingertime=<%d>\n", (ULONG) gLingerTime);
                }
            }

            //
            // Set the transmission rate and window size
            //
            RmWindow.RateKbitsPerSec = gRateKbitsPerSec;
            RmWindow.WindowSizeInMSecs = 0;
            RmWindow.WindowSizeInBytes = 0;
//            RmWindow.WindowSizeInBytes = 50*1000*1000;
            ret = setsockopt (s, IPPROTO_RM, RM_RATE_WINDOW_SIZE, (char *)&RmWindow, sizeof(RM_SEND_WINDOW));

            //
            // Now, query the transmission rate and window size (to verify that it got set)
            //
            RmWindow.RateKbitsPerSec = 0;
            Length = sizeof(RM_SEND_WINDOW);
            ret = getsockopt (s, IPPROTO_RM, RM_RATE_WINDOW_SIZE, (char *)&RmWindow, &Length);
            fprintf (stdout, "Rate= %d Kb/sec, WindowSize = %d msecs = %d bytes\n",
                RmWindow.RateKbitsPerSec, RmWindow.WindowSizeInMSecs, RmWindow.WindowSizeInBytes);

            //
            // Set the FEC info if desired
            //
            if (gFECGroupSize)
            {
                RmFEC.FECBlockSize = gFECBlockSize;
                RmFEC.FECGroupSize = gFECGroupSize;
                RmFEC.FECProActivePackets = gFECProActive;
                RmFEC.fFECOnDemandParityEnabled = gfFECOnDemand;

                ret = setsockopt (s, IPPROTO_RM, RM_USE_FEC, (char *)&RmFEC, sizeof(RM_FEC_INFO));
                fprintf (stdout, "RM_USE_FEC: ret = <%x>, gFECGroupSize=<%x>, Pro:OnD=<%x:%x>\n",
                    ret, gFECGroupSize, gFECProActive, gfFECOnDemand);

                RmFEC.FECBlockSize = 0;
                RmFEC.FECGroupSize = 0;
                RmFEC.FECProActivePackets = 0;
                RmFEC.fFECOnDemandParityEnabled = 0;
                Length = sizeof(RM_FEC_INFO);
                ret = getsockopt (s, IPPROTO_RM, RM_USE_FEC, (char *)&RmFEC, &Length);
                fprintf (stdout, "ret=<%x>, BlockSize= %d, GroupSize = %d, ProActive = %d, OnDemand = %s\n",
                    ret, RmFEC.FECBlockSize, RmFEC.FECGroupSize, RmFEC.FECProActivePackets,
                    (RmFEC.fFECOnDemandParityEnabled ? "ENabled" : "DISabled"));
            }

            //
            // Set the Late joiner option
            //
            if (gSetLateJoiner)
            {
                ret = setsockopt (s, IPPROTO_RM, RM_LATEJOIN, (char *)&gLateJoinerPercentage, sizeof(ULONG));
            }

            if (gfSetMCastTtl)
            {
                //
                // Set the MCast packet Ttl
                //
                ret = setsockopt (s, IPPROTO_RM, RM_SET_MCAST_TTL, (char *)&gMCastTtl, sizeof(ULONG));
            }

            //
            // Set the Send-Window Advance-rate
            //
            Length = 20;
            ret = setsockopt (s, IPPROTO_RM, RM_SEND_WINDOW_ADV_RATE, (char *)&Length, sizeof(ULONG));

            //
            // Query the Send-Window Advance-rate
            //
            Length= sizeof(ULONG);
            BufferInfo = 0;
            ret = getsockopt (s, IPPROTO_RM, RM_SEND_WINDOW_ADV_RATE, (char *)&BufferInfo, &Length);
            fprintf (stdout, "ret=<%d>, Length=<%d>, WindowAdvRate=<%d>\n", ret, Length, BufferInfo);

            if (connect (s, (SOCKADDR *)&SAMulticast, sizeof(SAMulticast)))
            {
                fprintf(stderr, "connect to (%s:%d) FAILed, status=<%x>\n",
                    inet_ntoa(SAMulticast.sin_addr), ntohs(SAMulticast.sin_port), WSAGetLastError());
            }
            else
            {
                fprintf (stdout, "Connect to <%s> succeeded! ...\n", inet_ntoa(SAMulticast.sin_addr));

                _ftime (&StartTime);
                PreviousTime = StartTime;

                //
                // Now, send the rest of the data
                //
                Length = gMinPktSize;
                count = 0;
                while (count < gNumSends)
                {
                    * ((PULONG) TestBuffer) = Length;
//                    fprintf (stdout, "\tSending %d/%d  Length=<%d>\n", count, gNumSends, Length);
                    ret = send (s, TestBuffer, Length, 0);
                    if (ret == SOCKET_ERROR)
                    {
                        fprintf(stderr, "[%d]th sendto() failed: %d, Length=<%d>\n",
                            (count+1), WSAGetLastError(), Length);
                        fflush (stdout);

                        break;
                    }

                    Length++;
                    if (Length > gMaxPktSize)
                    {
                        Length = gMinPktSize;
                    }

                    _ftime (&CurrentTime);
                    count++;
                    if (!(count % gStatusInterval))
                    {
                        if (ERROR_SUCCESS == GetSenderStats (s, count))
                        {
                            PreviousTime = CurrentTime;
                        }
                    }
                }

//                fprintf (stdout, "Calling shutdown!\n");
//                shutdown (s, SD_SEND);
                fprintf (stdout, "\nWaiting 10 seconds for receivers to finish receiving ...\n");
                Sleep (10*1000);    // 10 seconds for any receivers to finish receiving data!

                fprintf (stdout, "************************ Final Stats ***************************\n");
                GetSenderStats (s, count);
            }
        }
    }

    HeapFree (GetProcessHeap(), 0, TestBuffer);

    closesocket(s);
    WSACleanup();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acs.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ACS.h
		Defines Common Stuff to ACS 

    FILE HISTORY:
		11/12/97	Wei Jiang	Created
        
*/
#ifndef	_ACS_H_
#define	_ACS_H_

#include "hlptable.h"

//=============================================================================
// Dialog that handles Context Help
//
class CACSDialog : public CHelpDialog	// talk back to property sheet
{
	DECLARE_DYNCREATE(CACSDialog)

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CACSDialog)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
protected:
	CACSDialog() : CHelpDialog()
	{
		SetGlobalHelpTable(ACSHelpTable);
	};
	
public:	
	CACSDialog(UINT nIDTemplate, CWnd* pParent) : CHelpDialog(nIDTemplate, pParent)
	{
		SetGlobalHelpTable(ACSHelpTable);
	};

};


//=============================================================================
// Page that handles Context Help, and talk with CPageManager to do
// OnApply together
//
class CACSPage : public CManagedPage	// talk back to property sheet
{
	DECLARE_DYNCREATE(CACSPage)

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CACSPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
public:	
	CACSPage(UINT nIDTemplate) : CManagedPage(nIDTemplate)
	{
		SetGlobalHelpTable(ACSHelpTable);
	};
protected:
	CACSPage()	{
		SetGlobalHelpTable(ACSHelpTable);
	}
};

class CACSSubnetConfig;
class CACSSubnetHandle;

class CACSSubnetPageManager : public CPageManager
{
public:
	virtual ~CACSSubnetPageManager();
	
	void SetSubnetData(CACSSubnetConfig* pConfig, CACSSubnetHandle* pHandle);
	
	virtual BOOL	OnApply();
protected:	
	CComPtr<CACSSubnetConfig>		m_spConfig;
	CACSSubnetHandle*				m_pHandle;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acsdata.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ACSData.h
		Defines the DataObject classes used in ACS
		
    FILE HISTORY:
    	11/11/97	Wei Jiang			Created

*/
#ifndef	_ACSDATA_H_
#define	_ACSDATA_H_

#include <list>
#include <functional>
#include <algorithm>
#include "..\common\dataobj.h"

class CACSHandle;

// ACS data state
// CDSObject has virtual function to test state
// CACSHandle has virtual function to show state
// currently, only for acspolicy to show confilict state
#define	ACSDATA_STATE_CONFLICT		0x00000001
#define	ACSDATA_STATE_DISABLED		0x00000002
#define	ACSDATA_STATE_NOOBJECT		0x00000004	// no policy defined for the subnet

#define	ERROR_NO_SUCH_OBJECT	0x80072030


#define	ATTR_FLAGS_ALL				0xffffffff
#define	ATTR_FLAGS_NONE				0x0

#define TOMB(n)						((n) / 1024 / 1024)
#define FROMMB(n)					((n) * 1024 * 1024)
#define	TOKBS(n)					((n) / 1024)
#define FROMKBS(n)					((n) * 1024)
#define	MIN2SEC(n)					((n) * 60)
#define	SEC2MIN(n)					((n) / 60)
#define	IS_LARGE_UNLIMIT(large)		((large).LowPart == 0xffffffff && (large).HighPart == 0xffffffff)
#define	SET_LARGE_UNLIMIT(large)	((large.LowPart = 0xffffffff),(large.HighPart = 0xffffffff))
#define	UNLIMIT						0xffffffff
#define	SET_LARGE(l, h, lo)	((l).LowPart = (lo), (l).HighPart = (h))

#define ACSPOLICY_DEFAULT           _T("AcsPolicy0")
#define ACSPOLICY_UNKNOWN           _T("AcsPolicy1")

// to check if the mentioned attribute will have data after the next save
#define ATTR_WILL_EXIST_AFTER_SAVE(a, toBeSaved)	\
	(((toBeSaved & a) != 0 && GetFlags(ATTR_FLAG_SAVE, a) != 0 ) || \
	 ((toBeSaved & a) == 0 && GetFlags(ATTR_FLAG_LOAD, a) != 0 ) )
	
/*
When you create the global conatiner and the Authenticated and
UnAuthenticated user objects you need to set the following default values:

Authenticated user :

	Data rate: 	500 Kbits/sec
	Peak Data rate: 	500 kbits/sec
	Number of flows : 	2

UnAuthenticated user :

	Data rate: 	64 Kbits/sec
	Peak data rate: 	64 kbits/sec
	Number of flows : 	1
*/

#define	ACS_GLOBAL_DEFAULT_DATARATE		FROMKBS(500)
#define ACS_GLOBAL_DEFAULT_PEAKRATE		FROMKBS(500)
#define	ACS_GLOBAL_DEFAULT_FLOWS		2


#define	ACS_GLOBAL_UNKNOWN_DATARATE		FROMKBS(64)
#define	ACS_GLOBAL_UNKNOWN_PEAKRATE		FROMKBS(64)
#define	ACS_GLOBAL_UNKNOWN_FLOWS		1

///////////////////////////////////////////////////////////////////////////////
// CIDSDataObject
// 	Support Addtional format -- CFSTR_DSOBJECTNAMES
//

class	CDSIDataObject : public CDataObject
{
public:
	CDSIDataObject()
	{
		m_bstrADsPath = NULL;
		m_bstrClass = NULL;
	};

	virtual ~CDSIDataObject()
	{
		SysFreeString(m_bstrADsPath);
		SysFreeString(m_bstrClass);
	}

	
public:	
	// Implemented functions of IDataObject
    STDMETHOD(GetData)(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);


    void SetStrings(BSTR path, BSTR cls){m_bstrADsPath = path; m_bstrClass = cls;};


protected:
	BSTR			m_bstrADsPath;
	BSTR			m_bstrClass;

    // Property Page Clipboard formats
    static UINT m_cfDsObjectNames;
};

///////////////////////////////////////////////////////////////////////////////
// CDSAttributes
//
struct CDSAttributeInfo
{
	int			id;
	WCHAR*		name;
	ADSTYPE 	type;
	bool		ifMultiValued;
	DWORD		flag;
};

struct CDSAttribute
{
	CDSAttributeInfo*	pInfo;
	void*				pBuffer;
};

// maximum number of attribute supported
#define	MAX_ATTRIBUTES	32

enum ATTR_FLAG {
ATTR_FLAG_LOAD = 0,
ATTR_FLAG_SAVE,
ATTR_FLAG_TOTAL
};

/////////////////////////////////////////////////////////////////////////////
// CDSObject
class ATL_NO_VTABLE CDSObject :
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CDSObject, &CLSID_DSObject>,
	public IUnknown
{
BEGIN_COM_MAP(CDSObject)
	COM_INTERFACE_ENTRY(IUnknown)
END_COM_MAP()

	CDSObject(bool bNoRefCountOnContainer = FALSE);	// when container keeps ref count of
													// the this child, set bNoRefCountOnContainer to true

	virtual ~CDSObject();

public:	
   	// its own functions
   	// Set information about the DS object, without opening it
   	STDMETHOD(SetInfo)(	CDSObject*	pContainer, 	// container
   						LPCWSTR		clsName,		// class name
   						LPCWSTR		objName 		// object name
   					);

   	// load from DS -- derived need to override, when need to load data
   	STDMETHOD(Open)(	CDSObject*	pContainer, 	// container
   						LPCWSTR		clsName,		// class name
   						LPCWSTR		objName, 		// object name
   						bool		bCreateIfNonExist,	// if create, [in, out]
   						bool		bPersistWhenCreate = true
   					);

   	virtual void SetHandle(CACSHandle* pHandle){ ASSERT(pHandle); m_pHandle = pHandle;};				

   	// load from DS -- derived need to override, when need to load data
   	STDMETHOD(Reopen)();

   	// load from DS -- derived need to override, when need to load data
   	STDMETHOD(Attach)(	CDSObject*	pContainer, 	// container
   						IADs*		pIObject
   					);
   					
	// release the pointers, and free the buffer
   	STDMETHOD(Close)();

   	// save to DS -- derived must override
   	STDMETHOD(Save)(DWORD	dwAttrFlags);

   	// delete the object from DS -- usually not override
   	STDMETHOD(Delete)();

   	// rename the DS object -- usually not override
   	STDMETHOD(Rename)(LPCWSTR szName);

	// called after the object is created, before it actually become persist
	// derived class should set attribute values of the object
	// m_pIObject, m_pIContainer are available to use
	// initialize the attributes in DS should be done in this function
   	STDMETHOD(OnCreate)(DWORD* pdwAttrFlags) { *pdwAttrFlags = 0xffffffff; return S_OK;};

 	// called after the object is open,
 	// m_pIObject, m_pIContainer are available to use
 	// read attributes from DS should be done in this function
   	STDMETHOD(OnOpen)() SAYOK;

 	// called before SetInfo is called to set the object
 	// m_pIObject, m_pIContainer are available to use
 	// write attributes to DS should be done in this function
   	STDMETHOD(OnSave)(DWORD dwAttrFlags) SAYOK;

 	// called after the object is open,
 	// m_pIObject, m_pIContainer are available to use
 	// read attributes from DS should be done in this function
   	STDMETHOD(LoadAttributes)();

 	// called before SetInfo is called to set the object
 	// m_pIObject, m_pIContainer are available to use
 	// write attributes to DS should be done in this function
   	STDMETHOD(SaveAttributes)(DWORD dwAttrFlags);

	//=========================================
	// functions about container

	// add a child object to this container
	STDMETHOD(AddChild)(CDSObject* pObject) SAYOK;

	// remove a child object from this container
	STDMETHOD(RemoveChild)(CDSObject* pObject) SAYOK;

	// remove all children object from this container
	STDMETHOD(RemoveAllChildren)(CDSObject* pObject) SAYOK;

	// ===========================================
	// get the data memebers
   	STDMETHOD(GetIADs)(IADs**	ppIADs);

	// ===========================================
	// get the data memebers
	STDMETHOD(GetString)(CString& str, int nCol);

	// when object is not in the DS
	HRESULT	SetNoObjectState()
	{
		DWORD	state = GetState();
		
		if (Reopen() == ERROR_NO_SUCH_OBJECT)
		{
			SetState(state | ACSDATA_STATE_NOOBJECT);
			return S_FALSE;
		}
		else
		{
			SetState(state & (~ACSDATA_STATE_NOOBJECT));
			return S_OK;
		}
	};
	


   	STDMETHOD_(LPCWSTR, GetName)() { return m_bstrName + 3; /* L"CN="*/};
   	STDMETHOD_(LPCWSTR, GetADsPath)() { return m_bstrADsPath;};
   	STDMETHOD_(LPCWSTR, GetClass)() { return m_bstrClass;};
	STDMETHOD_(CDSObject*, GetContainer)()
	{
		if((CDSObject*)m_spContainer)
			m_spContainer->AddRef();
		return (CDSObject*)m_spContainer;
	};
	
	STDMETHOD_(CStrArray*, GetChildrenNameList)() { return NULL;};

	virtual	CDSAttribute*	GetAttributes() { return NULL;};
	
	// load attribute changes the flags, and save attribute uses the flag
	DWORD	GetFlags(ATTR_FLAG load_or_save, DWORD flags)
	{
		ASSERT(load_or_save < ATTR_FLAG_TOTAL);
		return (m_dwAttributeFlags[load_or_save] & flags);
	};

	void	ClearFlags(ATTR_FLAG load_or_save)
	{
		ASSERT(load_or_save < ATTR_FLAG_TOTAL);
		m_dwAttributeFlags[load_or_save] = 0;
	};
	
	void	SetFlags(ATTR_FLAG load_or_save, DWORD flags, bool bSet)
	{	
		ASSERT(load_or_save < ATTR_FLAG_TOTAL);
		if(bSet)
			m_dwAttributeFlags[load_or_save] |= flags;
		else	// clear the flags
			m_dwAttributeFlags[load_or_save] &= (~flags);
	};

	virtual HRESULT SetState(DWORD state);
	virtual DWORD	GetState() { return m_dwState;};
	
	HRESULT	MakeSureExist(BOOL *pNewCreated)
	{
		HRESULT	hr = Reopen();

		if(hr == ERROR_NO_SUCH_OBJECT)	// not exist
		{
			ASSERT(m_spContainer.p && m_bstrClass && m_bstrName);
			hr = Open(m_spContainer, m_bstrClass, m_bstrName, true /* create if non exist*/, true /* not persist when create */);
			if(pNewCreated)
				*pNewCreated = TRUE;
		}
		else if(pNewCreated)
			*pNewCreated = FALSE;
		
		return hr;
	};

	// return resource error ID, 0 means OK
	virtual UINT	PreSaveVerifyData(DWORD toBeSavedAttributes) { return 0;};
	
	bool	IfOpened() { return (m_spIADs.p != NULL);};
	bool	IfNewCreated() { return m_bNewCreated;};
//================================================
// protected data section
protected:
	CComPtr<IADs>			m_spIADs;
	CComPtr<CDSObject>		m_spContainer;

	BSTR			m_bstrADsPath;
	BSTR			m_bstrClass;
	BSTR			m_bstrName;

	bool			m_bNewCreated;
	bool			m_bNoRefCountOnContainer;
	bool			m_bOpened;

	CACSHandle*		m_pHandle;	// not ref counted
	DWORD			m_dwState;	// the state of the object, current being used by policy to show conflict

	// used set if an paricular attribute are loaded, or need to be saved
	DWORD			m_dwAttributeFlags[ATTR_FLAG_TOTAL];	
};

//=============================================================================
// container object for subnetworks container and policy container
template <class T>
class	CACSContainerObject :	public CDSObject
{
public:
	CACSContainerObject(bool bNoRefCountOnContainer = FALSE) : CDSObject(bNoRefCountOnContainer)
	{
		m_bListed = false;
	}

	virtual ~CACSContainerObject()
	{
		m_listChildrenName.DeleteAll();
	}

public:	
	//=========================================
	// functions about container

	// add a child object to this container
	STDMETHOD(AddChild)(CDSObject* pObject)
	{
		CString*	pStr = new CString();

		*pStr = pObject->GetName();
		m_listChildrenName.Add(pStr);

		// childrenlist
		m_listChildren.push_back(pObject);
		
		return S_OK;
	}

	// remove a child object from this container
	STDMETHOD(RemoveChild)(CDSObject* pObject)
	{
		// childrenlist
		std::list<CDSObject*>::iterator	j;
		j = std::find(m_listChildren.begin(), m_listChildren.end(), pObject);
		if(j!= m_listChildren.end())
			m_listChildren.erase(j);

		// name list
		CString Str;

		Str = pObject->GetName();
		int i = m_listChildrenName.Find(Str);

		if(i >= 0)
		{
			CString*	pStr = m_listChildrenName[(INT_PTR)i];
			m_listChildrenName.RemoveAt(i);
			delete pStr;
			return S_OK;
		}
		else
			return S_FALSE;
	};

	// remove all children object from this container
	STDMETHOD(RemoveAllChildren)()
	{
		// childrenlist
		m_listChildren.erase(m_listChildren.begin(), m_listChildren.end());

		m_listChildrenName.DeleteAll();
		return S_OK;

	};

   	// delete the object from DS -- usually not override
   	STDMETHOD(Delete)()
   	{
   		HRESULT	hr = CDSObject::Delete();
		if (hr == S_OK)
			RemoveAllChildren();

		return hr;
   	};

	// create DSObject(Type T) for children under the container,
	// create the children name list at the same time
	HRESULT ListChildren(std::list<T*>& children, BSTR clsName);

	STDMETHOD_(CStrArray*, GetChildrenNameList)()
	{	
		if(!m_bListed)
		{
			std::list<T*>	children;

			if(S_OK != ListChildren(children, NULL))
				return NULL;
		}
		return &m_listChildrenName;
	};

//================================================
// protected data section
protected:
	//== list of children's name
	CStrArray				m_listChildrenName;
	std::list<CDSObject*>	m_listChildren;	// no ref count on children

	bool		m_bListed;
};

///////////////////////////////////////////////////////////////////////////////
//
// CACSPolicyElement : policy in DS is still a folder which is capable of
//					holding multiple policy data
//					while, for this version there is one DS object with predefined
//					name defined in policy folder
//

enum ACS_POLICY_ATTRIBUTE_ID {
	ACS_PAI_INVALID	= 0	,
	ACS_PAI_TIMEOFDAY		,
	ACS_PAI_DIRECTION		,
	ACS_PAI_PF_TOKENRATE	,
	ACS_PAI_PF_PEAKBANDWIDTH,
	ACS_PAI_PF_DURATION		,
	ACS_PAI_SERVICETYPE		,
	ACS_PAI_PRIORITY		,
	ACS_PAI_PERMISSIONBITS	,
	ACS_PAI_TT_FLOWS		,
	ACS_PAI_TT_PEAKBANDWIDTH,
	ACS_PAI_TT_TOKENRATE	,
	ACS_PAI_IDENTITYNAME,
	__ACS_PAI_COUNT
};

// flag for each attribute
#define	ACS_PAF_TIMEOFDAY		0x00000001
#define	ACS_PAF_DIRECTION		0x00000002
#define	ACS_PAF_PF_TOKENRATE	0x00000004
#define	ACS_PAF_PF_PEAKBANDWIDTH 0x00000008
#define	ACS_PAF_PF_DURATION		0x00000010
#define	ACS_PAF_SERVICETYPE		0x00000020
#define	ACS_PAF_PRIORITY		0x00000040
#define	ACS_PAF_PERMISSIONBITS	0x00000080
#define	ACS_PAF_TT_FLOWS		0x00000100
#define	ACS_PAF_TT_TOKENRATE	0x00000200
#define	ACS_PAF_TT_PEAKBANDWIDTH 0x00000400
#define	ACS_PAF_IDENTITYNAME	0x00000800

class CPgTraffic;

struct CACSPolicyElementData{
	// data memebers of policy
	CStrArray					m_strArrayTimeOfDay;	// not support in this version
	ADS_INTEGER					m_dwDirection;
	ADS_LARGE_INTEGER			m_ddPFTokenRate;
	ADS_LARGE_INTEGER			m_ddPFPeakBandWidth;
	ADS_INTEGER					m_dwPFDuration;
	ADS_INTEGER					m_dwServiceType;
	ADS_INTEGER					m_dwPriority;
	ADS_LARGE_INTEGER			m_ddPermissionBits;
	ADS_INTEGER					m_dwTTFlows;
	ADS_LARGE_INTEGER			m_ddTTPeakBandWidth;
	ADS_LARGE_INTEGER			m_ddTTTokenRate;
	CStrArray					m_strArrayIdentityName;
	CACSPolicyElementData()
	{
		m_dwDirection = 0;
		SET_LARGE(m_ddPFTokenRate,0,0);
		SET_LARGE(m_ddPFPeakBandWidth, 0, 0);
		m_dwPFDuration  = 0;
		m_dwServiceType = 0;
		m_dwPriority = 0;
		SET_LARGE(m_ddPermissionBits,0,0);
		m_dwTTFlows = 0;
		SET_LARGE(m_ddTTPeakBandWidth,0,0);
		SET_LARGE(m_ddTTTokenRate,0,0);
	};
	~CACSPolicyElementData(){
		m_strArrayIdentityName.DeleteAll();
		};
};

enum AcsPolicyType
{
	ACSPOLICYTYPE_DEFAULT,
	ACSPOLICYTYPE_UNKNOWN,
	ACSPOLICYTYPE_USER,
	ACSPOLICYTYPE_OU
};

#define	ACSPOLICYTYPE_DELIMITER	_T(':')

// enterprise level default
#define	DEFAULT_AU_DATARATE	FROMKBS(64)			// default data rate for Any Unauthenticated User
#define	DEFAULT_AA_DATARATE	FROMKBS(500)		// default data rate for Any Authenticated User

enum	UserPolicyType
{
	UNDEFINED = 0,
	GLOBAL_ANY_AUTHENTICATED,
	GLOBAL_ANY_UNAUTHENTICATED,
};

class CACSPolicyContainer;
//
// IdentityName attribute of policy is as format
// 2:USerDN or 3:OUDN or 0 or 1  0-- for default, 1-- for unknown
//
class	CACSPolicyElement :	public CDSObject, public CACSPolicyElementData
{
public:
	~CACSPolicyElement()
	{
	};

	CACSPolicyElement() : CDSObject(true)
	{
		void*	pVoid;
		
		CDSAttributeInfo* pInfo = m_aPolicyAttributeInfo;

		m_bUseName_NewPolicy = FALSE;

		int	count = 0;
		while(pInfo && pInfo->id)
		{
			m_aAttributes[count].pInfo = pInfo;
			switch(pInfo->id)
			{
			case ACS_PAI_TIMEOFDAY:        pVoid = (void*)&m_strArrayTimeOfDay;	break;// n
			case ACS_PAI_DIRECTION:        pVoid = (void*)&m_dwDirection;	break;
			case ACS_PAI_PF_TOKENRATE:     pVoid = (void*)&m_ddPFTokenRate;	break;
			case ACS_PAI_PF_PEAKBANDWIDTH: pVoid = (void*)&m_ddPFPeakBandWidth;	break;
			case ACS_PAI_PF_DURATION:      pVoid = (void*)&m_dwPFDuration;	break;
			case ACS_PAI_SERVICETYPE:      pVoid = (void*)&m_dwServiceType;	break;
			case ACS_PAI_PRIORITY:         pVoid = (void*)&m_dwPriority;	break;
			case ACS_PAI_PERMISSIONBITS:   pVoid = (void*)&m_ddPermissionBits;	break;
			case ACS_PAI_TT_FLOWS:         pVoid = (void*)&m_dwTTFlows;	break;
			case ACS_PAI_TT_PEAKBANDWIDTH: pVoid = (void*)&m_ddTTPeakBandWidth;	break;
			case ACS_PAI_TT_TOKENRATE:     pVoid = (void*)&m_ddTTTokenRate;	break;
			case ACS_PAI_IDENTITYNAME:     pVoid = (void*)&m_strArrayIdentityName; break;
			default:	ASSERT(0);	break; // this should NOT happen
			}
			m_aAttributes[count++].pBuffer = pVoid;
			pInfo++;
		}
		m_aAttributes[count].pInfo = 0;
		m_aAttributes[count].pBuffer = 0;

	};

	DWORD SetGlobalDefault()
	// returning the flags which are the attributes have been set
	{
		// Direction and Service Type
		m_dwDirection = ACS_DIRECTION_BOTH;
		m_dwServiceType = ACS_SERVICETYPE_ALL;

		// make it Default
		CString* pStr = new CString(_T("0"));
		m_strArrayIdentityName.DeleteAll();
		m_strArrayIdentityName.Add(pStr);

		// Per flow rate

		// Total
		m_dwTTFlows = ACS_GLOBAL_DEFAULT_FLOWS;
		m_ddTTTokenRate.LowPart = ACS_GLOBAL_DEFAULT_DATARATE;
		m_ddTTTokenRate.HighPart = 0;
		m_ddTTPeakBandWidth.LowPart = ACS_GLOBAL_DEFAULT_PEAKRATE;
		m_ddTTPeakBandWidth.HighPart = 0;
		
		return  (ACS_PAF_DIRECTION | ACS_PAF_SERVICETYPE | ACS_PAF_IDENTITYNAME // dirction, service type, identity
							// per flow
				 | ACS_PAF_TT_FLOWS | ACS_PAF_TT_TOKENRATE | ACS_PAF_TT_PEAKBANDWIDTH);	// total
	};


	// return resource error ID, 0 means OK
	virtual UINT	PreSaveVerifyData(DWORD toBeSavedAttributes, UserPolicyType type)
	{
		// special checking for Global Any Authenticated, and Any Unauthenticated
		if(type == GLOBAL_ANY_AUTHENTICATED || type == GLOBAL_ANY_UNAUTHENTICATED)
		{
			UINT	dataRateLimit;
			if(type == GLOBAL_ANY_AUTHENTICATED)	
				dataRateLimit =	DEFAULT_AA_DATARATE;
			else
				dataRateLimit =	DEFAULT_AU_DATARATE;
				
			// total data rate and data rate -- one of them set to default
			if(ATTR_WILL_EXIST_AFTER_SAVE(ACS_PAF_PF_TOKENRATE, toBeSavedAttributes)
				&& ATTR_WILL_EXIST_AFTER_SAVE( ACS_PAF_TT_TOKENRATE, toBeSavedAttributes) == 0
				&& (!IS_LARGE_UNLIMIT(m_ddPFTokenRate))
				&& m_ddPFTokenRate.LowPart > dataRateLimit)
				return IDS_ERR_TOTALRATE_LESS_RATE;

			if(ATTR_WILL_EXIST_AFTER_SAVE(ACS_PAF_PF_TOKENRATE, toBeSavedAttributes) == 0
				&& ATTR_WILL_EXIST_AFTER_SAVE( ACS_PAF_TT_TOKENRATE, toBeSavedAttributes)
				&& (!IS_LARGE_UNLIMIT(m_ddTTTokenRate))
				&& dataRateLimit > m_ddTTTokenRate.LowPart)
				return IDS_ERR_TOTALRATE_LESS_RATE;
		}
		
		// data rate .. peak data rate
		if(ATTR_WILL_EXIST_AFTER_SAVE(ACS_PAF_PF_TOKENRATE, toBeSavedAttributes)
			&& ATTR_WILL_EXIST_AFTER_SAVE(ACS_PAF_PF_PEAKBANDWIDTH, toBeSavedAttributes)
			&& (!IS_LARGE_UNLIMIT(m_ddPFTokenRate)) && (!IS_LARGE_UNLIMIT(m_ddPFPeakBandWidth))
			&& m_ddPFTokenRate.LowPart > m_ddPFPeakBandWidth.LowPart)

			return IDS_ERR_PEAKRATE_LESS_RATE;

		// total data rate and data rate
		if(ATTR_WILL_EXIST_AFTER_SAVE(ACS_PAF_PF_TOKENRATE, toBeSavedAttributes)
			&& ATTR_WILL_EXIST_AFTER_SAVE( ACS_PAF_TT_TOKENRATE, toBeSavedAttributes)
			&& (!IS_LARGE_UNLIMIT(m_ddPFTokenRate)) && (!IS_LARGE_UNLIMIT(m_ddTTTokenRate))
			&& m_ddPFTokenRate.LowPart > m_ddTTTokenRate.LowPart)
			return IDS_ERR_TOTALRATE_LESS_RATE;

		// total data rate and total peak ...
		if(ATTR_WILL_EXIST_AFTER_SAVE(ACS_PAF_TT_PEAKBANDWIDTH, toBeSavedAttributes)
			&& ATTR_WILL_EXIST_AFTER_SAVE( ACS_PAF_TT_TOKENRATE, toBeSavedAttributes)
			&& (!IS_LARGE_UNLIMIT(m_ddTTTokenRate)) && (!IS_LARGE_UNLIMIT(m_ddTTPeakBandWidth))
			&& m_ddTTTokenRate.LowPart > m_ddTTPeakBandWidth.LowPart)
			return IDS_ERR_TOTALPEAK_LESS_TOTALRATE;

		// peak rate and total peak
		if(ATTR_WILL_EXIST_AFTER_SAVE( ACS_PAF_TT_PEAKBANDWIDTH, toBeSavedAttributes)
			&& ATTR_WILL_EXIST_AFTER_SAVE(ACS_PAF_PF_PEAKBANDWIDTH, toBeSavedAttributes)
			&& (!IS_LARGE_UNLIMIT(m_ddPFPeakBandWidth)) && (!IS_LARGE_UNLIMIT(m_ddTTPeakBandWidth))
			&& m_ddPFPeakBandWidth.LowPart > m_ddTTPeakBandWidth.LowPart)
			return IDS_ERR_TOTALPEAK_LESS_PEAK;
		return 0;
	};
	
	DWORD SetGlobalUnknown()
	// returning the flags which are the attributes have been set
	{

		// Direction and ServiceType
		m_dwDirection = ACS_DIRECTION_BOTH;
		m_dwServiceType = ACS_SERVICETYPE_ALL;

		CString* pStr = new CString(_T("1"));
		m_strArrayIdentityName.DeleteAll();
		m_strArrayIdentityName.Add(pStr);

		// Per flow

		// Total
		m_dwTTFlows = ACS_GLOBAL_UNKNOWN_FLOWS;
		m_ddTTTokenRate.LowPart = ACS_GLOBAL_UNKNOWN_DATARATE;
		m_ddTTTokenRate.HighPart = 0;
		m_ddTTPeakBandWidth.LowPart = ACS_GLOBAL_UNKNOWN_PEAKRATE;
		m_ddTTPeakBandWidth.HighPart = 0;

		return  (ACS_PAF_DIRECTION | ACS_PAF_SERVICETYPE | ACS_PAF_IDENTITYNAME // dirction, service type, identity
							// per flow
				 | ACS_PAF_TT_FLOWS | ACS_PAF_TT_TOKENRATE | ACS_PAF_TT_PEAKBANDWIDTH);	// total
	};
	
	DWORD SetDefault()
	// returning the flags which are the attributes have been set
	{
		// Direction and ServiceType
		m_dwDirection = ACS_DIRECTION_BOTH;
		m_dwServiceType = ACS_SERVICETYPE_ALL;

		CString* pStr = new CString(_T("0"));
		m_strArrayIdentityName.Add(pStr);

		return  (ACS_PAF_DIRECTION | ACS_PAF_SERVICETYPE | ACS_PAF_IDENTITYNAME);
	};


	DWORD SetUnknown()
	// returning the flags which are the attributes have been set
	{
		// Direction and ServiceType
		m_dwDirection = ACS_DIRECTION_BOTH;
		m_dwServiceType = ACS_SERVICETYPE_ALL;

		CString* pStr = new CString(_T("1"));
		m_strArrayIdentityName.Add(pStr);

		return  (ACS_PAF_DIRECTION | ACS_PAF_SERVICETYPE | ACS_PAF_IDENTITYNAME);
	};
	
	virtual	CDSAttribute*	GetAttributes() { return &(m_aAttributes[0]);};

	// identity type
	int	GetIdentityType(int* pStrOffset) const	// return -1, of the type is not recognized, or IdentityName doesn't exist
	{
		if(m_strArrayIdentityName.GetSize() == 0)	return -1;

		ASSERT(m_strArrayIdentityName.GetSize() == 1);	// more than one is not expected in this version
		CString	strIdentityName(*m_strArrayIdentityName.GetAt(0));
		int i = strIdentityName.Find(ACSPOLICYTYPE_DELIMITER);

		if(i != -1)
		{
			*pStrOffset = i+1;
			strIdentityName = strIdentityName.Left(i);
		}

		return _ttoi(strIdentityName);
	};

	int	GetIdentityType(CString& Str) const	// return -1, of the type is not recognized, or IdentityName doesn't exist
	{
		int Offset;

		int	Id = GetIdentityType(&Offset);

		if(Id != -1)
			Str = m_strArrayIdentityName[0]->Mid(Offset);

		return Id;
	}

	bool IsConflictInContainer();
	
	void InvalidateConflictState();
	
	bool IsConflictWith(const CACSPolicyElement& policy)
	{
		// disabled
		if(m_dwServiceType == ACS_SERVICETYPE_DISABLED || policy.m_dwServiceType == ACS_SERVICETYPE_DISABLED)
			return false;
			
		if(policy.m_strArrayIdentityName.GetSize() == 0 || m_strArrayIdentityName.GetSize() ==0)
			return false;

		if(m_dwServiceType != policy.m_dwServiceType)
			return false;

		if((m_dwDirection & policy.m_dwDirection) == 0)
			return false;

		if(m_strArrayIdentityName[(INT_PTR)0]->CompareNoCase(*policy.m_strArrayIdentityName[0]) != 0)
			return false;

		return true;
	};

	bool IsServiceTypeDisabled()
	{
		return (m_dwServiceType == ACS_SERVICETYPE_DISABLED);
	};

	// ===========================================
	// get the data memebers
	STDMETHOD(GetString)(CString& str, int nCol);

	BOOL m_bUseName_NewPolicy;
protected:
	static	CString				m_strDirectionSend;
	static	CString				m_strDirectionReceive;
	static	CString				m_strDirectionBoth;
	static	CString				m_strServiceTypeAll;
	static	CString				m_strServiceTypeBestEffort;
	static	CString				m_strServiceTypeControlledLoad;
	static	CString				m_strServiceTypeGuaranteedService;
	static	CString				m_strServiceTypeDisabled;
	static	CString				m_strDefaultUser;
	static	CString				m_strUnknownUser;
	
	static	CDSAttributeInfo	m_aPolicyAttributeInfo[];
	CDSAttribute				m_aAttributes[__ACS_PAI_COUNT];
};

///////////////////////////////////////////////////////////////////////////////
//
// CACSPolicyContainer
//
class	CACSPolicyContainer :	public CACSContainerObject<CACSPolicyElement>
{
public:

	bool IsConflictWithExisting(CACSPolicyElement* pPolicy)
	// NO REF COUNT CHANGE
	{
		std::list<CDSObject*>::iterator	i;
		bool	bConflict = false;
		CACSPolicyElement*	pExisting = NULL;

		for(i = m_listChildren.begin(); !bConflict && i != m_listChildren.end(); i++)
		{
			pExisting = dynamic_cast<CACSPolicyElement*>(*i);
			bConflict = ((pExisting != pPolicy) && pExisting->IsConflictWith(*pPolicy));
		}

		return bConflict;
	};

	// return # of conflict, this is always even number
	UINT SetChildrenConflictState()
	{
		std::list<CDSObject*>::iterator	i;
		CACSPolicyElement*	pSubject = NULL;
		UINT	count = 0;
		for(i = m_listChildren.begin(); i != m_listChildren.end(); i++)
		{
			pSubject = dynamic_cast<CACSPolicyElement*>(*i);
			ASSERT(pSubject);

			DWORD	state = pSubject->GetState();

			if(IsConflictWithExisting(pSubject))
			{
				count++;
				state = (state | ACSDATA_STATE_CONFLICT);
			}
			else
			{
				state = (state & (~ACSDATA_STATE_CONFLICT));
			}

			if(pSubject->IsServiceTypeDisabled())
			{
				state = (state | ACSDATA_STATE_DISABLED);
			}
			else
			{
				state = (state & (~ACSDATA_STATE_DISABLED));
			}

			pSubject->SetState(state);
		}
		return count;
	};
};


///////////////////////////////////////////////////////////////////////////////
//
// CACSGlobalObject
//
class	CACSGlobalObject :	public CACSPolicyContainer
{
public:
   	// load from DS -- derived need to override, when need to load data
   	STDMETHOD(Open)();
  	STDMETHOD(OnOpen)();

   	UINT	m_nOpenErrorId;
   	CString	m_strDomainName;
};

///////////////////////////////////////////////////////////////////////////////
//
// CACSGlobalObject
//
class	CACSSubnetsObject :	public CACSContainerObject<CDSObject>
{
public:
   	// load from DS -- derived need to override, when need to load data
   	STDMETHOD(Open)();
};

///////////////////////////////////////////////////////////////////////////////
//
// CACSSubnetConfig : subnet in DS is still a folder which is capable of
//					holding config object, users folder and profiles holder,
//					the class defined here is the config object contained in
// 					subnet object
//

enum ACS_SUBNET_CONFIG_ATTRIBUTE_ID {
	ACS_SCAI_INVALID	= 0	,
	ACS_SCAI_ALLOCABLERSVPBW,
	ACS_SCAI_MAXPEAKBW,
	ACS_SCAI_ENABLERSVPMESSAGELOGGING,
	ACS_SCAI_EVENTLOGLEVEL,
	ACS_SCAI_ENABLEACSSERVICE,
	ACS_SCAI_MAX_PF_TOKENRATE,
	ACS_SCAI_MAX_PF_PEAKBW,
	ACS_SCAI_MAX_PF_DURATION,
	ACS_SCAI_RSVPLOGFILESLOCATION,
	ACS_SCAI_DESCRIPTION,
	ACS_SCAI_MAXNOOFLOGFILES,
	ACS_SCAI_MAXSIZEOFRSVPLOGFILE,
	ACS_SCAI_DSBMPRIORITY,
	ACS_SCAI_DSBMREFRESH,
	ACS_SCAI_DSBMDEADTIME,
	ACS_SCAI_CACHETIMEOUT,
	ACS_SCAI_NONRESERVEDTXLIMIT,

	// accounting -- added by WeiJiang 2/16/98
	ACS_SCAI_ENABLERSVPMESSAGEACCOUNTING,
	ACS_SCAI_RSVPACCOUNTINGFILESLOCATION,
	ACS_SCAI_MAXNOOFACCOUNTINGFILES,		
	ACS_SCAI_MAXSIZEOFRSVPACCOUNTINGFILE,

	// server list
	ACS_SCAI_SERVERLIST,
	// the total count of the elementas
	__ACS_SCAI_COUNT
};

// bit flags for the attributes
#define	ACS_SCAF_ALLOCABLERSVPBW			0x00000001
#define	ACS_SCAF_MAXPEAKBW					0x00000002
#define	ACS_SCAF_ENABLERSVPMESSAGELOGGING	0x00000004
#define	ACS_SCAF_EVENTLOGLEVEL				0x00000008
#define	ACS_SCAF_ENABLEACSSERVICE			0x00000010
#define	ACS_SCAF_MAX_PF_TOKENRATE			0x00000020
#define	ACS_SCAF_MAX_PF_PEAKBW				0x00000040
#define	ACS_SCAF_MAX_PF_DURATION			0x00000080
#define	ACS_SCAF_DESCRIPTION				0x00000100
#define	ACS_SCAF_RSVPLOGFILESLOCATION		0x00000200
#define	ACS_SCAF_MAXNOOFLOGFILES			0x00000400
#define	ACS_SCAF_MAXSIZEOFRSVPLOGFILE		0x00000800
#define	ACS_SCAF_DSBMPRIORITY				0x00001000
#define	ACS_SCAF_DSBMREFRESH				0x00002000
#define	ACS_SCAF_DSBMDEADTIME				0x00004000
#define	ACS_SCAF_CACHETIMEOUT				0x00008000
#define	ACS_SCAF_NONRESERVEDTXLIMIT			0x00010000

// accounting -- added by WeiJiang 2/16/98
#define ACS_SCAF_ENABLERSVPMESSAGEACCOUNTING	0x00020000
#define ACS_SCAF_RSVPACCOUNTINGFILESLOCATION	0x00040000
#define ACS_SCAF_MAXNOOFACCOUNTINGFILES			0x00080000
#define ACS_SCAF_MAXSIZEOFRSVPACCOUNTINGFILE	0x00100000

//Server list
#define	ACS_SCAF_SERVERLIST						0x00200000


class CACSSubnetConfig : public CDSObject
{
friend class CPgGeneral;
friend class CPgLogging;
friend class CPgSBM;
friend class CPgAccounting;
friend class CPgServers;

public:
	CACSSubnetConfig() : CDSObject(true)
	{
		void*	pVoid;
		
		CDSAttributeInfo* pInfo = m_aSubnetAttributeInfo;
		
		int	count = 0;
		while(pInfo && pInfo->id)
		{
			m_aAttributes[count].pInfo = pInfo;
			switch(pInfo->id)
			{
			case ACS_SCAI_ALLOCABLERSVPBW:			pVoid = (void*)&m_ddALLOCABLERSVPBW; break;
			case ACS_SCAI_MAXPEAKBW:				pVoid = (void*)&m_ddMAXPEAKBW; break;			
			case ACS_SCAI_ENABLERSVPMESSAGELOGGING:	pVoid = (void*)&m_bENABLERSVPMESSAGELOGGING; break;
			case ACS_SCAI_EVENTLOGLEVEL:			pVoid = (void*)&m_dwEVENTLOGLEVEL; break;	
			case ACS_SCAI_ENABLEACSSERVICE:			pVoid = (void*)&m_bENABLEACSSERVICE; break;
			case ACS_SCAI_MAX_PF_TOKENRATE:			pVoid = (void*)&m_ddMAX_PF_TOKENRATE; break;		
			case ACS_SCAI_MAX_PF_PEAKBW:			pVoid = (void*)&m_ddMAX_PF_PEAKBW; break;
			case ACS_SCAI_MAX_PF_DURATION:			pVoid = (void*)&m_dwMAX_PF_DURATION; break;
			case ACS_SCAI_RSVPLOGFILESLOCATION:		pVoid = (void*)&m_strRSVPLOGFILESLOCATION; break;
			case ACS_SCAI_DESCRIPTION:				pVoid = (void*)&m_strDESCRIPTION; break;
			case ACS_SCAI_MAXNOOFLOGFILES:			pVoid = (void*)&m_dwMAXNOOFLOGFILES; break;
			case ACS_SCAI_MAXSIZEOFRSVPLOGFILE:		pVoid = (void*)&m_dwMAXSIZEOFRSVPLOGFILE; break;
			case ACS_SCAI_DSBMPRIORITY:				pVoid = (void*)&m_dwDSBMPRIORITY; break;
			case ACS_SCAI_DSBMREFRESH:				pVoid = (void*)&m_dwDSBMREFRESH; break;
			case ACS_SCAI_DSBMDEADTIME:				pVoid = (void*)&m_dwDSBMDEADTIME; break;
			case ACS_SCAI_CACHETIMEOUT:				pVoid = (void*)&m_dwCACHETIMEOUT; break;
			case ACS_SCAI_NONRESERVEDTXLIMIT:		pVoid = (void*)&m_ddNONRESERVEDTXLIMIT; break;

			// accounting	added by WeiJiang 2/16/98
			case ACS_SCAI_ENABLERSVPMESSAGEACCOUNTING:	pVoid = (void*)&m_bENABLERSVPMESSAGEACCOUNTING; break;
			case ACS_SCAI_RSVPACCOUNTINGFILESLOCATION:	pVoid = (void*)&m_strRSVPACCOUNTINGFILESLOCATION; break;
			case ACS_SCAI_MAXNOOFACCOUNTINGFILES: 		pVoid = (void*)&m_dwMAXNOOFACCOUNTINGFILES; break;
			case ACS_SCAI_MAXSIZEOFRSVPACCOUNTINGFILE:	pVoid = (void*)&m_dwMAXSIZEOFRSVPACCOUNTINGFILE; break;

			case ACS_SCAI_SERVERLIST:					pVoid = (void*)&m_strArrayServerList; break;
			
			default:	ASSERT(0);	break; // this should NOT happen
			}
			m_aAttributes[count++].pBuffer = pVoid;
			pInfo++;
		}
		m_aAttributes[count].pInfo = 0;
		m_aAttributes[count].pBuffer = 0;
	};
   	
	virtual	CDSAttribute*	GetAttributes() { return &(m_aAttributes[0]);};
	
	// ===========================================
	// get the data memebers
	STDMETHOD(GetString)(CString& str, int nCol);
	
protected:

	static	CDSAttributeInfo	m_aSubnetAttributeInfo[];
	CDSAttribute				m_aAttributes[__ACS_SCAI_COUNT];

	//===================================================
	// data member
	CString					m_strDescription;
	ADS_LARGE_INTEGER		m_ddALLOCABLERSVPBW;
	ADS_LARGE_INTEGER		m_ddMAXPEAKBW;			
	ADS_BOOLEAN				m_bENABLERSVPMESSAGELOGGING;
	ADS_INTEGER				m_dwEVENTLOGLEVEL;	
	ADS_BOOLEAN				m_bENABLEACSSERVICE;
	ADS_LARGE_INTEGER		m_ddMAX_PF_TOKENRATE;		
	ADS_LARGE_INTEGER		m_ddMAX_PF_PEAKBW;
	ADS_INTEGER				m_dwMAX_PF_DURATION;
	CString					m_strRSVPLOGFILESLOCATION;
	CString					m_strDESCRIPTION;
	ADS_INTEGER				m_dwMAXNOOFLOGFILES;
	ADS_INTEGER				m_dwMAXSIZEOFRSVPLOGFILE;
	ADS_INTEGER				m_dwDSBMPRIORITY;
	ADS_INTEGER				m_dwDSBMREFRESH;
	ADS_INTEGER				m_dwDSBMDEADTIME;
	ADS_INTEGER				m_dwCACHETIMEOUT;
	ADS_LARGE_INTEGER		m_ddNONRESERVEDTXLIMIT;

	// accounting -- added by WeiJiang 2/16/98
	ADS_BOOLEAN				m_bENABLERSVPMESSAGEACCOUNTING;
	CString					m_strRSVPACCOUNTINGFILESLOCATION;
	ADS_INTEGER				m_dwMAXNOOFACCOUNTINGFILES;
	ADS_INTEGER				m_dwMAXSIZEOFRSVPACCOUNTINGFILE;

	// Server list
	CStrArray					m_strArrayServerList;
};



//===============================================================
// subnet service limit
//
// bit flags for the attributes
#define	ACS_SSLAF_ALLOCABLERSVPBW			0x00000001
#define	ACS_SSLAF_MAXPEAKBW					0x00000002
#define	ACS_SSLAF_MAX_PF_TOKENRATE			0x00000004
#define	ACS_SSLAF_MAX_PF_PEAKBW				0x00000008
#define	ACS_SSLAF_SERVICETYPE				0x00000010


enum ACS_SUBNET_SERVICE_LIMITS_ATTRIBUTE_ID {
	ACS_SSLAI_INVALID	= 0	,
	ACS_SSLAI_ALLOCABLERSVPBW,
	ACS_SSLAI_MAXPEAKBW,
	ACS_SSLAI_MAX_PF_TOKENRATE,
	ACS_SSLAI_MAX_PF_PEAKBW,
	ACS_SSLAI_SERVICETYPE		,
	// the total count of the elementas
	__ACS_SSLAI_COUNT
};


class CACSSubnetServiceLimits : public CDSObject
{
public:
	CACSSubnetServiceLimits() : CDSObject(true)
	{
		void*	pVoid;
		
		CDSAttributeInfo* pInfo = m_aSubnetServiceLimitsAttributeInfo;
		
		int	count = 0;
		while(pInfo && pInfo->id)
		{
			m_aAttributes[count].pInfo = pInfo;
			switch(pInfo->id)
			{
			case ACS_SSLAI_ALLOCABLERSVPBW:			pVoid = (void*)&m_ddALLOCABLERSVPBW; break;
			case ACS_SSLAI_MAXPEAKBW:				pVoid = (void*)&m_ddMAXPEAKBW; break;			
			case ACS_SSLAI_MAX_PF_TOKENRATE:		pVoid = (void*)&m_ddMAX_PF_TOKENRATE; break;		
			case ACS_SSLAI_MAX_PF_PEAKBW:			pVoid = (void*)&m_ddMAX_PF_PEAKBW; break;
			case ACS_SSLAI_SERVICETYPE:      		pVoid = (void*)&m_dwServiceType;	break;
			
			default:	ASSERT(0);	break; // this should NOT happen
			}
			m_aAttributes[count++].pBuffer = pVoid;
			pInfo++;
		}
		m_aAttributes[count].pInfo = 0;
		m_aAttributes[count].pBuffer = 0;
	};
   	
	virtual	CDSAttribute*	GetAttributes() { return &(m_aAttributes[0]);};
	
	// ===========================================
	// get the data memebers
	STDMETHOD(GetString)(CString& str, int nCol)
	{
		switch(nCol)
		{
		case	0:	// name
		// inteprete name based on service type

		//

			break;
		case	1: 	// per flow data
			break;

		case	2:	// per flow peak
			break;

		case	3:	// aggre data
			break;

		case	4:	// aggre peak
			break;
		}

		return S_OK;
	};
	
protected:

	static	CDSAttributeInfo	m_aSubnetServiceLimitsAttributeInfo[];
	CDSAttribute				m_aAttributes[__ACS_SSLAI_COUNT];

public:
	//===================================================
	// data member
	ADS_LARGE_INTEGER		m_ddALLOCABLERSVPBW;
	ADS_LARGE_INTEGER		m_ddMAXPEAKBW;			
	ADS_LARGE_INTEGER		m_ddMAX_PF_TOKENRATE;		
	ADS_LARGE_INTEGER		m_ddMAX_PF_PEAKBW;
	ADS_INTEGER				m_dwServiceType;
};


class CACSSubnetLimitsContainer : public CACSContainerObject<CACSSubnetServiceLimits>
{
public:
	CACSSubnetLimitsContainer() : CACSContainerObject<CACSSubnetServiceLimits>(true)
	{};

};

///////////////////////////////////////////////////////////////////////////////
//
// CACSSubnetObject
//
class	CACSSubnetObject :	public CACSPolicyContainer
{
public:
   	// delete the object from DS -- usually not override
   	STDMETHOD(Delete)()
   	{
		HRESULT	hr = CACSPolicyContainer::Delete();

		CHECK_HR(hr);

		m_spConfigObject.Release();

	L_ERR:
		return hr;
   	};



 	// called after the object is open,
 	// m_pIObject, m_pIContainer are available to use
 	// read attributes from DS should be done in this function

   	STDMETHOD(OnOpen)()
   	{
   		HRESULT				hr = S_OK;
   		if(m_spConfigObject.p == NULL)
   		{
	   		CComObject<CACSSubnetConfig>*	pConfig;
			CHECK_HR(hr = CComObject<CACSSubnetConfig>::CreateInstance(&pConfig));
			ASSERT(pConfig);
			m_spConfigObject = pConfig;
		}

		if(m_spSubnetLimitsContainer.p == NULL)
		{
	   		CComObject<CACSSubnetLimitsContainer>*	pCont;
			CHECK_HR(hr = CComObject<CACSSubnetLimitsContainer>::CreateInstance(&pCont));
			ASSERT(pCont);
			m_spSubnetLimitsContainer = pCont;
		}

		
		if (IfNewCreated())
		{
			// create policy for default user
			CComObject<CACSPolicyElement>*	pPolicy = NULL;
			CComPtr<CACSPolicyElement>		spPolicy;
					
			// create the object in DS
			CHECK_HR(hr = CComObject<CACSPolicyElement>::CreateInstance(&pPolicy));	// ref == 0
			spPolicy = pPolicy;		// ref == 1

			if((CACSPolicyElement*)spPolicy)
			{
				spPolicy->SetFlags(ATTR_FLAG_SAVE, spPolicy->SetDefault(), true);
				CHECK_HR(hr = spPolicy->Open(this, ACS_CLS_POLICY, ACSPOLICY_DEFAULT, true, true));
				CHECK_HR(hr = spPolicy->Close());
			}

			// create policy for unknown user
					
			// create the object in DS
			CHECK_HR(hr = CComObject<CACSPolicyElement>::CreateInstance(&pPolicy));	// ref == 0
			spPolicy = pPolicy;		// ref == 1
			if((CACSPolicyElement*)spPolicy)
			{
				spPolicy->SetFlags(ATTR_FLAG_SAVE, spPolicy->SetUnknown(), true);
				CHECK_HR(hr = spPolicy->Open(this, ACS_CLS_POLICY, ACSPOLICY_UNKNOWN, true, true));
				CHECK_HR(hr = spPolicy->Close());

			}
		

			// config object
			CHECK_HR(hr = m_spConfigObject->Open(this, ACS_CLS_SUBNETCONFIG, ACS_NAME_SUBNETCONFIG, true, true));


			// limits container object
			CHECK_HR(hr = m_spSubnetLimitsContainer->Open(this, ACS_CLS_CONTAINER, ACS_NAME_SUBNETLIMITS, true, true));

			// create default policies for the subnet
		}
		else
		{
			// config object
			CHECK_HR(hr = m_spConfigObject->SetInfo(this, ACS_CLS_SUBNETCONFIG, ACS_NAME_SUBNETCONFIG));

#if 0	// fix bug 366384	1	D0707 johnmil	a-leeb	ACS: New snap-in not backward compatible with older subnets

			// limits container object
			CHECK_HR(hr = m_spLimitsContainer->SetInfo(this, ACS_CLS_CONTAINER, ACS_NAME_SUBNETLIMITS));
#else
			// limits container object
			CHECK_HR(hr = m_spSubnetLimitsContainer->Open(this, ACS_CLS_CONTAINER, ACS_NAME_SUBNETLIMITS, true, true));
#endif			
		}

	L_ERR:
		return hr;
   	};

   	// called before SetInfo is called to set the object
 	// m_pIObject, m_pIContainer are available to use
 	// write attributes to DS should be done in this function
   	STDMETHOD(OnSave)(DWORD	dwAttrFlags)
   	{
		if((CACSSubnetConfig*)m_spConfigObject)	// if the subobject is open
			return m_spConfigObject->Save(ATTR_FLAGS_ALL);
		else
			return S_OK;
   	};

	HRESULT	GetConfig(CACSSubnetConfig** ppConfig)
	{
		ASSERT(ppConfig);

		*ppConfig = (CACSSubnetConfig*)m_spConfigObject;
		if(*ppConfig)	(*ppConfig)->AddRef();

		return S_OK;
	};

	// Get service limits container object
	HRESULT	GetLimitsContainer( CACSSubnetLimitsContainer **ppContainer )
	{
		ASSERT(ppContainer);

		*ppContainer = (CACSSubnetLimitsContainer*)m_spSubnetLimitsContainer;
		if(*ppContainer)	(*ppContainer)->AddRef();

		return S_OK;

	};

	// ===========================================
	// get the data memebers
	STDMETHOD(GetString)(CString& str, int nCol);
	
protected:
	CComPtr<CACSSubnetConfig>	m_spConfigObject;
	CComPtr<CACSSubnetLimitsContainer>	m_spSubnetLimitsContainer;
};

///////////////////////////////////////////////////////////////////////////////
//
// CACSContainerObject
//
//
//+----------------------------------------------------------------------------
//
//  Method:     CACSContainerObject::ListChildren
//
//  Synopsis:   list children to the list, create the children name list
//
//-----------------------------------------------------------------------------

template <class T>
HRESULT CACSContainerObject<T>::ListChildren(std::list<T*>& children, BSTR clsName)
{
	CComPtr<IEnumVARIANT>	spEnum;
	CComPtr<IADsContainer>	spContainer;
	CComPtr<IADs>			spChild;
	CComPtr<IDispatch>		spDisp;

	BSTR			bstr = NULL;
	HRESULT			hr = S_OK;
	VARIANT			var;
	CComPtr< CComObject<T> >	spDSObj;
			

	VariantInit(&var);

	RemoveAllChildren();	// RemoveAllChildren from the existing list

	if(!(IADs*)m_spIADs)
		CHECK_HR(hr = Reopen());
	CHECK_HR(hr = m_spIADs->QueryInterface(IID_IADsContainer, (void**)&spContainer));
	CHECK_HR(hr = ADsBuildEnumerator(spContainer, &spEnum));

	try{
		VariantClear(&var);
		while(S_OK == (hr = ADsEnumerateNext(spEnum, 1, &var, NULL)))
		{
			spDisp.Release();
            spDisp = var.pdispVal;
			spChild.Release();	// make sure spChild is NULL
            CHECK_HR(hr = spDisp->QueryInterface(IID_IADs, (VOID **)&spChild));
			// if this object is a profile object
			if(clsName)
			{
				CHECK_HR(spChild->get_Class(&bstr));
				if (0 != _wcsicmp(bstr, clsName))
				{
					SysFreeString(bstr);
					continue;
				}
				SysFreeString(bstr);
			}

			// create the object
			spDSObj.Release();		// make sure it's  NULL
			CHECK_HR(hr = CComObject<T>::CreateInstance(&spDSObj));	// with 0 reference count
			spDSObj->AddRef();

			CHECK_HR(hr = spDSObj->Attach(this, spChild));

			// add to the children list,
			spDSObj->AddRef();
			children.push_back(spDSObj);

			// register the child in the children list
			CHECK_HR(hr = AddChild(spDSObj));

			CHECK_HR(hr = spDSObj->Close());
			VariantClear(&var);
        }
	}
	catch(CMemoryException&)
	{
		CHECK_HR(hr = E_OUTOFMEMORY);
	}

	m_bListed = true;
	hr = S_OK;

L_ERR:
	return hr;
}

//////
#endif
/////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acsadmin.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AcsAdmin.cpp
		Implements In-Proc Server for ACS User extension and ACS Admin Snapin

    FILE HISTORY:
		11/03/97	Wei Jiang	Created
        
*/
// acsadmin.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f acsadminps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "acsadmin.h"

#include "acsadmin_i.c"
#include "ACSUser.h"
#include "ACSSnap.h"
#include "ACSSnapE.h"
#include "ACSSnapA.h"

// TFS snapin support
#include "register.h"
#include "tfsguid.h"
#include "ncglobal.h"  // network console global defines

// ATL implementation code
#include <atlimpl.cpp>
// #include "DSObject.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
#if 0	// user page is removed
	OBJECT_ENTRY(CLSID_ACSUser, CACSUser)
#endif 	
	OBJECT_ENTRY(CLSID_ACSSnap, CACSSnap)
	OBJECT_ENTRY(CLSID_ACSSnapExt, CACSSnapExt)
	OBJECT_ENTRY(CLSID_ACSSnapAbout, CACSSnapAbout)
//	OBJECT_ENTRY(CLSID_DSObject, CDSObject)
END_OBJECT_MAP()

class CAcsadminApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CAcsadminApp theApp;

BOOL CAcsadminApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();
}

int CAcsadminApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	TCHAR	moduleFileName[MAX_PATH * 2];

   GetModuleFileNameOnly(_Module.GetModuleInstance(), moduleFileName, MAX_PATH * 2);

	//
	// registers object, typelib and all interfaces in typelib
	//
	HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
	ASSERT(SUCCEEDED(hr));

	CString name, NameStringIndirect;
	
	if (FAILED(hr))
		return hr;
	//
	// register the snapin into the console snapin list
	//
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	name.LoadString(IDS_SNAPIN_DESC);
	NameStringIndirect.Format(L"@%s,-%-d", moduleFileName, IDS_SNAPIN_DESC);
	
	hr = RegisterSnapinGUID(&CLSID_ACSSnap, 
						&CLSID_ACSRootNode, 
						&CLSID_ACSSnapAbout,
						(LPCTSTR)name,
						_T("1.0"), 
						TRUE,
						NameStringIndirect);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

#ifdef  __NETWORK_CONSOLE__
	hr = RegisterAsRequiredExtensionGUID(&GUID_NetConsRootNodeType, 
                                         &CLSID_ACSSnap,
    							         (LPCTSTR)name,
                                         EXTENSION_TYPE_TASK,
                                         &CLSID_ACSSnap);

	ASSERT(SUCCEEDED(hr));
#endif

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	HRESULT hr  = _Module.UnregisterServer();
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;
	
	// un register the snapin 
	//
	hr = UnregisterSnapinGUID(&CLSID_ACSSnap);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

#ifdef  __NETWORK_CONSOLE__
    hr = UnregisterAsExtensionGUID(&GUID_NetConsRootNodeType,
                                   &CLSID_ACSSnap,
                                   EXTENSION_TYPE_TASK);
#endif
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acscomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	acscomp.h
		This file contains the prototypes for the derived classes 
		for CComponent and CComponentData.  Most of these functions 
		are pure virtual functions that need to be overridden 
		for snapin functionality.
		
    FILE HISTORY:
    	11/05/97	Wei Jiang			Created
        
*/

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _COMPONT_H_
#include "compont.h"
#endif

#ifndef	_ACSCOMPONENT_H_
#define	_ACSCOMPONENT_H_
/////////////////////////////////////////////////////////////////////////////
//
// CACSComponentData
//
/////////////////////////////////////////////////////////////////////////////

#define ACS_CONSOLE_VERSION	0x50001	// NT5, version 1
#define ACS_CONSOLE_MAX_COL	32	// max col used for this version

struct CACSConsoleData
{
	ULONG	ulVersion;
	ULONG	ulSize;
	ULONG	ulMaxCol;	// should be ACS_CONSOLE_MAX_COL
	ULONG	ulPolicyColWidth[ACS_CONSOLE_MAX_COL + 1];
	ULONG	ulSubnetColWidth[ACS_CONSOLE_MAX_COL + 1];
};

class CACSComponentData :
	public CComponentData,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CACSComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()
			
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	STDMETHOD(OnNotifyPropertyChange)(LPDATAOBJECT lpDataObject, 
						MMC_NOTIFY_TYPE event, 
						LPARAM arg, 
						LPARAM param); 

	CACSComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();

	void GetConsoleData();
	void SetConsoleData();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
	CACSConsoleData	m_ConsoleData;
};

/////////////////////////////////////////////////////////////////////////////
//
// CACSComponent
//
/////////////////////////////////////////////////////////////////////////////

class CACSComponent : 
	public TFSComponent
{
public:
	CACSComponent();
	~CACSComponent();

	DeclareITFSCompCallbackMembers(IMPL)
    STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, long arg, long param);	
	virtual HRESULT OnNotifyPropertyChange(LPDATAOBJECT lpDataObject, 
						MMC_NOTIFY_TYPE event, 
						LPARAM arg, 
						LPARAM param); 

//Attributes
private:
};

// Note - These are offsets into my image list
typedef enum _IMAGE_INDICIES
{
	IMAGE_IDX_ACS = 0,
	IMAGE_IDX_SUBNETWORK,
	IMAGE_IDX_PROFILES,
	IMAGE_IDX_USERPOLICIES,
	IMAGE_IDX_POLICY,
	IMAGE_IDX_OPENFOLDER,
	IMAGE_IDX_CLOSEDFOLDER,
	IMAGE_IDX_CONFLICTPOLICY,
	IMAGE_IDX_DISABLEDPOLICY,
	Not_being_used,
	IMAGE_IDX_SUBNETWORK_NO_ACSPOLICY,
}  IMAGE_INDICIES, *LPIMAGE_INDICIES;


#endif	_ACSCOMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acshand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	AcsHand.cpp
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as
		all of the subnodes in this snapin).
		
    FILE HISTORY:
    	11/05/97	Wei Jiang			Created

*/

#include "stdafx.h"
#include <secext.h>
#include <objsel.h>
#include "acs.h"
#include "acshand.h"
#include "util.h"
#include "statsdlg.h"
#include "modeless.h"

#include "resource.h"
#include "helper.h"
#include "proppage.h"
#include "acsadmin.h"
#include "resource.h"
#include "acscomp.h"
#include "acsdata.h"
#include "newsub.h"
#include "pggen.h"
#include "pgsrvs.h"
#include "pgsbm.h"
#include "pglog.h"

// property pages
#include "pgpolicy.h"	// traffic page for ACSPolicy

#include "ncglobal.h"  // network console global defines

// const TCHAR g_szDefaultHelpTopic[] = _T("\\help\\QOSConcepts.chm::/acs_usingTN.htm");
const TCHAR g_szDefaultHelpTopic[] = _T("\\help\\QOSconcepts.chm::/sag_ACStopnode.htm");

UINT g_col_strid_name[] = {IDS_NAME, 0};
int  g_col_width_name[] = {200,	AUTO_WIDTH};

UINT g_col_strid_name_type[] = {IDS_NAME, IDS_TYPE, 0};
int  g_col_width_name_type[] = {200,	75, AUTO_WIDTH};

UINT g_col_strid_name_type_desc[] = {IDS_NAME, IDS_TYPE, IDS_DESC, 0};
int  g_col_width_name_type_desc[] = {200,	75, 250, AUTO_WIDTH};

UINT g_col_strid_policy[] = {IDS_COL_POLICY_APPLIES_TO, IDS_COL_POLICY_DIRECTION, IDS_COL_POLICY_SERVICE_LEVEL, IDS_COL_POLICY_DATARATE, IDS_COL_POLICY_PEAKRATE, 0};
int  g_col_width_policy[] = {150, 100, 100, 50, 50, AUTO_WIDTH};
const UINT g_col_count_policy = sizeof(g_col_strid_policy)/sizeof(UINT) - 1;

// the date rate and peak rate do not make sense any more, since they are related to service type
//UINT g_col_strid_subnet[] = {IDS_COL_SUBNET_NAME, IDS_COL_SUBNET_DESC, IDS_COL_SUBNET_DATARATE, IDS_COL_SUBNET_PEAKRATE, 0};
//int  g_col_width_subnet[] = {120, 150, 50, 50, AUTO_WIDTH};
UINT g_col_strid_subnet[] = {IDS_COL_SUBNET_NAME, IDS_COL_SUBNET_DESC, 0};
int  g_col_width_subnet[] = {120, 150, AUTO_WIDTH};
const UINT g_col_count_subnet = sizeof(g_col_strid_subnet)/sizeof(UINT) - 1;


// keep a public map of MMC verbs
const MMC_CONSOLE_VERB  g_mmc_verbs[ACS_TOTAL_MMC_VERBS] =
	{
		MMC_VERB_OPEN,
		MMC_VERB_COPY,
		MMC_VERB_PASTE,
		MMC_VERB_DELETE,
		MMC_VERB_PROPERTIES,
		MMC_VERB_RENAME,
		MMC_VERB_REFRESH,
		MMC_VERB_PRINT
	};

// verb state with no new menu, no property page
MMC_BUTTON_STATE	g_verbs_all_hiden[ACS_TOTAL_MMC_VERBS] =
	{
		HIDDEN, // MMC_VERB_OPEN,
		HIDDEN, // MMC_VERB_COPY,
		HIDDEN, // MMC_VERB_PASTE,
		HIDDEN, // MMC_VERB_DELETE,
		HIDDEN, // MMC_VERB_PROPERTIES,
		HIDDEN, // MMC_VERB_RENAME,
		HIDDEN, // MMC_VERB_REFRESH,
		HIDDEN  // MMC_VERB_PRINT
	};

// verb state with property page, delete, rename enabled
MMC_BUTTON_STATE	g_verbs_property_delete[ACS_TOTAL_MMC_VERBS] =	
	{
		HIDDEN, // MMC_VERB_OPEN,
		HIDDEN, // MMC_VERB_COPY,
		HIDDEN, // MMC_VERB_PASTE,
		ENABLED, // MMC_VERB_DELETE,
		ENABLED, // MMC_VERB_PROPERTIES,
		HIDDEN, // MMC_VERB_RENAME,
		HIDDEN, // MMC_VERB_REFRESH,
		HIDDEN  // MMC_VERB_PRINT
	};


// Container with no property
MMC_BUTTON_STATE	g_verbs_property_refresh[ACS_TOTAL_MMC_VERBS] =	
	{
		HIDDEN, // MMC_VERB_OPEN,
		HIDDEN, // MMC_VERB_COPY,
		HIDDEN, // MMC_VERB_PASTE,
		HIDDEN, // MMC_VERB_DELETE,
		ENABLED, // MMC_VERB_PROPERTIES,
		HIDDEN, // MMC_VERB_RENAME,
		ENABLED, // MMC_VERB_REFRESH,
		HIDDEN  // MMC_VERB_PRINT
	};

// Container with property
MMC_BUTTON_STATE	g_verbs_refresh[ACS_TOTAL_MMC_VERBS] =	
	{
		HIDDEN, // MMC_VERB_OPEN,
		HIDDEN, // MMC_VERB_COPY,
		HIDDEN, // MMC_VERB_PASTE,
		HIDDEN, // MMC_VERB_DELETE,
		HIDDEN, // MMC_VERB_PROPERTIES,
		HIDDEN, // MMC_VERB_RENAME,
		ENABLED, // MMC_VERB_REFRESH,
		HIDDEN  // MMC_VERB_PRINT
	};

// context menu for new
const UINT	g_new_menus_newsub[] = {IDS_NEWSUBNET, 0};
const UINT	g_new_menus_policy[] = {IDS_NEWPOLICY, 0};
const UINT	g_menus_subnet[] = {IDS_NEWPOLICY, IDS_DELETESUBNET, 0};
// const UINT	g_new_menus_profile[] = {IDS_NEWPROFILE, 0};

// static string IDs for strings
const UINT	g_strid_root[]= { IDS_ACSROOT, 0};
const UINT	g_strid_global[]= { IDS_GLOBAL, 0};
/*
const UINT	g_strid_profiles[]= { IDS_PROFILES, 0};
const UINT	g_strid_users[]= { IDS_USERS, 0};
*/
const UINT	g_strid_subnets[]= { IDS_SUBNETCONFIGS, 0};

//==========================================================
// CACSUIInfo structures
//

// Root handle
CACSUIInfo g_RootUIInfo =
{
	g_strid_root,		// static string
	1,	// only name column

	g_col_strid_name,	//m_aColumnIds;		
	g_col_width_name,	//m_aColumnWidths;	
	false,	//m_bPropertyPage;	
	true,	//m_bContainer;		
	NULL,	//m_aNewMenuTextIds;	
	NULL,	//m_aNewMenuIds;		
	NULL,	//m_aTaskMenuTextIds;
	NULL,	//m_aTaskMenuIds;		
	g_verbs_all_hiden,	//m_pVerbStates
	&CLSID_ACSRootNode
};

// Global Configuration handle
CACSUIInfo g_GlobalUIInfo =
{
	g_strid_global,		// static string
	1, // only name column

	g_col_strid_policy,	//m_aColumnIds;		
	g_col_width_policy,	//m_aColumnWidths;	
	false,	//m_bPropertyPage;	
	true,	//m_bContainer;		
	NULL, 	// g_new_menus_user,	//m_aNewMenuTextIds;	
	NULL,	//m_aNewMenuIds;		
	g_new_menus_policy,	//m_aTaskMenuTextIds;
	NULL,	//m_aTaskMenuIds;		
	g_verbs_refresh,	//m_pVerbStates
	&CLSID_ACSGlobalHolderNode
};

// Subnetworks Configuration handle
CACSUIInfo g_SubnetworksUIInfo =
{
	g_strid_subnets,		// static string
	1, // only name column
	
	g_col_strid_subnet,	//m_aColumnIds;		
	g_col_width_subnet,	//m_aColumnWidths;	
	false,				//m_bPropertyPage;	
	true,				//m_bContainer;		
	NULL, // g_new_menus_newsub,	//m_aNewMenuTextIds;	
	NULL,				//m_aNewMenuIds;		
	g_new_menus_newsub,	//m_aTaskMenuTextIds;
	NULL,				//m_aTaskMenuIds;		
	g_verbs_refresh,	//m_pVerbStates
	&CLSID_ACSSubnetHolderNode
};

// Policy handle
CACSUIInfo g_PolicyUIInfo =
{
	NULL,				// static string id
	sizeof(g_col_strid_policy) / sizeof(UINT) -1,	// the last string id is 0, so decrease by 1
	
	g_col_strid_policy,	//m_aColumnIds;		
	g_col_width_policy,	//m_aColumnWidths;	
	true,				//m_bPropertyPage;	
	false,				//m_bContainer;		
	NULL,				//m_aNewMenuTextIds;	
	NULL,				//m_aNewMenuIds;		
	NULL,				//m_aTaskMenuTextIds;
	NULL,				//m_aTaskMenuIds;		
	g_verbs_property_delete,	//m_pVerbStates
	&CLSID_ACSPolicyNode
};

// Subnet handle
CACSUIInfo g_SubnetUIInfo =
{
	NULL,				// static string id
	sizeof(g_col_strid_subnet) / sizeof(UINT) -1, 		// decrease by 1, since the last IDS is 0
	
	g_col_strid_policy,	//m_aColumnIds;		
	g_col_width_policy,	//m_aColumnWidths;	
	true,				//m_bPropertyPage;	
	true,				//m_bContainer;		
	NULL, //g_new_menus_user,				//m_aNewMenuTextIds;	
	NULL,				//m_aNewMenuIds;		
	g_menus_subnet,				//m_aTaskMenuTextIds;
	NULL,				//m_aTaskMenuIds;		
	g_verbs_property_refresh,	//m_pVerbStates
	&CLSID_ACSSubnetNode
};

///////////////////////////////////////////////////////////////////////////////
//
// CACSHandle implementation
//
///////////////////////////////////////////////////////////////////////////////
CACSHandle::CACSHandle(ITFSComponentData *pCompData, CDSObject* pDSObject, CACSUIInfo* pUIInfo)
			: CHandler(pCompData),
			m_pUIInfo(pUIInfo),
			m_dwShownState(0),
			m_pNode(NULL),
			m_pDSObject(pDSObject)
{
	if(pDSObject)
	{
		pDSObject->AddRef();
		pDSObject->SetHandle(this);
	}
		
	ASSERT(pUIInfo);
	// init the static string array
	if(pUIInfo->m_aStaticStrIds)
	{
		const UINT*		pUINT = pUIInfo->m_aStaticStrIds;
		int		i = 0;
		while(*pUINT)
		{
			i++;
			m_aStaticStrings.AddByRID(*pUINT++);
		}
		m_nFirstDynCol = i;
	}
	else
		m_nFirstDynCol = 0;

	m_ulIconIndex = IMAGE_IDX_CLOSEDFOLDER;
	m_ulIconIndexOpen = IMAGE_IDX_OPENFOLDER;
	m_nBranchFlag = 0;

	m_bACSHandleExpanded = FALSE;
	m_bCheckPropertyPageOpen = TRUE;
};

CACSHandle::~CACSHandle()
{
	m_aStaticStrings.DeleteAll();

	if(m_pDSObject)
		m_pDSObject->Release();
};

/*!--------------------------------------------------------------------------
    MachineHandler::DestroyHandler
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CACSHandle::DestroyResultHandler(LONG_PTR cookie)
{
    SPITFSNode  spNode;

	HRESULT	hr = S_OK;
    if (S_OK != m_spNodeMgr->FindNode(cookie, &spNode))
    	return S_FALSE;
    	
	if (S_OK == BringUpPropertyPageIfOpen(spNode, NULL))
	{
		AfxMessageBox(IDS_ERROR_CLOSE_PROPERTY_SHEET);
		return S_FALSE;
	}
	else
	    return S_OK;
	
    return hrOK;
}


/*!--------------------------------------------------------------------------
    MachineHandler::DestroyHandler
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CACSHandle::DestroyHandler(ITFSNode *pNode)
{
	if (S_OK == BringUpPropertyPageIfOpen(pNode, NULL))
	{
		AfxMessageBox(IDS_ERROR_CLOSE_PROPERTY_SHEET);
		return S_FALSE;
	}
	else
	    return S_OK;
}

//=============================================================================
// CACSHandle::HasPropertyPages
//		Implementation of ITFSNodeHandler::HasPropertyPages
//	NOTE: the root node handler has to over-ride this function to
//	handle the snapin manager property page (wizard) case!!!
//	
//	Author: KennT, WeiJiang
//=============================================================================
STDMETHODIMP
CACSHandle::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject,
	DATA_OBJECT_TYPES   type,
	DWORD               dwType
)
{
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = S_FALSE;
	}
	else
	{
		hr = (m_pUIInfo->m_bPropertyPage? S_OK : S_FALSE);
		
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CACSHandle::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT, WeiJiang
 ---------------------------------------------------------------------------*/
STDMETHODIMP CACSHandle::OnAddMenuItems(
	ITFSNode *pNode,
	LPCONTEXTMENUCALLBACK pContextMenuCallback,
	LPDATAOBJECT lpDataObject,
	DATA_OBJECT_TYPES type,
	DWORD dwType,
	long *pInsertionsAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
	BOOL	bExtension = !!(dwType & TFS_COMPDATA_EXTENSION);
	CString	stMenuItem;

	if(*pInsertionsAllowed & CCM_INSERTIONALLOWED_NEW)
//	if (type == CCT_SCOPE)
	{
		int		i = 0;
		long	lInsertionId;		
		long	lMenuText;
		long	lMenuId;

		// under new menu
		while(hr == S_OK && m_pUIInfo->m_aNewMenuTextIds && m_pUIInfo->m_aNewMenuTextIds[i])
		{

		//	lInsertionId = bExtension ? CCM_INSERTIONPOINTID_3RDPARTY_NEW :
		//							 CCM_INSERTIONPOINTID_PRIMARY_NEW;

			// BUG :: bExtension is alway true for same reason

			lInsertionId = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		
			lMenuText = m_pUIInfo->m_aNewMenuTextIds[i];

			if(m_pUIInfo->m_aNewMenuIds)
				lMenuId = m_pUIInfo->m_aNewMenuIds[i];
			else
				lMenuId = lMenuText;

			stMenuItem.LoadString(lMenuText);
			hr = LoadAndAddMenuItem( pContextMenuCallback,
									 stMenuItem,
									 lMenuId,
									 lInsertionId,
									 0 );
			i++;
		}

		i = 0;
		// under task menu
		while(hr == S_OK && m_pUIInfo->m_aTaskMenuTextIds && m_pUIInfo->m_aTaskMenuTextIds[i])
		{

			lInsertionId = bExtension ? CCM_INSERTIONPOINTID_3RDPARTY_TASK :
								    CCM_INSERTIONPOINTID_PRIMARY_TOP;

			// BUG :: bExtension is alway true for same reason

			lInsertionId = CCM_INSERTIONPOINTID_PRIMARY_TOP;

			lMenuText = m_pUIInfo->m_aTaskMenuTextIds[i];

			stMenuItem.LoadString(lMenuText);

			if(m_pUIInfo->m_aTaskMenuIds)
				lMenuText = m_pUIInfo->m_aTaskMenuTextIds[i];
			else
				lMenuId = lMenuText;

			hr = LoadAndAddMenuItem( pContextMenuCallback,
									 stMenuItem,
									 lMenuId,
									 lInsertionId,
									 0 );
			i++;
		}

	}
	return hr;
}

STDMETHODIMP CACSHandle::AddMenuItems(ITFSComponent *pComponent,
                                              MMC_COOKIE cookie,
                                              LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pCallback,
                                              long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    SPITFSNode  spNode;
    
    m_spNodeMgr->FindNode(cookie, &spNode);
    
    // Call through to the regular OnAddMenuItems
	if(*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW)
	    hr = OnAddMenuItems(spNode,
                        pCallback,
                        pDataObject,
                        CCT_RESULT,
                        TFS_COMPDATA_CHILD_CONTEXTMENU,
                        pInsertionAllowed);
    
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::Command
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CACSHandle::Command(ITFSComponent *pComponent,
                                           MMC_COOKIE cookie,
                                           int nCommandID,
                                           LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    SPITFSNode  spNode;
    
    m_spNodeMgr->FindNode(cookie, &spNode);
    
    // Call through to the regular OnCommand
	    hr = OnCommand(spNode,
                        nCommandID,
                        CCT_RESULT,
                        pDataObject,
                        TFS_COMPDATA_CHILD_CONTEXTMENU);
    
    return hr;
}
/*!--------------------------------------------------------------------------
	CACSHandle::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT, WeiJiang
 ---------------------------------------------------------------------------*/
STDMETHODIMP CACSHandle::OnCommand(ITFSNode *pNode, long nCommandId,
								   DATA_OBJECT_TYPES	type,
								   LPDATAOBJECT pDataObject,
								   DWORD	dwType)
{
	TRACE(_T("Command ID %d or %x is activated\n"), nCommandId, nCommandId);
	return S_OK;
}

/*!--------------------------------------------------------------------------
	CACSHandle::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT, WeiJiang
---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) CACSHandle::GetString(ITFSNode *pNode, int nCol)
{
	if(nCol < 0)
		// should be ROOT node
		nCol = 0;

	if(nCol < m_aStaticStrings.GetSize())
		return *m_aStaticStrings[(INT_PTR)nCol];
	else
	{
		ASSERT(nCol >= m_nFirstDynCol);
		UINT	dynCol = nCol - m_nFirstDynCol;
		if(m_aDynStrings.GetSize() == 0)	// new, not initialized yet
			UpdateStrings();

		if( nCol - m_nFirstDynCol < m_aDynStrings.GetSize())
			return *(m_aDynStrings.GetAt(dynCol));
		else
			return NULL;
	}
}

// should call the data object to get the latest dynamic strings
HRESULT	CACSHandle::UpdateStrings()	
{
	CString*	pStr;
	UINT		nCol;
	HRESULT		hr = S_OK;
	UINT		dynCol;
	
	for( nCol = m_nFirstDynCol, dynCol = 0; nCol < m_pUIInfo->m_nTotalStrs; nCol++, dynCol++)
	{
		if(nCol - m_nFirstDynCol < m_aDynStrings.GetSize())
			pStr = m_aDynStrings.GetAt(dynCol);
		else
		{
			pStr = new CString();
			m_aDynStrings.Add(pStr);
		}
		hr = m_pDSObject->GetString(*pStr, nCol);
	}
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpScopeOptions::InitializeNode
		Initializes node specific data
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CACSHandle::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	HRESULT hr = hrOK;

	ASSERT(m_pNode == NULL);
	m_pNode = pNode;
	if(m_pNode)
		m_pNode->AddRef();

	//
	// Create the display name for this scope
	//
	// Make the node immediately visible
	pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_IMAGEINDEX, m_ulIconIndex);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, m_ulIconIndexOpen);
	pNode->SetData(TFS_DATA_COOKIE, (DWORD_PTR)(ITFSNode *) pNode);
	TRACE(_T("COOKIE -- %08x\n"), (DWORD_PTR)(ITFSNode *) pNode);
	pNode->SetData(TFS_DATA_USER, (DWORD_PTR) this);

	if(IfContainer())
	{
		SetColumnStringIDs(m_pUIInfo->m_aColumnIds);
		SetColumnWidths(m_pUIInfo->m_aColumnWidths);
	}	
	return hr;
}

/*---------------------------------------------------------------------------
	CACSHandle::CompareItems
		Description
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CACSHandle::CompareItems
(
	ITFSComponent * pComponent,
	MMC_COOKIE		cookieA,
	MMC_COOKIE		cookieB,
	int				nCol
)
{
	SPITFSNode spNode1, spNode2;

	m_spNodeMgr->FindNode(cookieA, &spNode1);
	m_spNodeMgr->FindNode(cookieB, &spNode2);
	
	CACSHandle *pSub1 = GETHANDLER(CACSHandle, spNode1);
	CACSHandle *pSub2 = GETHANDLER(CACSHandle, spNode2);

	LPCTSTR	str1 = pSub1->GetString(NULL, nCol);
	LPCTSTR	str2 = pSub2->GetString(NULL, nCol);

	if(str1 && str2)
	{
		CString str(str1);
		return str.Compare(str2);
	}
	else
		return 0;
}

/*!--------------------------------------------------------------------------
	CACSHandle::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CACSHandle::OnResultContextHelp
(
    ITFSComponent * pComponent,
    LPDATAOBJECT    pDataObject,
    MMC_COOKIE      cookie,
    LPARAM          arg,
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

        szHelpFilePath.ReleaseBuffer();
	    szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}



//=============================================================================
//	CACSHandle::OnResultSelect
//		-
//	Author: WeiJiang
//
HRESULT CACSHandle::OnResultSelect(	ITFSComponent*	pComponent,
									LPDATAOBJECT	pDataObject,
									MMC_COOKIE 			cookie,
									LPARAM 			arg,
									LPARAM 			lParam)
{
	HRESULT hr = hrOK;
	SPIConsoleVerb spConsoleVerb;
	int		i;
	
	CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	// if it's ok to delete ... dynamic info

   	// Set the states for verbs
   	for(i = 0; i < ACS_TOTAL_MMC_VERBS; i++)
   	{
		spConsoleVerb->SetVerbState(g_mmc_verbs[i], m_pUIInfo->m_pVerbStates[i], TRUE);
	}

	if (IsOkToDelete() == S_FALSE)
		spConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);

    if (m_pUIInfo->m_pVerbStates[ ACS_MMC_VERB_PROPERTIES ] == ENABLED)
        spConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    else
        spConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CACSHandle::GetString
		Implementation of ITFSResultHandler::GetString
	Author: KennT, WeiJiang
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR)
CACSHandle::GetString
(
    ITFSComponent * pComponent,
	MMC_COOKIE cookie,
	int	 nCol
)
{
	return GetString(NULL, nCol);
}

/*!--------------------------------------------------------------------------
	CACSHandle::HasPropertyPages
		Implementation of ITFSResultHandler::HasPropertyPages
	Author: KennT, WeiJiang
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CACSHandle::HasPropertyPages
(
    ITFSComponent *         pComponent,
	MMC_COOKIE					cookie,
	LPDATAOBJECT			pDataObject
)
{
	return (m_pUIInfo->m_bPropertyPage? S_OK : S_FALSE);
}
//=============================================================================
//	CACSHandle::AddChild
//		-
//	Author: WeiJiang
//
HRESULT CACSHandle::AddChild(	
	ITFSNode*		pNode,
	CACSHandle*		pHandle,
	ITFSNode**		ppNewNode)
{
	HRESULT		hr = S_OK;
	ASSERT(ppNewNode);
	ASSERT(pNode);
	ASSERT(pHandle);
	
	if(pHandle->IfContainer())
	{
		CHECK_HR(hr = CreateContainerTFSNode(ppNewNode,
					  pHandle->m_pUIInfo->m_pGUID,
					  pHandle,
					  pHandle,
					  m_spNodeMgr));
	}
	else
	{
		CHECK_HR(hr = CreateLeafTFSNode(ppNewNode,
					  pHandle->m_pUIInfo->m_pGUID,
					  pHandle,
					  pHandle,
					  m_spNodeMgr));
	}

	// Need to initialize the data for the root node
	CHECK_HR(hr = pHandle->InitializeNode(*ppNewNode));	

	// Add the node to the root node
	CHECK_HR(hr = pNode->AddChild(*ppNewNode));
L_ERR:
	return hr;
}

// when data is changed on property page
HRESULT CACSHandle::NotifyDataChange(LPARAM param)
{
	CACSHandle* pHandle = reinterpret_cast<CACSHandle*>(param);
	ASSERT(pHandle);
	ASSERT(pHandle->m_pNode);
	if(!pHandle->m_pNode)
		return S_FALSE;	// not able to refresh the changes
	else
	{
		pHandle->m_pDSObject->SetNoObjectState();
		pHandle->UpdateStrings();
		if(pHandle->m_pNode->IsContainer())
			return pHandle->m_pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM);
		else
			return	pHandle->m_pNode->ChangeNode(RESULT_PANE_CHANGE_ITEM);
	}
}


/*---------------------------------------------------------------------------
	CACSHandle::OnCreateNodeId2
		Returns a unique string for this node
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT CACSHandle::OnCreateNodeId2(ITFSNode * pNode, CString & strId, 
DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strProviderId, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

	// attach display name
	strId += GetString(NULL, 0);
	strId += strGuid;

    return hrOK;
}

//=============================================================================
//	CACSHandle::OnExpand
//		-
//	Author: WeiJiang
//
HRESULT CACSHandle::OnExpand(	
ITFSNode *pNode,LPDATAOBJECT pDataObjecct, DWORD dwType, LPARAM arg,LPARAM param)
{
	HRESULT				hr = hrOK;

	SPITFSNode			spNode;

	std::list<CACSHandle*>	children;
	std::list<CACSHandle*>::iterator	i;
	
	if(arg)
	{
		hr = ListChildren(children);
		
		if (S_FALSE == hr)
			return S_OK;

		CHECK_HR(hr);
		
		// If this is TRUE, then we should enumerate the pane
		// add all children's handles
		for(i = children.begin(); i != children.end(); i++)
		{
			// For the root node, we will create one child node
			// Create a node
			spNode.Release();	// make sure the smart pointer is NULL

			CHECK_HR(hr = AddChild(pNode, (*i), &spNode));
			
			(*i)->Release();	// handle pointer,
			// Set the scope item for the root node
//			pNode->SetData(TFS_DATA_SCOPEID, param);
//			pNode->Show();
		}
	}

	m_bACSHandleExpanded = TRUE;

L_ERR:
	pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_DATA);

	if FAILED(hr)
		ReportError(hr, IDS_ERR_NODEEXPAND, NULL);
	return hr;
}



/*!--------------------------------------------------------------------------
	CACSHandle::SaveColumns
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CACSHandle::SaveColumns
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPARAM          arg,
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    DWORD               dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));

    while (m_pUIInfo->m_aColumnIds[nCol] != 0)
    {
        hr = spHeaderCtrl->GetColumnWidth(nCol, &nColWidth);
        if (SUCCEEDED(hr) &&
            m_pUIInfo->m_aColumnWidths[nCol] != nColWidth)
        {
            m_pUIInfo->m_aColumnWidths[nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		CORg(spRootNode->SetData(TFS_DATA_DIRTY, TRUE));
    }

Error:
    return hr;
}

HRESULT CACSHandle::OnResultRefresh(ITFSComponent * pComponent,
		LPDATAOBJECT pDataObject,
		MMC_COOKIE cookie,
		LPARAM arg,
		LPARAM lParam)
{
    HRESULT     hr = hrOK;
    SPITFSNode  spNode;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

	CORg (spNode->DeleteAllChildren(true));

	CORg (OnExpand(spNode, pDataObject, 0, arg, lParam));

Error:
    return hr;
}

HRESULT CACSHandle::OnDelete(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("CACSHandle::Notify(MMCN_DELETE) received\n");

	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	CString strMessage, strTemp;
	try{
		strTemp.LoadString(IDS_DELETE_CONTAINER);
		strMessage.Format(strTemp, GetString(NULL, 0));	
	}catch(CMemoryException&)
	{
		CHECK_HR(hr = E_OUTOFMEMORY);
	}

	if (AfxMessageBox(strMessage, MB_YESNO) == IDYES)
	{
		CHECK_HR(hr = Delete(pNode, NULL, TRUE));
	}

L_ERR:
	if FAILED(hr)
		ReportError(hr, IDS_ERR_NODEDELETE, NULL);
	return hr;
}

HRESULT CACSHandle::OnRename(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("CACSHandle::Notify(MMCN_RENAME) received\n");

	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT		hr = S_OK;

	OLECHAR*	pName = (OLECHAR*)lParam;

	hr = m_pDSObject->Rename(pName);

	if FAILED(hr)
		ReportError(hr, IDS_ERR_NODERENAME, NULL);
	return hr;
}

HRESULT CACSHandle::OnResultRename(	ITFSComponent*	pComponent,
									LPDATAOBJECT 	pDataObject,
									MMC_COOKIE 			cookie,
									LPARAM 			arg,
									LPARAM 			lParam)
{
	Trace0("CACSHandle::Notify(MMCN_DELETE) received\n");
	OLECHAR*	pName = (OLECHAR*)lParam;

	return m_pDSObject->Rename(pName);

}

HRESULT CACSHandle::OnResultDelete(	ITFSComponent*	pComponent,
											LPDATAOBJECT 	pDataObject,
											MMC_COOKIE 			cookie,
											LPARAM 			arg,
											LPARAM 			lParam)
{
	Trace0("CACSHandle::Notify(MMCN_DELETE) received\n");
	HRESULT hr = S_OK;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// build the list of selected nodes
	CTFSNodeList listNodesToDelete;
	hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

	//
	// Confirm with the user
	//
	CString strMessage, strTemp;
	int nNodes = listNodesToDelete.GetCount();

	try{
		if (nNodes > 1)
		{
			strTemp.LoadString(IDS_DELETE_MULTIITEMS);
			strMessage.Format(strTemp, nNodes);
		}
		else
		{
			strTemp.LoadString(IDS_DELETE_ITEM);
			strMessage.Format(strTemp, GetString(NULL, 0));
		}
	}catch(CMemoryException&){
		CHECK_HR(hr = E_OUTOFMEMORY);
	}

	if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
	{
		return NOERROR;
	}

	//
	// Loop through all items deleting
	//
    while (listNodesToDelete.GetCount() > 0)
	{
		SPITFSNode spOptionNode;
		spOptionNode = listNodesToDelete.RemoveHead();
		
		CACSHandle* pOptItem = GETHANDLER(CACSHandle, spOptionNode);

		// call the other OnDelete Function to do the deletion
		CHECK_HR(hr = pOptItem->Delete(spOptionNode, pComponent, TRUE));
		if(hr != S_OK)
			goto L_ERR;

		spOptionNode.Release();
	}

L_ERR:
	if FAILED(hr)
		ReportError(hr, IDS_ERR_NODEDELETE, NULL);

    return hr;
}



// bring up the property page if it's open
HRESULT	CACSHandle::BringUpPropertyPageIfOpen(ITFSNode *pNode, ITFSComponent* pTFSComponent)
{
	HRESULT		hr = S_OK;

	if(!m_bCheckPropertyPageOpen)	return S_FALSE;
	
	CComPtr<IConsole2>	spConsole;
	CComPtr<IDataObject>	spDataObject;
	CComPtr<IComponentData>	spComponentData;
	LONG_PTR uniqID;
	LONG_PTR cookie;
	
	hr = m_spNodeMgr->GetConsole(&spConsole);

	if (!spConsole)
		return S_FALSE;

	if ( hr != S_OK)
		return hr;
		
	// Query IConsole for the needed interface.
	CComQIPtr<IComponent, &IID_IComponent> 	spComponent(pTFSComponent);

	// Query IConsole for the needed interface.
	CComQIPtr<IPropertySheetProvider, &IID_IPropertySheetProvider> 	spPropertySheetProvider(spConsole );
	_ASSERTE( spPropertySheetProvider != NULL );


	cookie = pNode->GetData(TFS_DATA_COOKIE);
	// the find function FindPropertySheet takes cookie for result pane, and sopeId for scope pane
	if(pNode->IsContainer())
		uniqID = pNode->GetData(TFS_DATA_SCOPEID);
	else
		uniqID = cookie;
	
	CHECK_HR(hr = m_spNodeMgr->GetComponentData(&spComponentData));
		
	CHECK_HR(hr = spComponentData->QueryDataObject(cookie, pNode->IsContainer()?CCT_SCOPE:CCT_RESULT, &spDataObject));
		
	// This returns S_OK if a property sheet for this object already exists
	// and brings that property sheet to the foreground.
	// It returns S_FALSE if the property sheet wasn't found.
	// If this is coming in through my IComponent object, I pass the pComponent pointer.
	// If this is coming in through my IComponentData object,
	// then pComponent is NULL, which is the appropriate value to pass in for
	// the call to FindPropertySheet when coming in through IComponentData.
	hr = spPropertySheetProvider->FindPropertySheet(
								  (LONG_PTR) uniqID
								, spComponent
								, spDataObject
								);

L_ERR:
	return hr;									
}




HRESULT CACSHandle::Delete(ITFSNode *pNode, ITFSComponent* pTFSComponent, BOOL bCheckPropertyPage)
{
	Trace0("CACSHandle::Delete\n");

	HRESULT hr = S_OK;
	SPITFSNode spParent;

	if(bCheckPropertyPage)	// check to see if the property page is open
	{
		if(BringUpPropertyPageIfOpen(pNode, pTFSComponent) == S_OK)
		{
			AfxMessageBox(IDS_ERROR_CLOSE_PROPERTY_SHEET);
			hr = S_FALSE;
			goto L_ERR;
		}
	}

	// delete the corresponding DS object
	CHECK_HR(hr = m_pDSObject->Delete());
		
	// remove from UI
	pNode->GetParent(&spParent);
	CHECK_HR(hr = spParent->RemoveChild(pNode));

L_ERR:
	return hr;
}

unsigned int g_cfMachineName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");

LPOLESTR g_RootTaskOverBitmaps[ROOT_TASK_MAX] =
{
    L"/toolroll.bmp",
};

LPOLESTR g_RootTaskOffBitmaps[ROOT_TASK_MAX] =
{
    L"/tool.bmp",
};

UINT g_RootTaskText[ROOT_TASK_MAX] =
{
    IDS_ROOT_TASK_LAUNCH_ACS,  // for the extension case
};

UINT g_RootTaskHelp[ROOT_TASK_MAX] =
{
    IDS_ROOT_TASK_LAUNCH_ACS_HELP, // for the extension case
};


HRESULT
CRootTasks::Init(BOOL bExtension, BOOL bThisMachine, BOOL bNetServices)
{
    HRESULT     hr = hrOK;
    MMC_TASK    mmcTask;
    int         nPos = 0;
    int         nFinish = ROOT_TASK_MAX - 2;

    m_arrayMouseOverBitmaps.SetSize(ROOT_TASK_MAX);
    m_arrayMouseOffBitmaps.SetSize(ROOT_TASK_MAX);
    m_arrayTaskText.SetSize(ROOT_TASK_MAX);
    m_arrayTaskHelp.SetSize(ROOT_TASK_MAX);

    // setup path for reuse
    OLECHAR szBuffer[MAX_PATH*2];    // that should be enough
    lstrcpy (szBuffer, L"res://");
    ::GetModuleFileName(_Module.GetModuleInstance(), szBuffer + lstrlen(szBuffer), MAX_PATH);
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

    if (bExtension && bThisMachine)
    {
        nPos = ROOT_TASK_MAX - 2;
        nFinish = ROOT_TASK_MAX - 1;
    }
    else
    if (bExtension && bNetServices)
    {
        nPos = ROOT_TASK_MAX - 1;
        nFinish = ROOT_TASK_MAX;
    }
    else
    {
    	nPos = ROOT_TASK_MAX;
        nFinish = ROOT_TASK_MAX;
   	}

    for (nPos; nPos < nFinish; nPos++)
    {
        m_arrayMouseOverBitmaps[nPos] = szBuffer;
        m_arrayMouseOffBitmaps[nPos] = szBuffer;
        m_arrayMouseOverBitmaps[nPos] += g_RootTaskOverBitmaps[nPos];
        m_arrayMouseOffBitmaps[nPos] += g_RootTaskOffBitmaps[nPos];

        m_arrayTaskText[nPos].LoadString(g_RootTaskText[nPos]);
        m_arrayTaskHelp[nPos].LoadString(g_RootTaskHelp[nPos]);

        AddTask((LPTSTR) (LPCTSTR) m_arrayMouseOverBitmaps[nPos],
                (LPTSTR) (LPCTSTR) m_arrayMouseOffBitmaps[nPos],
                (LPTSTR) (LPCTSTR) m_arrayTaskText[nPos],
                (LPTSTR) (LPCTSTR) m_arrayTaskHelp[nPos],
                MMC_ACTION_ID,
                nPos);
    }

    return hr;
}


/*!--------------------------------------------------------------------------
	CTapiRootHandler::TaskPadNotify
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CACSRootHandle::TaskPadNotify
(
    ITFSComponent * pComponent,
    MMC_COOKIE            cookie,
    LPDATAOBJECT    pDataObject,
    VARIANT *       arg,
    VARIANT *       param
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (arg->vt == VT_I4)
    {
        switch (arg->lVal)
        {

            case ROOT_TASK_LAUNCH_ACS:
            {
				TCHAR		SystemPath[MAX_PATH];
				CString		CommandLine;

				GetSystemDirectory(SystemPath, MAX_PATH);

				// to construct "mmc.exe /s %windir%\system32\acssnap.msc")
				CommandLine = _T("mmc.exe /s ");
				CommandLine += SystemPath;
				CommandLine += _T("\\acssnap.msc");
				USES_CONVERSION;
				WinExec(T2A((LPTSTR)(LPCTSTR)CommandLine), SW_SHOW);
            }
                break;

            default:
                Panic1("CACSRootHandle::TaskPadNotify - Unrecognized command! %d", arg->lVal);
                break;
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::EnumTasks
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CACSRootHandle::EnumTasks
(
    ITFSComponent * pComponent,
    MMC_COOKIE            cookie,
    LPDATAOBJECT    pDataObject,
    LPOLESTR        pszTaskGroup,
    IEnumTASK **    ppEnumTask
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    CRootTasks *    pTasks = NULL;
    SPIEnumTask     spEnumTasks;
	SPINTERNAL	    spInternal = ExtractInternalFormat(pDataObject);
    BOOL            bExtension = FALSE;
    BOOL            bAddThisMachineTasks = FALSE;
    BOOL            bAddNetServicesTasks = FALSE;
    const CLSID *   pNodeClsid = &CLSID_ACSSnap;
    CString         strMachineGroup = NETCONS_ROOT_THIS_MACHINE;
    CString         strNetServicesGroup = NETCONS_ROOT_NET_SERVICES;

    if ((spInternal == NULL) || (*pNodeClsid != spInternal->m_clsid))
        bExtension = TRUE;

    if (bExtension &&
        strMachineGroup.CompareNoCase(pszTaskGroup) == 0)
    {
        // There are multiple taskpad groups in the network console
        // we need to make sure we are extending the correct one.
        bAddThisMachineTasks = TRUE;
    }

    if (bExtension &&
        strNetServicesGroup.CompareNoCase(pszTaskGroup) == 0)
    {
        // There are multiple taskpad groups in the network console
        // we need to make sure we are extending the correct one.
        bAddNetServicesTasks = TRUE;
    }

    COM_PROTECT_TRY
    {
        pTasks = new CRootTasks();
        spEnumTasks = pTasks;

//        if (!(bExtension && !bAddThisMachineTasks && !bAddNetServicesTasks))
            CORg (pTasks->Init(bExtension, bAddThisMachineTasks, bAddNetServicesTasks));

        CORg (pTasks->QueryInterface (IID_IEnumTASK, (void **)ppEnumTask));

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//	CACSRootHandle
//		-
//	Author: WeiJiang
//
HRESULT CACSRootHandle::ListChildren(std::list<CACSHandle*>& children)
{
	HRESULT	hr = S_OK;
	CACSHandle*		pHandle = NULL;

	CComObject<CACSGlobalObject>*	pGlobal;
	CComPtr<CACSGlobalObject>		spGlobal;

	CComObject<CACSSubnetsObject>*	pSubnets;
	CComPtr<CACSSubnetsObject>		spSubnets;

	// Global policy folder "cn=ACS,cn=Services,cn=Configuration"
	CHECK_HR(hr = CComObject<CACSGlobalObject>::CreateInstance(&pGlobal));	// ref == 0
	spGlobal = pGlobal;
	
	// open the global folder
	hr = pGlobal->Open();

	// Change the title of the node to include the name of the domain
	ASSERT(m_aStaticStrings[0]);	// we assume root node has name
	
	*m_aStaticStrings[(INT_PTR)0] += _T(" - ");
	
	if(FAILED(hr) && pGlobal->m_nOpenErrorId)
	{
		ReportError(hr, IDS_ERR_ROOTNODE, NULL);
		hr = S_OK;
		goto L_ERR;
	}

	// if opened successfully, the get name of domain information
	CHECK_HR(hr);

	// Change the title of the node to include the name of the domain
	ASSERT(m_aStaticStrings[0]);	// we assume root node has name
	*m_aStaticStrings[(INT_PTR)0] += pGlobal->m_strDomainName;
	
	//================================
	// global handle reuse the ACSROOTDS OBject		
	pHandle = new CACSGlobalHandle(m_spTFSCompData, pGlobal);	// ref == 1

	if(!pHandle)
		CHECK_HR(hr = E_OUTOFMEMORY);

	children.push_back(pHandle);	
			
	//=======================================
	//Subnetworks configuration folder "cn=subnets,cn=sits,cn=configuration"
	CHECK_HR(hr = CComObject<CACSSubnetsObject>::CreateInstance(&pSubnets));	// ref == 0
	spSubnets = pSubnets;
	
	if FAILED(hr = spSubnets->Open())
	{

		CHECK_HR(hr);
	}
	pHandle = new CACSSubnetContainerHandle(m_spTFSCompData, pSubnets);	// ref == 1

	if(!pHandle)
		CHECK_HR(hr = E_OUTOFMEMORY);
			
	children.push_back(pHandle);	
	
L_ERR:	
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//	CACSSubnetContainerHandle
//		-
//	Author: WeiJiang
//
STDMETHODIMP CACSSubnetContainerHandle::OnCommand(	ITFSNode*	pNode,
													long		nCommandId,
													DATA_OBJECT_TYPES	type,
													LPDATAOBJECT pDataObject,
													DWORD		dwType)
{
	CStrArray			Names;
	HRESULT				hr = S_OK;
	CComObject<CDSObject>*	pNTSubnetObj = NULL;
	CComPtr<CDSObject>		spNTSubnetObj;
	CComObject<CACSSubnetObject>*	pACSSubnetObj = NULL;
	CComPtr<CACSSubnetObject>		spACSSubnetObj;
	CACSSubnetHandle*	pHandle = NULL;
	ITFSNode*			pNewNode = NULL;
    SPIComponentData    spComponentData;

    int					i;

	TRACE(_T("Command ID %d or %x is activated\n"), nCommandId, nCommandId);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch(nCommandId)
	{
	case	IDS_NEWSUBNET:
		// get the object name -- which will be a new name within the container
		CHECK_HR(hr = GetNamesForCommandNew(nCommandId, Names));

		try{
			// for each name, create an object in list
			for(i = 0; i < Names.GetSize(); i++)
			{
				// create the object in DS

				// need to create a subnet (NT subnet object in DS)
				CHECK_HR(hr = CComObject<CDSObject>::CreateInstance(&pNTSubnetObj));	// ref == 0
				spNTSubnetObj = pNTSubnetObj;	// ref == 1, previous one get dereferenced

				CHECK_HR(hr = spNTSubnetObj->Open(	m_pDSObject,
										L"subnet",
										T2W((LPTSTR)(LPCTSTR)(*Names[(INT_PTR)i])),
										true,
										true));

				m_pDSObject->AddChild(pNTSubnetObj);


				// create ACS subobject within the subnet object ...
				CHECK_HR(hr = CComObject<CACSSubnetObject>::CreateInstance(&pACSSubnetObj));
				spACSSubnetObj = pACSSubnetObj;

				CHECK_HR(hr = spACSSubnetObj->SetInfo(spNTSubnetObj, ACS_CLS_CONTAINER, ACS_NAME_ACS));
		
				// create a handle and add to the node tree
				pHandle = new CACSSubnetHandle(m_spTFSCompData, spACSSubnetObj);

				// add this to snapin UI
				if(!pHandle)
					CHECK_HR(hr = E_OUTOFMEMORY);

				AddChild(pNode, pHandle, &pNewNode);

//				pNode->Show();
				pNewNode->Show();

			}
		}catch(CMemoryException&){
			CHECK_HR(hr = E_OUTOFMEMORY);
		}

		if(Names.GetSize() == 1)
		{
			// display the property page
			m_spNodeMgr->GetComponentData(&spComponentData);

			CHECK_HR( hr = DoPropertiesOurselvesSinceMMCSucks(pNewNode, (IComponentData*)spComponentData, *Names[(INT_PTR)0]));
		}
		
		break;

	default:
		CACSHandle::OnCommand(pNode, nCommandId, type, pDataObject, dwType);

	}

L_ERR:
	if(pHandle)	pHandle->Release();
		
	if FAILED(hr)
		ReportError(hr, IDS_ERR_COMMAND, NULL);
	return hr;
}

// container handler only list the subnets defined in NT, the ACS information is stored in
// 123.123.123.0/24 --> ACS --> Config
// the ACS becomes the real ACS subnet object
HRESULT CACSSubnetContainerHandle::ListChildren(std::list<CACSHandle*>& children)
{
	HRESULT				hr = S_OK;
	CACSHandle*			pHandle = NULL;
	CComPtr<CDSObject>	spNTSubnetObj;
	CComPtr<CACSSubnetObject>	spACSSubnetObj;
	CComObject<CACSSubnetObject>*	pACSSubnetObj = NULL;
	CACSContainerObject<CDSObject>*	pSubnetCont = NULL;

	std::list<CDSObject*>	ObjList;
	std::list<CDSObject*>::iterator	i;

	pSubnetCont = dynamic_cast<CACSContainerObject<CDSObject>*>(m_pDSObject);
	CHECK_HR(hr = pSubnetCont->ListChildren(ObjList, L"subnet"));

	for( i = ObjList.begin(); i != ObjList.end(); i++)
	{
		spNTSubnetObj = *i;	// this make a release call to the interface previously stored

		CHECK_HR(hr = CComObject<CACSSubnetObject>::CreateInstance(&pACSSubnetObj));
		spACSSubnetObj = pACSSubnetObj;

		CHECK_HR(hr = spACSSubnetObj->SetInfo(spNTSubnetObj, ACS_CLS_CONTAINER, ACS_NAME_ACS));

		spACSSubnetObj->SetNoObjectState();
		
		pHandle = new CACSSubnetHandle(m_spTFSCompData, spACSSubnetObj);		// ref == 1

		if(!pHandle)
			CHECK_HR(hr = E_OUTOFMEMORY);

		children.push_back(pHandle);
		
	}
L_ERR:	
	for( i = ObjList.begin(); i != ObjList.end(); i++)
	{
		(*i)->Release();			// release the data objects
	}
	
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//	CACSSubnetContainerHandle
//		-
//	Author: WeiJiang
//

HRESULT
CACSSubnetContainerHandle::GetNamesForCommandNew(int nCommandId, CStrArray& Names)
{
	CDlgNewSubnet	dlg;
	CString*	pStr = NULL;

	dlg.SetNameList(m_pDSObject->GetChildrenNameList());
	
	if(dlg.DoModal() == IDOK && dlg.m_strSubnetName.GetLength())
	{
		pStr = new CString(dlg.m_strSubnetName);
		Names.Add(pStr);
		return S_OK;
	}
	else
		return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	CACSPolicyContainerHandle
//		-
//	Author: WeiJiang
//

STDMETHODIMP
CACSSubnetHandle::OnCommand(	ITFSNode*	pNode,
										long		nCommandId,
										DATA_OBJECT_TYPES	type,
										LPDATAOBJECT pDataObject,
										DWORD		dwType)
{
	HRESULT	hr = S_OK;

	CACSSubnetObject*	pACSSubnetObj = (CACSSubnetObject *)m_pDSObject;
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch(nCommandId)
	{
	case	IDS_DELETESUBNET:
		if(S_OK == BringUpPropertyPageIfOpen(pNode, NULL))
		{
			AfxMessageBox(IDS_ERROR_CLOSE_PROPERTY_SHEET);
			hr = S_FALSE;
			break;
		}
		
		if (AfxMessageBox(IDS_CONFIRM_DELETE, MB_YESNO) != IDYES)
			break;

		// delete the corresponding DS object -- subnet object is a special version, which keeps the C++ object, but delete the DS object underneath
		hr = m_pDSObject->Delete();
		if(hr == ERROR_NO_SUCH_OBJECT)	// no such object
			hr = S_FALSE;
		CHECK_HR(hr);
		
		// remove from UI -- to get rid of the sub object within it
		if(hr == S_OK)
		{
			CHECK_HR(hr = pNode->DeleteAllChildren(true));
			UpdateStrings();
		}

		break;

	default:
		hr = CACSPolicyContainerHandle::OnCommand(pNode, nCommandId, type, pDataObject, dwType);
		break;

	}

L_ERR:
	if FAILED(hr)
		ReportError(hr, IDS_ERR_COMMAND, NULL);

	pACSSubnetObj->SetNoObjectState();
		
	return hr;
}


// only shown conflict state here
HRESULT
CACSSubnetHandle::ShowState(DWORD state)
{
	DWORD	dwShownState = GetShownState();

	HRESULT hr;
	UINT	id;

	CHECK_HR(hr = CACSHandle::ShowState(state));
	if(m_pNode == NULL)
		return S_OK;
	// change state on UI

	id = ((state & ACSDATA_STATE_NOOBJECT) != 0)? IMAGE_IDX_SUBNETWORK_NO_ACSPOLICY : IMAGE_IDX_SUBNETWORK;

	m_pNode->SetData(TFS_DATA_IMAGEINDEX, id);
	m_pNode->SetData(TFS_DATA_OPENIMAGEINDEX, id);
	hr = m_pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM);
	//
	
L_ERR:
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//	CACSHandle
//		-
//	Author: WeiJiang
//
STDMETHODIMP
CACSSubnetHandle::CreatePropertyPages
(
    ITFSNode                *pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject,
	LONG_PTR				handle,
    DWORD                   dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT        	hr = S_OK;
    DWORD		   	dwError;
    CString        	strServiceName;

	CPgGeneral* 	pPgGeneral = NULL;
	CPgServers*		pPgServers = NULL;
	CPgLogging*		pPgLogging = NULL;
	CPgAccounting*	pPgAccounting = NULL;
	CPgSBM*			pPgSBM = NULL;

	HPROPSHEETPAGE	hPgGeneral = NULL;
	HPROPSHEETPAGE	hPgServers = NULL;
	HPROPSHEETPAGE	hPgLogging = NULL;
	HPROPSHEETPAGE	hPgAccounting = NULL;
	HPROPSHEETPAGE 	hPgSBM = NULL;
	BOOL			bNewCreated = FALSE;

	CComObject<CACSSubnetPageManager>* pPageManager;

	hr = CComObject<CACSSubnetPageManager>::CreateInstance(&pPageManager);
	
    if (FAILED(hr))
       return hr;

    CACSSubnetObject* pObj = dynamic_cast<CACSSubnetObject*>(m_pDSObject);
    ASSERT(pObj);	// expect this object to be this type

	CComPtr<CACSSubnetConfig> spConfig;

	CHECK_HR(hr = pObj->MakeSureExist(&bNewCreated));		// make sure the current DS object is active

	m_pDSObject->SetNoObjectState();
	// if this is new added policy, need to re-expand to make sure the new added ones can be seen
	if(bNewCreated && m_bACSHandleExpanded)
	{
	// node already in Expanded state, need to manually expand again, since
		CHECK_HR(hr = pNode->DeleteAllChildren(true));
		// we re-created the data object
		CHECK_HR(hr = OnExpand(pNode, pDataObject, 0, 1, 0));
	}

	pObj->GetConfig(&spConfig);

	pPageManager->SetMMCNotify(handle, (LPARAM)this);
	pPageManager->SetSubnetData(spConfig, this);

	CHECK_HR(hr = spConfig->Reopen());		// make sure the current DS object is active

    //===============
    // general page -- traffic
    {
    CComPtr<CACSSubnetLimitsContainer> spLimitsCont;
    pObj->GetLimitsContainer(&spLimitsCont);
	CHECK_HR(hr = spLimitsCont->Reopen());		// make sure the current DS object is active
	pPgGeneral  = new CPgGeneral((CACSSubnetConfig*)spConfig, (CACSContainerObject<CACSSubnetServiceLimits>*) spLimitsCont );

	pPageManager->AddPage(pPgGeneral);
	}
	
    // tell MMC to hook the proc because we are running on a separate,
    // non MFC thread.

	// change callback function to delete itself when the property sheet is released
	pPgGeneral->SetSelfDeleteCallback();
	
	MMCPropPageCallback(&pPgGeneral->m_psp);

	hPgGeneral = ::CreatePropertySheetPage(&pPgGeneral->m_psp);
	if(hPgGeneral == NULL)
		return E_UNEXPECTED;

	lpProvider->AddPage(hPgGeneral);

    //===============
    // Servers page
	pPgServers  = new CPgServers((CACSSubnetConfig*)spConfig);

	pPageManager->AddPage(pPgServers);

    // tell MMC to hook the proc because we are running on a separate,
    // non MFC thread.

	// change callback function to delete itself when the property sheet is released
	pPgServers->SetSelfDeleteCallback();
	
	MMCPropPageCallback(&pPgServers->m_psp);

	hPgServers = ::CreatePropertySheetPage(&pPgServers->m_psp);
	if(hPgServers == NULL)
		return E_UNEXPECTED;

	lpProvider->AddPage(hPgServers);

    //===============
    // logging page
	pPgLogging  = new CPgLogging((CACSSubnetConfig*)spConfig);

	pPageManager->AddPage(pPgLogging);
    // tell MMC to hook the proc because we are running on a separate,
    // non MFC thread.
	pPgLogging->SetSelfDeleteCallback();
	MMCPropPageCallback(&pPgLogging->m_psp);

	hPgLogging = ::CreatePropertySheetPage(&pPgLogging->m_psp);
	if(hPgLogging == NULL)
		return E_UNEXPECTED;

	lpProvider->AddPage(hPgLogging);

    //===============
    // Accouting page -- added by WeiJiang 2/16/98

	pPgAccounting  = new CPgAccounting((CACSSubnetConfig*)spConfig);

	pPageManager->AddPage(pPgAccounting);
    // tell MMC to hook the proc because we are running on a separate,
    // non MFC thread.
	pPgAccounting->SetSelfDeleteCallback();
	MMCPropPageCallback(&pPgAccounting->m_psp);

	hPgAccounting = ::CreatePropertySheetPage(&pPgAccounting->m_psp);
	if(hPgAccounting == NULL)
		return E_UNEXPECTED;

	lpProvider->AddPage(hPgAccounting);

    //===============
    // advanced page -- SBM
	pPgSBM  = new CPgSBM((CACSSubnetConfig*)spConfig);

	pPageManager->AddPage(pPgSBM);
    // tell MMC to hook the proc because we are running on a separate,
    // non MFC thread.

	pPgSBM->SetSelfDeleteCallback();
	MMCPropPageCallback(&pPgSBM->m_psp);

	hPgSBM = ::CreatePropertySheetPage(&pPgSBM->m_psp);
	if(hPgSBM == NULL)
		return E_UNEXPECTED;

	lpProvider->AddPage(hPgSBM);

L_ERR:	//
	if FAILED(hr)
		ReportError(hr, IDS_ERR_PROPERTYPAGE, NULL);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//	CACSPolicyContainerHandle
//		-
//	Author: WeiJiang
//

STDMETHODIMP
CACSPolicyContainerHandle::OnCommand(	ITFSNode*	pNode,
										long		nCommandId,
										DATA_OBJECT_TYPES	type,
										LPDATAOBJECT pDataObject,
										DWORD		dwType)
{
	CStrArray			Names;
	HRESULT				hr = S_OK;
	CComObject<CACSPolicyElement>*	pDSObj = NULL;
	CComPtr<CACSPolicyElement>		spObj;
	CACSPolicyHandle*	pHandle = NULL;
	ITFSNode*			pNewNode = NULL;
    SPIComponentData        spComponentData;
    CACSSubnetObject*	pSubnetObj;
    int					i, j;
    TCHAR				szNameCanonical[MAX_PATH * 2];
    ULONG               len = MAX_PATH * 2;

	TRACE(_T("Command ID %d or %x is activated\n"), nCommandId, nCommandId);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch(nCommandId)
	{
	case	IDS_NEWPOLICY:
		// get the object name -- which will be a new name within the container
		CHECK_HR(hr = GetNamesForCommandNew(nCommandId, Names));

		// for each name, create an object in list
		try{
			for(i = 0; i < Names.GetSize(); i++)
			{
		
				// create the object in DS
				CHECK_HR(hr = CComObject<CACSPolicyElement>::CreateInstance(&pDSObj));	// ref == 0
				spObj = pDSObj;		// ref == 1
				CString*	pStr;
				
				try{
				pSubnetObj = dynamic_cast<CACSSubnetObject*>(m_pDSObject);
				}
				catch(...)
				{
				};
				if(pSubnetObj)	// the policy is in subnet folder, otherwise, it will be global
				{
					BOOL	bNew;
					CHECK_HR(hr = pSubnetObj->MakeSureExist(&bNew));
					if(bNew)
					{
						CHECK_HR(hr = pNode->DeleteAllChildren(true));
						CHECK_HR(hr = OnExpand(pNode, pDataObject, 0, 1, 0));
					}
				}
				spObj->SetFlags(ATTR_FLAG_SAVE, spObj->SetDefault(), true);
				CHECK_HR(hr = spObj->Open(	m_pDSObject,
										ACS_CLS_POLICY,
										T2W((LPTSTR)(LPCTSTR)*Names[(INT_PTR)i]),
										true,
										true));

				spObj->m_bUseName_NewPolicy = TRUE;

				m_pDSObject->AddChild(pDSObj);
				// create a handle and add to the node tree
				pHandle = new CACSPolicyHandle(m_spTFSCompData, spObj);

				CHECK_HR(hr = spObj->Close());

				// add this to snapin UI
				AddChild(pNode, pHandle, &pNewNode);

				if(!pHandle)
					CHECK_HR(hr = E_OUTOFMEMORY);

				pNode->Show();
			}

			// Display the property pages if there is only one new policy added
			if(Names.GetSize() == 1)
			{
				CString	newPolicyName;
				newPolicyName.LoadString(IDS_NEWACSPOLICY);
				// display the property page
				m_spNodeMgr->GetComponentData(&spComponentData);

				pHandle->SetDeleteOnCancelPropertyPage(pNewNode);

				CHECK_HR( hr = DoPropertiesOurselvesSinceMMCSucks(pNewNode, (IComponentData*)spComponentData, newPolicyName));
			}

		}catch(CMemoryException&){
			CHECK_HR(hr = E_OUTOFMEMORY);
		}

		break;

	default:
		CACSHandle::OnCommand(pNode, nCommandId, type, pDataObject, dwType);
		break;

	}

L_ERR:
	if(pHandle)	pHandle->Release();
		
	if FAILED(hr)
		ReportError(hr, IDS_ERR_COMMAND, NULL);
	return hr;
}


HRESULT CACSPolicyContainerHandle::OnExpand(	
ITFSNode *pNode,LPDATAOBJECT pDataObject, DWORD dwType, LPARAM arg,LPARAM param)
{
	HRESULT				hr = hrOK;
	CACSPolicyContainer*	pCont = NULL;

	CHECK_HR(hr = CACSHandle::OnExpand(pNode, pDataObject, dwType, arg, param));
	pCont = dynamic_cast<CACSPolicyContainer*>(m_pDSObject);
	pCont->SetChildrenConflictState();

L_ERR:
	return hr;
}
HRESULT CACSPolicyContainerHandle::ListChildren(std::list<CACSHandle*>& children)
{
	HRESULT				hr = S_OK;
	CACSHandle*			pHandle = NULL;
	CComPtr<CDSObject>	spObj;
	CACSPolicyContainer*	pCont = NULL;

	std::list<CACSPolicyElement*>	ObjList;
	std::list<CACSPolicyElement*>::iterator	i;

	pCont = dynamic_cast<CACSPolicyContainer*>(m_pDSObject);
	hr = pCont->ListChildren(ObjList, ACS_CLS_POLICY);

	if(hr == ERROR_NO_SUCH_OBJECT)	// object is not found in DS, it's fine, since, some subnet with no ACS info
	{
		hr = S_OK;
		goto	L_ERR;
	}

	CHECK_HR(hr);

	for( i = ObjList.begin(); i != ObjList.end(); i++)
	{
		spObj = *i;	// this make a release call to the interface previously stored
		pHandle = new CACSPolicyHandle(m_spTFSCompData, spObj);

		CACSPolicyElement* pPolicy = dynamic_cast<CACSPolicyElement*>((CDSObject*)spObj);
		ASSERT(pPolicy);

		if(!pHandle)
			CHECK_HR(hr = E_OUTOFMEMORY);

		pHandle->SetBranch(m_nBranchFlag);
		children.push_back(pHandle);
	}
L_ERR:	
	for( i = ObjList.begin(); i != ObjList.end(); i++)
	{
		(*i)->Release();
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//	CACSPolicyContainerHandle
//		-
//	Author: WeiJiang
//

HRESULT
CACSPolicyContainerHandle::GetNamesForCommandNew(int nCommandId, CStrArray& Names)
{
	// name of a policy is not important to the consumer of the policy
	// policy name is constructed as AcsPolicyYYYYMMDDMMn, AcsPolicy198808211236

	ASSERT(nCommandId == IDS_NEWPOLICY);
	CString*		pstrName = new CString();
	SYSTEMTIME		sysTime;

	GetSystemTime(&sysTime);

	pstrName->Format(_T("AcsPolicy%04d%02d%02d%02d%02d"), sysTime.wYear, sysTime.wMonth, sysTime.wDay, sysTime.wHour, sysTime.wMinute);
	CStrArray* pExistingNames =	m_pDSObject->GetChildrenNameList();

	int	i = 0;
	while(pExistingNames && pExistingNames->Find(*pstrName) != -1)	// found in existing names
	{
		// try next name with
		pstrName->Format(_T("AcsPolicy%04d%02d%02d%02d%02d%-d"), sysTime.wYear, sysTime.wMonth, sysTime.wDay, sysTime.wHour, sysTime.wMinute, i++);
	};

	Names.Add(pstrName);
	
	if (!Names.GetSize())
		return S_OK;
	else
		return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	CACSPolicyHandle
//		-
//	Author: WeiJiang
//

/*!--------------------------------------------------------------------------
	CACSPolicyHandle::CreatePropertyPages
		Implementation of ITFSResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CACSPolicyHandle::CreatePropertyPages
(
    ITFSNode                *pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject,
	LONG_PTR				handle,
    DWORD                   dwType
)
{
	return CreatePropertyPages((ITFSComponent*)NULL, (long) 0, lpProvider, pDataObject, handle);
}

HRESULT CACSPolicyHandle::OnResultDelete(	ITFSComponent*	pComponent,
											LPDATAOBJECT 	pDataObject,
											MMC_COOKIE 			cookie,
											LPARAM 			arg,
											LPARAM 			lParam)
{
	Trace0("CACSPolicyHandle::Notify(MMCN_DELETE) received\n");

	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CComPtr<CACSPolicyContainer>	spCont;

	// GetContainer already AddRef, so avoid AddRef twice, assign directly to .p
	spCont.p = dynamic_cast<CACSPolicyContainer*>(m_pDSObject->GetContainer());

	HRESULT hr = CACSHandle::OnResultDelete(pComponent, pDataObject, cookie, arg, lParam);

	spCont->SetChildrenConflictState();

	return hr;
}



// only shown conflict state here
HRESULT
CACSPolicyHandle::ShowState(DWORD state)
{
	DWORD	dwShownState = GetShownState();

	HRESULT hr;
	UINT	id;

	CHECK_HR(hr = CACSHandle::ShowState(state));
	if(m_pNode == NULL)
		return S_OK;
/*
		||
		(dwShownState & (ACSDATA_STATE_CONFLICT | ACSDATA_STATE_DISABLED)) == (state & (ACSDATA_STATE_CONFLICT | ACSDATA_STATE_DISABLED)))
		return S_OK;
*/
	// change conflict state on UI

	id = ((state & ACSDATA_STATE_CONFLICT) != 0)? IMAGE_IDX_CONFLICTPOLICY : IMAGE_IDX_POLICY;
	id = ((state & ACSDATA_STATE_DISABLED) != 0)? IMAGE_IDX_DISABLEDPOLICY : id;

	m_pNode->SetData(TFS_DATA_IMAGEINDEX, id);
	m_pNode->SetData(TFS_DATA_OPENIMAGEINDEX, id);
	hr = m_pNode->ChangeNode(RESULT_PANE_CHANGE_ITEM);
	//
	
L_ERR:
	return hr;
}

STDMETHODIMP
CACSPolicyHandle::CreatePropertyPages
(
    ITFSComponent *         pComponent,
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider,
	LPDATAOBJECT			pDataObject,
	LONG_PTR				handle
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT        hr = S_OK;
    DWORD		   dwError;
    CString        strServiceName;

    if (FAILED(hr))
       return FALSE;

    CACSPolicyElement* pObj = dynamic_cast<CACSPolicyElement*>(m_pDSObject);
	CComPtr<CACSPolicyElement> spElement;

	ASSERT(pObj);

	spElement = pObj;
	
	CHECK_HR(hr = spElement->Reopen());

	try{
		CPgPolicyGeneral*	pPgGeneral = NULL;
		CPgPolicyFlow* 		pPgFlow = NULL;
		CPgPolicyAggregate*	pPgAggr = NULL;
		HPROPSHEETPAGE		hPgGeneral = NULL;
		HPROPSHEETPAGE		hPgFlow = NULL;
		HPROPSHEETPAGE		hPgAggr = NULL;

		// create a page manager for all the pages
		CComObject<CACSPolicyPageManager>* pPageManager;
		CHECK_HR(hr = CComObject<CACSPolicyPageManager>::CreateInstance(&pPageManager));
		pPageManager->SetPolicyData(spElement, this);
		pPageManager->SetMMCNotify(handle, (LPARAM)this);

    	//===============
	    // general page
		pPgGeneral  = new CPgPolicyGeneral((CACSPolicyElement*)spElement);
		pPageManager->AddPage(pPgGeneral);	// add a page to the manager
		pPageManager->SetGeneralPage(pPgGeneral);
		pPageManager->SetBranchFlag(m_nBranchFlag);
		
	    // tell MMC to hook the proc because we are running on a separate,
    	// non MFC thread.
		// change callback function to delete itself when the property sheet is released
		pPgGeneral->SetSelfDeleteCallback();

		// if there are specil operation on Cancel, make sure the page is dirty
		// even when user just click on OK, OnApply is still called.
		if(m_bDeleteUponCancel)
			pPgGeneral->SetModified();
	

		MMCPropPageCallback(&pPgGeneral->m_psp);

		hPgGeneral = ::CreatePropertySheetPage(&pPgGeneral->m_psp);
		if(hPgGeneral == NULL)
			CHECK_HR(hr = E_UNEXPECTED);

		lpProvider->AddPage(hPgGeneral);

		//=====================
		// Flow page
		pPgFlow  = new CPgPolicyFlow((CACSPolicyElement*)spElement);
		pPageManager->AddPage(pPgFlow);	// add a page to the manager
		// tell MMC to hook the proc because we are running on a separate,
    	// non MFC thread.
		// change callback function to delete itself when the property sheet is released
		pPgFlow->SetSelfDeleteCallback();

		MMCPropPageCallback(&pPgFlow->m_psp);

		hPgFlow = ::CreatePropertySheetPage(&pPgFlow->m_psp);
		if(hPgFlow == NULL)
			CHECK_HR(hr = E_UNEXPECTED);

		lpProvider->AddPage(hPgFlow);

		// set branch info and ..
		pPgFlow->m_nBranchFlag = m_nBranchFlag;
		pPgFlow->m_pGeneralPage = pPgGeneral;



		//=====================
		// Aggr page
		pPgAggr  = new CPgPolicyAggregate((CACSPolicyElement*)spElement);
		pPageManager->AddPage(pPgAggr);	// add a page to the manager
	    // tell MMC to hook the proc because we are running on a separate,
    	// non MFC thread.
		// change callback function to delete itself when the property sheet is released
		pPgAggr->SetSelfDeleteCallback();

		MMCPropPageCallback(&pPgAggr->m_psp);

		hPgAggr = ::CreatePropertySheetPage(&pPgAggr->m_psp);
		if(hPgAggr == NULL)
			CHECK_HR(hr = E_UNEXPECTED);

		lpProvider->AddPage(hPgAggr);

		// set branch info and ..
		pPgAggr->m_nBranchFlag = m_nBranchFlag;
		pPgAggr->m_pGeneralPage = pPgGeneral;


	}catch(CMemoryException&){
		CHECK_HR(hr = E_OUTOFMEMORY);
	}

L_ERR:
	if FAILED(hr)
		ReportError(hr, IDS_ERR_PROPERTYPAGE, NULL);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acscomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	acscomp.cpp
		This file contains the derived classes for CComponent and 
		CComponentData.  Most of these functions are pure virtual 
		functions that need to be overridden for snapin functionality.
		
    FILE HISTORY:
    	11/05/97	Wei Jiang			Created
        
*/

#include "stdafx.h"
#include "acsadmin.h"
#include "acscomp.h"
#include "acshand.h"
#include "acsdata.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ACSSNAP_HELP_FILE_NAME   "acssnap.chm"


/////////////////////////////////////////////////////////////////////////////
// CACSComponent implementation

CACSComponent::CACSComponent()
{
}

CACSComponent::~CACSComponent()
{
}

STDMETHODIMP CACSComponent::OnUpdateView(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param)
{
	return TFSComponent::OnUpdateView(pDataObject, arg, param);
}

STDMETHODIMP CACSComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_spImageList != NULL);

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		CBitmap bmp16x16;
		CBitmap bmp32x32;
	
		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16X16);
		bmp32x32.LoadBitmap(IDB_32X32);

		// Set the images
		m_spImageList->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
					0, RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    CACSComponent::OnSnapinHelp
        -
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CACSComponent::OnSnapinHelp
(
    LPDATAOBJECT    pDataObject,
    long            arg,
    long            param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

//    theApp.WinHelp(DHCPSNAP_HELP_SNAPIN, HELP_CONTEXT);
	HtmlHelpA(NULL, "acssnap.chm", HH_DISPLAY_TOPIC, 0);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CACSComponentData implementation

CACSComponentData::CACSComponentData()
{
}


void CACSComponentData::GetConsoleData()
{
	// Init console data
	ZeroMemory(&m_ConsoleData, sizeof(CACSConsoleData));
	m_ConsoleData.ulSize = sizeof(CACSConsoleData);
	m_ConsoleData.ulVersion = ACS_CONSOLE_VERSION;
	m_ConsoleData.ulMaxCol = ACS_CONSOLE_MAX_COL;
	memcpy(m_ConsoleData.ulPolicyColWidth, g_col_width_policy, g_col_count_policy);
	memcpy(m_ConsoleData.ulSubnetColWidth, g_col_width_subnet, g_col_count_subnet);

}

void CACSComponentData::SetConsoleData()
{
	// Init console data
	memcpy(g_col_width_policy, m_ConsoleData.ulPolicyColWidth, g_col_count_policy);
	memcpy(g_col_width_subnet, m_ConsoleData.ulSubnetColWidth, g_col_count_subnet);
}

/*!--------------------------------------------------------------------------
	CACSComponentData::OnInitialize
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CACSComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(pScopeImage);

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		// add the images for the scope tree
		CBitmap bmp16x16;

		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16X16);

		// Set the images
		pScopeImage->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					0,
					RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CACSComponentData::OnInitializeNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CACSComponentData::OnInitializeNodeMgr(ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	CACSRootHandle*		pHandler = NULL;

	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode;
	HRESULT				hr = hrOK;

	COM_PROTECT_TRY
	{
		pHandler = new CACSRootHandle(pTFSCompData, NULL);
		

		// Do this so that it will get released correctly
		spHandler = pHandler;
	
		// Create the root node for this sick puppy
		CHECK_HR( hr = CreateContainerTFSNode(&spNode,
									 &CLSID_ACSRootNode,
									 pHandler,
									 pHandler /* result handler */,
									 pNodeMgr) );
		
		// Need to initialize the data for the root node
		spNode->SetData(TFS_DATA_IMAGEINDEX, pHandler->m_ulIconIndex);
		spNode->SetData(TFS_DATA_OPENIMAGEINDEX, pHandler->m_ulIconIndexOpen);
		spNode->SetData(TFS_DATA_SCOPEID, 0);
	    pTFSCompData->SetHTMLHelpFileName(_T(ACSSNAP_HELP_FILE_NAME));		
		CHECK_HR(hr = pNodeMgr->SetRootNode(spNode) );
	
		// in general do
		//		spNode->SetData(TFS_DATA_COOKIE, (DWORD)(ITFSNode *)spNode);
		spNode->SetData(TFS_DATA_COOKIE, 0);
	}
	COM_PROTECT_CATCH;

L_ERR:	

	if FAILED(hr)
		ReportError(hr, IDS_ERR_ROOTNODE, NULL);
		
	return S_OK;
}

/*!--------------------------------------------------------------------------
	CACSComponentData::OnCreateComponent
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CACSComponentData::OnCreateComponent(LPCOMPONENT *ppComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(ppComponent != NULL);
	
	HRESULT		hr = hrOK;
	CACSComponent *	pComp = NULL;

	COM_PROTECT_TRY
	{
		pComp = new CACSComponent;
		
		if (FHrSucceeded(hr))
		{
			pComp->Construct(m_spNodeMgr,
							 static_cast<IComponentData *>(this),
							 m_spTFSComponentData);
			*ppComponent = static_cast<IComponent *>(pComp);
		}
	}
	COM_PROTECT_CATCH;
	
	if FAILED(hr)
		ReportError(hr, IDS_ERR_COMPONENT, NULL);
		
	return hr;
}


STDMETHODIMP CACSComponentData::OnDestroy()
{
	m_spNodeMgr.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CACSComponentData::GetCoClassID
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) CACSComponentData::GetCoClassID()
{
	return &CLSID_ACSSnap;
}

/*!--------------------------------------------------------------------------
	CACSComponentData::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CACSComponentData::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ppDataObject != NULL);

	CDSIDataObject *		pObject = NULL;
	CComPtr<CDSIDataObject>	spDataObject;
	
	pObject = new CDSIDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
	if(pObject)
		pObject->Release();
						
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*GetCoClassID());

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CACSComponentData::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_ACSSnap;

    return hrOK;
}

STDMETHODIMP CACSComponentData::IsDirty()
{
	SPITFSNode	spNode;
	m_spNodeMgr->GetRootNode(&spNode);
	return spNode->GetData(TFS_DATA_DIRTY) ? hrOK : hrFalse;
}

STDMETHODIMP CACSComponentData::Load
(
	IStream *pStm
)
{
    HRESULT hr = S_OK;
    ULONG		ulDataSize;
    CACSConsoleData	Data;
	ASSERT(pStm);

    // Console Data
	hr = pStm->Read(&Data, sizeof(CACSConsoleData), &ulDataSize);
	if (SUCCEEDED(hr))
	{
		if(ulDataSize == sizeof(CACSConsoleData) && Data.ulSize == sizeof(CACSConsoleData)
			&& Data.ulVersion == ACS_CONSOLE_VERSION && Data.ulMaxCol == ACS_CONSOLE_MAX_COL)
		{
			memcpy(&m_ConsoleData, &Data, sizeof(m_ConsoleData));
			SetConsoleData();
		}
	}

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}


STDMETHODIMP CACSComponentData::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	HRESULT hr = S_OK;
	SPITFSNode	spNode;
	ULONG	ulDataSize;

	ASSERT(pStm);

    // Console Data
	GetConsoleData();
	hr = pStm->Write(&m_ConsoleData, sizeof(CACSConsoleData), &ulDataSize);

	if (SUCCEEDED(hr) && fClearDirty)
	{
		m_spNodeMgr->GetRootNode(&spNode);
		spNode->SetData(TFS_DATA_DIRTY, FALSE);
	}

    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}


STDMETHODIMP CACSComponentData::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 500);

    return S_OK;
}

STDMETHODIMP CACSComponentData::InitNew()
{
	return hrOK;
}



HRESULT CACSComponentData::FinalConstruct()
{
	HRESULT				hr = hrOK;
	
	hr = CComponentData::FinalConstruct();
	
	if (FHrSucceeded(hr))
	{
		m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
	}
	return hr;
}

void CACSComponentData::FinalRelease()
{
	CComponentData::FinalRelease();
}

	

STDMETHODIMP CACSComponentData::OnNotifyPropertyChange(  LPDATAOBJECT lpDataObject,  // pointer to a data object
		MMC_NOTIFY_TYPE event,  // action taken by a user
		LPARAM arg,               // depends on event
		LPARAM param              // depends on event
)
{
	return CACSHandle::NotifyDataChange(param);
}

HRESULT CACSComponent::OnNotifyPropertyChange(  LPDATAOBJECT lpDataObject,  // pointer to a data object
		MMC_NOTIFY_TYPE event,  // action taken by a user
		LPARAM arg,               // depends on event
		LPARAM param              // depends on event
)
{
	return CACSHandle::NotifyDataChange(param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acsdata.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	AcsData.cpp
		Implement DataObject classes used in ACS
		
    FILE HISTORY:
    	11/11/97	Wei Jiang			Created

*/

#include "stdafx.h"

#include "resource.h"			// main symbol definition
#include "helper.h"
#include "acsdata.h"
#include "acshand.h"

///////////////////////////////////////////////////////////////////////////////
//
// CDSIDataObject
//
//
unsigned int CDSIDataObject::m_cfDsObjectNames =
								RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);

//+----------------------------------------------------------------------------
//
//  Method:     CDSIDataObject::IDataObject::GetData
//
//  Synopsis:   Returns data, in this case the Prop Page format data.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDSIDataObject::GetData(FORMATETC * pFormatEtc, STGMEDIUM * pMedium)
{
	HRESULT	hr = S_OK;
	
    TRACE(_T("CDSIDataObject::GetData\n"));

    USES_CONVERSION;

    if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM)))
    {
        return E_INVALIDARG;
    }
    if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
    {
        return DV_E_TYMED;
    }

    if (pFormatEtc->cfFormat == m_cfDsObjectNames)
    {
		if(!m_bstrADsPath || !m_bstrClass)
			return DV_E_FORMATETC;

        // Return the object name and class.
        //
        LPCTSTR	szPath = W2T(m_bstrADsPath);
        LPCTSTR	szClass = W2T(m_bstrClass);

        int		cbPath  = sizeof(TCHAR) * (_tcslen(szPath) + 1);
        int		cbClass = sizeof(TCHAR) * (_tcslen(szClass) + 1);
        int		cbStruct = sizeof(DSOBJECTNAMES);

        LPDSOBJECTNAMES pDSObj;

        pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                              cbStruct + cbPath + cbClass);

        if (pDSObj == NULL)
        {
            return STG_E_MEDIUMFULL;
        }

        pDSObj->clsidNamespace = CLSID_MicrosoftDS;
        pDSObj->cItems = 1;
        pDSObj->aObjects[0].offsetName = cbStruct;
        pDSObj->aObjects[0].offsetClass = cbStruct + cbPath;

        _tcscpy((LPTSTR)((BYTE *)pDSObj + cbStruct), szPath);
        _tcscpy((LPTSTR)((BYTE *)pDSObj + cbStruct + cbPath), szClass);

        pMedium->hGlobal = (HGLOBAL)pDSObj;
        hr = S_OK;
    }
    else
		hr = CDataObject::GetData(pFormatEtc, pMedium);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CDSObject
//
//
CDSObject::CDSObject(bool bNoRefCountOnContainer) :
		m_bstrADsPath(NULL),
		m_bstrClass(NULL),
		m_bstrName(NULL),
		m_bNewCreated(false),
		m_bOpened(false),
		m_pHandle(NULL),
		m_dwState(0),
		m_bNoRefCountOnContainer(bNoRefCountOnContainer)
{
	m_dwAttributeFlags[ATTR_FLAG_LOAD] = 0;
	m_dwAttributeFlags[ATTR_FLAG_SAVE] = 0;
}

CDSObject::~CDSObject()
{
	Close();

	if(m_bNoRefCountOnContainer)
		m_spContainer.p = NULL;
	else
		m_spContainer.Release();
		
	SysFreeString(m_bstrClass);
	m_bstrClass = NULL;
	SysFreeString(m_bstrName);
	m_bstrName = NULL;
}
	
//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::Delete
//
//  Synopsis:   Delete the object from DS
//
//-----------------------------------------------------------------------------
STDMETHODIMP	CDSObject::Delete()
{
	HRESULT		hr = S_OK;
	BSTR		strThisRDN = NULL;
	BSTR		strThisCls = NULL;
	CComPtr<IADsContainer>	spContainer;
	CComPtr<IADs>			spContainerIADs;

	if(!(CDSObject*)m_spContainer)	return S_FALSE;
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CHECK_HR(hr = Reopen());
	hr = m_spIADs->QueryInterface(IID_IADsContainer, (void**)&spContainer);

	if(hr == S_OK)	// it's a container
	{
		CComPtr<IEnumVARIANT>	spEnum;
		CComPtr<IADs>			spChild;
		CComPtr<IDispatch>		spDisp;
		CComObject<CDSObject>*	pDSObj = NULL;
		CComPtr<CDSObject>		spDSObj;
		VARIANT					var;

		VariantInit(&var);

		CHECK_HR(hr = ADsBuildEnumerator(spContainer, &spEnum));

		while(S_OK == (hr = ADsEnumerateNext(spEnum, 1, &var, NULL)))
		{
			spDisp = var.pdispVal;
			spChild.Release();	// make sure spChild is NULL
	        CHECK_HR(hr = spDisp->QueryInterface(IID_IADs, (VOID **)&spChild));
			// if this object is a profile object

			// create the object
			spDSObj.Release();		// make sure it's  NULL
			CHECK_HR(hr = CComObject<CDSObject>::CreateInstance(&pDSObj));	// with 0 reference count
			spDSObj = pDSObj;

			CHECK_HR(hr = spDSObj->Attach(this, spChild));

			// delete
			spDSObj->Delete();
		}

		spContainer.Release();
	}
	
	CHECK_HR(hr = m_spIADs->get_Name (&strThisRDN));
	CHECK_HR(hr = m_spIADs->get_Class (&strThisCls));

	m_spIADs.Release();
	m_spContainer->GetIADs(&spContainerIADs);

	CHECK_HR(hr = spContainerIADs->QueryInterface(IID_IADsContainer, (void**)&spContainer));
	ASSERT((IADsContainer*)spContainer);
	CHECK_HR(hr = spContainer->Delete(strThisCls, strThisRDN));
	m_spContainer->RemoveChild(this);

L_ERR:
	SysFreeString(strThisRDN);
	SysFreeString(strThisCls);

	return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::Rename
//
//  Synopsis:   Rename the object within the save container
//
//-----------------------------------------------------------------------------
STDMETHODIMP	CDSObject::Rename(LPCWSTR szName)
{

	HRESULT 	hr = S_OK;
	DWORD 		result;
	CString 	AttrName;
	CString 	str;
	CComPtr<IDispatch>		spDispObj;
	CComPtr<IADs>			spADs;
	CComPtr<IADsContainer>	spIContainer;

	// if we didn't create it, we don't delete it
	if(!(CDSObject*)m_spContainer)	return S_FALSE;
	
	AttrName = L"cn=";
	AttrName += szName;
	TRACE(_T("CDSObject::Rename: Attributed name is %s.\n"), AttrName);

	m_spIADs.Release();

	// get container's IADs interface
	CHECK_HR(hr = m_spContainer->GetIADs(&spADs));

	// get containers's IADsContainer interface
  	CHECK_HR(hr = spADs->QueryInterface(IID_IADsContainer, (void**)&spIContainer));
  	ASSERT((IADsContainer*)spIContainer);

	CHECK_HR(hr = Reopen());	// make sure m_bADsPath is set
	str = m_bstrADsPath;
	CHECK_HR(hr = Close());		// close it before rename

	CHECK_HR(hr = spIContainer->MoveHere((LPWSTR)(LPCWSTR)str, (LPWSTR)(LPCWSTR)AttrName, &spDispObj));
	CHECK_HR(hr = spDispObj->QueryInterface (IID_IADs, (void **)&m_spIADs));

	ASSERT((IADs*)m_spIADs);

	SysFreeString(m_bstrName);
	CHECK_HR(hr = m_spIADs->get_Name(&m_bstrName));

	m_spIADs.Release();

L_ERR:

	return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::Save
//
//  Synopsis:   Save the object to DS
//
//-----------------------------------------------------------------------------
STDMETHODIMP	CDSObject::Save(DWORD dwAttrFlags)
{
	HRESULT	hr;
	if((IADs*)m_spIADs)
	{
		CHECK_HR(hr = OnSave(dwAttrFlags));				// any additional processing before save
		CHECK_HR(hr = m_spIADs->SetInfo());	// save other things
		CHECK_HR(hr = SaveAttributes(dwAttrFlags));		// save attributes
	}
	else
		hr = S_FALSE;
L_ERR:
	return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::SetInfo
//
//  Synopsis:   Set necessary information for Reopen
//
//-----------------------------------------------------------------------------
//??
STDMETHODIMP	CDSObject::SetInfo
(	
	CDSObject*	pContainer, 	// container, when NULL, objName is fullpath
   	LPCWSTR		clsName,		// class name
   	LPCWSTR		objName 		// object name, ignored when container == NULL
)
{
	HRESULT	hr = S_OK;
	
	if(m_bNoRefCountOnContainer)
		m_spContainer.p = pContainer;
	else
		m_spContainer = pContainer;

	try{
		SysFreeString(m_bstrClass);
		m_bstrClass = NULL;
		m_bstrClass = SysAllocString(clsName);
		CString	cnName = L"cn=";
		cnName += objName;
		SysFreeString(m_bstrName);
		m_bstrName = NULL;
		m_bstrName = SysAllocString(cnName);
	}catch(CMemoryException&){
		CHECK_HR(hr = E_OUTOFMEMORY);
	}
	
L_ERR:
	return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::Open
//
//  Synopsis:   Open an object in DS, create one when necessary
//
//-----------------------------------------------------------------------------
//??
STDMETHODIMP	CDSObject::Open
(	
	CDSObject*	pContainer, 	// container, when NULL, objName is fullpath
   	LPCWSTR		clsName,		// class name
   	LPCWSTR		objName, 		// object name, ignored when container == NULL
   	bool		bCreateIfNonExist,	// [in, out] if create
   	bool		bPersistWhenCreate
)
{
	HRESULT					hr = S_OK;
	CComPtr<IADs>			spIADs;
	CComPtr<IDispatch>		spIDisp;
	CComPtr<IADsContainer>	spIContainer;
	bool					bCallSave = false;
	DWORD					dwAttrFlags = 0;

	if(!pContainer)	// if container is not specified
	{
		CHECK_HR(hr = ADsOpenObject((LPWSTR)objName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_USE_SIGNING | ADS_USE_SEALING, IID_IADs, (void**)&spIADs));
		ASSERT((IADs*)spIADs);
  	}
	else	// open/create within container
	{
		// get container's ADSI
		CHECK_HR(hr = pContainer->GetIADs(&spIADs));
		ASSERT((IADs*)spIADs);

		CHECK_HR(spIADs->QueryInterface(IID_IADsContainer, (void**)&spIContainer));
		ASSERT((IADsContainer*)spIContainer);

		CString	cnName = objName;
		cnName.TrimLeft();

		// if cn= is already in the string
		if(cnName.GetLength() < 4 || cnName[2] != _T('=')
			|| (cnName[0] != _T('c') && cnName[0] != _T('C'))
			|| (cnName[1] != _T('n') && cnName[1] != _T('N')))
		{
			cnName = _T("cn=");
			cnName += objName;
		}


		// if it cannot open
		hr = spIContainer->GetObject((LPWSTR)clsName, (LPWSTR)(LPCWSTR)cnName, &spIDisp);

		spIADs.Release();
		if(S_OK == hr)
		{
			ASSERT((IDispatch*)spIDisp);
			spIDisp->QueryInterface(IID_IADs, (void**)&spIADs);
			ASSERT((IADs*)spIADs);
		}
		else	// the object cannot be open
		{
			if(!bCreateIfNonExist)	goto L_ERR;

			// create one if not exist
			CHECK_HR(spIContainer->Create((LPWSTR)clsName,(LPWSTR)(LPCWSTR)cnName, &spIDisp));
			ASSERT((IDispatch*)spIDisp);
			spIDisp->QueryInterface(IID_IADs, (void**)&spIADs);
			ASSERT((IADs*)spIADs);
			CHECK_HR(hr = OnCreate(&dwAttrFlags));	// callback function to do something for open

			// persist the object
			if(bPersistWhenCreate)
				bCallSave = true;

			m_bNewCreated = true;
		}

	}

	if(m_bNoRefCountOnContainer)
		m_spContainer.p = pContainer;
	else
		m_spContainer = pContainer;

	m_spIADs = (IADs*)spIADs;

	SysFreeString(m_bstrADsPath);
	m_bstrADsPath = NULL;
	CHECK_HR(hr = m_spIADs->get_ADsPath(&m_bstrADsPath));
	SysFreeString(m_bstrClass);
	m_bstrClass = NULL;
	CHECK_HR(hr = m_spIADs->get_Class(&m_bstrClass));
	SysFreeString(m_bstrName);
	m_bstrName = NULL;
	CHECK_HR(hr = m_spIADs->get_Name(&m_bstrName));

	// if new created and need to save
	if(bCallSave)
		CHECK_HR(hr = Save(dwAttrFlags));

	CHECK_HR(hr = OnOpen());	// callback function to do something for open

	CHECK_HR(hr = LoadAttributes());	// loadin attributes
	m_bOpened = true;
	
L_ERR:
	return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::Reopen
//
//  Synopsis:   Reopen an object in DS
//
//-----------------------------------------------------------------------------
STDMETHODIMP	CDSObject::Reopen()
{
	HRESULT					hr = S_OK;
	CComPtr<IDispatch>		spIDisp;
	CComPtr<IADs>			spIADs;
	CComPtr<IADsContainer>	spIContainer;

	// this must be pre opened, or created
	ASSERT((CDSObject*)m_spContainer);
	ASSERT(m_bstrName);		
	ASSERT(m_bstrClass);

	// close it, if the object was representing another DS object
	Close();

	// get container's ADSI
	CHECK_HR(hr = m_spContainer->GetIADs(&spIADs));
	ASSERT((IADs*)spIADs);

	CHECK_HR(spIADs->QueryInterface(IID_IADsContainer, (void**)&spIContainer));
	ASSERT((IADsContainer*)spIContainer);

	// if it cannot open
	CHECK_HR(hr = spIContainer->GetObject((LPWSTR)m_bstrClass, m_bstrName, &spIDisp));
	ASSERT((IDispatch*)spIDisp);

	if(!(IADs*)m_spIADs)
		spIDisp->QueryInterface(IID_IADs, (void**)&m_spIADs);
	ASSERT((IADs*)m_spIADs);

	CHECK_HR(hr = m_spIADs->get_ADsPath(&m_bstrADsPath));

	CHECK_HR(hr = OnOpen());	// callback function to do something for open

	CHECK_HR(hr = LoadAttributes());	// loadin attributes
	
	m_bOpened = true;
L_ERR:
	return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::Attach
//
//  Synopsis:   Open an object in DS, create one when necessary
//
//-----------------------------------------------------------------------------
STDMETHODIMP	CDSObject::Attach
(	
	CDSObject*	pContainer, 	// container, when NULL, objName is fullpath
   	IADs*		pIObject		// adsi interface for this object
)
{
	ASSERT(pIObject);		// no joke
	
	HRESULT		hr = S_OK;

	ASSERT(!m_bstrName);	// the object should never be opened before

	if(m_bNoRefCountOnContainer)
		m_spContainer.p = pContainer;
	else
		m_spContainer = pContainer;


	m_spIADs = pIObject;

	CHECK_HR(hr = OnOpen());	// callback function to do something for open
	CHECK_HR(hr = LoadAttributes());	// loadin attributes
	CHECK_HR(hr = m_spIADs->get_ADsPath(&m_bstrADsPath));
	CHECK_HR(hr = m_spIADs->get_Class(&m_bstrClass));
	CHECK_HR(hr = m_spIADs->get_Name(&m_bstrName));
	m_bOpened = true;
	
L_ERR:
	return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::Close
//
//  Synopsis:   Release pointers, free space
//
//-----------------------------------------------------------------------------
STDMETHODIMP	CDSObject::Close()
{
	m_spIADs.Release();
	SysFreeString(m_bstrADsPath);
	m_bstrADsPath = NULL;
	m_bOpened = false;

	return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::GetString
//
//  Synopsis:   GetIADs of the object, reference is increased by 1
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDSObject::GetString(CString& str, int nCol)
{
	USES_CONVERSION;

	switch(nCol)
	{
	case	0:	// name field

		str = GetName();
		return S_OK;
	default:
		str = _T(" ");
		return S_OK;
	}
}


//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::GetIADs
//
//  Synopsis:   GetIADs of the object, reference is increased by 1
//
//-----------------------------------------------------------------------------
STDMETHODIMP	CDSObject::GetIADs(IADs** ppIADs)
{
	HRESULT		hr = S_OK;
	bool		bNeedClose = false;
	
	if(!(IADs*)m_spIADs)
	{
		CHECK_HR(hr = Reopen());
		bNeedClose = true;
		ASSERT((IADs*)m_spIADs);
	}

	*ppIADs = (IADs*)m_spIADs;
		
	if(*ppIADs)
		(*ppIADs)->AddRef();
			
	if(bNeedClose)		
		CHECK_HR(hr = Close());

L_ERR:
	return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::SaveAttributes
//
//  Synopsis:   Save attributes to DS according to the flags
//
//-----------------------------------------------------------------------------
STDMETHODIMP	CDSObject::SaveAttributes(DWORD dwAttrFlags)
{
	CDSAttribute*	pAttr = GetAttributes();
	if(!pAttr)	return S_OK;	// when no attribute to save
	
	HRESULT			hr = S_OK;
	CDSAttributeInfo*	pInfo;
	CComPtr<IDirectoryObject>	spDirObj;
	ADS_ATTR_INFO	aADsAttrInfos[MAX_ATTRIBUTES];
	ADSVALUE		aADsValues[MAX_ATTRIBUTES];

	ZeroMemory(aADsAttrInfos, sizeof(aADsAttrInfos));
	ZeroMemory(aADsValues, sizeof(aADsValues));
	
	DWORD  count = 0;


	while(pAttr->pInfo)
	{
		ASSERT(count < MAX_ATTRIBUTES);			// make sure it's in the range
		if(dwAttrFlags & pAttr->pInfo->flag) 	// if the attribute should be saved
		{
			pInfo = pAttr->pInfo;

			// clear this attribute -- remove it
			if(GetFlags(ATTR_FLAG_SAVE, pInfo->flag) == 0)
			{
				// when need to delete
				if(GetFlags(ATTR_FLAG_LOAD, pInfo->flag) != 0)
				{
					SetFlags(ATTR_FLAG_LOAD, pInfo->flag, false);
					aADsAttrInfos[count].pszAttrName = pInfo->name;
					aADsAttrInfos[count].dwADsType = pInfo->type;
					aADsAttrInfos[count].dwNumValues = 0;
					aADsAttrInfos[count].dwControlCode = ADS_ATTR_CLEAR;
					aADsAttrInfos[count].pADsValues = NULL;

					count++;
				}
				// else doesn't exist in DS, need to do nothing
			}
			else	// need to save it
			{
				SetFlags(ATTR_FLAG_LOAD, pInfo->flag, true);

				aADsAttrInfos[count].pszAttrName = pInfo->name;
				aADsAttrInfos[count].dwADsType = pInfo->type;
				aADsAttrInfos[count].dwNumValues = 1;
				aADsAttrInfos[count].dwControlCode = ADS_ATTR_UPDATE;
				aADsAttrInfos[count].pADsValues = aADsValues + count;

				aADsValues[count].dwType = pInfo->type;
				switch(pInfo->type)
				{
				case	ADSTYPE_BOOLEAN:
					aADsValues[count].Boolean = *(ADS_BOOLEAN*)pAttr->pBuffer;
					break;
				case	ADSTYPE_INTEGER:
					aADsValues[count].Integer = *(ADS_INTEGER*)pAttr->pBuffer;
					break;
				case	ADSTYPE_LARGE_INTEGER:
					aADsValues[count].LargeInteger = *(ADS_LARGE_INTEGER*)pAttr->pBuffer;
					break;
				case	ADSTYPE_CASE_IGNORE_STRING:
				case	ADSTYPE_CASE_EXACT_STRING:
				case	ADSTYPE_PRINTABLE_STRING:
					if(pInfo->ifMultiValued)	// expect the buffer to be a StrArray pointer
					{
						// with current set of attributes, only one is possible
						CStrArray*	pArray = (CStrArray*)(pAttr->pBuffer);
						ASSERT(pArray);	// must be some mistake in code, types don't match
						ADSVALUE*	pValue;

						aADsAttrInfos[count].dwNumValues = pArray->GetSize();

						ASSERT(aADsAttrInfos[count].dwNumValues);
						
						if(aADsAttrInfos[count].dwNumValues > 1)
						{
							try{
							aADsAttrInfos[count].pADsValues = (ADSVALUE*)_alloca(sizeof(ADSVALUE) * aADsAttrInfos[count].dwNumValues);
							}
							catch(...)
							{
							CHECK_HR(hr = E_OUTOFMEMORY);
							}
						}

						pValue = aADsAttrInfos[count].pADsValues;

						// when need to support REAL multi-valued attribute, the way how aADsAttrInfos is allocated needs to change
						for(int i = 0; i < pArray->GetSize(); i++, pValue++)
						{
							pValue->CaseIgnoreString = T2W((LPTSTR)(LPCTSTR)*(pArray->GetAt(i)));
							pValue->dwType = pInfo->type;
						}
						
					}
					else	// NOT multivalued CString pointer
					{
						CString*	pStr = NULL;
						pStr = (CString*)(pAttr->pBuffer);
					
						ASSERT(pStr);
						if(pStr && pStr->GetLength())
							aADsValues[count].CaseIgnoreString = T2W((LPTSTR)(LPCTSTR)*pStr);
						else
							aADsValues[count].CaseIgnoreString = NULL;
					}
					break;
				default:
					// other types are not supported
					// need to make some changes when adding new types
					ASSERT(0);
					break;
				}

				count++;
			}
		}
		pAttr++;
	};

	if (!count) 	// there is no attribute to load
		return hr;

	// load the attributes
	ASSERT((IADs*)m_spIADs);
	CHECK_HR( hr = m_spIADs->QueryInterface(IID_IDirectoryObject, (void**)&spDirObj));
	ASSERT((IDirectoryObject*)spDirObj);

	CHECK_HR(hr = spDirObj->SetObjectAttributes(aADsAttrInfos, count, &count));

L_ERR:
	return hr;
}

HRESULT CDSObject::SetState(DWORD state)
{
	if(state == m_dwState)
		return S_OK;
	m_dwState = state;
	if(m_pHandle)
		return m_pHandle->ShowState(state);
	else
		return S_OK;
};
	
//+----------------------------------------------------------------------------
//
//  Method:     CDSObject::LoadAttributes
//
//  Synopsis:   Load attributes from DS and set flags to indicate the presence
//
//-----------------------------------------------------------------------------
STDMETHODIMP	CDSObject::LoadAttributes()
{
	CDSAttribute*	pAttr = GetAttributes();
	
	if(!pAttr)	return S_OK;	// when no attribute to read

	HRESULT	hr = S_OK;
	CDSAttributeInfo*	pInfo;
	CComPtr<IDirectoryObject>	spDirObj;
	LPWSTR	aAttriNames[MAX_ATTRIBUTES];
	ADS_ATTR_INFO*		pADsAttrInfo = NULL;

	DWORD count = 0;
	while(pAttr->pInfo)
	{
		pInfo = pAttr->pInfo;

		// clear the flag of this attribute
		SetFlags(ATTR_FLAG_LOAD, pInfo->flag, false);
		
		ASSERT(count < MAX_ATTRIBUTES);			// make sure it's in the range
		aAttriNames[count++] = pInfo->name;
		pAttr++;
	}

	if (!count) 	// there is no attribute to load
		return hr;

	// load the attributes
	ASSERT((IADs*)m_spIADs);
	CHECK_HR( hr = m_spIADs->QueryInterface(IID_IDirectoryObject, (void**)&spDirObj));
	ASSERT((IDirectoryObject*)spDirObj);

	CHECK_HR(hr = spDirObj->GetObjectAttributes(aAttriNames, count, &pADsAttrInfo, &count));
	
	while(count--)
	{
		pAttr = GetAttributes();
		ASSERT(pAttr);	// since we got it last time, we should get the same this time
		while(pAttr->pInfo)
		{
			pInfo = pAttr->pInfo;
			if(_wcsicmp(pADsAttrInfo[count].pszAttrName, pInfo->name) == 0)
				break;
			else
				pAttr++;
		};

		ASSERT(pAttr->pInfo);	// muse be found

		ASSERT(pInfo->type == pADsAttrInfo[count].dwADsType);	// type must match

		SetFlags(ATTR_FLAG_LOAD, pInfo->flag, true);

		switch(pInfo->type)
		{
		case	ADSTYPE_BOOLEAN:
			*(ADS_BOOLEAN*)pAttr->pBuffer = pADsAttrInfo[count].pADsValues[0].Boolean;
			break;
		case	ADSTYPE_INTEGER:
			*(ADS_INTEGER*)pAttr->pBuffer = pADsAttrInfo[count].pADsValues[0].Integer;
			break;
		case	ADSTYPE_LARGE_INTEGER:
			*(ADS_LARGE_INTEGER*)pAttr->pBuffer = pADsAttrInfo[count].pADsValues[0].LargeInteger;
			break;
		case	ADSTYPE_CASE_IGNORE_STRING:
		case	ADSTYPE_CASE_EXACT_STRING:
		case	ADSTYPE_PRINTABLE_STRING:
			if(!pInfo->ifMultiValued)	// CString is used
			{
				*(CString*)(pAttr->pBuffer) = pADsAttrInfo[count].pADsValues[0].CaseIgnoreString;
			}
			else	// for multi-valued, CStrArray is used
			{
				CString* pStr = NULL;
				CStrArray*	pArray = (CStrArray*)(pAttr->pBuffer);

				// clear the existing content of the array
				pArray->DeleteAll();

				for(int i = 0; i< pADsAttrInfo[count].dwNumValues; i++)
				{
					try{
					pStr = new CString(pADsAttrInfo[count].pADsValues[i].CaseIgnoreString);
					}
					catch(...)
					{
						CHECK_HR(hr = E_OUTOFMEMORY);
					}

					pArray->Add(pStr);

				}
			}

			break;
			
		default:
			// other types are not supported
			// need to make some changes when adding new types
			ASSERT(0);
			break;
		}
	}

L_ERR:
	FreeADsMem(pADsAttrInfo);

	// This is to deal with a bug related to GetAttribute function of ADS , which returns error when no attribute is found
	// code to be cleaned, once the bug is fixed, this should be removed
	if(hr == 0x80005210)	
		hr = S_OK;

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CACSGlobalObject
//
//
//+----------------------------------------------------------------------------
//
//  Method:     CACSGlobalObject::Open
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP	CACSGlobalObject::Open()
{
	HRESULT	hr = S_OK;
	
	CString	adsPath;
	int		i, j;

	// try to get the object to see if the object is already there
		// profile container pointer
	IADs*			pIADs = NULL;
	VARIANT			var;
	BSTR			bstrConfigPath = NULL;



	if(IfOpened())
		return S_OK;

	m_nOpenErrorId = 0;
	
	VariantInit(&var);

	// get ROOTDSE
	CHECK_HR(hr = ADsOpenObject(ACS_DSP_ROOTDSE, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_USE_SIGNING | ADS_USE_SEALING,IID_IADs, (void**)&pIADs));
	ASSERT(pIADs);

	// the name of the domain
	CHECK_HR(hr = pIADs->Get(ACS_DSA_DEFAULTCONTEXT, &var));
	m_strDomainName = V_BSTR(&var);
	i = m_strDomainName.Find(_T('='));
	if(i != -1) i++;
	j = m_strDomainName.Find(_T(','));

	m_strDomainName = m_strDomainName.Mid(i, j - i);

	VariantClear(&var);
	CHECK_HR(hr = pIADs->Get(ACS_DSA_CONFIGCONTEXT, &var));
	bstrConfigPath = V_BSTR(&var);

	pIADs->Release();
	pIADs = NULL;

	try{
		adsPath = LDAP_LEADING;
		adsPath += ACS_RPATH_ACS_INCONFIG;
		adsPath += bstrConfigPath;
	}catch(CMemoryException&){
		hr = E_OUTOFMEMORY;
	}
	CHECK_HR(hr);
	
	if FAILED(hr = CDSObject::Open(NULL, NULL, T2W((LPTSTR)(LPCTSTR)adsPath), false, false))
	// assume because of it doesn't exist
	{
		adsPath = LDAP_LEADING;
		adsPath += ACS_RPATH_ACS_PARENT_INCOFIG;
		adsPath += bstrConfigPath;

		CComObject<CDSObject>* pParentObj = NULL;
		CHECK_HR(hr = CComObject<CDSObject>::CreateInstance(&pParentObj));	// with 0 reference count

		// open it's parent -- this must be exist in DS
		CHECK_HR(hr = pParentObj->Open(NULL, NULL, T2W((LPTSTR)(LPCTSTR)adsPath), false, false));

		// create it within it's parent
		hr = CDSObject::Open(pParentObj, ACS_CLS_CONTAINER, ACS_NAME_ACS, true, true);

		if(FAILED(hr))
			m_nOpenErrorId = IDS_ERR_ROOTNODE;
	}
	
L_ERR:
	VariantClear(&var);

	return hr;
}


STDMETHODIMP	CACSGlobalObject::OnOpen()
{

	if (!IfNewCreated())
		return S_OK;

	HRESULT	hr = S_OK;

	// create default and unknown policies
	CComObject<CACSPolicyElement>*	pDSObj = NULL;
	CComPtr<CACSPolicyElement>		spObj;

	// create the object in DS
	CHECK_HR(hr = CComObject<CACSPolicyElement>::CreateInstance(&pDSObj));	// ref == 0
	spObj = pDSObj;		// ref == 1
	
	if((CACSPolicyElement*)spObj)
	{
		// set default attributes and set the flags to save it
		spObj->SetFlags(ATTR_FLAG_SAVE, spObj->SetGlobalDefault(), true);
	}
		
	CHECK_HR(hr = spObj->Open(this, ACS_CLS_POLICY, ACSPOLICY_DEFAULT, true, true));
	spObj->ClearFlags(ATTR_FLAG_SAVE);	// clear the saving flags

	CHECK_HR(hr = spObj->Close());

	// unknown_User -- make sure it exists
	spObj.Release();

	// create the object in DS
	CHECK_HR(hr = CComObject<CACSPolicyElement>::CreateInstance(&pDSObj));	// ref == 0
	spObj = pDSObj;		// ref == 1

	if((CACSPolicyElement*)spObj)
	{
		// set attribute and flag for global unknown
		spObj->SetFlags(ATTR_FLAG_SAVE, spObj->SetGlobalUnknown(), true);
	}
		
	CHECK_HR(hr = spObj->Open(this, ACS_CLS_POLICY, ACSPOLICY_UNKNOWN, true, true));
	spObj->ClearFlags(ATTR_FLAG_SAVE);	// clear the saving flags
	
	CHECK_HR(hr = spObj->Close());
	
L_ERR:
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CACSSubnetsObject
//
//
//+----------------------------------------------------------------------------
//
//  Method:     CACSSubnetsObject::Open
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP	CACSSubnetsObject::Open()
{
	HRESULT	hr = S_OK;
	
	CString	adsPath;
	int		i, j;

	// try to get the object to see if the object is already there
		// profile container pointer
	IADs*			pIADs = NULL;
	VARIANT			var;
	BSTR			bstrConfigPath = NULL;



	if(IfOpened())
		return S_OK;

	VariantInit(&var);

	// get ROOTDSE
	CHECK_HR(hr = ADsOpenObject(ACS_DSP_ROOTDSE, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_USE_SIGNING | ADS_USE_SEALING,	IID_IADs, (void**)&pIADs));
	ASSERT(pIADs);

	// configuration folder
	VariantClear(&var);
	CHECK_HR(hr = pIADs->Get(ACS_DSA_CONFIGCONTEXT, &var));
	bstrConfigPath = V_BSTR(&var);

	pIADs->Release();
	pIADs = NULL;

	try{
		adsPath = LDAP_LEADING;
		adsPath += ACS_RPATH_SUBNETS_INCONFIG;
		adsPath += bstrConfigPath;
	}catch(CMemoryException&){
		hr = E_OUTOFMEMORY;
	}
	CHECK_HR(hr);
	
	hr = CDSObject::Open(NULL, NULL, T2W((LPTSTR)(LPCTSTR)adsPath), false, false);
	
L_ERR:
	VariantClear(&var);

	return hr;
}

//============================================
// attribute info of policy element
CDSAttributeInfo CACSPolicyElement::m_aPolicyAttributeInfo[] = {
 {ACS_PAI_TIMEOFDAY			, ACS_PAN_TIMEOFDAY		   , ACS_PAT_TIMEOFDAY			, ACS_PAM_TIMEOFDAY			, ACS_PAF_TIMEOFDAY			},
 {ACS_PAI_DIRECTION			, ACS_PAN_DIRECTION		   , ACS_PAT_DIRECTION			, ACS_PAM_DIRECTION			, ACS_PAF_DIRECTION			},
 {ACS_PAI_PF_TOKENRATE		, ACS_PAN_PF_TOKENRATE	   , ACS_PAT_PF_TOKENRATE		, ACS_PAM_PF_TOKENRATE		, ACS_PAF_PF_TOKENRATE		},
 {ACS_PAI_PF_PEAKBANDWIDTH	, ACS_PAN_PF_PEAKBANDWIDTH , ACS_PAT_PF_PEAKBANDWIDTH	, ACS_PAM_PF_PEAKBANDWIDTH	, ACS_PAF_PF_PEAKBANDWIDTH 	},
 {ACS_PAI_PF_DURATION		, ACS_PAN_PF_DURATION	   , ACS_PAT_PF_DURATION		, ACS_PAM_PF_DURATION		, ACS_PAF_PF_DURATION 		},
 {ACS_PAI_SERVICETYPE		, ACS_PAN_SERVICETYPE	   , ACS_PAT_SERVICETYPE		, ACS_PAM_SERVICETYPE		, ACS_PAF_SERVICETYPE 		},
 {ACS_PAI_PRIORITY			, ACS_PAN_PRIORITY		   , ACS_PAT_PRIORITY			, ACS_PAM_PRIORITY			, ACS_PAF_PRIORITY 			},
 {ACS_PAI_PERMISSIONBITS		, ACS_PAN_PERMISSIONBITS   , ACS_PAT_PERMISSIONBITS		, ACS_PAM_PERMISSIONBITS	, ACS_PAF_PERMISSIONBITS 	},
 {ACS_PAI_TT_FLOWS			, ACS_PAN_TT_FLOWS		   , ACS_PAT_TT_FLOWS			, ACS_PAM_TT_FLOWS			, ACS_PAF_TT_FLOWS 			},
 {ACS_PAI_TT_TOKENRATE		, ACS_PAN_TT_TOKENRATE	   , ACS_PAT_TT_TOKENRATE		, ACS_PAM_TT_TOKENRATE		, ACS_PAF_TT_TOKENRATE 		},
 {ACS_PAI_TT_PEAKBANDWIDTH	, ACS_PAN_TT_PEAKBANDWIDTH , ACS_PAT_TT_PEAKBANDWIDTH	, ACS_PAM_TT_PEAKBANDWIDTH	, ACS_PAF_TT_PEAKBANDWIDTH 	},
 {ACS_PAI_IDENTITYNAME		, ACS_PAN_IDENTITYNAME	   , ACS_PAT_IDENTITYNAME		, ACS_PAM_IDENTITYNAME		, ACS_PAF_IDENTITYNAME 		},
{ACS_PAI_INVALID, NULL, ADSTYPE_INVALID, false, 0}
};

//============================================
// attribute info of subnet config object
CDSAttributeInfo CACSSubnetConfig::m_aSubnetAttributeInfo[] = {
{ACS_SCAI_ALLOCABLERSVPBW,			ACS_SCAN_ALLOCABLERSVPBW			,ACS_SCAT_ALLOCABLERSVPBW			,ACS_SCAM_ALLOCABLERSVPBW			,ACS_SCAF_ALLOCABLERSVPBW			},
{ACS_SCAI_MAXPEAKBW,				ACS_SCAN_MAXPEAKBW					,ACS_SCAT_MAXPEAKBW					,ACS_SCAM_MAXPEAKBW					,ACS_SCAF_MAXPEAKBW					},
{ACS_SCAI_ENABLERSVPMESSAGELOGGING,	ACS_SCAN_ENABLERSVPMESSAGELOGGING	,ACS_SCAT_ENABLERSVPMESSAGELOGGING	,ACS_SCAM_ENABLERSVPMESSAGELOGGING	,ACS_SCAF_ENABLERSVPMESSAGELOGGING	},
{ACS_SCAI_EVENTLOGLEVEL,			ACS_SCAN_EVENTLOGLEVEL				,ACS_SCAT_EVENTLOGLEVEL				,ACS_SCAM_EVENTLOGLEVEL				,ACS_SCAF_EVENTLOGLEVEL				},
{ACS_SCAI_ENABLEACSSERVICE,			ACS_SCAN_ENABLEACSSERVICE			,ACS_SCAT_ENABLEACSSERVICE			,ACS_SCAM_ENABLEACSSERVICE			,ACS_SCAF_ENABLEACSSERVICE			},
{ACS_SCAI_MAX_PF_TOKENRATE,			ACS_SCAN_MAX_PF_TOKENRATE			,ACS_SCAT_MAX_PF_TOKENRATE			,ACS_SCAM_MAX_PF_TOKENRATE			,ACS_SCAF_MAX_PF_TOKENRATE			},
{ACS_SCAI_MAX_PF_PEAKBW,			ACS_SCAN_MAX_PF_PEAKBW				,ACS_SCAT_MAX_PF_PEAKBW				,ACS_SCAM_MAX_PF_PEAKBW				,ACS_SCAF_MAX_PF_PEAKBW				},
{ACS_SCAI_MAX_PF_DURATION,			ACS_SCAN_MAX_PF_DURATION			,ACS_SCAT_MAX_PF_DURATION			,ACS_SCAM_MAX_PF_DURATION			,ACS_SCAF_MAX_PF_DURATION			},
{ACS_SCAI_RSVPLOGFILESLOCATION,		ACS_SCAN_RSVPLOGFILESLOCATION		,ACS_SCAT_RSVPLOGFILESLOCATION		,ACS_SCAM_RSVPLOGFILESLOCATION		,ACS_SCAF_RSVPLOGFILESLOCATION		},
{ACS_SCAI_DESCRIPTION,				ACS_SCAN_DESCRIPTION				,ACS_SCAT_DESCRIPTION				,ACS_SCAM_DESCRIPTION				,ACS_SCAF_DESCRIPTION				},
{ACS_SCAI_MAXNOOFLOGFILES,			ACS_SCAN_MAXNOOFLOGFILES			,ACS_SCAT_MAXNOOFLOGFILES			,ACS_SCAM_MAXNOOFLOGFILES			,ACS_SCAF_MAXNOOFLOGFILES			},
{ACS_SCAI_MAXSIZEOFRSVPLOGFILE,		ACS_SCAN_MAXSIZEOFRSVPLOGFILE		,ACS_SCAT_MAXSIZEOFRSVPLOGFILE		,ACS_SCAM_MAXSIZEOFRSVPLOGFILE		,ACS_SCAF_MAXSIZEOFRSVPLOGFILE		},
{ACS_SCAI_DSBMPRIORITY,				ACS_SCAN_DSBMPRIORITY				,ACS_SCAT_DSBMPRIORITY				,ACS_SCAM_DSBMPRIORITY				,ACS_SCAF_DSBMPRIORITY				},
{ACS_SCAI_DSBMREFRESH,				ACS_SCAN_DSBMREFRESH				,ACS_SCAT_DSBMREFRESH				,ACS_SCAM_DSBMREFRESH				,ACS_SCAF_DSBMREFRESH				},
{ACS_SCAI_DSBMDEADTIME,				ACS_SCAN_DSBMDEADTIME				,ACS_SCAT_DSBMDEADTIME				,ACS_SCAM_DSBMDEADTIME				,ACS_SCAF_DSBMDEADTIME				},
{ACS_SCAI_CACHETIMEOUT,				ACS_SCAN_CACHETIMEOUT				,ACS_SCAT_CACHETIMEOUT				,ACS_SCAM_CACHETIMEOUT				,ACS_SCAF_CACHETIMEOUT				},
{ACS_SCAI_NONRESERVEDTXLIMIT,		ACS_SCAN_NONRESERVEDTXLIMIT			,ACS_SCAT_NONRESERVEDTXLIMIT		,ACS_SCAM_NONRESERVEDTXLIMIT		,ACS_SCAF_NONRESERVEDTXLIMIT		},			

// accounting
{ACS_SCAI_ENABLERSVPMESSAGEACCOUNTING,	ACS_SCAN_ENABLERSVPMESSAGEACCOUNTING	,ACS_SCAT_ENABLERSVPMESSAGELOGGING	,ACS_SCAM_ENABLERSVPMESSAGEACCOUNTING	,ACS_SCAF_ENABLERSVPMESSAGEACCOUNTING	},
{ACS_SCAI_RSVPACCOUNTINGFILESLOCATION,	ACS_SCAN_RSVPACCOUNTINGFILESLOCATION	,ACS_SCAT_RSVPLOGFILESLOCATION		,ACS_SCAM_RSVPACCOUNTINGFILESLOCATION		,ACS_SCAF_RSVPACCOUNTINGFILESLOCATION		},
{ACS_SCAI_MAXNOOFACCOUNTINGFILES,		ACS_SCAN_MAXNOOFACCOUNTINGFILES			,ACS_SCAT_MAXNOOFLOGFILES			,ACS_SCAM_MAXNOOFACCOUNTINGFILES			,ACS_SCAF_MAXNOOFACCOUNTINGFILES			},
{ACS_SCAI_MAXSIZEOFRSVPACCOUNTINGFILE,	ACS_SCAN_MAXSIZEOFRSVPACCOUNTINGFILE	,ACS_SCAT_MAXSIZEOFRSVPLOGFILE		,ACS_SCAM_MAXSIZEOFRSVPACCOUNTINGFILE		,ACS_SCAF_MAXSIZEOFRSVPACCOUNTINGFILE		},

// server list
{ACS_SCAI_SERVERLIST,				ACS_SCAN_SERVERLIST					,ACS_SCAT_SERVERLIST				,ACS_SCAM_SERVERLIST				,ACS_SCAF_SERVERLIST		},

{ACS_PAI_INVALID, NULL, ADSTYPE_INVALID, false, 0}
};

//============================================
// attribute info of subnet service limit object
CDSAttributeInfo CACSSubnetServiceLimits::m_aSubnetServiceLimitsAttributeInfo[] = {
{ACS_SSLAI_ALLOCABLERSVPBW,	ACS_SSLAN_ALLOCABLERSVPBW	,ACS_SSLAT_ALLOCABLERSVPBW	,ACS_SSLAM_ALLOCABLERSVPBW	,ACS_SSLAF_ALLOCABLERSVPBW			},
{ACS_SSLAI_MAXPEAKBW,		ACS_SSLAN_MAXPEAKBW			,ACS_SSLAT_MAXPEAKBW		,ACS_SSLAM_MAXPEAKBW		,ACS_SSLAF_MAXPEAKBW					},
{ACS_SSLAI_MAX_PF_TOKENRATE,ACS_SSLAN_MAX_PF_TOKENRATE	,ACS_SSLAT_MAX_PF_TOKENRATE	,ACS_SSLAM_MAX_PF_TOKENRATE	,ACS_SSLAF_MAX_PF_TOKENRATE			},
{ACS_SSLAI_MAX_PF_PEAKBW,	ACS_SSLAN_MAX_PF_PEAKBW		,ACS_SSLAT_MAX_PF_PEAKBW	,ACS_SSLAM_MAX_PF_PEAKBW	,ACS_SSLAF_MAX_PF_PEAKBW				},
{ACS_SSLAI_SERVICETYPE,		ACS_SSLAN_SERVICETYPE	 	,ACS_SSLAT_SERVICETYPE		,ACS_SSLAM_SERVICETYPE		,ACS_SSLAF_SERVICETYPE 		},


{ACS_PAI_INVALID, NULL, ADSTYPE_INVALID, false, 0}
};

bool CACSPolicyElement::IsConflictInContainer()
{
	CACSPolicyContainer*	pCont = dynamic_cast<CACSPolicyContainer*>((CDSObject*)m_spContainer);

	return pCont->IsConflictWithExisting(this);
}

void CACSPolicyElement::InvalidateConflictState()
{
	CACSPolicyContainer*	pCont = dynamic_cast<CACSPolicyContainer*>((CDSObject*)m_spContainer);

	pCont->SetChildrenConflictState();

}

STDMETHODIMP CACSPolicyElement::GetString(CString& str, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	USES_CONVERSION;
	Reopen();
	str.Empty();

	switch(nCol)
	{
	case	0:	// name field
		if(m_bUseName_NewPolicy)
		{
			str.LoadString(IDS_NEWACSPOLICY);
		}
		else if(m_strArrayIdentityName.GetSize())
		{
			int offset;

			int id = GetIdentityType(&offset);
			switch(id){
			case	0:
				if(m_strDefaultUser.IsEmpty())
					str.LoadString(IDS_ANYAUTHENTICATEDUSER);
				break;
			case	1:
				if(m_strUnknownUser.IsEmpty())
					str.LoadString(IDS_NONAUTHENTICATEDUSER);
				break;
			default:
				str = m_strArrayIdentityName[(INT_PTR)0]->Mid(offset);
				break;
			}
		}
		break;

	case	1:	// direction
		if(GetFlags(ATTR_FLAG_LOAD, ACS_PAF_DIRECTION))
		{
			switch(m_dwDirection)
			{
			case	ACS_DIRECTION_SEND:
				if(m_strDirectionSend.IsEmpty())
					m_strDirectionSend.LoadString(IDS_SEND);
				str = m_strDirectionSend;
				break;
			case	ACS_DIRECTION_RECEIVE:
				if(m_strDirectionReceive.IsEmpty())
					m_strDirectionReceive.LoadString(IDS_RECEIVE);
				str = m_strDirectionReceive;
				break;
			case	ACS_DIRECTION_BOTH:
				if(m_strDirectionBoth.IsEmpty())
					m_strDirectionBoth.LoadString(IDS_SENDRECEIVE);
				str = m_strDirectionBoth;
				break;
				
			default:
				ASSERT(0);
			}
		}
		break;

	case	2:	// Service Level
		if(GetFlags(ATTR_FLAG_LOAD, ACS_PAF_SERVICETYPE))
		{
			switch(m_dwServiceType)
			{
			case	ACS_SERVICETYPE_BESTEFFORT:
				if(m_strServiceTypeBestEffort.IsEmpty())
				m_strServiceTypeBestEffort.LoadString(IDS_BESTEFFORT);
				str = m_strServiceTypeBestEffort;
				break;
			case	ACS_SERVICETYPE_CONTROLLEDLOAD:
				if(m_strServiceTypeControlledLoad.IsEmpty())
				m_strServiceTypeControlledLoad.LoadString(IDS_CONTROLLEDLOAD);
				str = m_strServiceTypeControlledLoad;
				break;
			case	ACS_SERVICETYPE_GUARANTEEDSERVICE:
				if(m_strServiceTypeGuaranteedService.IsEmpty())
				m_strServiceTypeGuaranteedService.LoadString(IDS_GUARANTEEDSERVICE);
				str = m_strServiceTypeGuaranteedService;
				break;
			case	ACS_SERVICETYPE_ALL:
				if(m_strServiceTypeAll.IsEmpty())
					m_strServiceTypeAll.LoadString(IDS_ALL);
				str = m_strServiceTypeAll;
				break;
				
			case	ACS_SERVICETYPE_DISABLED:
				if(m_strServiceTypeDisabled.IsEmpty())
					m_strServiceTypeDisabled.LoadString(IDS_SERVICETYPE_DISABLED);
				str = m_strServiceTypeDisabled;
				break;
			
			default:
				// invalid value
				ASSERT(0);
				// message box
			}
		}
		break;

	case	3:	// date rate
		if(GetFlags(ATTR_FLAG_LOAD, ACS_PAF_PF_TOKENRATE))
		{
			if (IS_LARGE_UNLIMIT(m_ddPFTokenRate))
			{
				str.LoadString(IDS_RESOURCELIMITED);
			}
			else
			{
				str.Format(_T("%d"), TOKBS(m_ddPFTokenRate.LowPart));
			}
		}

		break;
	case	4:	// peak rate
		if(GetFlags(ATTR_FLAG_LOAD, ACS_PAF_PF_PEAKBANDWIDTH))
		{
			if (IS_LARGE_UNLIMIT(m_ddPFPeakBandWidth))
			{
				str.LoadString(IDS_RESOURCELIMITED);
			}
			else
			{
				str.Format(_T("%d"), TOKBS(m_ddPFPeakBandWidth.LowPart));
			}
		}
		break;
		
	default:
		break;
	}

	if(str.IsEmpty())
		str = _T("-");

	return S_OK;
}

// string for direction
CString		CACSPolicyElement::m_strDirectionSend;
CString		CACSPolicyElement::m_strDirectionReceive;
CString		CACSPolicyElement::m_strDirectionBoth;

// string for service type
CString		CACSPolicyElement::m_strServiceTypeAll;
CString		CACSPolicyElement::m_strServiceTypeBestEffort;
CString		CACSPolicyElement::m_strServiceTypeControlledLoad;
CString		CACSPolicyElement::m_strServiceTypeGuaranteedService;
CString		CACSPolicyElement::m_strServiceTypeDisabled;

// identity display name
CString		CACSPolicyElement::m_strDefaultUser;
CString		CACSPolicyElement::m_strUnknownUser;


HRESULT CACSSubnetObject::GetString(CString& str, int nCol)
{
	USES_CONVERSION;

	switch(nCol)
	{
	case	0:	// name field
		ASSERT((CDSObject*)m_spContainer);
		str = m_spContainer->GetName();
		break;
		
	default:
		if(!m_spConfigObject.p)		// the ACS object is not created
		{
			Reopen();
			if(!m_spConfigObject.p)
			{
				str = _T("-");
				return S_OK;
			}
		}

		return m_spConfigObject->GetString(str, nCol);
		break;
	}
	return S_OK;
}

HRESULT CACSSubnetConfig::GetString(CString& str, int nCol)
{
	USES_CONVERSION;

	if(!m_bOpened)	Reopen();
	str.Empty();

	switch(nCol)
	{
	case	0:
		ASSERT(0);	// should not come here, it should be covered by its
	case	1:	// name field
		str = m_strDESCRIPTION;
		break;
	case	2:	// date rate
		if(GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_MAX_PF_TOKENRATE))
			str.Format(_T("%d"), TOKBS(m_ddMAX_PF_TOKENRATE.LowPart));

		break;
	case	3:	// peak rate
		if(GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_MAX_PF_PEAKBW))
			str.Format(_T("%d"), TOKBS(m_ddMAX_PF_PEAKBW.LowPart));
		break;

	default:
		ASSERT(0);
	}

	if(str.IsEmpty())
		str = _T("-");
		
	return S_OK;
}

/////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acshand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ACSHand.h
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
    	11/05/97	Wei Jiang			Created

	
*/

#ifndef _ACSHAND_H
#define _ACSHAND_H

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#include "acscomp.h"
#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

#include <list>
#include "helper.h"
#include "resource.h"

#define GETHANDLER(classname, node) (reinterpret_cast<classname *>(node->GetData(TFS_DATA_USER)))

extern UINT g_col_strid_name[];
extern int  g_col_width_name[];

extern UINT g_col_strid_name_type[];
extern int  g_col_width_name_type[];

extern UINT g_col_strid_name_type_desc[];
extern int  g_col_width_name_type_desc[];

extern UINT g_col_strid_policy[];
extern int  g_col_width_policy[];
extern const UINT g_col_count_policy;

extern UINT g_col_strid_subnet[];
extern int  g_col_width_subnet[];
extern const UINT g_col_count_subnet;


// type of ACS nodes
enum NodeTypes {
	ND_ACSROOT = 1,
	ND_GLOBALCONFIG,
	ND_SUBNETCONFIGS,
	ND_USERS,
	ND_PROFILES,
	ND_SUBNET,
	ND_SUBNET_CONFIG,
	ND_POLICY
};

class CACSDataObject;

// defined ACS index for the MMC verbs
enum ACS_MMC_VERBS {
	ACS_MMC_VERB_OPEN = 0,
	ACS_MMC_VERB_COPY,
	ACS_MMC_VERB_PASTE,
	ACS_MMC_VERB_DELETE,
	ACS_MMC_VERB_PROPERTIES,
	ACS_MMC_VERB_RENAME,
	ACS_MMC_VERB_REFRESH,
	ACS_MMC_VERB_PRINT,
	ACS_TOTAL_MMC_VERBS
};

// keep a public map of MMC verbs -- value defined in ACSHand.cpp
extern const MMC_CONSOLE_VERB  g_mmc_verbs[ACS_TOTAL_MMC_VERBS];

//============================================================================
//	Class:  CACSGenericHandle
//
//		Generic handler class for ACS handlers
//		
//		Author:		WeiJiang
//
struct CACSUIInfo
{
	const UINT*	m_aStaticStrIds;	// if names are static, the stringIDs appear hear
	UINT		m_nTotalStrs;		// for the UI's own's result pane

	UINT*		m_aColumnIds;		// IDS used for columns in result pane
	int*		m_aColumnWidths;	// column widths in result pane

	bool		m_bPropertyPage;	// if this node has property pages

	bool		m_bContainer;		// if this is an container

	const UINT*	m_aNewMenuTextIds;	// array of menu items for New
	const UINT*	m_aNewMenuIds;		// optional menu Ids for items for New

	const UINT*	m_aTaskMenuTextIds;	// array of menu items for Task
	const UINT*	m_aTaskMenuIds;		// optional menu Ids for items for Task

	MMC_BUTTON_STATE* 	m_pVerbStates;		// VERB STATE

	const GUID*		m_pGUID;
};

#define	BRANCH_FLAG_GLOBAL	0x00000001

extern CACSUIInfo	g_RootUIInfo;
extern CACSUIInfo	g_GlobalUIInfo;
extern CACSUIInfo	g_SubnetworksUIInfo;
extern CACSUIInfo	g_ProfilesUIInfo;
extern CACSUIInfo	g_UsersUIInfo;
extern CACSUIInfo	g_PolicyUIInfo;
extern CACSUIInfo	g_SubnetUIInfo;

class CDSObject;
//============================================================================
//	Class:  CACSGenericHandle
//
//		Generic handler class for ACS handlers
//		
//		Author:		WeiJiang
//
class CACSHandle : public CHandler
{
public:

	CACSHandle(ITFSComponentData *pCompData, CDSObject* pDSObject, CACSUIInfo* pUIInfo);

	virtual ~CACSHandle();

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();

	// Node Id 2 support
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();


	OVERRIDE_BaseHandlerNotify_OnDelete();	// handles delete menu item
	OVERRIDE_BaseHandlerNotify_OnRename();

	OVERRIDE_BaseHandlerNotify_OnExpand();
	
	OVERRIDE_ResultHandler_GetString();
	OVERRIDE_ResultHandler_HasPropertyPages();

	OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultRename();

	OVERRIDE_ResultHandler_CompareItems();
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();

    // base handler virtual function over-rides
    virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
	
	HRESULT	UpdateStrings();	// should call the data object to get the latest dynamic strings
	virtual HRESULT ShowState(DWORD state) {m_dwShownState = state; return S_OK;};
	DWORD	GetShownState() { return m_dwShownState;};
	
	// when data is changed on property page
	static HRESULT NotifyDataChange(LPARAM param);
	
	// Initialize function is called after handle is created
	virtual HRESULT InitializeNode(ITFSNode * pNode);

	virtual HRESULT ListChildren(std::list<CACSHandle*>& children){ return S_FALSE;};
	virtual HRESULT GetNamesForCommandNew(int nCommandId, CStrArray& Names) SAYOK;

	bool			IfContainer() { return m_pUIInfo->m_bContainer;};

	HRESULT			AddChild(ITFSNode*	pNode, CACSHandle* pHandle, ITFSNode** ppNewNode);

	virtual	HRESULT	EditProperties() SAYOK;

	virtual HRESULT	Delete(ITFSNode *pNode, ITFSComponent* pComponent, BOOL bCheckPropertyPage);
	// bring up the property page if it's open
	HRESULT	BringUpPropertyPageIfOpen(ITFSNode *pNode, ITFSComponent* pComponent);

    //
    // override to clean up our per-node data structures
    //
	OVERRIDE_NodeHandler_DestroyHandler();
	OVERRIDE_ResultHandler_DestroyResultHandler();

    HRESULT	IsOkToDelete()
	{
		if(m_nBranchFlag & BRANCH_FLAG_GLOBAL)
		{
			// unknown and default can not be deleted
			if(wcsstr(m_pDSObject->GetName(), ACS_NAME_DEFAULTUSER))
				return S_FALSE;

			if(wcsstr(m_pDSObject->GetName(), ACS_NAME_UNKNOWNUSER))
				return S_FALSE;
		}

		return S_OK;
	};

	void	SetBranch(UINT flag) { m_nBranchFlag = flag;};
	UINT			m_nBranchFlag;	// glocal defined as 0x0001

public:
	// ICON INDEX
	ULONG			m_ulIconIndex;
	ULONG			m_ulIconIndexOpen;
protected:	
	// UI Information such as Column info, if property page, context menu, if container
	CACSUIInfo*		m_pUIInfo;

	// Handlers get strings, expand node, data object query, and menu..
	CDSObject*		m_pDSObject;
	CStrArray		m_aStaticStrings;	// string used for get name
	CStrArray		m_aDynStrings;	// string used for get name
	UINT			m_nFirstDynCol;

	DWORD			m_dwShownState;

	ITFSNode*		m_pNode;	// ref counted, releasd in Destroy
	BOOL			m_bACSHandleExpanded;
	BOOL			m_bCheckPropertyPageOpen;
};


#ifndef _TASK_H
#include <task.h>
#endif

#define COMPUTERNAME_LEN_MAX			255

typedef enum _ROOT_TASKS
{
    ROOT_TASK_LAUNCH_ACS,
    ROOT_TASK_MAX
} ROOT_TASKS;

class CRootTasks : public CTaskList
{
public:
    HRESULT Init(BOOL bExtension, BOOL bThisMachine, BOOL bNetServices);

private:
    CStringArray    m_arrayMouseOverBitmaps;
    CStringArray    m_arrayMouseOffBitmaps;
    CStringArray    m_arrayTaskText;
    CStringArray    m_arrayTaskHelp; 
};

//============================================================================
//
//	Class:  CACSRootHandle
//
//		Handler class for ACS Root Node
//		
//		Author:		WeiJiang
//
class CACSRootHandle : public CACSHandle
{
public:

	CACSRootHandle(ITFSComponentData *pCompData, CDSObject* pDSObject)
	: CACSHandle(pCompData, pDSObject, &g_RootUIInfo)
	{
		m_ulIconIndex = IMAGE_IDX_CLOSEDFOLDER;
		m_ulIconIndexOpen = IMAGE_IDX_OPENFOLDER;
	};

	// for task pad to extend network console
    OVERRIDE_ResultHandler_TaskPadNotify();
    OVERRIDE_ResultHandler_EnumTasks();

	virtual HRESULT ListChildren(std::list<CACSHandle*>& children);

protected:
};


//============================================================================
//
//	Class:  CACSPolicyContainerHandle
//
//		Handler class for ACS Policy Containers like Users and Profiles Node
//		
//		Author:		WeiJiang
//

class CACSPolicyContainerHandle :
   public CACSHandle
{
public:
	CACSPolicyContainerHandle(ITFSComponentData *pCompData, CDSObject* pDSObject, CACSUIInfo* pUIInfo)
	: CACSHandle(pCompData, pDSObject, pUIInfo){};

	OVERRIDE_NodeHandler_OnCommand();

	OVERRIDE_BaseHandlerNotify_OnExpand();
	
	virtual HRESULT ListChildren(std::list<CACSHandle*>& children);

	virtual HRESULT GetNamesForCommandNew(int nCommandId, CStrArray& Names);
	
protected:
};

//============================================================================
//
//	Class:  CACSGlobalHandle
//
//		Handler class for ACS Global Configuration Node
//		
//		Author:		WeiJiang
//

class CACSGlobalHandle :
   public CACSPolicyContainerHandle
{
public:
	CACSGlobalHandle(ITFSComponentData *pCompData, CDSObject* pDSObject)
	: CACSPolicyContainerHandle(pCompData, pDSObject, &g_GlobalUIInfo)
	{
		SetBranch(BRANCH_FLAG_GLOBAL);
		m_ulIconIndex = IMAGE_IDX_CLOSEDFOLDER;
		m_ulIconIndexOpen = IMAGE_IDX_OPENFOLDER;
	};

protected:
};

//============================================================================
//
//	Class:  CACSSubnetContainerHandle
//
//		Handler class for ACS Subnetwork Configurations Node
//		
//		Author:		WeiJiang
//

class CACSSubnetContainerHandle :
   public CACSHandle
{
public:
	CACSSubnetContainerHandle(ITFSComponentData *pCompData, CDSObject* pDSObject)
	: CACSHandle(pCompData, pDSObject, &g_SubnetworksUIInfo)
	{
		m_ulIconIndex = IMAGE_IDX_CLOSEDFOLDER;
		m_ulIconIndexOpen = IMAGE_IDX_OPENFOLDER;
	};
	
	OVERRIDE_NodeHandler_OnCommand();

	virtual HRESULT ListChildren(std::list<CACSHandle*>& children);
	virtual HRESULT GetNamesForCommandNew(int nCommandId, CStrArray& Names);


protected:
};

//============================================================================
//
//	Class:  CACSSubnetHandle
//
//		Handler class for ACS Subnetwork
//		
//		Author:		WeiJiang
//

class CACSSubnetHandle :
   public CACSPolicyContainerHandle
{
public:
	CACSSubnetHandle(ITFSComponentData *pCompData, CDSObject* pDSObject)
	: CACSPolicyContainerHandle(pCompData, pDSObject, &g_SubnetUIInfo)
	{
		if ((pDSObject->GetState() & ACSDATA_STATE_NOOBJECT) != 0)
		{
			m_ulIconIndexOpen = m_ulIconIndex = IMAGE_IDX_SUBNETWORK_NO_ACSPOLICY;
		}
		else
		{
			m_ulIconIndexOpen = m_ulIconIndex = IMAGE_IDX_SUBNETWORK;
		}
	};

	OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	
	// show if the data is conflict
	virtual HRESULT ShowState(DWORD state);
	

protected:
};


//============================================================================
//
//	Class:  CACSPolicyHandle
//
//		Handler class for ACS Policy Node
//		
//		Author:		WeiJiang
//

class CACSPolicyHandle :
   public CACSHandle
{
public:
	CACSPolicyHandle(ITFSComponentData *pCompData, CDSObject* pDSObject)
	: CACSHandle(pCompData, pDSObject, &g_PolicyUIInfo)
	{
		m_ulIconIndex = IMAGE_IDX_POLICY;
		m_ulIconIndexOpen = IMAGE_IDX_POLICY;
		m_bDeleteUponCancel = FALSE;
	};


    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();
	OVERRIDE_BaseResultHandlerNotify_OnResultDelete();

	void	SetDeleteOnCancelPropertyPage(ITFSNode* pNode)
	{
		m_bDeleteUponCancel = TRUE;
	};
		
	void	OnPropertyPageApply()
	{
		m_bDeleteUponCancel = FALSE;
		CACSPolicyElement* pObj = dynamic_cast<CACSPolicyElement*>(m_pDSObject);

		ASSERT(pObj);

	};
	void	OnPropertyPageOK()
	{
		m_bDeleteUponCancel = FALSE;
	};
	void	OnPropertyPageCancel()
	{
		if(m_bDeleteUponCancel)
		{
			ASSERT(m_pNode);
			m_bCheckPropertyPageOpen = FALSE;
			Delete(m_pNode, NULL, FALSE);
		}
	};

	// show if the data is conflict
	virtual HRESULT ShowState(DWORD state);
	
protected:
	bool					m_bDeleteUponCancel;	// set to true when new create policy
};

#endif 		// _ACSHAND_H

//////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acssnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	AcsSnap.cpp
		Implements ACS admin snapin

    FILE HISTORY:
		11/03/97	Wei Jiang	Created
        
*/
// ACSSnap.cpp : Implementation of CACSSnap
#include "stdafx.h"
#include "acsadmin.h"
#include "ACSSnap.h"

/////////////////////////////////////////////////////////////////////////////
// CACSSnap
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acssnapa.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	AcsSnapA.cpp
		Implements ACS admin snapin's About object

    FILE HISTORY:
		11/03/97	Wei Jiang	Created
        
*/
// ACSSnapA.cpp : Implementation of CACSSnapAbout
#include "stdafx.h"
#include "acsadmin.h"
#include "ACSSnapA.h"

/////////////////////////////////////////////////////////////////////////////
// CACSSnapAbout
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acssnape.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	AcsSnapE.cpp
		Implements ACS admin snapin's Extension Snapin

    FILE HISTORY:
		11/03/97	Wei Jiang	Created
        
*/

// ACSSnapE.cpp : Implementation of CACSSnapExt
#include "stdafx.h"
#include "acsadmin.h"
#include "ACSSnapE.h"

/////////////////////////////////////////////////////////////////////////////
// CACSSnapExt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acssnapa.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AcsSnapA.h
		Defines the ACS Admin Snapin's About object

    FILE HISTORY:
		11/03/97	Wei Jiang	Created
        
*/
// ACSSnapA.h : Declaration of the CACSSnapAbout

#ifndef __ACSSNAPABOUT_H_
#define __ACSSNAPABOUT_H_

#include "resource.h"       // main symbols
#include "acscomp.h"

#define COLORREF_PINK        0x00FF00FF
/////////////////////////////////////////////////////////////////////////////
// CACSSnapAbout
class ATL_NO_VTABLE CACSSnapAbout : 
	public CAbout,
	public CComCoClass<CACSSnapAbout, &CLSID_ACSSnapAbout>
{
public:

	CACSSnapAbout()
	{

	};

	virtual ~CACSSnapAbout() {
	};

DECLARE_REGISTRY(CACSSnapAbout, 
				 _T("ACSSnapin.About.1"), 
				 _T("ACSSnapin.About"), 
				 IDS_SNAPIN_DESC, 
				 THREADFLAGS_BOTH)
	
BEGIN_COM_MAP(CACSSnapAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

// IACSSnapAbout
public:

DECLARE_NOT_AGGREGATABLE(CACSSnapAbout)

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_PROVIDER; }
	virtual UINT GetAboutVersionId()	 { return IDS_ABOUT_VERSION; }
	virtual UINT GetAboutIconId()		 { return IDI_ACS_SNAPIN; }

	virtual UINT GetSmallRootId()		 { return IDB_SMALLACS; }
	virtual UINT GetSmallOpenRootId()	 { return IDB_SMALLACSOPEN; }
	virtual UINT GetLargeRootId()		 { return IDB_LARGEACS; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) COLORREF_PINK; } 

};

#endif //__ACSSNAPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acssnap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	AcsSnap.h
		Defines the ACS Admin Snapin

    FILE HISTORY:
		11/03/97	Wei Jiang	Created
        
*/
// ACSSnap.h : Declaration of the CACSSnap

#ifndef __ACSSNAP_H_
#define __ACSSNAP_H_

#include "resource.h"       // main symbols
#include "acscomp.h"

/////////////////////////////////////////////////////////////////////////////
// CACSSnap
class ATL_NO_VTABLE CACSSnap : 
	public CACSComponentData,
	public CComCoClass<CACSSnap, &CLSID_ACSSnap>
{
public:
	CACSSnap()
	{
	}

public:
	DECLARE_REGISTRY(CACSSnap, 
					 _T("ACSSnapin.ACSSnapin.1"), 
					 _T("ACSSnapin.ACSSnapin"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

	STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_ACSSnap; }
// IACSSnap
public:
};

#endif //__ACSSNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acssnape.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	AcsSnapE.h
		Defines the ACS Admin Snapin's extension snapin

    FILE HISTORY:
		11/03/97	Wei Jiang	Created
        
*/
// ACSSnapE.h : Declaration of the CACSSnapExt

#ifndef __ACSSNAPEXT_H_
#define __ACSSNAPEXT_H_

#include "resource.h"       // main symbols
#include "acscomp.h"

/////////////////////////////////////////////////////////////////////////////
// CACSSnapExt
class ATL_NO_VTABLE CACSSnapExt : 
	public CACSComponentData,
	public CComCoClass<CACSSnapExt, &CLSID_ACSSnapExt>
{
public:
	CACSSnapExt()
	{
	}

	DECLARE_REGISTRY(CACSSnapExt, 
					 _T("ACSSnapinExtension.ACSSnapinExtension.1"), 
					 _T("ACSSnapinExtension.ACSSnapinExtension"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHOD_(const CLSID *, GetCoClassID)(){ return &CLSID_ACSSnapExt; }
};

#endif //__ACSSNAPEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\gtusrdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corporation, 1992 - 1997 -1997           **/
/**********************************************************************/

/*
    GetUser.h

    This file contains the definitions for the User Browser "C" API

    FILE HISTORY:
        AndyHe  11-Oct-1992     Created

*/

#ifndef _GETUSER_H_
#define _GETUSER_H_

//#include <ntseapi.h>

typedef HANDLE    HUSERBROW;        // handle type returned by OpenUserBrowser

//
//   Parameter structure passed to OpenUserBrowser
//
typedef struct tagUSLT {    // uslt
    ULONG             ulStructSize;
    BOOL              fUserCancelled;   // Set if user cancelled
    BOOL              fExpandNames;     // TRUE if full names should be returned
    HWND              hwndOwner;        // Window handle to use for dialog
    WCHAR           * pszTitle;         // Dialog title (or NULL)
    WCHAR           * pszInitialDomain; // NULL for local machine or prefix
                                        // with "\\" for server
    DWORD             Flags;            // Defined below
    ULONG             ulHelpContext;    // Help context for the main dialog
    WCHAR           * pszHelpFileName;  // Help file name
}  USERBROWSER, *LPUSERBROWSER, * PUSERBROWSER;

//
// Bit values for Flags field
//

//
//  Indicates the user accounts should be shown as if the user pressed
//  the "Show Users" button.  The button will be hidden if this flag is
//  set.  The USRBROWS_SHOW_USERS flag must also be set.

#define USRBROWS_EXPAND_USERS       (0x00000008)

//
//  Passing this will prevent the computer name from showing up in the
//  combo box.
//

#define USRBROWS_DONT_SHOW_COMPUTER (0x00000100)

//
//  Allow the user to only select a single item from the listbox (not all
//  SHOW_* combinations are supported with this option).
//

#define USRBROWS_SINGLE_SELECT	    (0x00001000)

//
//  These manifests determine which well known Sids are included in the list.
//
#define USRBROWS_INCL_REMOTE_USERS  (0x00000010)
#define USRBROWS_INCL_INTERACTIVE   (0x00000020)
#define USRBROWS_INCL_EVERYONE      (0x00000040)
#define USRBROWS_INCL_CREATOR       (0x00000080)
#define USRBROWS_INCL_SYSTEM        (0x00010000)
#define USRBROWS_INCL_ALL           (USRBROWS_INCL_REMOTE_USERS |\
                                     USRBROWS_INCL_INTERACTIVE  |\
                                     USRBROWS_INCL_EVERYONE     |\
                                     USRBROWS_INCL_CREATOR      |\
                                     USRBROWS_INCL_SYSTEM)

//
//  These manifests determine which type of accounts to display
//
//  Note: currently, if you display groups, you must display users
//		     if you display aliases (local groups), you must display
//			   groups and users
//
#define USRBROWS_SHOW_ALIASES	    (0x00000001)
#define USRBROWS_SHOW_GROUPS	    (0x00000002)
#define USRBROWS_SHOW_USERS	    (0x00000004)
#define USRBROWS_SHOW_ALL	    (USRBROWS_SHOW_ALIASES |\
				     USRBROWS_SHOW_GROUPS  |\
				     USRBROWS_SHOW_USERS)


//
// The caller should provide the name of a help file containing four
// help contexts.  The first help context is for the main User Browser
// dialog, the next three are for the Local Group Membership, Global Group
// Membership, and Find Account subdialogs, respectively.
//
#define USRBROWS_HELP_OFFSET_LOCALGROUP  1
#define USRBROWS_HELP_OFFSET_GLOBALGROUP 2
#define USRBROWS_HELP_OFFSET_FINDUSER    3

//
//  User Details structure returned by user browser enumeration
//
typedef struct tagUSDT {    // usdt
    enum _SID_NAME_USE    UserType;
    PSID                  psidUser;
    PSID                  psidDomain;
    WCHAR               * pszFullName;
    WCHAR               * pszAccountName;
    WCHAR               * pszDisplayName;
    WCHAR               * pszDomainName;
    WCHAR               * pszComment;
    ULONG                 ulFlags;          // User account flags
} USERDETAILS, * LPUSERDETAILS, * PUSERDETAILS;


// Function definitions for the GetUser API...

HUSERBROW WINAPI OpenUserBrowser( LPUSERBROWSER lpUserParms );

BOOL WINAPI EnumUserBrowserSelection( HUSERBROW hHandle,
                                      LPUSERDETAILS lpUser,
                                      DWORD *plBufferSize );

BOOL WINAPI CloseUserBrowser( HUSERBROW hHandle );

#endif //_GETUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acsuser.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AcsUser.cpp
		Implements the ACS User object extension

    FILE HISTORY:
		11/03/97	Wei Jiang	Created
        
*/
// ACSUser.cpp : Implementation of CACSUser
#include "stdafx.h"
#include "acs.h"
#include "acsadmin.h"
#include "ACSUser.h"
#include <dsgetdc.h>
#include <mmc.h>

#if 0 		// user page is removed
/////////////////////////////////////////////////////////////////////////////
// CACSUser
CACSUser::CACSUser()
{
	m_pPage = NULL;
	m_pwszObjName = NULL;
	m_pwszClass = NULL;
	m_ObjMedium.tymed =TYMED_HGLOBAL;
	m_ObjMedium.hGlobal = NULL;
    m_bShowPage = TRUE;
}

CACSUser::~CACSUser()
{
	// stgmedia 
	delete m_pPage;

	ReleaseStgMedium(&m_ObjMedium);
}

//===============================================================================
// IShellExtInit::Initialize
//
// information of the user object is passed in via parameter pDataObject
// further processing will be based on the DN of the user object

STDMETHODIMP CACSUser::Initialize
(
	LPCITEMIDLIST	pIDFolder, 
	LPDATAOBJECT	pDataObj, 
	HKEY			hRegKey
)
{
    TRACE(_T("CACSUser::Initialize()\r\n"));
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT (pDataObj != NULL);

    LPDSOBJECTNAMES		pDsObjectNames;

	// get the object name out of the pDataObj
	UINT 		cfDsObjectNames = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    FORMATETC 	fmte = {cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    // Get the path to the DS object from the data object.
    // Note: This call runs on the caller's main thread. The pages' window
    // procs run on a different thread, so don't reference the data object
    // from a winproc unless it is first marshalled on this thread.
    HRESULT hr = pDataObj->GetData(&fmte, &m_ObjMedium);
    if (!SUCCEEDED (hr))
	{
		ASSERT (0);
		return hr;
	}	
    pDsObjectNames = (LPDSOBJECTNAMES)m_ObjMedium.hGlobal;	
    if (pDsObjectNames->cItems < 1)
    {
		ASSERT (0);        
        return E_FAIL;
    }

    m_bShowPage = (pDsObjectNames->aObjects[0].dwProviderFlags & DSPROVIDER_ADVANCED);

    // if not to show the page, then nothing need to be done after this
    if(!m_bShowPage)
        return hr;

	// get the name of the object
    m_pwszObjName = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetName);

	// get the class name of the object
    m_pwszClass = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetClass);

	// if the user object is exist, change the user name, and load the property
	ASSERT(!m_pPage);	// it should have been consumed or new

	try{
		m_pPage = new CACSUserPg();
	}catch(CMemoryException&)
	{
		delete m_pPage; 
		m_pPage = NULL;
	}

	if(!m_pPage)
		return E_OUTOFMEMORY;

	return m_pPage->Load(m_pwszObjName);

}

//
//  FUNCTION: IShellPropSheetExt::AddPages(LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell just before the property sheet is displayed.
//
//  PARAMETERS:
//    lpfnAddPage -  Pointer to the Shell's AddPage function
//    lParam      -  Passed as second parameter to lpfnAddPage
//
//  RETURN VALUE:
//
//    NOERROR in all cases.  If for some reason our pages don't get added,
//    the Shell still needs to bring up the Properties... sheet.
//
//  COMMENTS:
//

STDMETHODIMP CACSUser::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    TRACE(_T("CACSUser::AddPages()\r\n"));

    // if not to show the page, then nothing need to be done after this
    if(!m_bShowPage)
        return S_OK;

	// param validation
	ASSERT (lpfnAddPage);
    if (lpfnAddPage == NULL)
        return E_UNEXPECTED;

	// make sure our state is fixed up (cause we don't know what context we were called in)
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_pPage);		// the page object must have been created in initialize

	VERIFY(SUCCEEDED(MMCPropPageCallback(&m_pPage->m_psp)));
	HPROPSHEETPAGE hPage = CreatePropertySheetPage(&(m_pPage->m_psp));

	ASSERT (hPage);
	if (hPage == NULL)
		return E_UNEXPECTED;
		// add the page
	lpfnAddPage (hPage, lParam);


	m_pPage = NULL;	// since it's just consumed by the dialog, cannot added again

    return S_OK;
}

//
//  FUNCTION: IShellPropSheetExt::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell only for Control Panel property sheet 
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_FAIL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//

STDMETHODIMP CACSUser::ReplacePage
(
	UINT					uPageID, 
	LPFNADDPROPSHEETPAGE	lpfnReplaceWith, 
	LPARAM					lParam
)
{
    TRACE(_T("CACSUser::ReplacePage()\r\n"));

    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// CACSUserPg property page

IMPLEMENT_DYNCREATE(CACSUserPg, CACSPage)

BEGIN_MESSAGE_MAP(CACSUserPg, CACSPage)
	//{{AFX_MSG_MAP(CACSUserPg)
	ON_CBN_EDITCHANGE(IDC_COMBOUSERPROFILENAME, OnEditchangeCombouserprofilename)
	ON_CBN_SELCHANGE(IDC_COMBOUSERPROFILENAME, OnSelchangeCombouserprofilename)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CACSUserPg::CACSUserPg() : CACSPage(CACSUserPg::IDD)
{
	//{{AFX_DATA_INIT(CACSUserPg)
	m_strProfileName = _T("");
	//}}AFX_DATA_INIT

	m_pBox = NULL;
}

CACSUserPg::~CACSUserPg()
{
	delete m_pBox;
}

void CACSUserPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CACSUserPg)
	DDX_CBString(pDX, IDC_COMBOUSERPROFILENAME, m_strProfileName);
	DDV_MaxChars(pDX, m_strProfileName, 128);
	//}}AFX_DATA_MAP
}


BOOL CACSUserPg::OnApply() 
{
	if(!GetModified())	return TRUE;
	
	m_strArrayPolicyNames.DeleteAll();
	if(!m_strProfileName.IsEmpty())
	{
		CString*	pStr = NULL;
		try
		{
			pStr = new CString();
			*pStr = m_strProfileName;
			m_strArrayPolicyNames.Add(pStr);
			pStr = NULL;
		}
		catch(CMemoryException&)
		{
			delete pStr;
		}
	}

	Save();
	// TODO: Add your specialized code here and/or call the base class
	
	return CACSPage::OnApply();
}

HRESULT CACSUserPg::Load(LPCWSTR userPath)
{
	HRESULT	hr;
	// get the DS user attributes for PolicyName
		// IADsContainer interface for the user object
	if(FAILED(hr = ADsOpenObject((LPWSTR)userPath, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_USE_SIGNING | ADS_USE_SEALING, IID_IADs, (void**)&m_spIADs)))
		return hr;

	ASSERT((IADs*)m_spIADs);
	VARIANT	var;

	VariantInit(&var);
	// framed route
	m_strArrayPolicyNames.DeleteAll();
	if SUCCEEDED(hr = m_spIADs->GetEx(ACS_UAN_POLICYNAME, &var))
	{
		m_strArrayPolicyNames = (SAFEARRAY*)V_ARRAY(&var);
	}
	else if (!NOTINCACHE(hr))
		goto L_ERR;
	VariantClear(&var);

L_SUCC:
	hr = S_OK;
	goto L_CLEANUP;

L_ERR:
	goto L_CLEANUP;

L_CLEANUP:
	VariantClear(&var);

	return hr;
}

HRESULT CACSUserPg::Save()
{
	HRESULT		hr;
	
	if(!(IADs*)m_spIADs)
		return E_FAIL;

	VARIANT	var;
	VariantInit(&var);

	// Policy names
	if(m_strArrayPolicyNames.GetSize())
	{
		V_VT(&var) = VT_VARIANT | VT_ARRAY;
		V_ARRAY(&var) = (SAFEARRAY*)m_strArrayPolicyNames;
		CHECK_HR(hr = m_spIADs->PutEx(ADS_PROPERTY_UPDATE,ACS_UAN_POLICYNAME, var));
	}
	else
	{
		if(S_OK == m_spIADs->GetEx(ACS_UAN_POLICYNAME, &var))
			CHECK_HR(hr = m_spIADs->PutEx(ADS_PROPERTY_CLEAR, ACS_UAN_POLICYNAME, var));
	}
	VariantClear(&var);
	CHECK_HR( hr = m_spIADs->SetInfo() );

L_ERR:
// message box to display error message -- FAILED to SAVE
	return hr;	
}

BOOL CACSUserPg::OnInitDialog() 
{
	HRESULT	hr = S_OK;
	CStrArray*	pStrArray;
	CComObject<CACSGlobalProfiles>*	pObj;
	int	currentIndex = -1;

	CHECK_HR( hr = CComObject<CACSGlobalProfiles>::CreateInstance(&pObj));
	ASSERT(pObj);
	m_spGlobalProfiles = (CACSGlobalProfiles*)pObj;
	CHECK_HR( hr = m_spGlobalProfiles->Open());
	pStrArray = m_spGlobalProfiles->GetChildrenNameList();

	if(pStrArray)
		m_GlobalProfileNames = *pStrArray;
	
	// Initialize profile name
	if(m_strArrayPolicyNames.GetSize())
		m_strProfileName = *(m_strArrayPolicyNames[0]);

	if(m_strProfileName.GetLength() && (currentIndex = m_GlobalProfileNames.Find(m_strProfileName)) == -1)
	{
		try
		{
			CString*	pStr = new CString(m_strProfileName);
			currentIndex = m_GlobalProfileNames.Add(pStr);
		}
		catch(CMemoryException&){} // it's ok even if the string is not added to the array
	}

	CACSPage::OnInitDialog();
	// Initialize combo box list
		// fillin the list box
	try{
		m_pBox = new CStrBox<CComboBox>(this, IDC_COMBOUSERPROFILENAME, m_GlobalProfileNames);
		m_pBox->Fill();
		if(currentIndex != -1)
			m_pBox->Select(currentIndex);
	}
	catch(CMemoryException&)
	{ 
		CHECK_HR(hr = E_OUTOFMEMORY);
	};

L_ERR:
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CACSUserPg::OnEditchangeCombouserprofilename() 
{
	SetModified(TRUE);
}

void CACSUserPg::OnSelchangeCombouserprofilename() 
{
	SetModified(TRUE);
}

#endif	// #if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acs_cn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       acs_cn.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\guids.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Administration SnapIn
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:       guids.cxx
//
//  Contents:   guid allocations - guids are defined in dsclient.h
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

// initguid.h requires this.
//
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

#include <dsclient.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\acsuser.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AcsUser.h
		Defines the ACS User object extension

    FILE HISTORY:
		11/03/97	Wei Jiang	Created
        
*/
// ACSUser.h : Declaration of the CACSUser

#ifndef __ACSUSER_H_
#define __ACSUSER_H_

#include "resource.h"       // main symbols
#include "helper.h"
#include "acsdata.h"
#include "acs.h"

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

#if 0 		// user page is removed
class	CACSUserPg;

/////////////////////////////////////////////////////////////////////////////
// CACSUser
class ATL_NO_VTABLE CACSUser : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CACSUser, &CLSID_ACSUser>,
	public IShellExtInit, 
	public IShellPropSheetExt
{
public:
	CACSUser();
	virtual	~CACSUser();

BEGIN_COM_MAP(CACSUser)
    COM_INTERFACE_ENTRY(IShellExtInit)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)  
END_COM_MAP()

public:
	//IShellExtInit methods
	STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID);

    //IShellPropSheetExt methods
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);
	
    DECLARE_REGISTRY(CACSUser, _T("ACSUser.UserAdminExt.1"), _T("ACSUser.UserAdminExt"), 0, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID(){ return CLSID_ACSUser; }

protected:
    LPWSTR			m_pwszObjName;
    LPWSTR			m_pwszClass;
	CACSUserPg*		m_pPage;
	STGMEDIUM		m_ObjMedium;
	BOOL			m_bShowPage;
};


/////////////////////////////////////////////////////////////////////////////
// CACSUserPg dialog

class CACSUserPg : public CACSPage
{
	DECLARE_DYNCREATE(CACSUserPg)

// Construction
public:
	HRESULT Save();
	HRESULT Load(LPCWSTR userPath);
	CACSUserPg();
	~CACSUserPg();

// Dialog Data
	//{{AFX_DATA(CACSUserPg)
	enum { IDD = IDD_ACSUSER };
	CString	m_strProfileName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CACSUserPg)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStrArray			m_strArrayPolicyNames;
	CComPtr<IADs>		m_spIADs;
	CStrArray			m_GlobalProfileNames;
	// Generated message map functions
	//{{AFX_MSG(CACSUserPg)
	virtual BOOL OnInitDialog();
	afx_msg void OnEditchangeCombouserprofilename();
	afx_msg void OnSelchangeCombouserprofilename();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CComPtr<CACSGlobalProfiles>	m_spGlobalProfiles;	
	CStrBox<CComboBox>*			m_pBox;
};


#endif	// #if 0

#endif //__ACSUSER_H_

//////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\helper.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	helper.cpp
		Implementation of the following helper classes:
		
		CDlgHelper -- enable, check, getcheck of dialog items
		CStrArray -- manages an array of CString*
			It doesn't duplicate the string when add
			It deletes the pointers during destruction
			It imports and exports SAFEARRAY of BSTRs
			It has copy operatators
		CManagedPage -- provide a middle layer between CpropertyPage and
			real property page class to manage: readonly, set modify, and 
			context help info.

		CHelpDialog -- implments context help
		
		And global functions:
			BOOL CheckADsError() -- check error code from ADSI
			void DecorateName() -- make new name to "CN=name" for LDAP
			
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include <afxtempl.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <mmc.h>
#include "helper.h"
#include "resource.h"
// helper function -- enable a dialog button
void CDlgHelper::EnableDlgItem(CDialog* pDialog, int id, bool bEnable)
{
	CWnd*	 pWnd = pDialog->GetDlgItem(id);
	ASSERT(pWnd);
	pWnd->EnableWindow(bEnable);
}

// helper function -- set check status of a dialog button
void CDlgHelper::SetDlgItemCheck(CDialog* pDialog, int id, int nCheck)
{
	CButton*	 pButton = (CButton*)pDialog->GetDlgItem(id);
	ASSERT(pButton);
	pButton->SetCheck(nCheck);
}

// helper function -- get check status of a dialog button
int CDlgHelper::GetDlgItemCheck(CDialog* pDialog, int id)
{
	CButton*	 pButton = (CButton*)(pDialog->GetDlgItem(id));
	ASSERT(pButton);
	return pButton->GetCheck();
}

CStrArray& CStrArray::operator = (const CStrArray& sarray)
{
	int	count = GetSize();
	CString*	pString;

	// remove existing members
	while(count --)
	{
		pString = GetAt(0);
		RemoveAt(0);
		delete pString;
	}

	// copy new
	count = sarray.GetSize();

	for(int i = 0; i < count; i++)
	{
		pString = new CString(*sarray[i]);
		Add(pString);
	}

	return *this;
}

// convert an array of CString to SAFEARRAY
CStrArray::operator SAFEARRAY*()
{
	USES_CONVERSION;
	int			count = GetSize();
	if(count == 0) return NULL;

	SAFEARRAYBOUND	bound[1];
	SAFEARRAY*		pSA = NULL;
	CString*		pStr = NULL;
	long			l[2];
	VARIANT	v;
	VariantInit(&v);

	bound[0].cElements = count;
	bound[0].lLbound = 0;
	try{
		// creat empty right size array
		pSA = SafeArrayCreate(VT_VARIANT, 1, bound);
		if(NULL == pSA)	return NULL;

		// put in each element
		for (long i = 0; i < count; i++)
		{
			pStr = GetAt(i);
			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = T2BSTR((LPTSTR)(LPCTSTR)(*pStr));	
			l[0] = i;
			SafeArrayPutElement(pSA, l, &v);
			VariantClear(&v);
		}
	}
	catch(CMemoryException&)
	{
		SafeArrayDestroy(pSA);
		pSA = NULL;
		VariantClear(&v);
		throw;
	}

	return pSA;
}

//build a StrArray from another array
CStrArray::CStrArray(const CStrArray& sarray)
{
	int	count = sarray.GetSize();
	CString*	pString = NULL;

	for(int i = 0; i < count; i++)
	{
		try{
			pString = new CString(*sarray[i]);
			Add(pString);
		}
		catch(CMemoryException&)
		{
			delete pString;
			throw;
		}
	}
}


//build a StrArray from a safe array
CStrArray::CStrArray(SAFEARRAY* pSA)
{
	if(pSA)	AppendSA(pSA);
}

//remove the elements from the array and delete them
int CStrArray::DeleteAll()
{
	int			ret, count;
	CString*	pStr;

	ret = count	= GetSize();

	while(count--)
	{
		pStr = GetAt(0);
		RemoveAt(0);
		delete pStr;
	}

	return ret;
}

CString*	CStrArray::AddByRID(UINT id)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString*	pStr = NULL;
	try
	{
		pStr = new CString();
		pStr->LoadString(id);
		Add(pStr);
	}
	catch(CMemoryException&)
	{
		delete pStr;
		pStr = NULL;
	}
	return pStr;
}

//build a StrArray from a safe array
bool CStrArray::AppendSA(SAFEARRAY* pSA)
{
	if(!pSA)	return false;

	CString*		pString = NULL;
	long			lIter;
	long			lBound, uBound;
	VARIANT			v;
	bool			bSuc = true;	// ser return value to true;

	USES_CONVERSION;
	VariantInit(&v);

	try{

		SafeArrayGetLBound(pSA, 1, &lBound);
		SafeArrayGetUBound(pSA, 1, &uBound);
		for(lIter = lBound; lIter <= uBound; lIter++)
		{
			if(SUCCEEDED(SafeArrayGetElement(pSA, &lIter, &v)))
			{
				if(V_VT(&v) == VT_BSTR)
				{
					pString = new CString;
					(*pString) = (LPCTSTR)W2T(V_BSTR(&v));
					Add(pString);
				}
			}
		}
	}
	catch(CMemoryException&)
	{
		delete pString;
		VariantClear(&v);
		bSuc = false;
		throw;
	}

	return bSuc;
}

//build a StrArray from a safe array
CStrArray::~CStrArray()
{
	DeleteAll();
}

// return index if found, otherwise -1;
int CStrArray::Find(const CString& Str) const
{
	int	count = GetSize();

	while(count--)
	{
		if(*GetAt(count) == Str) break;
	}
	return count;
}

//build a DWArray from another array
CDWArray::CDWArray(const CDWArray& dwarray)
{
	int	count = dwarray.GetSize();

	for(int i = 0; i < count; i++)
	{
		try{
			Add(dwarray[i]);
		}
		catch(CMemoryException&)
		{
			throw;
		}
	}
}

// return index if found, otherwise -1;
int CDWArray::Find(const DWORD dw) const
{
	int	count = GetSize();

	while(count--)
	{
		if(GetAt(count) == dw) break;
	}
	return count;
}

CDWArray& CDWArray::operator = (const CDWArray& dwarray)
{
	int	count;

	RemoveAll();

	// copy new
	count = dwarray.GetSize();

	for(int i = 0; i < count; i++)
	{
		Add(dwarray[i]);
	}

	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// CManagedPage property page

IMPLEMENT_DYNCREATE(CManagedPage, CPropertyPage)

BEGIN_MESSAGE_MAP(CManagedPage, CPropertyPage)
	//{{AFX_MSG_MAP(CManagedPage)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CManagedPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (m_pHelpTable)
		::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)m_pHelpTable);
}

BOOL CManagedPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW && m_pHelpTable)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_WM_HELP,
		           (DWORD_PTR)(LPVOID)m_pHelpTable);
	}
    return TRUE;	
}


//---------------------------------------------------------------------------
//  This is our self deleting callback function.  If you have more than a 
//  a few property sheets, it might be a good idea to implement this in a
//  base class and derive your MFC property sheets from the base class
//
UINT CALLBACK  CManagedPage::PropSheetPageProc
(
  HWND hWnd,		             // [in] Window handle - always null
  UINT uMsg,                 // [in,out] Either the create or delete message		
  LPPROPSHEETPAGE pPsp		   // [in,out] Pointer to the property sheet struct
)
{
  ASSERT( NULL != pPsp );

  // We need to recover a pointer to the current instance.  We can't just use
  // "this" because we are in a static function
  CManagedPage* pMe   = reinterpret_cast<CManagedPage*>(pPsp->lParam);           
  ASSERT( NULL != pMe );

  switch( uMsg )
  {
    case PSPCB_CREATE:                  
      break;

    case PSPCB_RELEASE:  
      // Since we are deleting ourselves, save a callback on the stack
      // so we can callback the base class
      LPFNPSPCALLBACK pfnOrig = pMe->m_pfnOriginalCallback;
      delete pMe;      
      return 1; //(pfnOrig)(hWnd, uMsg, pPsp);
  }
  // Must call the base class callback function or none of the MFC
  // message map stuff will work
  return (pMe->m_pfnOriginalCallback)(hWnd, uMsg, pPsp); 

} // end PropSheetPageProc()

/////////////////////////////////////////////////////////////////////////////
// CHelpDialog 

IMPLEMENT_DYNCREATE(CHelpDialog, CDialog)

BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
	//{{AFX_MSG_MAP(CHelpDialog)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CHelpDialog::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (m_pHelpTable)
		::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)m_pHelpTable);
}

BOOL CHelpDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW && m_pHelpTable)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_WM_HELP,
		           (DWORD_PTR)(LPVOID)m_pHelpTable);
	}
    return TRUE;	
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckADsError
//
//  Sysnopsis:  Checks the result code from an ADSI call.
//
//  Returns:    TRUE if no error.
//
//-----------------------------------------------------------------------------
BOOL CheckADsError(HRESULT hr, BOOL fIgnoreAttrNotFound, PSTR file,
                   int line)
{
    if (SUCCEEDED(hr))
        return TRUE;


	if( hr == E_ADS_PROPERTY_NOT_FOUND && fIgnoreAttrNotFound)
		return TRUE;

    if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR))
    {
        DWORD dwErr;
        WCHAR wszErrBuf[MAX_PATH+1];
        WCHAR wszNameBuf[MAX_PATH+1];
        ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);
        if ((LDAP_RETCODE)dwErr == LDAP_NO_SUCH_ATTRIBUTE && fIgnoreAttrNotFound)
        {
            return TRUE;
        }
        TRACE(_T("Extended Error 0x%x: %ws %ws (%s @line %d).\n"), dwErr,
                     wszErrBuf, wszNameBuf, file, line);
    }
    else
        TRACE(_T("Error %08lx (%s @line %d)\n"), hr, file, line);

    return FALSE;
}

void DecorateName(LPWSTR outString, LPCWSTR inString)
{
  wcscpy (outString, L"CN=");
  wcscat(outString, inString);
}

void FindNameByDN(LPWSTR outString, LPCWSTR inString)
{

	LPWSTR	p = wcsstr(inString, L"CN=");
	if(!p)
		p = wcsstr(inString, L"cn=");

	if(!p)	
		wcscpy(outString, inString);
	else
	{
		p+=3;
		LPWSTR	p1 = outString;
		while(*p == L' ')	p++;
		while(*p != L',')
			*p1++ = *p++;
		*p1 = L'\0';
	}
}

static	CString	__DSRoot;

HRESULT GetDSRoot(CString& RootString)
{
if(__DSRoot.GetLength() == 0)
{
	CString		sADsPath;
	BSTR		bstrDomainFolder = NULL;
	HRESULT		hr = S_OK;
	IADs*		pDomainObject = NULL;

	DOMAIN_CONTROLLER_INFO	*pInfo = NULL;
	// get the name of the Domain Controller
	DWORD	dwErr = DsGetDcName(NULL, NULL, NULL, NULL, 0, &pInfo);

	if ( (dwErr != NO_ERROR) || (pInfo == NULL) )
		return HRESULT_FROM_WIN32(dwErr);
		
	ASSERT(pInfo->DomainControllerName);

	// strip off any backslashes or slashes
	CString sDCName = pInfo->DomainControllerName;
	while(!sDCName.IsEmpty())
	{
		if ('\\' == sDCName.GetAt(0) || '/' == sDCName.GetAt(0))
			sDCName = sDCName.Mid(1);
		else
			break;
	}

	int	index = sDCName.Find(_T('.'));
	if(-1 != index)
		sDCName = sDCName.Left(index);

	sADsPath = _T("LDAP://") + sDCName;

	// Get the DC root DS object
	hr = ADsOpenObject(T2W((LPTSTR)(LPCTSTR)sADsPath), NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_USE_SIGNING | ADS_USE_SEALING,	IID_IADs, (void**)&pDomainObject);
	
	if(FAILED(hr))
		return hr;

	// find the ADsPath of the DC root
	hr = pDomainObject->get_ADsPath(&bstrDomainFolder);

	if(FAILED(hr))
		return hr;

	pDomainObject->Release();
	pDomainObject = NULL;

	// construct the DN for the object where to put the registration information
	__DSRoot = W2T(bstrDomainFolder);
	
	SysFreeString(bstrDomainFolder);
	
	index = __DSRoot.ReverseFind(_T('/'));
	__DSRoot = __DSRoot.Mid(index + 1);	// strip  off the ADsPath prefix to get the X500 DN
}
	
	RootString = __DSRoot;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Min Chars Dialog Data Validation

void AFXAPI DDV_MinChars(CDataExchange* pDX, CString const& value, int nChars)
{
    ASSERT(nChars >= 1);        // allow them something
    if (pDX->m_bSaveAndValidate && value.GetLength() < nChars)
    {
        TCHAR szT[32];
        wsprintf(szT, _T("%d"), nChars);
        CString prompt;
        AfxFormatString1(prompt, IDS_MIN_CHARS, szT);
        AfxMessageBox(prompt, MB_ICONEXCLAMATION, IDS_MIN_CHARS);
        prompt.Empty(); // exception prep
        pDX->Fail();
    }
}

#define MAX_STRING 1024

//+----------------------------------------------------------------------------
//
//  Function:   ReportErrorEx
//
//  Sysnopsis:  Attempts to get a user-friendly error message from the system.
//
//-----------------------------------------------------------------------------
UINT ReportErrorEx(HRESULT hr, int nStr, HWND hWnd, UINT MB_flags)
{
	CString	str;
	str.LoadString(nStr);
	return ReportErrorEx(hr, str, hWnd, MB_flags);
}

//+----------------------------------------------------------------------------
//
//  Function:   ReportErrorEx
//
//  Sysnopsis:  Attempts to get a user-friendly error message from the system.
//
//-----------------------------------------------------------------------------
UINT ReportErrorEx(HRESULT hr, LPCTSTR Str, HWND hWnd, UINT MB_flags)
{
	PTSTR	ptzSysMsg;
	int		cch;
	CString	AppStr;
	CString	SysStr;
	CString	ErrTitle;
	CString ErrMsg;

	TRACE (_T("*+*+* ReportError called with hr = %lx"), hr);
	if (!hWnd)
	{
		hWnd = GetDesktopWindow();
	}

	try{
		if (Str)
		{
			AppStr = Str;
		}

		cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
						NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						(PTSTR)&ptzSysMsg, 0, NULL);

		if (!cch) { //try ads errors
			HMODULE		adsMod;
			adsMod = GetModuleHandle (L"activeds.dll");
			cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, 
						adsMod, hr,	MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						(PTSTR)&ptzSysMsg, 0, NULL);
		}
		if (!cch)
	    {
    		CString	str;
    		str.LoadString(IDS_ERR_ERRORCODE);
	    	SysStr.Format(str, hr);
		}
		else
		{
			SysStr = ptzSysMsg;
			LocalFree(ptzSysMsg);
		}

		ErrTitle.LoadString(IDS_ERR_TITLE);
	
		if(!AppStr.IsEmpty())
		{
			if(AppStr.Find(_T("%s")) != -1)
				ErrMsg.Format(AppStr, (LPCTSTR)SysStr);
			else
			{
				ErrMsg = AppStr;
				ErrMsg += SysStr;
			}
		}
		else
		{
			ErrMsg = SysStr;
		}

		if(MB_flags == 0)	MB_flags = MB_OK | MB_ICONINFORMATION;
		
		return MessageBox(hWnd, (LPCTSTR)ErrMsg, (LPCTSTR)ErrTitle, MB_flags);
	}catch(CMemoryException&)
	{
		return MessageBox(hWnd, _T("No enought memory, please close other applications and try again."), _T("ACS Snapin Error"), MB_OK | MB_ICONINFORMATION);
	}
}

//+----------------------------------------------------------------------------
//
//  Function:   ReportError
//
//  Sysnopsis:  Attempts to get a user-friendly error message from the system.
//
//-----------------------------------------------------------------------------
void ReportError(HRESULT hr, int nStr, HWND hWnd)
{
	CString	str;

	str.LoadString(nStr);
	ReportErrorEx(hr, str, hWnd, MB_OK | MB_ICONINFORMATION);
}


//+----------------------------------------------------------------------------
//
//  Function:   ReportError
//
//  Sysnopsis:  Attempts to get a user-friendly error message from the system.
//
//-----------------------------------------------------------------------------
void ReportError(HRESULT hr, LPCTSTR Str, HWND hWnd)
{
	ReportErrorEx(hr, Str, hWnd, MB_OK | MB_ICONINFORMATION);
}


BOOL CPageManager::OnApply()
{
	if (!GetModified())	return FALSE;

	SetModified(FALSE);	// prevent from doing this more than once

	std::list<CManagedPage*>::iterator	i;
	for(i = m_listPages.begin(); i != m_listPages.end(); i++)
	{
		if ((*i)->GetModified())
			(*i)->OnApply(); 
	}

	return TRUE;
}

void CPageManager::AddPage(CManagedPage* pPage)
{
	m_listPages.push_back(pPage);
	pPage->SetManager(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       helparr.h
//
//--------------------------------------------------------------------------

#define	IDH_CHECK_ENABLEACCOUNTING	500000000
#define	IDH_CHECK_ENABLEACS	500000100
#define	IDH_CHECK_ENABLELOGGIN	500000150
#define	IDH_CHECK_PF_DATARATE	500000602
#define	IDH_CHECK_PF_DURATION	500000606
#define	IDH_CHECK_PF_PEAKRATE	500000604
#define	IDH_CHECK_TT_DATARATE	500000608
#define	IDH_CHECK_TT_FLOWS	500000612
#define	IDH_CHECK_TT_PEAKRATE	500000610
#define	IDH_COMBOLEVEL	500000154
#define	IDH_COMBOPROFILENAME	500000250
#define	IDH_COMBOUSERPROFILENAME	500000050
#define	IDH_EDIT_ACC_DIRECTORY	500000001
#define	IDH_EDIT_ACC_LOGFILES	500000002
#define	IDH_EDIT_ACC_MAXFILESIZE	500000003
#define	IDH_EDIT_ALIVEINTERVAL	500000501
#define	IDH_EDIT_B4RESERVE	500000504
#define	IDH_EDIT_DEADINTERVAL	500000502
#define	IDH_EDIT_ELECTION	500000500
#define	IDH_EDIT_GEN_DESC	500000101
#define	IDH_EDIT_GEN_PF_DATARATE	500000104
#define	IDH_EDIT_GEN_PF_PEAKRATE	500000107
#define	IDH_EDIT_GEN_TT_DATARATE	500000110
#define	IDH_EDIT_GEN_TT_PEAKRATE	500000113
#define	IDH_EDIT_LOG_DIRECTORY	500000151
#define	IDH_EDIT_LOG_LOGFILES	500000152
#define	IDH_EDIT_LOG_MAXFILESIZE	500000153
#define	IDH_EDIT_PF_DATARATE	500000603
#define	IDH_EDIT_PF_DURATION	500000607
#define	IDH_EDIT_PF_PEAKRATE	500000605
#define	IDH_EDIT_TIMEOUT	500000503
#define	IDH_EDIT_TT_DATARATE	500000609
#define	IDH_EDIT_TT_FLOWS	500000613
#define	IDH_EDIT_TT_PEAKRATE	500000611
#define	IDH_EDITEXTERALUSERNAME	500000200
#define	IDH_EDITSUBNETNAME	500000300
#define	IDH_POLICY_AGGR_DATARATE_DEF	500000351
#define	IDH_POLICY_AGGR_DATARATE_EDIT_LIMIT	500000353
#define	IDH_POLICY_AGGR_DATARATE_RADIO_LIMIT	500000352
#define	IDH_POLICY_AGGR_DATARATE_RES	500000350
#define	IDH_POLICY_AGGR_FLOWS_DEF	500000359
#define	IDH_POLICY_AGGR_FLOWS_EDIT_LIMIT	500000361
#define	IDH_POLICY_AGGR_FLOWS_RADIO_LIMIT	500000360
#define	IDH_POLICY_AGGR_FLOWS_RES	500000358
#define	IDH_POLICY_AGGR_PEAKDATARATE_DEF	500000355
#define	IDH_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT	500000357
#define	IDH_POLICY_AGGR_PEAKDATARATE_RADIO_LIMIT	500000356
#define	IDH_POLICY_AGGR_PEAKDATARATE_RES	500000354
#define	IDH_POLICY_FLOW_DATARATE_DEF	500000401
#define	IDH_POLICY_FLOW_DATARATE_EDIT_LIMIT	500000403
#define	IDH_POLICY_FLOW_DATARATE_RADIO_LIMIT	500000402
#define	IDH_POLICY_FLOW_DATARATE_RES	500000400
#define	IDH_POLICY_FLOW_DURATION_DEF	500000409
#define	IDH_POLICY_FLOW_DURATION_EDIT_LIMIT	500000411
#define	IDH_POLICY_FLOW_DURATION_RADIO_LIMIT	500000410
#define	IDH_POLICY_FLOW_DURATION_RES	500000408
#define	IDH_POLICY_FLOW_PEAKDATARATE_DEF	500000405
#define	IDH_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT	500000407
#define	IDH_POLICY_FLOW_PEAKDATARATE_RADIO_LIMIT	500000406
#define	IDH_POLICY_FLOW_PEAKDATARATE_RES	500000404
#define	IDH_POLICY_GEN_BROWSEOU	500000459
#define	IDH_POLICY_GEN_BROWSEUSER	500000456
#define	IDH_POLICY_GEN_DEFAULTUSER	500000452
#define	IDH_POLICY_GEN_DIRECTION	500000450
#define	IDH_POLICY_GEN_EDIT_OU	500000458
#define	IDH_POLICY_GEN_EDIT_USER	500000455
#define	IDH_POLICY_GEN_RADIO_OU	500000457
#define	IDH_POLICY_GEN_RADIO_USER	500000454
#define	IDH_POLICY_GEN_SERVICELEVEL	500000451
#define	IDH_POLICY_GEN_UNKNOWNUSER	500000453
#define	IDH_SERVERS_ADD	500000551
#define	IDH_SERVERS_INSTALL	500000552
#define	IDH_SERVERS_LIST	500000550
#define	IDH_SERVERS_REMOVE	500000553
#define	IDH_SUBNET_TRAFFIC_DATARATE_LIMITED	500000103
#define	IDH_SUBNET_TRAFFIC_DATARATE_UNLIMITED	500000102
#define	IDH_SUBNET_TRAFFIC_PEAKRATE_LIMITED	500000106
#define	IDH_SUBNET_TRAFFIC_PEAKRATE_UNLIMITED	500000105
#define	IDH_SUBNET_TRAFFIC_TTDATARATE_LIMITED	500000109
#define	IDH_SUBNET_TRAFFIC_TTDATARATE_UNLIMITED	500000108
#define	IDH_SUBNET_TRAFFIC_TTPEAKRATE_LIMITED	500000112
#define	IDH_SUBNET_TRAFFIC_TTPEAKRATE_UNLIMITED	500000111
#define	IDH_USERPASSWD_DOMAIN   500000650
#define	IDH_USERPASSWD_PASSWD	500000651
#define	IDH_USERPASSWD_PASSWD2	500000652
#define IDH_LIST_SERVICELIMIT           500000700
#define IDH_BUTTONADDSERVICELIMIT       500000701
#define IDH_BUTTONDELETESERVICELIMIT    500000702
#define IDH_BUTTONEDITSERVICELIMIT      500000703
#define IDH_COMBO_SUBNET_LIMIT_TYPES    500000704



const DWORD g_aHelpIDs_IDD_ACCOUNTING[]=
{
	IDC_EDIT_ACC_DIRECTORY,IDH_EDIT_ACC_DIRECTORY,
	IDC_EDIT_ACC_LOGFILES,IDH_EDIT_ACC_LOGFILES,
	IDC_EDIT_ACC_MAXFILESIZE,IDH_EDIT_ACC_MAXFILESIZE,
	IDC_CHECK_ENABLEACCOUNTING,IDH_CHECK_ENABLEACCOUNTING,
	0,0
};

const DWORD g_aHelpIDs_IDD_SUBNET_LIMIT[]=
{
	IDC_EDIT_GEN_PF_DATARATE,IDH_EDIT_GEN_PF_DATARATE,
	IDC_EDIT_GEN_TT_PEAKRATE,IDH_EDIT_GEN_TT_PEAKRATE,
	IDC_SUBNET_TRAFFIC_TTPEAKRATE_LIMITED,IDH_SUBNET_TRAFFIC_TTPEAKRATE_LIMITED,
	IDC_SUBNET_TRAFFIC_TTPEAKRATE_UNLIMITED,IDH_SUBNET_TRAFFIC_TTPEAKRATE_UNLIMITED,
	IDC_EDIT_GEN_TT_DATARATE,IDH_EDIT_GEN_TT_DATARATE,
	IDC_SUBNET_TRAFFIC_TTDATARATE_LIMITED,IDH_SUBNET_TRAFFIC_TTDATARATE_LIMITED,
	IDC_SUBNET_TRAFFIC_TTDATARATE_UNLIMITED,IDH_SUBNET_TRAFFIC_TTDATARATE_UNLIMITED,
	IDC_EDIT_GEN_PF_PEAKRATE,IDH_EDIT_GEN_PF_PEAKRATE,
	IDC_SUBNET_TRAFFIC_PEAKRATE_UNLIMITED,IDH_SUBNET_TRAFFIC_PEAKRATE_UNLIMITED,
	IDC_SUBNET_TRAFFIC_DATARATE_LIMITED,IDH_SUBNET_TRAFFIC_DATARATE_LIMITED,
	IDC_SUBNET_TRAFFIC_DATARATE_UNLIMITED,IDH_SUBNET_TRAFFIC_DATARATE_UNLIMITED,
	IDC_SUBNET_TRAFFIC_PEAKRATE_LIMITED,IDH_SUBNET_TRAFFIC_PEAKRATE_LIMITED,
	IDC_COMBO_SUBNET_LIMIT_TYPES,IDH_COMBO_SUBNET_LIMIT_TYPES,
	0, 0
};
	
const DWORD g_aHelpIDs_IDD_GENERAL[]=
{
	IDC_EDIT_GEN_DESC,IDH_EDIT_GEN_DESC,
	IDC_CHECK_ENABLEACS,IDH_CHECK_ENABLEACS,
	IDC_LIST_SERVICELIMIT,IDH_LIST_SERVICELIMIT,
	IDC_BUTTONADDSERVICELIMIT,IDH_BUTTONADDSERVICELIMIT,
	IDC_BUTTONDELETESERVICELIMIT,IDH_BUTTONDELETESERVICELIMIT,
	IDC_BUTTONEDITSERVICELIMIT,IDH_BUTTONEDITSERVICELIMIT,
	
	0, 0
};

const DWORD g_aHelpIDs_IDD_LOGGING[]=
{
	IDC_COMBOLEVEL,IDH_COMBOLEVEL,
	IDC_EDIT_LOG_DIRECTORY,IDH_EDIT_LOG_DIRECTORY,
	IDC_CHECK_ENABLELOGGIN,IDH_CHECK_ENABLELOGGIN,
	IDC_EDIT_LOG_LOGFILES,IDH_EDIT_LOG_LOGFILES,
	IDC_EDIT_LOG_MAXFILESIZE,IDH_EDIT_LOG_MAXFILESIZE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_NEWSUBNET[]=
{
	IDC_EDITSUBNETNAME,IDH_EDITSUBNETNAME,
	0, 0
};

const DWORD g_aHelpIDs_IDD_POLICY_AGGR[]=
{
	IDC_POLICY_AGGR_PEAKDATARATE_RES,IDH_POLICY_AGGR_PEAKDATARATE_RES,
	IDC_POLICY_AGGR_FLOWS_EDIT_LIMIT,IDH_POLICY_AGGR_FLOWS_EDIT_LIMIT,
	IDC_POLICY_AGGR_FLOWS_RADIO_LIMIT,IDH_POLICY_AGGR_FLOWS_RADIO_LIMIT,
	IDC_POLICY_AGGR_FLOWS_DEF,IDH_POLICY_AGGR_FLOWS_DEF,
	IDC_POLICY_AGGR_FLOWS_RES,IDH_POLICY_AGGR_FLOWS_RES,
	IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT,IDH_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT,
	IDC_POLICY_AGGR_PEAKDATARATE_DEF,IDH_POLICY_AGGR_PEAKDATARATE_DEF,
	IDC_POLICY_AGGR_DATARATE_EDIT_LIMIT,IDH_POLICY_AGGR_DATARATE_EDIT_LIMIT,
	IDC_POLICY_AGGR_DATARATE_RADIO_LIMIT,IDH_POLICY_AGGR_DATARATE_RADIO_LIMIT,
	IDC_POLICY_AGGR_DATARATE_DEF,IDH_POLICY_AGGR_DATARATE_DEF,
	IDC_POLICY_AGGR_DATARATE_RES,IDH_POLICY_AGGR_DATARATE_RES,
	IDC_POLICY_AGGR_PEAKDATARATE_RADIO_LIMIT,IDH_POLICY_AGGR_PEAKDATARATE_RADIO_LIMIT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_POLICY_FLOW[]=
{
	IDC_POLICY_FLOW_PEAKDATARATE_RES,IDH_POLICY_FLOW_PEAKDATARATE_RES,
	IDC_POLICY_FLOW_DATARATE_RES,IDH_POLICY_FLOW_DATARATE_RES,
	IDC_POLICY_FLOW_DATARATE_DEF,IDH_POLICY_FLOW_DATARATE_DEF,
	IDC_POLICY_FLOW_DATARATE_EDIT_LIMIT,IDH_POLICY_FLOW_DATARATE_EDIT_LIMIT,
	IDC_POLICY_FLOW_PEAKDATARATE_DEF,IDH_POLICY_FLOW_PEAKDATARATE_DEF,
	IDC_POLICY_FLOW_PEAKDATARATE_RADIO_LIMIT,IDH_POLICY_FLOW_PEAKDATARATE_RADIO_LIMIT,
	IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT,IDH_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT,
	IDC_POLICY_FLOW_DURATION_RES,IDH_POLICY_FLOW_DURATION_RES,
	IDC_POLICY_FLOW_DURATION_DEF,IDH_POLICY_FLOW_DURATION_DEF,
	IDC_POLICY_FLOW_DURATION_RADIO_LIMIT,IDH_POLICY_FLOW_DURATION_RADIO_LIMIT,
	IDC_POLICY_FLOW_DURATION_EDIT_LIMIT,IDH_POLICY_FLOW_DURATION_EDIT_LIMIT,
	IDC_POLICY_FLOW_DATARATE_RADIO_LIMIT,IDH_POLICY_FLOW_DATARATE_RADIO_LIMIT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_POLICY_GEN[]=
{
	IDC_POLICY_GEN_SERVICELEVEL,IDH_POLICY_GEN_SERVICELEVEL,
	IDC_POLICY_GEN_BROWSEOU,IDH_POLICY_GEN_BROWSEOU,
	IDC_POLICY_GEN_EDIT_OU,IDH_POLICY_GEN_EDIT_OU,
	IDC_POLICY_GEN_RADIO_OU,IDH_POLICY_GEN_RADIO_OU,
	IDC_POLICY_GEN_BROWSEUSER,IDH_POLICY_GEN_BROWSEUSER,
	IDC_POLICY_GEN_EDIT_USER,IDH_POLICY_GEN_EDIT_USER,
	IDC_POLICY_GEN_RADIO_USER,IDH_POLICY_GEN_RADIO_USER,
	IDC_POLICY_GEN_DEFAULTUSER,IDH_POLICY_GEN_DEFAULTUSER,
	IDC_POLICY_GEN_DIRECTION,IDH_POLICY_GEN_DIRECTION,
	IDC_POLICY_GEN_UNKNOWNUSER,IDH_POLICY_GEN_UNKNOWNUSER,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SBM[]=
{
	IDC_EDIT_TIMEOUT,IDH_EDIT_TIMEOUT,
	IDC_EDIT_DEADINTERVAL,IDH_EDIT_DEADINTERVAL,
	IDC_EDIT_ALIVEINTERVAL,IDH_EDIT_ALIVEINTERVAL,
	IDC_EDIT_ELECTION,IDH_EDIT_ELECTION,
	IDC_EDIT_B4RESERVE,IDH_EDIT_B4RESERVE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SERVERS[]=
{
	IDC_SERVERS_LIST,IDH_SERVERS_LIST,
	IDC_SERVERS_ADD,IDH_SERVERS_ADD,
	IDC_SERVERS_INSTALL,IDH_SERVERS_INSTALL,
	IDC_SERVERS_REMOVE,IDH_SERVERS_REMOVE,
	0, 0
};


const DWORD g_aHelpIDs_IDD_USERPASSWD[]=
{
    IDC_USERPASSWD_DOMAIN,IDH_USERPASSWD_DOMAIN,
	IDC_USERPASSWD_PASSWD,IDH_USERPASSWD_PASSWD,
	IDC_USERPASSWD_PASSWD2,IDH_USERPASSWD_PASSWD2,
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\helper.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	helper.h
		This file defines the following macros helper classes and functions:

		Macros to check HRESULT
		CDlgHelper -- helper class to Enable/Check dialog Item,
		CMangedPage -- helper class for PropertyPage,
			It manages ReadOnly, SetModified, and ContextHelp

		CHelpDialog -- helper class for dialog with context help support

		CStrArray -- an array of pointer to CString
			It does NOT duplicate the string upon Add
			and It deletes the pointer during destruction
			It imports and exports SAFEARRAY
		
		CReadWriteLock -- class for share read or exclusive write lock
		
		CStrBox -- wrapper class for CListBox and CComboBox
		
		CIPAddress -- wrapper for IPAddress
		
		CFramedRoute -- Wrapper for FramedRoute
		CStrParse -- parses string for TimeOfDay


    FILE HISTORY:

*/
// helper functions for dialog and dialog items
#ifndef _DLGHELPER_
#define _DLGHELPER_

#ifdef NOIMP
#undef NOIMP
#endif
#define NOIMP  {return E_NOTIMPL;}

#ifdef SAYOK
#undef SAYOK
#endif
#define SAYOK  {return S_OK;}
	
// to reduce the step to set VARIANT
#define	V__BOOL(v, v1)\
	V_VT(v) = VT_BOOL,	V_BOOL(v) = (v1)

#define	V__I4(v, v1)\
	V_VT(v) = VT_I4,	V_I4(v) = (v1)

#define	V__I2(v, v1)\
	V_VT(v) = VT_I2,	V_I2(v) = (v1)

#define	V__UI1(v, v1)\
	V_VT(v) = VT_UI1,	V_UI1(v) = (v1)

#define	V__BSTR(v, v1)\
	V_VT(v) = VT_BSTR,	V_BSTR(v) = (v1)

#define	V__ARRAY(v, v1)\
	V_VT(v) = VT_ARRAY,	V_ARRAY(v) = (v1)

#define REPORT_ERROR(hr) \
    TRACE(_T("**** ERROR RETURN <%s @line %d> -> %08lx\n"), \
                 __FILE__, __LINE__, hr)); \
    ReportError(hr, 0, 0);

#ifdef	_DEBUG
#define	CHECK_HR(hr)\
	{if(!CheckADsError(hr, FALSE, __FILE__, __LINE__)){goto L_ERR;}}
#else
#define	CHECK_HR(hr)\
	if FAILED(hr)	goto L_ERR
#endif

#ifdef	_DEBUG
#define	NOTINCACHE(hr)\
	(CheckADsError(hr, TRUE, __FILE__, __LINE__))
#else
#define	NOTINCACHE(hr)\
	(E_ADS_PROPERTY_NOT_FOUND == (hr))
#endif

BOOL CheckADsError(HRESULT hr, BOOL fIgnoreAttrNotFound, PSTR file, int line);


#ifdef	_DEBUG
#define TRACEAfxMessageBox(id) {\
	TRACE(_T("AfxMessageBox <%s @line %d> ID: %d\n"), \
                 __FILE__, __LINE__, id); \
	 AfxMessageBox(id);}\

#else
#define TRACEAfxMessageBox(id) AfxMessageBox(id)
#endif

// change string Name to CN=Name
void DecorateName(LPWSTR outString, LPCWSTR inString);

// change string Name to CN=Name
HRESULT GetDSRoot(CString& RootString);

// find name from DN for example LDAP://CN=userA,CN=users...  returns userA
void FindNameByDN(LPWSTR outString, LPCWSTR inString);

class CDlgHelper
{
public:
	static void EnableDlgItem(CDialog* pDialog, int id, bool bEnable = true);
	static int  GetDlgItemCheck(CDialog* pDialog, int id);
	static void SetDlgItemCheck(CDialog* pDialog, int id, int nCheck);
};


struct CMMCNotify
{
	CMMCNotify() : m_lNotifyHandle(0), m_lParam(0) {};
	LONG_PTR	m_lNotifyHandle;
	LPARAM		m_lParam;
	HRESULT MMCNotify()
	{
		if(m_lNotifyHandle != 0 && m_lParam != 0)
			return MMCPropertyChangeNotify(m_lNotifyHandle, m_lParam);
		else
			return S_FALSE;
	};
};

class CManagedPage;
// class CPageManager and CManagedPage together handle the situation when
// the property sheet need to do some processing when OnApply function is called
// on some of the pages
class ATL_NO_VTABLE CPageManager :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IUnknown
{
BEGIN_COM_MAP(CPageManager)
	COM_INTERFACE_ENTRY(IUnknown)
END_COM_MAP()

public:

	CPageManager(){ m_bCanCancel = TRUE; m_bModified = FALSE; m_bReadOnly = FALSE; m_dwFlags = 0;};
	BOOL	GetModified(){ return m_bModified;};
	void	SetModified(BOOL bModified){ m_bModified = bModified;};
	void	SetReadOnly(BOOL bReadOnly){ m_bReadOnly = bReadOnly;};
	BOOL	GetReadOnly(){ return m_bReadOnly;};
	HRESULT	MMCNotify() { 	return m_mmcNotify.MMCNotify();};
	BOOL	IfCanCancel() { return m_bCanCancel;};
	void	SetCanCancel(BOOL bCanCancel ) { m_bCanCancel = bCanCancel;};
	
	void	SetMMCNotify(LONG_PTR lNotifyHandle, LPARAM lParam)
	{
		// this should be called only once
		ASSERT(m_mmcNotify.m_lNotifyHandle == 0);
		ASSERT(m_mmcNotify.m_lParam == 0);

		ASSERT(lNotifyHandle != 0);
		ASSERT(lParam != 0);

		m_mmcNotify.m_lNotifyHandle = lNotifyHandle;
		m_mmcNotify.m_lParam = lParam;
	};

	virtual BOOL	OnApply();
	virtual void 	OnCancel( ){};
	virtual void 	OnOK( ){};

	void AddPage(CManagedPage* pPage);

	void AddFlags(DWORD flags) { m_dwFlags |= flags;};
	DWORD GetFlags() { return m_dwFlags;};
	void ClearFlags() { m_dwFlags = 0;};
	
protected:
	BOOL						m_bModified;
	BOOL						m_bReadOnly;
	std::list<CManagedPage*>	m_listPages;
	DWORD						m_dwFlags;
	CMMCNotify					m_mmcNotify;
	BOOL						m_bCanCancel;
};

//=============================================================================
// Global Help Table for many Dialog IDs
//
struct CGlobalHelpTable{
	UINT	nIDD;
	const DWORD*	pdwTable;
};

//=============================================================================
// Page that handles Context Help, and talk with CPageManager to do
// OnApply together
//
class CManagedPage : public CPropertyPage	// talk back to property sheet
{
	DECLARE_DYNCREATE(CManagedPage)

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CManagedPage)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
protected:
	CManagedPage() : CPropertyPage(){
		// Need to save the original callback pointer because we are replacing
		// it with our own
		m_pfnOriginalCallback = m_psp.pfnCallback;
	};
	
public:	
	CManagedPage(UINT nIDTemplate) : CPropertyPage(nIDTemplate)
	{
		m_bModified = FALSE;
		m_pHelpTable = NULL;
		m_nIDD = nIDTemplate;

		// Need to save the original callback pointer because we are replacing
		// it with our own
		m_pfnOriginalCallback = m_psp.pfnCallback;
	};

	void SetModified( BOOL bModified = TRUE )
	{
		if(m_spManager.p && !m_spManager->GetReadOnly())	// if NOT readonly
		{
			m_bModified = bModified;
			CPropertyPage::SetModified(bModified);

			// only set change
			if(bModified) m_spManager->SetModified(TRUE);
		}
		else
		{
			m_bModified = bModified;
			CPropertyPage::SetModified(bModified);
		}
	};

	BOOL GetModified() { return m_bModified;};

	virtual BOOL OnApply()
	{
		m_bModified = FALSE;
		BOOL	bRet = TRUE;
		if(m_spManager.p && m_spManager->GetModified())	// prevent from entering more than once
		{
			bRet = m_spManager->OnApply();
		}

		
		if(bRet)
			return CPropertyPage::OnApply();
		else
		{
			SetModified();	// when user click on OK next time, OnApply Should be called again.
			if(m_spManager->IfCanCancel() != TRUE)
				CancelToClose();	// change cancel button to close button
				
			return bRet;
		}
	};

	virtual void 	OnCancel( )
	{
		if(m_spManager.p)	// prevent from entering more than once
			m_spManager->OnCancel();
		CPropertyPage::OnCancel();
	};
	virtual void 	OnOK( )
	{
		if(m_spManager.p)	// prevent from entering more than once
			m_spManager->OnOK();
		CPropertyPage::OnOK();
	};

	void SetManager(CPageManager* pManager) { m_spManager = pManager;};
	void AddFlags(DWORD	flags) { if(m_spManager.p) m_spManager->AddFlags(flags);};

protected:

	// set help table: either call SetGHelpTable or call setHelpTable
	void SetGlobalHelpTable(CGlobalHelpTable** pGTable)
	{
		if(pGTable)
		{
			while((*pGTable)->nIDD && (*pGTable)->nIDD != m_nIDD)
				pGTable++;
			if((*pGTable)->nIDD)
				m_pHelpTable = (*pGTable)->pdwTable;
		}
	};
	
	void SetHelpTable(DWORD* pTable){m_pHelpTable = pTable;};

#ifdef	_DEBUG
	virtual void Dump( CDumpContext& dc ) const
	{
		dc << _T("CManagedPage");
	};

#endif

protected:
	CComPtr<CPageManager>		m_spManager;
	BOOL				m_bModified;

	UINT				m_nIDD;
	const DWORD*				m_pHelpTable;


public:
    static UINT CALLBACK PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    void	SetSelfDeleteCallback()
    {

	    // tell MMC to hook the proc because we are running on a separate,
    	// non MFC thread.
		m_psp.pfnCallback = PropSheetPageProc;

		// We also need to save a self-reference so that the static callback
		// function can recover a "this" pointer
		m_psp.lParam = (LONG_PTR)this;

    };

protected:
    LPFNPSPCALLBACK      m_pfnOriginalCallback;

};

//=============================================================================
// Dialog that handles Context Help
//
class CHelpDialog : public CDialog	// talk back to property sheet
{
	DECLARE_DYNCREATE(CHelpDialog)

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHelpDialog)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
protected:
	CHelpDialog() : CDialog(){};
	
public:	
	CHelpDialog(UINT nIDTemplate, CWnd* pParent) : CDialog(nIDTemplate, pParent)
	{
		m_pHelpTable = NULL;
		m_nIDD = nIDTemplate;
	};
protected:

	// set help table: either call SetGHelpTable or call setHelpTable
	void SetGlobalHelpTable(CGlobalHelpTable** pGTable)
	{
		if(pGTable)
		{
			while((*pGTable)->nIDD && (*pGTable)->nIDD != m_nIDD)
				pGTable++;
			if((*pGTable)->nIDD)
				m_pHelpTable = (*pGTable)->pdwTable;
		}
	};
	
	void SetHelpTable(DWORD* pTable){m_pHelpTable = pTable;};

#ifdef	_DEBUG
	virtual void Dump( CDumpContext& dc ) const
	{
		dc << _T("CHelpDialog");
	};
#endif	

protected:
	UINT				m_nIDD;
	const DWORD*				m_pHelpTable;
};

#include <afxtempl.h>
class CStrArray :  public CArray< CString*, CString* >
{
public:
	CStrArray(SAFEARRAY* pSA = NULL);
	CStrArray(const CStrArray& sarray);
	CString*	AddByRID(UINT	rID);
	int	Find(const CString& Str) const;
	int	DeleteAll();
	virtual ~CStrArray();
	operator SAFEARRAY*();
	CStrArray& operator = (const CStrArray& sarray);
	bool AppendSA(SAFEARRAY* pSA);
};

class CDWArray :  public CArray< DWORD, DWORD >
{
public:
	CDWArray(){};
	CDWArray(const CDWArray& dwarray);
	int	Find(const DWORD dw) const;
	int	DeleteAll(){ RemoveAll(); return 0;};
	virtual ~CDWArray(){RemoveAll();};
	CDWArray& operator = (const CDWArray& dwarray);
};

// a lock to allow multiple read access exclusive or only one write access
class CReadWriteLock		// sharable read, exclusive write
{
public:
	CReadWriteLock() : m_nRead(0)
	{
#ifdef	_DEBUG
		d_bWrite = false;
#endif
	};
	void EnterRead()
	{
		TRACE(_T("Entering Read Lock ..."));
		m_csRead.Lock();
		if (!m_nRead++)
			m_csWrite.Lock();
		m_csRead.Unlock();
		TRACE(_T("Entered Read Lock\n"));
	};

	void LeaveRead()
	{
		TRACE(_T("Leaving Read Lock ..."));
		m_csRead.Lock();
		ASSERT(m_nRead > 0);
		if (!--m_nRead)
			m_csWrite.Unlock();
		m_csRead.Unlock();
		TRACE(_T("Left Read Lock\n"));
	};

	void EnterWrite()
	{
		TRACE(_T("Entering Write Lock ..."));
		m_csWrite.Lock();
		TRACE(_T("Entered Write Lock\n"));
#ifdef	_DEBUG
		d_bWrite = true;
#endif
	};
	void LeaveWrite()
	{
#ifdef	_DEBUG
		d_bWrite = false;
#endif
		m_csWrite.Unlock(); 	
		TRACE(_T("Left Write Lock\n"));
	};
public:
#ifdef	_DEBUG
	bool	d_bWrite;
#endif
	
protected:
	CCriticalSection	m_csRead;
	CCriticalSection	m_csWrite;
	int					m_nRead;
};

// to manage a list box/ combo box
template <class CBox>
class CStrBox
{
public:
	CStrBox(CDialog* pDialog, int id, CStrArray& Strings)
		: m_Strings(Strings), m_id(id)
	{
		m_pDialog = pDialog;
		m_pBox = NULL;
	};

	int Fill()
	{
		m_pBox = (CBox*)m_pDialog->GetDlgItem(m_id);	
		ASSERT(m_pBox);
		m_pBox->ResetContent();

		int count = m_Strings.GetSize();
		int	index;
		for(int i = 0; i < count; i++)
		{
			index = m_pBox->AddString(*m_Strings[(INT_PTR)i]);
			m_pBox->SetItemDataPtr(index, m_Strings[(INT_PTR)i]);
		}
		return count;
	};

	int DeleteSelected()
	{
		int	index;
		ASSERT(m_pBox);
		index = m_pBox->GetCurSel();

		// if there is any selected
		if( index != LB_ERR )
		{
			CString* pStr;
			pStr = (CString*)m_pBox->GetItemDataPtr(index);
			// remove the entry from the box
			m_pBox->DeleteString(index);

			// find the string in the String array
			int count = m_Strings.GetSize();
			for(int i = 0; i < count; i++)
			{
				if (m_Strings[(INT_PTR)i] == pStr)
					break;
			}
			ASSERT(i < count);
			// remove the string from the string array
			m_Strings.RemoveAt(i);
			index = i;
			delete pStr;
		}
		return index;
	};

	int AddString(CString* pStr)		// the pStr needs to dynamically allocated
	{
		int index;
		ASSERT(m_pBox && pStr);
		index = m_pBox->AddString(*pStr);
		m_pBox->SetItemDataPtr(index, pStr);
		return m_Strings.Add(pStr);
	};

	int Select(int arrayindex)		// the pStr needs to dynamically allocated
	{
		if(arrayindex < m_Strings.GetSize())
			return m_pBox->SelectString(0, *m_Strings[(INT_PTR)arrayindex]);
		else
			return	CB_ERR;
	};

	void Enable(BOOL b)		// the pStr needs to dynamically allocated
	{
		ASSERT(m_pBox);
		m_pBox->EnableWindow(b);
	};

	int GetSelected()		// it returns the index where the
	{
		int	index;
		ASSERT(m_pBox);
		index = m_pBox->GetCurSel();

		// if there is any selected
		if( index != LB_ERR )
		{
			CString* pStr;
			pStr = (CString*)m_pBox->GetItemDataPtr(index);

			// find the string in the String array
			int count = m_Strings.GetSize();
			for(int i = 0; i < count; i++)
			{
				if (m_Strings[(INT_PTR)i] == pStr)
					break;
			}
			ASSERT(i < count);
			index = i;
		}
		return index;
	};

	CBox*		m_pBox;
protected:
	int			m_id;
	CStrArray&	m_Strings;
	CDialog*	m_pDialog;
};

// class to take care of ip address
class CIPAddress
{
public:
	CIPAddress(DWORD address = 0)
	{
		m_dwAddress = address;
	};
	
//	CIPAddress(const CString& strAddress){};

	operator DWORD() { return m_dwAddress;};
	operator CString()
	{
		CString	str;

		WORD	hi = HIWORD(m_dwAddress);
		WORD	lo = LOWORD(m_dwAddress);
		str.Format(_T("%-d.%-d.%-d.%d"), HIBYTE(hi), LOBYTE(hi), HIBYTE(lo), LOBYTE(lo));
		return str;
	};

	DWORD	m_dwAddress;
};

// format of framedroute:  mask dest metric ; mask and dest in dot format
class CFramedRoute
{
public:
	void SetRoute(CString* pRoute)
	{
		m_pStrRoute = pRoute;
		m_pStrRoute->TrimLeft();
		m_pStrRoute->TrimRight();
		m_iFirstSpace = m_pStrRoute->Find(_T(' '))	;
		m_iLastSpace = m_pStrRoute->ReverseFind(_T(' '))	;
	};

	CString& GetDest(CString& dest) const
	{
		int		i = m_pStrRoute->Find(_T('/'));
		if(i == -1)
			i = m_iFirstSpace;

		dest = m_pStrRoute->Left(i);
		return dest;
	};

	CString& GetNextStop(CString& nextStop) const
	{
		nextStop = m_pStrRoute->Mid(m_iFirstSpace + 1, m_iLastSpace - m_iFirstSpace -1 );
		return nextStop;
	};

	CString& GetPrefixLength(CString& prefixLength) const
	{
		int		i = m_pStrRoute->Find(_T('/'));

		if( i != -1)
		{
			prefixLength = m_pStrRoute->Mid(i + 1, m_iFirstSpace - i - 1);
		}
		else
			prefixLength = _T("");

		return prefixLength;
	};

	CString& GetMetric(CString& metric) const
	{
		metric = m_pStrRoute->Mid(m_iLastSpace + 1);	
		return metric;
	};

protected:

	// WARNING: the string is not copied, so user need to make sure the origin is valid
	CString*	m_pStrRoute;
	int			m_iFirstSpace;
	int			m_iLastSpace;
};

class CStrParser
{
public:
	CStrParser(LPCTSTR pStr = NULL) : m_pStr(pStr) { }

	// get the current string position
	LPCTSTR	GetStr() const	{ return m_pStr;};

	void	SetStr(LPCTSTR pStr) { m_pStr = pStr;};

	// find a unsigned interger and return it, -1 == not found
	int GetUINT()
	{
		UINT	ret = 0;
		while((*m_pStr < _T('0') || *m_pStr > _T('9')) && *m_pStr != _T('\0'))
			m_pStr++;

		if(*m_pStr == _T('\0')) return -1;

		while(*m_pStr >= _T('0') && *m_pStr <= _T('9'))
		{
			ret = ret * 10 + *m_pStr - _T('0');
			m_pStr++;
		}

		return ret;
	};

	// find c and skip it
	int	GotoAfter(TCHAR c)
	{
		int	ret = 0;
		// go until find c or end of string
		while(*m_pStr != c && *m_pStr != _T('\0'))
			m_pStr++, ret++;

		// if found
		if(*m_pStr == c)	
			m_pStr++, ret++;
		else	
			ret = -1;
		return ret;
	};

	// skip blank characters space tab
	void	SkipBlank()
	{
		while((*m_pStr == _T(' ') || *m_pStr == _T('\t')) && *m_pStr != _T('\0'))
			m_pStr++;
	};

	// check to see if the first character is '0'-'6' for Monday(0) to Sunday(6)
	int DayOfWeek() {
		SkipBlank();
		if(*m_pStr >= _T('0') && *m_pStr <= _T('6'))
			return (*m_pStr++ - _T('0'));
		else
			return -1;	// not day of week
	};


protected:
	LPCTSTR	m_pStr;
private:
	CString	_strTemp;
};

void ReportError(HRESULT hr, int nStr, HWND hWnd);
void ReportError(HRESULT hr, LPCTSTR Str, HWND hWnd);

UINT ReportErrorEx(HRESULT hr, int nStr, HWND hWnd, UINT MB_flags);
UINT ReportErrorEx(HRESULT hr, LPCTSTR Str, HWND hWnd, UINT MB_flags);

// number of characters
void AFXAPI DDV_MinChars(CDataExchange* pDX, CString const& value, int nChars);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\newsub.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       newsub.cpp
//
//--------------------------------------------------------------------------

// newsub.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "acsadmin.h"
#include "acs.h"
#include "newsub.h"

extern "C"
{
#include <dsgetdc.h> // DsValidateSubnetName
}

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgNewSubnet dialog


CDlgNewSubnet::CDlgNewSubnet(CWnd* pParent /*=NULL*/)
	: CACSDialog(CDlgNewSubnet::IDD, pParent)
{
	m_pNameList = NULL;

	//{{AFX_DATA_INIT(CDlgNewSubnet)
	m_strSubnetName = _T("");
	//}}AFX_DATA_INIT
}


void CDlgNewSubnet::DoDataExchange(CDataExchange* pDX)
{
	CACSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgNewSubnet)
	DDX_Text(pDX, IDC_EDITSUBNETNAME, m_strSubnetName);
	DDV_MaxChars(pDX, m_strSubnetName, 128);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDlgNewSubnet, CACSDialog)
	//{{AFX_MSG_MAP(CDlgNewSubnet)
	ON_EN_CHANGE(IDC_EDITSUBNETNAME, OnChangeEditsubnetname)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgNewSubnet message handlers

void CDlgNewSubnet::OnChangeEditsubnetname() 
{
	CEdit	*pEdit = (CEdit*)GetDlgItem(IDC_EDITSUBNETNAME);
	CString	str;
	pEdit->GetWindowText(str);
	ASSERT(m_pNameList);
	BOOL bEnable = (str.GetLength() && (m_pNameList->Find(str) == -1));

	GetDlgItem(IDOK)->EnableWindow(bEnable);
}

void CDlgNewSubnet::OnOK() 
{
	UpdateData(TRUE );
	DWORD dw = ::DsValidateSubnetName( (LPCTSTR)m_strSubnetName );
	if (ERROR_SUCCESS != dw)
		AfxMessageBox(IDS_ERR_SUBNET_NAME);
    else
	    CACSDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\hlptable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       hlptable.h
//
//--------------------------------------------------------------------------

extern CGlobalHelpTable*	ACSHelpTable[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\hlptable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       hlptable.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "helper.h"
#include "acs_cn.h"
#include "helparr.h"

CGlobalHelpTable _g_ht0 = 	{IDD_ACCOUNTING,	g_aHelpIDs_IDD_ACCOUNTING};
CGlobalHelpTable _g_ht1 = 	{IDD_SUBNET_LIMIT,	g_aHelpIDs_IDD_SUBNET_LIMIT};
CGlobalHelpTable _g_ht2 = 	{IDD_GENERAL,	g_aHelpIDs_IDD_GENERAL};
CGlobalHelpTable _g_ht3 = 	{IDD_LOGGING,	g_aHelpIDs_IDD_LOGGING};
CGlobalHelpTable _g_ht6 = 	{IDD_NEWSUBNET,	g_aHelpIDs_IDD_NEWSUBNET};
CGlobalHelpTable _g_ht7 = 	{IDD_POLICY_AGGR,	g_aHelpIDs_IDD_POLICY_AGGR};
CGlobalHelpTable _g_ht8 = 	{IDD_POLICY_FLOW,	g_aHelpIDs_IDD_POLICY_FLOW};
CGlobalHelpTable _g_ht9 = 	{IDD_POLICY_GEN,	g_aHelpIDs_IDD_POLICY_GEN};
CGlobalHelpTable _g_ht10 = 	{IDD_SBM,		g_aHelpIDs_IDD_SBM};
CGlobalHelpTable _g_ht11 = 	{IDD_SERVERS,	g_aHelpIDs_IDD_SERVERS};
CGlobalHelpTable _g_ht13 = 	{IDD_USERPASSWD,	g_aHelpIDs_IDD_USERPASSWD};
CGlobalHelpTable _g_NULL = 	{NULL,	g_aHelpIDs_IDD_NEWSUBNET};

CGlobalHelpTable* ACSHelpTable[] = {
	&_g_ht0 ,
	&_g_ht1 ,
	&_g_ht2 ,
	&_g_ht3 ,
	&_g_ht6 ,
	&_g_ht7 ,
	&_g_ht8 ,
	&_g_ht9 ,
	&_g_ht10 ,
	&_g_ht11 ,
	&_g_ht13 ,
	&_g_NULL ,
	NULL
};
// Microsoft Developer Studio generated Help ID include file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pggen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pggen.cpp
//
//--------------------------------------------------------------------------

// general.cpp : implementation file
//

#include "stdafx.h"
#include "acsadmin.h"
#include "acsdata.h"
#include "pggen.h"
#include "pglimit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPgGeneral property page

IMPLEMENT_DYNCREATE(CPgGeneral, CACSPage)

CPgGeneral::CPgGeneral(CACSSubnetConfig* pConfig, CACSContainerObject<CACSSubnetServiceLimits>* pLimitsCont) : CACSPage(CPgGeneral::IDD)
{
	ASSERT(pConfig);
	m_spConfig = pConfig;
	m_spLimitsCont = pLimitsCont;
	DataInit();
}

void CPgGeneral::DataInit()
{
	//{{AFX_DATA_INIT(CPgGeneral)
	m_bEnableACS = ACS_SCADEF_ENABLEACSSERVICE;
	m_strDesc = _T(" ");
	m_uDataRate = 0;
	m_uPeakRate = 0;
	m_uTTDataRate = 0;
	m_uTTPeakRate = 0;
	m_bFlowDataChanged = FALSE;
	//}}AFX_DATA_INIT

	// service level limits list
	m_aLimitsRecord[Index_Aggregate].m_strNameToCompareWith = ACS_SUBNET_LIMITS_OBJ_AGGREGATE;
	m_aLimitsRecord[Index_Guaranteed].m_strNameToCompareWith = ACS_SUBNET_LIMITS_OBJ_GUARANTEEDSERVICE;
	m_aLimitsRecord[Index_ControlledLoad].m_strNameToCompareWith = ACS_SUBNET_LIMITS_OBJ_CONTROLLEDLOAD;

	m_aLimitsRecord[Index_Aggregate].m_nServiceType = ACS_SUBNET_LIMITS_SERVICETYPE_AGGREGATE;
	m_aLimitsRecord[Index_Guaranteed].m_nServiceType = ACS_SUBNET_LIMITS_SERVICETYPE_GUARANTEEDSERVICE;
	m_aLimitsRecord[Index_ControlledLoad].m_nServiceType = ACS_SUBNET_LIMITS_SERVICETYPE_CONTROLLEDLOAD;

}

CPgGeneral::CPgGeneral() : CACSPage(CPgGeneral::IDD)
{
	DataInit();
}

CPgGeneral::~CPgGeneral()
{
}

void CPgGeneral::DoDataExchange(CDataExchange* pDX)
{
	CACSPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgGeneral)
	DDX_Control(pDX, IDC_BUTTONEDITSERVICELIMIT, m_btnEdit);
	DDX_Control(pDX, IDC_BUTTONDELETESERVICELIMIT, m_btnDelete);
	DDX_Control(pDX, IDC_BUTTONADDSERVICELIMIT, m_btnAdd);
	DDX_Control(pDX, IDC_LIST_SERVICELIMIT, m_listServiceLimit);
	DDX_Check(pDX, IDC_CHECK_ENABLEACS, m_bEnableACS);
	DDX_Text(pDX, IDC_EDIT_GEN_DESC, m_strDesc);
	DDV_MinChars(pDX, m_strDesc, 1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgGeneral, CACSPage)
	//{{AFX_MSG_MAP(CPgGeneral)
	ON_BN_CLICKED(IDC_CHECK_ENABLEACS, OnCheckEnableacs)
	ON_EN_CHANGE(IDC_EDIT_GEN_DESC, OnChangeEditGenDesc)
	ON_BN_CLICKED(IDC_BUTTONADDSERVICELIMIT, OnButtonaddservicelimit)
	ON_BN_CLICKED(IDC_BUTTONDELETESERVICELIMIT, OnButtondeleteservicelimit)
	ON_BN_CLICKED(IDC_BUTTONEDITSERVICELIMIT, OnButtoneditservicelimit)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_SERVICELIMIT, OnItemchangedListServicelimit)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_SERVICELIMIT, OnDblclkListServicelimit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgGeneral message handlers

BOOL CPgGeneral::OnApply() 
{
	// Enable ACS
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_ENABLEACSSERVICE, true);
	m_spConfig->m_bENABLEACSSERVICE = m_bEnableACS;

	// description
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_DESCRIPTION, true);
	m_spConfig->m_strDESCRIPTION = m_strDesc;


	DWORD	dwAttrFlags = ATTR_FLAGS_NONE;
	HRESULT	hr = S_OK;

	dwAttrFlags |= (ACS_SCAF_ENABLEACSSERVICE);
	dwAttrFlags |= (ACS_SCAF_DESCRIPTION);

	AddFlags(dwAttrFlags);	// prepare flags for saving

	// loop through the limits object
	for (int i = 0;  i < _Index_Total_; i++)
	{
		// need to create new one
		if (m_aLimitsRecord[i].m_bExistAfterEdit)
		{
			if (!m_aLimitsRecord[i].m_bExistBeforeEdit)
			{
				CHECK_HR( hr = m_aLimitsRecord[i].m_spLimitsObj->Open(m_spLimitsCont, ACS_CLS_SUBNETLIMITS, m_aLimitsRecord[i].m_strNameToCompareWith, true, true));
				m_aLimitsRecord[i].m_bExistBeforeEdit = true;
			}
		
			// those need to be saved
			if (m_aLimitsRecord[i].m_dwSaveFlags)	
			{
				CHECK_HR ( hr = m_aLimitsRecord[i].m_spLimitsObj->Save(	m_aLimitsRecord[i].m_dwSaveFlags ));
			}
		}
		else
		{
			// those need to be Deleted
			if (m_aLimitsRecord[i].m_bExistBeforeEdit)
			{
				CHECK_HR( hr = m_aLimitsRecord[i].m_spLimitsObj->Delete());
				m_aLimitsRecord[i].m_bExistBeforeEdit = false;
			}
		}
	}


L_ERR:
    // Call superclass first then set your local flag.
	BOOL result = CACSPage::OnApply();
	if ( hr != S_OK)
	{
		ReportError(hr, IDS_FAIL_SAVE_TRAFFIC, NULL);
	}
	else if(m_bFlowDataChanged) 
	{
		AfxMessageBox(IDS_WRN_POLICY_EFFECTIVE_FROM_NEXT_RSVP);
		// Set modified to false since apply should have saved the state.
		m_bFlowDataChanged = false;
	}

	return result;
}

void CPgGeneral::OnCheckEnableacs() 
{
	// TODO: Add your control notification handler code here
	
	SetModified();
	EnableEverything();
	m_bFlowDataChanged	 = TRUE;
}

void CPgGeneral::EnableEverything()
{
	UpdateData();

	CButton*	pButton = (CButton*)GetDlgItem(IDC_CHECK_ENABLEACS);
	int			nCheck = pButton->GetCheck();

	m_listServiceLimit.EnableWindow(nCheck);
	m_btnAdd.EnableWindow(nCheck);
	m_btnDelete.EnableWindow(nCheck);
	m_btnEdit.EnableWindow(nCheck);

	if(nCheck)
	{
		if(m_aAvailableTypes[0] == -1)
		{
			if(::GetFocus() == m_btnAdd.GetSafeHwnd())
				GetDlgItem(IDC_LIST_SERVICELIMIT)->SetFocus();
			m_btnAdd.EnableWindow(FALSE);
		}
		else
			m_btnAdd.EnableWindow(TRUE);

		if(m_listServiceLimit.GetSelectedCount() == 0)
		{
			if(::GetFocus() == m_btnDelete.GetSafeHwnd())
				GetDlgItem(IDC_LIST_SERVICELIMIT)->SetFocus();
		}
		m_btnDelete.EnableWindow(m_listServiceLimit.GetSelectedCount() != 0);

		if(m_listServiceLimit.GetSelectedCount() == 0)
		{
			if(::GetFocus() == m_btnEdit.GetSafeHwnd())
				GetDlgItem(IDC_LIST_SERVICELIMIT)->SetFocus();
		}
		m_btnEdit.EnableWindow(m_listServiceLimit.GetSelectedCount() != 0);
	}
}

void CPgGeneral::OnChangeEditGenDesc() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
}

int SetLimitsObjInListView(CListCtrl& list, CACSSubnetServiceLimits* pLimitsObj, ATTR_FLAG flag)	// return the index of the item
{
	// try to find the item in the list
	LVFINDINFO	fi;
	ZeroMemory(&fi, sizeof(fi));

	fi.flags = LVFI_PARAM;
	fi.lParam = (LPARAM)pLimitsObj;
	int index = list.FindItem(&fi);

	// if not in the list, then add
	if (index == -1)	// not found
	{
		CString	name;
		UINT	id = 0;
		// find out the name of the policy
		switch(pLimitsObj->m_dwServiceType)
		{
		case	ACS_SUBNET_LIMITS_SERVICETYPE_AGGREGATE: id = IDS_AGGREGATEPOLICY; break;
		case	ACS_SUBNET_LIMITS_SERVICETYPE_GUARANTEEDSERVICE: id= IDS_GPOLICY; break;
		case	ACS_SUBNET_LIMITS_SERVICETYPE_CONTROLLEDLOAD: id = IDS_CLPOLICY; break;
		}

		if (id != 0)
			name.LoadString(id);
			
		// add the item into the list
		index = list.InsertItem(0, (LPTSTR)(LPCTSTR)name);
		if (index == -1)
			return index;

		// set the key
		list.SetItemData(index, (LPARAM)pLimitsObj);

		// set text for the 1st column
		list.SetItemText(index, 0, (LPTSTR)(LPCTSTR)name);
	}

	CString	str;
	
	// data rate
	if (pLimitsObj->GetFlags(flag, ACS_SSLAF_MAX_PF_TOKENRATE) != 0)
		str.Format(_T("%d"), TOKBS(pLimitsObj->m_ddMAX_PF_TOKENRATE.LowPart));
	else
		str.LoadString(IDS_TEXT_UNLIMITED);

	list.SetItemText(index, 1, (LPTSTR)(LPCTSTR)str);

	// peak rate
	if (pLimitsObj->GetFlags(flag, ACS_SSLAF_MAX_PF_PEAKBW) != 0)
		str.Format(_T("%d"), TOKBS(pLimitsObj->m_ddMAX_PF_PEAKBW.LowPart));
	else
		str.LoadString(IDS_TEXT_UNLIMITED);
		
	list.SetItemText(index, 2, (LPTSTR)(LPCTSTR)str);

	// total data rate
	if (pLimitsObj->GetFlags(flag, ACS_SSLAF_ALLOCABLERSVPBW) != 0)
		str.Format(_T("%d"), TOKBS(pLimitsObj->m_ddALLOCABLERSVPBW.LowPart));
	else
		str.LoadString(IDS_TEXT_UNLIMITED);

	list.SetItemText(index, 3, (LPTSTR)(LPCTSTR)str);
	
	// total peak rate
	if (pLimitsObj->GetFlags(flag, ACS_SSLAF_MAXPEAKBW) != 0)
		str.Format(_T("%d"), TOKBS(pLimitsObj->m_ddMAXPEAKBW.LowPart));
	else
		str.LoadString(IDS_TEXT_UNLIMITED);

	list.SetItemText(index, 4, (LPTSTR)(LPCTSTR)str);

	list.SetItemState(index, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
	list.SetFocus();

	return index;
}

void CPgGeneral::CalculateAvailableTypes() 
{
	// prepare available type list
	if (m_aLimitsRecord[Index_Aggregate].m_bExistAfterEdit)
		m_aAvailableTypes[0] = -1;	// end of the list
	else
	{
		int index = 0;
		if (!m_aLimitsRecord[Index_Guaranteed].m_bExistAfterEdit)
		{
			m_aAvailableTypes[index ++] = ACS_SUBNET_LIMITS_SERVICETYPE_GUARANTEEDSERVICE;
		}

		if (!m_aLimitsRecord[Index_ControlledLoad].m_bExistAfterEdit)
		{
			m_aAvailableTypes[index++] = ACS_SUBNET_LIMITS_SERVICETYPE_CONTROLLEDLOAD;
		}

		if (!m_aLimitsRecord[Index_ControlledLoad].m_bExistAfterEdit && !m_aLimitsRecord[Index_Guaranteed].m_bExistAfterEdit)
		{
			m_aAvailableTypes[index++] = ACS_SUBNET_LIMITS_SERVICETYPE_AGGREGATE;
		}
		
		m_aAvailableTypes[index] = -1;	// end of the list
	}
}	


BOOL CPgGeneral::OnInitDialog() 
{

	HRESULT	hr = S_OK;
	
	// Enable ACS
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_ENABLEACSSERVICE))
		m_bEnableACS = (m_spConfig->m_bENABLEACSSERVICE != 0);

	// description
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_DESCRIPTION))
		m_strDesc = m_spConfig->m_strDESCRIPTION;

	CACSPage::OnInitDialog();

	// initialize the list view
	ListView_SetExtendedListViewStyle(m_listServiceLimit.m_hWnd, LVS_EX_FULLROWSELECT);

	// Insert all the columns 
	CString	sName;
	CString	sDataRate;
	CString	sPeakRate;
	CString	sTotalDataRate;
	CString	sTotalPeakRate;

/*
    IDS_COL_SUBLIMITS_NAME	"Name"
    IDS_COL_SUBLIMITS_DATARATE	"Data Rate"
    IDS_COL_SUBLIMITS_PEAKRATE	"Peak Rate"
    IDS_COL_SUBLIMITS_TOTALDATARATE	"Tot.Data Rate"
    IDS_COL_SUBLIMITS_TOTALPEAKRATE	"Tot.Peak"
*/
	try{
		if(	sName.LoadString(IDS_COL_SUBLIMITS_NAME)
			&& sDataRate.LoadString(IDS_COL_SUBLIMITS_DATARATE) 
			&& sPeakRate.LoadString(IDS_COL_SUBLIMITS_PEAKRATE) 
			&& sTotalDataRate.LoadString(IDS_COL_SUBLIMITS_TOTALDATARATE) 
			&& sTotalPeakRate.LoadString(IDS_COL_SUBLIMITS_TOTALPEAKRATE))
		{

			RECT	rect;
			m_listServiceLimit.GetClientRect(&rect);
			m_listServiceLimit.InsertColumn(1, sName, LVCFMT_LEFT, (rect.right - rect.left)/5 - 10);
			m_listServiceLimit.InsertColumn(2, sDataRate, LVCFMT_CENTER, (rect.right - rect.left)/5 + 1) ;
			m_listServiceLimit.InsertColumn(3, sPeakRate, LVCFMT_CENTER, (rect.right - rect.left)/5 + 2);
			m_listServiceLimit.InsertColumn(4, sTotalDataRate, LVCFMT_CENTER, (rect.right - rect.left)/5 + 23);
			m_listServiceLimit.InsertColumn(5, sTotalPeakRate, LVCFMT_CENTER, (rect.right - rect.left)/5);
		}

	}
	catch(CMemoryException&)
	{
		TRACEAfxMessageBox(256);
	}
	
	// Insert all the items
	// enumerat the container to list all the policy in place
	std::list<CACSSubnetServiceLimits*>	ObjList;
	std::list<CACSSubnetServiceLimits*>::iterator	it;

	ASSERT(m_spLimitsCont);
	hr = m_spLimitsCont->ListChildren(ObjList, ACS_CLS_SUBNETLIMITS);

	if(hr == ERROR_NO_SUCH_OBJECT)	// object is not found in DS, it's fine, since, some subnet with no ACS info
	{
		hr = S_OK;
		return TRUE;
	}

	if (hr != S_OK)
		return TRUE;
		
	// prepare the list

	for( it = ObjList.begin(); it != ObjList.end(); it++)
	{
		CComPtr<CACSSubnetServiceLimits> spObj;
		spObj = *it;	// this make a release call to the interface previously stored

		for(int i = 0; i < _Index_Total_; i++)
		{
			// put it in the list
			if(m_aLimitsRecord[i].m_strNameToCompareWith.CompareNoCase(spObj->GetName()) == 0)
			{
				m_aLimitsRecord[i].m_bExistBeforeEdit = true;
				m_aLimitsRecord[i].m_bExistAfterEdit = true;
				m_aLimitsRecord[i].m_spLimitsObj = spObj;

				// enforce the service type matches the name
				if(m_aLimitsRecord[i].m_nServiceType != spObj->m_dwServiceType)
				{
					// some processing needed
					spObj->m_dwServiceType = m_aLimitsRecord[i].m_nServiceType;
				}

				spObj->Reopen();
			}
		}
	}

	// populate the list
	for(int i = 0; i < _Index_Total_; i++)
	{
		if ( m_aLimitsRecord[i].m_bExistAfterEdit )
		{
			SetLimitsObjInListView(m_listServiceLimit, m_aLimitsRecord[i].m_spLimitsObj, ATTR_FLAG_LOAD);
		}
	}	

	m_listServiceLimit.SetItemCount(256);

	CalculateAvailableTypes();
	
	EnableEverything();
	
	// TODO: Add extra initialization here
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgGeneral::GetLimitsFromLimitsDlg(CPgSubLimit& dlg) 
{
	// TODO: Add your control notification handler code here
	//
//	start up the LIMIT dialog

	// get the data out and put into the
	CComPtr<CACSSubnetServiceLimits>	spLimits;

	for(int i = 0; i < _Index_Total_; i++)
	{
		if (m_aLimitsRecord[i].m_nServiceType == dlg.m_nServiceType)
		{
			if ( !m_aLimitsRecord[i].m_spLimitsObj )	// not exist
			{
				CComObject<CACSSubnetServiceLimits>*	pObj = NULL;
				CComObject<CACSSubnetServiceLimits>::CreateInstance(&pObj);	// with 0 reference count
				m_aLimitsRecord[i].m_spLimitsObj = pObj;
			}
	
			spLimits = m_aLimitsRecord[i].m_spLimitsObj;

			m_aLimitsRecord[i].m_bExistAfterEdit = true;

			m_aLimitsRecord[i].m_dwSaveFlags = ( ACS_SSLAF_ALLOCABLERSVPBW	
											| ACS_SSLAF_MAXPEAKBW
											| ACS_SSLAF_MAX_PF_TOKENRATE
											| ACS_SSLAF_MAX_PF_PEAKBW
											| ACS_SSLAF_SERVICETYPE	);

			break;
		}
	}

	if (spLimits != NULL)
	{
		// copy the data over from dlg
		spLimits->m_dwServiceType = dlg.m_nServiceType;
		spLimits->SetFlags(ATTR_FLAG_SAVE, ACS_SSLAF_SERVICETYPE, true);

		// data rate
		if(dlg.m_nDataRateChoice)
		{
			spLimits->SetFlags(ATTR_FLAG_SAVE, ACS_SSLAF_MAX_PF_TOKENRATE, true);
			spLimits->m_ddMAX_PF_TOKENRATE.LowPart = FROMKBS(dlg.m_uDataRate);	// in bps --> from kbps
			spLimits->m_ddMAX_PF_TOKENRATE.HighPart = 0;
		}
		else
			spLimits->SetFlags(ATTR_FLAG_SAVE, ACS_SSLAF_MAX_PF_TOKENRATE, false);

		// peak rate
		if(dlg.m_nPeakRateChoice)
		{
			spLimits->SetFlags(ATTR_FLAG_SAVE, ACS_SSLAF_MAX_PF_PEAKBW, true);
			spLimits->m_ddMAX_PF_PEAKBW.LowPart = FROMKBS(dlg.m_uPeakRate);
			spLimits->m_ddMAX_PF_PEAKBW.HighPart = 0;
		}
		else
			spLimits->SetFlags(ATTR_FLAG_SAVE, ACS_SSLAF_MAX_PF_PEAKBW, false);

		// total rate
		if(dlg.m_nTTDataRateChoice)
		{
			spLimits->SetFlags(ATTR_FLAG_SAVE, ACS_SSLAF_ALLOCABLERSVPBW, true);
			spLimits->m_ddALLOCABLERSVPBW.LowPart = FROMKBS(dlg.m_uTTDataRate);
			spLimits->m_ddALLOCABLERSVPBW.HighPart = 0;
		}
		else
			spLimits->SetFlags(ATTR_FLAG_SAVE, ACS_SSLAF_ALLOCABLERSVPBW, false);

		// total peak rate
		if(dlg.m_nTTPeakDataRateChoice)
		{
			spLimits->SetFlags(ATTR_FLAG_SAVE, ACS_SSLAF_MAXPEAKBW, true);
			spLimits->m_ddMAXPEAKBW.LowPart = FROMKBS(dlg.m_uTTPeakRate);
			spLimits->m_ddMAXPEAKBW.HighPart = 0;
		}
		else
			spLimits->SetFlags(ATTR_FLAG_SAVE, ACS_SSLAF_MAXPEAKBW, false);

		m_bFlowDataChanged = TRUE;

		SetLimitsObjInListView(m_listServiceLimit, (CACSSubnetServiceLimits*)spLimits, ATTR_FLAG_SAVE);

		CalculateAvailableTypes();
		EnableEverything();
		SetModified();
	}
}


void CPgGeneral::OnButtonaddservicelimit() 
{
	// TODO: Add your control notification handler code here
	//
//	start up the LIMIT dialog

	CPgSubLimit	dlg(&m_aLimitsRecord[0], &m_aAvailableTypes[0], this);

	if (IDOK == dlg.DoModal())
	{
		GetLimitsFromLimitsDlg(dlg);
	}
}


int GetListViewSelected(CListCtrl& list)	// single selection only
{
	int	count = list.GetItemCount();
	int index = -1;

	while(count--)
	{
		if(list.GetItemState(count, LVIS_SELECTED))
		{
			index = count;
			break;
		}
	}

	return index;
}

void CPgGeneral::OnButtondeleteservicelimit() 
{
	LPARAM	param;
	int	iSelected = GetListViewSelected(m_listServiceLimit);

	if (iSelected != -1)	
	{
		param = m_listServiceLimit.GetItemData(iSelected);

		for(int i = 0; i < _Index_Total_; i++)
		{
			if ((CACSSubnetServiceLimits*)(m_aLimitsRecord[i].m_spLimitsObj) == (CACSSubnetServiceLimits*)param)
			{
				m_aLimitsRecord[i].m_bExistAfterEdit = false;
				break;
			}
		}

		m_listServiceLimit.DeleteItem(iSelected);
		m_bFlowDataChanged = TRUE;

		CalculateAvailableTypes();
		EnableEverything();
		SetModified();
	}
}










void CPgGeneral::SetLimitsToLimitsDlg(CPgSubLimit& dlg, CACSSubnetServiceLimits* pLimits) 
{
	if(NULL == pLimits)	return;

	ATTR_FLAG flag = ATTR_FLAG_LOAD;

	
	for(int i = 0; i < _Index_Total_; i++)
	{
		if ((CACSSubnetServiceLimits*)(m_aLimitsRecord[i].m_spLimitsObj) == pLimits)
		{
			if (m_aLimitsRecord[i].m_dwSaveFlags != 0)
				flag = ATTR_FLAG_SAVE;
			
			break;
		}
	}

	// type
	dlg.m_nServiceType = pLimits->m_dwServiceType;

	// data rate
	if(pLimits->GetFlags(flag, ACS_SSLAF_MAX_PF_TOKENRATE))
	{
		dlg.m_nDataRateChoice = 1;
		dlg.m_uDataRate = TOKBS(pLimits->m_ddMAX_PF_TOKENRATE.LowPart);
	}
	else
		dlg.m_nDataRateChoice = 0;

	// peak rate
	if(pLimits->GetFlags(flag, ACS_SSLAF_MAX_PF_PEAKBW))
	{
		dlg.m_nPeakRateChoice = 1;
		dlg.m_uPeakRate = TOKBS(pLimits->m_ddMAX_PF_PEAKBW.LowPart);
	}
	else
		dlg.m_nPeakRateChoice = 0;

	// total rate
	if(pLimits->GetFlags(flag, ACS_SSLAF_ALLOCABLERSVPBW))
	{
		dlg.m_nTTDataRateChoice = 1;
		dlg.m_uTTDataRate = TOKBS(pLimits->m_ddALLOCABLERSVPBW.LowPart);
	}
	else
		dlg.m_nTTDataRateChoice = 0;

	// total peak rate
	if(pLimits->GetFlags(flag, ACS_SSLAF_MAXPEAKBW))
	{
		dlg.m_nTTPeakDataRateChoice = 1;
		dlg.m_uTTPeakRate = TOKBS(pLimits->m_ddMAXPEAKBW.LowPart);
	}
	else
		dlg.m_nTTPeakDataRateChoice = 0;


}









void CPgGeneral::OnButtoneditservicelimit() 
{
	// TODO: Add your control notification handler code here
	int	iSelected = GetListViewSelected(m_listServiceLimit);
	CComPtr<CACSSubnetServiceLimits>	spLimits;
	if (iSelected != -1)	
	{
		int	types[2];
		
		spLimits = (CACSSubnetServiceLimits*)m_listServiceLimit.GetItemData(iSelected);
		
		types[0] = spLimits->m_dwServiceType;
		types[1] = -1;	// end of list
		
		CPgSubLimit	dlg(&m_aLimitsRecord[0], &types[0], this);

		SetLimitsToLimitsDlg(dlg, (CACSSubnetServiceLimits*)spLimits);


		if (IDOK == dlg.DoModal())
		{
			GetLimitsFromLimitsDlg(dlg);
		}
	}
}

void CPgGeneral::OnItemchangedListServicelimit(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModified();

	EnableEverything();
	
	*pResult = 0;
}

void CPgGeneral::OnDblclkListServicelimit(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	OnButtoneditservicelimit();
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\newprof.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       newprof.cpp
//
//--------------------------------------------------------------------------

// NewProf.cpp : implementation file
//

#include "stdafx.h"
#include "acsadmin.h"
#include "dsacsuse.h"
#include "NewProf.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgNewProf dialog

#if	0		// concept of profile is removed

CDlgNewProf::CDlgNewProf(CWnd* pParent /*=NULL*/)
	: CACSDialog(CDlgNewProf::IDD, pParent)
{
	m_pNameList = NULL;
	//{{AFX_DATA_INIT(CDlgNewProf)
	m_strProfileName = _T("");
	//}}AFX_DATA_INIT

	m_pBox = NULL;
}

CDlgNewProf::~CDlgNewProf()
{
	delete m_pBox;
}


void CDlgNewProf::DoDataExchange(CDataExchange* pDX)
{
	CACSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgNewProf)
	DDX_CBString(pDX, IDC_COMBOPROFILENAME, m_strProfileName);
	DDV_MaxChars(pDX, m_strProfileName, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgNewProf, CACSDialog)
	//{{AFX_MSG_MAP(CDlgNewProf)
	ON_CBN_EDITCHANGE(IDC_COMBOPROFILENAME, OnEditchangeComboprofilename)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgNewProf message handlers

void CDlgNewProf::OnEditchangeComboprofilename() 
{
	CEdit	*pEdit = (CEdit*)GetDlgItem(IDC_COMBOPROFILENAME);
	CString	str;
	pEdit->GetWindowText(str);
	ASSERT(m_pNameList);
	BOOL bEnable = (str.GetLength() && (m_pNameList->Find(str) == -1));

	GetDlgItem(IDOK)->EnableWindow(bEnable);
}

#endif		// #if 0

/////////////////////////////////////////////////////////////////////////////
// CDlgNewExtUser dialog


CDlgNewExtUser::CDlgNewExtUser(CWnd* pParent /*=NULL*/)
	: CACSDialog(CDlgNewExtUser::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgNewExtUser)
	m_strExtUserName = _T("");
	//}}AFX_DATA_INIT
}


void CDlgNewExtUser::DoDataExchange(CDataExchange* pDX)
{
	CACSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgNewExtUser)
	DDX_Text(pDX, IDC_EDITEXTERALUSERNAME, m_strExtUserName);
	DDV_MaxChars(pDX, m_strExtUserName, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgNewExtUser, CACSDialog)
	//{{AFX_MSG_MAP(CDlgNewExtUser)
	ON_EN_CHANGE(IDC_EDITEXTERALUSERNAME, OnChangeEditexteralusername)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgNewExtUser message handlers

void CDlgNewExtUser::OnChangeEditexteralusername() 
{
	CEdit	*pEdit = (CEdit*)GetDlgItem(IDC_EDITEXTERALUSERNAME);
	CString	str;
	pEdit->GetWindowText(str);
	ASSERT(m_pNameList);
	BOOL bEnable = (str.GetLength() && (m_pNameList->Find(str) == -1));

	GetDlgItem(IDOK)->EnableWindow(bEnable);
}


#if 0		// profile folder is removed, the concept of profile is remvoed
BOOL CDlgNewProf::OnInitDialog() 
{
	CACSDialog::OnInitDialog();
	
	HRESULT	hr = S_OK;
	CStrArray*	pStrArray;
	CString*	pStr = NULL;
	CComObject<CACSGlobalProfiles>*	pObj;

	CHECK_HR( hr = CComObject<CACSGlobalProfiles>::CreateInstance(&pObj));
	ASSERT(pObj);
	m_spGlobalProfiles = (CACSGlobalProfiles*)pObj;
	CHECK_HR( hr = m_spGlobalProfiles->Open());
	pStrArray = m_spGlobalProfiles->GetChildrenNameList();

	try{
		if(pStrArray)
			m_GlobalProfileNames = *pStrArray;

	// remove the profile names already exist in this subnet
		for(int i = m_GlobalProfileNames.GetSize() - 1; i >= 0; i--)
		{
			pStr = m_GlobalProfileNames[i];
			if(m_pNameList->Find(*pStr) != -1)
			{
				m_GlobalProfileNames.RemoveAt(i);
				delete pStr;
			}
		}

		// Initialize combo box list
		// fillin the list box
		m_pBox = new CStrBox<CComboBox>(this, IDC_COMBOPROFILENAME, m_GlobalProfileNames);
		m_pBox->Fill();
	}
	catch(CMemoryException&)
	{ 
		CHECK_HR(hr = E_OUTOFMEMORY);
	};

L_ERR:
	if FAILED(hr)
		ReportError(hr, IDS_ERR_COMMAND, NULL);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

#endif		// #if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\newsub.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       newsub.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_NEWSUB_H__A1B96B93_6A82_11D1_8560_00C04FC31FD3__INCLUDED_)
#define AFX_NEWSUB_H__A1B96B93_6A82_11D1_8560_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// newsub.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgNewSubnet dialog

class CDlgNewSubnet : public CACSDialog
{
// Construction
public:
	CDlgNewSubnet(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgNewSubnet)
	enum { IDD = IDD_NEWSUBNET };
	CString	m_strSubnetName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgNewSubnet)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	void SetNameList(CStrArray* pNames) { m_pNameList = pNames;};
// Implementation
protected:
	CStrArray*	m_pNameList; 

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgNewSubnet)
	afx_msg void OnChangeEditsubnetname();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWSUB_H__A1B96B93_6A82_11D1_8560_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\newprof.h ===
#if !defined(AFX_NEWPROF_H__F1801DFC_6212_11D1_855B_00C04FC31FD3__INCLUDED_)
#define AFX_NEWPROF_H__F1801DFC_6212_11D1_855B_00C04FC31FD3__INCLUDED_

#include "helper.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NewProf.h : header file
//

#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CDlgNewProf dialog

#if 0		// concept of profile is removed
class CDlgNewProf : public CACSDialog
{
// Construction
public:
	CDlgNewProf(CWnd* pParent = NULL);   // standard constructor
	virtual ~CDlgNewProf();

// Dialog Data
	//{{AFX_DATA(CDlgNewProf)
	enum { IDD = IDD_NEWPROFILE };
	CString	m_strProfileName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgNewProf)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
public:
	void SetNameList(CStrArray* pNames) { m_pNameList = pNames;};
// Implementation
protected:
	CStrArray*	m_pNameList; 

	// Generated message map functions
	//{{AFX_MSG(CDlgNewProf)
	afx_msg void OnEditchangeComboprofilename();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CStrArray					m_GlobalProfileNames;
	CComPtr<CACSGlobalProfiles>	m_spGlobalProfiles;	
	CStrBox<CComboBox>*			m_pBox;
};

#endif	//#if 0

/////////////////////////////////////////////////////////////////////////////
// CDlgNewExtUser dialog

class CDlgNewExtUser : public CACSDialog
{
// Construction
public:
	CDlgNewExtUser(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgNewExtUser)
	enum { IDD = IDD_NEWEXTERNALUSER };
	CString	m_strExtUserName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgNewExtUser)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	void SetNameList(CStrArray* pNames) { m_pNameList = pNames;};
// Implementation
protected:
	CStrArray*	m_pNameList; 

	// Generated message map functions
	//{{AFX_MSG(CDlgNewExtUser)
	afx_msg void OnChangeEditexteralusername();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPROF_H__F1801DFC_6212_11D1_855B_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pglimit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pglimit.cpp
//
//--------------------------------------------------------------------------

// pglimit.cpp : implementation file
//

#include "stdafx.h"
#include "acsadmin.h"
#include "acsdata.h"
#include "pggen.h"
#include "pglimit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPgSubLimit property page

IMPLEMENT_DYNCREATE(CPgSubLimit, CACSDialog)

CPgSubLimit::CPgSubLimit(CServiceLevelLimitsRecord* pRecord, int *pAvailTypes, CWnd* pParent) : CACSDialog(CPgSubLimit::IDD, pParent)
{
	ASSERT(pRecord != NULL  && pAvailTypes != NULL);
	m_pAvailTypes = pAvailTypes;
	m_pLimitsRecord = pRecord;
	DataInit();
}

void CPgSubLimit::DataInit()
{
	//{{AFX_DATA_INIT(CPgSubLimit)

	// unlimit is the default choice
	m_nDataRateChoice = 0;
	m_nPeakRateChoice = 0;
	m_nTTDataRateChoice = 0;
	m_nTTPeakDataRateChoice = 0;

	
	m_uDataRate = 0;
	m_uPeakRate = 0;
	m_uTTDataRate = 0;
	m_uTTPeakRate = 0;
	m_bFlowDataChanged = FALSE;
	m_nServiceType = -1;
	//}}AFX_DATA_INIT
}

CPgSubLimit::CPgSubLimit() : CACSDialog(CPgSubLimit::IDD, NULL)
{
	DataInit();
}

CPgSubLimit::~CPgSubLimit()
{
}

void CPgSubLimit::DoDataExchange(CDataExchange* pDX)
{
	CACSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgSubLimit)
	DDX_Control(pDX, IDC_COMBO_SUBNET_LIMIT_TYPES, m_comboTypes);
	DDX_Control(pDX, IDC_EDIT_GEN_TT_PEAKRATE, m_editTTPeakRate);
	DDX_Control(pDX, IDC_EDIT_GEN_TT_DATARATE, m_editTTDataRate);
	DDX_Control(pDX, IDC_EDIT_GEN_PF_PEAKRATE, m_editPeakRate);
	DDX_Control(pDX, IDC_EDIT_GEN_PF_DATARATE, m_editDataRate);
	DDX_Radio(pDX, IDC_SUBNET_TRAFFIC_DATARATE_UNLIMITED, m_nDataRateChoice);
	DDX_Radio(pDX, IDC_SUBNET_TRAFFIC_PEAKRATE_UNLIMITED, m_nPeakRateChoice);
	DDX_Radio(pDX, IDC_SUBNET_TRAFFIC_TTDATARATE_UNLIMITED, m_nTTDataRateChoice);
	DDX_Radio(pDX, IDC_SUBNET_TRAFFIC_TTPEAKRATE_UNLIMITED, m_nTTPeakDataRateChoice);
	//}}AFX_DATA_MAP
	DDX_Text(pDX, IDC_EDIT_GEN_PF_DATARATE, m_uDataRate);
	if(m_nDataRateChoice == 1)
		DDV_MinMaxUInt(pDX, m_uDataRate, 0, 4194300);
		
	DDX_Text(pDX, IDC_EDIT_GEN_PF_PEAKRATE, m_uPeakRate);
	if(m_nPeakRateChoice == 1)
	DDV_MinMaxUInt(pDX, m_uPeakRate, 0, 4194300);
	
	DDX_Text(pDX, IDC_EDIT_GEN_TT_DATARATE, m_uTTDataRate);
	if(m_nTTDataRateChoice == 1)
	DDV_MinMaxUInt(pDX, m_uTTDataRate, 0, 4194300);

	
	DDX_Text(pDX, IDC_EDIT_GEN_TT_PEAKRATE, m_uTTPeakRate);
	if(m_nTTPeakDataRateChoice == 1)
	DDV_MinMaxUInt(pDX, m_uTTPeakRate, 0, 4194300);
}


BEGIN_MESSAGE_MAP(CPgSubLimit, CACSDialog)
	//{{AFX_MSG_MAP(CPgSubLimit)
	ON_BN_CLICKED(IDC_SUBNET_TRAFFIC_DATARATE_LIMITED, OnSubnetTrafficDatarateLimited)
	ON_BN_CLICKED(IDC_SUBNET_TRAFFIC_DATARATE_UNLIMITED, OnSubnetTrafficDatarateUnlimited)
	ON_BN_CLICKED(IDC_SUBNET_TRAFFIC_PEAKRATE_LIMITED, OnSubnetTrafficPeakrateLimited)
	ON_BN_CLICKED(IDC_SUBNET_TRAFFIC_PEAKRATE_UNLIMITED, OnSubnetTrafficPeakrateUnlimited)
	ON_BN_CLICKED(IDC_SUBNET_TRAFFIC_TTDATARATE_LIMITED, OnSubnetTrafficTtdatarateLimited)
	ON_BN_CLICKED(IDC_SUBNET_TRAFFIC_TTDATARATE_UNLIMITED, OnSubnetTrafficTtdatarateUnlimited)
	ON_BN_CLICKED(IDC_SUBNET_TRAFFIC_TTPEAKRATE_LIMITED, OnSubnetTrafficTtpeakrateLimited)
	ON_BN_CLICKED(IDC_SUBNET_TRAFFIC_TTPEAKRATE_UNLIMITED, OnSubnetTrafficTtpeakrateUnlimited)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgSubLimit message handlers

BOOL CPgSubLimit::OnInitDialog() 
{

	CACSDialog::OnInitDialog();


	// populate the strings in combo box
	int*	pTypes = m_pAvailTypes;
	CString	str;
	UINT	strId = 0;
	
	if(!pTypes)	return FALSE;

	while (*pTypes != -1)
	{
		switch(*pTypes)
		{
		case	ACS_SUBNET_LIMITS_SERVICETYPE_AGGREGATE:
			strId = IDS_AGGREGATEPOLICY;
			break;
		case	ACS_SUBNET_LIMITS_SERVICETYPE_GUARANTEEDSERVICE:
			strId = IDS_GUARANTEEDSERVICE;
			break;
		case	ACS_SUBNET_LIMITS_SERVICETYPE_CONTROLLEDLOAD:
			strId = IDS_CONTROLLEDLOAD;
			break;
		}

		str.LoadString(strId);

		int index = m_comboTypes.AddString(str);
		
		if(index != -1)
			m_comboTypes.SetItemData(index, *pTypes);
		
		pTypes++;
	}

	m_comboTypes.SetCurSel(0);

	EnableEverything();
	
	// TODO: Add extra initialization here
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgSubLimit::OnSubnetTrafficDatarateLimited() 
{
	m_editDataRate.EnableWindow(TRUE);
	m_bFlowDataChanged	 = TRUE;
}

void CPgSubLimit::OnSubnetTrafficDatarateUnlimited() 
{
	m_editDataRate.EnableWindow(FALSE);
	m_bFlowDataChanged	 = TRUE;
}

void CPgSubLimit::OnSubnetTrafficPeakrateLimited() 
{
	m_editPeakRate.EnableWindow(TRUE);
	m_bFlowDataChanged	 = TRUE;
}

void CPgSubLimit::OnSubnetTrafficPeakrateUnlimited() 
{
	m_editPeakRate.EnableWindow(FALSE);
	m_bFlowDataChanged	 = TRUE;
}

void CPgSubLimit::OnSubnetTrafficTtdatarateLimited() 
{
	m_editTTDataRate.EnableWindow(TRUE);
	
	m_bFlowDataChanged	 = TRUE;
}

void CPgSubLimit::OnSubnetTrafficTtdatarateUnlimited() 
{
	m_editTTDataRate.EnableWindow(FALSE);
	m_bFlowDataChanged	 = TRUE;
	
}

void CPgSubLimit::OnSubnetTrafficTtpeakrateLimited() 
{
	m_editTTPeakRate.EnableWindow(TRUE);
	m_bFlowDataChanged	 = TRUE;
	
}

void CPgSubLimit::OnSubnetTrafficTtpeakrateUnlimited() 
{
	m_editTTPeakRate.EnableWindow(FALSE);
	m_bFlowDataChanged	 = TRUE;
}

void CPgSubLimit::EnableEverything()
{
    UpdateData();

    m_editDataRate.EnableWindow(m_nDataRateChoice);
    m_editPeakRate.EnableWindow(m_nPeakRateChoice);
    m_editTTDataRate.EnableWindow(m_nTTDataRateChoice);
    m_editTTPeakRate.EnableWindow(m_nTTPeakDataRateChoice);

	if(m_nServiceType != -1)	// being edited
		m_comboTypes.EnableWindow(FALSE);
	
}
void CPgSubLimit::OnOK() 
{
	// TODO: Add extra validation here
	UINT	cId = 0;
	UINT	mId = 0;
		
	if(m_nDataRateChoice && m_nPeakRateChoice && m_uDataRate > m_uPeakRate)
	{
		cId = IDC_EDIT_GEN_PF_PEAKRATE;
		mId = IDS_ERR_PEAKRATE_LESS_RATE;
	}

	if(!cId && m_nTTDataRateChoice && m_nDataRateChoice && m_uDataRate > m_uTTDataRate)
	{
		cId = IDC_EDIT_GEN_TT_DATARATE;
		mId = IDS_ERR_TOTALRATE_LESS_RATE;
	}

#if 0 // 367760	1	 	a-leeb	ACS: Snap-in performin incorrect boundary checking

	if(!cId && m_nTTDataRateChoice && m_nPeakRateChoice && m_uPeakRate > m_uTTDataRate)
	{
		cId = IDC_EDIT_GEN_TT_DATARATE;
		mId = IDS_ERR_TOTALRATE_LESS_PEAKRATE;
	}
#endif 

	if(!cId && m_nTTPeakDataRateChoice && m_nPeakRateChoice && m_uPeakRate > m_uTTPeakRate)
	{
		cId = IDC_EDIT_GEN_TT_PEAKRATE;
		mId = IDS_ERR_TOTALPEAK_LESS_PEAK;
	}

	if(!cId && m_nTTDataRateChoice && m_nTTPeakDataRateChoice && m_uTTDataRate > m_uTTPeakRate)
	{
		cId = IDC_EDIT_GEN_TT_PEAKRATE;
		mId = IDS_ERR_TOTALPEAK_LESS_TOTALRATE;
	}

	if(cId)
	{
		CWnd*	pWnd = GetDlgItem(cId);
		ASSERT(pWnd);
		GotoDlgCtrl( pWnd );

		AfxMessageBox(mId);
		return ;
	}
	else
	{
		int index = m_comboTypes.GetCurSel();

		if( index != CB_ERR)
		{
			m_nServiceType = m_comboTypes.GetItemData(index);
		}
		
		CACSDialog::OnOK();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pggen.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       pggen.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_GENERAL_H__C0DCD9EA_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
#define AFX_GENERAL_H__C0DCD9EA_64FE_11D1_855B_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// general.h : header file
//

class CPgSubLimit;

/////////////////////////////////////////////////////////////////////////////
// CPgGeneral dialog

struct CServiceLevelLimitsRecord
{
	CServiceLevelLimitsRecord()
	{
		m_nServiceType = -1;	// no inited
		m_bExistBeforeEdit = false;
		m_bExistAfterEdit = false;
		m_dwSaveFlags = 0;
	};
	
	int		m_nServiceType;
	CString	m_strNameToCompareWith;
	bool	m_bExistBeforeEdit;
	bool	m_bExistAfterEdit;
	CComPtr<CACSSubnetServiceLimits>	m_spLimitsObj;
	DWORD	m_dwSaveFlags;		// attribute flags
};
	//		ACS_SUBNET_LIMITS_SERVICETYPE_AGGREGATE			
	//		ACS_SUBNET_LIMITS_SERVICETYPE_GUARANTEEDSERVICE	
	//		ACS_SUBNET_LIMITS_SERVICETYPE_CONTROLLEDLOAD	

enum ServiceLevelIndex
{
	Index_Aggregate,
	Index_Guaranteed,
	Index_ControlledLoad,
	_Index_Total_
};


class CPgGeneral : public CACSPage
{
	DECLARE_DYNCREATE(CPgGeneral)

// Construction
protected:
	CPgGeneral();
public:
	CPgGeneral(CACSSubnetConfig* pConfig, CACSContainerObject<CACSSubnetServiceLimits>* pLimitsCont);
	~CPgGeneral();

// Dialog Data
	//{{AFX_DATA(CPgGeneral)
	enum { IDD = IDD_GENERAL };
	CButton	m_btnEdit;
	CButton	m_btnDelete;
	CButton	m_btnAdd;
	CListCtrl	m_listServiceLimit;
	BOOL	m_bEnableACS;
	CString	m_strDesc;
	UINT	m_uDataRate;
	UINT	m_uPeakRate;
	UINT	m_uTTDataRate;
	UINT	m_uTTPeakRate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	void EnableEverything();
	// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPgGeneral)
	afx_msg void OnCheckEnableacs();
	afx_msg void OnChangeEditGenDesc();
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonaddservicelimit();
	afx_msg void OnButtondeleteservicelimit();
	afx_msg void OnButtoneditservicelimit();
	afx_msg void OnItemchangedListServicelimit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkListServicelimit(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void	DataInit();
	CComPtr<CACSSubnetConfig>		m_spConfig;
	BOOL	m_bFlowDataChanged;
	CComPtr<CACSContainerObject<CACSSubnetServiceLimits> > m_spLimitsCont;

	void CalculateAvailableTypes();
	void GetLimitsFromLimitsDlg(CPgSubLimit& dlg);
	void SetLimitsToLimitsDlg(CPgSubLimit& dlg, CACSSubnetServiceLimits* pLimits) ;


	// since, we only support 3 different service-level limit
	// type ids are defined by
	//		ACS_SUBNET_LIMITS_SERVICETYPE_AGGREGATE			
	//		ACS_SUBNET_LIMITS_SERVICETYPE_GUARANTEEDSERVICE	
	//		ACS_SUBNET_LIMITS_SERVICETYPE_CONTROLLEDLOAD	
	
	// names are defined by 
	//		ACS_SUBNET_LIMITS_OBJ_AGGREGATE			
	//		ACS_SUBNET_LIMITS_OBJ_GUARANTEEDSERVICE		
	//		ACS_SUBNET_LIMITS_OBJ_CONTROLLEDLOAD		

	// the following logic is used to determine which limit can be added
	// if aggregate, is defined, no other limit can be added, till the aggregate is removed
	// if either guranteed or controlled-load is defined, no aggregate can be added
	// guranteed and controlled-load may 
	CServiceLevelLimitsRecord	m_aLimitsRecord[_Index_Total_];
	int							m_aAvailableTypes[_Index_Total_ + 1];	// -1 is used for the end
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GENERAL_H__C0DCD9EA_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pglimit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       pggen.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SUB_LIMIT_H__C0DCD9EA_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
#define AFX_SUB_LIMIT_H__C0DCD9EA_64FE_11D1_855B_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CPgSubLimit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPgCPgSubLimit dialog

class CPgSubLimit : public CACSDialog
{
	DECLARE_DYNCREATE(CPgSubLimit)

// Construction
protected:
	CPgSubLimit();
public:
	CPgSubLimit(CServiceLevelLimitsRecord* pRecord, int	*pAvailTypes, CWnd* pParent);
	~CPgSubLimit();

// Dialog Data
	//{{AFX_DATA(CPgSubLimit)
	enum { IDD = IDD_SUBNET_LIMIT };
	CComboBox	m_comboTypes;
	CEdit	m_editTTPeakRate;
	CEdit	m_editTTDataRate;
	CEdit	m_editPeakRate;
	CEdit	m_editDataRate;
	int		m_nDataRateChoice;
	int		m_nPeakRateChoice;
	int		m_nTTDataRateChoice;
	int		m_nTTPeakDataRateChoice;
	UINT	m_uDataRate;
	UINT	m_uPeakRate;
	UINT	m_uTTDataRate;
	UINT	m_uTTPeakRate;
	int		m_nServiceType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgSubLimit)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPgSubLimit)
	virtual BOOL OnInitDialog();
	afx_msg void OnSubnetTrafficDatarateLimited();
	afx_msg void OnSubnetTrafficDatarateUnlimited();
	afx_msg void OnSubnetTrafficPeakrateLimited();
	afx_msg void OnSubnetTrafficPeakrateUnlimited();
	afx_msg void OnSubnetTrafficTtdatarateLimited();
	afx_msg void OnSubnetTrafficTtdatarateUnlimited();
	afx_msg void OnSubnetTrafficTtpeakrateLimited();
	afx_msg void OnSubnetTrafficTtpeakrateUnlimited();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void	EnableEverything();
	void	DataInit();
	CServiceLevelLimitsRecord*		m_pLimitsRecord;
	int*							m_pAvailTypes;	// -1 is the end
	BOOL	m_bFlowDataChanged;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SUB_LIMIT_H__C0DCD9EA_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pglog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pglog.cpp
//
//--------------------------------------------------------------------------

// logging.cpp : implementation file
//

#include "stdafx.h"
#include "acsadmin.h"
#include "pglog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPgAccounting property page

IMPLEMENT_DYNCREATE(CPgAccounting, CACSPage)

CPgAccounting::CPgAccounting(CACSSubnetConfig* pConfig) : CACSPage(CPgAccounting::IDD)
{
	ASSERT(pConfig);
	m_spConfig = pConfig;
	DataInit();
}

void CPgAccounting::DataInit()
{
	//{{AFX_DATA_INIT(CPgAccounting)
	m_bEnableAccounting = ACS_SCADEF_ENABLERSVPMESSAGEACCOUNTING;
	m_strLogDir = ACS_SCADEF_RSVPACCOUNTINGFILESLOCATION;
	m_dwNumFiles = ACS_SCADEF_MAXNOOFACCOUNTINGFILES;
	m_dwLogSize = ACS_SCADEF_MAXSIZEOFRSVPACCOUNTINGFILE;
	//}}AFX_DATA_INIT
}

CPgAccounting::CPgAccounting() : CACSPage(CPgAccounting::IDD)
{
	DataInit();
}

CPgAccounting::~CPgAccounting()
{
}

void CPgAccounting::DoDataExchange(CDataExchange* pDX)
{
	CACSPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgAccounting)
	DDX_Check(pDX, IDC_CHECK_ENABLEACCOUNTING, m_bEnableAccounting);
	DDX_Text(pDX, IDC_EDIT_ACC_DIRECTORY, m_strLogDir);
	DDV_MaxChars(pDX, m_strLogDir, ACS_SCAV_MAX_LOGFILESLOCATION);
	DDX_Text(pDX, IDC_EDIT_ACC_LOGFILES, m_dwNumFiles);
	DDV_MinMaxDWord(pDX, m_dwNumFiles, 1, DWORD_LIMIT);
	DDX_Text(pDX, IDC_EDIT_ACC_MAXFILESIZE, m_dwLogSize);
	DDV_MinMaxDWord(pDX, m_dwLogSize, 1, TOMB(DWORD_LIMIT));
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgAccounting, CACSPage)
	//{{AFX_MSG_MAP(CPgAccounting)
	ON_BN_CLICKED(IDC_CHECK_ENABLEACCOUNTING, OnCheckEnableAccounting)
	ON_EN_CHANGE(IDC_EDIT_ACC_DIRECTORY, OnChangeEditLogDirectory)
	ON_EN_CHANGE(IDC_EDIT_ACC_LOGFILES, OnChangeEditLogLogfiles)
	ON_EN_CHANGE(IDC_EDIT_ACC_MAXFILESIZE, OnChangeEditLogMaxfilesize)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgAccounting message handlers

BOOL CPgAccounting::OnApply() 
{
	USES_CONVERSION;
	
	// Enable Logging
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_ENABLERSVPMESSAGEACCOUNTING, true);
	m_spConfig->m_bENABLERSVPMESSAGEACCOUNTING = m_bEnableAccounting;

	// logging directory
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_RSVPACCOUNTINGFILESLOCATION, true);
	m_spConfig->m_strRSVPACCOUNTINGFILESLOCATION = m_strLogDir;

	// number of log files
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_MAXNOOFACCOUNTINGFILES, true);
	m_spConfig->m_dwMAXNOOFACCOUNTINGFILES = m_dwNumFiles;

	// max file size
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_MAXSIZEOFRSVPACCOUNTINGFILE, true);
	m_spConfig->m_dwMAXSIZEOFRSVPACCOUNTINGFILE = FROMMB(m_dwLogSize);

	DWORD	dwAttrFlags = ATTR_FLAGS_NONE;
	dwAttrFlags |= (ACS_SCAF_ENABLERSVPMESSAGEACCOUNTING | ACS_SCAF_RSVPACCOUNTINGFILESLOCATION);
	dwAttrFlags |= (ACS_SCAF_MAXNOOFACCOUNTINGFILES | ACS_SCAF_MAXSIZEOFRSVPACCOUNTINGFILE);

	AddFlags(dwAttrFlags);	// prepare flags for saving

	return CACSPage::OnApply();
}

void CPgAccounting::OnCheckEnableAccounting() 
{
	SetModified();
	EnableEverything();
	// TODO: Add your control notification handler code here
	
}

void CPgAccounting::OnChangeEditLogDirectory() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

void CPgAccounting::OnChangeEditLogLogfiles() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

void CPgAccounting::OnChangeEditLogMaxfilesize() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

BOOL CPgAccounting::OnInitDialog() 
{
	// Enable Logging
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_ENABLERSVPMESSAGEACCOUNTING))
		m_bEnableAccounting = (m_spConfig->m_bENABLERSVPMESSAGEACCOUNTING != 0);

	// logging directory
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_RSVPACCOUNTINGFILESLOCATION))
		m_strLogDir = m_spConfig->m_strRSVPACCOUNTINGFILESLOCATION;

	// number of log files
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_MAXNOOFACCOUNTINGFILES))
	{
		m_dwNumFiles = m_spConfig->m_dwMAXNOOFACCOUNTINGFILES;
	}

	// max file size
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_MAXSIZEOFRSVPACCOUNTINGFILE))
	{
		m_dwLogSize = TOMB(m_spConfig->m_dwMAXSIZEOFRSVPACCOUNTINGFILE);
	}

	CACSPage::OnInitDialog();
	
	EnableEverything();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgAccounting::EnableEverything()
{
	CButton*	pButton = (CButton*)GetDlgItem(IDC_CHECK_ENABLEACCOUNTING);
	int			nCheck = pButton->GetCheck();
	
	GetDlgItem(IDC_EDIT_ACC_DIRECTORY)->EnableWindow(nCheck);
	GetDlgItem(IDC_EDIT_ACC_LOGFILES)->EnableWindow(nCheck);
	GetDlgItem(IDC_EDIT_ACC_MAXFILESIZE)->EnableWindow(nCheck);
}



/////////////////////////////////////////////////////////////////////////////
// CPgLogging property page

IMPLEMENT_DYNCREATE(CPgLogging, CACSPage)

CPgLogging::CPgLogging(CACSSubnetConfig* pConfig) : CACSPage(CPgLogging::IDD)
{
	ASSERT(pConfig);
	m_spConfig = pConfig;
	DataInit();
}

void CPgLogging::DataInit()
{
	//{{AFX_DATA_INIT(CPgLogging)
	m_bEnableLogging = ACS_SCADEF_ENABLERSVPMESSAGELOGGING;
	m_dwLevel = ACS_SCADEF_EVENTLOGLEVEL;
	m_strLogDir = ACS_SCADEF_RSVPLOGFILESLOCATION;
	m_dwNumFiles = ACS_SCADEF_MAXNOOFLOGFILES;
	m_dwLogSize = ACS_SCADEF_MAXSIZEOFRSVPLOGFILE;
	//}}AFX_DATA_INIT

	m_pLevel = NULL;
}

CPgLogging::CPgLogging() : CACSPage(CPgLogging::IDD)
{
	DataInit();
}

CPgLogging::~CPgLogging()
{
	delete	m_pLevel;
	m_aLevelStrings.DeleteAll();
}

void CPgLogging::DoDataExchange(CDataExchange* pDX)
{
	CACSPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgLogging)
	DDX_Check(pDX, IDC_CHECK_ENABLELOGGIN, m_bEnableLogging);
	DDX_CBIndex(pDX, IDC_COMBOLEVEL, m_dwLevel);
	DDX_Text(pDX, IDC_EDIT_LOG_DIRECTORY, m_strLogDir);
	DDV_MaxChars(pDX, m_strLogDir, ACS_SCAV_MAX_LOGFILESLOCATION);
	DDX_Text(pDX, IDC_EDIT_LOG_LOGFILES, m_dwNumFiles);
	DDV_MinMaxDWord(pDX, m_dwNumFiles, 1, DWORD_LIMIT);
	DDX_Text(pDX, IDC_EDIT_LOG_MAXFILESIZE, m_dwLogSize);
	DDV_MinMaxDWord(pDX, m_dwLogSize, 1, TOMB(DWORD_LIMIT));
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgLogging, CACSPage)
	//{{AFX_MSG_MAP(CPgLogging)
	ON_BN_CLICKED(IDC_CHECK_ENABLELOGGIN, OnCheckEnableloggin)
	ON_CBN_SELCHANGE(IDC_COMBOLEVEL, OnSelchangeCombolevel)
	ON_EN_CHANGE(IDC_EDIT_LOG_DIRECTORY, OnChangeEditLogDirectory)
	ON_EN_CHANGE(IDC_EDIT_LOG_LOGFILES, OnChangeEditLogLogfiles)
	ON_EN_CHANGE(IDC_EDIT_LOG_MAXFILESIZE, OnChangeEditLogMaxfilesize)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgLogging message handlers

BOOL CPgLogging::OnApply() 
{
	USES_CONVERSION;
	
	// Enable Logging
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_ENABLERSVPMESSAGELOGGING, true);
	m_spConfig->m_bENABLERSVPMESSAGELOGGING = m_bEnableLogging;

	// logging directory
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_RSVPLOGFILESLOCATION, true);
	m_spConfig->m_strRSVPLOGFILESLOCATION = m_strLogDir;

	// number of log files
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_MAXNOOFLOGFILES, true);
	m_spConfig->m_dwMAXNOOFLOGFILES = m_dwNumFiles;

	// max file size
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_MAXSIZEOFRSVPLOGFILE, true);
	m_spConfig->m_dwMAXSIZEOFRSVPLOGFILE = FROMMB(m_dwLogSize);

	// logging level
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_EVENTLOGLEVEL, true);
	m_spConfig->m_dwEVENTLOGLEVEL = m_dwLevel;

	DWORD	dwAttrFlags = ATTR_FLAGS_NONE;
	dwAttrFlags |= (ACS_SCAF_ENABLERSVPMESSAGELOGGING | ACS_SCAF_RSVPLOGFILESLOCATION);
	dwAttrFlags |= (ACS_SCAF_MAXNOOFLOGFILES | ACS_SCAF_MAXSIZEOFRSVPLOGFILE | ACS_SCAF_EVENTLOGLEVEL);

	AddFlags(dwAttrFlags);	// prepare flags for saving

	return CACSPage::OnApply();
}

void CPgLogging::OnCheckEnableloggin() 
{
	SetModified();
	EnableEverything();
	// TODO: Add your control notification handler code here
	
}

void CPgLogging::OnSelchangeCombolevel() 
{
	// TODO: Add your control notification handler code here
	SetModified();
}

void CPgLogging::OnChangeEditLogDirectory() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

void CPgLogging::OnChangeEditLogLogfiles() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

void CPgLogging::OnChangeEditLogMaxfilesize() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

BOOL CPgLogging::OnInitDialog() 
{
	// Enable Logging
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_ENABLERSVPMESSAGELOGGING))
		m_bEnableLogging = (m_spConfig->m_bENABLERSVPMESSAGELOGGING != 0);

	// logging directory
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_RSVPLOGFILESLOCATION))
		m_strLogDir = m_spConfig->m_strRSVPLOGFILESLOCATION;

	// number of log files
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_MAXNOOFLOGFILES))
	{
		m_dwNumFiles = m_spConfig->m_dwMAXNOOFLOGFILES;
	}

	// max file size
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_MAXSIZEOFRSVPLOGFILE))
	{
		m_dwLogSize = TOMB(m_spConfig->m_dwMAXSIZEOFRSVPLOGFILE);
	}

	// logging level
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_EVENTLOGLEVEL))
	{
		m_dwLevel = m_spConfig->m_dwEVENTLOGLEVEL;
	}


	CString*	pStr = NULL;
	// direction
	// fillin the list box
	try{

		pStr = new CString();
		pStr->LoadString(IDS_LOGLEVEL_0);
		m_aLevelStrings.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_LOGLEVEL_1);
		m_aLevelStrings.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_LOGLEVEL_2);
		m_aLevelStrings.Add(pStr);

/* 366523	1	I0706 rajeshm	a-leeb	ACS: Snap in should list 3 event levels rather than four

		pStr = new CString();
		pStr->LoadString(IDS_LOGLEVEL_3);
		m_aLevelStrings.Add(pStr);
*/
		m_pLevel = new CStrBox<CComboBox>(this, IDC_COMBOLEVEL, m_aLevelStrings);
		m_pLevel->Fill();

		m_pLevel->Select(m_dwLevel);

	}catch(CMemoryException&){};

	CACSPage::OnInitDialog();
	
	EnableEverything();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgLogging::EnableEverything()
{
	CButton*	pButton = (CButton*)GetDlgItem(IDC_CHECK_ENABLELOGGIN);
	int			nCheck = pButton->GetCheck();
	
	GetDlgItem(IDC_EDIT_LOG_DIRECTORY)->EnableWindow(nCheck);
	GetDlgItem(IDC_EDIT_LOG_LOGFILES)->EnableWindow(nCheck);
	GetDlgItem(IDC_EDIT_LOG_MAXFILESIZE)->EnableWindow(nCheck);
	
	GetDlgItem(IDC_COMBOLEVEL)->EnableWindow(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pglog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pglog.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_LOGGING_H__C0DCD9EB_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
#define AFX_LOGGING_H__C0DCD9EB_64FE_11D1_855B_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// logging.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// Accounting dialog

class CPgAccounting : public CACSPage
{
	DECLARE_DYNCREATE(CPgAccounting)

// Construction
	CPgAccounting();
public:
	CPgAccounting(CACSSubnetConfig* pConfig);
	~CPgAccounting();

// Dialog Data
	//{{AFX_DATA(CPgAccounting)
	enum { IDD = IDD_ACCOUNTING };
	BOOL	m_bEnableAccounting;
	CString	m_strLogDir;
	DWORD	m_dwNumFiles;
	DWORD	m_dwLogSize;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgAccounting)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
	void	EnableEverything();
protected:
	// Generated message map functions
	//{{AFX_MSG(CPgAccounting)
	afx_msg void OnCheckEnableAccounting();
	afx_msg void OnChangeEditLogDirectory();
	afx_msg void OnChangeEditLogLogfiles();
	afx_msg void OnChangeEditLogMaxfilesize();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void	DataInit();
	CComPtr<CACSSubnetConfig>		m_spConfig;
};

/////////////////////////////////////////////////////////////////////////////
// CPgLogging dialog

class CPgLogging : public CACSPage
{
	DECLARE_DYNCREATE(CPgLogging)

// Construction
	CPgLogging();
public:
	CPgLogging(CACSSubnetConfig* pConfig);
	~CPgLogging();

// Dialog Data
	//{{AFX_DATA(CPgLogging)
	enum { IDD = IDD_LOGGING };
	BOOL	m_bEnableLogging;
	int		m_dwLevel;
	CString	m_strLogDir;
	DWORD	m_dwNumFiles;
	DWORD	m_dwLogSize;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgLogging)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
	void	EnableEverything();
protected:
	// Generated message map functions
	//{{AFX_MSG(CPgLogging)
	afx_msg void OnCheckEnableloggin();
	afx_msg void OnSelchangeCombolevel();
	afx_msg void OnChangeEditLogDirectory();
	afx_msg void OnChangeEditLogLogfiles();
	afx_msg void OnChangeEditLogMaxfilesize();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void	DataInit();
	CComPtr<CACSSubnetConfig>		m_spConfig;
	CStrArray						m_aLevelStrings;
	CStrBox<CComboBox>*				m_pLevel;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGGING_H__C0DCD9EB_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pgpolicy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pgpolicy.cpp
//
//--------------------------------------------------------------------------

// pgpolicy.cpp : implementation file
//

#include "stdafx.h"
#include <objsel.h>
#include "helper.h"
#include "acsadmin.h"
#include "acsdata.h"
#include "acshand.h"
#include "pgpolicy.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void CACSPolicyPageManager::SetPolicyData(CACSPolicyElement* pPolicy, CACSPolicyHandle* pHandle)
{
	ASSERT(pPolicy && pHandle);
	m_spPolicy = pPolicy;
	m_pHandle = pHandle;
	if(pHandle)
		pHandle->AddRef();
}
CACSPolicyPageManager::~CACSPolicyPageManager()
{
	m_spPolicy.Release();
	if(m_pHandle)
		m_pHandle->Release();
}

BOOL CACSPolicyPageManager::OnApply()
{
	if(CPageManager::OnApply())
	{
		HRESULT	hr = S_OK;
		ASSERT((CACSPolicyElement*)m_spPolicy);

		// check if data is valid ... // to verify cross page data
		UserPolicyType	PolicyType = UNDEFINED;

		if ((m_nBranchFlag & BRANCH_FLAG_GLOBAL) != 0)	// may need to alter the text
		{
			ASSERT(m_pGeneralPage);
		
			if(m_pGeneralPage->IfAnyAuth())
			{
				PolicyType = GLOBAL_ANY_AUTHENTICATED;
			}
			else if (m_pGeneralPage->IfAnyUnauth())
			{
				PolicyType = GLOBAL_ANY_UNAUTHENTICATED;
			}
		}

		
		UINT ErrorId = m_spPolicy->PreSaveVerifyData(GetFlags(), PolicyType);

		if(ErrorId != 0)	// not valid
		{
			// Display error message,
			AfxMessageBox(ErrorId);
			
			// Return FALSE
			return FALSE;
		}
		
		// persist the data into DS

		hr = m_spPolicy->Save(GetFlags());

		{
			CWaitCursor		wc;

			Sleep(1000);
		}

		// modifies the state info on UI ( may change states of other conflicted ones
		m_spPolicy->InvalidateConflictState();
		
		// inform container to check conflict

		if FAILED(hr)
			ReportError(hr, IDS_ERR_SAVESUBNETCONFIG, NULL);
		else
		{
			AfxMessageBox(IDS_WRN_POLICY_EFFECTIVE_FROM_NEXT_RSVP);
			m_pHandle->UpdateStrings();
			m_pHandle->OnPropertyPageApply();
			// Advise super class that the apply button has been activated.
			CPageManager::OnApply();
		}
		ClearFlags();

		MMCNotify();
		
		return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CPgPolicyGeneral property page

IMPLEMENT_DYNCREATE(CPgPolicyGeneral, CACSPage)

/////////////////////////////////////////////////////////////////////////////
// CPgTraffic message handlers
enum DirectionIndex
{
	DIRECTION_SEND,
	DIRECTION_RECEIVE,
	DIRECTION_SENDRECEIVE
};

enum ServiceTypeIndex
{
	SERVICETYPE_ALL,
	SERVICETYPE_CONTROLLEDLOAD,
	SERVICETYPE_GUARANTEEDSERVICE,
	SERVICETYPE_DISABLED
};

enum IdentityTypeIndex
{
	IDENTITYTYPE_DEFAULT,
	IDENTITYTYPE_UNKNOWN,
	IDENTITYTYPE_USER,
	IDENTITYTYPE_OU
};

CPgPolicyGeneral::CPgPolicyGeneral() : CACSPage(CPgPolicyGeneral::IDD)
{
	DataInit();
}

CPgPolicyGeneral::CPgPolicyGeneral(CACSPolicyElement* pData) : CACSPage(CPgPolicyGeneral::IDD)
{
	ASSERT(pData);
	m_spData = pData;
	DataInit();
}


void CPgPolicyGeneral::DataInit()
{
	//{{AFX_DATA_INIT(CPgPolicyGeneral)
	m_strOU = _T("");
	m_strUser = _T("");
	m_nIdentityChoice = -1;
	//}}AFX_DATA_INIT
}

CPgPolicyGeneral::~CPgPolicyGeneral()
{
	delete	m_pDirection;
	delete	m_pServiceType;
	m_aServiceTypes.DeleteAll();
	m_aDirections.DeleteAll();
}

void CPgPolicyGeneral::DoDataExchange(CDataExchange* pDX)
{
	CACSPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgPolicyGeneral)
	DDX_Control(pDX, IDC_POLICY_GEN_BROWSEUSER, m_buttonUser);
	DDX_Control(pDX, IDC_POLICY_GEN_BROWSEOU, m_buttonOU);
	DDX_Control(pDX, IDC_POLICY_GEN_EDIT_USER, m_editUser);
	DDX_Control(pDX, IDC_POLICY_GEN_EDIT_OU, m_editOU);
	DDX_Text(pDX, IDC_POLICY_GEN_EDIT_OU, m_strOU);
	DDX_Text(pDX, IDC_POLICY_GEN_EDIT_USER, m_strUser);
	DDX_Radio(pDX, IDC_POLICY_GEN_DEFAULTUSER, m_nIdentityChoice);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgPolicyGeneral, CACSPage)
	//{{AFX_MSG_MAP(CPgPolicyGeneral)
	ON_BN_CLICKED(IDC_POLICY_GEN_BROWSEOU, OnBrowseOU)
	ON_BN_CLICKED(IDC_POLICY_GEN_BROWSEUSER, OnBrowseUser)
	ON_BN_CLICKED(IDC_POLICY_GEN_UNKNOWNUSER, OnUnknownuser)
	ON_BN_CLICKED(IDC_POLICY_GEN_DEFAULTUSER, OnDefaultuser)
	ON_BN_CLICKED(IDC_POLICY_GEN_RADIO_OU, OnRadioOu)
	ON_BN_CLICKED(IDC_POLICY_GEN_RADIO_USER, OnRadioUser)
	ON_EN_CHANGE(IDC_POLICY_GEN_EDIT_OU, OnChangeEditOu)
	ON_EN_CHANGE(IDC_POLICY_GEN_EDIT_USER, OnChangeEditUser)
	ON_CBN_SELCHANGE(IDC_POLICY_GEN_SERVICELEVEL, OnSelchangeServicelevel)
	ON_CBN_SELCHANGE(IDC_POLICY_GEN_DIRECTION, OnSelchangeDirection)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgPolicyGeneral message handlers
void CPgPolicyGeneral::OnBrowseOU()
{
    TCHAR szRoot[MAX_PATH] = TEXT("");
    TCHAR szBuffer[MAX_PATH] = TEXT("");;
    DSBROWSEINFO dsbi = { 0 };
    CString	strTemp;

    strTemp.LoadString(IDS_BROWSEOU_TITLE);
    // initialize the structure (its already NULL)

    dsbi.cbStruct = sizeof(dsbi);
    dsbi.hwndOwner = GetSafeHwnd();
    dsbi.pszTitle = strTemp;
    dsbi.pszRoot = NULL;
    dsbi.pszPath = szBuffer;
    dsbi.cchPath = sizeof(szBuffer) / sizeof(TCHAR);
    dsbi.dwFlags = 0;
    dsbi.pfnCallback = NULL;
    dsbi.lParam = (LPARAM)0;

	dsbi.dwFlags |= DSBI_ENTIREDIRECTORY;


    UINT idResult = DsBrowseForContainer(&dsbi);

    if ( idResult != IDOK )
		return;

	m_strOU = szBuffer;
	IADs*	pADs = NULL;
	VARIANT	v;
	VariantInit(&v);
	if(m_strOU.GetLength())
	{
		m_strOU = _T("");
		CHECK_HR(ADsOpenObject(szBuffer, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_USE_SIGNING | ADS_USE_SEALING, IID_IADs, (void**)&pADs));
		ASSERT(pADs);
		CHECK_HR(pADs->Get(L"distinguishedName", &v));
		m_strOU = V_BSTR(&v);
		m_editOU.SetWindowText(m_strOU);
	}
		
L_ERR:	
	VariantClear(&v);
	if(pADs)
	{
		pADs->Release();
		pADs = NULL;
	}
}




//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, BOOL fMultiselect)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN | DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = (fMultiselect) ? DSOP_FLAG_MULTISELECT : 0;

    LPCTSTR	attrs[] = {_T("distinguishedName")};

    InitInfo.cAttributesToFetch = 1;
    InitInfo.apwzAttributeNames = attrs;


    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);

    if (FAILED(hr))
    {
        ULONG i;

        for (i = 0; i < SCOPE_INIT_COUNT; i++)
        {
            if (FAILED(InitInfo.aDsScopeInfos[i].hr))
            {
                printf("Initialization failed because of scope %u\n", i);
            }
        }
    }

    return hr;
}

#define BREAK_ON_FAIL_HRESULT(hr)       \
    if (FAILED(hr)) { printf("line %u err 0x%x\n", __LINE__, hr); break; }


void CPgPolicyGeneral::OnBrowseUser()
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if(FAILED(hr))
		return ;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = InitObjectPickerForGroups(pDsObjectPicker, FALSE);

        //
        // Invoke the modal dialog.
        //
        hr = pDsObjectPicker->InvokeDialog(this->GetSafeHwnd(), &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            Trace0("User canceled object picker dialog\n");
            fSuccess = FALSE;
            break;
        }

        //
        // Process the user's selections
        //
        Assert(pdo);
		//        ProcessSelectedObjects(pdo);
        {
        	UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);


		    STGMEDIUM stgmedium =
		    {
		        TYMED_HGLOBAL,
		        NULL,
        		NULL
		    };

		    FORMATETC formatetc =
		    {
		        (unsigned short)g_cfDsObjectPicker,
		        NULL,
		        DVASPECT_CONTENT,
		        -1,
		        TYMED_HGLOBAL
		    };

		    bool fGotStgMedium = false;

		    do
		    {
        		hr = pdo->GetData(&formatetc, &stgmedium);
		        BREAK_ON_FAIL_HRESULT(hr);

        		fGotStgMedium = true;

		        PDS_SELECTION_LIST pDsSelList =
        		    (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

				// inteprete the selection
				ASSERT(pDsSelList->cItems == 1);

				ASSERT(pDsSelList->aDsSelection[0].pvarFetchedAttributes[0].vt == VT_BSTR);

				if(pDsSelList->aDsSelection[0].pvarFetchedAttributes[0].vt == VT_BSTR)
				{
					m_strUser = V_BSTR(&(pDsSelList->aDsSelection[0].pvarFetchedAttributes[0]));
					// update the edit field of the property page

					m_editUser.SetWindowText(m_strUser);
	
		
			    }
			    else
			    {
					CString	str;
					str.LoadString(IDS_ERR_DN);
					str.Format(str, pDsSelList->aDsSelection[0].pwzName);
					AfxMessageBox(str, MB_OK);
			    }
		        GlobalUnlock(stgmedium.hGlobal);
		    } while (0);

		    if (fGotStgMedium)
		    {
		        ReleaseStgMedium(&stgmedium);
		    }
        }

        pdo->Release();
        pdo = NULL;

    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }

    CoUninitialize();

    if (FAILED(hr))
        fSuccess = FALSE;

    return;
}

void CPgPolicyGeneral::OnUnknownuser()
{
	// TODO: Add your control notification handler code here
	SetModified();
	EnableIdentityCtrls(1);
	
}

void CPgPolicyGeneral::OnDefaultuser()
{
	// TODO: Add your control notification handler code here
	SetModified();
	EnableIdentityCtrls(0);
	
}

void CPgPolicyGeneral::OnRadioOu()
{
	// TODO: Add your control notification handler code here
	SetModified();
	EnableIdentityCtrls(3);
	
}

void CPgPolicyGeneral::OnRadioUser()
{
	// TODO: Add your control notification handler code here
	SetModified();
	EnableIdentityCtrls(2);
	
}

void CPgPolicyGeneral::OnChangeEditOu()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgPolicyGeneral::OnChangeEditUser()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();	
}

void CPgPolicyGeneral::OnSelchangeServicelevel()
{
	// TODO: Add your control notification handler code here
	SetModified();
}

void CPgPolicyGeneral::OnSelchangeDirection()
{
	// TODO: Add your control notification handler code here
	SetModified();
	
}

BOOL CPgPolicyGeneral::OnKillActive( )
{
	// GURANTEEDSERVICE and SEND can not be a policy
	if(m_pServiceType->GetSelected() == SERVICETYPE_GUARANTEEDSERVICE && m_pDirection->GetSelected() == DIRECTION_SEND)
	{
		AfxMessageBox(IDS_NO_POLICY_FOR_SEND_AND_GUARANTEE, MB_OK, 0);
		return FALSE;
	}

	return CACSPage::OnKillActive();
}

BOOL CPgPolicyGeneral::OnApply()
{
	if(!GetModified())	return TRUE;

	// direction
	if(m_pDirection)
	{
		switch(m_pDirection->GetSelected())
		{
		case	DIRECTION_SEND:
			m_spData->m_dwDirection = ACS_DIRECTION_SEND;
			break;
		case	DIRECTION_RECEIVE:
			m_spData->m_dwDirection = ACS_DIRECTION_RECEIVE;
			break;
		case	DIRECTION_SENDRECEIVE:
			m_spData->m_dwDirection = ACS_DIRECTION_BOTH;
			break;
		default:
			// no valid value should come here
			ASSERT(0);
		}
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_DIRECTION, true);
	}
	else	// save what ever is loaded
	{
		if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_DIRECTION))
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_DIRECTION, true);
		else
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_DIRECTION, false);
	}

	// service type
	if(m_pServiceType)
	{
		switch(m_pServiceType->GetSelected())
		{
		case	SERVICETYPE_DISABLED:
			m_spData->m_dwServiceType = ACS_SERVICETYPE_DISABLED;
			break;
		case	SERVICETYPE_CONTROLLEDLOAD:
			m_spData->m_dwServiceType = ACS_SERVICETYPE_CONTROLLEDLOAD;
			break;
		case	SERVICETYPE_GUARANTEEDSERVICE:
			m_spData->m_dwServiceType = ACS_SERVICETYPE_GUARANTEEDSERVICE;
			break;
		case	SERVICETYPE_ALL:
			m_spData->m_dwServiceType = ACS_SERVICETYPE_ALL;
			break;
		default:
			// no valid value should come here
			ASSERT(0);
		}
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_SERVICETYPE, true);
	}
	else	// save what ever is loaded
	{
		if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_SERVICETYPE))
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_SERVICETYPE, true);
		else
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_SERVICETYPE, false);
	}

	// GURANTEEDSERVICE and SEND can not be a policy
	if(m_spData->m_dwServiceType == ACS_SERVICETYPE_GUARANTEEDSERVICE && m_spData->m_dwDirection == ACS_DIRECTION_SEND)
	{
		AfxMessageBox(IDS_NO_POLICY_FOR_SEND_AND_GUARANTEE, MB_OK, 0);
		return FALSE;

	}

	// ACS_SERVICETYPE_CONTROLLEDLOAD and SEND can not be a policy
	if(m_spData->m_dwServiceType == ACS_SERVICETYPE_CONTROLLEDLOAD && m_spData->m_dwDirection == ACS_DIRECTION_SEND)
	{
		AfxMessageBox(IDS_NO_POLICY_FOR_SEND_AND_CONTROLLEDLOAD, MB_OK, 0);
		return FALSE;

	}

	// code for identity

	CString*	pIdentity;
	if(m_spData->m_strArrayIdentityName.GetSize())
	{
		pIdentity = m_spData->m_strArrayIdentityName[(INT_PTR)0];
	}
	else
	{
		pIdentity = new CString();
		m_spData->m_strArrayIdentityName.Add(pIdentity);
	}
		
	switch(m_nIdentityChoice)
	{
	case	0:	// default user
		*pIdentity = ACS_IDENTITY_DEFAULT;
		break;
	case	1:	// unknown user
		*pIdentity = ACS_IDENTITY_UNKNOWN;
		break;
	case	2:	// user
		*pIdentity = ACS_IDENTITY_USER;
		if(m_strUser.GetLength() == 0)
		{
			GotoDlgCtrl(&m_editUser);
			AfxMessageBox(IDS_ERR_USER_DN);
			return FALSE;
		}

		*pIdentity += m_strUser;
		break;
	case	3:	// OU
		*pIdentity = ACS_IDENTITY_OU;
		if(m_strOU.GetLength() == 0)
		{
			GotoDlgCtrl(&m_editOU);
			AfxMessageBox(IDS_ERR_OU_DN);
			return FALSE;
		}

		*pIdentity+= m_strOU;
		break;
	
	default:
		return FALSE;

	}

	m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_IDENTITYNAME, true);

	// check if conflict with other policies in the folder
	if(m_spData->IsConflictInContainer())
	{
		if(AfxMessageBox(IDS_CONFLICTPOLICY, MB_OKCANCEL, 0) != IDOK)
		{
			return FALSE;
		}
	}

	DWORD	dwAttrFlags = 0;
	dwAttrFlags |= (ACS_PAF_IDENTITYNAME | ACS_PAF_SERVICETYPE | ACS_PAF_DIRECTION);

	AddFlags(dwAttrFlags);	// prepare flags for saving



	return CACSPage::OnApply();
}

BOOL CPgPolicyGeneral::OnInitDialog()
{
	CString*	pStr = NULL;
	bool		bModified = false;
	// direction
	// fillin the list box
	try{

		pStr = new CString();
		pStr->LoadString(IDS_SEND);
		m_aDirections.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_RECEIVE);
		m_aDirections.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_SENDRECEIVE);
		m_aDirections.Add(pStr);

		m_pDirection = new CStrBox<CComboBox>(this, IDC_POLICY_GEN_DIRECTION, m_aDirections);
		m_pDirection->Fill();

		// decide which one to select
		if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_DIRECTION))
		{
			int	current = -1;
			switch(m_spData->m_dwDirection)
			{
			case	ACS_DIRECTION_SEND:
				current = DIRECTION_SEND;
				break;
			case	ACS_DIRECTION_RECEIVE:
				current = DIRECTION_RECEIVE;
				break;
			case	ACS_DIRECTION_BOTH:
				current = DIRECTION_SENDRECEIVE;
				break;
			default:
				// invalid value
				ASSERT(0);
				// message box
			}

			m_pDirection->Select(current);
		}
		else
		{
			m_pDirection->Select(DIRECTION_SENDRECEIVE);	// default
		}
	}catch(CMemoryException&){};

	// service type
	try{
		pStr = new CString();
		pStr->LoadString(IDS_ALL);
		m_aServiceTypes.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_CONTROLLEDLOAD);
		m_aServiceTypes.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_GUARANTEEDSERVICE);
		m_aServiceTypes.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_SERVICETYPE_DISABLED);
		m_aServiceTypes.Add(pStr);

		m_pServiceType = new CStrBox<CComboBox>(this, IDC_POLICY_GEN_SERVICELEVEL, m_aServiceTypes);
		m_pServiceType->Fill();

		// decide which one to select
		if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_SERVICETYPE))
		{
			int	current = -1;
			switch(m_spData->m_dwServiceType)
			{
			case	ACS_SERVICETYPE_DISABLED:
				current = SERVICETYPE_DISABLED;
				break;
			case	ACS_SERVICETYPE_CONTROLLEDLOAD:
				current = SERVICETYPE_CONTROLLEDLOAD;
				break;
			case	ACS_SERVICETYPE_GUARANTEEDSERVICE:
				current = SERVICETYPE_GUARANTEEDSERVICE;
				break;
			case	ACS_SERVICETYPE_ALL:
				current = SERVICETYPE_ALL;
				break;
			default:
				// invalid value
				ASSERT(0);
				// message box
			}

			m_pServiceType->Select(current);
		}
		else
		{
			m_pServiceType->Select(SERVICETYPE_ALL);	// default
		}
	}catch(CMemoryException&){};

	// Identity -- user / ou
	CString	strIdentity;
	m_nIdentityChoice = m_spData->GetIdentityType(strIdentity);

	switch(m_nIdentityChoice){
	case	0:	// default
	case	1:	// unknown
		break;
	case	2:	// user
		m_strUser = strIdentity;
		break;
	case	3:	// OU
		m_strOU = strIdentity;
		break;
	default:
		ASSERT(0);
		break;
	}
	
	
	CACSPage::OnInitDialog();

	if(bModified)
		SetModified();

	EnableIdentityCtrls(m_nIdentityChoice);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void	CPgPolicyGeneral::EnableIdentityCtrls(int nChoice)
{

	switch(nChoice){
	case	0:	// default
	case	1:	// unknown
		m_editUser.EnableWindow(FALSE);
		m_editOU.EnableWindow(FALSE);
		m_buttonUser.EnableWindow(FALSE);
		m_buttonOU.EnableWindow(FALSE);
		break;
	case	2:	// user
		m_editUser.EnableWindow(TRUE);
		m_buttonUser.EnableWindow(TRUE);
		m_editOU.EnableWindow(FALSE);
		m_buttonOU.EnableWindow(FALSE);
		break;
	case	3:	// OU
		m_editUser.EnableWindow(FALSE);
		m_buttonUser.EnableWindow(FALSE);
		m_editOU.EnableWindow(TRUE);
		m_buttonOU.EnableWindow(TRUE);
		break;
	default:
		m_editUser.EnableWindow(FALSE);
		m_buttonUser.EnableWindow(FALSE);
		m_editOU.EnableWindow(FALSE);
		m_buttonOU.EnableWindow(FALSE);
	}

}

/////////////////////////////////////////////////////////////////////////////
// CPgPolicyFlow property page

IMPLEMENT_DYNCREATE(CPgPolicyFlow, CACSPage)

CPgPolicyFlow::CPgPolicyFlow(CACSPolicyElement* pData) : CACSPage(CPgPolicyFlow::IDD)
{
	ASSERT(pData);
	m_spData = pData;
	DataInit();
}

CPgPolicyFlow::CPgPolicyFlow() : CACSPage(CPgPolicyFlow::IDD)
{
}

void CPgPolicyFlow::DataInit()
{
	//{{AFX_DATA_INIT(CPgPolicyFlow)
	m_uDuration = 0;
	m_uPeakRate = 0;
	m_nDataRateChoice = -1;
	m_nDurationChoice = -1;
	m_nPeakRateChoice = -1;
	m_uDataRate = 0;
	//}}AFX_DATA_INIT

	m_nBranchFlag = 0;
	m_pGeneralPage = NULL;
}

CPgPolicyFlow::~CPgPolicyFlow()
{
	m_nBranchFlag = 0;
	m_pGeneralPage = NULL;
}

void CPgPolicyFlow::DoDataExchange(CDataExchange* pDX)
{
	CACSPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgPolicyFlow)
	
	DDX_Control(pDX, IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT, m_editPeakRate);
	DDX_Control(pDX, IDC_POLICY_FLOW_DURATION_EDIT_LIMIT, m_editDuration);
	DDX_Control(pDX, IDC_POLICY_FLOW_DATARATE_EDIT_LIMIT, m_editDataRate);
	
	DDX_Radio(pDX, IDC_POLICY_FLOW_DATARATE_RES, m_nDataRateChoice);
	DDX_Radio(pDX, IDC_POLICY_FLOW_DURATION_RES, m_nDurationChoice);
	DDX_Radio(pDX, IDC_POLICY_FLOW_PEAKDATARATE_RES, m_nPeakRateChoice);
	
	DDX_Text(pDX, IDC_POLICY_FLOW_DURATION_EDIT_LIMIT, m_uDuration);
	if (m_nDurationChoice == 2)
		DDV_MinMaxUInt(pDX, m_uDuration, 0, 71582780);
	
	DDX_Text(pDX, IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT, m_uPeakRate);
	if (m_nPeakRateChoice ==2 )
		DDV_MinMaxUInt(pDX, m_uPeakRate, 0, 4194300);
	
	DDX_Text(pDX, IDC_POLICY_FLOW_DATARATE_EDIT_LIMIT, m_uDataRate);
	if (m_nDataRateChoice == 2)
		DDV_MinMaxUInt(pDX, m_uDataRate, 0, 4194300);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgPolicyFlow, CACSPage)
	//{{AFX_MSG_MAP(CPgPolicyFlow)
	ON_BN_CLICKED(IDC_POLICY_FLOW_DATARATE_DEF, OnPolicyFlowDatarateDef)
	ON_EN_CHANGE(IDC_POLICY_FLOW_DATARATE_EDIT_LIMIT, OnChangePolicyFlowDatarateEditLimit)
	ON_BN_CLICKED(IDC_POLICY_FLOW_DATARATE_RADIO_LIMIT, OnPolicyFlowDatarateRadioLimit)
	ON_BN_CLICKED(IDC_POLICY_FLOW_DATARATE_RES, OnPolicyFlowDatarateRes)
	ON_BN_CLICKED(IDC_POLICY_FLOW_DURATION_DEF, OnPolicyFlowDurationDef)
	ON_EN_CHANGE(IDC_POLICY_FLOW_DURATION_EDIT_LIMIT, OnChangePolicyFlowDurationEditLimit)
	ON_BN_CLICKED(IDC_POLICY_FLOW_DURATION_RADIO_LIMIT, OnPolicyFlowDurationRadioLimit)
	ON_BN_CLICKED(IDC_POLICY_FLOW_DURATION_RES, OnPolicyFlowDurationRes)
	ON_BN_CLICKED(IDC_POLICY_FLOW_PEAKDATARATE_DEF, OnPolicyFlowPeakdatarateDef)
	ON_EN_CHANGE(IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT, OnChangePolicyFlowPeakdatarateEditLimit)
	ON_BN_CLICKED(IDC_POLICY_FLOW_PEAKDATARATE_RADIO_LIMIT, OnPolicyFlowPeakdatarateRadioLimit)
	ON_BN_CLICKED(IDC_POLICY_FLOW_PEAKDATARATE_RES, OnPolicyFlowPeakdatarateRes)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgPolicyFlow message handlers

BOOL CPgPolicyFlow::OnInitDialog()
{
	//------------------
	// per flow
	
	// data rate
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_PF_TOKENRATE))
	{
		if IS_LARGE_UNLIMIT(m_spData->m_ddPFTokenRate)
			m_nDataRateChoice = 0;
		else	
		{
			m_nDataRateChoice = 2;	// numbered limit
			m_uDataRate = TOKBS(m_spData->m_ddPFTokenRate.LowPart);
		}
	}
	else
		m_nDataRateChoice = 1;	// default

	// Peak data rate
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_PF_PEAKBANDWIDTH))
	{
		if IS_LARGE_UNLIMIT(m_spData->m_ddPFPeakBandWidth)
			m_nPeakRateChoice = 0;
		else	
		{
			m_nPeakRateChoice = 2;	// numbered limit
			m_uPeakRate = TOKBS(m_spData->m_ddPFPeakBandWidth.LowPart);
		}
	}
	else
		m_nPeakRateChoice = 1;	// default

	// duration
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_PF_DURATION))
	{
		if(m_spData->m_dwPFDuration == UNLIMIT)
			m_nDurationChoice = 0;
		else
		{
			m_nDurationChoice = 2;
			m_uDuration = SEC2MIN(m_spData->m_dwPFDuration);
		}
	}
	else
		m_nDurationChoice = 1;

	// ==== data exchange is done within here
	CACSPage::OnInitDialog();

	if(m_nDataRateChoice != 2)
		m_editDataRate.EnableWindow(FALSE);

	if(m_nPeakRateChoice != 2)
		m_editPeakRate.EnableWindow(FALSE);

	if(m_nDurationChoice != 2)
		m_editDuration.EnableWindow(FALSE);

	GetDlgItem(IDC_POLICY_FLOW_DATARATE_DEF)->GetWindowText(m_strDataRateDefault);
	GetDlgItem(IDC_POLICY_FLOW_PEAKDATARATE_DEF)->GetWindowText(m_strPeakRateDefault);
	GetDlgItem(IDC_POLICY_FLOW_DURATION_DEF)->GetWindowText(m_strDurationDefault);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CPgPolicyFlow::OnSetActive( )
{
	// change default button strings based on choice of user
	CString	datarateStr = m_strDataRateDefault;
	CString	peakrateStr = m_strPeakRateDefault;
	CString	durationStr = m_strDurationDefault;

	if ((m_nBranchFlag & BRANCH_FLAG_GLOBAL) != 0)	// may need to alter the text
	{
		CString	tmp;

		ASSERT(m_pGeneralPage);
		
		if(m_pGeneralPage->IfAnyAuth())
		{
			tmp.LoadString(IDS_A_DEF_DATARATE_SUF);
			datarateStr += tmp;
			tmp.LoadString(IDS_A_DEF_PEAKRATE_SUF);
			peakrateStr += tmp;
			tmp.LoadString(IDS_A_DEF_DURATION_SUF);
			durationStr += tmp;
		}
		else if (m_pGeneralPage->IfAnyUnauth())
		{
			tmp.LoadString(IDS_U_DEF_DATARATE_SUF);
			datarateStr += tmp;
			tmp.LoadString(IDS_U_DEF_PEAKRATE_SUF);
			peakrateStr += tmp;
			tmp.LoadString(IDS_U_DEF_DURATION_SUF);
			durationStr += tmp;
		}
	}
	
	// test if the policy is for any authentication/unauthenticaion policy in enterprise level
	GetDlgItem(IDC_POLICY_FLOW_DATARATE_DEF)->SetWindowText(datarateStr);
	GetDlgItem(IDC_POLICY_FLOW_PEAKDATARATE_DEF)->SetWindowText(peakrateStr);
	GetDlgItem(IDC_POLICY_FLOW_DURATION_DEF)->SetWindowText(durationStr);
	
	return CACSPage::OnSetActive();
}


BOOL CPgPolicyFlow::OnKillActive( )
{
	UINT	cId = 0;
	UINT	mId = 0;

	if(!UpdateData())
		return FALSE;

	// Peak Rate should be >= data rate
	if(m_nPeakRateChoice ==2 && m_nDataRateChoice == 2 && m_uDataRate > m_uPeakRate)
	{
		cId = IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT;
		mId = IDS_ERR_PEAKRATE_LESS_RATE;
	}

	if ((m_nBranchFlag & BRANCH_FLAG_GLOBAL) != 0)	// need to check again default value
	{
		CString	tmp;

		ASSERT(m_pGeneralPage);
		
		if(m_pGeneralPage->IfAnyAuth())
		{
			// Peak Rate should be >= data rate
			if(m_nPeakRateChoice ==2 && m_nDataRateChoice == 1 && DEFAULT_AA_DATARATE > FROMKBS(m_uPeakRate))
			{
				cId = IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT;
				mId = IDS_ERR_PEAKRATE_LESS_RATE;
			}
		}
		else if (m_pGeneralPage->IfAnyUnauth())
		{
			// Peak Rate should be >= data rate
			if(m_nPeakRateChoice ==2 && m_nDataRateChoice == 1 && DEFAULT_AU_DATARATE > FROMKBS(m_uPeakRate))
			{
				cId = IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT;
				mId = IDS_ERR_PEAKRATE_LESS_RATE;
			}
		}
	}
	// if there is anything wrong
	if(cId)
	{
		CWnd*	pWnd = GetDlgItem(cId);

		ASSERT(pWnd);
		GotoDlgCtrl( pWnd );

		AfxMessageBox(mId);

		return FALSE;
	}

	// check if any is set to Zero
	if(m_nDataRateChoice == 2 && m_uDataRate == 0)	// date rate
	{
		cId = IDC_POLICY_FLOW_DATARATE_EDIT_LIMIT;
		mId = IDS_WRN_ZERO_POLICY_DATA;
	} 
	else if(m_nPeakRateChoice ==2 && m_uPeakRate == 0)	// peak data rate
	{
		cId = IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT;
		mId = IDS_WRN_ZERO_POLICY_DATA;
	} 
	else if(m_nDurationChoice == 2 && m_uDuration == 0) // duration
	{
		cId = IDC_POLICY_FLOW_DURATION_EDIT_LIMIT;
		mId = IDS_WRN_ZERO_POLICY_DATA;
	}
	
	if(cId)
	{
	
		if(IDNO == AfxMessageBox(mId, MB_YESNO))
		{
			CWnd*	pWnd = GetDlgItem(cId);

			ASSERT(pWnd);
			GotoDlgCtrl( pWnd );
		
			return FALSE;
		}
	}
	
	return CACSPage::OnKillActive();

}

// radio buttons here, 0 -- no limit (resouce limit ) , 1 -- default to general level, 2 -- user limit
//
BOOL CPgPolicyFlow::OnApply()
{
	CString*	pStr = NULL;
	// check if the values input on the page is valid
	UINT	cId = 0;
	UINT	mId = 0;

	if(!GetModified())	return TRUE;

	// Peak Rate should be >= data rate
	if(m_nPeakRateChoice ==2 && m_nDataRateChoice == 2 && m_uDataRate > m_uPeakRate)
	{
		cId = IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT;
		mId = IDS_ERR_PEAKRATE_LESS_RATE;
	}

	// if there is anything wrong
	if(cId)
	{
		CWnd*	pWnd = GetDlgItem(cId);

		ASSERT(pWnd);
		GotoDlgCtrl( pWnd );

		AfxMessageBox(mId);

		return FALSE;
	}

	
	//------------------
	// per flow
	
	// data rate
	switch(m_nDataRateChoice){
	case	2:	// limit
		m_spData->m_ddPFTokenRate.LowPart = FROMKBS(m_uDataRate);
		m_spData->m_ddPFTokenRate.HighPart = 0;
		break;
	case	1:	// default
		break;
	case	0:	// unlimit
		SET_LARGE_UNLIMIT(m_spData->m_ddPFTokenRate);
		break;
	default:
		ASSERT(0);
	};

	m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_PF_TOKENRATE, (m_nDataRateChoice != 1));

	// Peak data rate
	switch(m_nPeakRateChoice){
	case	2:	// limit
		m_spData->m_ddPFPeakBandWidth.LowPart = FROMKBS(m_uPeakRate);
		m_spData->m_ddPFPeakBandWidth.HighPart = 0;
		break;
	case	1:	// default
		break;
	case	0:	// unlimit
		SET_LARGE_UNLIMIT(m_spData->m_ddPFPeakBandWidth);
		break;
	default:
		ASSERT(0);
	};

	m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_PF_PEAKBANDWIDTH, (m_nPeakRateChoice != 1));

	// duration
	switch(m_nDurationChoice){
	case	2:	// limit
		m_spData->m_dwPFDuration = MIN2SEC(m_uDuration);
		break;
	case	1:	// default
		break;
	case	0:	// unlimit
		m_spData->m_dwPFDuration = UNLIMIT;
		break;
	default:
		ASSERT(0);
	};

	m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_PF_DURATION, (m_nDurationChoice != 1));

	DWORD	dwAttrFlags = 0;
	dwAttrFlags |= (ACS_PAF_PF_TOKENRATE | ACS_PAF_PF_PEAKBANDWIDTH | ACS_PAF_PF_DURATION);

	AddFlags(dwAttrFlags);	// prepare flags for saving

	return CACSPage::OnApply();
}

void CPgPolicyFlow::OnPolicyFlowDatarateDef()
{
	SetModified();	
	m_editDataRate.EnableWindow(FALSE);
}

void CPgPolicyFlow::OnChangePolicyFlowDatarateEditLimit()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgPolicyFlow::OnPolicyFlowDatarateRadioLimit()
{
	// TODO: Add your control notification handler code here
	SetModified();
	m_editDataRate.EnableWindow(TRUE);
}

void CPgPolicyFlow::OnPolicyFlowDatarateRes()
{
	// TODO: Add your control notification handler code here
	SetModified();
	m_editDataRate.EnableWindow(FALSE);
}

void CPgPolicyFlow::OnPolicyFlowDurationDef()
{
	// TODO: Add your control notification handler code here
	m_editDuration.EnableWindow(FALSE);

	SetModified();
	
}

void CPgPolicyFlow::OnChangePolicyFlowDurationEditLimit()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgPolicyFlow::OnPolicyFlowDurationRadioLimit()
{
	// TODO: Add your control notification handler code here
	m_editDuration.EnableWindow(TRUE);
	SetModified();
	
}

void CPgPolicyFlow::OnPolicyFlowDurationRes()
{
	// TODO: Add your control notification handler code here
	m_editDuration.EnableWindow(FALSE);
	
	SetModified();
}

void CPgPolicyFlow::OnPolicyFlowPeakdatarateDef()
{
	// TODO: Add your control notification handler code here
	m_editPeakRate.EnableWindow(FALSE);
	
	SetModified();
}

void CPgPolicyFlow::OnChangePolicyFlowPeakdatarateEditLimit()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgPolicyFlow::OnPolicyFlowPeakdatarateRadioLimit()
{
	// TODO: Add your control notification handler code here
	m_editPeakRate.EnableWindow(TRUE);
	
	SetModified();
}

void CPgPolicyFlow::OnPolicyFlowPeakdatarateRes()
{
	// TODO: Add your control notification handler code here

	m_editPeakRate.EnableWindow(FALSE);
	SetModified();
}


/////////////////////////////////////////////////////////////////////////////
// CPgPolicyAggregate dialog

CPgPolicyAggregate::CPgPolicyAggregate(CACSPolicyElement* pData) : CACSPage(CPgPolicyAggregate::IDD)
{
	ASSERT(pData);
	m_spData = pData;
	DataInit();
}


CPgPolicyAggregate::CPgPolicyAggregate()
	: CACSPage(CPgPolicyAggregate::IDD)
{
	DataInit();
}

void CPgPolicyAggregate::DataInit()
{
	//{{AFX_DATA_INIT(CPgPolicyAggregate)
	m_nDataRateChoice = -1;
	m_nFlowsChoice = -1;
	m_nPeakRateChoice = -1;
	m_uDataRate = 0;
	m_uFlows = 0;
	m_uPeakRate = 0;
	//}}AFX_DATA_INIT

	
	m_nBranchFlag = 0;
	m_pGeneralPage = NULL;

}


void CPgPolicyAggregate::DoDataExchange(CDataExchange* pDX)
{
	CACSPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgPolicyAggregate)
	DDX_Control(pDX, IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT, m_editPeakRate);
	DDX_Control(pDX, IDC_POLICY_AGGR_FLOWS_EDIT_LIMIT, m_editFlows);
	DDX_Control(pDX, IDC_POLICY_AGGR_DATARATE_EDIT_LIMIT, m_editDataRate);
	DDX_Radio(pDX, IDC_POLICY_AGGR_DATARATE_RES, m_nDataRateChoice);
	DDX_Radio(pDX, IDC_POLICY_AGGR_FLOWS_RES, m_nFlowsChoice);
	DDX_Radio(pDX, IDC_POLICY_AGGR_PEAKDATARATE_RES, m_nPeakRateChoice);

	DDX_Text(pDX, IDC_POLICY_AGGR_DATARATE_EDIT_LIMIT, m_uDataRate);
	if(m_nDataRateChoice == 2)
		DDV_MinMaxUInt(pDX, m_uDataRate, 0, DWORD_LIMIT/1024);

	
	DDX_Text(pDX, IDC_POLICY_AGGR_FLOWS_EDIT_LIMIT, m_uFlows);
	if(m_nFlowsChoice == 2)
		DDV_MinMaxUInt(pDX, m_uFlows, 0, DWORD_LIMIT);
		
	DDX_Text(pDX, IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT, m_uPeakRate);
	if(m_nPeakRateChoice == 2)
	DDV_MinMaxUInt(pDX, m_uPeakRate, 0, DWORD_LIMIT/1024);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgPolicyAggregate, CACSPage)
	//{{AFX_MSG_MAP(CPgPolicyAggregate)
	ON_BN_CLICKED(IDC_POLICY_AGGR_DATARATE_DEF, OnPolicyAggrDatarateDef)
	ON_EN_CHANGE(IDC_POLICY_AGGR_DATARATE_EDIT_LIMIT, OnChangePolicyAggrDatarateEditLimit)
	ON_BN_CLICKED(IDC_POLICY_AGGR_DATARATE_RADIO_LIMIT, OnPolicyAggrDatarateRadioLimit)
	ON_BN_CLICKED(IDC_POLICY_AGGR_DATARATE_RES, OnPolicyAggrDatarateRes)
	ON_BN_CLICKED(IDC_POLICY_AGGR_FLOWS_DEF, OnPolicyAggrFlowsDef)
	ON_EN_CHANGE(IDC_POLICY_AGGR_FLOWS_EDIT_LIMIT, OnChangePolicyAggrFlowsEditLimit)
	ON_BN_CLICKED(IDC_POLICY_AGGR_FLOWS_RES, OnPolicyAggrFlowsRes)
	ON_BN_CLICKED(IDC_POLICY_AGGR_PEAKDATARATE_DEF, OnPolicyAggrPeakdatarateDef)
	ON_EN_CHANGE(IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT, OnChangePolicyAggrPeakdatarateEditLimit)
	ON_BN_CLICKED(IDC_POLICY_AGGR_PEAKDATARATE_RADIO_LIMIT, OnPolicyAggrPeakdatarateRadioLimit)
	ON_BN_CLICKED(IDC_POLICY_AGGR_PEAKDATARATE_RES, OnPolicyAggrPeakdatarateRes)
	ON_BN_CLICKED(IDC_POLICY_AGGR_FLOWS_RADIO_LIMIT, OnPolicyAggrFlowsRadioLimit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgPolicyAggregate message handlers
/////////////////////////////////////////////////////////////////////////////
// CPgPolicyFlow message handlers

BOOL CPgPolicyAggregate::OnInitDialog()
{
	//------------------
	// Total
	
	// data rate
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_TT_TOKENRATE))
	{
		if IS_LARGE_UNLIMIT(m_spData->m_ddTTTokenRate)
			m_nDataRateChoice = 0;
		else	
		{
			m_nDataRateChoice = 2;	// numbered limit
			m_uDataRate = TOKBS(m_spData->m_ddTTTokenRate.LowPart);
		}
	}
	else
		m_nDataRateChoice = 1;	// default

	// Peak data rate
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_TT_PEAKBANDWIDTH))
	{
		if IS_LARGE_UNLIMIT(m_spData->m_ddTTPeakBandWidth)
			m_nPeakRateChoice = 0;
		else	
		{
			m_nPeakRateChoice = 2;	// numbered limit
			m_uPeakRate = TOKBS(m_spData->m_ddTTPeakBandWidth.LowPart);
		}
	}
	else
		m_nPeakRateChoice = 1;	// default

	// flows
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_TT_FLOWS))
	{
		if(m_spData->m_dwTTFlows == UNLIMIT)
			m_nFlowsChoice = 0;
		else
		{
			m_nFlowsChoice = 2;
			m_uFlows = m_spData->m_dwTTFlows;
		}
	}
	else
		m_nFlowsChoice = 1;

	CACSPage::OnInitDialog();
	

	if(m_nDataRateChoice != 2)
		m_editDataRate.EnableWindow(FALSE);
		
	if(m_nPeakRateChoice != 2)
		m_editPeakRate.EnableWindow(FALSE);

	if(m_nFlowsChoice != 2)
		m_editFlows.EnableWindow(FALSE);

	GetDlgItem(IDC_POLICY_AGGR_DATARATE_DEF)->GetWindowText(m_strDataRateDefault);
	GetDlgItem(IDC_POLICY_AGGR_PEAKDATARATE_DEF)->GetWindowText(m_strPeakRateDefault);
	GetDlgItem(IDC_POLICY_AGGR_FLOWS_DEF)->GetWindowText(m_strFlowsDefault);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CPgPolicyAggregate::OnSetActive( )
{
	// change default button strings based on choice of user
	CString	datarateStr = m_strDataRateDefault;
	CString	peakrateStr = m_strPeakRateDefault;
	CString	flowsStr = m_strFlowsDefault;

	if ((m_nBranchFlag & BRANCH_FLAG_GLOBAL) != 0)	// may need to alter the text
	{
		CString	tmp;
		ASSERT(m_pGeneralPage);

		if(m_pGeneralPage->IfAnyAuth())
		{
			tmp.LoadString(IDS_A_DEF_DATARATE_SUF);
			datarateStr += tmp;
			tmp.LoadString(IDS_A_DEF_PEAKRATE_SUF);
			peakrateStr += tmp;
			tmp.LoadString(IDS_A_DEF_FLOWS_SUF);
			flowsStr += tmp;
		}
		else if (m_pGeneralPage->IfAnyUnauth())
		{
			tmp.LoadString(IDS_U_DEF_DATARATE_SUF);
			datarateStr += tmp;
			tmp.LoadString(IDS_U_DEF_PEAKRATE_SUF);
			peakrateStr += tmp;
			tmp.LoadString(IDS_U_DEF_FLOWS_SUF);
			flowsStr += tmp;
		}
	}
	
	// test if the policy is for any authentication/unauthenticaion policy in enterprise level
	GetDlgItem(IDC_POLICY_AGGR_DATARATE_DEF)->SetWindowText(datarateStr);
	GetDlgItem(IDC_POLICY_AGGR_PEAKDATARATE_DEF)->SetWindowText(peakrateStr);
	GetDlgItem(IDC_POLICY_AGGR_FLOWS_DEF)->SetWindowText(flowsStr);

	
	return CACSPage::OnSetActive();
}



BOOL CPgPolicyAggregate::OnKillActive( )
{
	// check if the values input on the page is valid
	UINT	cId = 0;
	UINT	mId = 0;

	if(!UpdateData(TRUE)) return FALSE;
	if(!GetModified())	return TRUE;

	// Peak Rate should be >= data rate
	if(m_nPeakRateChoice ==2 && m_nDataRateChoice == 2 && m_uDataRate > m_uPeakRate)
	{
		cId = IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT;
		mId = IDS_ERR_TOTALPEAK_LESS_TOTALRATE;
	}

	if ((m_nBranchFlag & BRANCH_FLAG_GLOBAL) != 0)	// need to check again default value
	{
		CString	tmp;

		ASSERT(m_pGeneralPage);
		
		if(m_pGeneralPage->IfAnyAuth())
		{
			// Peak Rate should be >= data rate
			if(m_nPeakRateChoice ==2 && m_nDataRateChoice == 1 && DEFAULT_AA_DATARATE > FROMKBS(m_uPeakRate))
			{
				cId = IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT;
				mId = IDS_ERR_TOTALPEAK_LESS_TOTALRATE;
			}
		}
		else if (m_pGeneralPage->IfAnyUnauth())
		{
			// Peak Rate should be >= data rate
			if(m_nPeakRateChoice ==2 && m_nDataRateChoice == 1 && DEFAULT_AU_DATARATE > FROMKBS(m_uPeakRate))
			{
				cId = IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT;
				mId = IDS_ERR_TOTALPEAK_LESS_TOTALRATE;
			}
		}
	}
	// if there is anything wrong
	if(cId)
	{
		CWnd*	pWnd = GetDlgItem(cId);

		ASSERT(pWnd);
		GotoDlgCtrl( pWnd );

		AfxMessageBox(mId);
		return FALSE;
	}


	// check if any is set to Zero
	if(m_nDataRateChoice == 2 && m_uDataRate == 0)	// date rate
	{
		cId = IDC_POLICY_AGGR_DATARATE_EDIT_LIMIT;
		mId = IDS_WRN_ZERO_POLICY_DATA;
	} 
	else if(m_nPeakRateChoice ==2 && m_uPeakRate == 0)	// peak data rate
	{
		cId = IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT;
		mId = IDS_WRN_ZERO_POLICY_DATA;
	} 
	else if(m_nFlowsChoice == 2 && m_uFlows == 0) // duration
	{
		cId = IDC_POLICY_AGGR_FLOWS_EDIT_LIMIT;
		mId = IDS_WRN_ZERO_POLICY_DATA;
	}
	
	if(cId)
	{
	
		if(IDNO == AfxMessageBox(mId, MB_YESNO))
		{
			CWnd*	pWnd = GetDlgItem(cId);

			ASSERT(pWnd);
			GotoDlgCtrl( pWnd );
		
			return FALSE;
		}
	}
	

	return CACSPage::OnKillActive();

}

// radio buttons here, 0 -- no limit (resouce limit ) , 1 -- default to general level, 2 -- user limit
//
BOOL CPgPolicyAggregate::OnApply()
{
	CString*	pStr = NULL;
	// check if the values input on the page is valid
	UINT	cId = 0;
	UINT	mId = 0;

	if(!GetModified())	return TRUE;

	// Peak Rate should be >= data rate
	if(m_nPeakRateChoice ==2 && m_nDataRateChoice == 2 && m_uDataRate > m_uPeakRate)
	{
		cId = IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT;
		mId = IDS_ERR_TOTALPEAK_LESS_TOTALRATE;
	}

	// if there is anything wrong
	if(cId)
	{
		CWnd*	pWnd = GetDlgItem(cId);

		ASSERT(pWnd);
		GotoDlgCtrl( pWnd );

		AfxMessageBox(mId);
		return FALSE;
	}

	
	//------------------
	// per flow
	
	// data rate
	switch(m_nDataRateChoice){
	case	2:	// limit
		m_spData->m_ddTTTokenRate.LowPart = FROMKBS(m_uDataRate);
		m_spData->m_ddTTTokenRate.HighPart = 0;
		break;
	case	1:	// default
		break;
	case	0:	// unlimit
		SET_LARGE_UNLIMIT(m_spData->m_ddTTTokenRate);
		break;
	default:
		ASSERT(0);
	};

	m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_TT_TOKENRATE, (m_nDataRateChoice != 1));

	// Peak data rate
	switch(m_nPeakRateChoice){
	case	2:	// limit
		m_spData->m_ddTTPeakBandWidth.LowPart = FROMKBS(m_uPeakRate);
		m_spData->m_ddTTPeakBandWidth.HighPart = 0;
		break;
	case	1:	// default
		break;
	case	0:	// unlimit
		SET_LARGE_UNLIMIT(m_spData->m_ddTTPeakBandWidth);
		break;
	default:
		ASSERT(0);
	};

	m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_TT_PEAKBANDWIDTH, (m_nPeakRateChoice != 1));

	// duration
	switch(m_nFlowsChoice){
	case	2:	// limit
		m_spData->m_dwTTFlows = m_uFlows;
		break;
	case	1:	// default
		break;
	case	0:	// unlimit
		m_spData->m_dwTTFlows = UNLIMIT;
		break;
	default:
		ASSERT(0);
	};

	m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_TT_FLOWS, (m_nFlowsChoice != 1));

	DWORD	dwAttrFlags = 0;
	dwAttrFlags |= (ACS_PAF_TT_TOKENRATE | ACS_PAF_TT_PEAKBANDWIDTH | ACS_PAF_TT_FLOWS);

	AddFlags(dwAttrFlags);	// prepare flags for saving


	return CACSPage::OnApply();
}



void CPgPolicyAggregate::OnPolicyAggrDatarateDef()
{
	// TODO: Add your control notification handler code here
	SetModified();	
	m_editDataRate.EnableWindow(FALSE);
	
}

void CPgPolicyAggregate::OnChangePolicyAggrDatarateEditLimit()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();	
	
}

void CPgPolicyAggregate::OnPolicyAggrDatarateRadioLimit()
{
	// TODO: Add your control notification handler code here
	
	SetModified();	
	m_editDataRate.EnableWindow(TRUE);
}

void CPgPolicyAggregate::OnPolicyAggrDatarateRes()
{
	// TODO: Add your control notification handler code here
	SetModified();	
	m_editDataRate.EnableWindow(FALSE);
	
}

void CPgPolicyAggregate::OnPolicyAggrFlowsDef()
{
	// TODO: Add your control notification handler code here
	SetModified();	
	m_editFlows.EnableWindow(FALSE);
	
}

void CPgPolicyAggregate::OnChangePolicyAggrFlowsEditLimit()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();	
	
}

void CPgPolicyAggregate::OnPolicyAggrFlowsRes()
{
	// TODO: Add your control notification handler code here
	SetModified();	
	m_editFlows.EnableWindow(FALSE);
	
}

void CPgPolicyAggregate::OnPolicyAggrFlowsRadioLimit()
{
	// TODO: Add your control notification handler code here
	SetModified();	
	m_editFlows.EnableWindow(TRUE);
	
}

void CPgPolicyAggregate::OnPolicyAggrPeakdatarateDef()
{
	// TODO: Add your control notification handler code here
	SetModified();	
	m_editPeakRate.EnableWindow(FALSE);
	
}

void CPgPolicyAggregate::OnChangePolicyAggrPeakdatarateEditLimit()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();	
	
}

void CPgPolicyAggregate::OnPolicyAggrPeakdatarateRadioLimit()
{
	// TODO: Add your control notification handler code here
	SetModified();	
	m_editPeakRate.EnableWindow(TRUE);
	
}

void CPgPolicyAggregate::OnPolicyAggrPeakdatarateRes()
{
	// TODO: Add your control notification handler code here
	SetModified();	
	m_editPeakRate.EnableWindow(FALSE);
	
}


void CPgPolicyFlow::OnKillFocus(CWnd* pNewWnd)
{
	CACSPage::OnKillFocus(pNewWnd);
	
	// TODO: Add your message handler code here
	
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pgsbm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       pgsbm.cpp
//
//--------------------------------------------------------------------------

// PgSBM.cpp : implementation file
//

#include "stdafx.h"
#include "acsadmin.h"
#include "PgSBM.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPgSBM property page

IMPLEMENT_DYNCREATE(CPgSBM, CACSPage)

CPgSBM::CPgSBM(CACSSubnetConfig* pConfig) : CACSPage(CPgSBM::IDD)
{
	ASSERT(pConfig);
	m_spConfig = pConfig;
	DataInit();
}

void CPgSBM::DataInit()
{
	//{{AFX_DATA_INIT(CPgSBM)
	m_dwAliveInterval = ACS_SCADEF_DSBMREFRESH;
	m_dwB4Reserve = ACS_SCADEF_NONRESERVEDTXLIMIT;
	m_dwDeadInterval = ACS_SCADEF_DSBMDEADTIME;
	m_dwElection = ACS_SCADEF_DSBMPRIORITY;
	m_dwTimeout = ACS_SCADEF_CACHETIMEOUT;
	//}}AFX_DATA_INIT
}

CPgSBM::CPgSBM() : CACSPage(CPgSBM::IDD)
{
	DataInit();
}

CPgSBM::~CPgSBM()
{
}

void CPgSBM::DoDataExchange(CDataExchange* pDX)
{
	CACSPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgSBM)
	DDX_Control(pDX, IDC_SPIN1, m_SpinElection);
	DDX_Text(pDX, IDC_EDIT_ALIVEINTERVAL, m_dwAliveInterval);
	DDV_MinMaxDWord(pDX, m_dwAliveInterval, ACS_SCAV_MIN_DSBMREFRESH, ACS_SCAV_MAX_DSBMREFRESH);
	DDX_Text(pDX, IDC_EDIT_B4RESERVE, m_dwB4Reserve);
	DDV_MinMaxDWord(pDX, m_dwB4Reserve, 0, DWORD_LIMIT);
	DDX_Text(pDX, IDC_EDIT_DEADINTERVAL, m_dwDeadInterval);
	DDV_MinMaxDWord(pDX, m_dwDeadInterval, ACS_SCAV_MIN_DSBMDEADTIME, ACS_SCAV_MAX_DSBMDEADTIME);
	DDX_Text(pDX, IDC_EDIT_ELECTION, m_dwElection);
	DDV_MinMaxDWord(pDX, m_dwElection, ACS_SCAV_MIN_DSBMPRIORITY, ACS_SCAV_MAX_DSBMPRIORITY);
	DDX_Text(pDX, IDC_EDIT_TIMEOUT, m_dwTimeout);
	DDV_MinMaxDWord(pDX, m_dwTimeout, ACS_SCAV_MIN_CACHETIMEOUT, ACS_SCAV_MAX_CACHETIMEOUT);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgSBM, CACSPage)
	//{{AFX_MSG_MAP(CPgSBM)
	ON_EN_CHANGE(IDC_EDIT_ALIVEINTERVAL, OnChangeEditAliveinterval)
	ON_EN_CHANGE(IDC_EDIT_B4RESERVE, OnChangeEditB4reserve)
	ON_EN_CHANGE(IDC_EDIT_DEADINTERVAL, OnChangeEditDeadinterval)
	ON_EN_CHANGE(IDC_EDIT_ELECTION, OnChangeEditElection)
	ON_EN_CHANGE(IDC_EDIT_TIMEOUT, OnChangeEditTimeout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgSBM message handlers

BOOL CPgSBM::OnApply() 
{
	// Election
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_DSBMPRIORITY, true);
	m_spConfig->m_dwDSBMPRIORITY = m_dwElection;

	// alive interval
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_DSBMREFRESH, true);
	m_spConfig->m_dwDSBMREFRESH = m_dwAliveInterval;

	// dead interval
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_DSBMDEADTIME, true);
	m_spConfig->m_dwDSBMDEADTIME = m_dwDeadInterval;

	// cache timeout
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_CACHETIMEOUT, true);
	m_spConfig->m_dwCACHETIMEOUT = MIN2SEC(m_dwTimeout);

	// B4 reservation
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_NONRESERVEDTXLIMIT, true);
	m_spConfig->m_ddNONRESERVEDTXLIMIT.LowPart = FROMKBS(m_dwB4Reserve);
	m_spConfig->m_ddNONRESERVEDTXLIMIT.HighPart = 0;

	DWORD	dwAttrFlags = ATTR_FLAGS_NONE;

	dwAttrFlags |= (ACS_SCAF_DSBMPRIORITY | ACS_SCAF_DSBMREFRESH);
	dwAttrFlags |= (ACS_SCAF_DSBMDEADTIME | ACS_SCAF_CACHETIMEOUT | ACS_SCAF_NONRESERVEDTXLIMIT);

	AddFlags(dwAttrFlags);	// prepare flags for saving
/*
	m_spConfig->Save(dwAttrFlags);
*/	
	return CACSPage::OnApply();
}

BOOL CPgSBM::OnInitDialog() 
{
	// Election Priority
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_DSBMPRIORITY))
		m_dwElection = m_spConfig->m_dwDSBMPRIORITY;

	// Alive interval
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_DSBMREFRESH))
		m_dwAliveInterval = m_spConfig->m_dwDSBMREFRESH;

	// Dead interval
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_DSBMDEADTIME))
		m_dwDeadInterval = m_spConfig->m_dwDSBMDEADTIME;

	// Cache timeout
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_CACHETIMEOUT))
		m_dwTimeout = SEC2MIN(m_spConfig->m_dwCACHETIMEOUT);

	// B4 reservation
	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_NONRESERVEDTXLIMIT))
		m_dwB4Reserve = TOKBS(m_spConfig->m_ddNONRESERVEDTXLIMIT.LowPart);

	CACSPage::OnInitDialog();
	
	m_SpinElection.SetRange(ACS_SCAV_MIN_DSBMPRIORITY, ACS_SCAV_MAX_DSBMPRIORITY);

	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgSBM::OnChangeEditAliveinterval() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

void CPgSBM::OnChangeEditB4reserve() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

void CPgSBM::OnChangeEditDeadinterval() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

void CPgSBM::OnChangeEditElection() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}

void CPgSBM::OnChangeEditTimeout() 
{
	SetModified();
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pgpolicy.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pgpolicy.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_PGPOLICY_H__52F8CCA2_3092_11D2_9792_00C04FC31FD3__INCLUDED_)
#define AFX_PGPOLICY_H__52F8CCA2_3092_11D2_9792_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// pgpolicy.h : header file
//

class CACSPolicyHandle;
class CPgPolicyGeneral;

class CACSPolicyPageManager : public CPageManager
{
public:
	void SetPolicyData(CACSPolicyElement* pPolicy, CACSPolicyHandle* pHandle);

	virtual ~CACSPolicyPageManager();
	
	virtual BOOL	OnApply();
	virtual void 	OnCancel( )
	{
		m_pHandle->OnPropertyPageCancel();
		CPageManager::OnCancel();
	};
	virtual void 	OnOK( )
	{
		m_pHandle->OnPropertyPageOK();
		CPageManager::OnOK();

		// if this is a new created policy, need to change the name field in result pane.
		if(m_spPolicy->m_bUseName_NewPolicy)
		{
			m_spPolicy->m_bUseName_NewPolicy = FALSE;
			MMCNotify();
		}
	};

	void	SetGeneralPage(CPgPolicyGeneral* pPage) { m_pGeneralPage = pPage;};
	void	SetBranchFlag(UINT flag) { m_nBranchFlag = flag; };
	
protected:	
	CComPtr<CACSPolicyElement>		m_spPolicy;
	CACSPolicyHandle*				m_pHandle;
	CPgPolicyGeneral*				m_pGeneralPage;
	UINT				m_nBranchFlag;	// glocal defined as 0x0001
};


/////////////////////////////////////////////////////////////////////////////
// CPgPolicyGeneral dialog

class CPgPolicyGeneral : public CACSPage
{
	DECLARE_DYNCREATE(CPgPolicyGeneral)

// Construction
public:
	CPgPolicyGeneral();
	CPgPolicyGeneral(CACSPolicyElement* pData);
	~CPgPolicyGeneral();

	void	EnableIdentityCtrls(int nChoice);

// Dialog Data
	//{{AFX_DATA(CPgPolicyGeneral)
	enum { IDD = IDD_POLICY_GEN };
	CButton	m_buttonUser;
	CButton	m_buttonOU;
	CEdit	m_editUser;
	CEdit	m_editOU;
	CString	m_strOU;
	CString	m_strUser;
	int		m_nIdentityChoice;
	//}}AFX_DATA

	BOOL	IfAnyAuth() { return (m_nIdentityChoice == 0);};
	BOOL	IfAnyUnauth() { return (m_nIdentityChoice == 1);};

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgPolicyGeneral)
	public:
	virtual BOOL OnKillActive( );
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void	DataInit();

	// Generated message map functions
	//{{AFX_MSG(CPgPolicyGeneral)
	afx_msg void OnBrowseOU();
	afx_msg void OnBrowseUser();
	afx_msg void OnUnknownuser();
	afx_msg void OnDefaultuser();
	afx_msg void OnRadioOu();
	afx_msg void OnRadioUser();
	afx_msg void OnChangeEditOu();
	afx_msg void OnChangeEditUser();
	afx_msg void OnSelchangeServicelevel();
	afx_msg void OnSelchangeDirection();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// data members
	CComPtr<CACSPolicyElement>		m_spData;
	CStrBox<CComboBox>*				m_pDirection;
	CStrBox<CComboBox>*				m_pServiceType;
	CStrArray						m_aDirections;
	CStrArray						m_aServiceTypes;

};

/////////////////////////////////////////////////////////////////////////////
// CPgPolicyFlow dialog

class CPgPolicyFlow : public CACSPage
{
	DECLARE_DYNCREATE(CPgPolicyFlow)

// Construction
public:
	CPgPolicyFlow();
	CPgPolicyFlow(CACSPolicyElement* pData);
	~CPgPolicyFlow();

// Dialog Data
	//{{AFX_DATA(CPgPolicyFlow)
	enum { IDD = IDD_POLICY_FLOW };
	CEdit	m_editPeakRate;
	CEdit	m_editDuration;
	CEdit	m_editDataRate;
	UINT	m_uDuration;
	UINT	m_uPeakRate;
	int		m_nDataRateChoice;
	int		m_nDurationChoice;
	int		m_nPeakRateChoice;
	UINT	m_uDataRate;
	//}}AFX_DATA


	// 
	UINT				m_nBranchFlag;	// glocal defined as 0x0001
	CPgPolicyGeneral*	m_pGeneralPage;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgPolicyFlow)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnKillActive( );
	virtual BOOL OnSetActive( );

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void	DataInit();

	// Generated message map functions
	//{{AFX_MSG(CPgPolicyFlow)
	virtual BOOL OnInitDialog();
	afx_msg void OnPolicyFlowDatarateDef();
	afx_msg void OnChangePolicyFlowDatarateEditLimit();
	afx_msg void OnPolicyFlowDatarateRadioLimit();
	afx_msg void OnPolicyFlowDatarateRes();
	afx_msg void OnPolicyFlowDurationDef();
	afx_msg void OnChangePolicyFlowDurationEditLimit();
	afx_msg void OnPolicyFlowDurationRadioLimit();
	afx_msg void OnPolicyFlowDurationRes();
	afx_msg void OnPolicyFlowPeakdatarateDef();
	afx_msg void OnChangePolicyFlowPeakdatarateEditLimit();
	afx_msg void OnPolicyFlowPeakdatarateRadioLimit();
	afx_msg void OnPolicyFlowPeakdatarateRes();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// data members
	CComPtr<CACSPolicyElement>		m_spData;

	CString	m_strDataRateDefault;
	CString	m_strPeakRateDefault;
	CString	m_strDurationDefault;

};
/////////////////////////////////////////////////////////////////////////////
// CPgPolicyAggregate dialog

class CPgPolicyAggregate : public CACSPage
{
// Construction
public:
	CPgPolicyAggregate();   // standard constructor
	CPgPolicyAggregate(CACSPolicyElement* pData);

// Dialog Data
	//{{AFX_DATA(CPgPolicyAggregate)
	enum { IDD = IDD_POLICY_AGGR };
	CEdit	m_editPeakRate;
	CEdit	m_editFlows;
	CEdit	m_editDataRate;
	int		m_nDataRateChoice;
	int		m_nFlowsChoice;
	int		m_nPeakRateChoice;
	UINT	m_uDataRate;
	UINT	m_uFlows;
	UINT	m_uPeakRate;
	//}}AFX_DATA


	//
	UINT				m_nBranchFlag;	// glocal defined as 0x0001
	CPgPolicyGeneral*	m_pGeneralPage;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPgPolicyAggregate)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnKillActive( );
	virtual BOOL OnSetActive( );
	
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void	DataInit();

	// Generated message map functions
	//{{AFX_MSG(CPgPolicyAggregate)
	virtual BOOL OnInitDialog();
	afx_msg void OnPolicyAggrDatarateDef();
	afx_msg void OnChangePolicyAggrDatarateEditLimit();
	afx_msg void OnPolicyAggrDatarateRadioLimit();
	afx_msg void OnPolicyAggrDatarateRes();
	afx_msg void OnPolicyAggrFlowsDef();
	afx_msg void OnChangePolicyAggrFlowsEditLimit();
	afx_msg void OnPolicyAggrFlowsRes();
	afx_msg void OnPolicyAggrPeakdatarateDef();
	afx_msg void OnChangePolicyAggrPeakdatarateEditLimit();
	afx_msg void OnPolicyAggrPeakdatarateRadioLimit();
	afx_msg void OnPolicyAggrPeakdatarateRes();
	afx_msg void OnPolicyAggrFlowsRadioLimit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// data members
	CComPtr<CACSPolicyElement>		m_spData;
	
	CString	m_strDataRateDefault;
	CString	m_strPeakRateDefault;
	CString	m_strFlowsDefault;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PGPOLICY_H__52F8CCA2_3092_11D2_9792_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by acsadmin.rc
//
#define IDS_ERR_SUBNET_NAME             1
#define IDS_PROJNAME                    100
#define IDS_ABOUT_DESCRIPTION           101
#define IDR_ACSUSER                     102
#define IDS_ABOUT_PROVIDER              102
#define IDR_ACSSNAP                     103
#define IDS_ABOUT_VERSION               103
#define IDR_ACSSNAPEXT                  104
#define IDS_SNAPIN_DESC                 104
#define IDR_ACSSNAPABOUT                105
#define IDS_EXTENSION_CREATE_NEW_SAMPLE 105
#define IDS_EXTENSION_TASK_SAMPLE       106
#define IDS_NAME                        114
#define IDS_TYPE                        115
#define IDS_DESC                        116
#define IDS_GLOBAL                      117
#define IDS_SUBNETCONFIGS               118
#define IDS_USERS                       119
#define IDS_PROFILES                    120
#define IDS_COL_POLICY_APPLIES_TO       121
#define IDS_COL_POLICY_DIRECTION        122
#define IDS_SUBNET_CONFIG               123
#define IDS_ACSROOT                     124
#define IDS_COL_POLICY_SERVICE_LEVEL    125
#define IDS_COL_SUBNET_NAME             126
#define IDS_COL_SUBNET_DESC             127
#define IDS_ANYAUTHENTICATEDUSER        128
#define IDS_SERVICETYPE_DISABLED        129
#define IDS_NEWSUBNET                   131
#define IDS_DELETEPOLICY                132
#define IDS_DELETESUBNET                133
#define IDS_NEWPOLICY                   134
#define IDS_CONFIRM_DELETE              135
#define IDS_COL_POLICY_DATARATE         136
#define IDS_COL_POLICY_PEAKRATE         137
#define IDS_PROPERTIES                  138
#define IDS_COL_SUBNET_DATARATE         139
#define IDS_DEFAULT                     140
#define IDS_SEND                        141
#define IDS_RECEIVE                     142
#define IDS_SENDRECEIVE                 143
#define IDS_BESTEFFORT                  144
#define IDS_CONTROLLEDLOAD              145
#define IDS_GUARANTEEDSERVICE           146
#define IDS_DELETE_ITEM                 147
#define IDS_DELETE_CONTAINER            148
#define IDS_DELETE_MULTIITEMS           149
#define IDS_MIN_CHARS                   150
#define IDS_FAIL_SAVE_TRAFFIC           151
#define IDS_FAIL_SAVE_LOGGING           152
#define IDS_FAIL_SAVE_ADVANCED          153
#define IDS_ERR_ERRORCODE               154
#define IDS_ERR_TITLE                   155
#define IDS_ERR_SAVESUBNETCONFIG        156
#define IDS_ERR_ROOTNODE                157
#define IDS_ERR_COMPONENT               158
#define IDS_ERR_NODEEXPAND              159
#define IDS_ERR_NODEDELETE              160
#define IDS_ERR_COMMAND                 161
#define IDS_ERR_PROPERTYPAGE            162
#define IDS_ERR_NODERENAME              163
#define IDS_ALL                         164
#define IDS_ERR_SAVEPOLICY              165
#define IDS_ERR_LOADPOLICY              166
#define IDS_ERR_LOADSUBNETCONFIG        167
#define IDS_ROOT_TASK_LAUNCH_ACS        168
#define IDS_ROOT_TASK_LAUNCH_ACS_HELP   169
#define IDS_ERR_PEAKRATE_LESS_RATE      170
#define IDS_ERR_TOTALRATE_LESS_PEAKRATE 171
#define IDS_ERR_TOTALRATE_LESS_RATE     172
#define IDS_ERR_TOTALPEAK_LESS_PEAK     173
#define IDS_ERR_TOTALPEAK_LESS_TOTALRATE 174
#define IDS_NONAUTHENTICATEDUSER        176
#define IDS_CONFLICTPOLICY              177
#define IDS_COL_SUBNET_PEAKRATE         178
#define IDS_FAILED_INSTALL_ACSSERVER    179
#define IDS_FAILED_UNINSTALL_ACSSERVER  180
#define IDS_NEWACSPOLICY                181
#define IDS_NO_POLICY_FOR_SEND_AND_GUARANTEE 182
#define IDS_ERR_DNSNAME                 183
#define IDS_ERR_DN                      184
#define IDS_RESOURCELIMITED             185
#define IDS_LOGLEVEL_0                  186
#define IDS_LOGLEVEL_1                  187
#define IDS_LOGLEVEL_2                  188
#define IDS_LOGLEVEL_3                  189
#define IDS_ERR_NOT_SERVER              190
#define IDS_WRN_ZERO_POLICY_DATA        191
#define IDS_DEFAULT_POLICIES_ADDED      192
#define IDS_A_DEF_DATARATE_SUF          193
#define IDS_A_DEF_PEAKRATE_SUF          194
#define IDS_A_DEF_FLOWS_SUF             195
#define IDS_A_DEF_DURATION_SUF          196
#define IDS_U_DEF_DATARATE_SUF          197
#define IDS_U_DEF_PEAKRATE_SUF          198
#define IDS_U_DEF_FLOWS_SUF             199
#define IDS_U_DEF_DURATION_SUF          200
#define IDI_ACS_SNAPIN                  201
#define IDC_EDIT_ELECTION               204
#define IDC_EDIT_ALIVEINTERVAL          205
#define IDC_EDIT_DEADINTERVAL           206
#define IDD_GENERAL                     208
#define IDD_LOGGING                     209
#define IDD_SBM                         210
#define IDC_EDIT_TIMEOUT                210
#define IDC_EDIT_B4RESERVE              211
#define IDD_NEWSUBNET                   215
#define IDB_LARGEACS                    216
#define IDD_ACCOUNTING                  216
#define IDB_SMALLACS                    217
#define IDB_SMALLACSOPEN                218
#define IDB_16X16                       219
#define IDB_32X32                       220
#define IDD_USERPASSWD                  224
#define IDC_EDIT_GEN_DESC               226
#define IDC_CHECK_ENABLEACS             227
#define IDC_EDIT_GEN_PF_DATARATE        228
#define IDC_EDIT_GEN_PF_PEAKRATE        229
#define IDC_EDIT_GEN_TT_DATARATE        231
#define IDC_EDIT_GEN_TT_PEAKRATE        232
#define IDC_CHECK_ENABLELOGGIN          233
#define IDC_EDIT_LOG_DIRECTORY          234
#define IDC_EDIT_LOG_LOGFILES           235
#define IDC_COMBOLEVEL                  236
#define IDC_EDITSUBNETNAME              247
#define IDC_SPIN1                       251
#define IDC_EDIT_LOG_MAXFILESIZE        252
#define IDC_CHECK_ENABLEACCOUNTING      253
#define IDC_EDIT_ACC_DIRECTORY          254
#define IDC_EDIT_ACC_LOGFILES           255
#define IDC_EDIT_ACC_MAXFILESIZE        256
#define IDC_POLICY_GEN_DIRECTION        257
#define IDC_POLICY_GEN_SERVICELEVEL     258
#define IDC_POLICY_GEN_DEFAULTUSER      259
#define IDC_POLICY_GEN_UNKNOWNUSER      260
#define IDC_POLICY_GEN_RADIO_USER       261
#define IDC_POLICY_GEN_RADIO_OU         262
#define IDC_POLICY_GEN_BROWSEUSER       263
#define IDC_POLICY_GEN_BROWSEOU         264
#define IDC_POLICY_GEN_EDIT_USER        266
#define IDC_POLICY_GEN_EDIT_OU          267
#define IDC_POLICY_FLOW_DATARATE_RES    268
#define IDC_POLICY_FLOW_DATARATE_DEF    269
#define IDC_POLICY_FLOW_DATARATE_RADIO_LIMIT 270
#define IDC_POLICY_FLOW_DATARATE_EDIT_LIMIT 271
#define IDC_POLICY_AGGR_DATARATE_RES    272
#define IDC_POLICY_AGGR_DATARATE_DEF    273
#define IDC_POLICY_AGGR_DATARATE_RADIO_LIMIT 274
#define IDC_POLICY_FLOW_PEAKDATARATE_RES 275
#define IDC_POLICY_FLOW_PEAKDATARATE_DEF 276
#define IDC_POLICY_FLOW_PEAKDATARATE_RADIO_LIMIT 277
#define IDC_POLICY_FLOW_PEAKDATARATE_EDIT_LIMIT 278
#define IDC_POLICY_FLOW_DURATION_RES    279
#define IDC_POLICY_FLOW_DURATION_DEF    280
#define IDC_POLICY_FLOW_DURATION_RADIO_LIMIT 281
#define IDC_POLICY_FLOW_DURATION_EDIT_LIMIT 282
#define IDC_POLICY_AGGR_DATARATE_EDIT_LIMIT 283
#define IDC_POLICY_AGGR_PEAKDATARATE_RES 284
#define IDC_POLICY_AGGR_PEAKDATARATE_DEF 285
#define IDC_POLICY_AGGR_PEAKDATARATE_RADIO_LIMIT 286
#define IDC_POLICY_AGGR_PEAKDATARATE_EDIT_LIMIT 287
#define IDC_POLICY_AGGR_FLOWS_RES       288
#define IDC_POLICY_AGGR_FLOWS_DEF       289
#define IDC_POLICY_AGGR_FLOWS_RADIO_LIMIT 290
#define IDC_POLICY_AGGR_FLOWS_EDIT_LIMIT 291
#define IDC_SUBNET_TRAFFIC_DATARATE_UNLIMITED 292
#define IDC_SUBNET_TRAFFIC_DATARATE_LIMITED 293
#define IDC_SERVERS_LIST                293
#define IDC_SUBNET_TRAFFIC_PEAKRATE_UNLIMITED 294
#define IDC_SERVERS_ADD                 294
#define IDC_SUBNET_TRAFFIC_PEAKRATE_LIMITED 295
#define IDC_SERVERS_INSTALL             295
#define IDC_SUBNET_TRAFFIC_TTDATARATE_UNLIMITED 296
#define IDC_SERVERS_REMOVE              296
#define IDC_SUBNET_TRAFFIC_TTDATARATE_LIMITED 297
#define IDC_USERPASSWD_DOMAIN           297
#define IDC_SUBNET_TRAFFIC_TTPEAKRATE_UNLIMITED 298
#define IDC_USERPASSWD_PASSWD           298
#define IDC_SUBNET_TRAFFIC_TTPEAKRATE_LIMITED 299
#define IDC_USERPASSWD_PASSWD2          299
#define IDC_COMBO_SUBNET_LIMIT_TYPES    301
#define IDC_LIST_SERVICELIMIT           342
#define IDC_BUTTONADDSERVICELIMIT       343
#define IDC_BUTTONDELETESERVICELIMIT    344
#define IDC_BUTTONEDITSERVICELIMIT      345
#define IDS_WRN_POLICY_EFFECTIVE_FROM_NEXT_RSVP 500
#define IDS_BROWSEOU_TITLE              501
#define IDS_ERR_USERFORMAT              502
#define IDS_ERR_USERACCOUNT             503
#define IDS_ERR_INSTALL                 504
#define IDS_PASSWORDMUSTBESAME          505
#define IDS_EMPTY_DOMAIN                506
#define IDS_ERROR_CLOSE_PROPERTY_SHEET  507
#define	IDS_ADD_TO_LIST                 508
#define	IDS_ERROR_QOS_NOTINSTALLED		509
#define	IDS_ASK_ADD_SERVER				510
#define	IDS_ERR_USER_DN					511
#define	IDS_ERR_OU_DN					512

#define IDD_POLICY_GEN                  5004
#define IDD_POLICY_FLOW                 5005
#define IDD_POLICY_AGGR                 5006
#define IDD_SERVERS                     5007
#define IDD_GENERAL_BACKUP              5008
#define IDS_COL_SUBNET_TOTALDATARATE    5009
#define IDD_SUBNET_LIMIT                5009
#define IDS_COL_SUBNET_TOTALPEAKRATE    5010
#define IDS_AGGREGATEPOLICY             5011
#define IDS_TEXT_UNLIMITED              5012
#define IDS_COL_SUBLIMITS_NAME			5013
#define IDS_COL_SUBLIMITS_DATARATE		5014
#define IDS_COL_SUBLIMITS_PEAKRATE		5015
#define	IDS_COL_SUBLIMITS_TOTALDATARATE	5016
#define	IDS_COL_SUBLIMITS_TOTALPEAKRATE	5017
#define	IDS_CLPOLICY					5018
#define	IDS_GPOLICY						5019
#define IDS_QUESTION_UNINSTALL_ACS		5020
#define IDS_NO_POLICY_FOR_SEND_AND_CONTROLLEDLOAD 5021
#define IDS_ACS_ADMIN_HELPTEXT          5022
#define IDS_ACS_ADMIN_LINK              5023


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        225
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         304
#define _APS_NEXT_SYMED_VALUE           123
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pgsbm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       pgsbm.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_PGSBM_H__C0DCD9EC_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
#define AFX_PGSBM_H__C0DCD9EC_64FE_11D1_855B_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PgSBM.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPgSBM dialog

class CPgSBM : public CACSPage
{
	DECLARE_DYNCREATE(CPgSBM)

// Construction
	CPgSBM();
public:
	CPgSBM(CACSSubnetConfig* pConfig);
	~CPgSBM();

// Dialog Data
	//{{AFX_DATA(CPgSBM)
	enum { IDD = IDD_SBM };
	CSpinButtonCtrl	m_SpinElection;
	DWORD	m_dwAliveInterval;
	DWORD	m_dwB4Reserve;
	DWORD	m_dwDeadInterval;
	DWORD	m_dwElection;
	DWORD	m_dwTimeout;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgSBM)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPgSBM)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditAliveinterval();
	afx_msg void OnChangeEditB4reserve();
	afx_msg void OnChangeEditDeadinterval();
	afx_msg void OnChangeEditElection();
	afx_msg void OnChangeEditTimeout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void	DataInit();
	CComPtr<CACSSubnetConfig>		m_spConfig;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PGSBM_H__C0DCD9EC_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED_)
#define AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxmt.h>
#include <afxdlgs.h>
#include <afxtempl.h>

// #define _WIN32_WINNT 0x0400
// #define _ATL_APARTMENT_THREADED

// #ifdef _WIN32_IE
// #undef _WIN32_IE
// #endif
// #define _WIN32_IE 0x0400
#include <commctrl.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <shlobj.h>
#include <dsclient.h>

#include <list>

extern "C"
{
    #include "winsock.h"     //  WinSock definitions
    #include "lmerr.h"

    // for get user stuff
    #include <wtypes.h>
    #include <sspi.h>
    #include <ntsecapi.h>
    #include "secedit.h"

}

#include <mmc.h>

// Files from ..\tfscore
#include <dbgutil.h>
#include <std.h>
#include <errutil.h>
#include <register.h>

// Files from ..\common
#include <ccdata.h>
#include <about.h>
#include <dataobj.h>
// #include <proppage.h>
#include <ipaddr.hpp>
#include <dialog.h>

#include <htmlhelp.h>

// for 'trace' debuging (sample remnants)
#define ODS(sz) OutputDebugString(sz)

#include "dsacsuse.h"
#include "helper.h"
#include "acs.h"

#define	DWORD_LIMIT		4294967290

#include "resource.h"
#include "acsdata.h"
#include "acsadmin.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pgsrvs.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pgsrvs.cpp
//
//--------------------------------------------------------------------------

// PgSrvs.cpp : implementation file
//

#include "stdafx.h"
#include <objsel.h>
#include <secext.h>
#include "acsadmin.h"
#include <dsrole.h>
#include "PgSrvs.h"

#include "ntsecapi.h"

#ifndef STATUS_SUCCESS
#define	STATUS_SUCCESS	0L
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef BOOL (*ACSINSTALL_Func)(
								LPWSTR HostName,
				                LPWSTR DomainName,
				                LPWSTR UserName,
				                LPWSTR PassWord,
				                LPDWORD dwError);
					                

typedef BOOL (*ACSUNINSTALL_Func)(
								LPWSTR HostName,
				                LPDWORD dwError);

#define ACSINSTALL		"AcsInstall"
#define	ACSUNINSTALL	"AcsUninstall"
#define	ACSINSTALLDLL	_T("acsetupc.dll")
#define	ACSAccount		_T("AcsService")

/////////////////////////////////////////////////////////////////////////////
// CPgServers property page

IMPLEMENT_DYNCREATE(CPgServers, CACSPage)

#if 0	// LSA functions can only change policy on a machine, it's not the APIs we want
		// need to remove the code later
void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    }

    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}

/*++
This function attempts to obtain a SID representing the supplied
account on the supplied system.

If the function succeeds, the return value is TRUE. A buffer is
allocated which contains the SID representing the supplied account.
This buffer should be freed when it is no longer needed by calling
HeapFree(GetProcessHeap(), 0, buffer)

If the function fails, the return value is FALSE. Call GetLastError()
to obtain extended error information.

Scott Field (sfield)    12-Jul-95
--*/

BOOL
GetAccountSid(
    LPTSTR SystemName,
    LPTSTR AccountName,
    PSID *Sid
    )
{
    LPTSTR ReferencedDomain=NULL;
    DWORD cbSid=128;    // initial allocation attempt
    DWORD cbReferencedDomain=16; // initial allocation size
    SID_NAME_USE peUse;
    BOOL bSuccess=FALSE; // assume this function will fail

    __try {

    //
    // initial memory allocations
    //
    if((*Sid=HeapAlloc(
                    GetProcessHeap(),
                    0,
                    cbSid
                    )) == NULL) __leave;

    if((ReferencedDomain=(LPTSTR)HeapAlloc(
                    GetProcessHeap(),
                    0,
                    cbReferencedDomain
                    )) == NULL) __leave;

    //
    // Obtain the SID of the specified account on the specified system.
    //
    while(!LookupAccountName(
                    SystemName,         // machine to lookup account on
                    AccountName,        // account to lookup
                    *Sid,               // SID of interest
                    &cbSid,             // size of SID
                    ReferencedDomain,   // domain account was found on
                    &cbReferencedDomain,
                    &peUse
                    )) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // reallocate memory
            //
            if((*Sid=HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        *Sid,
                        cbSid
                        )) == NULL) __leave;

            if((ReferencedDomain=(LPTSTR)HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        ReferencedDomain,
                        cbReferencedDomain
                        )) == NULL) __leave;
        }
        else __leave;
    }

    //
    // Indicate success.
    //
    bSuccess=TRUE;

    } // finally
    __finally {

    //
    // Cleanup and indicate failure, if appropriate.
    //

    HeapFree(GetProcessHeap(), 0, ReferencedDomain);

    if(!bSuccess) {
        if(*Sid != NULL) {
            HeapFree(GetProcessHeap(), 0, *Sid);
            *Sid = NULL;
        }
    }

    } // finally

    return bSuccess;
}

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;

    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);

    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
    else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}

#endif	// LSA is not the right API for this

HRESULT	RemoveInteractiveLoginPrivilege(LPCTSTR strDomain, LPCTSTR strAccount)
{
	return S_OK;
	
#if 0	// LSA is not the right API for this
    LSA_HANDLE PolicyHandle = NULL;
    PSID pSid = NULL;
    NTSTATUS Status;
    HRESULT	hr = S_OK;

    //
    // Open the policy on the target machine.
    //
    if((Status=OpenPolicy(
                (LPTSTR)strDomain,      // target machine
                POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                &PolicyHandle       // resultant policy handle
                )) != 0) {
        return HRESULT_FROM_WIN32(Status);
    }

    //
    // Obtain the SID of the user/group.
    // Note that we could target a specific machine, but we don't.
    // Specifying NULL for target machine searches for the SID in the
    // following order: well-known, Built-in and local, primary domain,
    // trusted domains.
    //
    if(GetAccountSid(
            NULL,       // default lookup logic
            (LPTSTR)strAccount,// account to obtain SID
            &pSid       // buffer to allocate to contain resultant SID
            )) {
        //
        // We only grant the privilege if we succeeded in obtaining the
        // SID. We can actually add SIDs which cannot be looked up, but
        // looking up the SID is a good sanity check which is suitable for
        // most cases.

        //
        // Grant the SeServiceLogonRight to users represented by pSid.
        //

        // #define SE_INTERACTIVE_LOGON_NAME           TEXT("SeInteractiveLogonRight")
		// #define SE_DENY_INTERACTIVE_LOGON_NAME      TEXT("SeDenyInteractiveLogonRight")

        if((Status=SetPrivilegeOnAccount(
                    PolicyHandle,           // policy handle
                    pSid,                   // SID to grant privilege
                    SE_INTERACTIVE_LOGON_NAME, // Unicode privilege
                    FALSE                    // enable the privilege
                    )) != STATUS_SUCCESS)
		{
			hr = HRESULT_FROM_WIN32(Status);
			goto L_Err;
		}
        if((Status=SetPrivilegeOnAccount(
                    PolicyHandle,           // policy handle
                    pSid,                   // SID to grant privilege
                    SE_DENY_INTERACTIVE_LOGON_NAME, // Unicode privilege
                    TRUE                    // enable the privilege
                    )) != STATUS_SUCCESS)
		{
			hr = HRESULT_FROM_WIN32(Status);
			goto L_Err;
		}
    }
    
L_Err:
    //
    // Close the policy handle.
    //
    if(PolicyHandle != NULL)
	    LsaClose(PolicyHandle);

    //
    // Free memory allocated for SID.
    //
    if(pSid != NULL) HeapFree(GetProcessHeap(), 0, pSid);

    return hr;
#endif		// LSA is not the right API
}

HRESULT	VerifyAccount(LPCTSTR strDomain, LPCTSTR strAccount, LPCTSTR passwd, HWND hParent)
{
	CString		UserDN = _T("WinNT://");
	CComPtr<IADs>			spADs;
	CComPtr<IADsUser>		spADsUser;
	CComPtr<IADsContainer>	spCont;
	CComPtr<IDispatch>		spDisp;
	CWaitCursor				wc;

	UserDN+=strDomain;
	UserDN+=_T("/");
	UserDN+=strAccount;

	// this doesn't compile
	// UserDN.Replace(_T("\\"), _T("/"));

	// try to create the user account in DS, 
	HRESULT hr = ADsOpenObject((LPTSTR)(LPCTSTR)UserDN, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_USE_SIGNING | ADS_USE_SEALING,	IID_IADs, (void**)&spADs);

	// if no such object
	if ( hr != S_OK)
	{
		CString	strDomainDN = _T("WinNT://");

		strDomainDN += strDomain;

		CHECK_HR(hr = ADsOpenObject((LPTSTR)(LPCTSTR)strDomainDN, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_USE_SIGNING | ADS_USE_SEALING, IID_IADsContainer, (void**)&spCont));

		// create the user
		CHECK_HR(hr = spCont->Create(L"user", (LPTSTR)(LPCTSTR)strAccount, &spDisp ));
			
		hr = spDisp->QueryInterface( IID_IADsUser, (void**) &spADsUser );

		CHECK_HR(hr = spADsUser->SetInfo()); // Commit

		// set the password for the user
		try{
			BSTR bstrPasswd = SysAllocString((LPTSTR)passwd);
			spADsUser->SetPassword(bstrPasswd);
			SysFreeString(bstrPasswd);
			// turn the interactive login off
			CString str = strDomain;
			str += _T("\\");
			str += strAccount;
			hr = RemoveInteractiveLoginPrivilege(NULL, str);
		}
		catch(...)
		{
			hr = E_OUTOFMEMORY;
		}
	}

L_ERR:
	if (FAILED(hr))
	{
		if (IDYES == ReportErrorEx(hr,IDS_ERR_USERACCOUNT, hParent, MB_YESNO))
			hr = S_OK;
	}
	
	return hr;
}

HRESULT	InstallACSServer(LPCWSTR	pMachineName, LPCWSTR strDomain, LPCWSTR strUser, LPCWSTR strPasswd, HWND hParent)
{
	HRESULT				hr = S_OK;
	ACSINSTALL_Func		acsInstallFunc;
	HINSTANCE			hAcsInstallDLL = NULL;
	CWaitCursor			wc;

    hAcsInstallDLL = LoadLibrary(ACSINSTALLDLL);
    if ( NULL != hAcsInstallDLL )
   	{
		// load the API pointer
    	acsInstallFunc = (ACSINSTALL_Func) GetProcAddress(hAcsInstallDLL, ACSINSTALL);

    	if(acsInstallFunc == NULL)
	    	hr = HRESULT_FROM_WIN32(GetLastError());
	    else
	    {
	    	DWORD	dwErr;
	    	if(!acsInstallFunc((LPWSTR)pMachineName, (LPWSTR) strDomain, (LPWSTR)strUser, (LPWSTR)strPasswd, &dwErr))
		    	hr = HRESULT_FROM_WIN32(dwErr);
	    }

	    FreeLibrary(hAcsInstallDLL);
    }
    else
    	hr = HRESULT_FROM_WIN32(GetLastError());

	return hr;
}

HRESULT	UninstallACSServer(LPWSTR	pMachineName, HWND hParent)
{
	ACSUNINSTALL_Func	acsUninstallFunc;
	HRESULT				hr = S_OK;
	HINSTANCE			hAcsInstallDLL = NULL;
	CWaitCursor			wc;

    hAcsInstallDLL = LoadLibrary(ACSINSTALLDLL);
    if ( NULL != hAcsInstallDLL )
   	{
	    	
		// load the API pointer
    	acsUninstallFunc = (ACSUNINSTALL_Func) GetProcAddress(hAcsInstallDLL, ACSUNINSTALL);
    	if(acsUninstallFunc == NULL)
	    	hr = HRESULT_FROM_WIN32(GetLastError());
	    else
	    {
	    	DWORD	dwErr;
	    	if(!acsUninstallFunc(pMachineName, &dwErr))
		    	hr = HRESULT_FROM_WIN32(dwErr);
	    }

	    FreeLibrary(hAcsInstallDLL);
    }
    else
    	hr = HRESULT_FROM_WIN32(GetLastError());

	return hr;
}

CPgServers::CPgServers(CACSSubnetConfig* pConfig) : CACSPage(CPgServers::IDD)
{
	ASSERT(pConfig);
	m_spConfig = pConfig;
	DataInit();
}


CPgServers::CPgServers() : CACSPage(CPgServers::IDD)
{
	DataInit();
}

void CPgServers::DataInit()
{
	m_pServers = NULL;
	//{{AFX_DATA_INIT(CPgServers)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPgServers::~CPgServers()
{
	if(m_pServers)
		delete m_pServers;
}

void CPgServers::DoDataExchange(CDataExchange* pDX)
{
	CACSPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgServers)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgServers, CACSPage)
	//{{AFX_MSG_MAP(CPgServers)
	ON_BN_CLICKED(IDC_SERVERS_ADD, OnServersAdd)
	ON_BN_CLICKED(IDC_SERVERS_INSTALL, OnServersInstall)
	ON_BN_CLICKED(IDC_SERVERS_REMOVE, OnServersRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(
    IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

	LPCTSTR	attrs[] = {_T("dNSHostName"), _T("userAccountControl")};
	InitInfo.cAttributesToFetch = 2;
	InitInfo.apwzAttributeNames = attrs;



    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}


#define BREAK_ON_FAIL_HRESULT(hr)       \
    if (FAILED(hr)) { printf("line %u err 0x%x\n", __LINE__, hr); break; }


UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);



/////////////////////////////////////////////////////////////////////////////
// CPgServers message handlers

void CPgServers::OnServersAdd() 
{
	bool bAddedNew = false;
	
    HRESULT hr = S_OK;
    IDsObjectPicker *pDsObjectPicker = NULL;
    IDataObject *pdo = NULL;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) return;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //

        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Reinitialize the object picker to choose computers
        //

        hr = InitObjectPickerForComputers(pDsObjectPicker);

        if(FAILED(hr))
        {
			TCHAR	msg[1024];

			FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 1024, NULL);
        }
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now pick a computer
        //

        hr = pDsObjectPicker->InvokeDialog(this->GetSafeHwnd(), &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

		if(hr == S_OK)	// when user selected cancel, hr == S_FALSE, 
        // ProcessSelectedObjects(pdo);
        {
	        ASSERT(pdo);
        

			STGMEDIUM stgmedium =
			{
				TYMED_HGLOBAL,
				NULL,
				NULL
			};

			FORMATETC formatetc =
			{
				(unsigned short)g_cfDsObjectPicker,
				NULL,
				DVASPECT_CONTENT,
				-1,
				TYMED_HGLOBAL
			};

			bool fGotStgMedium = false;

			do
			{
				hr = pdo->GetData(&formatetc, &stgmedium);
				BREAK_ON_FAIL_HRESULT(hr);
				// user and password dialog
				CDlgPasswd				dlg;

				fGotStgMedium = true;

				PDS_SELECTION_LIST pDsSelList =
				(PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

				if (!pDsSelList)
				{
					printf("GlobalLock error %u\n", GetLastError());
					break;
				}

				if(pDsSelList->cItems > 0)	// some are selected
				{
					// user and password dialog
	
					if(dlg.DoModal() != IDOK)
						break;	// the selected servers are not added

					// validate user's existence -- return other than OK, will not do anything
					if (S_OK != VerifyAccount(dlg.m_strDomain, ACSAccount, dlg.m_strPasswd, GetSafeHwnd()))
						break;
				}

		        ULONG i;

				for (i = 0; i < pDsSelList->cItems; i++)
				{
					CString*	pStr = NULL;
					BSTR		bstrTemp;

					try{
						if(pDsSelList->aDsSelection[i].pvarFetchedAttributes[0].vt == VT_EMPTY)
						{
							CString	str;
							str.Format(IDS_ERR_DNSNAME, pDsSelList->aDsSelection[i].pwzName);
							AfxMessageBox(str, MB_OK);
							continue;
						}

						ASSERT(pDsSelList->aDsSelection[i].pvarFetchedAttributes[0].vt == VT_BSTR);


						bstrTemp = V_BSTR(&(pDsSelList->aDsSelection[i].pvarFetchedAttributes[0]));



						DSROLE_PRIMARY_DOMAIN_INFO_BASIC*	pDsRole;
						DWORD	dwErr = DsRoleGetPrimaryDomainInformation(bstrTemp, DsRolePrimaryDomainInfoBasic, (PBYTE *)&pDsRole);

						if(dwErr == NO_ERROR && (pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation 
										|| pDsRole->MachineRole == DsRole_RoleMemberWorkstation))
						{
							CString	tempMsg;
							tempMsg.LoadString(IDS_ERR_NOT_SERVER);
							CString errMsg;

							errMsg.Format(tempMsg, bstrTemp);
							AfxMessageBox(errMsg);

							DsRoleFreeMemory((PVOID)pDsRole);
							pDsRole = NULL;

							continue;
						}
						else
						{
							if(pDsRole)
							{
								DsRoleFreeMemory((PVOID)pDsRole);
								pDsRole = NULL;
							}
						}

						// add to the list
						pStr = NULL;
						if(m_aServers.Find(bstrTemp) == -1 )
						{
							HRESULT	hr = S_OK;
							pStr = new CString();
							*pStr = bstrTemp;
							bAddedNew = true;
							hr = InstallACSServer(V_BSTR(&(pDsSelList->aDsSelection[i].pvarFetchedAttributes[0])), dlg.m_strDomain, ACSAccount, dlg.m_strPasswd, GetSafeHwnd());
							if( hr != S_OK)
							{
								CString	Str;
								Str.LoadString(IDS_FAILED_INSTALL_ACSSERVER);

								CString strTemp1;
								strTemp1.LoadString(IDS_ADD_TO_LIST);
								
								CString	strAskAdd1;
								strAskAdd1.Format(strTemp1, V_BSTR(&(pDsSelList->aDsSelection[i].pvarFetchedAttributes[0])));
								
								CString	strTemp2;
								strTemp2.LoadString(IDS_ASK_ADD_SERVER);
								
								CString	strAskAdd2;
								strAskAdd2.Format(strTemp2, V_BSTR(&(pDsSelList->aDsSelection[i].pvarFetchedAttributes[0])));

								Str += strAskAdd1;
								Str += strAskAdd2;

								UINT	nAdd = IDNO;
								if(hr == REGDB_E_CLASSNOTREG)
								{
									CString	strQosNotInstalled;
									strQosNotInstalled.LoadString(IDS_ERROR_QOS_NOTINSTALLED);
									CString	strToDisplay;
									strToDisplay.Format(Str, strQosNotInstalled);
									nAdd = AfxMessageBox(strToDisplay, MB_YESNO);
								}
								else
									nAdd =  ReportErrorEx(hr, Str, GetSafeHwnd(), MB_YESNO);

								if(IDYES != nAdd)
									continue;	
							}
							m_pServers->AddString(pStr);	// this will add the string to m_aServers array as well underneath
						}
						
					}
					catch(...)
					{
						delete pStr;
						pStr = NULL;
					}
				}

				GlobalUnlock(stgmedium.hGlobal);
			} while (0);

			if (fGotStgMedium)
    		{
		        ReleaseStgMedium(&stgmedium);
		    }
	        pdo->Release();
	        pdo = NULL;
        }

    } while (0);

	if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

	if(bAddedNew)
		SetModified();
}

void CPgServers::OnServersInstall() 
{
	int i = m_pServers->GetSelected();

	// nothing selected
	if(i == LB_ERR)	return;

	HRESULT	hr = S_OK;
	CString*	pStr = m_aServers.GetAt(i);

	ASSERT(pStr);
	// user and password dialog
	CDlgPasswd				dlg;
	if(dlg.DoModal() != IDOK)
		return;

	// validate user's existence -- return other than OK, will not do anything
	if (S_OK != VerifyAccount(dlg.m_strDomain, ACSAccount, dlg.m_strPasswd, GetSafeHwnd()))
		return;

	USES_CONVERSION;
	InstallACSServer(T2W((LPTSTR)(LPCTSTR)*pStr), dlg.m_strDomain, ACSAccount, dlg.m_strPasswd, GetSafeHwnd());
}

void CPgServers::OnServersRemove() 
{
	// TODO: Add your control notification handler code here

	int i = m_pServers->GetSelected();
	if(i== LB_ERR)	return;

	HRESULT	hr = S_OK;
	CString*	pStr = m_aServers.GetAt(i);

	ASSERT(pStr);

	USES_CONVERSION;

	int cId = AfxMessageBox(IDS_QUESTION_UNINSTALL_ACS, MB_YESNOCANCEL);

	if (cId == IDCANCEL)	return;

	if (cId == IDYES)
		hr = UninstallACSServer(T2W((LPTSTR)(LPCTSTR)*pStr), GetSafeHwnd());
	
	if( hr != S_OK)
	{
		CString	ErrStr;
		ErrStr.LoadString(IDS_FAILED_UNINSTALL_ACSSERVER);
		CString	Str;
		Str.Format(ErrStr, (LPCTSTR)*pStr);
		CString	strBecause;

		Str += strBecause;

		ReportError(hr, Str, GetSafeHwnd());
	}
	
	m_pServers->DeleteSelected();
	SetModified();
}

BOOL CPgServers::OnApply() 
{
	// logging level
	DWORD	dwAttrFlags = ATTR_FLAGS_NONE;
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_SERVERLIST, true);
	m_spConfig->m_strArrayServerList = m_aServers;
	m_spConfig->SetFlags(ATTR_FLAG_SAVE, ACS_SCAF_SERVERLIST, m_aServers.GetSize() != 0);
	dwAttrFlags |= ACS_SCAF_SERVERLIST;
	
	AddFlags(dwAttrFlags);	// prepare flags for saving

	return CACSPage::OnApply();
}

BOOL CPgServers::OnInitDialog() 
{

	if(m_spConfig->GetFlags(ATTR_FLAG_LOAD, ACS_SCAF_SERVERLIST))
	{

		m_aServers = m_spConfig->m_strArrayServerList;
	}
	
	m_pServers = new CStrBox<CListBox>(this, IDC_SERVERS_LIST, m_aServers);
	m_pServers->Fill();
	CACSPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/////////////////////////////////////////////////////////////////////////////
// CDlgPasswd dialog

IMPLEMENT_DYNCREATE(CDlgPasswd, CACSDialog)

CDlgPasswd::CDlgPasswd(CWnd* pParent /*=NULL*/)
	: CACSDialog(CDlgPasswd::IDD, pParent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	//{{AFX_DATA_INIT(CDlgPasswd)
	m_strPasswd = _T("");
	m_strMachine = _T("");
	m_strPasswd2 = _T("");
	m_strDomain = _T("");
	//}}AFX_DATA_INIT
	
}

void CDlgPasswd::DoDataExchange(CDataExchange* pDX)
{
	CACSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgPasswd)
	DDX_Text(pDX, IDC_USERPASSWD_PASSWD, m_strPasswd);
	DDX_Text(pDX, IDC_USERPASSWD_PASSWD2, m_strPasswd2);
	DDX_Text(pDX, IDC_USERPASSWD_DOMAIN, m_strDomain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgPasswd, CACSDialog)
	//{{AFX_MSG_MAP(CDlgPasswd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgPasswd message handlers

void CDlgPasswd::OnOK() 
{
	// TODO: Add extra validation here
	// user name should be in domain\user format
	// password and confirmed password must be exactly the same
	UpdateData();

	// domain name field can not be empty
	m_strDomain.TrimLeft();
	m_strDomain.TrimRight();
	if (m_strDomain.IsEmpty())
	{
		AfxMessageBox(IDS_EMPTY_DOMAIN);
		GotoDlgCtrl(GetDlgItem(IDC_USERPASSWD_DOMAIN));
		return;
	}

	if (m_strPasswd.Compare(m_strPasswd2) != 0)	// not the same
	{
		AfxMessageBox(IDS_PASSWORDMUSTBESAME);
		GotoDlgCtrl(GetDlgItem(IDC_USERPASSWD_PASSWD));
		return;
	}

	CACSDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\pgsrvs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pgsrvs.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_PGSRVS_H__2D9AC0D4_4CC3_11D2_97A3_00C04FC31FD3__INCLUDED_)
#define AFX_PGSRVS_H__2D9AC0D4_4CC3_11D2_97A3_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PgSrvs.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPgServers dialog

class CPgServers : public CACSPage
{
	DECLARE_DYNCREATE(CPgServers)

// Construction
public:
	CPgServers();
	CPgServers(CACSSubnetConfig* pConfig);

	~CPgServers();

	void	DataInit();
// Dialog Data
	//{{AFX_DATA(CPgServers)
	enum { IDD = IDD_SERVERS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgServers)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPgServers)
	afx_msg void OnServersAdd();
	afx_msg void OnServersInstall();
	afx_msg void OnServersRemove();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CStrArray						m_aServers;
	CStrBox<CListBox>*				m_pServers;
	CComPtr<CACSSubnetConfig>		m_spConfig;
};

/////////////////////////////////////////////////////////////////////////////
// CDlgPasswd dialog

class CDlgPasswd : public CACSDialog // public CDialog
{
    DECLARE_DYNCREATE(CDlgPasswd)

// Construction
public:
	CDlgPasswd(CWnd* pParent = NULL);   // standard constructor
public:
// Dialog Data
	//{{AFX_DATA(CDlgPasswd)
	enum { IDD = IDD_USERPASSWD };
	CString	m_strPasswd;
	CString	m_strMachine;
	CString	m_strPasswd2;
	CString	m_strDomain;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgPasswd)
	protected:
	
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
//    CDlgPasswd();
	// Generated message map functions
	//{{AFX_MSG(CDlgPasswd)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PGSRVS_H__2D9AC0D4_4CC3_11D2_97A3_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\traffic.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       traffic.cpp
//
//--------------------------------------------------------------------------

// Traffic.cpp : implementation file
//

#include "stdafx.h"
#include "helper.h"
#include "acsadmin.h"
#include "acsdata.h"
#include "Traffic.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPgTraffic property page

IMPLEMENT_DYNCREATE(CPgTraffic, CACSPage)

CPgTraffic::CPgTraffic() : CACSPage(CPgTraffic::IDD)
{
	DataInit();
}

CPgTraffic::CPgTraffic(CACSPolicyElement* pData) : CACSPage(CPgTraffic::IDD)
{
	ASSERT(pData);
	m_spData = pData;
	DataInit();
}

void CPgTraffic::DataInit()
{
	//{{AFX_DATA_INIT(CPgTraffic)
	m_dwPFDataRate = 0;
	m_dwPFDuration = 0;
	m_dwPFPeakRate = 0;
	m_dwTTDataRate = 0;
	m_dwTTFlows = 0;
	m_bPFDataRate = FALSE;
	m_bPFPeakRate = FALSE;
	m_bTTDataRate = FALSE;
	m_bTTFlows = FALSE;
	m_bPFDuration = FALSE;
	m_bTTPeakRate = FALSE;
	m_dwTTPeakRate = 0;
	//}}AFX_DATA_INIT

	m_pServiceType = NULL;
	m_pDirection = NULL;
}

CPgTraffic::~CPgTraffic()
{
	delete m_pDirection;
	delete m_pServiceType;
	m_aDirections.DeleteAll();
	m_aServiceTypes.DeleteAll();
}

void CPgTraffic::DoDataExchange(CDataExchange* pDX)
{
	CACSPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgTraffic)
	DDX_Check(pDX, IDC_CHECK_PF_DATARATE, m_bPFDataRate);
	DDX_Check(pDX, IDC_CHECK_PF_PEAKRATE, m_bPFPeakRate);
	DDX_Check(pDX, IDC_CHECK_TT_DATARATE, m_bTTDataRate);
	DDX_Check(pDX, IDC_CHECK_TT_FLOWS, m_bTTFlows);
	DDX_Check(pDX, IDC_CHECK_PF_DURATION, m_bPFDuration);
	DDX_Check(pDX, IDC_CHECK_TT_PEAKRATE, m_bTTPeakRate);
	if(m_bPFDataRate)
	{
		DDX_Text(pDX, IDC_EDIT_PF_DATARATE, m_dwPFDataRate);
		DDV_MinMaxDWord(pDX, m_dwPFDataRate, 0, DWORD_LIMIT/1024);
	}
	if(m_bPFDuration)
	{
		DDX_Text(pDX, IDC_EDIT_PF_DURATION, m_dwPFDuration);
		DDV_MinMaxDWord(pDX, m_dwPFDuration, 0, DWORD_LIMIT/60);
	}
	if(m_bPFPeakRate)
	{
		DDX_Text(pDX, IDC_EDIT_PF_PEAKRATE, m_dwPFPeakRate);
		DDV_MinMaxDWord(pDX, m_dwPFPeakRate, 0, DWORD_LIMIT/1024);
	}
	
	if(m_bTTDataRate)
	{
		DDX_Text(pDX, IDC_EDIT_TT_DATARATE, m_dwTTDataRate);
		DDV_MinMaxDWord(pDX, m_dwTTDataRate, 0, DWORD_LIMIT/1024);
	}
	
	if(m_bTTFlows)
	{
		DDX_Text(pDX, IDC_EDIT_TT_FLOWS, m_dwTTFlows);
		DDV_MinMaxDWord(pDX, m_dwTTFlows, 0, DWORD_LIMIT);
	}
	
	if(m_bTTPeakRate)
	{
		DDX_Text(pDX, IDC_EDIT_TT_PEAKRATE, m_dwTTPeakRate);
		DDV_MinMaxDWord(pDX, m_dwTTPeakRate, 0, DWORD_LIMIT/1024);
	}
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgTraffic, CACSPage)
	//{{AFX_MSG_MAP(CPgTraffic)
	ON_CBN_SELCHANGE(IDC_COMBODIRECTION, OnSelchangeCombodirectioin)
	ON_CBN_SELCHANGE(IDC_COMBOSERVICELEVEL, OnSelchangeComboservicelevel)
	ON_EN_CHANGE(IDC_EDIT_PF_DATARATE, OnChangeEditPfDatarate)
	ON_EN_CHANGE(IDC_EDIT_PF_DURATION, OnChangeEditPfDuration)
	ON_EN_CHANGE(IDC_EDIT_PF_PEAKRATE, OnChangeEditPfPeakrate)
	ON_EN_CHANGE(IDC_EDIT_TT_DATARATE, OnChangeEditTtDatarate)
	ON_EN_CHANGE(IDC_EDIT_TT_FLOWS, OnChangeEditTtFlows)
	ON_BN_CLICKED(IDC_CHECK_PF_DATARATE, OnCheckPfDatarate)
	ON_BN_CLICKED(IDC_CHECK_PF_PEAKRATE, OnCheckPfPeakrate)
	ON_BN_CLICKED(IDC_CHECK_TT_DATARATE, OnCheckTtDatarate)
	ON_BN_CLICKED(IDC_CHECK_TT_FLOWS, OnCheckTtFlows)
	ON_BN_CLICKED(IDC_CHECK_PF_DURATION, OnCheckPfDuration)
	ON_BN_CLICKED(IDC_CHECK_TT_PEAKRATE, OnCheckTtPeakrate)
	ON_EN_CHANGE(IDC_EDIT_TT_PEAKRATE, OnChangeEditTtPeakrate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgTraffic message handlers
enum DirectionIndex 
{
//	DIRECTION_DEFAULT = 0,
	DIRECTION_SEND,
	DIRECTION_RECEIVE,
	DIRECTION_SENDRECEIVE
};

enum ServiceTypeIndex 
{
//	SERVICETYPE_DEFAULT = 0,
	SERVICETYPE_ALL,
	SERVICETYPE_BESTEFFORT,
	SERVICETYPE_CONTROLLEDLOAD,
	SERVICETYPE_GUARANTEEDSERVICE
};


BOOL CPgTraffic::OnApply() 
{
	CString*	pStr = NULL;
	// check if the values input on the page is valid
	UINT	cId = 0;
	UINT	mId = 0;
		
	if(m_bPFPeakRate && m_bPFDataRate && m_dwPFDataRate > m_dwPFPeakRate)
	{
		cId = IDC_EDIT_PF_PEAKRATE;
		mId = IDS_ERR_PEAKRATE_LESS_RATE;
	}

	if(!cId && m_bTTDataRate && m_bPFDataRate && m_dwPFDataRate > m_dwTTDataRate)
	{
		cId = IDC_EDIT_TT_DATARATE;
		mId = IDS_ERR_TOTALRATE_LESS_RATE;
	}

	if(!cId && m_bTTDataRate && m_bPFPeakRate && m_dwPFPeakRate > m_dwTTDataRate)
	{
		cId = IDC_EDIT_TT_DATARATE;
		mId = IDS_ERR_TOTALRATE_LESS_PEAKRATE;
	}
	
	if(!cId && m_bTTDataRate && m_bTTPeakRate && m_dwTTPeakRate < m_dwTTDataRate)
	{
		cId = IDC_EDIT_TT_PEAKRATE;
		mId = IDS_ERR_TOTALPEAK_LESS_TOTALRATE;
	}
	
	if(!cId && m_bTTPeakRate && m_bPFPeakRate && m_dwTTPeakRate < m_dwPFPeakRate)
	{
		cId = IDC_EDIT_TT_PEAKRATE;
		mId = IDS_ERR_TOTALPEAK_LESS_PEAK;
	}
	
	if(cId)
	{
		CWnd*	pWnd = GetDlgItem(cId);

		ASSERT(pWnd);
		GotoDlgCtrl( pWnd );

		AfxMessageBox(mId);
		return FALSE;
	}

	
	// direction
	if(m_pDirection)
	{
		switch(m_pDirection->GetSelected())
		{
		case	DIRECTION_SEND:
			m_spData->m_dwDirection = ACS_DIRECTION_SEND;
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_DIRECTION, true);
			break;
		case	DIRECTION_RECEIVE:
			m_spData->m_dwDirection = ACS_DIRECTION_RECEIVE;
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_DIRECTION, true);
			break;
		case	DIRECTION_SENDRECEIVE:
			m_spData->m_dwDirection = ACS_DIRECTION_BOTH;
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_DIRECTION, true);
			break;
		default:
			// no valid value should come here
			ASSERT(0);
		}
	}
	else	// save what ever is loaded
	{
		if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_DIRECTION))
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_DIRECTION, true);
		else
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_DIRECTION, false);
	}

	// service type
	if(m_pServiceType)
	{
		switch(m_pServiceType->GetSelected())
		{
		case	SERVICETYPE_BESTEFFORT:
			m_spData->m_dwServiceType = ACS_SERVICETYPE_BESTEFFORT;
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_SERVICETYPE, true);
			break;
		case	SERVICETYPE_CONTROLLEDLOAD:
			m_spData->m_dwServiceType = ACS_SERVICETYPE_CONTROLLEDLOAD;
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_SERVICETYPE, true);
			break;
		case	SERVICETYPE_GUARANTEEDSERVICE:
			m_spData->m_dwServiceType = ACS_SERVICETYPE_GUARANTEEDSERVICE;
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_SERVICETYPE, true);
			break;
		case	SERVICETYPE_ALL:
			m_spData->m_dwServiceType = ACS_SERVICETYPE_ALL;
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_SERVICETYPE, true);
			break;
		default:
			// no valid value should come here
			ASSERT(0);
		}
	}
	else	// save what ever is loaded
	{
		if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_SERVICETYPE))
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_SERVICETYPE, true);
		else
			m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_SERVICETYPE, false);
	}

	//------------------
	// per flow
	
	// data rate
	if(m_bPFDataRate)
	{
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_PF_TOKENRATE, true);
		m_spData->m_ddPFTokenRate.LowPart = FROMKBS(m_dwPFDataRate);
		m_spData->m_ddPFTokenRate.HighPart = 0;
	}
	else
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_PF_TOKENRATE, false);

	// Peak data rate
	if(m_bPFPeakRate)
	{
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_PF_PEAKBANDWIDTH, true);
		m_spData->m_ddPFPeakBandWidth.LowPart = FROMKBS(m_dwPFPeakRate);
		m_spData->m_ddPFPeakBandWidth.HighPart = 0;
	}
	else
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_PF_PEAKBANDWIDTH, false);

	// duration
	if(m_bPFDuration)
	{
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_PF_DURATION, true);
		m_spData->m_dwPFDuration = MIN2SEC(m_dwPFDuration);
	}
	else
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_PF_DURATION, false);

	//------------------
	// total

	// data rate
	if(m_bTTDataRate)
	{
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_TT_TOKENRATE, true);
		m_spData->m_ddTTTokenRate.LowPart = FROMKBS(m_dwTTDataRate);
		m_spData->m_ddTTTokenRate.HighPart = 0;
	}
	else
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_TT_TOKENRATE, false);

	// total peak bandwidth
	if(m_bTTPeakRate)
	{
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_TT_PEAKBANDWIDTH, true);
		m_spData->m_ddTTPeakBandWidth.LowPart = FROMKBS(m_dwTTPeakRate);
		m_spData->m_ddTTPeakBandWidth.HighPart = 0;
	}
	else
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_TT_PEAKBANDWIDTH, false);

	// flows
	if(m_bTTFlows)
	{
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_TT_FLOWS, true);
		m_spData->m_dwTTFlows = m_dwTTFlows;
	}
	else
		m_spData->SetFlags(ATTR_FLAG_SAVE, ACS_PAF_TT_FLOWS, false);

	// persist the data into DS
	DWORD	dwAttrFlags = ATTR_FLAGS_NONE;

	dwAttrFlags |= (ACS_PAF_SERVICETYPE | ACS_PAF_DIRECTION);
	dwAttrFlags |= (ACS_PAF_PF_DURATION | ACS_PAF_PF_PEAKBANDWIDTH | ACS_PAF_PF_TOKENRATE);
	dwAttrFlags |= (ACS_PAF_TT_FLOWS | ACS_PAF_TT_TOKENRATE | ACS_PAF_TT_PEAKBANDWIDTH);
	
	HRESULT hr = m_spData->Save(dwAttrFlags);

	if(FAILED(hr))	ReportError(hr, IDS_ERR_SAVEPOLICY, NULL);

	return CACSPage::OnApply();
}

BOOL CPgTraffic::OnInitDialog() 
{
	CString*	pStr = NULL;
	// direction
	// fillin the list box
	try{
// removed based on bug: 156787
//		pStr = new CString();
//		pStr->LoadString(IDS_DEFAULT);
//		m_aDirections.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_SEND);
		m_aDirections.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_RECEIVE);
		m_aDirections.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_SENDRECEIVE);
		m_aDirections.Add(pStr);

		m_pDirection = new CStrBox<CComboBox>(this, IDC_COMBODIRECTION, m_aDirections);
		m_pDirection->Fill();

		// decide which one to select
		if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_DIRECTION))
		{
			int	current = -1;
			switch(m_spData->m_dwDirection)
			{
			case	ACS_DIRECTION_SEND:
				current = DIRECTION_SEND;
				break;
			case	ACS_DIRECTION_RECEIVE:
				current = DIRECTION_RECEIVE;
				break;
			case	ACS_DIRECTION_BOTH:
				current = DIRECTION_SENDRECEIVE;
				break;
			default:
				// invalid value
				ASSERT(0);
				// message box
			}

			m_pDirection->Select(current);
		}
		else
		{
			m_pDirection->Select(DIRECTION_SENDRECEIVE);	// default
		}
	}catch(CMemoryException&){};

	// service type
	try{
		pStr = new CString();
		pStr->LoadString(IDS_ALL);
		m_aServiceTypes.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_BESTEFFORT);
		m_aServiceTypes.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_CONTROLLEDLOAD);
		m_aServiceTypes.Add(pStr);

		pStr = new CString();
		pStr->LoadString(IDS_GUARANTEEDSERVICE);
		m_aServiceTypes.Add(pStr);

		m_pServiceType = new CStrBox<CComboBox>(this, IDC_COMBOSERVICELEVEL, m_aServiceTypes);
		m_pServiceType->Fill();

		// decide which one to select
		if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_SERVICETYPE))
		{
			int	current = -1;
			switch(m_spData->m_dwServiceType)
			{
			case	ACS_SERVICETYPE_BESTEFFORT:
				current = SERVICETYPE_BESTEFFORT;
				break;
			case	ACS_SERVICETYPE_CONTROLLEDLOAD:
				current = SERVICETYPE_CONTROLLEDLOAD;
				break;
			case	ACS_SERVICETYPE_GUARANTEEDSERVICE:
				current = SERVICETYPE_GUARANTEEDSERVICE;
				break;
			case	ACS_SERVICETYPE_ALL:
				current = SERVICETYPE_ALL;
				break;
			default:
				// invalid value
				ASSERT(0);
				// message box
			}

			m_pServiceType->Select(current);
		}
		else
		{
			m_pServiceType->Select(SERVICETYPE_ALL);	// default
		}
	}catch(CMemoryException&){};
	

	//------------------
	// per flow
	
	// data rate
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_PF_TOKENRATE))
	{
		m_bPFDataRate = TRUE;
		m_dwPFDataRate = TOKBS(m_spData->m_ddPFTokenRate.LowPart);
	}
	else
		m_bPFDataRate = FALSE;

	// Peak data rate
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_PF_PEAKBANDWIDTH))
	{
		m_bPFPeakRate = TRUE;
		m_dwPFPeakRate = TOKBS(m_spData->m_ddPFPeakBandWidth.LowPart);
	}
	else
		m_bPFPeakRate = FALSE;

	// duration
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_PF_DURATION))
	{
		m_bPFDuration = TRUE;
		m_dwPFDuration = SEC2MIN(m_spData->m_dwPFDuration);
	}
	else
		m_bPFDuration = FALSE;

	//------------------
	// total

	// data rate
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_TT_TOKENRATE))
	{
		m_bTTDataRate = TRUE;
		m_dwTTDataRate = TOKBS(m_spData->m_ddTTTokenRate.LowPart);
	}
	else
		m_bTTDataRate = FALSE;

	// Peak data rate
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_TT_PEAKBANDWIDTH))
	{
		m_bTTPeakRate = TRUE;
		m_dwTTPeakRate = TOKBS(m_spData->m_ddTTPeakBandWidth.LowPart);
	}
	else
		m_bTTPeakRate = FALSE;

	// flows
	if(m_spData->GetFlags(ATTR_FLAG_LOAD, ACS_PAF_TT_FLOWS))
	{
		m_bTTFlows = TRUE;
		m_dwTTFlows = m_spData->m_dwTTFlows;
	}
	else
		m_bTTFlows = FALSE;

	CACSPage::OnInitDialog();

	GetDlgItem(IDC_EDIT_PF_DATARATE)->EnableWindow(m_bPFDataRate);
	GetDlgItem(IDC_EDIT_PF_PEAKRATE)->EnableWindow(m_bPFPeakRate);
	GetDlgItem(IDC_EDIT_PF_DURATION)->EnableWindow(m_bPFDuration);
	GetDlgItem(IDC_EDIT_TT_DATARATE)->EnableWindow(m_bTTDataRate);
	GetDlgItem(IDC_EDIT_TT_PEAKRATE)->EnableWindow(m_bTTPeakRate);
	GetDlgItem(IDC_EDIT_TT_FLOWS)->EnableWindow(m_bTTFlows);

	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgTraffic::OnSelchangeCombodirectioin() 
{
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgTraffic::OnSelchangeComboservicelevel() 
{
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgTraffic::OnChangeEditPfDatarate() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgTraffic::OnChangeEditPfDuration() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
}

void CPgTraffic::OnChangeEditPfPeakrate() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgTraffic::OnChangeEditTtDatarate() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgTraffic::OnChangeEditTtPeakrate() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();	
}

void CPgTraffic::OnChangeEditTtFlows() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CACSPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	SetModified();
	
}

void CPgTraffic::OnCheckPfDatarate() 
{
	// TODO: Add your control notification handler code here
	SetModified();

	CButton*	pButton = (CButton*)GetDlgItem(IDC_CHECK_PF_DATARATE);
	GetDlgItem(IDC_EDIT_PF_DATARATE)->EnableWindow(pButton->GetCheck());
}

void CPgTraffic::OnCheckPfPeakrate() 
{
	// TODO: Add your control notification handler code here
	SetModified();
	
	CButton*	pButton = (CButton*)GetDlgItem(IDC_CHECK_PF_PEAKRATE);
	GetDlgItem(IDC_EDIT_PF_PEAKRATE)->EnableWindow(pButton->GetCheck());
}

void CPgTraffic::OnCheckPfDuration() 
{
	// TODO: Add your control notification handler code here
	SetModified();
	
	CButton*	pButton = (CButton*)GetDlgItem(IDC_CHECK_PF_DURATION);
	GetDlgItem(IDC_EDIT_PF_DURATION)->EnableWindow(pButton->GetCheck());
}

void CPgTraffic::OnCheckTtDatarate() 
{
	// TODO: Add your control notification handler code here
	SetModified();
	
	CButton*	pButton = (CButton*)GetDlgItem(IDC_CHECK_TT_DATARATE);
	GetDlgItem(IDC_EDIT_TT_DATARATE)->EnableWindow(pButton->GetCheck());
}

void CPgTraffic::OnCheckTtFlows() 
{
	// TODO: Add your control notification handler code here
	SetModified();

	CButton*	pButton = (CButton*)GetDlgItem(IDC_CHECK_TT_FLOWS);
	GetDlgItem(IDC_EDIT_TT_FLOWS)->EnableWindow(pButton->GetCheck());
}


void CPgTraffic::OnCheckTtPeakrate() 
{
	// TODO: Add your control notification handler code here
	SetModified();
	
	CButton*	pButton = (CButton*)GetDlgItem(IDC_CHECK_TT_PEAKRATE);
	GetDlgItem(IDC_EDIT_TT_PEAKRATE)->EnableWindow(pButton->GetCheck());
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\about.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    about.h
     prototypes for the IAbout interface for MMC

    FILE HISTORY:
    
*/

#ifndef _ABOUT_H
#define _ABOUT_H

class CAbout : 
    public ISnapinAbout,
    public CComObjectRoot
{
public:
    CAbout();
    ~CAbout();

public:
//DECLARE_REGISTRY(CSnapin, _T("Snapin.About.1"), _T("Snapin.About"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage, 
                                    HBITMAP* hSmallImageOpen, 
                                    HBITMAP* hLargeImage, 
                                    COLORREF* cLargeMask);

// Must override
protected:
    virtual UINT GetAboutDescriptionId() = 0;
    virtual UINT GetAboutProviderId() = 0;
    virtual UINT GetAboutVersionId() = 0;
    virtual UINT GetAboutIconId() = 0;

    // helpers for the GetStaticFolderImage
    virtual UINT GetSmallRootId() = 0;
    virtual UINT GetSmallOpenRootId() = 0;
    virtual UINT GetLargeRootId() = 0;
    virtual COLORREF GetLargeColorMask() = 0;

private:
    HBITMAP m_hSmallImage;
    HBITMAP m_hSmallImageOpen;
    HBITMAP m_hLargeImage;
    HICON   m_hAppIcon;
        
// Internal functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\about.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
    about.cpp
    base class for the IAbout interface for MMC

    FILE HISTORY:
    
*/

#include <stdafx.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CAbout);

CAbout::CAbout() : 
    m_hSmallImage(NULL),
    m_hSmallImageOpen(NULL),
    m_hLargeImage(NULL),
    m_hAppIcon(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CAbout);
}


CAbout::~CAbout()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CAbout);
    if (m_hSmallImage)
    {
        DeleteObject(m_hSmallImage);
    }

    if (m_hSmallImageOpen)
    {
        DeleteObject(m_hSmallImageOpen);
    }

    if (m_hLargeImage)
    {
        DeleteObject(m_hLargeImage);
    }

    if (m_hAppIcon)
    {
        DeleteObject(m_hAppIcon);
    }
}

/*!--------------------------------------------------------------------------
    CAbout::AboutHelper
        Helper to get information from resource file
    Author:
 ---------------------------------------------------------------------------*/
HRESULT 
CAbout::AboutHelper
(
    UINT        nID, 
    LPOLESTR*   lpPtr
)
{
    if (lpPtr == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {

        s.LoadString(nID);
        *lpPtr = reinterpret_cast<LPOLESTR>
                 (CoTaskMemAlloc((s.GetLength() + 1)* sizeof(wchar_t)));

        if (*lpPtr == NULL)
            return E_OUTOFMEMORY;

        lstrcpy(*lpPtr, (LPCTSTR)s);
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CAbout::GetSnapinDescription
        MMC calls this to get the snapin's description
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetSnapinDescription
(
    LPOLESTR* lpDescription
)
{
    return AboutHelper(GetAboutDescriptionId(), lpDescription);
}

/*!--------------------------------------------------------------------------
    CAbout::GetProvider
        MMC calls this to get the snapin's provider
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetProvider
(
    LPOLESTR* lpName
)
{
    return AboutHelper(GetAboutProviderId(), lpName);
}

/*!--------------------------------------------------------------------------
    CAbout::AboutHelper
        MMC calls this to get the snapin's version
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetSnapinVersion
(
    LPOLESTR* lpVersion
)
{
    return AboutHelper(GetAboutVersionId(), lpVersion);
}

/*!--------------------------------------------------------------------------
    CAbout::GetSnapinImage
        MMC calls this to get the snapin's icon
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetSnapinImage
(
    HICON* hAppIcon
)
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (NULL == m_hAppIcon)
    {
        m_hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(GetAboutIconId()));
    }
    *hAppIcon = m_hAppIcon;

    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


/*!--------------------------------------------------------------------------
    CAbout::GetStaticFolderImage
        MMC calls this to get the bitmap for the snapin's root node
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetStaticFolderImage
(
    HBITMAP* hSmallImage, 
    HBITMAP* hSmallImageOpen, 
    HBITMAP* hLargeImage, 
    COLORREF* cLargeMask
)
{
    if (NULL == hSmallImage || NULL == hSmallImageOpen || NULL == hLargeImage)
    {
        return E_POINTER;
    }

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (NULL == m_hSmallImage)
    {
        m_hSmallImage = LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(GetSmallRootId()));
    }
    *hSmallImage = m_hSmallImage;

    if (NULL == m_hSmallImageOpen)
    {
        m_hSmallImageOpen = LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(GetSmallOpenRootId()));
    }
    *hSmallImageOpen = m_hSmallImageOpen;

    if (NULL == m_hLargeImage)
    {
        m_hLargeImage = LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(GetLargeRootId()));
    }
    *hLargeImage = m_hLargeImage;

    *cLargeMask = GetLargeColorMask();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\basehand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	node.cpp
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "basehand.h"
#include "util.h"

DEBUG_DECLARE_INSTANCE_COUNTER(CBaseHandler);

/*!--------------------------------------------------------------------------
	CBaseHandler::CBaseHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CBaseHandler::CBaseHandler(ITFSComponentData *pTFSCompData)
	: m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CBaseHandler);

	m_spTFSCompData.Set(pTFSCompData);
	pTFSCompData->GetNodeMgr(&m_spNodeMgr);
}

CBaseHandler::~CBaseHandler()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CBaseHandler);
}

IMPLEMENT_ADDREF_RELEASE(CBaseHandler)

STDMETHODIMP CBaseHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
	*ppv = (LPVOID) this;
	else if (riid == IID_ITFSNodeHandler)
		*ppv = (ITFSNodeHandler *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}


STDMETHODIMP CBaseHandler::DestroyHandler(ITFSNode *pNode)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::Notify
		Implementation of ITFSNodeHandler::Notify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::Notify(ITFSNode *pNode, IDataObject *pDataObject,
								  DWORD dwType, MMC_NOTIFY_TYPE event, 
								  LPARAM arg, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	switch (event)
	{
		case MMCN_PROPERTY_CHANGE:
			hr = OnPropertyChange(pNode, pDataObject, dwType, arg, lParam);
			break;
		
		case MMCN_EXPAND:
			{
				// when MMC calls us to expand the root node, it
				// hands us the scopeID.  We need to save it off here.
				SPITFSNode spRootNode;
				m_spNodeMgr->GetRootNode(&spRootNode);
				if (pNode == spRootNode)
					pNode->SetData(TFS_DATA_SCOPEID, lParam);

				// now walk the list of children for this node and 
				// show them (they may have been added to the internal tree,
				// but not the UI before this node was expanded 
				SPITFSNodeEnum spNodeEnum;
		        ITFSNode * pCurrentNode;
				ULONG nNumReturned = 0;

		        pNode->GetEnum(&spNodeEnum);

				spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
				while (nNumReturned)
				{
					if (pCurrentNode->IsVisible() && !pCurrentNode->IsInUI())
						pCurrentNode->Show();

					pCurrentNode->Release();
					spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
				}

				// Now call the notification handler for specific functionality
				hr = OnExpand(pNode, pDataObject, dwType, arg, lParam);
			}
			break;
		
        case MMCN_DELETE:
			hr = OnDelete(pNode, arg, lParam);
			break;

        case MMCN_RENAME:
			hr = OnRename(pNode, arg, lParam);
			break;

/*		case MMCN_CONTEXTMENU:
			hr = OnContextMenu(pNode, arg, lParam);
			break;
*/
        case MMCN_REMOVE_CHILDREN:
            hr = OnRemoveChildren(pNode, pDataObject, arg, lParam);
            break;

		case MMCN_EXPANDSYNC:
            hr = OnExpandSync(pNode, pDataObject, arg, lParam);
			break;

        case MMCN_BTN_CLICK:
			switch (lParam)
			{
				case MMC_VERB_COPY:
					hr = OnVerbCopy(pNode, arg, lParam);
					break;
				case MMC_VERB_PASTE:
					hr = OnVerbPaste(pNode, arg, lParam);
					break;
				case MMC_VERB_DELETE:
					hr = OnVerbDelete(pNode, arg, lParam);
					break;
				case MMC_VERB_PROPERTIES:
					hr = OnVerbProperties(pNode, arg, lParam);
					break;
				case MMC_VERB_RENAME:
					hr = OnVerbRename(pNode, arg, lParam);
					break;
				case MMC_VERB_REFRESH:
					hr = OnVerbRefresh(pNode, arg, lParam);
					break;
				case MMC_VERB_PRINT:
					hr = OnVerbPrint(pNode, arg, lParam);
					break;
			};
        break;

        case MMCN_RESTORE_VIEW:
            hr = OnRestoreView(pNode, arg, lParam);
            break;

        default:
			Panic1("Uknown event in CBaseHandler::Notify! 0x%x", event);  // Handle new messages
			hr = S_FALSE;
			break;

	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::CreatePropertyPages
		Implementation of ITFSNodeHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::CreatePropertyPages(ITFSNode *pNode,
											   LPPROPERTYSHEETCALLBACK lpProvider, 
											   LPDATAOBJECT pDataObject, 
											   LONG_PTR handle, 
											   DWORD dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;

	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		SPITFSNode              spRootNode;
		SPITFSNodeHandler       spHandler;
			
		// get the root node
		m_spNodeMgr->GetRootNode(&spRootNode);
		spRootNode->GetHandler(&spHandler);
		spHandler->CreatePropertyPages(spRootNode, lpProvider, pDataObject,
									   handle, dwType);
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::HasPropertyPages(ITFSNode *pNode,
											LPDATAOBJECT pDataObject, 
											DATA_OBJECT_TYPES       type, 
											DWORD                           dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		
		SPITFSNode              spRootNode;
		SPITFSNodeHandler       spHandler;
			
		// get the root node
		m_spNodeMgr->GetRootNode(&spRootNode);
		spRootNode->GetHandler(&spHandler);
		hr = spHandler->HasPropertyPages(spRootNode, pDataObject, type, dwType);
	}
	else
	{
		// we have no property pages in the normal case
		hr = S_FALSE;
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::OnAddMenuItems(ITFSNode *pNode,
										  LPCONTEXTMENUCALLBACK pContextMenuCallback, 
										  LPDATAOBJECT lpDataObject, 
										  DATA_OBJECT_TYPES type, 
										  DWORD dwType,
										  long *pInsertionAllowed)
{
	return S_FALSE;
}


/*!--------------------------------------------------------------------------
	CBaseHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::OnCommand(ITFSNode *pNode,
									 long nCommandId, 
									 DATA_OBJECT_TYPES      type, 
									 LPDATAOBJECT pDataObject, 
									 DWORD  dwType)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR)CBaseHandler::GetString(ITFSNode *pNode, int nCol)
{
	return _T("Foo");
}

/*!--------------------------------------------------------------------------
	CBaseHandler::UserNotify
		Implememntation of ITFSNodeHandler::UserNotify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::UserNotify(ITFSNode *pNode, LPARAM dwParam1, LPARAM dwParam2)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::OnCreateDataObject
		Implementation of ITFSNodeHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	// this relies on the ComponentData to do this work
	return S_FALSE;
}


/*!--------------------------------------------------------------------------
	CBaseHandler::CreateNodeId2
		Implementation of ITFSNodeHandler::CreateNodeId2
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::CreateNodeId2(ITFSNode * pNode, BSTR * pbstrId, DWORD * pdwFlags)
{
    HRESULT hr = S_FALSE;
	CString strId;

    COM_PROTECT_TRY
    {
        if (pbstrId == NULL) 
            return hr;

        // call the handler function to get the data
        hr = OnCreateNodeId2(pNode, strId, pdwFlags);
        if (SUCCEEDED(hr) && hr != S_FALSE)
        {
            *pbstrId = ::SysAllocString((LPOLESTR) (LPCTSTR) strId);
        }
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
	CBaseHandler Notifications
 ---------------------------------------------------------------------------*/

HRESULT CBaseHandler::OnPropertyChange(ITFSNode *pNode, LPDATAOBJECT pDataobject, DWORD dwType, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_PROPERTY_CHANGE) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnDelete(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_DELETE) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnRename(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_RENAME) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnExpand(ITFSNode *pNode, LPDATAOBJECT pDataObject, DWORD dwType, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_EXPAND) received\n");
	return hrOK;
}

HRESULT CBaseHandler::OnRemoveChildren(ITFSNode *pNode, LPDATAOBJECT pDataObject, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_REMOVECHILDREN) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnExpandSync(ITFSNode *pNode, LPDATAOBJECT pDataObject, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_EXPANDSYNC) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnContextMenu(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_CONTEXTMENU) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbCopy(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_COPY) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbPaste(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_PASTE) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbDelete(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_DELETE) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbProperties(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_PROPERTIES) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbRename(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_RENAME) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbRefresh(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_REFRESH) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbPrint(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_PRINT) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnRestoreView(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_RESTORE_VIEW) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * pdwFlags)
{
	return S_FALSE;
}

DEBUG_DECLARE_INSTANCE_COUNTER(CBaseResultHandler);

/*---------------------------------------------------------------------------
	CBaseResultHandler implementation
 ---------------------------------------------------------------------------*/
CBaseResultHandler::CBaseResultHandler(ITFSComponentData *pTFSCompData)
    : m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CBaseResultHandler);

	m_spTFSComponentData.Set(pTFSCompData);
	pTFSCompData->GetNodeMgr(&m_spResultNodeMgr);

	m_nColumnFormat = LVCFMT_LEFT; // default column alignment
	m_pColumnStringIDs = NULL;
	m_pColumnWidths = NULL;

    m_fMessageView = FALSE;
}

CBaseResultHandler::~CBaseResultHandler()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CBaseResultHandler);
}

IMPLEMENT_ADDREF_RELEASE(CBaseResultHandler)

STDMETHODIMP CBaseResultHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
	*ppv = (LPVOID) this;
	else if (riid == IID_ITFSResultHandler)
		*ppv = (ITFSResultHandler *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}

STDMETHODIMP CBaseResultHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::Notify
		Implementation of ITFSResultHandler::Notify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::Notify
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie,
	LPDATAOBJECT	pDataObject, 
	MMC_NOTIFY_TYPE	event, 
	LPARAM			arg, 
	LPARAM			param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    pComponent->SetCurrentDataObject(pDataObject);

    COM_PROTECT_TRY
    {
        switch(event)
	    {
		    case MMCN_PROPERTY_CHANGE:
			    hr = OnResultPropertyChange(pComponent, pDataObject, cookie, arg, param);
			    break;

		    case MMCN_ACTIVATE:
			    hr = OnResultActivate(pComponent, cookie, arg, param);
			    break;

		    case MMCN_CLICK:
			    hr = OnResultItemClkOrDblClk(pComponent, cookie, arg, param, FALSE);
			    break;

		    case MMCN_COLUMN_CLICK:
			    hr = OnResultColumnClick(pComponent, arg, (BOOL)param);
			    break;
                
            case MMCN_COLUMNS_CHANGED:
                hr = OnResultColumnsChanged(pComponent, pDataObject,
                                            (MMC_VISIBLE_COLUMNS *) param);
                break;

		    case MMCN_DBLCLICK:
			    hr = OnResultItemClkOrDblClk(pComponent, cookie, arg, param, TRUE);
			    break;
		    
            case MMCN_SHOW:
                {
                    CWaitCursor wait;
			        hr = OnResultShow(pComponent, cookie, arg, param);
                }
			    break;

		    case MMCN_SELECT:
			    hr = OnResultSelect(pComponent, pDataObject, cookie, arg, param);
			    break;

		    case MMCN_INITOCX:
			    hr = OnResultInitOcx(pComponent, pDataObject, cookie, arg, param);
			    break;

            case MMCN_MINIMIZED:
			    hr = OnResultMinimize(pComponent, cookie, arg, param);
			    break;

		    case MMCN_DELETE:
			    hr = OnResultDelete(pComponent, pDataObject, cookie, arg, param);
			    break;

		    case MMCN_RENAME:
			    hr = OnResultRename(pComponent, pDataObject, cookie, arg, param);
			    break;

            case MMCN_REFRESH:
                hr = OnResultRefresh(pComponent, pDataObject, cookie, arg, param);
                break;

            case MMCN_CONTEXTHELP:
                hr = OnResultContextHelp(pComponent, pDataObject, cookie, arg, param);
                break;

            case MMCN_QUERY_PASTE:
                hr = OnResultQueryPaste(pComponent, pDataObject, cookie, arg, param);
                break;

            case MMCN_BTN_CLICK:
			    switch (param)
			    {
				    case MMC_VERB_COPY:
					    OnResultVerbCopy(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_PASTE:
					    OnResultVerbPaste(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_DELETE:
					    OnResultVerbDelete(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_PROPERTIES:
					    OnResultVerbProperties(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_RENAME:
					    OnResultVerbRename(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_REFRESH:
					    OnResultVerbRefresh(pComponent, cookie, arg, param);
					    break;
				    
				    case MMC_VERB_PRINT:
					    OnResultVerbPrint(pComponent, cookie, arg, param);
					    break;

				    default:
					    break;
			    }
			    break;

            case MMCN_RESTORE_VIEW:
                hr = OnResultRestoreView(pComponent, cookie, arg, param);
                break;

		    // Note - Future expansion of notify types possible
		    default:
			    Panic1("Uknown event in CBaseResultHandler::Notify! 0x%x", event);  // Handle new messages
			    hr = S_FALSE;
			    break;
	    }
    }
    COM_PROTECT_CATCH
    
    pComponent->SetCurrentDataObject(NULL);

    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnUpdateView
		Implementation of ITFSResultHandler::UpdateView
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::UpdateView
(
    ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	LPARAM			data, 
	LPARAM			hint
)
{
	return OnResultUpdateView(pComponent, pDataObject, data, hint);
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::GetString
		Implementation of ITFSResultHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CBaseResultHandler::GetString
(
    ITFSComponent * pComponent, 
	MMC_COOKIE      cookie,
	int	            nCol
)
{
	return NULL;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::CompareItems
		Implementation of ITFSResultHandler::CompareItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) 
CBaseResultHandler::CompareItems
(
    ITFSComponent * pComponent, 
	MMC_COOKIE	    cookieA, 
	MMC_COOKIE	    cookieB,
	int		        nCol
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::FindItem
		called when the Virutal listbox needs to find an item.  
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::FindItem
(
    LPRESULTFINDINFO    pFindInfo, 
    int *               pnFoundIndex
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::CacheHint
		called when the virtual listbox has hint information that we can
        pre-load.  The hint is not a guaruntee that the items will be used
        or that items outside this range will be used.
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::SortItems
		called when the Virutal listbox data needs to be sorted
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	return S_FALSE;
}

// task pad functions

/*!--------------------------------------------------------------------------
	CBaseResultHandler::TaskPadNotify
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::TaskPadNotify
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    VARIANT *       arg,
    VARIANT *       param
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::EnumTasks
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::EnumTasks
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    LPOLESTR        pszTaskGroup,
    IEnumTASK **    ppEnumTask
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::TaskPadGetTitle
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::TaskPadGetTitle
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPOLESTR        pszGroup,
    LPOLESTR *      ppszTitle
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::TaskPadGetBackground
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::TaskPadGetBackground
(
    ITFSComponent *		      pComponent,
    MMC_COOKIE				  cookie,
    LPOLESTR				  pszGroup,
	MMC_TASK_DISPLAY_OBJECT * pTDO
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::TaskPadGetDescriptiveText
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::TaskPadGetDescriptiveText
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPOLESTR        pszGroup,
	LPOLESTR *		pszDescriptiveText
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::HasPropertyPages
		Implementation of ITFSResultHandler::HasPropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::HasPropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::CreatePropertyPages
		Implementation of ITFSResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR 				handle
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::Command
		Implementation of ITFSResultHandler::Command
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE  	cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnCreateControlbars
		Implementation of ITFSResultHandler::OnCreateControlbars
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::OnCreateControlbars
(
    ITFSComponent * pComponent, 
	LPCONTROLBAR pControlBar
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ControlbarNotify
		Implementation of ITFSResultHandler::ControlbarNotify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::ControlbarNotify
(
    ITFSComponent * pComponent, 
	MMC_NOTIFY_TYPE event, 
	LPARAM			arg, 
	LPARAM			param
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::UserResultNotify
		Implememntation of ITFSNodeHandler::UserResultNotify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::UserResultNotify
(
	ITFSNode *	pNode, 
	LPARAM		dwParam1, 
	LPARAM		dwParam2
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseResultHandler::OnCreateDataObject(ITFSComponent *pComponent, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	// this relies on the ComponentData to do this work
	return S_FALSE;
}


/*---------------------------------------------------------------------------
	CBaseResultHandler Notifications
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultPropertyChange(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
	Trace0("IComponent::Notify(MMCN_PROPERTY_CHANGE) received\n");
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultUpdateView
		Implementation of ITFSResultHandler::OnResultUpdateView
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM          data, 
    LPARAM          hint
)
{
    SPITFSNode spSelectedNode;
    pComponent->GetSelectedNode(&spSelectedNode);

	if (hint == RESULT_PANE_DELETE_ALL)
	{
        if (spSelectedNode == NULL)
		    return S_OK; // no selection for our IComponentData

        //
		// data contains the container whose result pane has to be refreshed
		//
		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(data);
		Assert(pNode != NULL);
		
		//
		// do it only if selected, if not, reselecting will do a delete/enumeration
		//
		if (spSelectedNode == pNode && !m_fMessageView)
		{
			SPIResultData spResultData;
            pComponent->GetResultData(&spResultData);

            Assert(spResultData != NULL);
			spResultData->DeleteAllRsltItems();
		}
	}
	else 
	if (hint == RESULT_PANE_ADD_ALL)
	{
        if (spSelectedNode == NULL)
		    return S_OK; // no selection for our IComponentData

        //
		// data contains the container whose result pane has to be refreshed
		//
		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(data);
		Assert(pNode != NULL);
		
		//
		// do it only if selected, if not, reselecting will do a delete/enumeration
		//
		if (spSelectedNode == pNode)
		{
			SPIResultData spResultData;
            pComponent->GetResultData(&spResultData);

            Assert(spResultData != NULL);

			//
			// update all the nodes in the result pane
			//
            SPITFSNodeEnum spNodeEnum;
            ITFSNode * pCurrentNode;
            ULONG nNumReturned = 0;

            pNode->GetEnum(&spNodeEnum);

			spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
            while (nNumReturned)
			{
				// All containers go into the scope pane and automatically get 
				// put into the result pane for us by the MMC
				//
				if (!pCurrentNode->IsContainer())
				{
					AddResultPaneItem(pComponent, pCurrentNode);
				}
    
                pCurrentNode->Release();
                spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
			}
		}
	}
	else 
	if (hint == RESULT_PANE_REPAINT)
	{
        if (spSelectedNode == NULL)
		    return S_OK; // no selection for our IComponentData

        //
		// data contains the container whose result pane has to be refreshed
		//
		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(data);
		//if (pNode == NULL)
		//	pContainer = m_pSelectedNode; // passing NULL means apply to the current selection

		//
		// update all the nodes in the result pane
		//
        SPITFSNodeEnum spNodeEnum;
        ITFSNode * pCurrentNode;
        ULONG nNumReturned = 0;

        pNode->GetEnum(&spNodeEnum);

		spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
        while (nNumReturned)
		{
			// All containers go into the scope pane and automatically get 
			// put into the result pane for us by the MMC
			//
			if (!pCurrentNode->IsContainer())
			{
				ChangeResultPaneItem(pComponent, pCurrentNode, RESULT_PANE_CHANGE_ITEM);
			}

            pCurrentNode->Release();
            spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
		}
	}
    else 
	if ( (hint == RESULT_PANE_ADD_ITEM) || (hint == RESULT_PANE_DELETE_ITEM) || (hint & RESULT_PANE_CHANGE_ITEM))
	{
		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(data);
		Assert(pNode != NULL);
		
		//
		// consider only if the parent is selected, otherwise will enumerate later when selected
		//
        SPITFSNode spParentNode;
        pNode->GetParent(&spParentNode);
		if (spSelectedNode == spParentNode)
		{
			if (hint & RESULT_PANE_CHANGE_ITEM)
			{
				ChangeResultPaneItem(pComponent, pNode, hint);
			}
			else if ( hint ==  RESULT_PANE_ADD_ITEM)
			{
				AddResultPaneItem(pComponent, pNode);
			}
			else if ( hint ==  RESULT_PANE_DELETE_ITEM)
			{
				DeleteResultPaneItem(pComponent, pNode);
			}
		}
    }
	else
    if ( hint == RESULT_PANE_SET_VIRTUAL_LB_SIZE )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);

        if (pNode == spSelectedNode)
        {       
            SetVirtualLbSize(pComponent, data);
        }
    }
	else
    if ( hint == RESULT_PANE_CLEAR_VIRTUAL_LB )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);

        if (pNode == spSelectedNode)
        {       
            ClearVirtualLb(pComponent, data);
        }
    }
    else
    if ( hint == RESULT_PANE_EXPAND )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPIConsole spConsole;

        pComponent->GetConsole(&spConsole);
        spConsole->Expand(pNode->GetData(TFS_DATA_SCOPEID), (BOOL)data);

    }
    else
    if (hint == RESULT_PANE_SHOW_MESSAGE)
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);

        BOOL fOldMessageView = (BOOL) data;

        //
		// do it only if selected
		//
		if (spSelectedNode == pNode)
		{
            if (!fOldMessageView)
            {
                SPIConsole spConsole;

                pComponent->GetConsole(&spConsole);
                spConsole->SelectScopeItem(pNode->GetData(TFS_DATA_SCOPEID));
            }
            else
            {
                ShowResultMessage(pComponent, spInternal->m_cookie, NULL, NULL);
            }
        }
    }
    else
    if (hint == RESULT_PANE_CLEAR_MESSAGE)
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);

        BOOL fOldMessageView = (BOOL) data;

		//
		// do it only if selected
		//
		if (spSelectedNode == pNode)
		{
            if (fOldMessageView)
            {
                SPIConsole spConsole;

                pComponent->GetConsole(&spConsole);
                spConsole->SelectScopeItem(pNode->GetData(TFS_DATA_SCOPEID));
            }
        }
    }

    // else if

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ChangeResultPaneItem
		Implementation of ChangeResultPaneItem
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::ChangeResultPaneItem
(
    ITFSComponent * pComponent, 
    ITFSNode *      pNode, 
    LPARAM          changeMask
)
{
    Assert(changeMask & RESULT_PANE_CHANGE_ITEM);
	Assert(pNode != NULL);
	
    HRESULTITEM itemID;
    HRESULT hr = hrOK;
    SPIResultData pResultData;

    CORg ( pComponent->GetResultData(&pResultData) );

	CORg ( pResultData->FindItemByLParam(static_cast<LPARAM>(pNode->GetData(TFS_DATA_COOKIE)), &itemID) );

    RESULTDATAITEM resultItem;
    ZeroMemory(&resultItem, sizeof(RESULTDATAITEM));
	resultItem.itemID = itemID;
	
	if (changeMask & RESULT_PANE_CHANGE_ITEM_DATA)
	{
		resultItem.mask |= RDI_STR;
		resultItem.str = MMC_CALLBACK;
	}
	
	if (changeMask & RESULT_PANE_CHANGE_ITEM_ICON)
	{
		resultItem.mask |= RDI_IMAGE;
		resultItem.nImage = (int)pNode->GetData(TFS_DATA_IMAGEINDEX);
	}
	
	CORg ( pResultData->SetItem(&resultItem) );
	
	CORg ( pResultData->UpdateItem(itemID) );

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::AddResultPaneItem
		Implementation of AddResultPaneItem
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::AddResultPaneItem
(
    ITFSComponent * pComponent, 
    ITFSNode *      pNode
)
{
	Assert(pNode != NULL);

    RESULTDATAITEM dataitemResult;
    HRESULT hr = hrOK;

    SPIResultData pResultData;

    CORg ( pComponent->GetResultData(&pResultData) );

    ZeroMemory(&dataitemResult, sizeof(dataitemResult));
        
    dataitemResult.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    dataitemResult.str = MMC_CALLBACK;
    
    dataitemResult.mask |= SDI_IMAGE;
    dataitemResult.nImage = (int)pNode->GetData(TFS_DATA_IMAGEINDEX);

    dataitemResult.lParam = static_cast<LPARAM>(pNode->GetData(TFS_DATA_COOKIE));

    CORg ( pResultData->InsertItem(&dataitemResult) );

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::DeleteResultPaneItem
		Implementation of DeleteResultPaneItem
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::DeleteResultPaneItem
(
    ITFSComponent * pComponent, 
    ITFSNode *      pNode
)
{
	Assert(pNode != NULL);

    HRESULT hr = hrOK;
	HRESULTITEM itemID;
	
    SPIResultData pResultData;

    CORg ( pComponent->GetResultData(&pResultData) );

    CORg ( pResultData->FindItemByLParam(static_cast<LPARAM>(pNode->GetData(TFS_DATA_COOKIE)), &itemID) );

	CORg ( pResultData->DeleteItem(itemID, 0 /* all cols */) );

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::SetVirtualLbSize
		Sets the virtual listbox count.  Over-ride this if you need to 
        specify and options.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::SetVirtualLbSize
(
    ITFSComponent * pComponent,
    LONG_PTR        data
)
{
    HRESULT hr = hrOK;
    SPIResultData spResultData;

    CORg (pComponent->GetResultData(&spResultData));

    CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOINVALIDATEALL));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ClearVirtualLb
		Sets the virtual listbox count.  Over-ride this if you need to 
        specify and options.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::ClearVirtualLb
(
    ITFSComponent * pComponent,
    LONG_PTR        data
)
{
    HRESULT hr = hrOK;
    SPIResultData spResultData;

    CORg (pComponent->GetResultData(&spResultData));

    CORg (spResultData->SetItemCount((int) data, 0));

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultActivate
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultActivate(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
	Trace0("IComponent::Notify(MMCN_ACTIVATE) received\n");
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultItemClkOrDblClk
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultItemClkOrDblClk(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM param, BOOL bDoubleClick)
{
	if (!bDoubleClick)
		Trace0("IComponent::Notify(MMCN_CLK) received\n");
	else
		Trace0("IComponent::Notify(MMCN_DBLCLK) received\n");

    // return false so that MMC does the default behavior (open the node);
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultShow(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
        // show the result view message if there is one
        ShowResultMessage(pComponent, cookie, arg, lParam);

		// Show the headers for this nodetype
		LoadColumns(pComponent, cookie, arg, lParam);
		EnumerateResultPane(pComponent, cookie, arg, lParam);

		SortColumns(pComponent);
		
		SPITFSNode spNode;
        m_spResultNodeMgr->FindNode(cookie, &spNode);
	    pComponent->SetSelectedNode(spNode);
    }
    else
    {
		SaveColumns(pComponent, cookie, arg, lParam);
	    pComponent->SetSelectedNode(NULL);
		// Free data associated with the result pane items, because
		// your node is no longer being displayed.
		// Note: The console will remove the items from the result pane
    }

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultColumnClick
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultColumnClick(ITFSComponent *pComponent, LPARAM iColumn, BOOL fAscending)
{
	return S_FALSE;
}


/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultColumnsChanged
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultColumnsChanged(ITFSComponent *, LPDATAOBJECT, MMC_VISIBLE_COLUMNS *)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ShowResultMessage
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::ShowResultMessage(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT         hr = hrOK;
    SPIMessageView  spMessageView;
    SPIUnknown      spUnknown;
    SPIConsole      spConsole;
    LPOLESTR        pText = NULL;

    // put up our message text 
    if (m_fMessageView)
    {
        if (pComponent)
        {
            CORg ( pComponent->GetConsole(&spConsole) );

            CORg ( spConsole->QueryResultView(&spUnknown) );

            CORg ( spMessageView.HrQuery(spUnknown) );
        }

        // set the title text
		pText = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR) * (m_strMessageTitle.GetLength() + 1));
        if (pText)
        {
            lstrcpy (pText, m_strMessageTitle);
            CORg(spMessageView->SetTitleText(pText));
            // bugid:148215 vivekk
            CoTaskMemFree(pText);
        }

        // set the body text
		pText = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR) * (m_strMessageBody.GetLength() + 1));
        if (pText)
        {
            lstrcpy (pText, m_strMessageBody);
            CORg(spMessageView->SetBodyText(pText));
            // bugid:148215 vivekk           
            CoTaskMemFree(pText);
        }

        // set the icon
        CORg(spMessageView->SetIcon(m_lMessageIcon));

        COM_PROTECT_ERROR_LABEL;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ShowMessage
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::ShowMessage(ITFSNode * pNode, LPCTSTR pszTitle, LPCTSTR pszBody, IconIdentifier lIcon)
{
    HRESULT             hr = hrOK;
	SPIComponentData	spCompData;
	SPIConsole			spConsole;
    SPIDataObject       spDataObject;
    IDataObject *       pDataObject;
    BOOL                fOldMessageView;
    
    m_strMessageTitle = pszTitle;
    m_strMessageBody = pszBody;
    m_lMessageIcon = lIcon;

    fOldMessageView = m_fMessageView;
    m_fMessageView = TRUE;

    // tell the views to update themselves here
	m_spResultNodeMgr->GetComponentData(&spCompData);

	CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
    spDataObject = pDataObject;

    CORg ( m_spResultNodeMgr->GetConsole(&spConsole) );
	CORg ( spConsole->UpdateAllViews(pDataObject, (LPARAM) fOldMessageView, RESULT_PANE_SHOW_MESSAGE) ); 

COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ClearMessage
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::ClearMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
	SPIComponentData	spCompData;
	SPIConsole			spConsole;
    SPIDataObject       spDataObject;
    IDataObject *       pDataObject;
    BOOL                fOldMessageView;

    fOldMessageView = m_fMessageView;
    m_fMessageView = FALSE;

    // tell the views to update themselves here
	m_spResultNodeMgr->GetComponentData(&spCompData);

	CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
    spDataObject = pDataObject;

    CORg ( m_spResultNodeMgr->GetConsole(&spConsole) );
	CORg ( spConsole->UpdateAllViews(pDataObject, (LPARAM) fOldMessageView, RESULT_PANE_CLEAR_MESSAGE) ); 

COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::LoadColumns
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::LoadColumns(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIHeaderCtrl spHeaderCtrl;
	pComponent->GetHeaderCtrl(&spHeaderCtrl);

	CString str;
	int i = 0;

	if (!m_pColumnStringIDs)
		return hrOK;

    if (!m_fMessageView)
    {
	    while (TRUE)
	    {
		    int nColumnWidth = AUTO_WIDTH;

		    if ( 0 == m_pColumnStringIDs[i] )
			    break;
		    
		    str.LoadString(m_pColumnStringIDs[i]);
		    
		    if (m_pColumnWidths)
			    nColumnWidth = m_pColumnWidths[i];

		    spHeaderCtrl->InsertColumn(i, 
								       const_cast<LPTSTR>((LPCWSTR)str), 
								       m_nColumnFormat,
								       nColumnWidth);
		    i++;
	    }
    }

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::SaveColumns
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::SaveColumns(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::SortColumns
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::SortColumns(ITFSComponent *pComponent)
{
	return S_FALSE;
}


/*!--------------------------------------------------------------------------
	CBaseResultHandler::EnumerateResultPane
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::EnumerateResultPane(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode spContainer;
    m_spResultNodeMgr->FindNode(cookie, &spContainer);

	//
	// Walk the list of children to see if there's anything
	// to put in the result pane
	//
    SPITFSNodeEnum spNodeEnum;
    ITFSNode * pCurrentNode;
    ULONG nNumReturned = 0;

    spContainer->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		//
		// All containers go into the scope pane and automatically get 
		// put into the result pane for us by the MMC
		//
		if (!pCurrentNode->IsContainer() && pCurrentNode->IsVisible())
		{
			AddResultPaneItem(pComponent, pCurrentNode);
		}

        pCurrentNode->Release();
        spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
	}

	return hrOK;
}
 
/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultSelect
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	HRESULT hr = hrOK;
	SPIConsoleVerb spConsoleVerb;
	
	CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

   	// Default is to turn everything off
	spConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
    spConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultInitOcx
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultInitOcx(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    // arg - not used
    // param - contains IUnknown to the OCX

	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::FIsTaskpadPreferred
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::FIsTaskpadPreferred(ITFSComponent *pComponent)
{
    HRESULT     hr = hrOK;
    SPIConsole  spConsole;

    pComponent->GetConsole(&spConsole);
    hr = spConsole->IsTaskpadViewPreferred();

//Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::DoTaskpadResultSelect
		Handlers with taskpads should override the OnResultSelect and call 
        this to handle setting of the selected node.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::DoTaskpadResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam, BOOL bTaskPadView)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    SPITFSNode spNode, spSelectedNode;
	HRESULT hr = hrOK;

    // if this node is being selected then set the selected node.
    // this node with a taskpad gets the MMCN_SHOW when the node is
    // de-selected, so that will set the selected node to NULL.
    if ( (HIWORD(arg) == TRUE) &&
          bTaskPadView )
    {
        m_spResultNodeMgr->FindNode(cookie, &spNode);
        pComponent->GetSelectedNode(&spSelectedNode);

        // in the normal case MMC will call whichever node is selected to 
        // notify that is being de-selected.  In this case our handler will
        // set the selected node to NULL.  If the selected node is not null then
        // we are just being notified of something like a selection for a context
        // menu...
        if (!spSelectedNode)
            pComponent->SetSelectedNode(spNode);
    }

    // call the base class to handle anything else
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnGetResultViewType
        MMC calls this to get the result view information		
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    HRESULT hr = S_FALSE;

    //
	// use the MMC default result view if no message is specified.  
    // Multiple selection, or virtual listbox, override this function.
	// See MMC sample code for example.  The Message view uses an OCX...
	//
    if (m_fMessageView)
    {
        // create the message view thingie
        *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

        LPOLESTR psz = NULL;
        StringFromCLSID(CLSID_MessageView, &psz);

        USES_CONVERSION;

        if (psz != NULL)
        {
            *ppViewType = psz;
            hr = S_OK;
        }
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::GetVirtualString
        called when the virtual listbox needs information on an index
	Author: EricDav
 ---------------------------------------------------------------------------*/
LPCWSTR CBaseResultHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
    return NULL;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::GetVirtualImage
        called when the virtual listbox needs an image index for an item
	Author: EricDav
 ---------------------------------------------------------------------------*/
int CBaseResultHandler::GetVirtualImage
(
    int     nIndex
)
{
    return 0;
}


HRESULT CBaseResultHandler::OnResultMinimize(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_MINIMIZE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultDelete(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_DELETE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultRename(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_RENAME) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_REFRESH) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultContextHelp(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_CONTEXTHELP) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultQueryPaste(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_QUERY_PASTE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbCopy(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_COPY) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbPaste(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_PASTE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbDelete(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_DELETE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbProperties(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_PROPERTIES) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbRename(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_RENAME) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbRefresh(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_REFRESH) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbPrint(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_PRINT) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultRestoreView(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_RESTORE_VIEW) received\n");
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\acssnap\traffic.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       traffic.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_TRAFFIC_H__C0DCD9E9_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
#define AFX_TRAFFIC_H__C0DCD9E9_64FE_11D1_855B_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Traffic.h : header file
//

#include "resource.h"
#include "acs.h"

class CACSPolicyElement;
 
/////////////////////////////////////////////////////////////////////////////
// CPgTraffic dialog

class CPgTraffic : public CACSPage
{
	DECLARE_DYNCREATE(CPgTraffic)

// Construction
private:
	CPgTraffic();
public:
	CPgTraffic(CACSPolicyElement* pData);
	~CPgTraffic();

// Dialog Data
	//{{AFX_DATA(CPgTraffic)
	enum { IDD = IDD_TRAFFIC };
	DWORD	m_dwPFDataRate;
	DWORD	m_dwPFDuration;
	DWORD	m_dwPFPeakRate;
	DWORD	m_dwTTDataRate;
	DWORD	m_dwTTFlows;
	BOOL	m_bPFDataRate;
	BOOL	m_bPFPeakRate;
	BOOL	m_bTTDataRate;
	BOOL	m_bTTFlows;
	BOOL	m_bPFDuration;
	BOOL	m_bTTPeakRate;
	DWORD	m_dwTTPeakRate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgTraffic)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void	DataInit();
	// Generated message map functions
	//{{AFX_MSG(CPgTraffic)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeCombodirectioin();
	afx_msg void OnSelchangeComboservicelevel();
	afx_msg void OnChangeEditPfDatarate();
	afx_msg void OnChangeEditPfDuration();
	afx_msg void OnChangeEditPfPeakrate();
	afx_msg void OnChangeEditTtDatarate();
	afx_msg void OnChangeEditTtFlows();
	afx_msg void OnCheckPfDatarate();
	afx_msg void OnCheckPfPeakrate();
	afx_msg void OnCheckTtDatarate();
	afx_msg void OnCheckTtFlows();
	afx_msg void OnCheckPfDuration();
	afx_msg void OnCheckTtPeakrate();
	afx_msg void OnChangeEditTtPeakrate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CComPtr<CACSPolicyElement>		m_spData;
	CStrBox<CComboBox>*				m_pDirection;
	CStrBox<CComboBox>*				m_pServiceType;
	CStrArray						m_aDirections;
	CStrArray						m_aServiceTypes;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRAFFIC_H__C0DCD9E9_64FE_11D1_855B_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\basehand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	basehand.h
        base classes for node handlers.
		
    FILE HISTORY:
	
*/

#ifndef _BASEHAND_H
#define _BASEHAND_H

#ifndef _TFSINT_H
#include "tfsint.h"
#endif

#ifndef _TFSNODE_H
#include "tfsnode.h"
#endif

/*---------------------------------------------------------------------------
	Class:  CBaseHandler

	This class provides functionality for handling notification from the
	IComponentData interface on a node (or handler) basis.  The 
	CBaseResultHandler class handles notifcation to the IConponent interface
	that a snapin exposes.
 ---------------------------------------------------------------------------*/

#define OVERRIDE_BaseHandlerNotify_OnPropertyChange() \
 virtual HRESULT OnPropertyChange(ITFSNode *pNode,LPDATAOBJECT pdo,DWORD dwType,LPARAM arg,LPARAM lParam) \
												
#define OVERRIDE_BaseHandlerNotify_OnDelete() \
 virtual HRESULT OnDelete(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnRename() \
 virtual HRESULT OnRename(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnRemoveChildren() \
	virtual HRESULT OnRemoveChildren(ITFSNode *pNode,LPDATAOBJECT pdo,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnExpandSync() \
	virtual HRESULT OnExpandSync(ITFSNode *pNode,LPDATAOBJECT pdo,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnExpand() \
 virtual HRESULT OnExpand(ITFSNode *pNode,LPDATAOBJECT pdo, DWORD dwType, LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnContextMenu() \
 virtual HRESULT OnContextMenu(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbCopy() \
 virtual HRESULT OnVerbCopy(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbPaste() \
 virtual HRESULT OnVerbPaste(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbDelete() \
 virtual HRESULT OnVerbDelete(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbProperties() \
 virtual HRESULT OnVerbProperties(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbRename() \
 virtual HRESULT OnVerbRename(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbRefresh() \
 virtual HRESULT OnVerbRefresh(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbPrint() \
 virtual HRESULT OnVerbPrint(ITFSNode *pNode,LPARAM arg,LPARAM lParam)              

#define OVERRIDE_BaseHandlerNotify_OnRestoreView() \
 virtual HRESULT OnRestoreView(ITFSNode *pNode,LPARAM arg,LPARAM lParam)              

#define OVERRIDE_BaseHandlerNotify_OnCreateNodeId2() \
 virtual HRESULT OnCreateNodeId2(ITFSNode *pNode,CString & strId,LPDWORD pdwFlags)              

//class TFS_EXPORT_CLASS CBaseHandler :
class CBaseHandler :
	public ITFSNodeHandler
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareITFSNodeHandlerMembers(IMPL)
			
	CBaseHandler(ITFSComponentData *pTFSCompData);
	virtual ~CBaseHandler();

	// Here are the possible notifications
	OVERRIDE_BaseHandlerNotify_OnPropertyChange();
	OVERRIDE_BaseHandlerNotify_OnDelete();
	OVERRIDE_BaseHandlerNotify_OnRename();
    OVERRIDE_BaseHandlerNotify_OnRemoveChildren();
	OVERRIDE_BaseHandlerNotify_OnExpandSync();
	OVERRIDE_BaseHandlerNotify_OnExpand();
	OVERRIDE_BaseHandlerNotify_OnContextMenu();
	OVERRIDE_BaseHandlerNotify_OnVerbCopy();
	OVERRIDE_BaseHandlerNotify_OnVerbPaste();
	OVERRIDE_BaseHandlerNotify_OnVerbDelete();
	OVERRIDE_BaseHandlerNotify_OnVerbProperties();
	OVERRIDE_BaseHandlerNotify_OnVerbRename();
	OVERRIDE_BaseHandlerNotify_OnVerbRefresh();
	OVERRIDE_BaseHandlerNotify_OnVerbPrint();
	OVERRIDE_BaseHandlerNotify_OnRestoreView();
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

protected:
	SPITFSComponentData     m_spTFSCompData;
	SPITFSNodeMgr           m_spNodeMgr;

	long                    m_cRef;
};


/*---------------------------------------------------------------------------
	Class:	CBaseResultHandler
 ---------------------------------------------------------------------------*/

#define OVERRIDE_BaseResultHandlerNotify_OnResultActivate() \
	virtual HRESULT OnResultActivate(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultColumnClick() \
	virtual HRESULT OnResultColumnClick(ITFSComponent *, LPARAM, BOOL)

#define OVERRIDE_BaseResultHandlerNotify_OnResultColumnsChanged() \
    virtual HRESULT OnResultColumnsChanged(ITFSComponent *, LPDATAOBJECT, MMC_VISIBLE_COLUMNS *)

#define OVERRIDE_BaseResultHandlerNotify_OnResultDelete() \
	virtual HRESULT OnResultDelete(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultRename() \
	virtual HRESULT OnResultRename(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultRefresh() \
	virtual HRESULT OnResultRefresh(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp() \
	virtual HRESULT OnResultContextHelp(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultQueryPaste() \
	virtual HRESULT OnResultQueryPaste(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange() \
	virtual HRESULT OnResultPropertyChange(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultItemClkOrDblClk() \
	virtual HRESULT OnResultItemClkOrDblClk(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM,BOOL)

#define OVERRIDE_BaseResultHandlerNotify_OnResultMinimize() \
	virtual HRESULT OnResultMinimize(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultSelect() \
	virtual HRESULT OnResultSelect(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultInitOcx() \
	virtual HRESULT OnResultInitOcx(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultShow() \
	virtual HRESULT OnResultShow(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView() \
	virtual HRESULT OnResultUpdateView(ITFSComponent *,LPDATAOBJECT,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbCopy() \
	virtual HRESULT OnResultVerbCopy(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbPaste() \
	virtual HRESULT OnResultVerbPaste(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbDelete() \
	virtual HRESULT OnResultVerbDelete(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbProperties() \
	virtual HRESULT OnResultVerbProperties(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbRename() \
	virtual HRESULT OnResultVerbRename(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbPrint() \
	virtual HRESULT OnResultVerbPrint(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbRefresh() \
	virtual HRESULT OnResultVerbRefresh(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultRestoreView() \
	virtual HRESULT OnResultRestoreView(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

//class TFS_EXPORT_CLASS CBaseResultHandlerNotify :
class CBaseResultHandler :
	public ITFSResultHandler
{
public:
	CBaseResultHandler(ITFSComponentData *pTFSCompData);
	virtual ~CBaseResultHandler();

	DeclareIUnknownMembers(IMPL)
	DeclareITFSResultHandlerMembers(IMPL)

	// Here are the possible notifications
	OVERRIDE_BaseResultHandlerNotify_OnResultActivate();
	OVERRIDE_BaseResultHandlerNotify_OnResultColumnClick();
    OVERRIDE_BaseResultHandlerNotify_OnResultColumnsChanged();
	OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultRename();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();
	OVERRIDE_BaseResultHandlerNotify_OnResultQueryPaste();
	OVERRIDE_BaseResultHandlerNotify_OnResultItemClkOrDblClk();
	OVERRIDE_BaseResultHandlerNotify_OnResultMinimize();
	OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange();
	OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultInitOcx();
    OVERRIDE_BaseResultHandlerNotify_OnResultShow();
	OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

	OVERRIDE_BaseResultHandlerNotify_OnResultVerbCopy();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbPaste();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbProperties();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbRename();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbPrint();
	OVERRIDE_BaseResultHandlerNotify_OnResultRestoreView();
	
	// Over-ride these to provide custom column functionality
	// or custom ways to add things to the result pane
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
	virtual HRESULT EnumerateResultPane(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
	virtual HRESULT SortColumns(ITFSComponent *);
    
    virtual HRESULT SetVirtualLbSize(ITFSComponent * pComponent, LONG_PTR data);
    virtual HRESULT ClearVirtualLb(ITFSComponent * pComponent, LONG_PTR data);

	void SetColumnStringIDs(UINT * pStringIDs) { m_pColumnStringIDs = pStringIDs; }
	void SetColumnWidths(int * pWidths) { m_pColumnWidths = pWidths; }
	void SetColumnFormat(int nColumnFormat) { m_nColumnFormat = nColumnFormat; }

    HRESULT ShowMessage(ITFSNode * pNode, LPCTSTR pszTitle, LPCTSTR pszBody, IconIdentifier lIcon);
    HRESULT ClearMessage(ITFSNode * pNode);

    virtual HRESULT FIsTaskpadPreferred(ITFSComponent *pComponent);
    virtual HRESULT DoTaskpadResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam, BOOL bTaskPadView);

protected:
    HRESULT ChangeResultPaneItem(ITFSComponent *, ITFSNode *, LONG_PTR);
    HRESULT AddResultPaneItem(ITFSComponent *, ITFSNode *);
    HRESULT DeleteResultPaneItem(ITFSComponent *, ITFSNode *);
    HRESULT ShowResultMessage(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam);

    BOOL    IsMessageView() {return m_fMessageView;}

protected:
	SPITFSComponentData     m_spTFSComponentData;
	SPITFSNodeMgr           m_spResultNodeMgr;

private:
	UINT *					m_pColumnStringIDs;
	int *					m_pColumnWidths;
   	int						m_nColumnFormat;

	LONG			        m_cRef;

    // result message view stuff
    BOOL                    m_fMessageView;
    CString                 m_strMessageTitle;
    CString                 m_strMessageBody;
    IconIdentifier          m_lMessageIcon;
};

#endif _BASEHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\busydlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    busydlg.h
	base class for the busy dialog

    FILE HISTORY:
	
*/

#ifndef _BUSYDLG_H
#define _BUSYDLG_H

/////////////////////////////////////////////////////////////////////////////
// CWorkerThread

class CWorkerThread : public CWinThread
{
public:
	CWorkerThread();
	virtual ~CWorkerThread();

	BOOL Start(HWND hWnd);
	virtual BOOL InitInstance() { return TRUE; }	// MFC override
	virtual int Run() { return -1;}					// MFC override

	void Lock() { ::EnterCriticalSection(&m_cs); }
	void Unlock() { ::LeaveCriticalSection(&m_cs); }

	void Abandon();
	BOOL IsAbandoned();

	void AcknowledgeExiting() { VERIFY(0 != ::SetEvent(m_hEventHandle));}

protected:
	virtual void OnAbandon() {}

protected:
	BOOL PostMessageToWnd(UINT Msg, WPARAM wParam, LPARAM lParam);
	void WaitForExitAcknowledge();

private:
	CRITICAL_SECTION		m_cs;	
	HANDLE					m_hEventHandle;

	HWND					m_hWnd;
	BOOL					m_bAbandoned;
};

/////////////////////////////////////////////////////////////////////////////
// CDlgWorkerThread

class CLongOperationDialog; // fwd decl

class CDlgWorkerThread : public CWorkerThread
{
public:
	CDlgWorkerThread();

	BOOL Start(CLongOperationDialog* pDlg);
	virtual int Run();								// MFC override

	DWORD GetError() { return m_dwErr;}

protected:
	virtual void OnDoAction() = 0;

	DWORD m_dwErr;

private:
	BOOL PostMessageToDlg();
};


/////////////////////////////////////////////////////////////////////////////
// CLongOperationDialog dialog

class CLongOperationDialog : public CDialog
{
// Construction
public:
	static UINT s_nNotificationMessage;
	CLongOperationDialog(CDlgWorkerThread* pThreadObj, UINT nAviID = -1);
	virtual ~CLongOperationDialog();

	BOOL LoadTitleString(UINT nID);
	BOOL LoadDescriptionString(UINT nID);

    void EnableCancel(BOOL bCancel) { m_bCancel = bCancel; }

    CDlgWorkerThread* GetThreadObj() 
	{
		ASSERT(m_pThreadObj != NULL);
		return m_pThreadObj;
	}

	UINT m_nAviID;
	CString m_strTitle;
    CString m_strDescription;
    BOOL m_bAbandoned;

	afx_msg LONG OnNotificationMessage( WPARAM wParam, LPARAM lParam); 

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	virtual void OnCancel();

	DECLARE_MESSAGE_MAP()

private:
	CDlgWorkerThread*   m_pThreadObj;
    BOOL                m_bCancel;
};

#endif _BUSYDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\busydlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    busydlg.cpp
	base class for the busy dialog

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "busydlg.h"

/////////////////////////////////////////////////////////////////////////////
// CWorkerThread

CWorkerThread::CWorkerThread()
{
	m_bAutoDelete = FALSE;
	m_bAbandoned = FALSE;
	m_hEventHandle = NULL;
	::InitializeCriticalSection(&m_cs);
	m_hWnd = NULL; 
}

CWorkerThread::~CWorkerThread()
{
	::DeleteCriticalSection(&m_cs);
	if (m_hEventHandle != NULL)
	{
		VERIFY(::CloseHandle(m_hEventHandle));
		m_hEventHandle = NULL;
	}
}

BOOL CWorkerThread::Start(HWND hWnd)
{
	ASSERT(m_hWnd == NULL);
	ASSERT(::IsWindow(hWnd));
	m_hWnd = hWnd;

	ASSERT(m_hEventHandle == NULL); // cannot call start twice or reuse the same C++ object
	m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
	if (m_hEventHandle == NULL)
		return FALSE;
	return CreateThread();
}

void CWorkerThread::Abandon()
{
	Lock();
	OnAbandon();
	m_bAutoDelete = TRUE;
	m_bAbandoned = TRUE;
	Unlock();
}


BOOL CWorkerThread::IsAbandoned()
{
	Lock();
	BOOL b = m_bAbandoned;
	Unlock();
	return b;
}

BOOL CWorkerThread::PostMessageToWnd(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	BOOL b = IsAbandoned();
	if (b)
		return TRUE; // no need to post
	ASSERT(::IsWindow(m_hWnd));
	return ::PostMessage(m_hWnd, Msg, wParam, lParam);
}

void CWorkerThread::WaitForExitAcknowledge() 
{
	BOOL b = IsAbandoned();
	if (b)
		return;
	VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE)); 
}

/////////////////////////////////////////////////////////////////////////////
// CDlgWorkerThread

CDlgWorkerThread::CDlgWorkerThread()
{
	m_dwErr = 0x0;
}


BOOL CDlgWorkerThread::Start(CLongOperationDialog* pDlg)
{
	ASSERT(pDlg != NULL);
	HWND hWnd = pDlg->GetSafeHwnd();
	return CWorkerThread::Start(hWnd);
}

BOOL CDlgWorkerThread::PostMessageToDlg()
{
	return PostMessageToWnd(CLongOperationDialog::s_nNotificationMessage,
							(WPARAM)0, (LPARAM)0);
}


int CDlgWorkerThread::Run()
{
	// do the stuff
	OnDoAction();
	VERIFY(PostMessageToDlg());
	WaitForExitAcknowledge();
	//TRACE(_T("exiting\n"));
	return 0;

}


/////////////////////////////////////////////////////////////////////////////
// CLongOperationDialog dialog

UINT CLongOperationDialog::s_nNotificationMessage = WM_USER + 100;

CLongOperationDialog::CLongOperationDialog(CDlgWorkerThread* pThreadObj,
										   UINT nAviID)
	: CDialog(IDD_BUSY, NULL),
      m_bCancel(TRUE)
{
	ASSERT(pThreadObj != NULL);
	m_bAbandoned = TRUE;
	m_pThreadObj = pThreadObj;
	m_nAviID = nAviID;
}

CLongOperationDialog::~CLongOperationDialog()
{
	if(m_pThreadObj != NULL)
	{
		delete m_pThreadObj;
		m_pThreadObj = NULL;
	}
}

BOOL CLongOperationDialog::LoadTitleString(UINT nID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return m_strTitle.LoadString(nID);
}

BOOL CLongOperationDialog::LoadDescriptionString(UINT nID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return m_strDescription.LoadString(nID);
}

BEGIN_MESSAGE_MAP(CLongOperationDialog, CDialog)
	ON_MESSAGE( CLongOperationDialog::s_nNotificationMessage, OnNotificationMessage )
END_MESSAGE_MAP()


afx_msg LONG CLongOperationDialog::OnNotificationMessage( WPARAM wParam, LPARAM lParam)
{
	TRACE(_T("CLongOperationDialog::OnNotificationMessage()\n"));

	ASSERT(m_pThreadObj != NULL);
	if (m_pThreadObj != NULL)
	{
		m_pThreadObj->AcknowledgeExiting();
		VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_pThreadObj->m_hThread,INFINITE));
		m_bAbandoned = FALSE;
		PostMessage(WM_CLOSE,0,0);
	}
	return 0;
}

BOOL CLongOperationDialog::OnInitDialog() 
{
	TRACE(_T("CLongOperationDialog::OnInitDialog()\n"));

	CDialog::OnInitDialog();
	
	if (!m_strTitle.IsEmpty())
		SetWindowText(m_strTitle);

	if (!m_strDescription.IsEmpty())
		GetDlgItem(IDC_STATIC_DESCRIPTION)->SetWindowText(m_strDescription);

    // load auto play AVI file if needed
	if (m_nAviID != -1)
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		CAnimateCtrl* pAnimate = (CAnimateCtrl*)GetDlgItem(IDC_SEARCH_ANIMATE);
		VERIFY(pAnimate->Open(m_nAviID)); 
	}
	
    if (!m_bCancel)
    {
        // hide the system menu
        DWORD dwWindowStyle = GetWindowLong(GetSafeHwnd(), GWL_STYLE);
        dwWindowStyle &= ~WS_SYSMENU;

        SetWindowLong(GetSafeHwnd(), GWL_STYLE, dwWindowStyle);

        // hide the cancel button
        GetDlgItem(IDCANCEL)->ShowWindow(FALSE);
    }

    // spawn worker thread
	GetThreadObj()->Start(this);
	
	return TRUE;
}

void CLongOperationDialog::OnCancel() 
{
	TRACE(_T("CLongOperationDialog::OnCancel()\n"));
	if (m_bAbandoned)
	{
		m_pThreadObj->Abandon();
		m_pThreadObj = NULL;
	}
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\coldlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	column.h
		Column chooser.
		
    FILE HISTORY:
        
*/

#ifndef _COLDLG_H
#define _COLDLG_H

#ifndef _DIALOG_H
#include "dialog.h"
#endif

#ifndef _LISTCTRL_H
#include "listctrl.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _COLUMN_H
#include "column.h"	// need ContainerColumnInfo
#endif

//----------------------------------------------------------------------------
// Class:       ColumnDlg
//
// This dialog displays all the rows for available for a list-control,
// allowing the user to select which ones should be displayed.
//----------------------------------------------------------------------------

class ColumnDlg : public CBaseDialog
{
public:
	ColumnDlg(CWnd *pParent);

	void	Init(const ContainerColumnInfo *prgColInfo, UINT cColumns,
				 ColumnData *prgColumnData);
	~ColumnDlg( );

	//{{AFX_DATA(ColumnDlg)
	CListBox                 m_lboxDisplayed;
	CListBox                 m_lboxHidden;
	//}}AFX_DATA


	//{{AFX_VIRTUAL(ColumnDlg)
protected:
	virtual VOID                DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL

protected:
    virtual DWORD * GetHelpMap() { return m_dwHelpMap; }
	static DWORD				m_dwHelpMap[];

	const ContainerColumnInfo *	m_pColumnInfo;
	UINT						m_cColumnInfo;
	ColumnData *				m_pColumnData;
	

	VOID MoveItem( INT dir );
	BOOL AddColumnsToList();
	
	static INT CALLBACK
			ColumnCmp(
					  LPARAM                  lParam1,
					  LPARAM                  lParam2,
					  LPARAM                  lParamSort );
	
	//{{AFX_MSG(ColumnDlg)
	virtual BOOL                OnInitDialog( );
	virtual VOID                OnOK();
	afx_msg VOID				OnUseDefaults();
	afx_msg VOID                OnMoveUp();
	afx_msg VOID                OnMoveDown();
	afx_msg VOID                OnAddColumn();
	afx_msg VOID                OnRemoveColumn();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};




#endif _COLDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\cmptrmgr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	cmptrmgr.h
        computer management 

	FILE HISTORY:
        
*/
extern GUID NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\cmptrmgr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	cmptrmgr.cpp
        computer management 

	FILE HISTORY:
        
*/
#include "stdafx.h"
#include <compuuid.h>
#include "cmptrmgr.h"
GUID NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS = structuuidNodetypeServerApps;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\coldlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	column.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tfschar.h"
#include "column.h"
#include "coldlg.h"

//----------------------------------------------------------------------------
// Class:       ColumnDlg
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Function:    ColumnDlg::ColumnDlg
//----------------------------------------------------------------------------

ColumnDlg::ColumnDlg(
    CWnd*           pParent
    ) : CBaseDialog(IDD_COMMON_SELECT_COLUMNS, pParent)
{
}


//----------------------------------------------------------------------------
// Function:    ColumnDlg::~ColumnDlg
//----------------------------------------------------------------------------

ColumnDlg::~ColumnDlg() { }



void ColumnDlg::Init(const ContainerColumnInfo *prgColInfo,
					 UINT cColumns,
					 ColumnData *prgColumnData)
{
	Assert(prgColInfo);
	Assert(prgColumnData);
	
	m_pColumnInfo = prgColInfo;
	m_cColumnInfo = cColumns;
	m_pColumnData = prgColumnData;
}

//----------------------------------------------------------------------------
// Function:    ColumnDlg::DoDataExchange
//----------------------------------------------------------------------------

void ColumnDlg::DoDataExchange(CDataExchange* pDX) {

    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(ColumnDlg)
    DDX_Control(pDX, IDC_DISPLAYED_COLUMNS, m_lboxDisplayed);
    DDX_Control(pDX, IDC_HIDDEN_COLUMNS,    m_lboxHidden);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ColumnDlg, CBaseDialog)
    //{{AFX_MSG_MAP(ColumnDlg)
    ON_WM_HSCROLL()
	ON_BN_CLICKED(IDC_RESET_COLUMNS,   OnUseDefaults)
    ON_BN_CLICKED(IDC_MOVEUP_COLUMN,   OnMoveUp)
    ON_BN_CLICKED(IDC_MOVEDOWN_COLUMN, OnMoveDown)
	ON_BN_CLICKED(IDC_ADD_COLUMNS,     OnAddColumn)
	ON_BN_CLICKED(IDC_REMOVE_COLUMNS,  OnRemoveColumn)
	ON_LBN_DBLCLK(IDC_HIDDEN_COLUMNS,    OnAddColumn)
	ON_LBN_DBLCLK(IDC_DISPLAYED_COLUMNS, OnRemoveColumn)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


DWORD ColumnDlg::m_dwHelpMap[] =
{
//	IDC_LCX_COLUMNS, HIDC_LCX_COLUMNS,
//	IDC_LCX_MOVEUP, HIDC_LCX_MOVEUP,
//	IDC_LCX_MOVEDOWN, HIDC_LCX_MOVEDOWN,
//	IDC_LCX_WIDTH, HIDC_LCX_WIDTH,
//	IDC_LCX_LEFT, HIDC_LCX_LEFT,
//	IDC_LCX_SCALE, HIDC_LCX_SCALE,
//	IDC_LCX_RIGHT, HIDC_LCX_RIGHT,
	0,0
};


//----------------------------------------------------------------------------
// Function:    ColumnDlg::OnInitDialog
//
// Handles the 'WM_INITDIALOG' message.
//----------------------------------------------------------------------------

BOOL ColumnDlg::OnInitDialog() {

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	ULONG				i, j;
	int					iPos, iItem;
    RECT                rc;
	POSITION            pos;
    CString             sItem;
	ULONG				uCol;

    CBaseDialog::OnInitDialog();

	// Fill the list with the titles of the columns
	//
	if (!AddColumnsToList())
		return FALSE;
	
	//
	// Select the first item
	//
	return TRUE;
}

void ColumnDlg::OnUseDefaults()
{
	int		count, i;
	HDWP	hdwp;
	
	// Reset the column information
	for (i=0; i<(int)m_cColumnInfo; i++)
	{
		if (m_pColumnInfo[i].m_fVisibleByDefault)
			m_pColumnData[i].m_nPosition = i+1;
		else
			m_pColumnData[i].m_nPosition = -(i+1);
	}

	// Get rid of all of the current columns
	hdwp = BeginDeferWindowPos(2);


	m_lboxDisplayed.ResetContent();
	m_lboxHidden.ResetContent();

	// add the columns back to the list
	AddColumnsToList();

	if (hdwp)
		EndDeferWindowPos(hdwp);
}



//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnOK
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnOK(
    ) {
    BOOL            bEmpty;
    INT             i;
    INT             count;
	DWORD_PTR		nPosition;

    count = m_lboxDisplayed.GetCount();
    
    //
    // Check to see whether any columns are enabled
    //
	bEmpty = (count == 0);

	//
	// If no columns are enabled and the caller needs at least one column,
	// complain to the user and don't close the dialog.
	//	
	if (bEmpty)
	{
		AfxMessageBox(IDS_ERR_NOCOLUMNS);
		return;
	}

	// Ok, we need to write the info back out
	for (i = 0; i < count; i++)
	{
		nPosition = m_lboxDisplayed.GetItemData(i);
		m_pColumnData[nPosition].m_nPosition = (i+1);
	}

	INT HiddenCount = m_lboxHidden.GetCount();
	for (i = 0; i < HiddenCount; i++)
	{
		nPosition = m_lboxHidden.GetItemData(i);
		m_pColumnData[nPosition].m_nPosition = -(1+i+count);
	}
	
    CBaseDialog::OnOK();
}



//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnMoveUp
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnMoveUp( ) { MoveItem(-1); }



//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnMoveDown
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnMoveDown( ) { MoveItem(1); }



//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnRemoveColumn
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnRemoveColumn( ) 
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    INT		i;
    BOOL bEnabled;
    CString sItem;
    DWORD_PTR iItem;

    //
    // Get the selected item
    //
    i = m_lboxDisplayed.GetCurSel();
	if (LB_ERR == i)
		return;

    iItem = m_lboxDisplayed.GetItemData(i);

    //
    // Remove the item from its current position
    //
    m_lboxDisplayed.DeleteString(i);

    //
    // Insert the item at its new position
    //
    sItem.LoadString(m_pColumnInfo[iItem].m_ulStringId);

	i = m_lboxHidden.GetCount();
    m_lboxHidden.InsertString(i, sItem);
    m_lboxHidden.SetItemData(i, (DWORD)iItem);
    m_lboxHidden.SetCurSel(i);
}

//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnAddColumn
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnAddColumn( ) 
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    INT		i;
    BOOL bEnabled;
    CString sItem;
    DWORD_PTR iItem;

    //
    // Get the selected item
    //
    i = m_lboxHidden.GetCurSel();
	if (LB_ERR == i)
		return;

    iItem = m_lboxHidden.GetItemData(i);

    //
    // Remove the item from its current position
    //
    m_lboxHidden.DeleteString(i);

    //
    // Insert the item at its new position
    //
    sItem.LoadString(m_pColumnInfo[iItem].m_ulStringId);

	i = m_lboxDisplayed.GetCount();
    m_lboxDisplayed.InsertString(i, sItem);
    m_lboxDisplayed.SetItemData(i, (DWORD)iItem);
    m_lboxDisplayed.SetCurSel(i);
}

//----------------------------------------------------------------------------
// Function::   ColumnDlg::MoveItem
//----------------------------------------------------------------------------

VOID
ColumnDlg::MoveItem(
    INT     dir
    ) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    INT		i;
    BOOL bEnabled;
    CString sItem;
    DWORD_PTR iItem;

    //
    // Get the selected item
    //
    i = m_lboxDisplayed.GetCurSel();

    if (i == -1 || (i + dir) < 0 || (i + dir) >= m_lboxDisplayed.GetCount())
        return;

    iItem = m_lboxDisplayed.GetItemData(i);

    //
    // Remove the item from its current position
    //
    m_lboxDisplayed.DeleteString(i);

    //
    // Insert the item at its new position
    //
    i += dir;

    sItem.LoadString(m_pColumnInfo[iItem].m_ulStringId);

    m_lboxDisplayed.InsertString(i, sItem);
    m_lboxDisplayed.SetItemData(i, (DWORD)iItem);
    m_lboxDisplayed.SetCurSel(i);
}



BOOL ColumnDlg::AddColumnsToList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ULONG		i, j;
	int			iPos, iItem;
	CString		sItem;
	
	Assert(m_pColumnData);

	m_lboxDisplayed.ResetContent();
	m_lboxHidden.ResetContent();

	int cDisplayItems = 0;
	int HiddenItems = 0;
	for (i=0; i<m_cColumnInfo; i++)
	{
		// look for the column at position (i+1)
		for (j=0; j<m_cColumnInfo; j++)
		{
			iPos = m_pColumnData[j].m_nPosition;
			iPos = abs(iPos);
			if ((ULONG)iPos == (i+1))
				break;
		}
		Assert( j < m_cColumnInfo );

		sItem.LoadString(m_pColumnInfo[j].m_ulStringId);

		if (m_pColumnData[j].m_nPosition > 0)
		{
			iItem = m_lboxDisplayed.InsertString(cDisplayItems++, sItem);
		    if (iItem == -1) { OnCancel(); return FALSE; }
	        m_lboxDisplayed.SetItemData(iItem, j);
		}
		else
		{
			iItem = m_lboxHidden.InsertString(HiddenItems++, sItem);
		    if (iItem == -1) { OnCancel(); return FALSE; }
	        m_lboxHidden.SetItemData(iItem, j);
		}
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\ccdata.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ccdata.h
	 prototypes for the CComponentData

    FILE HISTORY:
	
*/

#ifndef _CCDATA_H
#define _CCDATA_H


#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _TFSINT_H
#include <tfsint.h>
#endif

/*---------------------------------------------------------------------------
	Forward declarations
 ---------------------------------------------------------------------------*/



/*---------------------------------------------------------------------------
	Class:	CComponentData

	This is a wrapper around the IComponentData facilities provided
	by TFSCore.
 ---------------------------------------------------------------------------*/
class CComponentData :
   public IComponentData,
   public IExtendPropertySheet2,
   public IExtendContextMenu,
   public IPersistStreamInit,
   public ISnapinHelp
{
public:
	CComponentData();
	virtual ~CComponentData();

public:
	DeclareIUnknownMembers(IMPL)

	// Implementation for these interfaces is provided by TFSCore
	DeclareIComponentDataMembers(IMPL)
	DeclareIExtendPropertySheetMembers(IMPL)
	DeclareIExtendContextMenuMembers(IMPL)
	DeclareISnapinHelpMembers(IMPL)

	// These have to be implemented by the derived classes
	DeclareIPersistStreamInitMembers(PURE)

    // manadatory callback members
    DeclareITFSCompDataCallbackMembers(PURE)

    // not required members
    STDMETHOD(OnNotifyPropertyChange)(THIS_ LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM lParam) { return E_NOTIMPL; }

public:
	HRESULT FinalConstruct();
	void FinalRelease();

protected:
	LONG					m_cRef;
	SPITFSComponentData		m_spTFSComponentData;
	SPIComponentData		m_spComponentData;
	SPIExtendPropertySheet	m_spExtendPropertySheet;
	SPIExtendContextMenu	m_spExtendContextMenu;
	SPISnapinHelp	        m_spSnapinHelp;
	
private:
	
	// This class does NOT show up in our QI maps, this is purely
	// intended for passing down to the ITFSComponent
	// This is valid for as long as we have a valid m_spTFSComponentData
	class EITFSCompDataCallback : public ITFSCompDataCallback
	{
	public:
		DeclareIUnknownMembers(IMPL)
		DeclareIPersistStreamInitMembers(IMPL)
		DeclareITFSCompDataCallbackMembers(IMPL)

        // not required members
        STDMETHOD(OnNotifyPropertyChange)(THIS_ LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM lParam);
    } m_ITFSCompDataCallback;
	friend class EITFSCompDataCallback;
};


/*---------------------------------------------------------------------------
	Inlined functions
 ---------------------------------------------------------------------------*/

inline STDMETHODIMP CComponentData::Initialize(LPUNKNOWN punk)
{
	Assert(m_spComponentData);
	return m_spComponentData->Initialize(punk);
}

inline STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComp)
{
	Assert(m_spComponentData);
	return m_spComponentData->CreateComponent(ppComp);
}

inline STDMETHODIMP CComponentData::Notify(LPDATAOBJECT pDataObject,
										   MMC_NOTIFY_TYPE event,
										   LPARAM arg, LPARAM param)
{
	Assert(m_spComponentData);
	return m_spComponentData->Notify(pDataObject, event, arg, param);
}

inline STDMETHODIMP CComponentData::Destroy()
{
	Assert(m_spComponentData);
	return m_spComponentData->Destroy();
}

inline STDMETHODIMP CComponentData::QueryDataObject(MMC_COOKIE cookie,
	DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
	Assert(m_spComponentData);
	return m_spComponentData->QueryDataObject(cookie, type, ppDataObject);
}

inline STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT pA, LPDATAOBJECT pB)
{
	Assert(m_spComponentData);
	return m_spComponentData->CompareObjects(pA, pB);
}

inline STDMETHODIMP CComponentData::GetDisplayInfo(SCOPEDATAITEM *pScopeDataItem)
{
	Assert(m_spComponentData);
	return m_spComponentData->GetDisplayInfo(pScopeDataItem);
}

inline STDMETHODIMP CComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
	LONG_PTR handle, LPDATAOBJECT pDataObject)
{
	Assert(m_spExtendPropertySheet);
	return m_spExtendPropertySheet->CreatePropertyPages(lpProvider, handle, pDataObject);
}

inline STDMETHODIMP CComponentData::QueryPagesFor(LPDATAOBJECT pDataObject)
{
	Assert(m_spExtendPropertySheet);
	return m_spExtendPropertySheet->QueryPagesFor(pDataObject);
}

inline STDMETHODIMP CComponentData::GetWatermarks(LPDATAOBJECT pDataObject,
                                                  HBITMAP *  lphWatermark, 
                                                  HBITMAP *  lphHeader, 
                                                  HPALETTE * lphPalette, 
                                                  BOOL *     bStretch)
{
	Assert(m_spExtendPropertySheet);
	return m_spExtendPropertySheet->GetWatermarks(pDataObject, lphWatermark, lphHeader, lphPalette, bStretch);
}


inline STDMETHODIMP CComponentData::AddMenuItems(LPDATAOBJECT pDataObject,
	LPCONTEXTMENUCALLBACK pCallback, long *pInsertionAllowed)
{
	Assert(m_spExtendContextMenu);
	return m_spExtendContextMenu->AddMenuItems(pDataObject, pCallback, pInsertionAllowed);
}

inline STDMETHODIMP CComponentData::Command(long nCommandId, LPDATAOBJECT pDataObject)
{
	Assert(m_spExtendContextMenu);
	return m_spExtendContextMenu->Command(nCommandId, pDataObject);
}

inline STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
	Assert(m_spSnapinHelp);
	return m_spSnapinHelp->GetHelpTopic(lpCompiledHelpFile);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\ccdata.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    ccdata.cpp
	base class for the IAbout interface for MMC

    FILE HISTORY:
	
*/

#include <stdafx.h>
#include "ccdata.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CComponentData::CComponentData()
{
}

CComponentData::~CComponentData()
{
}

IMPLEMENT_ADDREF_RELEASE(CComponentData)

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IComponentData)
		*ppv = (IComponentData *) this;
	else if (riid == IID_IExtendPropertySheet)
		*ppv = (IExtendPropertySheet *) this;
	else if (riid == IID_IExtendPropertySheet2)
		*ppv = (IExtendPropertySheet2 *) this;
	else if (riid == IID_IExtendContextMenu)
		*ppv = (IExtendContextMenu *) this;
	else if (riid == IID_IPersistStreamInit)
		*ppv = (IPersistStreamInit *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}



/*!--------------------------------------------------------------------------
	CComponentData::FinalConstruct()
		Initialize values
	Author: 
		Modifide 12/12/97	WeiJiang,	Check return value from 
										CreateTFSComponentData and check the result
 ---------------------------------------------------------------------------*/
HRESULT 
CComponentData::FinalConstruct()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = S_OK;
	IComponentData *	pComponentData = NULL;

	// Create the underlying TFSComponentData
	hr = CreateTFSComponentData(&pComponentData,
						   (ITFSCompDataCallback *) &m_ITFSCompDataCallback);
	// 
	if(S_OK == hr)
	{
		m_spTFSComponentData.Query(pComponentData);
		m_spComponentData = pComponentData;
		m_spExtendPropertySheet.Query(pComponentData);
		m_spExtendContextMenu.Query(pComponentData);
        m_spSnapinHelp.Query(pComponentData);
	}
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CComponentData::FinalRelease()
		Called when the COM object is going away 
	Author: 
 ---------------------------------------------------------------------------*/
void 
CComponentData::FinalRelease()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_spTFSComponentData.Release();
	
	// Call destroy on our TFSComponentData if needed
	if (m_spComponentData)
		m_spComponentData->Destroy();
	m_spComponentData.Release();
	
	m_spExtendPropertySheet.Release();
	m_spExtendContextMenu.Release();
	m_spSnapinHelp.Release();
}


/*---------------------------------------------------------------------------
	Implementation of EITFSCompDataCallback
 ---------------------------------------------------------------------------*/

STDMETHODIMP CComponentData::EITFSCompDataCallback::QueryInterface(REFIID iid,void **ppv)
{ 
	*ppv = 0; 
	if (iid == IID_IUnknown)
		*ppv = (IUnknown *) this;
	else if (iid == IID_ITFSCompDataCallback)
		*ppv = (ITFSCompDataCallback *) this; 
	else
		return ResultFromScode(E_NOINTERFACE);
	
	((IUnknown *) *ppv)->AddRef(); 
	return hrOK;
}

STDMETHODIMP_(ULONG) CComponentData::EITFSCompDataCallback::AddRef() 
{ 
	return 1; 
}

STDMETHODIMP_(ULONG) CComponentData::EITFSCompDataCallback::Release() 
{ 
	return 1; 
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::GetClassID(LPCLSID pClassID)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, GetClassID)
	return pThis->GetClassID(pClassID);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::IsDirty()
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, IsDirty())
	return pThis->IsDirty();
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::Load(LPSTREAM pStm)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, Load)
	return pThis->Load(pStm);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, Save)
	return pThis->Save(pStm, fClearDirty);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, GetSizeMax)
	return pThis->GetSizeMax(pcbSize);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::InitNew()
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, InitNew)
	return pThis->InitNew();
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnInitialize(LPIMAGELIST lpScopeImage)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnInitialize);
	return pThis->OnInitialize(lpScopeImage);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnInitializeNodeMgr(ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnInitializeNodeMgr);
	return pThis->OnInitializeNodeMgr(pTFSCompData, pNodeMgr);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnCreateComponent(LPCOMPONENT *ppComponent)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnCreateComponent);
	return pThis->OnCreateComponent(ppComponent);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnDestroy()
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnDestroy);
	return pThis->OnDestroy();
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnNotifyPropertyChange(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM lParam)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnNotifyPropertyChange);
	return pThis->OnNotifyPropertyChange(pDataObject, event, arg, lParam);
}

STDMETHODIMP_(const CLSID *) CComponentData::EITFSCompDataCallback::GetCoClassID()
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, GetCoClassID);
	return pThis->GetCoClassID();
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnCreateDataObject);
	return pThis->OnCreateDataObject(cookie, type, ppDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\column.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipstrm.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "column.h"
#include "xstream.h"

/*---------------------------------------------------------------------------
	ViewInfo implementation
 ---------------------------------------------------------------------------*/

ViewInfo::ViewInfo()
{
	m_cColumns = 0;
	m_prgColumns = NULL;
	m_dwSortColumn = 0;
	m_dwSortDirection = TRUE;
	m_pViewColumnInfo = NULL;
	m_cVisibleColumns = 0;
	m_prgSubitems = NULL;
    m_fConfigurable = TRUE;
}

ViewInfo::~ViewInfo()
{
	delete [] m_prgColumns;
	delete [] m_prgSubitems;
	m_pViewColumnInfo = NULL;
}


/*!--------------------------------------------------------------------------
	ViewInfo::InitViewInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ViewInfo::InitViewInfo(ULONG cColumns,
                            BOOL fConfigurable,
							BOOL fDefaultSortDirectionDescending,
							const ContainerColumnInfo *pViewColInfo)
{
	m_cColumns = cColumns;
	delete [] m_prgColumns;
	m_prgColumns = new ColumnData[cColumns];

	delete [] m_prgSubitems;
	m_prgSubitems = new ULONG[cColumns];

	m_pViewColumnInfo = pViewColInfo;

	m_fDefaultSortDirection = fDefaultSortDirectionDescending;

    m_fConfigurable = fConfigurable;

	InitNew();
}

/*!--------------------------------------------------------------------------
	ViewInfo::InitNew
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ViewInfo::InitNew()
{
	// setup the defaults for this column
	for (int i=0; i<(int) m_cColumns; i++)
	{
		if (m_pViewColumnInfo[i].m_fVisibleByDefault)
			m_prgColumns[i].m_nPosition = i+1;
		else
			m_prgColumns[i].m_nPosition = -(i+1);

		m_prgColumns[i].m_dwWidth = AUTO_WIDTH;
	}

 	m_dwSortDirection = m_fDefaultSortDirection;

	UpdateSubitemMap();
}

ULONG ViewInfo::MapSubitemToColumn(ULONG  nSubitemId)
{
	for (ULONG i=0; i<m_cVisibleColumns; i++)
	{
		if (m_prgSubitems[i] == nSubitemId)
			return i;
	}
	return 0xFFFFFFFF;
}

/*!--------------------------------------------------------------------------
	ViewInfo::UpdateSubitemMap
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ViewInfo::UpdateSubitemMap()
{
 	Assert(m_prgSubitems);
	
	ULONG	i, cVisible, j;

	// Iterate over the entire set of columns
	for (i=0, cVisible=0; i<m_cColumns; i++)
	{
		// look for this column in ColumnData
		for (j=0; j<m_cColumns; j++)
		{
			if ((ULONG) m_prgColumns[j].m_nPosition == (i+1))
				break;
		}

		// Did we find anything?  If not go on
		if (j >= m_cColumns)
			continue;

		m_prgSubitems[cVisible++] = j;
	}
	m_cVisibleColumns = cVisible;
}


HRESULT ViewInfo::Xfer(XferStream *pxstm, ULONG ulSortColumnId,
					  ULONG ulSortAscendingId, ULONG ulColumnsId)
{
	Assert(pxstm);
	
	HRESULT	hr = hrOK;
	ULONG cColumns;

	// Xfer the column data
	Assert(m_prgColumns);
	
	cColumns = m_cColumns;
	CORg( pxstm->XferColumnData(ulColumnsId, &m_cColumns,
								m_prgColumns) );
	
	// The number of columns shouldn't change!
	Assert(m_cColumns == cColumns);
	// Use the old number of columns (this is for as we change our code)
	m_cColumns = cColumns;

	// Xfer the sort column
	CORg( pxstm->XferDWORD( ulSortColumnId, &m_dwSortColumn) );

	// Xfer the ascending data
	CORg( pxstm->XferDWORD( ulSortAscendingId, &m_dwSortDirection) );

	UpdateSubitemMap();

Error:
	return hr;
}




/*---------------------------------------------------------------------------
	ConfigStream implementation
 ---------------------------------------------------------------------------*/


/*!--------------------------------------------------------------------------
	ConfigStream::ConfigStream
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
ConfigStream::ConfigStream()
	: m_nVersion(0x00020000),
	m_nVersionAdmin(0x0002000),
	m_fDirty(FALSE),
	m_rgViewInfo(NULL),
	m_cColumnSetsMax(0),
	m_prgrc(NULL)
{
}

ConfigStream::~ConfigStream()
{
	delete [] m_rgViewInfo;
	delete [] m_prgrc;
	m_cColumnSetsMax = 0;
}

void ConfigStream::Init(ULONG cColumnSetsMax)
{
	delete [] m_rgViewInfo;
	m_rgViewInfo = NULL;
	m_rgViewInfo = new ViewInfo[cColumnSetsMax];

	delete [] m_prgrc;
	m_prgrc = NULL;
	m_prgrc = new RECT[cColumnSetsMax];
	
	m_cColumnSetsMax = cColumnSetsMax;
}

/*!--------------------------------------------------------------------------
	ConfigStream::InitViewInfo
		Initializes the static data.  This is not the same as InitNew.
		This will initialize the data for a single view.
	Author: KennT
 ---------------------------------------------------------------------------*/
void ConfigStream::InitViewInfo(ULONG ulId,
                                BOOL fConfigurableColumns,
								ULONG cColumns,
								BOOL fSortDirection,
								const ContainerColumnInfo *pViewColumnInfo)
{
	Assert(ulId < m_cColumnSetsMax);
    m_fConfigurableColumns = fConfigurableColumns;
	m_rgViewInfo[ulId].InitViewInfo(cColumns, fConfigurableColumns,
                                    fSortDirection,
                                    pViewColumnInfo);
}

/*!--------------------------------------------------------------------------
	ConfigStream::InitNew
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::InitNew()
{
	int		iVisible=0;
	// Setup the appropriate defaults
	for (UINT i=0; i<m_cColumnSetsMax; i++)
	{
		m_rgViewInfo[i].InitNew();
		m_prgrc[i].top = m_prgrc[i].bottom = 0;
		m_prgrc[i].left = m_prgrc[i].right = 0;
	}

	return hrOK;
}

/*!--------------------------------------------------------------------------
	ConfigStream::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::SaveTo(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	ConfigStream::SaveAs
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::SaveAs(UINT nVersion, IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	ConfigStream::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::LoadFrom(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_READ, NULL);
}

/*!--------------------------------------------------------------------------
	ConfigStream::GetSize
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::GetSize(ULONG *pcbSize)
{
	return XferVersion0(NULL, XferStream::MODE_SIZE, NULL);
}

/*!--------------------------------------------------------------------------
	ConfigStream::GetVersionInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::GetVersionInfo(DWORD *pdwVersion, DWORD *pdwAdminVersion)
{
	if (pdwVersion)
		*pdwVersion = m_nVersion;
	if (pdwAdminVersion)
		*pdwAdminVersion = m_nVersionAdmin;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	ConfigStream::XferVersion0
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	Panic0("Should be implemented by derived classes!");
	return E_NOTIMPL;
}


void ConfigStream::GetStatsWindowRect(ULONG ulId, RECT *prc)
{
	*prc = m_prgrc[ulId];
}

void ConfigStream::SetStatsWindowRect(ULONG ulId, RECT rc)
{
	m_prgrc[ulId] = rc;
}



/*!--------------------------------------------------------------------------
	ViewInfo::GetColumnData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ViewInfo::GetColumnData(ULONG cColData,
								ColumnData *prgColData)
{
	Assert(cColData <= m_cColumns);
	Assert(prgColData);
	Assert(!IsBadWritePtr(prgColData, sizeof(ColumnData)*cColData));
	
	HRESULT	hr = hrOK;

	memcpy(prgColData, m_prgColumns, sizeof(ColumnData)*cColData);

	return hr;
}

HRESULT ViewInfo::GetColumnData(ULONG nColumnId, ULONG cColData,
								ColumnData *prgColData)
{
	Assert(cColData <= m_cColumns);
	Assert(prgColData);
	Assert(!IsBadWritePtr(prgColData, sizeof(ColumnData)*cColData));
	
	HRESULT	hr = hrOK;

	memcpy(prgColData, m_prgColumns + nColumnId, sizeof(ColumnData)*cColData);

	return hr;
}


HRESULT ViewInfo::SetColumnData(ULONG cColData, ColumnData*prgColData)
{
	// For now we don't do resizing
	Assert(cColData == m_cColumns);
	Assert(prgColData);
	Assert(!IsBadReadPtr(prgColData, sizeof(ColumnData)*cColData));
	
	HRESULT	hr = hrOK;

	memcpy(m_prgColumns, prgColData, sizeof(ColumnData)*cColData);
	UpdateSubitemMap();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\column.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	column.h
		Customizable column info.

		Use this to get/set configuration data.  This class will take
		care of versioning of config formats as well as serializing
		of the data.
		
    FILE HISTORY:
        
*/

#ifndef _COLUMN_H
#define _COLUMN_H

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

// forward declarations

/*---------------------------------------------------------------------------
	Struct:	ContainerColumnInfo
	This structure will hold column information that doesn't change.
 ---------------------------------------------------------------------------*/
struct ContainerColumnInfo
{
	ULONG	m_ulStringId;		// String id of the column header
	int		m_nSortCriteria;	// = 0 for string, = 1 for DWORD
	BOOL	m_fVisibleByDefault;// TRUE if default is column is visible
	ULONG	m_ulDefaultColumnWidth;	// in number of characters
};

// constants used by m_nSortCriteria
#define CON_SORT_BY_STRING	0
#define CON_SORT_BY_DWORD		1

// constants used for m_ulDefaultColumnWidth
// This should be used to ensure consistency (as well as making it
// easier to change a whole bunch of column widths at the same time).
#define COL_IF_NAME			30
#define COL_IF_DEVICE		30
#define COL_STATUS			12
#define COL_LARGE_NUM		15
#define COL_SMALL_NUM		8
#define COL_DATE			12
#define COL_IPADDR			15
#define COL_STRING			15
#define COL_MACHINE_NAME	20
#define COL_DURATION		10
#define COL_IPXNET			32
#define COL_NETBIOS_NAME	18
#define COL_BIG_STRING		32



//
//	Class:	ViewColumnInfo
//
//	This class is intended as a simple struct rather than a whole class.
//	Information needed on a per-view basis.
//
//
class ViewInfo
{
public:
	ViewInfo();
	~ViewInfo();

	//
	//	Initializes the data for a single view or column set.
	//
	void InitViewInfo(ULONG cColumns,
                      BOOL fConfigurable,
					  BOOL fDefaultSortDirectionDescending,
					  const ContainerColumnInfo *pViewColInfo);

	//
	//	Call this to initialize the column data (reset to defaults).
	//
	void InitNew();

	//
	//	Updates the mapping from the column id to the subitem ids.
	//
	void UpdateSubitemMap();

	//
	//	Xfers the data to the stream using the given ids.
	//
	HRESULT	Xfer(XferStream *pxstm,
				 ULONG ulSortColumId,
				 ULONG ulSortAscendingId,
				 ULONG ulColumnsId);

	ULONG	MapColumnToSubitem(ULONG nColumnId);
	ULONG	MapSubitemToColumn(ULONG nSubitemId);

	HRESULT	GetColumnData(ULONG cArrayMax, ColumnData *pColData);
	HRESULT SetColumnData(ULONG cArray, ColumnData *pColData);

	HRESULT	GetColumnData(ULONG nColumnId, ULONG cArrayMax, ColumnData *pColData);

	int		GetSortCriteria(ULONG nColumnId);
	ULONG	GetStringId(ULONG nColumnId);
	DWORD	GetColumnWidth(ULONG nColumnId);

	ULONG	GetVisibleColumns();
	BOOL	IsSubitemVisible(ULONG nSubitemId);

	ULONG	GetColumnCount();

	ULONG	GetSortColumn();
	void	SetSortColumn(ULONG nSortColumn);

	ULONG	GetSortDirection();
	void	SetSortDirection(ULONG ulSortDirection);

	const ContainerColumnInfo *	GetColumnInfo()
			{	return m_pViewColumnInfo;	}

protected:

	// The individual column data (indexed by subitem id)
	ColumnData *m_prgColumns;

	// Number of columns
	ULONG	m_cColumns;
	
	// The subitem id that we are sorting by
	DWORD	m_dwSortColumn;
	
	// TRUE if we are sorting by ascending order
	DWORD	m_dwSortDirection;

	// Pointer to default static data for this view
	const ContainerColumnInfo *	m_pViewColumnInfo;

    // TRUE if the column order can be changed
    BOOL    m_fConfigurable;

 	//
	//	The data after this point is for use during runtime display of data.
	//	Thus it is organized a little differently then the persisted data.
	//
	
 	// Number of visible columns.
	ULONG	m_cVisibleColumns;

	// This is the mapping from column id to subitem id.  The column ids
	// is the order in which the columns actually appear to MMC.
	//	For example, if there were 3 columns (subitemA, subitemB, subitemC)
	//	and we wished to show the columns in the order [subitemC, subitemB]
	//	then m_cVisibleColumns = 2
	//	and m_rgSubItems[] = { subitemC, subitemB, XXXX }
	// Do NOT make changes to this directly!  This must be kept in sync
	// with the ordered data.  This will get updated automatically when
	// SetColumnData is called.
	ULONG *	m_prgSubitems;


	BOOL	m_fDefaultSortDirection;
};


inline ULONG ViewInfo::MapColumnToSubitem(ULONG nColumnId)
{
	Assert(nColumnId < (int) m_cColumns);
    
    // In the new MMC model, the only time we have configurable
    // columns are the statistics dialogs.
    if (m_fConfigurable)
        return m_prgSubitems[nColumnId];
    else
        return nColumnId;
}

inline int ViewInfo::GetSortCriteria(ULONG nColumnId)
{
	Assert(nColumnId < m_cColumns);
	return m_pViewColumnInfo[MapColumnToSubitem(nColumnId)].m_nSortCriteria;
}

inline ULONG ViewInfo::GetStringId(ULONG nColumnId)
{
	Assert(nColumnId < m_cColumns);
	return m_pViewColumnInfo[MapColumnToSubitem(nColumnId)].m_ulStringId;
}

inline ULONG ViewInfo::GetColumnWidth(ULONG nColumnId)
{
	Assert(nColumnId < m_cColumns);
	Assert(m_prgColumns);
	return m_prgColumns[MapColumnToSubitem(nColumnId)].m_dwWidth;
}

inline ULONG ViewInfo::GetVisibleColumns()
{
	return m_cVisibleColumns;
}

inline ULONG ViewInfo::GetColumnCount()
{
	return m_cColumns;
}

inline BOOL ViewInfo::IsSubitemVisible(ULONG nSubitem)
{
	return (m_prgColumns[nSubitem].m_nPosition > 0);
}

inline void ViewInfo::SetSortColumn(ULONG nColumnId)
{
	m_dwSortColumn = nColumnId;
}

inline ULONG ViewInfo::GetSortColumn()
{
	return m_dwSortColumn;
}

inline void ViewInfo::SetSortDirection(ULONG ulDir)
{
	m_dwSortDirection = ulDir;
}

inline ULONG ViewInfo::GetSortDirection()
{
	return m_dwSortDirection;
}


/*---------------------------------------------------------------------------
	Class:	ConfigStream

	This class is used to place all configuration information into a
	single place.
 ---------------------------------------------------------------------------*/

class ConfigStream
{
public:
	ConfigStream();
	virtual ~ConfigStream();

	//
	//	Allocates the memory for these number of column sets
	//
	void Init(ULONG cColumnSetsMax);

	//
	//	Initializes the data for a single column set.
	//
	void InitViewInfo(ULONG ulId,
                      BOOL  fConfigurableColumns,
                      ULONG cColumns,
					  BOOL fSortDirection,
					  const ContainerColumnInfo *pColumnInfo);
	
	HRESULT	InitNew();				// set defaults
	HRESULT	SaveTo(IStream *pstm);
	HRESULT SaveAs(UINT nVersion, IStream *pstm);
	
	HRESULT LoadFrom(IStream *pstm);

	HRESULT GetSize(ULONG *pcbSize);

	BOOL	GetDirty() { return m_fDirty; } 
	void	SetDirty(BOOL fDirty) { m_fDirty = fDirty; };


	// --------------------------------------------------------
	// Accessors
	// --------------------------------------------------------
	
	HRESULT	GetVersionInfo(DWORD *pnVersion, DWORD *pnAdminVersion);

	ULONG	MapColumnToSubitem(ULONG ulId, ULONG ulColumnId);
	ULONG	MapSubitemToColumn(ULONG ulId, ULONG nSubitemId);

	HRESULT GetColumnData(ULONG ulId, ULONG cArrayMax, ColumnData *pColData);
	HRESULT GetColumnData(ULONG ulId, ULONG nColumnId, ULONG cArrayMax, ColumnData *pColData);
	HRESULT SetColumnData(ULONG ulId, ULONG cArray, ColumnData *pColData);

	ULONG	GetColumnCount(ULONG ulId);

	int		GetSortCriteria(ULONG ulId, ULONG uColumnId);
	ULONG	GetStringId(ULONG ulId, ULONG nColumnId);
	DWORD	GetColumnWidth(ULONG ulId, ULONG nColumnId);

	ULONG	GetVisibleColumns(ULONG ulId);
	BOOL	IsSubitemVisible(ULONG ulId, UINT nSubitemId);

	const ContainerColumnInfo *	GetColumnInfo(ULONG ulId);

	void	GetStatsWindowRect(ULONG ulId, RECT *prc);
	void	SetStatsWindowRect(ULONG ulId, RECT rc);

	void	SetSortColumn(ULONG ulId, ULONG uColumnId);
	ULONG	GetSortColumn(ULONG ulId);
	
	void	SetSortDirection(ULONG ulId, ULONG uSortDir);
	ULONG	GetSortDirection(ULONG ulId);
	
protected:
	DWORD	m_nVersionAdmin;
	DWORD	m_nVersion;
	BOOL	m_fDirty;
    BOOL    m_fConfigurableColumns; // = TRUE if we can change the columns

	ULONG		m_cColumnSetsMax;
	ViewInfo *	m_rgViewInfo;	// = ViewInfo[m_cColumnSetsMax]
	RECT *		m_prgrc;		// = Rect[m_cColumnSetsMax]

	// Overide this to provide basic defaults
	virtual HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
};


inline ULONG ConfigStream::MapColumnToSubitem(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);

    return m_rgViewInfo[ulId].MapColumnToSubitem(nColumnId);
}

inline ULONG ConfigStream::MapSubitemToColumn(ULONG ulId, ULONG nSubitemId)
{
	Assert(ulId < m_cColumnSetsMax);

    return m_rgViewInfo[ulId].MapSubitemToColumn(nSubitemId);
}

inline int ConfigStream::GetSortCriteria(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetSortCriteria(nColumnId);
}

inline ULONG ConfigStream::GetVisibleColumns(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetVisibleColumns();
}

inline BOOL ConfigStream::IsSubitemVisible(ULONG ulId, UINT nSubitemId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].IsSubitemVisible(nSubitemId);
}

inline ULONG ConfigStream::GetColumnCount(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnCount();
}

inline HRESULT ConfigStream::GetColumnData(ULONG ulId, ULONG cArrayMax, ColumnData *pColData)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnData(cArrayMax, pColData);
}

inline HRESULT ConfigStream::GetColumnData(ULONG ulId, ULONG cColData, ULONG cArrayMax, ColumnData *pColData)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnData(cColData, cArrayMax, pColData);
}

inline HRESULT ConfigStream::SetColumnData(ULONG ulId,
	ULONG cArrayMax,
	ColumnData *pColData)
{
	Assert(ulId < m_cColumnSetsMax);
	SetDirty(TRUE);
	return m_rgViewInfo[ulId].SetColumnData(cArrayMax, pColData);
}

inline const ContainerColumnInfo *	ConfigStream::GetColumnInfo(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnInfo();
}

inline ULONG ConfigStream::GetStringId(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetStringId(nColumnId);
}

inline DWORD ConfigStream::GetColumnWidth(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnWidth(nColumnId);
}

inline void ConfigStream::SetSortColumn(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);
	m_rgViewInfo[ulId].SetSortColumn(nColumnId);
}

inline ULONG ConfigStream::GetSortColumn(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetSortColumn();
}

inline void ConfigStream::SetSortDirection(ULONG ulId, ULONG nDir)
{
	Assert(ulId < m_cColumnSetsMax);
	m_rgViewInfo[ulId].SetSortDirection(nDir);
}

inline ULONG ConfigStream::GetSortDirection(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetSortDirection();
}

#endif _COLUMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\commhelp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       commhelp.cpp
//
//--------------------------------------------------------------------------

#include "commres.h"
#include "common.hm"

// "File common.rc line 63 : Resource - DIALOGEX : IDD_STATS"
static const DWORD rgdw_IDD_STATS[] = 
{
    IDC_STATSDLG_LIST, HIDC_STATSDLG_LIST,
    IDC_STATSDLG_BTN_SELECT_COLUMNS, HIDC_STATSDLG_BTN_SELECT_COLUMNS,
    IDC_STATSDLG_BTN_CLEAR, HIDC_STATSDLG_BTN_CLEAR,
    IDC_STATSDLG_BTN_REFRESH, HIDC_STATSDLG_BTN_REFRESH,
	0,0 
};


// "File common.rc line 78 : Resource - DIALOGEX : IDD_STATS_NARROW"
static const DWORD rgdw_IDD_STATS_NARROW[] = 
{
    IDC_STATSDLG_LIST, HIDC_STATSDLG_LIST,
    IDC_STATSDLG_BTN_SELECT_COLUMNS, HIDC_STATSDLG_BTN_SELECT_COLUMNS,
    IDC_STATSDLG_BTN_CLEAR, HIDC_STATSDLG_BTN_CLEAR,
    IDC_STATSDLG_BTN_REFRESH, HIDC_STATSDLG_BTN_REFRESH,
	0,0 
};


// "File common.rc line 91 : Resource - DIALOGEX : IDD_COMMON_SELECT_COLUMNS"
static const DWORD rgdw_IDD_COMMON_SELECT_COLUMNS[] = 
{
    IDC_DISPLAYED_COLUMNS, HIDC_DISPLAYED_COLUMNS,
    IDC_RESET_COLUMNS,     HIDC_RESET_COLUMNS,
    IDC_MOVEUP_COLUMN,     HIDC_MOVEUP_COLUMN,
    IDC_MOVEDOWN_COLUMN,   HIDC_MOVEDOWN_COLUMN,
    IDC_HIDDEN_COLUMNS,    HIDC_HIDDEN_COLUMNS,
    IDC_ADD_COLUMNS,       HIDC_ADD_COLUMNS,
    IDC_REMOVE_COLUMNS,    HIDC_REMOVE_COLUMNS,
	0,0 
};


// "File common.rc line 110 : Resource - DIALOG : IDD_BUSY"
static const DWORD rgdw_IDD_BUSY[] = 
{
    IDC_SEARCH_ANIMATE, HIDC_SEARCH_ANIMATE,
    IDC_STATIC_DESCRIPTION, HIDC_STATIC_DESCRIPTION,
	0,0 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\commres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       commres.h
//
//--------------------------------------------------------------------------

#ifndef _COMMON_COMMRES_H
#define _COMMON_COMMRES_H

// Dialog ids start at 5000-5099
#define IDD_STATS                       5000
#define IDD_COMMON_SELECT_COLUMNS	5001
#define IDD_STATS_NARROW		5002
#define IDD_BUSY                        5003

// Controls are from 5100-5499
#define IDC_STATSDLG_LIST               5100
#define IDC_STATSDLG_BTN_REFRESH        5101
#define IDC_STATSDLG_BTN_SELECT_COLUMNS 5102
#define IDC_STATSDLG_BTN_CLEAR		5103

#define IDC_DISPLAYED_COLUMNS			5111
#define IDC_MOVEUP_COLUMN				5112
#define IDC_MOVEDOWN_COLUMN				5113
#define IDC_RESET_COLUMNS				5114
#define IDC_HIDDEN_COLUMNS				5120
#define IDC_ADD_COLUMNS					5121
#define IDC_REMOVE_COLUMNS				5122

// These are still used elsewhere in the system
#define IDC_LCX_LIST_COLUMNS            5111
#define IDC_LCX_BTN_MOVEUP              5112
#define IDC_LCX_BTN_MOVEDOWN            5113
#define IDC_LCX_BTN_DEFAULTS            5114

#define IDC_STATIC_DESCRIPTION          5115
#define IDC_SEARCH_ANIMATE              5116

// Miscellaneous at from 5500-5599
#define IDI_COMMON_CHECK				5500
#define IDI_COMMON_UNCHECK				5501
#define IDR_STATSDLG					5502

// Strings are from 5600-5999
#define IDS_ERR_NOCOLUMNS				5600
#define IDS_STATSDLG_MENU_REFRESH		5601
#define IDS_STATSDLG_MENU_SELECT		5602
#define IDS_STATSDLG_DESCRIPTION		5603
#define IDS_STATSDLG_DETAILS			5604
#define IDS_ERR_TOD_LOADLOGHOURDLL  	5605
#define IDS_ERR_TOD_FINDLOGHOURSAPI 	5606

#define IDS_COMMON_ERR_IPADDRESS_NONCONTIGUOUS_MASK 5700
#define IDS_COMMON_ERR_IPADDRESS_TOO_SPECIFIC   5701
#define IDS_COMMON_ERR_IPADDRESS_NORMAL_RANGE   5702
#define IDS_COMMON_ERR_IPADDRESS_127            5703
#define IDS_COMMON_ERR_IPADDRESS_NOT_EQ_MASK 5704

#endif	// _COMMON_COMMRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\compinfo.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	compinfo.cpp
		Computer info class plus helper functions

	FILE HISTORY:


*/
#include <stdafx.h>
#include <winsock.h>
#include "compinfo.h"

#define STRING_MAX	256

//
//
//
BOOL	
CIpInfoArray::FIsInList(DWORD dwIp)
{
	BOOL fFound = FALSE;

	for (int i = 0; i < GetSize(); i++)
	{
		if (GetAt(i).dwIp == dwIp)
		{
			fFound = TRUE;
			break;
		}
	}

	return fFound;
}


//
//
//

CComputerInfo::CComputerInfo(LPCTSTR pszNameOrIp)
{
	m_strNameOrIp = pszNameOrIp;
	m_nIndex = -1;
}

CComputerInfo::~CComputerInfo()
{

}

HRESULT
CComputerInfo::GetIp(DWORD * pdwIp, int nIndex)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (SUCCEEDED(hr))
	{
		if (pdwIp)
			*pdwIp = m_arrayIps[nIndex].dwIp;
	}
	else
	{
		if (pdwIp)
			*pdwIp = 0xFFFFFFFF;
	}

	return hr;
}

HRESULT
CComputerInfo::GetIpStr(CString & strIp, int nIndex)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (SUCCEEDED(hr))
	{
		struct in_addr ipaddr ;

		//
		//  Convert the unsigned long to network byte order
		//
		ipaddr.s_addr = ::htonl( (u_long) m_arrayIps[nIndex].dwIp ) ;
		CHAR * pszAddr = inet_ntoa( ipaddr ) ;

		::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszAddr, -1, strIp.GetBuffer(IP_ADDDRESS_LENGTH_MAX), IP_ADDDRESS_LENGTH_MAX);
		strIp.ReleaseBuffer();
	}
	else
	{
		strIp.Empty();
	}

	return hr;
}

HRESULT
CComputerInfo::GetHostName(CString & strHostName)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (SUCCEEDED(hr))
	{
		strHostName = m_strHostname;
	}
	else
	{
		strHostName.Empty();
	}

	return hr;
}

HRESULT
CComputerInfo::GetFqdn(CString & strFqdn, int nIndex)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (SUCCEEDED(hr))
	{
		strFqdn = m_arrayIps[nIndex].strFqdn;
	}
	else
	{
		strFqdn.Empty();
	}

	return hr;
}

int
CComputerInfo::GetCount()
{
	return m_nIndex;
}

//
//	Call this function to reset the internal data so that on the next query
//  we will rebuild our data.
//
void
CComputerInfo::Reset()
{
	// set this to -1 so that we will get the data again on the next call
	m_nIndex = -1;
	m_arrayIps.RemoveAll();
	m_strHostname.Empty();
}

HRESULT
CComputerInfo::GetDomain(CString & strDomain)
{
	// not supported right now
	strDomain.Empty();

	return E_NOTIMPL;
}

HRESULT
CComputerInfo::IsLocalMachine(BOOL * pfIsLocal)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (pfIsLocal)
	{
		if (SUCCEEDED(hr))
		{
			CString strLocal;
			DWORD	dwSize = STRING_MAX;
			BOOL fSuccess = GetComputerName(strLocal.GetBuffer(dwSize), &dwSize);
			strLocal.ReleaseBuffer();

			if (fSuccess)
			{
				*pfIsLocal = (strLocal.CompareNoCase(m_strHostname) == 0) ? TRUE : FALSE;
			}
		}
		else
		{
			*pfIsLocal = FALSE;
		}
	}

	return hr;
}

COMPUTER_INFO_TYPE
CComputerInfo::GetInputType()
{
    // assume a NetBios name
	COMPUTER_INFO_TYPE enResult = COMPUTER_INFO_TYPE_NB ;
	const TCHAR chDash = '-';
    const TCHAR chDot = '.' ;
	const TCHAR chSlash = '\\' ;
	CString strName( m_strNameOrIp ) ;

	int cch = strName.GetLength() ;

	//  Does the name begin with two slashes??

	if (    cch > 2
		&& strName.GetAt(0) == chSlash
		&& strName.GetAt(1) == chSlash )
	{
		enResult = COMPUTER_INFO_TYPE_NB ;
	}
	else
	{
		//
		//  Scan the name looking for DNS name or IP address
		//
		int i = 0,
			cDots = 0,
			cAlpha = 0,
            cDash = 0;
		TCHAR ch ;
		BOOL bOk = TRUE ;

		for ( ; i < cch ; i++ )
		{
			switch ( ch = strName.GetAt( i ) )
			{
				case chDot:
					if ( ++cDots > 3 )
					{
                        // we keep track of the number of dots,
                        // but we need to be able to handle fully
                        // qualified domain names (FQDN) so more than
                        // 3 dots is ok.
						//bOk = FALSE ;
					}
					break;

				default:
					if ( _istalpha( ch ) )
					{
						cAlpha++;
					}
                    else if ( ch == chDash )
                    {
                        cDash++;
                    }
					else if ( !_istdigit(ch) )
					{
						bOk = FALSE;
					}

					break;
			}
			if ( ! bOk )
			{
				break ;
			}
		}
		if ( bOk )
		{
			if ( cAlpha )
			{
				enResult = COMPUTER_INFO_TYPE_DNS ;
			}
			else if ( cDots == 3 )
			{
				enResult = COMPUTER_INFO_TYPE_IP ;
			}
		}
	}

	return enResult ;
}

// internal functions
HRESULT
CComputerInfo::InitializeData()
{
	HRESULT hr = hrOK;

	switch (GetInputType())
	{
		case COMPUTER_INFO_TYPE_NB:
		case COMPUTER_INFO_TYPE_DNS:
		{
			DWORD dwIp;

			GetHostAddress(m_strNameOrIp, &dwIp);
			GetHostInfo(dwIp);
		}
			break;

		case COMPUTER_INFO_TYPE_IP:
		{
			// convert the string to ansi 
		    CHAR szString [ STRING_MAX ] = {0};
			::WideCharToMultiByte(CP_ACP, 0, m_strNameOrIp, -1, szString, sizeof(szString), NULL, NULL);

			// get the host info after converting the IP string to a DWORD
			GetHostInfo(::ntohl( ::inet_addr( szString ) ) );
		}
			break;
	}

	return hr;
}

HRESULT
CComputerInfo::GetHostInfo 
(
    DWORD	dhipa
)
{
	CString		strFQDN;
	CString		strHostname;
	CString		strTemp;
	CIpInfo		ipInfo;

    //
    //  Call the Winsock API to get host name and alias information.
    //
    u_long ulAddrInNetOrder = ::htonl( (u_long) dhipa ) ;

    HOSTENT * pHostEnt = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
										   sizeof ulAddrInNetOrder,
										   PF_INET ) ;
    if ( pHostEnt == NULL )
    {
        return HRESULT_FROM_WIN32(::WSAGetLastError());
	}

    CHAR * * ppchAlias = pHostEnt->h_aliases ;

    //
    //  Check and copy the host name.
    //
	
    ::MultiByteToWideChar(CP_ACP, 
                          MB_PRECOMPOSED, 
                          pHostEnt->h_name, 
                          lstrlenA(pHostEnt->h_name), 
                          strTemp.GetBuffer(STRING_MAX * 2), 
                          STRING_MAX * 2);

	strTemp.ReleaseBuffer();

    // remove any periods at the end
    while (strTemp[strTemp.GetLength() - 1] == '.')
    {
        strTemp = strTemp.Left(strTemp.GetLength() - 1);
    }

    // gethostbyaddr is returning the hostname only in some cases.  
    // Make another call to get the fqdn
    if (strTemp.Find('.') == -1)
    {
		// this is not a FQDN
        GetHostAddressFQDN(strTemp, &strFQDN, &dhipa);
    }
	else
	{
		strFQDN = strTemp;
	}

    // copy the data into the buffer
	strFQDN.MakeLower();
	int nDot = strFQDN.Find('.');
	m_strHostname = strFQDN.Left(nDot);
	
	// add the primary entry to the array
	ipInfo.dwIp = dhipa;
	ipInfo.strFqdn = strFQDN;

	m_arrayIps.Add(ipInfo);

	// now loop through the h_addr_list
	int iCount = 0;
	while ( (LPDWORD)(pHostEnt->h_addr_list[iCount] ) )
	{
		if (!m_arrayIps.FIsInList(addrFromHostent(pHostEnt, iCount)))
		{
			ipInfo.dwIp = addrFromHostent(pHostEnt, iCount);
			ipInfo.strFqdn.Empty();

			m_arrayIps.Add(ipInfo);
		}

		iCount++;
	}

	m_nIndex = m_arrayIps.GetSize();

    //
    //  Find the first acceptable NetBIOS name among the aliases;
    //  i.e., the first name without a period
    //
    /*
    for ( ; *ppchAlias ; ppchAlias++ )
    {
        if  ( validateNetbiosName( *ppchAlias ) )
        {
            break ;
        }
    }

    //
    //  Empty the NetBIOS name in case we didn't get one.
    //
    pdhsrvi->_chNetbiosName[0] = 0 ;
    
    if ( *ppchAlias )
    {
        //
        //  We found a usable name; copy it to output structure.
        //
        ::MultiByteToWideChar(CP_ACP, 
                              MB_PRECOMPOSED, 
                              *ppchAlias, 
                              lstrlenA(*ppchAlias),
                              pdhsrvi->_chNetbiosName, 
                              sizeof(pdhsrvi->_chNetbiosName));
    }
    */

    return hrOK ;
}

HRESULT 
CComputerInfo::GetHostAddressFQDN
(
    LPCTSTR			pszHostName,
    CString *       pstrFQDN,
    DWORD *			pdhipa
)
{
	HRESULT hr = hrOK;
    CHAR szString [ MAX_PATH ] = {0};

    ::WideCharToMultiByte(CP_ACP, 0, pszHostName, -1, szString, sizeof(szString), NULL, NULL);

    HOSTENT * pHostent = ::gethostbyname( szString ) ;

    if ( pHostent )
    {
        *pdhipa = addrFromHostent( pHostent ) ;

        LPTSTR pName = pstrFQDN->GetBuffer(STRING_MAX * 2);
        ZeroMemory(pName, STRING_MAX * 2);

        ::MultiByteToWideChar(CP_ACP, 
                              MB_PRECOMPOSED, 
                              pHostent->h_name, 
                              strlen(pHostent->h_name),
                              pName, 
                              STRING_MAX * 2);

        pstrFQDN->ReleaseBuffer();

    }
    else
    {
        hr = HRESULT_FROM_WIN32(::WSAGetLastError());
	}

    return hr;
}

DWORD
CComputerInfo::addrFromHostent 
(
    const HOSTENT * pHostent,
    INT				index  
)
{
    return (DWORD) ::ntohl( *((u_long *) pHostent->h_addr_list[index]) );
}


HRESULT
CComputerInfo::GetHostAddress 
(
    LPCTSTR		pszHostName,
    DWORD *		pdhipa
)
{
	HRESULT hr = hrOK;
    CHAR szString [ MAX_PATH ] = {0};

    ::WideCharToMultiByte(CP_ACP, 0, pszHostName, -1, szString, sizeof(szString), NULL, NULL);

    HOSTENT * pHostent = ::gethostbyname( szString ) ;

    if ( pHostent )
    {
        *pdhipa = addrFromHostent( pHostent ) ;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::WSAGetLastError());
	}

    return hr ;
}

HRESULT 
CComputerInfo::GetLocalHostAddress 
(
    DWORD *		pdhipa
)
{
	HRESULT hr = hrOK;
    CHAR	chHostName [ STRING_MAX * 2 ];

    if ( ::gethostname( chHostName, sizeof(chHostName) ) == 0 )
    {
        CString strTemp = chHostName;
		hr = GetHostAddress( strTemp, pdhipa ) ;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::WSAGetLastError()) ;
	}

    return hr;
}

HRESULT 
CComputerInfo::GetLocalHostName
(
    CString * pstrName
)
{
	HRESULT hr = hrOK;
    CHAR	chHostName [ STRING_MAX * 2 ] ;

    if ( ::gethostname( chHostName, sizeof (chHostName) ) == 0 )
    {
        LPTSTR pName = pstrName->GetBuffer(STRING_MAX * 2);
		ZeroMemory(pName, STRING_MAX * 2);

        ::MultiByteToWideChar(CP_ACP, 
                              MB_PRECOMPOSED, 
                              chHostName, 
                              strlen(chHostName),
                              pName, 
                              STRING_MAX * 2);

        pstrName->ReleaseBuffer();
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::WSAGetLastError()) ;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\compinfo.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	compinfo.cpp
		Computer info class plus helper functions

	FILE HISTORY:


*/

#define IP_ADDDRESS_LENGTH_MAX   16

typedef enum COMPUTER_INFO_TYPE
{
	COMPUTER_INFO_TYPE_IP,
	COMPUTER_INFO_TYPE_DNS,
	COMPUTER_INFO_TYPE_NB
};

class CIpInfo
{
public:
	DWORD	dwIp;
	CString	strFqdn;
};

typedef CArray<CIpInfo, CIpInfo &> CIpInfoArrayBase;

class CIpInfoArray : public CIpInfoArrayBase
{
public:
	BOOL	FIsInList(DWORD dwIp);
};

class CComputerInfo
{
public:
	CComputerInfo(LPCTSTR pszNameOrIp);
	~CComputerInfo();

	HRESULT	GetIp(DWORD * pdwIp, int nIndex = 0);
	HRESULT	GetIpStr(CString & strIp, int nIndex = 0);
	HRESULT	GetHostName(CString & strHostName);
	HRESULT	GetFqdn(CString & strFqdn, int nIndex = 0);
	int		GetCount();
	HRESULT	GetDomain(CString & strDomain);
	COMPUTER_INFO_TYPE	GetInputType();
	HRESULT IsLocalMachine(BOOL * pfIsLocal);
	HRESULT	InitializeData();

	void	Reset();

// internal functions
protected:
	HRESULT	GetHostInfo(DWORD dhipa);
	HRESULT GetHostAddressFQDN(LPCTSTR pszHostName, CString * pstrFQDN, DWORD * pdhipa);
	DWORD	addrFromHostent(const HOSTENT * pHostent, INT index = 0);
	HRESULT	GetHostAddress(LPCTSTR pszHostName, DWORD * pdhipa);
	HRESULT GetLocalHostAddress(DWORD * pdhipa);
	HRESULT GetLocalHostName(CString * pstrName);

private:
	CString				m_strNameOrIp;
	CString				m_strHostname;

	int					m_nIndex;
	
	CIpInfoArray		m_arrayIps;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\dataobj.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    dataobj.cpp
        Implementation for data objects in the MMC

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dataobj.h"
#include "extract.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity


// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"SNAPIN_INTERNAL"; 


///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

// MMC required clipboard formats
unsigned int CDataObject::m_cfNodeType          = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString    = RegisterClipboardFormat(CCF_SZNODETYPE);  
unsigned int CDataObject::m_cfDisplayName       = RegisterClipboardFormat(CCF_DISPLAY_NAME); 
unsigned int CDataObject::m_cfCoClass           = RegisterClipboardFormat(CCF_SNAPIN_CLASSID); 
unsigned int CDataObject::m_cfMultiSel          = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
unsigned int CDataObject::m_cfMultiSelDobj      = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
unsigned int CDataObject::m_cfDynamicExtension  = RegisterClipboardFormat(CCF_MMC_DYNAMIC_EXTENSIONS);
unsigned int CDataObject::m_cfNodeId2           = RegisterClipboardFormat(CCF_NODEID2);

// snpain specific clipboard formats
unsigned int CDataObject::m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL); 

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations
DEBUG_DECLARE_INSTANCE_COUNTER(CDataObject);

IMPLEMENT_ADDREF_RELEASE(CDataObject)

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
	else if (riid == IID_IDataObject)
		*ppv = (IDataObject *) this;
	else if (m_spUnknownInner)
	{
		// blind aggregation, we don't know what we're aggregating
		// with, so just pass it down.
		return m_spUnknownInner->QueryInterface(riid, ppv);
	}

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
        {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
        }
    else
		return E_NOINTERFACE;
}


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
	else
	{
		//
		// Call the derived class and see if it can handle
		// this clipboard format
		//
		hr = GetMoreDataHere(lpFormatetc, lpMedium);
	}

	return hr;
}

STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = DV_E_CLIPFORMAT;

    if (lpFormatetcIn->cfFormat == m_cfMultiSel)
    {
        ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
        if (m_internal.m_cookie != MMC_MULTI_SELECT_COOKIE)
            return E_FAIL;
        
        //return CreateMultiSelData(lpMedium);

        ASSERT(m_pbMultiSelData != 0);
        ASSERT(m_cbMultiSelData != 0);

        lpMedium->tymed = TYMED_HGLOBAL; 
        lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, 
                                          (m_cbMultiSelData + sizeof(DWORD)));
        if (lpMedium->hGlobal == NULL)
            return STG_E_MEDIUMFULL;

        BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
        *((DWORD*)pb) = m_cbMultiSelData / sizeof(GUID); 
        pb += sizeof(DWORD);
        CopyMemory(pb, m_pbMultiSelData, m_cbMultiSelData);

        ::GlobalUnlock(lpMedium->hGlobal);

        hr = S_OK;
    }
    else
    if (lpFormatetcIn->cfFormat == m_cfDynamicExtension)
    {
        if (m_pDynExt)
        {
            // get the data...
            m_pDynExt->BuildMMCObjectTypes(&lpMedium->hGlobal);

            if (lpMedium->hGlobal == NULL)
                return STG_E_MEDIUMFULL;

            hr = S_OK;
        }
    }
    else 
    if (lpFormatetcIn->cfFormat == m_cfNodeId2)
    {
        hr = CreateNodeId2(lpMedium);
    }

    return hr;
}
    
STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC lpFormatEtc)
{
    HRESULT hr = E_INVALIDARG;

    if (lpFormatEtc == NULL)
        return DV_E_FORMATETC;

    if (lpFormatEtc->lindex != -1)
        return DV_E_LINDEX;

    if (lpFormatEtc->tymed != TYMED_HGLOBAL)
        return DV_E_TYMED;

    if (!(lpFormatEtc->dwAspect & DVASPECT_CONTENT))
        return DV_E_DVASPECT;

    // these are our supported clipboard formats.  If it isn't one 
    // of these then return invalid.

    if ( (lpFormatEtc->cfFormat == m_cfNodeType) ||
         (lpFormatEtc->cfFormat == m_cfNodeTypeString) ||
         (lpFormatEtc->cfFormat == m_cfDisplayName) ||
         (lpFormatEtc->cfFormat == m_cfCoClass) ||
         (lpFormatEtc->cfFormat == m_cfInternal) ||
         (lpFormatEtc->cfFormat == m_cfNodeId2) ||
         (lpFormatEtc->cfFormat == m_cfDynamicExtension) )
    {
        hr = S_OK;
    }
	else if ((lpFormatEtc->cfFormat == m_cfMultiSel) ||
			 (lpFormatEtc->cfFormat == m_cfMultiSelDobj))
	{
		// Support multi-selection format only if this
		// is a multi-select data object
		if (m_bMultiSelDobj)
			hr = S_OK;
	}
	else
		hr = QueryGetMoreData(lpFormatEtc);

#ifdef DEBUG
    TCHAR buf[2000];

    ::GetClipboardFormatName(lpFormatEtc->cfFormat, buf, sizeof(buf));

    Trace2("CDataObject::QueryGetData - query format %s returning %lx\n", buf, hr);
#endif
    
    return hr;
}


// Note - Sample does not implement these
STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::GetCanonicalFormatEtc(LPFORMATETC lpFormatEtcIn, LPFORMATETC lpFormatEtcOut)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::SetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpMedium, BOOL bRelease)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::DAdvise(LPFORMATETC lpFormatEc, DWORD advf,
								  LPADVISESINK pAdvSink, LPDWORD pdwConn)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::DUnadvise(DWORD dwConnection)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::EnumDAdvise(LPENUMSTATDATA *ppEnumAdvise)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
		    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Create the node type object in GUID format
	SPITFSNode	spNode;
	spNode = GetDataFromComponentData();
	const GUID* pNodeType = spNode->GetNodeType();
    return Create(reinterpret_cast<const void*>(pNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
	OLECHAR szNodeType[128];
	SPITFSNode	spNode;
	spNode = GetDataFromComponentData();
	const GUID* pNodeType = spNode->GetNodeType();
	::StringFromGUID2(*pNodeType,szNodeType,128);
    return Create(szNodeType, ((wcslen(szNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager
	CString szDispName;
	SPITFSNode	spNode;
	spNode = GetDataFromComponentData();
	szDispName = spNode->GetString(-1);
    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create(reinterpret_cast<const void*>(&m_internal.m_clsid), sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreateMultiSelData(LPSTGMEDIUM lpMedium)
{
    Assert(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
        
    Assert(m_pbMultiSelData != 0);
    Assert(m_cbMultiSelData != 0);

    return Create(reinterpret_cast<const void*>(m_pbMultiSelData), 
                  m_cbMultiSelData, lpMedium);
}

HRESULT CDataObject::CreateNodeId2(LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    // Create the node type object in GUID format
	SPITFSNode	spNode;
	spNode = GetDataFromComponentData();

	SPITFSNodeHandler   spHandler;

	spNode->GetHandler(&spHandler);

    if (spHandler)
    {
        CComBSTR bstrId;
        DWORD    dwFlags = 0;

        hr = spHandler->CreateNodeId2(spNode, &bstrId, &dwFlags);
        if (SUCCEEDED(hr) && hr != S_FALSE && bstrId.Length() > 0)
        {
            int nSize = sizeof(SNodeID2) + (bstrId.Length() * sizeof(TCHAR));

            lpMedium->tymed = TYMED_HGLOBAL; 
            lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, nSize);
            if (lpMedium->hGlobal == NULL)
            {
                hr = STG_E_MEDIUMFULL;
            }
            else
            {
                SNodeID2 * pNodeId = reinterpret_cast<SNodeID2*>(::GlobalLock(lpMedium->hGlobal));

                ::ZeroMemory(pNodeId, nSize);

                pNodeId->cBytes = bstrId.Length() * sizeof(TCHAR);
                pNodeId->dwFlags = dwFlags;
                _tcscpy((LPTSTR) pNodeId->id, bstrId);

                ::GlobalUnlock(lpMedium->hGlobal);
            }
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

ITFSNode* CDataObject::GetDataFromComponentData()
{	
	SPITFSNodeMgr	spNodeMgr;
	SPITFSNode		spNode;

	Assert(m_spTFSComponentData);
	m_spTFSComponentData->GetNodeMgr(&spNodeMgr);
	spNodeMgr->FindNode(m_internal.m_cookie, &spNode);
	
	return spNode.Transfer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\dataobj.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    dataobj.h
	Implementation for data objects in the MMC

    FILE HISTORY:
	
*/

#ifndef _DATAOBJ_H
#define _DATAOBJ_H


#ifndef _COMPDATA_H_
#include "compdata.h"
#endif

#ifndef _EXTRACT_H
#include "extract.h"
#endif

#ifndef _DYNEXT_H
#include "dynext.h"
#endif

class CDataObject :
	public IDataObject
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIDataObjectMembers(IMPL)

	// Derived class should override this for custom behavior
	virtual HRESULT QueryGetMoreData(LPFORMATETC lpFormatEtc)
		{ return E_INVALIDARG; }
	virtual HRESULT GetMoreDataHere(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpMedium)
		{ return DV_E_CLIPFORMAT; }

public:
// Construction/Destruction
	// Normal constructor
    CDataObject() :
		m_cRef(1),
        m_pbMultiSelData(NULL),
        m_cbMultiSelData(0),
        m_bMultiSelDobj(FALSE),
        m_pDynExt(NULL)
	{
	    DEBUG_INCREMENT_INSTANCE_COUNTER(CDataObject);
	};

    virtual ~CDataObject() 
	{
	    DEBUG_DECREMENT_INSTANCE_COUNTER(CDataObject);
        if (m_pbMultiSelData)
            delete m_pbMultiSelData;
	};

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;  
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;             // Required by the console
    static unsigned int    m_cfMultiSel;            // Required for multiple selection
    static unsigned int    m_cfMultiSelDobj;        // Required for multiple selection
    static unsigned int    m_cfDynamicExtension;
    static unsigned int    m_cfNodeId2;
    
    static unsigned int    m_cfInternal; 

// Standard IDataObject methods
public:

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type) 
    { Assert(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; }
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    void SetClsid(const CLSID& clsid) { m_internal.m_clsid = clsid; }
    void SetVirtualIndex(int nIndex) { m_internal.m_index = nIndex; }

    BOOL HasVirtualIndex() { return m_internal.m_index != -1; }
    int  GetVirtualIndex() { return m_internal.m_index; }

    void SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData)
    {
        m_pbMultiSelData = pbMultiSelData;
        m_cbMultiSelData = cbMultiSelData;
    }

    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = TRUE;
    }

	HRESULT SetTFSComponentData(ITFSComponentData *pTFSCompData)
	{
		m_spTFSComponentData.Set(pTFSCompData);
		return hrOK;
	}

	void SetInnerIUnknown(IUnknown *punk)
	{
		m_spUnknownInner.Set(punk);
	}

    void SetDynExt(CDynamicExtensions * pDynExt) { m_pDynExt = pDynExt; }
    CDynamicExtensions * GetDynExt() { return m_pDynExt; }

protected:
    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
	ITFSNode* GetDataFromComponentData();

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); 
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateMultiSelData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeId2(LPSTGMEDIUM lpMedium);

    INTERNAL            m_internal;   

// pointer to the ComponentData
private:

    long	            m_cRef;

	SPITFSComponentData	m_spTFSComponentData;

    BYTE*               m_pbMultiSelData;
    UINT                m_cbMultiSelData;
    BOOL                m_bMultiSelDobj;

    CDynamicExtensions *m_pDynExt;

    // pointer to inner unknown
	SPIUnknown	        m_spUnknownInner;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\ctrlgrp.h ===
/*--------------------------------------------------------------------------
	ctrlgrp.h
		Control group switcher

	Copyright (C) Microsoft Corporation, 1993 - 1997
	All rights reserved.

	Authors:
		matth	Matthew F. Hillman, Microsoft

	History:
		10/14/93	matth	Created.
		26 oct 95	garykac	DBCS_FILE_CHECK
  --------------------------------------------------------------------------*/


#ifndef _CTRLGRP_H
#define _CTRLGRP_H

/*
#if defined(_DEBUG) && defined(INLINE)
#undef THIS_FILE
extern char BASED_CODE CTRLGRP_H[];
#define THIS_FILE CTRLGRP_H
#endif
*/
#define INLINE				inline

#define fTrue				TRUE
#define fFalse				FALSE
#define g_fWin4				FALSE
#define g_fWinNT			TRUE
#define EDIT_NORMAL_WIDE	L"EDIT"

class RGControlInfo;

class CGControlInfo
{
	friend class RGControlInfo;
	friend class ControlGroup;
public:	
	CGControlInfo();
	CGControlInfo(const CGControlInfo & cgciCopy);
	~CGControlInfo();
	//DeclareStdDebugMembers()
	
	HWND m_hwnd;
};

//DeclareGenericArrayBegin(RGControlInfo, CGControlInfo, 10)
//	DeclareGenericArrayAccessors(RGControlInfo, CGControlInfo)
//	DeclareGenericArrayConstructDestruct(RGControlInfo, CGControlInfo)
//	DeclareGenericArrayDebug(RGControlInfo, CGControlInfo)
//DeclareGenericArrayEnd

typedef CArray<CGControlInfo, CGControlInfo> tempRGControlInfo;

class RGControlInfo : public tempRGControlInfo
{
};

class ControlGroup : public CObject
{
public:
	// INITIALIZATION
	ControlGroup(int idGroup, int idd, void (*pfnInit)(CWnd * pwndParent));
	~ControlGroup();
	
	//DeclareStdDebugMembers()

public:
	// APIS
	void LoadGroup(CWnd * pwndParent, int xOffset, int yOffset);
	void UnloadGroup();
	void ShowGroup(HDWP& hdwp, BOOL fShow = fTrue, CWnd *pwndParent = NULL);
	void EnableGroup(BOOL fEnable);
	
	int IDGroup() const;
	BOOL FLoaded() const;
	BOOL FVisible() const;
	int CControls() const;

	void AddControl(HWND hwnd);
	void RemoveControl(HWND hwnd);

private:

	static void MaskAccelerator(HWND hwnd, BOOL fMask);

#ifdef WIN16
	void LoadWin16DialogResource(HWND hDlg, BYTE FAR *lpDlgRes, int x, int y);
#else
	void LoadWin32DialogResource(HWND hDlg, BYTE FAR *lpDlgRes, int x, int y);
#endif
	
	int m_idGroup;
	int m_idd;
	void (*m_pfnInit)(CWnd * pwndParent);
	RGControlInfo m_rgControls;
	BOOL m_fLoaded;
	BOOL m_fVisible;
};

typedef ControlGroup * PControlGroup;

//DeclareGenericArrayBegin(RGPControlGroup, PControlGroup, 10)
//	DeclareGenericArrayAccessors(RGPControlGroup, PControlGroup)
//	DeclareGenericArrayDebug(RGPControlGroup, PControlGroup)
//	long GroupIndex(int idGroup) const;
//	PControlGroup PGroup(int idGroup) const;
//DeclareGenericArrayEnd

typedef CArray<PControlGroup, PControlGroup> tempRGPControlGroup;

class RGPControlGroup : public tempRGPControlGroup
{
public:
	long GroupIndex(int idGroup) const;
	PControlGroup PGroup(int idGroup) const;
};

enum
{
	cgsPreCreateAll, cgsCreateOnDemand, cgsCreateDestroyOnDemand
};

class ControlGroupSwitcher : public CObject
{
public:
	// INITIALIZATION
	ControlGroupSwitcher();
	void Create(CWnd * pwndParent, int idcAnchor, int cgsStyle);
	~ControlGroupSwitcher();

	//DeclareStdDebugMembers();

public:
	// APIS
	void AddGroup(int idGroup, int idd, void (*pfnInit)(CWnd * pwndParent));
	void RemoveGroup(int idGroup);
	void ShowGroup(int idGroup);
	int GetCurrentGroupID() const;
	void AddControlToGroup(int idGroup, HWND hwnd);
	void RemoveControlFromGroup(int idGroup, HWND hwnd);
	void EnableGroup(int idGroup, BOOL fEnable);

private:
	void ComputeAnchorOffsets();
	
	RGPControlGroup m_rgpGroups;
	int m_iGroup;
	CWnd * m_pwndParent;
	int m_cgsStyle;
	int m_idcAnchor;
	int m_xOffset;
	int m_yOffset;
};

#ifdef INLINE

INLINE CGControlInfo::CGControlInfo()
	: m_hwnd(NULL)
{
}

INLINE CGControlInfo::CGControlInfo(const CGControlInfo & cgciCopy)
	: m_hwnd(cgciCopy.m_hwnd)
{
}

INLINE CGControlInfo::~CGControlInfo()
{
	//$ REVIEW: Don't destroy windows -- probably already gone (like in dlg)
//	if (m_hwnd)
//		::DestroyWindow(m_hwnd);
}

INLINE int ControlGroup::IDGroup() const
{
	return m_idGroup;
}

INLINE BOOL ControlGroup::FLoaded() const
{
	return m_fLoaded;
}

INLINE BOOL ControlGroup::FVisible() const
{
	return m_fVisible;
}

INLINE BOOL ControlGroup::CControls() const
{
	Assert(FLoaded());
	return (int)m_rgControls.GetSize();
}

INLINE PControlGroup RGPControlGroup::PGroup(int idGroup) const
{
	return GetAt(GroupIndex(idGroup));
}

INLINE int ControlGroupSwitcher::GetCurrentGroupID() const
{
	return m_iGroup;
}

INLINE void ControlGroupSwitcher::AddControlToGroup(int idGroup, HWND hwnd)
{
	m_rgpGroups.PGroup(idGroup)->AddControl(hwnd);
}

INLINE void ControlGroupSwitcher::RemoveControlFromGroup(int idGroup,
														 HWND hwnd)
{
	m_rgpGroups.PGroup(idGroup)->RemoveControl(hwnd);
}

#endif // INLINE

#endif // _CTRLGRP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\ctrlgrp.cpp ===
/*--------------------------------------------------------------------------
	ctrlgrp.cpp
		Control group switcher

	Copyright (C) Microsoft Corporation, 1993 - 1999
	All rights reserved.

	Authors:
		matth	Matthew F. Hillman, Microsoft

	History:
		10/14/93	matth	Created.
		26 oct 95	garykac	DBCS_FILE_CHECK
  --------------------------------------------------------------------------*/

//#include "precomp.h"
#include "stdafx.h"

//#ifndef _GUISTD_H
//#include "guistd.h"
//#endif

#ifndef _CTRLGRP_H
#include "ctrlgrp.h"
#endif

//#ifndef	_GLOBALS_H
//#include "globals.h"
//#endif

//#include "richres.h"

/*
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = "ctrlgrp.cpp";
#endif
*/

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// DIALOGEX structures (from MFC 4.0)
#pragma pack(push, 1)
typedef struct
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cdit;
	short x;
	short y;
	short cx;
	short cy;
} DLGTEMPLATEEX;

typedef struct
{
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	short x;
	short y;
	short cx;
	short cy;
	DWORD id;
} DLGITEMTEMPLATEEX;
#pragma pack(pop)

/*!C------------------------------------------------------------------------
	ControlGroupSwitcher

	This class is used to manage switching among groups of controls in a
	parent window.

	Primary APIs are:
	
		Create -- The pwndParent parameter is the window which will be the
		parent of the controls in the control groups.  It is commonly a
		dialog.  The idcAnchor parameter is the id of a control which will
		server as an 'anchor' for the controls.  This means that the controls
		will created in the parent window offset by the position of the
		top left corner of the anchor control.  This control is commonly
		a group box surrounding the area where the groups appear.  The
		cgsStyle parameter specifieds whether the the controls in the groups
		are created right away (cgsPreCreateAll), only when that group is
		shown (cgsCreateOnDemand), or created each time the group is shown
		and destroyed when they are hidden (cgsCreateDestroyOnDemand).

		AddGroup -- Adds a group of controls, which can be shown using
		ShowGroup.  The idGroup parameter identifies the group, and is used
		as the parameter to ShowGroup.  The idd parameter is the id of the
		dialog template with the layout of the controls.  The pfnInit
		parameter, if not NULL, is a function called when the group is
		loaded.  Note that -1 is not a legal value for idGroup (it is a
		distinguised value meaning no group).

		RemoveGroup -- Removes the group specified by idGroup, destroying the
		controls if they have been created.

		ShowGroup -- Show the group specified by idGroup, hiding any other
		group.  If -1, hides all groups.
  --------------------------------------------------------------------------*/

#if 0
BOOL CGControlInfo::MarkMem(IDebugContext * pdbc, long cRef)
{
	if (pdbc->MarkMem(this,sizeof(*this),cRef))
		return fTrue;

	return fFalse;
}

void CGControlInfo::AssertValid() const
{
}

void CGControlInfo::Dump(CDumpContext &dc) const
{
}
#endif // DEBUG

//ImplementGenericArrayConstructDestruct(RGControlInfo, CGControlInfo)
//ImplementGenericArrayDebug(RGControlInfo, CGControlInfo)

ControlGroup::ControlGroup(int idGroup, int idd,
						   void (*pfnInit)(CWnd * pwndParent))
	: m_idGroup(idGroup), m_idd(idd), m_pfnInit(pfnInit),
	  m_fLoaded(fFalse), m_fVisible(fFalse)
{
}

ControlGroup::~ControlGroup()
{
	m_rgControls.RemoveAll();
}

#if 0
BOOL ControlGroup::MarkMem(IDebugContext * pdbc, long cRef)
{
	if (pdbc->MarkMem(this,sizeof(*this),cRef))
		return fTrue;

	MarkCObject(pdbc,this,0);
		
	m_rgControls.MarkMem(pdbc,0);

	return fFalse;
}

void ControlGroup::AssertValid() const
{
	m_rgControls.AssertValid();
}

void ControlGroup::Dump(CDumpContext &dc) const
{
}
#endif // DEBUG

void ControlGroup::LoadGroup(CWnd * pwndParent, int xOffset, int yOffset)
{
	/*------------------------------------------------------------------------
	This function is mostly stolen from the Knowledge Base code for the
	'multidlg' example.

	That's why it uses mostly raw Windows rather than MFC conventions.
	------------------------------------------------------------------------*/
	
	HWND			hDlg = NULL;
	HGLOBAL         hDlgResMem = NULL;
	HRSRC           hDlgRes = NULL;
	BYTE FAR        *lpDlgRes = NULL;

//	PutAssertCanThrow();
	TRY
		{
		Assert(!m_fLoaded);

		hDlg = pwndParent->m_hWnd;
		Assert(hDlg);

		// Load the resource into memory and get a pointer to it.

		hDlgRes    = FindResource (AfxGetResourceHandle(),
								   MAKEINTRESOURCE(m_idd),
								   RT_DIALOG);
		if (!hDlgRes)
			AfxThrowResourceException();
		hDlgResMem = LoadResource (AfxGetResourceHandle(), hDlgRes);
		if (!hDlgResMem)
			AfxThrowResourceException();
		lpDlgRes   = (BYTE FAR *) LockResource (hDlgResMem);
		if (!lpDlgRes)
			AfxThrowResourceException();

		LoadWin32DialogResource(hDlg, lpDlgRes, xOffset, yOffset);

		m_fLoaded = fTrue;

		// Free the resource which we just parsed.

		UnlockResource (hDlgResMem);
		FreeResource (hDlgResMem);

		// Send the new child an init message
		if (m_pfnInit)
			(*m_pfnInit)(pwndParent);
			}
	CATCH_ALL(e)
		{
		if (hDlgRes && hDlgResMem)
			{
			if (lpDlgRes)
				UnlockResource(hDlgResMem);
			FreeResource(hDlgResMem);
			}
		m_rgControls.RemoveAll();
		THROW_LAST();
		}
	END_CATCH_ALL
}


void ControlGroup::LoadWin32DialogResource(
		HWND hDlg, 
		BYTE FAR *lpDlgRes,
		int	xOffset,
		int	yOffset)
{
	BOOL			fEx;
    RECT            rc;
	SMALL_RECT		srct;
    HFONT			hDlgFont;
    DWORD           style;
	DWORD			exstyle;
    DWORD            dwID;
    WORD			wCurCtrl;
	WORD			wNumOfCtrls;
    LPWSTR           classname;
	WORD FAR *		lpwDlgRes;
	char			pszaClassName[256];
	char 			pszaTitle[256];

	// We need to get the font of the dialog so we can set the font of
	// the child controls.  If the dialog has no font set, it uses the
	// default system font, and hDlgFont equals zero.

	hDlgFont = (HFONT) SendMessage (hDlg, WM_GETFONT, 0, 0L);

	// Figure out if this is a DIALOGEX resource
	fEx = ((DLGTEMPLATEEX *)lpDlgRes)->signature == 0xFFFF;

	// Grab all the stuff we need out of the headers
	if (fEx)
		{
		style = ((DLGTEMPLATEEX *)lpDlgRes)->style;
		wNumOfCtrls = ((DLGTEMPLATEEX *)lpDlgRes)->cdit;
		lpDlgRes += sizeof(DLGTEMPLATEEX);
		}
	else
		{
		style = ((DLGTEMPLATE *)lpDlgRes)->style;
		wNumOfCtrls = ((DLGTEMPLATE *)lpDlgRes)->cdit;
		lpDlgRes += sizeof(DLGTEMPLATE);
		}

	// Skip the variable sized information
	lpwDlgRes = (LPWORD)lpDlgRes;
	if (0xFFFF == *lpwDlgRes)
		lpwDlgRes += 2;					// menu by ordinal, skip ffff & ordinal
	else
		lpwDlgRes += wcslen(lpwDlgRes) + 1;	// Menu by name or no menu at all

	if (0xFFFF == *lpwDlgRes)
		lpwDlgRes += 2;					// classname by ordinal, skip
	else
		lpwDlgRes += wcslen(lpwDlgRes) + 1;

	lpwDlgRes += wcslen(lpwDlgRes) + 1;       // Pass the caption

	// Some fields are present only if DS_SETFONT is specified.

	if (style & DS_SETFONT)
		{
		lpwDlgRes += fEx ? 3 : 1;		// skip point size, (weight, and style)
		lpwDlgRes += wcslen(lpwDlgRes) + 1;       // Pass face name
		}

	// Allocate space in the control info array
	m_rgControls.SetSize(wNumOfCtrls);

	// The rest of the dialog template contains ControlData structures.
	// We parse these structures and call CreateWindow() for each.

	for (wCurCtrl = 0; wCurCtrl < wNumOfCtrls; wCurCtrl++)
		{
		// ControlData coordinates are in dialog units.  We need to convert
		// these to pixels before adding the anchor offset
		// Should be Word Aligned
		Assert(!((ULONG_PTR) lpwDlgRes & (0x1)));
		// Make it DWORD aligned
		if (((ULONG_PTR)(lpwDlgRes)) & (0x2))
			lpwDlgRes += 1;

		// Get the header info we need
		if (fEx)
			{
			style = ((DLGITEMTEMPLATEEX *)lpwDlgRes)->style;
			exstyle = ((DLGITEMTEMPLATEEX *)lpwDlgRes)->exStyle;
			srct = *(SMALL_RECT *)(&((DLGITEMTEMPLATEEX *)lpwDlgRes)->x);
			dwID = ((DLGITEMTEMPLATEEX *)lpwDlgRes)->id;
			lpwDlgRes = (LPWORD)((LPBYTE)lpwDlgRes + sizeof(DLGITEMTEMPLATEEX));
			}
		else
			{
			style = ((DLGITEMTEMPLATE *)lpwDlgRes)->style;
			exstyle = 0;
			srct = *(SMALL_RECT *)(&((DLGITEMTEMPLATE *)lpwDlgRes)->x);
			dwID = ((DLGITEMTEMPLATE *)lpwDlgRes)->id;
			lpwDlgRes = (LPWORD)((LPBYTE)lpwDlgRes + sizeof(DLGITEMTEMPLATE));
			}

		style &= ~WS_VISIBLE;			// Create invisible!

		// use the rc structure as x,y,width,height

		rc.top = srct.Top;
		rc.bottom = srct.Bottom;
		rc.left = srct.Left;
		rc.right = srct.Right;

		MapDialogRect (hDlg, &rc);                    // Convert to pixels.
		rc.left += xOffset;                           // Add the offset.
		rc.top += yOffset;

		// At this point in the ControlData structure (see "Dialog Box
		// Resource" in online help), the class of the control may be
		// described either with text, or as a byte with a pre-defined
		// meaning.

		if (*lpwDlgRes == 0xFFFF)
			{
			lpwDlgRes++; 		// Skip the FFFF
			switch (*lpwDlgRes)
				{
				case 0x0080:
					classname = L"button";		// STRING_OK
					break;
				case 0x0081:
					classname = EDIT_NORMAL_WIDE;
					//$ The strange code below fixes 3D problems
					// on Win95
					//if (g_fWin4 && !g_fWinNT)
						exstyle |= WS_EX_CLIENTEDGE;
					break;
				case 0x0082:
					classname = L"static";		// STRING_OK
					break;
				case 0x0083:
					classname = L"listbox";		// STRING_OK
					exstyle |= WS_EX_CLIENTEDGE;
					break;
				case 0x0084:
					classname = L"scrollbar";	// STRING_OK
					break;
				case 0x0085:
					classname = L"combobox";	// STRING_OK
					break;
				default:
					// Next value is an atom
					AssertSz(fFalse,"Illegal Class Value in Dialog Template");
					//$Review: Can this be any atom or must it be an enumerated
					//    value from above?
				}
			lpwDlgRes++;  // passes the class identifier
			}
		else
			{
			classname = (WCHAR *)lpwDlgRes;
			lpwDlgRes += wcslen(lpwDlgRes) + 1;
			exstyle |= WS_EX_CLIENTEDGE;
			}

		//$32 review: is this correct matt?
		// Be sure to use the UNICODE function, all the data should
		// be in UNICODE
		m_rgControls[wCurCtrl].m_hwnd =
						CreateWindowExW (exstyle, classname, (LPWSTR)lpwDlgRes,
										 style, (int) rc.left, (int) rc.top,
										 (int) rc.right, (int) rc.bottom,
										 hDlg, (HMENU)ULongToPtr(dwID),
										 (HINSTANCE) AfxGetInstanceHandle(),
										 NULL);

		// There is no CreateWindowExW in Win95 so convert the strings to ANSI
		if (m_rgControls[wCurCtrl].m_hwnd == NULL &&
			GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
			{
			if (!WideCharToMultiByte(CP_ACP,0,classname,-1,pszaClassName,256,NULL,NULL) ||
				!WideCharToMultiByte(CP_ACP,0,(LPWSTR)lpwDlgRes, -1, pszaTitle, 256, NULL,NULL))
				{				
				AssertSz(fFalse, "WideCharToMultiByteFailed");
				AfxThrowResourceException();
				}
			m_rgControls[wCurCtrl].m_hwnd = 
						CreateWindowExA(exstyle,pszaClassName, pszaTitle,
										style,(int) rc.left, (int) rc.top,
										(int) rc.right, (int) rc.bottom,
										hDlg, (HMENU)ULongToPtr(dwID),
										(HINSTANCE) AfxGetInstanceHandle(),
										NULL);

			}

		if (!m_rgControls[wCurCtrl].m_hwnd)
			AfxThrowResourceException();

		MaskAccelerator(m_rgControls[wCurCtrl].m_hwnd, fTrue); // Make sure all the accelerators are disabled

		// Pass the window text
		if (0xFFFF == *lpwDlgRes)
			lpwDlgRes += 2;
		else
			lpwDlgRes += wcslen(lpwDlgRes) + 1;

		// skip over creation data
		lpwDlgRes = (LPWORD)((LPBYTE)lpwDlgRes + *lpwDlgRes + 2);
		// see DYNDLG SDK example, this is a size word in Win32


		// Even though the font is the right size (MapDialogRect() did 
		// this), we also need to set the font if it's not the system font.
		if (hDlgFont)
			::SendMessage(m_rgControls[wCurCtrl].m_hwnd,WM_SETFONT,
						  (WPARAM)hDlgFont,(LPARAM)fFalse);
		}
}

void ControlGroup::UnloadGroup()
{
	Assert(m_fLoaded);
	
	m_rgControls.RemoveAll();
	m_fLoaded = fFalse;
}

void ControlGroup::ShowGroup(HDWP& hdwp, BOOL fShow, CWnd * pwnd)
{
	long i,n;
	UINT rgfSwp;
	HWND hwndInsertAfter = NULL;
	
	if (pwnd)
		hwndInsertAfter = pwnd->m_hWnd;

	Assert((fShow && !m_fVisible) || (m_fVisible && !fShow));
	Assert(m_fLoaded);

	rgfSwp = SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE |(pwnd != NULL ? 0 : SWP_NOZORDER)|
			 (fShow ? SWP_SHOWWINDOW : SWP_HIDEWINDOW);
	for (i = 0, n = (long)m_rgControls.GetSize(); i < n; i++)
		{
		HWND hwnd = m_rgControls[i].m_hwnd;
		MaskAccelerator(hwnd, !fShow);
		hdwp = DeferWindowPos(hdwp,hwnd,hwndInsertAfter,0,0,0,0,rgfSwp);
		hwndInsertAfter = hwnd;
		}
	m_fVisible = fShow;
}

void ControlGroup::EnableGroup(BOOL fEnable)
{
	long i,n;

	Assert(m_fLoaded);

	for (i = 0, n = (long)m_rgControls.GetSize(); i < n; i++)
	{
		HWND hwnd = m_rgControls[i].m_hwnd;
		::EnableWindow(hwnd, fEnable);
	}
}

void ControlGroup::AddControl(HWND hwnd)
{
	Assert(m_fLoaded);
	
	int nNewIndex = (int)m_rgControls.Add(CGControlInfo());

	m_rgControls[nNewIndex].m_hwnd = hwnd;
}

void ControlGroup::RemoveControl(HWND hwnd)
{
	long i, n;
	
	Assert(m_fLoaded);

	for (i = 0, n = (long)m_rgControls.GetSize(); i < n; i++)
	{
		if (m_rgControls[i].m_hwnd == hwnd)
		{
			m_rgControls.RemoveAt(i);
			return;
		}
	}

	Assert(fFalse);
}

void ControlGroup::MaskAccelerator(HWND hwnd, BOOL fMask)
{
	TCHAR szText[256];
	TCHAR * psz;
	DWORD_PTR dwCtlCode;
	
	// Ignore text of controls which accept text (like edit controls)
	// and of static controls which have the SS_NOPREFIX style.

	dwCtlCode = SendMessage (hwnd, WM_GETDLGCODE, 0, 0L);
	if (DLGC_WANTCHARS & dwCtlCode)
		return;
	if (DLGC_STATIC & dwCtlCode)
		{
		LONG lStyle;
		
		lStyle = GetWindowLong (hwnd, GWL_STYLE);
                
		if (SS_NOPREFIX & lStyle)
			return;
		}

	// DBCS_OK [tatsuw]

	// Don't have a really long label
	Assert(GetWindowTextLength(hwnd) < DimensionOf(szText));
	
	GetWindowText (hwnd, szText, DimensionOf(szText));
	
	// Don't have |s in your text
	Assert((!fMask) || (_tcschr(szText, TEXT('|')) == NULL));
	
	psz = szText;
	while ((psz = _tcschr(psz, fMask ? TEXT('&') : TEXT('|'))) != NULL)
		{
		if (fMask && psz[1] == '&')
			{
			// Special! Ignore double ampersand
			psz++;
			continue;
			}
		*psz = fMask ? TEXT('|') : TEXT('&');
		SetWindowText(hwnd, szText);
		break;
		}
}

#if 0
void RGPControlGroup::AssertValidGen(GEN *pgen) const
{
	ControlGroup * pGroup = *(PControlGroup *)pgen;
	if (pGroup)
		pGroup->AssertValid();
}

void RGPControlGroup::MarkMemGen(IDebugContext *pdbc, GEN *pgen)
{
	ControlGroup * pGroup = *(PControlGroup *)pgen;
	pGroup->MarkMem(pdbc,0);
}
#endif

long RGPControlGroup::GroupIndex(int idGroup) const
{
	long i, n;

	for (i = 0, n = (long)GetSize(); i < n; i++)
		if ((GetAt(i))->IDGroup() == idGroup)
			return i;

	Assert(fFalse);
	return -1;
}

ControlGroupSwitcher::ControlGroupSwitcher()
	: m_iGroup(-1), m_pwndParent(NULL)
{
}

void ControlGroupSwitcher::Create(CWnd * pwndParent, int idcAnchor,
								  int cgsStyle)
{
	m_pwndParent = pwndParent;
	m_idcAnchor = idcAnchor;
	m_cgsStyle = cgsStyle;
	ComputeAnchorOffsets();
}


ControlGroupSwitcher::~ControlGroupSwitcher()
{
	for (long i = 0, n = (long)m_rgpGroups.GetSize(); i < n; i++)
		{
		delete m_rgpGroups[i];
		m_rgpGroups[i] = NULL;
		}
	
	m_rgpGroups.RemoveAll();
}

#if 0
BOOL ControlGroupSwitcher::MarkMem(IDebugContext * pdbc, long cRef)
{
	if (pdbc->MarkMem(this,sizeof(*this),cRef))
		return fTrue;
	
	MarkCObject(pdbc,this,0);

	m_rgpGroups.MarkMem(pdbc,0);

	return fFalse;
}

void ControlGroupSwitcher::AssertValid() const
{
	m_rgpGroups.AssertValid();
}

void ControlGroupSwitcher::Dump(CDumpContext &dc) const
{
}
#endif // DEBUG

void ControlGroupSwitcher::AddGroup(int idGroup, int idd,
									void (*pfnInit)(CWnd * pwndParent))
{
	ControlGroup * pGroupNew = NULL;

	TRY
	{
    	pGroupNew = new ControlGroup(idGroup, idd, pfnInit);
	
        m_rgpGroups.Add(pGroupNew);
	}
	CATCH_ALL(e)
	{
		delete pGroupNew;
		THROW_LAST();
	}
	END_CATCH_ALL

	// In a stable state now.  Possibly load controls which might also throw
	if (m_cgsStyle == cgsPreCreateAll)
		pGroupNew->LoadGroup(m_pwndParent, m_xOffset, m_yOffset);
}

void ControlGroupSwitcher::RemoveGroup(int idGroup)
{
	// Don't remove group being shown!  Show another group first.
	Assert(idGroup != m_iGroup);
	
	long index;
	ControlGroup * pGroup;

	index = m_rgpGroups.GroupIndex(idGroup);
	pGroup = m_rgpGroups[index];
	delete pGroup;
	m_rgpGroups.RemoveAt(index);
}

void ControlGroupSwitcher::EnableGroup(int idGroup, BOOL fEnable)
{
	long index;
	ControlGroup * pGroup;

	if (idGroup = -1)
		idGroup = m_iGroup;

	index = m_rgpGroups.GroupIndex(idGroup);
	pGroup = m_rgpGroups[index];
	
	pGroup->EnableGroup(fEnable);
}

void ControlGroupSwitcher::ShowGroup(int idGroup)
{
	ControlGroup * pGroupOld = NULL;
	ControlGroup * pGroupNew = NULL;
	HDWP hdwp;
	int cWindows;
	
	if (m_iGroup == idGroup)
		return;

	cWindows = 0;
	
	if (m_iGroup != -1)
	{
		pGroupOld = m_rgpGroups.PGroup(m_iGroup);
		Assert(pGroupOld->FVisible());
		cWindows += pGroupOld->CControls();
	}
	
	if (idGroup != -1)
	{
		pGroupNew = m_rgpGroups.PGroup(idGroup);
		if (!pGroupNew->FLoaded())
			pGroupNew->LoadGroup(m_pwndParent, m_xOffset, m_yOffset);
		cWindows += pGroupNew->CControls();
	}

	hdwp = BeginDeferWindowPos(cWindows);
	if (!hdwp)
		AfxThrowResourceException();

	if (m_iGroup != -1)
		{
		pGroupOld->ShowGroup(hdwp,fFalse, NULL);
		if (m_cgsStyle == cgsCreateDestroyOnDemand)
			pGroupOld->UnloadGroup();
		}

	// Indicate we currently have no group, in case below throws
	m_iGroup = -1;

	if (idGroup != -1)
		{
		pGroupNew->ShowGroup(hdwp, fTrue, m_pwndParent->GetDlgItem(m_idcAnchor));
		m_iGroup = idGroup;
		}

	EndDeferWindowPos(hdwp);
}

void ControlGroupSwitcher::ComputeAnchorOffsets()
{
	/*------------------------------------------------------------------------
	Note that anchor offset is computed relative to upper left.
	Intended use: Make an invisible group box where you want your controls.
	------------------------------------------------------------------------*/
	
	CWnd * pwndAnchor;
	RECT rc;
	LPPOINT ppt;

	pwndAnchor = m_pwndParent->GetDlgItem(m_idcAnchor);
	Assert(pwndAnchor);

	pwndAnchor->GetWindowRect(&rc);
	ppt = (LPPOINT)&rc;
	m_pwndParent->ScreenToClient(ppt);
	ppt++;
	m_pwndParent->ScreenToClient(ppt);

	m_xOffset = (int) rc.left;
	m_yOffset = (int) rc.top;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\dialog.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dialog.cpp
        base dialog class to handle help
        
    FILE HISTORY:
    	7/10/97     Eric Davison        Created

*/

#include "stdafx.h"
#include "dialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*---------------------------------------------------------------------------
	Global help map
 ---------------------------------------------------------------------------*/
PFN_FINDHELPMAP	g_pfnHelpMap = NULL;

/*!--------------------------------------------------------------------------
	SetGlobalHelpMapFunction
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SetGlobalHelpMapFunction(PFN_FINDHELPMAP pfnHelpFunction)
{
	g_pfnHelpMap = pfnHelpFunction;
}



IMPLEMENT_DYNAMIC(CBaseDialog, CDialog)

CBaseDialog::CBaseDialog()
{
}

CBaseDialog::CBaseDialog(UINT nIDTemplate, CWnd *pParent)
	: CDialog(nIDTemplate, pParent)
{
}

BEGIN_MESSAGE_MAP(CBaseDialog, CDialog)
	//{{AFX_MSG_MAP(CBaseDialogDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
			
END_MESSAGE_MAP()


HWND FixupIpAddressHelp(HWND hwndItem)
{
	HWND	hwndParent;
	TCHAR	szClassName[32];	 // should be enough to hold "RtrIpAddress"
	
	// If any of these calls fail, bail and pass the call down
	hwndParent = ::GetParent(hwndItem);
	if (hwndParent)
	{
		if (::GetClassName(hwndParent, szClassName, DimensionOf(szClassName)))
		{
			// Ensure that the string is NULL terminated
			szClassName[DimensionOf(szClassName)-1] = 0;
			
			if (lstrcmpi(szClassName, TEXT("IPAddress")) == 0)
			{
				// Ok, this control is part of the IP address
				// control, return the handle of the parent
				hwndItem = hwndParent;
			}
		}
		
	}
	return hwndItem;
}

/*!--------------------------------------------------------------------------
	CBaseDialog::OnHelpInfo
		Brings up the context-sensitive help for the controls.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL CBaseDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	int		i;
	DWORD	dwCtrlId;

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		DWORD *	pdwHelp	= GetHelpMapInternal();

        if (pdwHelp)
        {
		    // Ok to fix the f**king help for the f**king IP address
		    // controls, we will need to add special case code.  If we
		    // can't find the id of our control in our list, then we look
		    // to see if this is the child of the "RtrIpAddress" control, if
		    // so then we change the pHelpInfo->hItemHandle to point to the
		    // handle of the ip address control rather than the control in
		    // the ip addrss control.  *SIGH*
		    dwCtrlId = ::GetDlgCtrlID((HWND) pHelpInfo->hItemHandle);
		    for (i=0; pdwHelp[i]; i+=2)
		    {
			    if (pdwHelp[i] == dwCtrlId)
				    break;
		    }

		    if (pdwHelp[i] == 0)
		    {
			    // Ok, we didn't find the control in our list, so let's
			    // check to see if it's part of the IP address control.
			    pHelpInfo->hItemHandle = FixupIpAddressHelp((HWND) pHelpInfo->hItemHandle);
		    }

#ifdef DEBUG
			LPCTSTR pszTemp = AfxGetApp()->m_pszHelpFilePath;
#endif
			::WinHelp ((HWND)pHelpInfo->hItemHandle,
			           AfxGetApp()->m_pszHelpFilePath,
			           HELP_WM_HELP,
			           (ULONG_PTR)pdwHelp);
        }
	}
	
	return TRUE;
}

/*!--------------------------------------------------------------------------
	CBaseDialog::OnContextMenu
		Brings up the help context menu for those controls that don't
		usually have context menus (i.e. buttons).  Note that this won't
		work for static controls since they just eat up all messages.
	Author: EricDav
 ---------------------------------------------------------------------------*/
void CBaseDialog::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	if (this == pWnd)
		return;

	DWORD * pdwHelp = GetHelpMapInternal();

    if (pdwHelp)
    {
	    ::WinHelp (pWnd->m_hWnd,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_CONTEXTMENU,
		           (ULONG_PTR)pdwHelp);
    }
}

/*!--------------------------------------------------------------------------
	CBaseDialog::GetHelpMapInternal
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD * CBaseDialog::GetHelpMapInternal()
{
	DWORD	*	pdwHelpMap = NULL;
	DWORD		dwIDD = 0;

//	if (HIWORD(m_lpszTemplateName) == 0)
//		dwIDD = LOWORD((DWORD) m_lpszTemplateName);
	if ((ULONG_PTR) m_lpszTemplateName < 0xFFFF)
		dwIDD = (WORD) m_lpszTemplateName;
	
	// If there is no dialog IDD, give up
	// If there is no global help map function, give up
	if ((dwIDD == 0) ||
		(g_pfnHelpMap == NULL) ||
		((pdwHelpMap = g_pfnHelpMap(dwIDD)) == NULL))
		return GetHelpMap();

	return pdwHelpMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\dialog.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dialog.h
        base dialog class to handle help
        
    FILE HISTORY:
    	7/10/97     Eric Davison        Created

*/

#ifndef _DIALOG_H_
#define _DIALOG_H_


//----------------------------------------------------------------------------
//	Class:	CBaseDialog
//
//	This class is used to hold all common dialog code.  Specifically, the
//	help code.  What this requires is that the dialog user override the
//	GetHelpMap function and return the array of help IDs.  CBaseDialog does 
//  NOT free this array up, it is up to the derived class to do so.
//
//	An additional way (which is a hack, but it helps because Kenn is so
//	lazy) is to use the SetGlobalHelpMapFunction().  If we find a global
//	help function, we will use that before calling GetHelpMap().
//
//	The overridden function gets called each time a help request comes in
//  to pass the help IDs to WinHelp.
//----------------------------------------------------------------------------

class CBaseDialog : public CDialog 
{
public:
    DECLARE_DYNAMIC(CBaseDialog)
			
	CBaseDialog();
	CBaseDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);

	// Use this call to get the actual help map
	// this version will check the global help map first.
	DWORD *		GetHelpMapInternal();
	
    // override this to return the app specific help map
    virtual DWORD * GetHelpMap() { return NULL; }
    
protected:
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);

	DECLARE_MESSAGE_MAP()
};

HWND FixupIpAddressHelp(HWND hwndItem);


/*---------------------------------------------------------------------------
	The functions below are used to setup the global help map for use
	by the property pages and the dialog code.
 ---------------------------------------------------------------------------*/
typedef DWORD *	(*PFN_FINDHELPMAP)(DWORD dwIDD);
void	SetGlobalHelpMapFunction(PFN_FINDHELPMAP pfnHelpFunction);

#endif // _COMMON_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\dynext.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    dynext.cpp
	    dynamic extension helper

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "Dynext.h"
#include "tregkey.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TCHAR g_szContextMenu[] = TEXT("ContextMenu");
const TCHAR g_szNameSpace[] = TEXT("NameSpace");
const TCHAR g_szPropertySheet[] = TEXT("PropertySheet");
const TCHAR g_szToolbar[] = TEXT("Toolbar");
const TCHAR g_szExtensions[] = TEXT("Extensions");
const TCHAR g_szTask[] = TEXT("Task");
const TCHAR g_szDynamicExtensions[] = TEXT("Dynamic Extensions");

const TCHAR NODE_TYPES_KEY[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR SNAPINS_KEY[] = TEXT("Software\\Microsoft\\MMC\\SnapIns");


CDynamicExtensions::CDynamicExtensions()
{
    m_bLoaded = FALSE;
}

CDynamicExtensions::~CDynamicExtensions()
{
}

HRESULT 
CDynamicExtensions::SetNode(const GUID * guid)
{
    m_guidNode = *guid;

    return hrOK;
}

HRESULT 
CDynamicExtensions::Reset()
{
    HRESULT hr = hrOK;

    m_aNameSpace.RemoveAll();
    m_aMenu.RemoveAll();
    m_aToolbar.RemoveAll();
    m_aPropSheet.RemoveAll();
    m_aTask.RemoveAll();

    m_bLoaded = FALSE;

    return hr;
}

HRESULT 
CDynamicExtensions::Load()
{
    HRESULT     hr = hrOK;
    LONG        lRes;
    CGUIDArray  aDynExtensions;

    Reset();

	OLECHAR szGuid[128] = {0};
	::StringFromGUID2(m_guidNode, szGuid, 128);

	RegKey regkeyNodeTypes;
	lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
	Assert(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

	RegKey regkeyNode;
	lRes = regkeyNode.Open(regkeyNodeTypes, szGuid);
	if (lRes != ERROR_SUCCESS)
	{
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

	// open the key for dynamic extensions and enumerate
    RegKey regkeyDynExt;
	lRes = regkeyDynExt.Open(regkeyNode, g_szDynamicExtensions);
	if (lRes != ERROR_SUCCESS)
	{
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

    RegKey regkeyExtensions;
	lRes = regkeyExtensions.Open(regkeyNode, g_szExtensions);
	if (lRes != ERROR_SUCCESS)
	{
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

    CString strKey;
    RegValueIterator iterDynExt;
    iterDynExt.Init(&regkeyDynExt);
    
    while (iterDynExt.Next(&strKey, NULL) == hrOK)
    {
        GUID guid;

        ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
        if (!aDynExtensions.IsInList(guid))
            aDynExtensions.Add(guid);
    }

    // ok, have the list of dynamic extensions, now enumerate the various extension types

    // namespace extensions
    RegKey regkeyNSExt;
	lRes = regkeyNSExt.Open(regkeyExtensions, g_szNameSpace);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterNSExt;
        iterNSExt.Init(&regkeyNSExt);

        while (iterNSExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aNameSpace.Add(guid);
        }
    }

    // Menu extensions
    RegKey regkeyMenuExt;
	lRes = regkeyMenuExt.Open(regkeyExtensions, g_szContextMenu);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterMenuExt;
        iterMenuExt.Init(&regkeyMenuExt);

        while (iterMenuExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aMenu.Add(guid);
        }
    }

    // toolbar extensions
    RegKey regkeyToolbarExt;
	lRes = regkeyToolbarExt.Open(regkeyExtensions, g_szToolbar);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterToolbarExt;
        iterToolbarExt.Init(&regkeyToolbarExt);

        while (iterToolbarExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aToolbar.Add(guid);
        }
    }

    // PropPage extensions
    RegKey regkeyPSExt;
	lRes = regkeyPSExt.Open(regkeyExtensions, g_szPropertySheet);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterPSExt;
        iterPSExt.Init(&regkeyPSExt);

        while (iterPSExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aPropSheet.Add(guid);
        }
    }

    // taskpad extensions
    RegKey regkeyTaskExt;
	lRes = regkeyTaskExt.Open(regkeyExtensions, g_szTask);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterTaskExt;
        iterTaskExt.Init(&regkeyTaskExt);

        while (iterTaskExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aTask.Add(guid);
        }
    }

    m_bLoaded = TRUE;

    return hr;
}

HRESULT 
CDynamicExtensions::GetNamespaceExtensions(CGUIDArray & aGuids)
{
    HRESULT hr = hrOK;

    aGuids.Copy(m_aNameSpace);

    return hr;
}

HRESULT 
CDynamicExtensions::BuildMMCObjectTypes(HGLOBAL * phGlobal)
{
    HRESULT hr = hrOK;
    HGLOBAL hGlobal = NULL;
    SMMCDynamicExtensions * pDynExt = NULL;
    
    if (phGlobal)
        *phGlobal = NULL;

    COM_PROTECT_TRY
    {
        int i;
        CGUIDArray aOtherDynExt;

        // build our main list of other extension types 
        // other means everything except namespace
        for (i = 0; i < m_aMenu.GetSize(); i++)
        {
            if (!aOtherDynExt.IsInList(m_aMenu[i]))
                aOtherDynExt.Add(m_aMenu[i]);
        }

        for (i = 0; i < m_aToolbar.GetSize(); i++)
        {
            if (!aOtherDynExt.IsInList(m_aToolbar[i]))
                aOtherDynExt.Add(m_aToolbar[i]);
        }
        
        for (i = 0; i < m_aPropSheet.GetSize(); i++)
        {
            if (!aOtherDynExt.IsInList(m_aPropSheet[i]))
                aOtherDynExt.Add(m_aPropSheet[i]);
        }

        for (i = 0; i < m_aTask.GetSize(); i++)
        {
            if (!aOtherDynExt.IsInList(m_aTask[i]))
                aOtherDynExt.Add(m_aTask[i]);
        }

        int nCount = (int)aOtherDynExt.GetSize();
        hGlobal = (SMMCDynamicExtensions *) ::GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, 
                                                sizeof(SMMCDynamicExtensions) + (nCount * sizeof(GUID)));
        pDynExt = reinterpret_cast<SMMCDynamicExtensions*>(::GlobalLock(hGlobal));
        if (!pDynExt)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    
        ZeroMemory(pDynExt, sizeof(SMMCDynamicExtensions) + (nCount * sizeof(GUID)));

        // now build the real struct
        pDynExt->count = nCount;
        for (i = 0; i < nCount; i++)
        {
            pDynExt->guid[i] = aOtherDynExt[i];
        }

        ::GlobalUnlock(hGlobal);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH
    
    if (SUCCEEDED(hr) && phGlobal)
        *phGlobal = hGlobal;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\dynext.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    dynext.cpp
	    dynamic extension helper

    FILE HISTORY:
	
*/

#ifndef _DYNEXT_H
#define _DYNEXT_H

#ifndef _SNAPUTIL_H
#include "snaputil.h"
#endif

class CDynamicExtensions
{
public:
	// These strings must remain unchanged until the FileServiceProvider is released
	CDynamicExtensions();
	virtual ~CDynamicExtensions();

    HRESULT SetNode(const GUID * guid);
    HRESULT Reset();
    HRESULT Load();
    HRESULT GetNamespaceExtensions(CGUIDArray & aGuids);
    HRESULT BuildMMCObjectTypes(HGLOBAL * phGlobal);

    BOOL    IsLoaded() { return m_bLoaded; }

protected:
    BOOL        m_bLoaded;
    GUID        m_guidNode;
    CGUIDArray  m_aNameSpace;
    CGUIDArray  m_aMenu;
    CGUIDArray  m_aToolbar;
    CGUIDArray  m_aPropSheet;
    CGUIDArray  m_aTask;
};


/*!--------------------------------------------------------------------------
	SearchChildNodesForGuid
		Returns hrOK (and a pointer in ppChild, if that is non-NULL).
		Returns S_FALSE if a node (with the matching GUID) is not found.

		This will return the FIRST node that matches the GUID.  If there
		are more than one node that has a GUID match, then you're on
		your own.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SearchChildNodesForGuid(ITFSNode *pParent, const GUID *pGuid, ITFSNode **ppChild);



#endif // _DYNEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\guid.c ===
/*----------------------------------------------------------------------------
	dbgguid.c
		Initialize debug GUIDs.

	Copyright (C) Microsoft Corporation, 1993 - 1997
	All rights reserved.

	Authors:
		GaryBu	Gary S. Burd, Microsoft

	History:
		05/27/93	GaryBu	Created.
		27 oct 95	garykac	DBCS_FILE_CHECK	debug file: BEGIN_STRING_OK
 ----------------------------------------------------------------------------*/

#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include "tfsguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\handlers.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    handlers.cpp
        Implementation for non-threaded handlers and background
		threaded handlers.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "handlers.h"

/*---------------------------------------------------------------------------
	ThreadHandler implementation
 ---------------------------------------------------------------------------*/

ThreadHandler::ThreadHandler()
	: m_hThread(NULL),
	m_hwndHidden(NULL),
	m_cRef(1)
{
}

ThreadHandler::~ThreadHandler()
{
}

IMPLEMENT_ADDREF_RELEASE(ThreadHandler)

STDMETHODIMP ThreadHandler::QueryInterface(REFIID iid,void **ppv)
{ 
	*ppv = 0; 
	if (iid == IID_IUnknown)
		*ppv = (IUnknown *) this;
	else if (iid == IID_ITFSThreadHandler)
		*ppv = (ITFSThreadHandler *) this; 
	else
		return ResultFromScode(E_NOINTERFACE);
	
	((IUnknown *) *ppv)->AddRef(); 
	return hrOK;
}



/*!--------------------------------------------------------------------------
	ThreadHandler::StartBackgroundThread
		-
	Author: 
 ---------------------------------------------------------------------------*/
BOOL
ThreadHandler::StartBackgroundThread(ITFSNode * pNode, HWND hWndHidden, ITFSQueryObject *pQuery)
{
	CQueryObject *	pquery = NULL;
	HRESULT		hr = hrOK;
	BOOL		bRes = TRUE;
	CBackgroundThread *	pThread;
	
	// Store the node pointer
	this->m_spNode.Set(pNode);
	
	// Get the data for the hidden window
	m_hwndHidden = hWndHidden;
	Assert(m_hwndHidden);
	Assert(::IsWindow(m_hwndHidden));

	// First create the thread object (it hasn't started yet)
	pThread = CreateThreadObject();
	ASSERT(pThread != NULL);

	// Now that we have everything allocated, register ourselves for msgs
	m_uMsgBase = (INT)::SendMessage(m_hwndHidden, WM_HIDDENWND_REGISTER, TRUE, 0);
	Assert(m_uMsgBase);

	// Initialize and setup the query object
	CORg( pQuery->Init(this, m_hwndHidden, m_uMsgBase) );

	pThread->SetQueryObj(pQuery);
	m_spQuery.Set(pQuery);

	// phew, now start the thread
	bRes = pThread->Start();
	if (bRes)
    {
		if (pThread->m_hThread)
        {
            HANDLE hPseudohandle;

            hPseudohandle = pThread->m_hThread;
		    BOOL bRet = DuplicateHandle(GetCurrentProcess(), 
									     hPseudohandle,
									     GetCurrentProcess(),
									     &m_hThread,
									     SYNCHRONIZE,
									     FALSE,
									     DUPLICATE_SAME_ACCESS);
		    if (!bRet)
		    {
			    DWORD dwLastErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwLastErr);
		    }
            
            // NOTE:::  ericdav 10/23/97
            // the thread is initially suspended so we can duplicate the handle
            // if the query object exits very quickly, the background thread object
            // may be destroyed before we can duplicate the handle.
            pThread->ResumeThread();
        }
        else
        {
            m_hThread = NULL;
        }
    }

Error:
	if (FHrFailed(hr) || (bRes == FALSE))
	{
		// Need to do some cleanup
		
		ReleaseThreadHandler();
		
		delete pThread;
		
		bRes = FALSE;
	}
	return bRes;
}

/*!--------------------------------------------------------------------------
	ThreadHandler::ReleaseThreadHandler
		-
	Author: 
 ---------------------------------------------------------------------------*/
void ThreadHandler::ReleaseThreadHandler()
{
	if (m_hwndHidden)
	{
		Assert(m_uMsgBase);
		::SendMessage(m_hwndHidden, WM_HIDDENWND_REGISTER, FALSE, m_uMsgBase);
		m_hwndHidden = NULL;
		m_uMsgBase = 0;
	}
	
	if (m_spQuery)
	{
		// Signal the thread to abort
		m_spQuery->SetAbortEvent();
		m_spQuery.Release();
	}

	if (m_spNode)
	{
		m_spNode.Release();
	}

//  Trace1("%X ReleaseThreadHandler() called\n", GetCurrentThreadId());
}

void ThreadHandler::WaitForThreadToExit()
{
	//$ Review: kennt, should this be INFINITE?
	// Ok, wait for 5 seconds, else just shutdown
	// If we return, we can't do anything about the return value anyway
	if (m_hThread)
    {
	    if (WaitForSingleObjectEx(m_hThread, 10000, FALSE) != WAIT_OBJECT_0)
        {
//      	Trace1("%X WaitForThreadToExit() Wait failed! \n", GetCurrentThreadId());
        }
        
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }
}


CBackgroundThread* ThreadHandler::CreateThreadObject()
{ 
	return new CBackgroundThread; // override if need derived tipe of object
}

DEBUG_DECLARE_INSTANCE_COUNTER(CHandler);

/*---------------------------------------------------------------------------
	CHandler implementation
 ---------------------------------------------------------------------------*/
CHandler::CHandler(ITFSComponentData *pTFSCompData)
    : CBaseHandler(pTFSCompData),
	  CBaseResultHandler(pTFSCompData),
      m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CHandler);

	m_nLockCount = 0;
	m_nState = 0;
	m_dwErr = 0;

	m_bExpanded = FALSE;
}

CHandler::~CHandler()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CHandler);

	Assert(m_nLockCount == 0);
}

IMPLEMENT_ADDREF_RELEASE(CHandler)

STDMETHODIMP CHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_ITFSResultHandler)
		*ppv = (ITFSResultHandler *) this;
	else if (riid == IID_ITFSNodeHandler)
		*ppv = (ITFSNodeHandler *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
		((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}

void 
CHandler::Lock() 
{ 
	InterlockedIncrement(&m_nLockCount);
}

void 
CHandler::Unlock() 
{ 
	InterlockedDecrement(&m_nLockCount);
}

/*!--------------------------------------------------------------------------
	CHandler::UserNotify
		Implememntation of ITFSNodeHandler::UserNotify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CHandler::UserNotify
(
	ITFSNode *	pNode, 
	LPARAM		dwParam1, 
	LPARAM		dwParam2
)
{
	HRESULT hr = hrOK;

	switch (dwParam1)
	{
		case TFS_MSG_CREATEPROPSHEET:
		{
			CPropertyPageHolderBase * pPropSheet = 
				reinterpret_cast<CPropertyPageHolderBase *>(dwParam2);
			AddPropSheet(pPropSheet);
		}
			break;

		case TFS_MSG_DELETEPROPSHEET:
		{
			CPropertyPageHolderBase * pPropSheet = 
				reinterpret_cast<CPropertyPageHolderBase *>(dwParam2);
			RemovePropSheet(pPropSheet);
		}
			break;

		default:
			Panic1("Alert the troops!: invalid arg(%d) to CHandler::UserNotify\n",
				   dwParam1);			
			break;
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	CHandler::UserResultNotify
		Implememntation of ITFSResultHandler::UserResultNotify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CHandler::UserResultNotify
(
	ITFSNode *	pNode, 
	LONG_PTR		dwParam1, 
	LONG_PTR		dwParam2
)
{
	HRESULT hr = hrOK;

	switch (dwParam1)
	{
		case TFS_MSG_CREATEPROPSHEET:
		{
			CPropertyPageHolderBase * pPropSheet = 
				reinterpret_cast<CPropertyPageHolderBase *>(dwParam2);
			AddPropSheet(pPropSheet);
		}
			break;
		
		case TFS_MSG_DELETEPROPSHEET:
		{
			CPropertyPageHolderBase * pPropSheet = 
				reinterpret_cast<CPropertyPageHolderBase *>(dwParam2);
			RemovePropSheet(pPropSheet);
		}
			break;

		default:
			Panic1("Alert the troops!: invalid arg(%d) to CHandler::UserResultNotify\n",
				   dwParam1);			
			break;
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	CHandler::DestroyPropSheets
		Implememntation of DestroyPropSheets
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT 
CHandler::DestroyPropSheets()
{

//  Trace1("CHandler destructor - hander has %d prop sheets active\n", m_listPropSheets.GetCount());
	while (!m_listPropSheets.IsEmpty())
	{
		// This handler still has some prop sheets up.
		// Destroy them before we go away.
		HANDLE hThread;
		CPropertyPageHolderBase * pPropSheet;

		pPropSheet = m_listPropSheets.RemoveHead();
		hThread = pPropSheet->m_hThread;
		pPropSheet->ForceDestroy();

		DWORD dwReturn = WaitForSingleObject(hThread, 1000);
		if (dwReturn == WAIT_OBJECT_0)
		{
		}
		else 
		if (dwReturn == WAIT_TIMEOUT)
		{
		}
		else
		if (dwReturn == WAIT_ABANDONED)
		{
		}
		else
		if (dwReturn == WAIT_FAILED)
		{
			DWORD dwReturn = GetLastError();
		}

		CloseHandle(hThread);
	}

	return hrOK;
}


/*!--------------------------------------------------------------------------
	CHandler::HasPropSheets
		Implememntation of CHandler::HasPropSheets
		returns the # of prop sheets this node has open
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CHandler::HasPropSheetsOpen()
{
	return (int)m_listPropSheets.GetCount();
}

/*!--------------------------------------------------------------------------
	CHandler::GetPropSheet
		Implememntation of CHandler::GetPropSheet
		returns the CPropPageHolderBase of the given index # (zero based)
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHandler::GetOpenPropSheet
(
	int						   nIndex,
	CPropertyPageHolderBase ** ppPropSheet
)
{
	HRESULT hr = hrOK;

	if (ppPropSheet)
	{
		POSITION pos = m_listPropSheets.FindIndex(nIndex);
		*ppPropSheet = m_listPropSheets.GetAt(pos);
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	CHandler::AddPropSheet
		Implememntation of CHandler::AddPropSheet
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHandler::AddPropSheet
(
	CPropertyPageHolderBase * pPropSheet
)
{
	HRESULT hr = hrOK;

	m_listPropSheets.AddTail(pPropSheet);
//  Trace1("CHandler::AddPropSheet - Added page holder %lx\n", pPropSheet);

	return hr;
}

/*!--------------------------------------------------------------------------
	CHandler::RemovePropSheet
		Implememntation of CHandler::RemovePropSheet
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHandler::RemovePropSheet
(
	CPropertyPageHolderBase * pPropSheet
)
{
	HRESULT hr = hrOK;

	POSITION pos = m_listPropSheets.Find(pPropSheet);
	if (pos)
	{
		m_listPropSheets.RemoveAt(pos);
	}
//	else
//	{
//		// prop sheet is not in the list
//		Trace0("CHandler::RemovePropSheet - prop page holder not in list!\n");
//		Assert(FALSE);
//	}

	return hr;
}


/*!--------------------------------------------------------------------------
	CHandler::OnRefresh
		Default implementation for the refresh functionality
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHandler::OnRefresh
(
	ITFSNode *		pNode,
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg,
	LPARAM			param
)
{
/*
	pNode->DeleteAllChildren();
	Assert(GetChildCount() == 0);
	
	OnEnumerate(pComponentData, pDataObject, bExtension);
	
	AddCurrentChildrenToUI(pComponentData);
*/
    return hrOK;
}

/*!--------------------------------------------------------------------------
	CHandler::BuildSelectedItemList
		Builds a list of selected items in the result pane (can't do 
		multiple selection in the scope pane).
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CHandler::BuildSelectedItemList
(
	ITFSComponent * pComponent, 
	CTFSNodeList *	plistSelectedItems
)
{
	RESULTDATAITEM resultDataItem;
	HRESULT hr = hrOK;

	ZeroMemory(&resultDataItem, sizeof(resultDataItem));
	resultDataItem.nState = LVIS_SELECTED;
	resultDataItem.nIndex = -1;
	
	CTFSNodeList listSelectedNodes;
	
    SPIResultData spResultData;

    CORg ( pComponent->GetResultData(&spResultData) );

	//
	// Loop through and build a list of all selected items
	//
	while (TRUE)
	{
		//
		// Gets the Selected items ID
		//
		resultDataItem.mask = RDI_STATE;
		CORg (spResultData->GetNextItem(&resultDataItem)); 
        if (hr == S_FALSE)
			break;
		
		//
		// Now get the items lparam
		//
		//resultDataItem.mask = RDI_PARAM;
		//CORg (spResultData->GetItem(&resultDataItem));

		ITFSNode * pNode;
		pNode = reinterpret_cast<ITFSNode *>(resultDataItem.lParam);
		Assert(pNode != NULL);

		pNode->AddRef();

		plistSelectedItems->AddTail(pNode);
	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CHandler::BuildVirtualSelectedItemList
		Builds a list of selected items in the result pane (can't do 
		multiple selection in the scope pane).
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CHandler::BuildVirtualSelectedItemList
(
	ITFSComponent *         pComponent, 
	CVirtualIndexArray *	parraySelectedItems
)
{
	RESULTDATAITEM resultDataItem;
	HRESULT hr = hrOK;

	ZeroMemory(&resultDataItem, sizeof(resultDataItem));
	resultDataItem.nState = LVIS_SELECTED;
	resultDataItem.nIndex = -1;
	
    SPIResultData spResultData;

    CORg ( pComponent->GetResultData(&spResultData) );

	//
	// Loop through and build a list of all selected items
	//
	while (TRUE)
	{
		//
		// Gets the Selected items ID
		//
		resultDataItem.mask = RDI_STATE;
		CORg (spResultData->GetNextItem(&resultDataItem)); 
        if (hr == S_FALSE)
			break;
		
		//
		// The index of the selected item is in the resultDataItem struct
		//
		parraySelectedItems->Add(resultDataItem.nIndex);
	}

Error:
	return hr;
}

DEBUG_DECLARE_INSTANCE_COUNTER(CMTHandler);

/*---------------------------------------------------------------------------
	CMTHandler implementation
 ---------------------------------------------------------------------------*/
CMTHandler::CMTHandler(ITFSComponentData *pTFSCompData)
    : CHandler(pTFSCompData),
	  m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CMTHandler);
}

CMTHandler::~CMTHandler()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CMTHandler);
}

IMPLEMENT_ADDREF_RELEASE(CMTHandler)

STDMETHODIMP CMTHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_ITFSResultHandler)
		*ppv = (ITFSResultHandler *) this;
	else if (riid == IID_ITFSNodeHandler)
		*ppv = (ITFSNodeHandler *) this;
	else if (riid == IID_ITFSThreadHandler)
		*ppv = (ITFSThreadHandler *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
		((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}

/*!--------------------------------------------------------------------------
	CMTHandler::DestoryHandler
		This gets called when the node for this handler is told to destroy.
		Free up anything we may be holding onto here.
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTHandler::DestroyHandler(ITFSNode *pNode)
{
	ReleaseThreadHandler();
	WaitForThreadToExit();

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CMTHandler::OnExpand
		Default implementation for the refresh functionality
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnExpand
(
	ITFSNode *		pNode,
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg,
	LPARAM			param
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
	SPITFSNodeHandler	spHandler;
	ITFSQueryObject *	pQuery = NULL;
	
	if (m_bExpanded)
	{
		return hr;
	}

	Lock();

	OnChangeState(pNode);

	pQuery = OnCreateQuery(pNode);
	Assert(pQuery);

	// notify the UI to change icon, if needed
	//Verify(SUCCEEDED(pComponentData->ChangeNode(this, SCOPE_PANE_CHANGE_ITEM_ICON)));

	Verify(StartBackgroundThread(pNode, m_spTFSCompData->GetHiddenWnd(), pQuery));
	
	pQuery->Release();

	m_bExpanded = TRUE;

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CMTHandler::OnRefresh
		Default implementation for the refresh functionality
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnRefresh
(
	ITFSNode *		pNode,
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg,
	LPARAM			param
)
{
	HRESULT hr = hrOK;

    if (m_bExpanded == FALSE)
    {
        // we cannot refresh/add items to a node that hasn't been expanded yet.
        return hr;
    }

    BOOL bLocked = IsLocked();
	if (bLocked)
    {
        // cannot do refresh on locked node, the UI should prevent this
		return hr; 
    }
	
    pNode->DeleteAllChildren(TRUE);

	int nVisible, nTotal;
	pNode->GetChildCount(&nVisible, &nTotal);
	Assert(nVisible == 0);
	Assert(nTotal == 0);
	
	m_bExpanded = FALSE;
	OnExpand(pNode, pDataObject, dwType, arg, param); // will spawn a thread to do enumeration

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTHandler::OnNotifyError
		Implementation of ThreadHandler::OnNotifyError
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnNotifyError
(
	LPARAM			lParam
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
    	OnError((DWORD) lParam);
    }
    COM_PROTECT_CATCH

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CMTHandler::OnNotifyHaveData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnNotifyHaveData
(
	LPARAM			lParam
)
{
	// For these nodes, assume that the lParam is a CNodeQueryObject *
	CNodeQueryObject *  pQuery;
	LPQUEUEDATA         pQD;
    ITFSNode *          p;
    HRESULT             hr = hrOK;

    COM_PROTECT_TRY
    {
        pQuery = (CNodeQueryObject *) lParam;
	    Assert(pQuery);

        if (pQuery)
            pQuery->AddRef();

	    while (pQD = pQuery->RemoveFromQueue())
	    {
		    if (pQD->Type == QDATA_PNODE)
		    {
			    // this is the normal case.  The handler just expects nodes
			    // to be handed back from the background thread
			    p = reinterpret_cast<ITFSNode *>(pQD->Data);
			    OnHaveData(m_spNode, p);
			    p->Release();
		    }
		    else
		    {
			    // custom case here.  The user provided their own data 
			    // type.  Call the appropriate hander for this.
			    OnHaveData(m_spNode, pQD->Data, pQD->Type);
		    }

		    delete pQD;
	    }

        if (pQuery)
            pQuery->Release();
    }
    COM_PROTECT_CATCH

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CMTHandler::OnNotifyExiting
		Implementation of ThreadHandler::OnNotifyExiting
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnNotifyExiting
(
	LPARAM			lParam
)
{
	CNodeQueryObject *  pQuery;
	HRESULT             hr = hrOK;

    COM_PROTECT_TRY
    {
        pQuery = (CNodeQueryObject *) lParam;
	    Assert(pQuery);

        if (pQuery)
            pQuery->AddRef();

        OnChangeState(m_spNode);

	    ReleaseThreadHandler();

	    Unlock();

        if (pQuery)
            pQuery->Release();
    }
    COM_PROTECT_CATCH

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\handlers.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    handlers.h
        Prototypes for the various handlers

    FILE HISTORY:
        
*/

#ifndef _HANDLERS_H
#define _HANDLERS_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _PROPPAGE_H
#include "proppage.h"
#endif
 
typedef CArray<int, int> CVirtualIndexArray;

/*---------------------------------------------------------------------------
	Class: ThreadHandler

	This is an abstract base class that anyone who wants to run a
	background thread needs to implement (if they use the hidden window
	mechanism that is).

	This is the class that does all of the background thread management.

	Author: kennt
 ---------------------------------------------------------------------------*/
class ThreadHandler :
   public ITFSThreadHandler
{
public:
	ThreadHandler();
	~ThreadHandler();

	DeclareIUnknownMembers(IMPL)

	// Derived classes should implement this
	DeclareITFSThreadHandlerMembers(PURE)
	
	// Thread management functions
	BOOL	StartBackgroundThread(ITFSNode * pNode, HWND hWndHidden, ITFSQueryObject *pQuery);

	void	WaitForThreadToExit();
	void	ReleaseThreadHandler();
		
protected:
	// override for custom thread creation
	virtual CBackgroundThread* CreateThreadObject();
	
	SPITFSQueryObject	m_spQuery;
	SPITFSNode			m_spNode;
	HWND				m_hwndHidden;		// handle to window to post to
	UINT				m_uMsgBase;
	HANDLE				m_hThread;
	long				m_cRef;
};

typedef CList <CPropertyPageHolderBase *, CPropertyPageHolderBase *> CPropSheetListBase;


/*---------------------------------------------------------------------------
	Class:	CHandler
 ---------------------------------------------------------------------------*/
class CHandler :
		public CBaseHandler,
		public CBaseResultHandler
{
public:
	CHandler(ITFSComponentData *pTFSCompData);
	virtual ~CHandler();

	DeclareIUnknownMembers(IMPL)

	virtual HRESULT OnExpand(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM) { m_bExpanded = TRUE; return hrOK; }

	void Lock();
	void Unlock();
	BOOL IsLocked() { return m_nLockCount > 0;}

	OVERRIDE_NodeHandler_UserNotify();
	OVERRIDE_NodeHandler_DestroyHandler()
			{ return DestroyPropSheets(); }
	OVERRIDE_ResultHandler_UserResultNotify();
	OVERRIDE_ResultHandler_DestroyResultHandler()
			{ return DestroyPropSheets(); }

	// public helpers
	int		HasPropSheetsOpen();
	HRESULT GetOpenPropSheet(int nIndex, CPropertyPageHolderBase ** ppPropSheet);

	virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

protected:
	HRESULT BuildSelectedItemList(ITFSComponent * pComponent, CTFSNodeList * plistSelectedItems);
    HRESULT BuildVirtualSelectedItemList(ITFSComponent * pComponent, CVirtualIndexArray * parraySelectedItems);
    HRESULT RemovePropSheet(CPropertyPageHolderBase * pPageHolder);
	HRESULT AddPropSheet(CPropertyPageHolderBase * pPageHolder);
	HRESULT DestroyPropSheets();

public:
	int		m_nState;		// for general purpose finite state machine implementation
	DWORD	m_dwErr;	// for general purpose error handling
	LONG	m_nLockCount;	// keeps track if a node has been locked (e.g. to spin a thread, etc.)
	BOOL    m_bExpanded;    // whether or not this node has been expanded yet

protected:
   	LONG				m_cRef;
	CPropSheetListBase	m_listPropSheets;
};

/*---------------------------------------------------------------------------
	Class:	CMTHander
 ---------------------------------------------------------------------------*/
class CMTHandler :
	public CHandler,
	public ThreadHandler
{
public:
	CMTHandler(ITFSComponentData *pTFSCompData);
	virtual ~CMTHandler();

    DeclareIUnknownMembers(IMPL)

	STDMETHOD (DestroyHandler) (ITFSNode *pNode);

	virtual HRESULT OnExpand(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

	// query creation - override to create a user-specific query object
	virtual ITFSQueryObject* OnCreateQuery(ITFSNode *pNode) = 0;

	virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

protected:
	virtual int		GetImageIndex(BOOL bOpenIndex) { return -1; }
	
	// the next 3 functions are background thread notification callbacks
	// these override the ThreadHandler::OnNotifyXXX functions
	DeclareITFSThreadHandlerMembers(IMPL)

	virtual void OnChangeState(ITFSNode * pNode) {}
	virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNode) = 0;
	virtual void OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type) { };
	virtual void OnError(DWORD dwErr) { m_dwErr = dwErr; }

protected:
  	LONG		m_cRef;

private:
//	friend class CHiddenWnd;			// to get OnThreadNotification()
};

#endif _HANDLERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\ipaddr.hpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ipaddr.hpp
//
//--------------------------------------------------------------------------

//
//  IPADDR.HPP:  IPADDRESS control implementation file.
//

#if !defined(_IPADDR_HPP_)
#define _IPADDR_HPP_

class CWndIpAddress : public CWnd
{
    DECLARE_DYNAMIC(CWndIpAddress)

protected:
    static WNDPROC m_wproc_super ;
    static BOOL m_b_inited ;

public:

    CWndIpAddress () ;
    ~ CWndIpAddress () ;

    BOOL Create(LPCTSTR lpszText, 
        DWORD dwStyle,
        const RECT& rect, 
        CWnd* pParentWnd, 
        UINT nID = 0xffff
        );

    WNDPROC * GetSuperWndProcAddr() ;

    //  Modification flag handling
    void SetModify ( BOOL bModified ) ;
    BOOL GetModify () const ;

    //   Set focus on a particular sub-field
    void SetFocusField(int iField);
    void ClearAddress () ;
    void SetFieldRange (int dwField, int dwMin, int dwMax);
    void SetReadOnly (BOOL fReadonly = TRUE);
    void SetField(int dwField, BOOL fSet = FALSE, BYTE bValue = 0x00);

    BOOL SetAddress (DWORD dwAddr) ;
    BOOL GetAddress (DWORD * pdwAddr  ) const ;
    BYTE GetMask() const ;
    BOOL SetMask(DWORD dwAddr, BYTE bMask);

	BOOL IsBlank();

    //  One-shot initialization
    static BOOL CreateWindowClass ( HINSTANCE hInstance ) ;  
};



#endif  // _IPADDR_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\intltime.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#define OEMRESOURCE
#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include <string.h>

#include "dbgutil.h"
#include "objplus.h"
#include "intltime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// FormatDateTime
//
//  Generates a current local date/time string
//
//
/////////////////////////////////////////////////////////////////////////////
void
InternalFormatDateTime(CString & strOutput, SYSTEMTIME * psystemtime, BOOL fLongDate)
{
    int     nLen;
    CString strDate, strTime;
    DWORD   dwFlags = 0;
    
    dwFlags = fLongDate ? DATE_LONGDATE : DATE_SHORTDATE;

    // call once to get the length, and again to format the string
    nLen = GetDateFormat(GetThreadLocale(), dwFlags, psystemtime, NULL, NULL, 0);
    nLen = GetDateFormat(GetThreadLocale(), dwFlags, psystemtime, NULL, strDate.GetBuffer(nLen + 1), nLen + 1);
    strDate.ReleaseBuffer();

    // now the time
    nLen = GetTimeFormat(GetThreadLocale(), 0, psystemtime, NULL, NULL, 0);
    nLen = GetTimeFormat(GetThreadLocale(), 0, psystemtime, NULL, strTime.GetBuffer(nLen + 1), nLen + 1);
    strTime.ReleaseBuffer();

    strOutput = strDate + _T(" ") + strTime;
}

void
FormatDateTime(CString & strOutput, SYSTEMTIME * psystemtime, BOOL fLongDate)
{
    InternalFormatDateTime(strOutput, psystemtime, fLongDate);
}

void
FormatDateTime(CString & strOutput, FILETIME * pfiletime, BOOL fLongDate)
{
    FILETIME    localTime;
    SYSTEMTIME  systemtime;

	if (!FileTimeToLocalFileTime(pfiletime, &localTime))
	{
		return;
	}

    if (!FileTimeToSystemTime(&localTime, &systemtime))
    {
        return;
    }

    InternalFormatDateTime(strOutput, &systemtime, fLongDate);
}

void
FormatDateTime(CString & strOutput, CTime & time, BOOL fLongDate)
{
    SYSTEMTIME systemtime;
    struct tm * ptm = time.GetLocalTm(NULL);

    if (ptm != NULL)
    {
	    systemtime.wYear = (WORD) (1900 + ptm->tm_year);
	    systemtime.wMonth = (WORD) (1 + ptm->tm_mon);
	    systemtime.wDayOfWeek = (WORD) ptm->tm_wday;
	    systemtime.wDay = (WORD) ptm->tm_mday;
	    systemtime.wHour = (WORD) ptm->tm_hour;
	    systemtime.wMinute = (WORD) ptm->tm_min;
	    systemtime.wSecond = (WORD) ptm->tm_sec;
	    systemtime.wMilliseconds = 0;

        InternalFormatDateTime(strOutput, &systemtime, fLongDate);
    }
    else
    {
        strOutput.Empty();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CIntlTime
//
//          These allocations cause a phoney "memory leak" error, since
//          they're not freed until after the audit-check.  Anyway
//          around this?
//
/////////////////////////////////////////////////////////////////////////////

// Initialise static members
CIntlTime::INTL_TIME_SETTINGS CIntlTime::m_itsInternationalSettings;
BOOL CIntlTime::m_fIntlOk = CIntlTime::SetIntlTimeSettings();
CString CIntlTime::m_strBadDate("--");
CString CIntlTime::m_strBadTime("--");

/***
 *
 *  CIntlTime::SetIntlTimeSettings
 *
 *  Purpose:
 *
 *      This is a static function which initialises the international
 *      settings (date seperator, etc) of the CIntlTime class.
 *
 *  Returns:
 *
 *      TRUE if the international settings are properly initialised,
 *      or FALSE if they are not.
 *
 */
BOOL CIntlTime::SetIntlTimeSettings ()
{
#ifdef _WIN32
    #define MAXSTR 128

    BOOL fOk;
    TCHAR str[MAXSTR];

    #define GETCSTRINGFIELD(field,cstring)\
         ::GetLocaleInfo(GetUserDefaultLCID(), field, cstring.GetBuffer(MAXSTR), MAXSTR);\
         cstring.ReleaseBuffer()
    #define GETINTFIELD(field, integer)\
         ::GetLocaleInfo(GetUserDefaultLCID(), field, str, MAXSTR);\
         integer = _ttol(str)
    #define GETBOOLFIELD(field, boolean)\
         ::GetLocaleInfo(GetUserDefaultLCID(), field, str, MAXSTR);\
         boolean=*str == '1'

    fOk = GETCSTRINGFIELD(LOCALE_SDATE, CIntlTime::m_itsInternationalSettings.strDateSeperator);
    fOk &= GETCSTRINGFIELD(LOCALE_STIME, CIntlTime::m_itsInternationalSettings.strTimeSeperator);
    fOk &= GETINTFIELD(LOCALE_IDATE, CIntlTime::m_itsInternationalSettings.nDateFormat);
    ASSERT((CIntlTime::m_itsInternationalSettings.nDateFormat >= 0) && (CIntlTime::m_itsInternationalSettings.nDateFormat <= 2));
    fOk &= GETBOOLFIELD(LOCALE_ITIME, CIntlTime::m_itsInternationalSettings.f24HourClock);
    fOk &= GETBOOLFIELD(LOCALE_ICENTURY, CIntlTime::m_itsInternationalSettings.fCentury);
    fOk &= GETBOOLFIELD(LOCALE_ITLZERO, CIntlTime::m_itsInternationalSettings.fLeadingTimeZero);
    fOk &= GETBOOLFIELD(LOCALE_IDAYLZERO, CIntlTime::m_itsInternationalSettings.fLeadingDayZero);
    fOk &= GETBOOLFIELD(LOCALE_IMONLZERO, CIntlTime::m_itsInternationalSettings.fLeadingMonthZero);
    if (CIntlTime::m_itsInternationalSettings.f24HourClock)
    {
        CIntlTime::m_itsInternationalSettings.strAM = "";
        CIntlTime::m_itsInternationalSettings.strPM = "";
    }
    else
    {
        fOk &= GETCSTRINGFIELD(LOCALE_S1159, CIntlTime::m_itsInternationalSettings.strAM);
        fOk &= GETCSTRINGFIELD(LOCALE_S2359, CIntlTime::m_itsInternationalSettings.strPM);
    }

#ifdef _DEBUG
    if (!fOk)
    {
        Trace0("There was a problem with some of the intl time settings\n");
    }
#endif // _DEBUG

    return(fOk);

#endif // _WIN32

#ifdef _WIN16

    #define MAXSTR 128

    CString strMisc;

    #define GETCSTRINGFIELD(field,cstring,defstring)\
        ::GetProfileString("Intl", field, defstring, cstring.GetBuffer(MAXSTR), MAXSTR);\
        cstring.ReleaseBuffer()
    #define GETINTFIELD(field, integer, defint)\
        integer = ::GetProfileInt("Intl", field, defint)
    #define GETBOOLFIELD(field, boolean, defint)\
        boolean = ::GetProfileInt("Intl", field, defint)==1

    // Get the values.  Assume American defaults in case of failure.

    GETCSTRINGFIELD("sDate", CIntlTime::m_itsInternationalSettings.strDateSeperator, "/");
    GETCSTRINGFIELD("sTime", CIntlTime::m_itsInternationalSettings.strTimeSeperator, ":");
    GETINTFIELD("iDate", CIntlTime::m_itsInternationalSettings.nDateFormat, 0);
    ASSERT((CIntlTime::m_itsInternationalSettings.nDateFormat >= 0) && (CIntlTime::m_itsInternationalSettings.nDateFormat <= 2));
    GETBOOLFIELD("iTime", CIntlTime::m_itsInternationalSettings.f24HourClock, FALSE);
    GETBOOLFIELD("iTLZero", CIntlTime::m_itsInternationalSettings.fLeadingTimeZero, FALSE);
    if (CIntlTime::m_itsInternationalSettings.f24HourClock)
    {
        CIntlTime::m_itsInternationalSettings.strAM = "";
        CIntlTime::m_itsInternationalSettings.strPM = "";
    }
    else
    {
        GETCSTRINGFIELD("s1159", CIntlTime::m_itsInternationalSettings.strAM, "AM");
        GETCSTRINGFIELD("s2359", CIntlTime::m_itsInternationalSettings.strPM, "PM");
    }


    GETCSTRINGFIELD("sShortDate", strMisc, "M/d/yy");
    // These settings are determined from the short date sample, as
    // there is no direct equivalent in the win.ini
    CIntlTime::m_itsInternationalSettings.fCentury = strMisc.Find("yyyy") != -1;
    CIntlTime::m_itsInternationalSettings.fLeadingDayZero = strMisc.Find("dd") != -1;
    CIntlTime::m_itsInternationalSettings.fLeadingMonthZero = strMisc.Find("MM") != -1;

    return(TRUE);

#endif // _WIN16

}

/***
 *
 *  CIntlTime::Reset()
 *
 *  Purpose:
 *
 *      Reset the international settings. Usually in response to
 *      a change in those international settings by the user.
 *
 *  Notes:
 *
 *      This is a publically available static function.
 *
 */
void CIntlTime::Reset()
{
    CIntlTime::m_fIntlOk = CIntlTime::SetIntlTimeSettings();
}

/***
 *
 *  CIntlTime::IsLeapYear
 *
 *  Purpose:
 *
 *      Determine if the given year is/was a leap year
 *
 *  Arguments:
 *
 *      int nYear   The year in question.
 *
 *  Returns:
 *
 *      TRUE if the year is/was a leap year, or FALSE otherwise.
 *
 *  Comments:
 *
 *      A year is a leap year, if is divisible by 4, but not by a 100, unless
 *      it is divisible by 400. e.g. 1900 was not a leap year, but 2000 will
 *      be.
 *
 */
BOOL CIntlTime::IsLeapYear(UINT nYear)
{
    return(!(nYear % 4) && ( (nYear % 100) || !(nYear % 400) ));
}

/***
 *
 *  CIntlTime::IsValidDate
 *
 *  Purpose:
 *
 *      Determine if the given month, day year values are
 *      valid.
 *
 *  Arguments:
 *
 *      int nMonth      Month
 *      int nDay        Day
 *      int nYear       Year
 *
 *  Returns:
 *
 *      TRUE for a valid date, FALSE otherwise.
 *
 */
BOOL CIntlTime::IsValidDate(UINT nMonth, UINT nDay, UINT nYear)
{
    // Sanity Check:
    BOOL fOk = ((nYear <100) || (nYear >= 1970)) &&
                (nYear <= 2037)                  &&
               ((nMonth >= 1) && (nMonth <= 12)) &&
               ((nDay >= 1) && (nDay <= 31));

    // Detailed check of days per month
    if (fOk)
    {
        switch(nMonth)
        {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                fOk = (nDay <= 30);
                break;
            case 2:
                fOk = (nDay <= (UINT)(IsLeapYear(nYear) ? 29 : 28));
                break;
        }
    }

    return(fOk);
}

/***
 *
 *  CIntlTime::IsValidTime
 *
 *  Purpose:
 *
 *      Determine if the given hour, minute, second values
 *      valid.
 *
 *  Arguments:
 *
 *      int nHour       Hour
 *      int nMinute     Minute
 *      int nSecond     Second
 *
 *  Returns:
 *
 *      TRUE for a valid time, FALSE otherwise.
 *
 */

BOOL CIntlTime::IsValidTime(UINT nHour, UINT nMinute, UINT nSecond)
{
    return ((nHour < 24) && (nMinute < 60) && (nSecond < 60));
}

// Constructors.  m_fInitOk will indicate whether or not the object
// was succesfully constructed.  This can be checked at runtime by
// the IsValid() member function

CIntlTime::CIntlTime()
    :CTime()
{
    // Time set to 0, always bad.
    m_fInitOk = FALSE;
}

CIntlTime::CIntlTime(const CTime &timeSrc)
    :CTime(timeSrc)
{
    m_fInitOk = GetTime() > 0L;
}

CIntlTime::CIntlTime(time_t time)
    :CTime(time)
{
    m_fInitOk = (time > 0);
}

CIntlTime::CIntlTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec)
    :CTime(nYear, nMonth, nDay, nHour, nMin, nSec)
{
    m_fInitOk = IsValidDate(nMonth, nDay, nYear) && IsValidTime(nHour, nMin, nSec);
}

CIntlTime::CIntlTime(WORD wDosDate, WORD wDosTime)
    :CTime(wDosDate, wDosTime)
{
    m_fInitOk = GetTime() != 0L;
}

// Constructor taking a string as an argument. The string can contain
// either a time, a date or both.  If the string is missing the date,
// the current date will be filled in.  If the string is missing the time,
// the current time will be filled in.  As with all constructors, be
// sure the call IsValid() to determine proper contruction.

CIntlTime::CIntlTime(const CString & strTime, int nFormat, time_t * ptmOldValue)
    :CTime(ConvertFromString(strTime, nFormat, ptmOldValue,  &m_fInitOk))
{
}

CIntlTime::CIntlTime(const CIntlTime &timeSrc)
{
    CTime::operator=(timeSrc.GetTime());
    m_fInitOk = timeSrc.IsValid();
}

#ifdef _WIN32
CIntlTime::CIntlTime(const SYSTEMTIME& sysTime)
    : CTime(sysTime)
{
    m_fInitOk = IsValidDate((UINT)sysTime.wMonth, (UINT)sysTime.wDay, (UINT)sysTime.wYear)
             && IsValidTime((UINT)sysTime.wHour, (UINT)sysTime.wMinute, (UINT)sysTime.wSecond);
}

CIntlTime::CIntlTime(const FILETIME& fileTime)
    : CTime(fileTime)
{
    m_fInitOk = GetTime() != 0L;
}

#endif // _WIN32
// Desctructor
CIntlTime::~CIntlTime()
{
}

// Assignment operators.  As with constructors, be sure to check the
// IsValid() member function to determine succesfull assignment, as
// assignment operators do set the m_fInitOk member variable.

const CIntlTime& CIntlTime::operator =(const CString & strValue)
{
    time_t tmValue = ConvertFromString (strValue, CIntlTime::TFRQ_TIME_OR_DATE, NULL, &m_fInitOk);
    if (m_fInitOk)
    {
        CTime::operator=(tmValue);
    }
    return(*this);
}

// Assignment operator taking a time_t argument
const CIntlTime& CIntlTime::operator =(time_t tmValue)
{
    CTime::operator=(tmValue);
    m_fInitOk = (tmValue > 0);
    return(*this);
}

const CIntlTime& CIntlTime::operator =(const CTime & time)
{
    CTime::operator=(time.GetTime());
    m_fInitOk = (GetTime() > 0);
    return(*this);
}

const CIntlTime& CIntlTime::operator =(const CIntlTime & time)
{
    CTime::operator=(time.GetTime());
    m_fInitOk = (GetTime() > 0);
    return(*this);
}

// Conversion operators
CIntlTime::operator const time_t() const
{
    return(GetTime());
}

// Conversion operator that returns the date followed by the time
// in international format as a CString.

CIntlTime::operator const CString() const
{
    return(ConvertToString(TFRQ_TIME_AND_DATE));
}

CIntlTime::operator CString() const
{
    return(ConvertToString(TFRQ_TIME_AND_DATE));
}

/***
 *
 *  CIntlTime::GetDateString()
 *
 *  Purpose:
 *
 *      Represent the current date in a format consistent with the current
 *      international settings in a CString.
 *
 *  Returns:
 *
 *      A CString containing the date in string format, or "--" if
 *      the date is invalid.
 *
 */
const CString CIntlTime::GetDateString() const
{
    CString strIntl;

    if (!IsValid())
    {
        return(CIntlTime::m_strBadDate);
    }

    TCHAR szPct02D[] = _T("%02d");
    TCHAR szPctD[] = _T("%d");
    TCHAR szDay[3], szMonth[16], szYear[8];
    TCHAR *first, *second, *third;
    int i;

    i = GetYear();
    if(!CIntlTime::m_itsInternationalSettings.fCentury)
    {
        i %= 100;
    }
    
    // fix year 2000 problem -- ericdav
    //::_itot(i, szYear, 10);
    ::wsprintf (szYear, szPct02D, i);
    ::wsprintf (szMonth, CIntlTime::m_itsInternationalSettings.fLeadingMonthZero
                         ? szPct02D : szPctD, GetMonth());
    ::wsprintf (szDay, CIntlTime::m_itsInternationalSettings.fLeadingDayZero
                         ? szPct02D : szPctD, GetDay());

    if (CIntlTime::m_itsInternationalSettings.nDateFormat == _DFMT_YMD)
    {
        first = szYear;
        second = szMonth;
        third = szDay;
    }
    else
    {
        third = szYear;
        if (CIntlTime::m_itsInternationalSettings.nDateFormat == _DFMT_DMY)
        {
            first = szDay;
            second = szMonth;
        }
        else
        {
            first = szMonth;
            second = szDay;
        }
    }
    ::wsprintf (strIntl.GetBuffer(80),
                        _T("%s%s%s%s%s"),
                        first,
                        (LPCTSTR)CIntlTime::m_itsInternationalSettings.strDateSeperator,
                        second,
                        (LPCTSTR)CIntlTime::m_itsInternationalSettings.strDateSeperator,
                        third);
    strIntl.ReleaseBuffer();

    return(strIntl);
}

/***
 *
 *  CIntlTime::GetTimeString()
 *
 *  Purpose:
 *
 *      Represent the current time in a format consistent with the current
 *      international settings in a CString.
 *
 *  Returns:
 *
 *      A CString containing the time in string format, or "--" if
 *      the time is invalid.
 *
 */
const CString CIntlTime::GetTimeString() const
{
    CString strIntl;

    if (!IsValid())
    {
        return(CIntlTime::m_strBadTime);
    }

    int hour = GetHour();
    int minute = GetMinute();
    int second = GetSecond();

    // Set AM/PM depending on non-24 hour clock, and the time
    // of day.  Note: a space is prepended for readability.
    CString strAMPM(CIntlTime::m_itsInternationalSettings.f24HourClock
                    ? "" : " " + ((hour < 12)
                        ? CIntlTime::m_itsInternationalSettings.strAM
                        : CIntlTime::m_itsInternationalSettings.strPM)
                   );

    if ((!CIntlTime::m_itsInternationalSettings.f24HourClock) && (!(hour %= 12)))
    {
        hour = 12;
    }

    ::wsprintf (strIntl.GetBuffer(30), CIntlTime::m_itsInternationalSettings.fLeadingTimeZero
                ? _T("%02d%s%02d%s%02d%s") : _T("%d%s%02d%s%02d%s"),
                hour,
                (LPCTSTR)CIntlTime::m_itsInternationalSettings.strTimeSeperator,
                minute,
                (LPCTSTR)CIntlTime::m_itsInternationalSettings.strTimeSeperator,
                second,
                (LPCTSTR)strAMPM);

    strIntl.ReleaseBuffer();
    return(strIntl);
}

const CString CIntlTime::GetMilitaryTime() const
{
    CString strIntl;

    if (!IsValid())
    {
        return(CIntlTime::m_strBadTime);
    }

    int hour = GetHour();
    int minute = GetMinute();
    int second = GetSecond();

    ::wsprintf (strIntl.GetBuffer(30),
                _T("%02d:%02d:%02d"),
                hour,
                minute,
                second);

    strIntl.ReleaseBuffer();
    return(strIntl);
}

/***
 *
 *  CIntlTime::ConvertToString(int nFormat)
 *
 *  Purpose:
 *
 *      Convert the curent time/date to a string
 *
 *  Arguments:
 *
 *      int nFormat     Format request ID, can be one of the following
 *                      values (enumerated in CIntlTime):
 *
 *                      TFRQ_TIME_ONLY      Only give me the time.
 *                      TFRQ_DATE_ONLY      Only give me the date.
 *                      TFRQ_TIME_AND_DATE  Give me the time and the date.
 *
 *  Returns:
 *
 *      A CString containing the time and/or date in international format.
 *
 */
const CString CIntlTime::ConvertToString(int nFormat) const
{
    switch(nFormat)
    {
        case TFRQ_TIME_ONLY:
             return(GetTimeString());

        case TFRQ_DATE_ONLY:
            return(GetDateString());

        case TFRQ_TIME_AND_DATE:
            return(GetDateString() + CString(" ") + GetTimeString());

        case TFRQ_MILITARY_TIME:
            return(GetMilitaryTime());

        case TFRQ_TIME_OR_DATE:
        default:
            Trace1("Invalid time/date format code %d requested.\n", nFormat);
            return(CIntlTime::m_strBadDate);
    }
}

/***
 *
 *  CIntlTime::ConvertFromString
 *
 *  Purpose:
 *
 *      Convert a given CString into a time_t
 *
 *  Arguments:
 *
 *      const CString & str The string to convert
 *      int nFormat     Format request ID, can be one of the following
 *                      values (enumerated in CIntlTime):
 *
 *                      TFRQ_TIME_ONLY      Only give me the time.
 *                      TFRQ_DATE_ONLY      Only give me the date.
 *                      TFRQ_TIME_AND_DATE  Give me the time and the date.
 *                      TFRQ_TIME_OR_DATE   Give me time or date (or both).
 *
 *      time_t * ptmOldValue    This time_t will be used to fill in the fields
 *                      not given in the string.  If it is NULL, the current
 *                      time or date will be used.
 *      BOOL * pfOk     Returns TRUE for succesfull conversion, FALSE
 *                      otherwise.
 *
 *  Returns:
 *
 *      A time_t representing the time/date string, or 0 in case of error.
 *
 *  Notes:
 *
 *      Full validation of all paremeters will be done, e.g. No Feb 29 in
 *      a non-leap year will be accepted.
 *
 *      [CAVEAT] Time, date seperators longer than one character will not
 *      work.
 *
 */
time_t CIntlTime::ConvertFromString (
    const CString & str,
    int nFormat,
    time_t * ptmOldValue,   // If only getting time or date, count on remaining
                            // fields to be provided here (optionally);
    BOOL * pfOk)
{
    #define MAXSTRLEN 40

    TCHAR dtseps[10] ;      // Date/Time separators passed to _tcstok
    TCHAR *pchToken;
    TCHAR szDateString[MAXSTRLEN+1];
    BOOL fGotDate = FALSE;
    BOOL fGotTime = FALSE;
    BOOL fPM = FALSE;
    BOOL fAM = FALSE;
    int i;
    UINT anValues[6] = { 0, 0, 0, 0, 0, 0 };
    CTime tmTmp;

    *pfOk = FALSE;      // Assume failure.

    if (ptmOldValue != NULL)
    {
        tmTmp = *ptmOldValue;
    }
    else
    {
        tmTmp = CTime::GetCurrentTime();
    }

    if (str.GetLength() > MAXSTRLEN)
    {
        // Too long to be a proper time/date string
        return(0);
    }
    ::lstrcpy(szDateString, (LPCTSTR)str);

    int nIndex = 0;

    // If we're looking for something specific, only
    // accept specific seperators (time, date, both, either)
    if ((nFormat == TFRQ_DATE_ONLY) || (nFormat == TFRQ_TIME_AND_DATE) || (nFormat == TFRQ_TIME_OR_DATE))
    {
        dtseps[nIndex++] = '/';
        dtseps[nIndex++] = '-';
        dtseps[nIndex++] = ',';
        dtseps[nIndex++] = CIntlTime::m_itsInternationalSettings.strDateSeperator[0];
    }

    if ((nFormat == TFRQ_TIME_ONLY) || (nFormat == TFRQ_TIME_AND_DATE) || (nFormat == TFRQ_TIME_OR_DATE))
    {
        dtseps[nIndex++] = ':';
        dtseps[nIndex++] = '.';
        dtseps[nIndex++] = ' ';
        dtseps[nIndex++] = CIntlTime::m_itsInternationalSettings.strTimeSeperator[0];
    }

    ASSERT(nIndex != 0);    // Make sure we asked for something.
    if (nIndex == 0)
    {
        // Request type is illegal
        return(0);
    }
    dtseps[nIndex++] = '\0';

    Trace3("CIntlTime::ConvertFromString.  String: %s Format = %d Seps: %s\n", str, nFormat, dtseps);

    i = 0;
    pchToken = ::_tcstok(szDateString, dtseps);
    while (pchToken != NULL)
    {
        if (i > 6)        // 7 fields max (date, time + AM/PM maximum)
        {
            // Too many values, reject the string.
            return(0);
        }

        // Determine if its a number (can't _ttoi, since it will
        // merely return 0 for inappropriate values)

        BOOL fProperNumber = TRUE;
        int l = ::lstrlen(pchToken);
        if ( (l == 0) || (l == 3) || (l > 4) )
        {
            fProperNumber = FALSE;
        }
        else
        {
            int j;
            for (j=0; j < l; ++j)
            {
                if (!isdigit(*(pchToken+j)))
                {
                    fProperNumber = FALSE;
                    break;
                }
            }
        }

        if (!fProperNumber)
        {
            // Ok, this is not a proper numeric field.  Only
            // if it's AM or PM at the end of the string can this
            // string be saved.
            fGotTime = TRUE;
            if ((CIntlTime::m_itsInternationalSettings.f24HourClock) ||
                (::_tcstok(NULL, dtseps) != NULL))
            {
                return(0);
            }

            if (!CIntlTime::m_itsInternationalSettings.strAM.CompareNoCase(pchToken))
            {
                fAM = TRUE;
            }
            else if (!CIntlTime::m_itsInternationalSettings.strPM.CompareNoCase(pchToken))
            {
                fPM = TRUE;
            }
            else
            {
                // Neither AM nor PM
                return(0);
            }
            break;
        }
        else
        {
            // Value is acceptable
            anValues[i++] = (UINT)::_ttoi(pchToken);
        }

        pchToken = ::_tcstok(NULL, dtseps);
    }
    // Now what did we get, exactly?

    ASSERT(!fAM || !fPM); // Make sure we didn't set both somehow.
    if (i == 0)
    {
        // String without values
        return(0);
    }
    switch(i)
    {
        case 1:     // Hour
        case 2:     // Hour, minutes
            Trace0("We got time\n");
            fGotTime = TRUE;
            break;
        case 3:

            // This one might be ambiguous, try to intelligently decide what
            // we have.  First check if only time or date only was requested,
            // then check for out of bounds time values, and lastly check for
            // the presence of a time seperator.

            if (!fGotTime) // If we didn't already have AM/PM
            {
                Trace0("Picking between time and date by seperator\n");
                if (nFormat == TFRQ_DATE_ONLY)
                {
                    fGotDate = TRUE;
                }
                else if (nFormat == TFRQ_TIME_ONLY)
                {
                    fGotTime = TRUE;
                }
                else if ((anValues[0] > 23) || (anValues[1] > 59) || (anValues[2] > 59))
                {
                    fGotDate = TRUE;
                }
                else if (str.Find(CIntlTime::m_itsInternationalSettings.strTimeSeperator) != -1)
                {
                    fGotTime = TRUE;
                }
                else
                {
                    fGotDate = TRUE;
                }
                Trace1("Decided on %s", (fGotDate ?  "date\n" : "time\n"));
            }
            break;
        case 4: // Date, hour
        case 5: // Date, hours, minutes
        case 6: // Date, hours, minutes, seconds
            Trace0("We got date and time\n");
            fGotDate = TRUE;
            fGotTime = TRUE;
            break;
        default:
            ASSERT(0 && "Incorrect number of values!");
            return(0);
    }

    // Was that what we're looking for?
    if ( ((nFormat == TFRQ_DATE_ONLY) && fGotTime) ||
         ((nFormat == TFRQ_TIME_ONLY) && fGotDate) ||
         ((nFormat == TFRQ_TIME_AND_DATE) && (!fGotTime || !fGotDate))
       )
    {
        Trace0("Entry didn't match expectations\n");
        return(0);

    }
    i = 0;

    int h, m, s, D, M, Y;   // Array indices;
    // Now determine where to find what.
    if (fGotDate) // Date always goes first
    {
        switch(CIntlTime::m_itsInternationalSettings.nDateFormat)
        {
            case _DFMT_MDY:
                M = i++;
                D = i++;
                Y = i++;
                break;

            case _DFMT_DMY:
                D = i++;
                M = i++;
                Y = i++;
                break;

            case _DFMT_YMD:
                Y = i++;
                M = i++;
                D = i++;
                break;
        }
        // If only 2 digits are given, determine if we're talking about
        // the 21st or 20th century
        if (anValues[Y] < 100)
        {
            anValues[Y] += (anValues[Y] > 37) ? 1900 : 2000;
        }
        Trace3("Month = %d Day = %d Year = %d\n", anValues[M], anValues[D], anValues[Y]);

        // Validation.
        if (!IsValidDate(anValues[M], anValues[D], anValues[Y]))
        {
            return(0);
        }
    }

    if (fGotTime)
    {
        h = i++;
        m = i++;
        s = i++;

        Trace3("Hours = %d Minutes = %d Seconds = %d\n", anValues[h], anValues[m], anValues[s]);

        // Shouldn't specify AM or PM with 24 hour clock value.
        if ((anValues[h] > 12) && (fAM || fPM))
        {
            return(0);
        }

        // Adjust for AM/PM modifiers
        if (fPM)
        {
            if (anValues[h] != 12)
            {
                anValues[h] += 12;
            }
        }
        else if (fAM)
        {
            if ( anValues[h] == 12)
            {
                anValues[h] -= 12;
            }
        }

        // Sanity Check:
        if (!IsValidTime(anValues[h], anValues[m], anValues[s]))
        {
            return(0);
        }
    }

    // Fill in the missing fields
    CIntlTime tm( fGotDate ? anValues[Y] : tmTmp.GetYear(),
                  fGotDate ? anValues[M] : tmTmp.GetMonth(),
                  fGotDate ? anValues[D] : tmTmp.GetDay(),
                  fGotTime ? anValues[h] : tmTmp.GetHour(),
                  fGotTime ? anValues[m] : tmTmp.GetMinute(),
                  fGotTime ? anValues[s] : tmTmp.GetSecond()
                );

    *pfOk = (tm.GetTime() > (time_t)0);

    return(tm);
}

#ifdef _DEBUG

// Dump to debug device
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlTime& tim)
{
    dc << _T("\nDate Seperator: ") << tim.m_itsInternationalSettings.strDateSeperator;
    dc << _T("\nTime Seperator: ") << tim.m_itsInternationalSettings.strTimeSeperator;
    dc << _T("\nAM String: ")  << tim.m_itsInternationalSettings.strAM;
    dc << _T("\nPM String: ")  << tim.m_itsInternationalSettings.strPM;
    dc << _T("\nDate Format: ") << tim.m_itsInternationalSettings.nDateFormat;
    dc << _T("\n24 Hour Clock: ")  << (tim.m_itsInternationalSettings.f24HourClock ? "TRUE" : "FALSE");
    dc << _T("\n4 Digit Century: ") << (tim.m_itsInternationalSettings.fCentury ? "TRUE" : "FALSE");
    dc << _T("\nTime Leading Zero: ")  << (tim.m_itsInternationalSettings.fLeadingTimeZero ? "TRUE" : "FALSE");
    dc << _T("\nDay Leading Zero ")  << (tim.m_itsInternationalSettings.fLeadingDayZero ? "TRUE" : "FALSE");
    dc << _T("\nMonth Leading Zero: ")  << (tim.m_itsInternationalSettings.fLeadingMonthZero ? "TRUE" : "FALSE");
    dc << _T("\n\ntime_t: ") << tim.GetTime();
    return(dc);
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\intlnum.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1997 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _INTLNUM_H_
#define _INTLNUM_H_

class CIntlNumber : public CObjectPlus
{
public:
    CIntlNumber()
    {
        m_lValue = 0L;
        m_fInitOk = TRUE;
    }
    CIntlNumber(LONG lValue)
    {
        m_lValue = lValue;
        m_fInitOk = TRUE;
    }
    CIntlNumber(const CString & str);

    CIntlNumber(CIntlNumber const &x)
    {
        m_lValue = x.m_lValue;
        m_fInitOk = x.m_fInitOk;
    }

    CIntlNumber& operator =(CIntlNumber const &x)
    {
        m_lValue = x.m_lValue;
        m_fInitOk = x.m_fInitOk;
        return(*this);
    }

public:
    // Assignment Operators
    CIntlNumber& operator =(LONG l);
    CIntlNumber& operator =(const CString &str);

    // Shorthand operators.
    CIntlNumber& operator +=(const CIntlNumber& num);
    CIntlNumber& operator +=(const LONG l);
    CIntlNumber& operator -=(const CIntlNumber& num);
    CIntlNumber& operator -=(const LONG l);
    CIntlNumber& operator /=(const CIntlNumber& num);
    CIntlNumber& operator /=(const LONG l);
    CIntlNumber& operator *=(const CIntlNumber& num);
    CIntlNumber& operator *=(const LONG l);

    // Conversion operators
    operator const LONG() const
    {
        return(m_lValue);
    }
    operator const CString() const;

public:
    virtual BOOL IsValid() const
    {
        return(m_fInitOk);
    }

public:
    static void Reset();
    static void SetBadNumber(CString strBadNumber = "--")
    {
        m_strBadNumber = strBadNumber;
    }
    static CString ConvertNumberToString(const LONG l);
    static LONG ConvertStringToNumber(const CString & str, BOOL * pfOk);
    static CString& GetBadNumber()
    {
        return(m_strBadNumber);
    }

private:
    static CString GetThousandSeperator();

private:
    static CString m_strThousandSeperator;
    static CString m_strBadNumber;

private:
    LONG m_lValue;
    BOOL m_fInitOk;

public:
    #ifdef _DEBUG
        friend CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlNumber& num);
    #endif // _DEBUG

    friend CArchive& AFXAPI operator<<(CArchive& ar, const CIntlNumber& num);
    friend CArchive& AFXAPI operator>>(CArchive& ar, CIntlNumber& num);
};

class CIntlLargeNumber : public CObjectPlus
{
public:
    CIntlLargeNumber()
    {
        m_lLowValue = 0L;
        m_lHighValue = 0L;
        m_fInitOk = TRUE;
    }
    CIntlLargeNumber(LONG lHighWord, LONG lLowWord)
    {
        m_lLowValue = lLowWord;
        m_lHighValue = lHighWord;
        m_fInitOk = TRUE;
    }
    CIntlLargeNumber(const CString & str);

public:
    // Assignment Operators
    CIntlLargeNumber& operator =(const CString &str);
    operator const CString() { return ConvertNumberToString(); }
    operator CString() { return ConvertNumberToString(); }

public:
    virtual LONG GetLowWord() const { return m_lLowValue; }
    virtual LONG GetHighWord() const { return m_lHighValue; }
    virtual BOOL IsValid() const { return(m_fInitOk); }

private:
    static CString m_strBadNumber;
    CString ConvertNumberToString();
    void ConvertStringToNumber(const CString & str, BOOL * pfOk);

private:
    LONG m_lLowValue;
    LONG m_lHighValue;
    BOOL m_fInitOk;
};

#endif _INTLNUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\ipaddres.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#define OEMRESOURCE
#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include <winsock.h>

#include "objplus.h"
#include "ipaddres.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

// CAVEAT: The functions herein require the winsock lib.

// Constructor
CIpAddress::CIpAddress (const CString & str)
{
    CHAR szString [ MAX_PATH ] = {0};

	if (IsValidIp(str))
	{
#ifdef UNICODE
		::WideCharToMultiByte(CP_ACP, 0, str, -1, szString, sizeof(szString), NULL, NULL);
#else
		strcpy (szString, str, str.GetLength());
#endif

		ULONG ul = ::inet_addr( szString );
		m_fInitOk = (ul != INADDR_NONE);
    
		//  Convert the string to network byte order, then to host byte order.
		if (m_fInitOk)
		{
			m_lIpAddress = (LONG)::ntohl(ul) ;
		}
	}
	else
	{
		m_fInitOk = FALSE;
		m_lIpAddress = 0;
	}
}

// Assignment operator
const CIpAddress & CIpAddress::operator =(const LONG l)
{
    m_lIpAddress = l;
    m_fInitOk = TRUE;
    return (*this);
}

// Assignment operator
const CIpAddress & CIpAddress::operator =(const CString & str)
{
    CHAR szString [ MAX_PATH ] = {0};

	if (IsValidIp(str))
	{
#ifdef UNICODE
	    ::WideCharToMultiByte(CP_ACP, 0, str, -1, szString, sizeof(szString), NULL, NULL);
#else
		strcpy (szString, str, str.GetLength());
#endif

		ULONG ul = ::inet_addr( szString );
		m_fInitOk = (ul != INADDR_NONE);
    
		//  Convert the string to network byte order, then to host byte order.
		if (m_fInitOk)
		{
			m_lIpAddress = (LONG)::ntohl(ul) ;
		}
	}
	else
	{
		m_fInitOk = FALSE;
		m_lIpAddress = 0;
	}

    return(*this);
}

BOOL
CIpAddress::IsValidIp(const CString & str)
{
	BOOL fValid = TRUE;

	for (int i = 0; i < str.GetLength(); i++)
	{
		if (str[i] != '.' &&
			!iswdigit(str[i]))
		{
			fValid = FALSE;
			break;
		}
	}

	return fValid;
}

// Conversion operator
CIpAddress::operator const CString&() const
{
    struct in_addr ipaddr ;
    static CString strAddr;

    //  Convert the unsigned long to network byte order
    ipaddr.s_addr = ::htonl( (u_long) m_lIpAddress ) ;

    //  Convert the IP address value to a string
    strAddr = inet_ntoa( ipaddr ) ;

    return(strAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\intlnum.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1997 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#define OEMRESOURCE
#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>

#include "objplus.h"
#include "intlnum.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//
// Initialise static thousand seperator string
//
CString CIntlNumber::m_strThousandSeperator(GetThousandSeperator());
CString CIntlNumber::m_strBadNumber("--");

/***
 * 
 *  CIntlNumber::GetThousandSeperator
 *
 *  Purpose:
 *
 *      Get the thousand seperator string from the registry (win32) or the
 *      win.ini file (win16).
 *
 *  Returns:
 *
 *      A CString containing the system thousand seperator, or the
 *      American default (",") in case of failure.
 *
 */
CString CIntlNumber::GetThousandSeperator()
{
    #define MAXLEN  6

#ifdef _WIN32   

    CString str;

    if (::GetLocaleInfo(GetUserDefaultLCID(), LOCALE_STHOUSAND, str.GetBuffer(MAXLEN), MAXLEN))
    {
         str.ReleaseBuffer();
         return(str);
    }
    Trace0("Couldn't get 1000 seperator from system, using american default");
    str = ",";
    return(str);

#endif // _WIN32

#ifdef _WIN16

    CString str;

    ::GetProfileString("Intl", "sThousand", ",", str.GetBuffer(MAXLEN), MAXLEN);
    str.ReleaseBuffer();
    return(str);

#endif // _WIN16

}

/***
 *
 *  CIntlNumber::Reset()
 *
 *  Purpose:
 *
 *      Reset the international settings. Usually in response to
 *      a change in those international settings by the user.
 *
 *  Notes:
 *
 *      This is a publically available static function.
 *
 */
void CIntlNumber::Reset()
{
    CIntlNumber::m_strThousandSeperator = GetThousandSeperator();
}

/***
 * 
 *  CIntlNumber::ConvertNumberToString
 *
 *  Purpose:
 *
 *      Convert the given long number to a string, inserting thousand
 *      seperators at the appropriate intervals.
 *
 *  Arguments:
 *
 *      const LONG l        The number to convert
 *
 *  Returns:
 *
 *      A CString containing the number in string format.
 *
 */
CString CIntlNumber::ConvertNumberToString(const LONG l)
{
    // Default returned string:
    CString str = CIntlNumber::m_strBadNumber;

    LPTSTR lpOutString = str.GetBuffer(16);
    int outstrlen;
    // Forget about the negative sign for now.
    LONG lNum = (l >= 0) ? l : -l;

    outstrlen = 0;
    do
    {
        lpOutString[outstrlen++] = '0' + (TCHAR)(lNum % 10);
        lNum /= 10;

        // if more digits left and we're on a 1000 boundary (printed 3 digits,
        // or 3 digits + n*(3 digits + 1 comma), then print a 1000 separator.

        if (lNum != 0 && (outstrlen == 3 || outstrlen == 7 || outstrlen == 11))
        {
            lstrcpy (lpOutString + outstrlen, CIntlNumber::m_strThousandSeperator);
            outstrlen += m_strThousandSeperator.GetLength();
        }

    } while (lNum > 0);

    // Add a negative sign if necessary.
    if (l < 0L)
    {
        lpOutString[outstrlen++] = '-';
    }
    lpOutString[outstrlen] = '\0';
    str.ReleaseBuffer();
    str.MakeReverse();

    return(str);
}

/***
 *
 *  CIntlNumber::ConvertStringToNumber
 *
 *  Purpose:
 *
 *      Given a CString, with optional thousand seperators, convert it to
 *      a LONG.
 *
 *  Arguments:
 *
 *      const CString & str The string to convert
 *      BOOL * pfOk         Returns TRUE for successful conversion,
 *                          FALSE for failure.
 *
 *  Returns:
 *
 *      The return value is the number, or 0 if the string contained
 *      invalid characters.
 *
 *  Notes:
 *
 *      If a negative sign is given, it must be the first character of
 *      the string, immediately (no spaces) followed by the number.
 *
 *      Optional thousand seperators can only be placed at the expected
 *      3 digit intervals.  The function will return an error if a thousand
 *      seperator is encountered elsewhere.
 *
 *      [CAVEAT] This function will not accept thousand seperators of longer
 *               than one character.
 *
 *      No leading or trailing spaces will be acceptable.
 *
 */
LONG CIntlNumber::ConvertStringToNumber(const CString & str, BOOL * pfOk)
{
    CString strNumber(str);
    LONG lValue = 0L;
    LONG lBase = 1L;
    *pfOk = FALSE;
    BOOL fNegative = FALSE;
 
    // Empty strings are invalid
    if (strNumber.IsEmpty())
    {
        return(lValue);
    }
   
    int i;

    strNumber.MakeReverse();
    for (i=0; i<strNumber.GetLength(); ++i)
    {
        if ((strNumber[i] >= '0') && (strNumber[i] <= '9'))
        {
            lValue += (LONG)(strNumber[i] - '0') * lBase;
            lBase *= 10;
        }
        // It's not a digit, maybe a thousand seperator?
        // CAVEAT: If a thousand seperator of more than
        //         one character is used, this won't work.
        else if ((strNumber[i] != m_strThousandSeperator[0]) ||
              (i != 3) && (i != 7) && (i != 11))
        {
            // Check for negative sign (at the end only)
            if ((strNumber[i] == '-') && (i == strNumber.GetLength()-1))
            {
                fNegative = TRUE;
            }
            else
            {
                // This is just invalid, since it is not a thousand
                // seperator in the proper location, nor a negative
                // sign.
                Trace1("Invalid character %c encountered in numeric conversion", (BYTE)strNumber[i]);
                return(0L);
            }
        }
    }
         
    if (fNegative)
    {
        lValue = -lValue;
    }
    *pfOk = TRUE;    
    return (lValue);
}

// Constructor taking a CString argument
CIntlNumber::CIntlNumber(const CString & str)
{
    m_lValue = ConvertStringToNumber(str, &m_fInitOk);
}

// Assignment operator
CIntlNumber & CIntlNumber::operator =(LONG l)
{
    m_lValue = l;
    m_fInitOk = TRUE;
    return(*this);
}

// Assignment operator
CIntlNumber & CIntlNumber::operator =(const CString &str)
{
    m_lValue = ConvertStringToNumber(str, &m_fInitOk);
    return(*this);
}

// Conversion operator
CIntlNumber::operator const CString() const
{
    return(IsValid() ? ConvertNumberToString(m_lValue) : CIntlNumber::m_strBadNumber);
}

#ifdef _DEBUG
//
// Dump context to the debugging output
//
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlNumber& num)
{
    dc << num.m_lValue;
    return(dc);
}

#endif // _DEBUG
                     
// Initialise static thousand seperator string
CString CIntlLargeNumber::m_strBadNumber("--");

/***
 * 
 *  CIntlLargeNumber::ConvertNumberToString
 *
 *  Purpose:
 *
 *      Convert the given long number to a string.
 *
 *  Returns:
 *
 *      A CString containing the number in string format.
 *
 */
CString CIntlLargeNumber::ConvertNumberToString()
{    
    CString str;

    TCHAR sz[20];
    TCHAR *pch = sz;
    ::wsprintf(sz, _T("%08lX%08lX"), m_lHighValue, m_lLowValue);
    // Kill leading zero's
    while (*pch == '0')
    {
        ++pch;
    }
    // At least one digit...
    if (*pch == '\0')
    {
        --pch;
    }

    str = pch;

    return(str);
}

/***
 *
 *  CIntlLargeNumber::ConvertStringToNumber
 *
 *  Purpose:
 *
 *      Given a CString convert it to LargeInteger.
 */
void CIntlLargeNumber::ConvertStringToNumber(const CString & str, BOOL * pfOk)
{
    *pfOk = FALSE;

    m_lHighValue = m_lLowValue = 0;

    int j = str.GetLength();

    if ( j > 16 || !j )
    {
        //
        // Invalid string
        //
        return;
    }

    TCHAR sz[] = _T("0000000000000000");
    TCHAR *pch;

    ::lstrcpy(sz + 16 - j, (LPCTSTR)str);
    pch = sz + 8;
    ::swscanf(pch, _T("%08lX"), &m_lLowValue);
    *pch = '\0';
    ::swscanf(sz, _T("%08lX"), &m_lHighValue);

    *pfOk = TRUE;    
    return;
}

// Constructor taking a CString argument
CIntlLargeNumber::CIntlLargeNumber(const CString & str)
{
    ConvertStringToNumber(str, &m_fInitOk);
}


// Assignment operator
CIntlLargeNumber & CIntlLargeNumber::operator =(const CString &str)
{
    ConvertStringToNumber(str, &m_fInitOk);
    return(*this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\ipadrcls.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1998 **/
/**********************************************************************/

/*

    ipaddr.cpp:  CWndIpAddress class control implementation     

    FILE HISTORY:
*/

#include "stdafx.h"

#include "ipaddr.hpp"

extern "C"
{
   #include "ipadd.h"
   #include "ipaddr.h"
}

    //  Static class-level data

    //  Super window proc address
WNDPROC CWndIpAddress :: m_wproc_super = NULL ;

    //  Window class initialization flag                  
BOOL CWndIpAddress :: m_b_inited = FALSE ;


WNDPROC * CWndIpAddress :: GetSuperWndProcAddr ()
{
    return & m_wproc_super ;
}


BOOL CWndIpAddress :: CreateWindowClass ( HINSTANCE hInstance )
{
    Trace0("CWndIpAddress::CreateWindowClass\n");
    if ( ! m_b_inited ) 
    {
        m_b_inited = ::IPAddrInit( hInstance )  ;
    }
    return m_b_inited ;
}

IMPLEMENT_DYNAMIC(CWndIpAddress, CWnd)

CWndIpAddress :: CWndIpAddress ()
{
}

CWndIpAddress :: ~ CWndIpAddress ()
{
    DestroyWindow();
}

BOOL CWndIpAddress :: Create ( 
    LPCTSTR			lpszText, 
    DWORD			dwStyle,
    const RECT &	rect, 
    CWnd *			pParentWnd, 
    UINT			nID )
{
    return CWnd::Create( TEXT("IPAddress"), lpszText, dwStyle, rect, pParentWnd, nID);
}

    //  Modification flag handling
void CWndIpAddress :: SetModify ( BOOL bModified )
{
    ::SendMessage( m_hWnd, IP_SETMODIFY, bModified, 0 );
}

BOOL CWndIpAddress :: GetModify () const
{
    return ::SendMessage( m_hWnd, IP_GETMODIFY, 0, 0 ) > 0 ;
}

void CWndIpAddress :: SetFocusField( int iField )
{
    ::SendMessage( m_hWnd, IP_SETFOCUS, iField, 0);
}

void CWndIpAddress::ClearAddress ( )
{
    ::SendMessage( m_hWnd, IP_CLEARADDRESS, 0, 0);
}

BOOL CWndIpAddress :: SetAddress ( DWORD dwAddr )
{
    return ::SendMessage( m_hWnd, IP_SETADDRESS, 0, dwAddr ) > 0 ;
}

BOOL CWndIpAddress :: GetAddress ( DWORD * pdwAddr ) const
{
    return ::SendMessage( m_hWnd, IP_GETADDRESS, 0,(LPARAM) pdwAddr ) > 0 ;
}
    void SetReadOnly (BOOL fReadonly = TRUE);
    void SetField(int dwField, BYTE bValue);

void CWndIpAddress :: SetReadOnly ( BOOL fReadOnly )
{
    ::SendMessage( m_hWnd, IP_SETREADONLY, (WPARAM)fReadOnly, (LPARAM)0 );
}

void CWndIpAddress :: SetField (int dwField, BOOL fSet, BYTE bValue)
{
    ::SendMessage( m_hWnd, IP_SETFIELD, (WPARAM)dwField, fSet 
        ? MAKELPARAM(0, MAKEWORD(0, bValue))
        : (LPARAM)-1
        );
}

BYTE CWndIpAddress :: GetMask () const
{
    DWORD_PTR dw = ::SendMessage( m_hWnd, IP_GETMASK, 0, 0);
    return (BYTE)dw;
}

BOOL CWndIpAddress :: SetMask(DWORD dwAddress, BYTE bMask)
{
    return ::SendMessage( m_hWnd, IP_SETMASK, (WPARAM)bMask, (LPARAM)dwAddress) > 0;
}

BOOL CWndIpAddress :: IsBlank()
{
    return ::SendMessage( m_hWnd, IP_ISBLANK, 0, 0) > 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\ipaddres.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _IPADDRES_H_
#define _IPADDRES_H_

//
// IP Address Conversion Macros
//
#ifndef MAKEIPADDRESS
  #define MAKEIPADDRESS(b1,b2,b3,b4) ((LONG)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

  #define GETIP_FIRST(x)             ((x>>24) & 0xff)
  #define GETIP_SECOND(x)            ((x>>16) & 0xff)
  #define GETIP_THIRD(x)             ((x>> 8) & 0xff)
  #define GETIP_FOURTH(x)            ((x)     & 0xff)
#endif // MAKEIPADDRESS

/////////////////////////////////////////////////////////////////////////////
// CIpAddress class

class CIpAddress : public CObjectPlus
{
public:
    // Constructors
    CIpAddress()
    {
        m_lIpAddress = 0L;
        m_fInitOk = FALSE;
    }
    CIpAddress (LONG l)
    {
        m_lIpAddress = l;
        m_fInitOk = TRUE;
    }
    CIpAddress (BYTE b1, BYTE b2, BYTE b3, BYTE b4)
    {
        m_lIpAddress = (LONG)MAKEIPADDRESS(b1,b2,b3,b4);
        m_fInitOk = TRUE;
    }
    CIpAddress(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
    }

    CIpAddress (const CString & str);

    //
    // Assignment operators
    //
    const CIpAddress & operator =(const LONG l);
    const CIpAddress & operator =(const CString & str);
    const CIpAddress & operator =(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
        return *this;
    }

    //
    // Conversion operators
    //
    operator const LONG() const
    {
        return m_lIpAddress;
    }
    operator const CString&() const;

public:
    BOOL IsValid() const
    {
        return m_fInitOk;
    }

protected:
	BOOL IsValidIp(const CString & str);

private:
    LONG m_lIpAddress;
    BOOL m_fInitOk;
};

#endif _IPADDRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\intltime.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _INTLTIME_H_
#define _INTLTIME_H_

//
// Utility functions
//
void FormatDateTime(CString & strOutput, SYSTEMTIME * psystemtime, BOOL fLongDate = FALSE);
void FormatDateTime(CString & strOutput, FILETIME * pfiletime, BOOL fLongDate = FALSE);
void FormatDateTime(CString & strOutput, CTime & time, BOOL fLongDate = FALSE);

//
// CIntlTime class definition
//
class CIntlTime : public CTime
{
//
// Attributes
//
public:
    enum _TIME_FORMAT_REQUESTS
    {
        TFRQ_TIME_ONLY,
        TFRQ_DATE_ONLY,
        TFRQ_TIME_AND_DATE,
        TFRQ_TIME_OR_DATE,
        TFRQ_MILITARY_TIME,
    };

public:
// Same contructors as CTime
    CIntlTime();
    CIntlTime(const CTime &timeSrc);
    CIntlTime(time_t time);
    CIntlTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec);
    CIntlTime(WORD wDosDate, WORD wDosTime);
#ifdef _WIN32
    CIntlTime(const SYSTEMTIME& sysTime);
    CIntlTime(const FILETIME& fileTime);
#endif // _WIN32

// New for CIntlTime
    CIntlTime(const CIntlTime &timeSrc);
    CIntlTime(const CString &strTime, int nFormat = TFRQ_TIME_OR_DATE, time_t * ptmOldValue = NULL);

public:
    virtual ~CIntlTime();

// Operations
public:
    // Assignment operators
    const CIntlTime& operator=(time_t tmValue);
    const CIntlTime& operator=(const CString& strValue);
    const CIntlTime& operator=(const CTime & time);
    const CIntlTime& operator=(const CIntlTime & time);

    // Conversion operators
    operator const time_t() const;
    operator CString() const;
    operator const CString() const;

    const CString IntlFormat(int nFormat) const
    {
        return(ConvertToString(nFormat));
    }

    // Validation checks

    BOOL IsValid() const
    {
        return(m_fInitOk);
    }

    static BOOL IsIntlValid()
    {
        return(CIntlTime::m_fIntlOk);
    }

public:
    // ... Input and output
    #ifdef _DEBUG
        friend CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlTime& tim);
    #endif // _DEBUG

    friend CArchive& AFXAPI operator <<(CArchive& ar, const CIntlTime& tim);
    friend CArchive& AFXAPI operator >>(CArchive& ar, CIntlTime& tim);

// Implementation

public:
    static void Reset();
    static void SetBadDateAndTime(CString strBadDate = "--", CString strBadTime = "--")
    {
        m_strBadDate = strBadDate;
        m_strBadTime = strBadTime;
    }
    static CString& GetBadDate()
    {
        return(m_strBadDate);
    }
    static CString& GetBadTime()
    {
        return(m_strBadTime);
    }
    static time_t ConvertFromString (const CString & str, int nFormat, time_t * ptmOldValue, BOOL * pfOk);
    static BOOL IsLeapYear(UINT nYear); // Complete year value
    static BOOL IsValidDate(UINT nMonth, UINT nDay, UINT nYear);
    static BOOL IsValidTime(UINT nHour, UINT nMinute, UINT nSecond);


private:
    enum _DATE_FORMATS
    {
        _DFMT_MDY,  // Day, month, year
        _DFMT_DMY,  // Month, day, year
        _DFMT_YMD,  // Year, month, day
    };

    typedef struct _INTL_TIME_SETTINGS
    {
        CString strDateSeperator; // String used between date fields
        CString strTimeSeperator; // String used between time fields.
        CString strAM;            // Suffix string used for 12 hour clock AM times
        CString strPM;            // Suffix string used for 12 hour clock PM times
        int nDateFormat;          // see _DATE_FORMATS enum above.
        BOOL f24HourClock;        // TRUE = 24 hours, FALSE is AM/PM
        BOOL fCentury;            // If TRUE, uses 4 digits for the century
        BOOL fLeadingTimeZero;    // If TRUE, uses leading 0 in time format
        BOOL fLeadingDayZero;     // If TRUE, uses leading 0 in day
        BOOL fLeadingMonthZero;   // If TRUE, uses leading 0 in month
    } INTL_TIME_SETTINGS;

    static INTL_TIME_SETTINGS m_itsInternationalSettings;
    static CString m_strBadTime;
    static CString m_strBadDate;

private:
    static BOOL SetIntlTimeSettings();
    static BOOL m_fIntlOk;

private:
    const CString GetDateString() const;
    const CString GetTimeString() const;
    const CString GetMilitaryTime() const;
    const CString ConvertToString(int nFormat) const;

private:
    BOOL m_fInitOk;
};

#endif _INTLTIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\ncglobal.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ncglobal.cpp
        network console global stuff

	FILE HISTORY:
        
*/

// {DA1BDD17-8E54-11d1-93DB-00C04FC3357A}
DEFINE_GUID(GUID_NetConsRootNodeType, 
    0xda1bdd17, 0x8e54, 0x11d1, 0x93, 0xdb, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a);

#define NETCONS_ROOT_TOP            L"NETCONS_ROOT_TOP"
#define NETCONS_ROOT_THIS_MACHINE   L"NETCONS_ROOT_THIS_MACHINE"
#define NETCONS_ROOT_NET_SERVICES   L"NETCONS_ROOT_NET_SERVICES"
#define NETCONS_ROOT_LOAD_CONSOLES  L"NETCONS_ROOT_LOAD_CONSOLES"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\listctrl.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    lcx.cpp
//
// History:
//  07/13/96    Abolade Gbadegesin      Created, based on C code by Steve Cobb
//
// Implements an enhanced list-control.
//============================================================================
#include "stdafx.h"
#include "resource.h"
#include "util.h"
#include "listctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNAMIC(CListCtrlEx, CListCtrl)

BEGIN_MESSAGE_MAP(CListCtrlEx, CListCtrl)
    //{{AFX_MSG_MAP(CListCtrlEx)
    ON_WM_LBUTTONDOWN()
    ON_WM_CHAR()
    ON_WM_KEYDOWN()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::~CListCtrlEx
//
// Destructor. Deletes the image list, if any, and unloads row-information.
//----------------------------------------------------------------------------

CListCtrlEx::~CListCtrlEx(
    ) {

	delete m_pimlChecks;
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::GetColumnCount
//
// Called to retrieve the number of columns in any list-control.
//----------------------------------------------------------------------------

INT
CListCtrlEx::GetColumnCount(
    ) {

    return Header_GetItemCount(ListView_GetHeader(m_hWnd));
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::SetColumnText
//
// Sets the text in the header of the column in position 'iCol'.
//----------------------------------------------------------------------------

BOOL
CListCtrlEx::SetColumnText(
    INT             iCol,
    LPCTSTR         pszText,
    INT             fmt
    ) {

    LV_COLUMN   lvc;

    lvc.mask = LVCF_FMT | LVCF_TEXT;
    lvc.pszText = (LPTSTR)pszText;
    lvc.fmt = fmt;

    return SetColumn(iCol, &lvc);
}


//----------------------------------------------------------------------------
// Function:    CListCtrlEx::InstallChecks
//
// Installs check-box handling for the list-control.
//----------------------------------------------------------------------------

BOOL
CListCtrlEx::InstallChecks(
    ) {

    HICON   hIcon;

    //
    // Make sure the list-control is in report-mode
    //

    if (!(GetStyle() & LVS_REPORT)) { return FALSE; }


    //
    // Allocate a new image-list.
    //

    m_pimlChecks = new CImageList;

    if (!m_pimlChecks) { return FALSE; }

    do {
    
        //
        // Initialize the image-list
        //
    
        if (!m_pimlChecks->Create(
                ::GetSystemMetrics(SM_CXSMICON),
                ::GetSystemMetrics(SM_CYSMICON),
                ILC_MASK, 2, 2
                )) {
    
            break;
        }
    
    
        //
        // Add the icons for the checked and unchecked images
        //
    
        hIcon = ::LoadIcon(
                    AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_COMMON_UNCHECK)
                    );

        if (!hIcon) { break; }

        m_pimlChecks->Add(hIcon); ::DeleteObject(hIcon);

    
        hIcon = ::LoadIcon(
                    AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_COMMON_CHECK)
                    );

        if (!hIcon) { break; }

        m_pimlChecks->Add(hIcon); ::DeleteObject(hIcon);


        //
        // Replace the list-control's current image-list with the new one
        //
    
        m_pimlOldState = SetImageList(m_pimlChecks, LVSIL_STATE);

        return TRUE;
    
    } while(FALSE);


    //
    // If we arrive here, an error occurred, so clean up and fail
    //

    delete m_pimlChecks; m_pimlChecks = NULL;

    return FALSE;
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::UninstallChecks
//
// Uninstalls checkbox-handling for the list-control.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::UninstallChecks(
    ) {

    if (!m_pimlChecks) { return; }

    if (m_pimlOldState) { SetImageList(m_pimlOldState, LVSIL_STATE); }

    delete m_pimlChecks; m_pimlChecks = NULL;
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::GetCheck
//
// Returns TRUE if the specified item is checked, FALSE otherwise.
//----------------------------------------------------------------------------

BOOL
CListCtrlEx::GetCheck(
    INT     iItem
    ) {

    return !!(GetItemState(iItem, LVIS_STATEIMAGEMASK) &
                INDEXTOSTATEIMAGEMASK(LCXI_CHECKED));
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::SetCheck
//
// If 'fCheck' is non-zero, checks 'iItem', otherwise clears 'iItem'.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::SetCheck(
    INT     iItem,
    BOOL    fCheck
    ) {

    SetItemState(
        iItem,
        INDEXTOSTATEIMAGEMASK(fCheck ? LCXI_CHECKED : LCXI_UNCHECKED),
        LVIS_STATEIMAGEMASK
        );

    if (GetParent()) {

        NMHDR nmh;

        nmh.code = LVXN_SETCHECK;
        nmh.hwndFrom = m_hWnd;

        ::SendMessage(
            GetParent()->m_hWnd, WM_NOTIFY, GetDlgCtrlID(), (LPARAM)&nmh
            );
    }
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::OnChar
//
// Handles the 'WM_CHAR' message for the list-control.
// This allows users to change items' checked-states using the keyboard.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::OnChar(
    UINT    nChar,
    UINT    nRepCnt,
    UINT    nFlags
    ) {

    BOOL    fSet = FALSE;
    BOOL    fClear = FALSE;
    BOOL    fToggle = FALSE;
    INT     iItem;


    //
    // Handle characters with special meaning for us
    //

    switch (nChar) {

        case TEXT(' '): { fToggle = TRUE; break; }

        case TEXT('+'):
        case TEXT('='): { fSet = TRUE; break; }

        case TEXT('-'): { fClear = TRUE; break; }
    }

    if (!fToggle && !fSet && !fClear) {

        CListCtrl::OnChar(nChar, nRepCnt, nFlags);
    }
    else {

        //
        // Change the state of all the selected items
        //

        for (iItem = GetNextItem(-1, LVNI_SELECTED);
             iItem != -1;
             iItem = GetNextItem(iItem, LVNI_SELECTED)) {

            if (fToggle) {

                SetCheck(iItem, !GetCheck(iItem));
            }
            else
            if (fSet) {

                if (!GetCheck(iItem)) { SetCheck(iItem, TRUE); }
            }
            else {

                if (GetCheck(iItem)) { SetCheck(iItem, FALSE); }
            }
        }
    }
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::OnKeyDown
//
// Handles the 'WM_KEYDOWN' message for the list-control.
// This allows users to change items' checked-states using the keyboard.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::OnKeyDown(
    UINT    nChar,
    UINT    nRepCnt,
    UINT    nFlags
    ) {

    //
    // We want the left-arrow treated as an up-arrow
    // and the right-arrow treated as a down-arrow.
    //

    if (nChar == VK_LEFT) {

        CListCtrl::OnKeyDown(VK_UP, nRepCnt, nFlags); return;
    }
    else
    if (nChar == VK_RIGHT) {

        CListCtrl::OnKeyDown(VK_DOWN, nRepCnt, nFlags); return;
    }

    CListCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::OnLButtonDown
//
// Handles the 'WM_LBUTTONDOWN' message, changing an item's checked state 
// when the user clicks the item's check-image.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::OnLButtonDown(
    UINT    nFlags,
    CPoint  pt
    ) {

    INT     iItem;
    UINT    uiFlags;


    //
    // If the left-mouse button is over the check-box icon,
    // we treat it as a toggle on the check-box.
    //

    uiFlags = 0;

    iItem = HitTest(pt, &uiFlags);


    if (iItem != -1 && (uiFlags & LVHT_ONITEMSTATEICON)) {

        SetCheck(iItem, !GetCheck(iItem));

        // Redraw this item
        RedrawItems(iItem, iItem);
    }

    CListCtrl::OnLButtonDown(nFlags, pt);
}




//----------------------------------------------------------------------------
// Function:    AdjustColumnWidth
//
// Called to adjust the width of column 'iCol' so that the string 'pszContent'
// can be displayed in the column without truncation.
//
// If 'NULL' is specified for 'pszContent', the function adjusts the column
// so that the first string in the column is displayed without truncation.
//
// Returns the new width of the column.
//----------------------------------------------------------------------------

INT
AdjustColumnWidth(
    IN      CListCtrl&      listCtrl,
    IN      INT             iCol,
    IN      LPCTSTR         pszContent
    ) {

    INT iWidth, iOldWidth;


    //
    // Compute the minimum width the column needs to be
    //

    if (pszContent) {

        iWidth = listCtrl.GetStringWidth(pszContent);
    }
    else {

        iWidth = listCtrl.GetStringWidth(listCtrl.GetItemText(0, iCol));
    }


    //
    // Adjust 'iWidth' to leave some breathing space
    //

    iWidth += ::GetSystemMetrics(SM_CXSMICON) +
              ::GetSystemMetrics(SM_CXEDGE) * 2;


    //
    // If the column is narrower than 'iWidth', enlarge it.
    //

    iOldWidth = listCtrl.GetColumnWidth(iCol);

    if (iOldWidth < iWidth) {

        listCtrl.SetColumnWidth(iCol, iWidth);

        iOldWidth = iWidth;
    }

    return iOldWidth;
}


INT
AdjustColumnWidth(
    IN  CListCtrl&      listCtrl,
    IN  INT             iCol,
    IN  UINT            idsContent
    ) {

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString sCol;

    sCol.LoadString(idsContent);

    return AdjustColumnWidth(listCtrl, iCol, sCol);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\modeless.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       modeless.cpp
//
//--------------------------------------------------------------------------

// StatsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "modeless.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*---------------------------------------------------------------------------
	ModelessThread implementation
 ---------------------------------------------------------------------------*/

IMPLEMENT_DYNCREATE(ModelessThread, CWinThread)

BEGIN_MESSAGE_MAP(ModelessThread, CWinThread)
END_MESSAGE_MAP()

ModelessThread::ModelessThread()
{
}

ModelessThread::ModelessThread(HWND hWndParent, UINT nIDD, HANDLE hEvent, CDialog *pModelessDlg) :
   m_hwndParent(hWndParent),
   m_pModelessDlg(pModelessDlg),
   m_nIDD(nIDD),
   m_hEvent(hEvent)
{
}

ModelessThread::~ModelessThread()
{
	SetEvent(m_hEvent);
	m_hEvent = 0;
}


int ModelessThread::InitInstance()
{
	CWnd *	pParent = CWnd::FromHandle(m_hwndParent);

	BOOL bReturn = m_pModelessDlg->Create(m_nIDD, pParent);

	if (bReturn)
		m_pMainWnd = m_pModelessDlg;
	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\listctrl.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    lcx.h
//
// History:
//  07/13/96    Abolade Gbadegesin      Created, based on C code by Steve Cobb
//
// Contains declarations for an enhanced list-control.
//============================================================================

#ifndef _LISTCTRL_H_
#define _LISTCTRL_H_

#ifndef _COMMON_UTIL_H_
#include "util.h"
#endif


//
// Notification sent by CListCtrlEx when an item's checked state changes.
//

#define LVXN_SETCHECK   (LVN_LAST + 1)


//----------------------------------------------------------------------------
// Structs:     SLcxRow
//              SLcxColumn
//
// Describes rows and columns in customizable list-controls.
//----------------------------------------------------------------------------

struct SLcxRow {

    UINT        uiRowId;
    UINT        idsTitle;
    BOOL        bEnabled;

};

struct SLcxColumn {

    INT         iSubItem;
    UINT        idsTitle;
    INT         cx;
    BOOL        bEnabled;
    INT         iIndex;

};



//----------------------------------------------------------------------------
// Class:       CListCtrlEx
//
// Controls a list-control which has extended capabilities,
// including the ability to show checkboxes next to its items,
// and the ability to maintain row-information in the registry.
//----------------------------------------------------------------------------

class CListCtrlEx : public CListCtrl
{

	DECLARE_DYNAMIC(CListCtrlEx)

public:

	CListCtrlEx()
			: m_pimlChecks(NULL), m_pimlOldState(NULL)
			{ }

	virtual ~CListCtrlEx( );

	enum {
		LCXI_UNCHECKED  = 1,
		LCXI_CHECKED    = 2
	};

	INT	GetColumnCount( );

	BOOL SetColumnText(INT iCol, LPCTSTR pszText, INT fmt = LVCFMT_LEFT );

	BOOL SetColumnText(INT iCol, UINT nID, INT fmt = LVCFMT_LEFT)
	{
        // Needed for Loadstring
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

		CString sCol;
		sCol.LoadString(nID);
		return SetColumnText(iCol, sCol, fmt);
	}


	//--------------------------------------------------------------------
	// Functions:   InstallChecks
	//              UninstallChecks
	//              GetCheck
	//              SetCheck
	//
	// Checkbox-handling functions.
	//--------------------------------------------------------------------
	
	BOOL InstallChecks( );
    VOID UninstallChecks( );
	BOOL GetCheck(INT iItem );
	VOID SetCheck(  INT iItem, BOOL fCheck );

protected:
	CImageList*     m_pimlChecks;
	CImageList*     m_pimlOldState;
	
	//{{AFX_MSG(CListCtrlEx)
	afx_msg VOID    OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg VOID    OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg VOID    OnLButtonDown(UINT nFlags, CPoint pt);
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};


//----------------------------------------------------------------------------
// Function:    AdjustColumnWidth
//
// Called to adjust the width of column 'iCol' so that the string 'pszContent'
// can be displayed in the column without truncation.
//
// If 'NULL' is specified for 'pszContent', the function adjusts the column
// so that the first string in the column is displayed without truncation.
//
// Returns the new width of the column.
//----------------------------------------------------------------------------

INT
AdjustColumnWidth(
    IN      CListCtrl&      listCtrl,
    IN      INT             iCol,
    IN      LPCTSTR         pszContent
    );

INT
AdjustColumnWidth(
    IN  CListCtrl&      listCtrl,
    IN  INT             iCol,
    IN  UINT            idsContent
    );

#endif // _LISTCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\objpick.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       objpick.h
//
//--------------------------------------------------------------------------

// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#ifndef OBJPICK_H
#define OBJPICK_H

//
// A list of names (e.g., users, groups, machines, and etc)
//

void    FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay);

class CUserInfo
{
public:
    CUserInfo() {};
    CUserInfo(LPCTSTR pName, LPCTSTR pFullName)
        : m_strName(pName), m_strFullName(pFullName) {};

    CUserInfo(CUserInfo & userInfo)
    {
		if (this != &userInfo)
			*this = userInfo;
    }

    CUserInfo & operator = (const CUserInfo & userInfo)
    {
        if (this != &userInfo)
        {
            m_strName = userInfo.m_strName;
            m_strFullName = userInfo.m_strFullName;
        }
        
        return *this;
    }

public:
	CString			m_strName;			// in the form of "domain\username"
	CString			m_strFullName;		// in the form of "firstname lastname"
};

typedef CArray<CUserInfo, CUserInfo&> CUserInfoArray;

class CGetUsers : public CUserInfoArray
{
public:
    CGetUsers(BOOL fMultiselect = FALSE);
    ~CGetUsers();

	BOOL    GetUsers(HWND hwndOwner);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

protected:
    BOOL    m_fMultiselect;
};

class CGetComputer 
{
public:
    CGetComputer();
    ~CGetComputer();

    BOOL    GetComputer(HWND hwndOwner);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

public:
    CString     m_strComputerName;
};

#endif // GETUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\modeless.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	modeless.h

	Header file for the base class of the Statistics dialogs.

    FILE HISTORY:
	
*/

#ifndef _MODELESS_H
#define _MODELESS_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#include "commres.h"

// forward declarations
struct ColumnData;


class ModelessThread : public CWinThread
{
	DECLARE_DYNCREATE(ModelessThread)
protected:
	ModelessThread();		// protected constructor used by dynamic creation

public:
	ModelessThread(HWND hWndParent, UINT nIdTemplate,
				   HANDLE hEvent,
				   CDialog *pModelessDialog);

// Operations
public:

	// Overrides
	virtual BOOL	InitInstance();
//	virtual int		ExitInstance();


protected:
	virtual ~ModelessThread();

	CDialog *	m_pModelessDlg;
	UINT		m_nIDD;
	HWND		m_hwndParent;

	// Signal this when we are being destroyed
	HANDLE		m_hEvent;

	DECLARE_MESSAGE_MAP()
};


#endif // _MODELESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\objpick.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       objpick.cpp
//
//--------------------------------------------------------------------------

// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "objpick.h"

#include <iads.h>           
#include <iadsp.h>          // IADsPathname

#include <objsel.h>
#include <adshlp.h>

#include "objplus.h"
#include "ipaddres.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


#define BREAK_ON_FAIL_HRESULT(hr)       \
    if (FAILED(hr)) { Trace2("line %u err 0x%x\n", __LINE__, hr); break; }

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

HRESULT InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, BOOL fMultiselect);
HRESULT InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker);

DWORD ObjPickGetHostName(DWORD dwIpAddr, CString & strHostName);
DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName);


//////////////////////////////////////////////////////////////////////
// CGetUsers Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


void    
FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay)
{
    strDisplay.Format(_T("%s (%s)"), pszFullName, pszDomainName);
}

CGetUsers::CGetUsers(BOOL fMultiselect)
{
    m_fMultiselect = fMultiselect;
}

CGetUsers::~CGetUsers()
{

}

BOOL
CGetUsers::GetUsers(HWND hwndParent)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = InitObjectPickerForGroups(pDsObjectPicker, m_fMultiselect);

        //
        // Invoke the modal dialog.
        //
        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            Trace0("User canceled object picker dialog\n");
            fSuccess = FALSE;
            break;
        }

        //
        // Process the user's selections
        //
        Assert(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;

    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr))
        fSuccess = FALSE;

    return fSuccess;
}

void
CGetUsers::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            Trace1("GlobalLock error %u\n", GetLastError());
            break;
        }

        // create the path name thing
        CComPtr<IADsPathname> spIADsPathname;
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (PVOID *)&spIADsPathname);
        BREAK_ON_FAIL_HRESULT(hr);
        
        hr = spIADsPathname->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );

        for (UINT nCount = 0; nCount < pDsSelList->cItems; nCount++)
        {
            DS_SELECTION * pDsSel = &(pDsSelList->aDsSelection[nCount]);
            Assert(NULL != pDsSel);
        
            LPWSTR pwzADsPath = pDsSel->pwzADsPath;
            Assert( NULL != pwzADsPath );

            hr = spIADsPathname->Set( pwzADsPath, ADS_SETTYPE_FULL );
            if (FAILED(hr))
                continue;

            long lnNumPathElements = 0;
            hr = spIADsPathname->GetNumElements( &lnNumPathElements );
            if (FAILED(hr))
                continue;
        
            CComBSTR sbstrUser, sbstrDomain;
            hr = spIADsPathname->GetElement( 0, &sbstrUser );
            if (FAILED(hr))
                continue;
        
            switch (lnNumPathElements)
            {
                case 1:
                    hr = spIADsPathname->Retrieve( ADS_FORMAT_SERVER, &sbstrDomain );
                    break;

                case 2:  // nt4, nt5 domain
                case 3:  // local domain
                    hr = spIADsPathname->GetElement( 1, &sbstrDomain );
                    break;

                default:
                    Assert(FALSE);
                    hr = E_FAIL;
            }

            if (FAILED(hr))
                continue;

            CUserInfo userTemp;
            CString strDomain;

            strDomain = sbstrDomain;
            strDomain.MakeUpper();

            if (pDsSel->pvarFetchedAttributes[0].vt == VT_EMPTY)
                userTemp.m_strFullName = pDsSel->pwzName;
            else
                userTemp.m_strFullName = V_BSTR(&(pDsSel->pvarFetchedAttributes[0]));
        
            userTemp.m_strName.Format(L"%s\\%s", strDomain, sbstrUser);

            Add(userTemp);
        }

        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}


//////////////////////////////////////////////////////////////////////
// CGetComputer Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGetComputer::CGetComputer()
{
}

CGetComputer::~CGetComputer()
{
}

BOOL
CGetComputer::GetComputer(HWND hwndParent)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Reinitialize the object picker to choose computers
        //

        hr = InitObjectPickerForComputers(pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now pick a computer
        //

        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            Trace0("User canceled object picker dialog\n");
            fSuccess = FALSE;
            break;
        }

        Assert(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;
    
    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr))
        fSuccess = FALSE;

    return fSuccess;
}


void
CGetComputer::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            Trace1("GlobalLock error %u\n", GetLastError());
            break;
        }

        CString strTemp = pDsSelList->aDsSelection[0].pwzName;
        if (strTemp.Left(2) == _T("\\\\"))
            strTemp = pDsSelList->aDsSelection[0].pwzName[2];

        if (ERROR_SUCCESS != ObjPickNameOrIpToHostname(strTemp, m_strComputerName))
        {
            //we use the name from the object picker if we failed to convert it into hostname
            m_strComputerName = strTemp;
        }

        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, BOOL fMultiselect)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE | DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT | DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS | DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE;

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                          | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    aScopeInit[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[3].flType =
       DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
       | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

    aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    aScopeInit[3].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    aScopeInit[3].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    //
    // The Global Catalog
    //

    aScopeInit[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[4].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

    // Only native mode applies to gc scope.

    aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = (fMultiselect) ? DSOP_FLAG_MULTISELECT : 0;

    LPCTSTR attrs[] = {_T("FullName")};

    InitInfo.cAttributesToFetch = 1;
    InitInfo.apwzAttributeNames = attrs;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);

    if (FAILED(hr))
    {
        ULONG i;

        for (i = 0; i < SCOPE_INIT_COUNT; i++)
        {
            if (FAILED(InitInfo.aDsScopeInfos[i].hr))
            {
                printf("Initialization failed because of scope %u\n", i);
            }
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 2;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Build a scope init struct for everything except the joined domain.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;


    //
    // scope for the joined domain, make it the default
    //
    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}

//Use WinSock to the host name based on the ip address
DWORD
ObjPickGetHostName
(
    DWORD       dwIpAddr,
    CString &   strHostName
)
{
    CString strName;

    //
    //  Call the Winsock API to get host name information.
    //
    strHostName.Empty();

    u_long ulAddrInNetOrder = ::htonl( (u_long) dwIpAddr ) ;

    HOSTENT * pHostInfo = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
                                           sizeof ulAddrInNetOrder,
                                           PF_INET ) ;
    if ( pHostInfo == NULL )
    {
        return ::WSAGetLastError();
    }

    // copy the name
    LPTSTR pBuf = strName.GetBuffer(256);
    ZeroMemory(pBuf, 256);

    ::MultiByteToWideChar(CP_ACP, 
                          MB_PRECOMPOSED, 
                          pHostInfo->h_name, 
                          -1, 
                          pBuf, 
                          256);

    strName.ReleaseBuffer();
    strName.MakeUpper();

    int nDot = strName.Find(_T("."));

    if (nDot != -1)
        strHostName = strName.Left(nDot);
    else
        strHostName = strName;

    return NOERROR;
}

//Convert any valid name of a machine (IP address, NetBios name or fully qualified DNS name)
//to the host name
DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName)
{
    DWORD dwErr = ERROR_SUCCESS;
    CString strTemp;

    CIpAddress ia(strNameOrIp);
    if (ia.IsValid())
    {
        dwErr = ObjPickGetHostName((LONG)ia, strTemp);
    }
    else
    {
         // just want the host name
         int nDot = strNameOrIp.Find('.');
         if (nDot != -1)
         {
             strTemp = strNameOrIp.Left(nDot);
         }
         else
         {
             strTemp = strNameOrIp;
         }
    }

    if (ERROR_SUCCESS == dwErr)
    {
        strHostName = strTemp;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\objplus.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#define OEMRESOURCE
#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>

#include "objplus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CObjHelper :: CObjHelper ()
  : m_ctor_err( 0 ),
    m_api_err( 0 ),
    m_b_dirty( FALSE ),
    m_time_created( ::GetCurrentTime() )
{
}


void CObjHelper :: ReportError ( LONG errInConstruction )
{
    Trace1("CObjectPlus construction failure, error = %d", errInConstruction);
    m_ctor_err = errInConstruction ;
}

LONG CObjHelper :: SetApiErr ( LONG errApi )
{
    return m_api_err = errApi ;
}

void CObjHelper :: AssertValid () const
{
    ASSERT( QueryError() == 0 ) ;
}

BOOL CObjHelper :: IsValid () const
{
    return QueryError() == 0 ;
}

DWORD CObjHelper :: QueryAge () const
{
    DWORD dwTime = ::GetCurrentTime(),
          dwDiff ;
    if ( dwTime < m_time_created )
    {
        dwDiff = dwTime + (((DWORD) -1) - (m_time_created - 1)) ;   
    }
    else
    {
        dwDiff = dwTime - m_time_created ;
    }

    return dwDiff ;
}


    //  Constructor of extended object
CObjectPlus :: CObjectPlus ()
{
}

    //  Compare one object with another:  default implementation
    //  orders objects by creation time.  Return -1, 0 or 1.

int CObjectPlus :: Compare ( const CObjectPlus * pob ) const
{
    return QueryCreationTime() < pob->QueryCreationTime()
     ? -1
     : QueryCreationTime() != pob->QueryCreationTime() ;
}

CObListIter :: CObListIter ( const CObOwnedList & obList )
    : m_obList( obList )
{
    Reset() ;
}

void CObListIter :: Reset ()
{
    m_pos = m_obList.GetCount() ? m_obList.GetHeadPosition() : NULL ;
}

CObject * CObListIter :: Next ()
{
    return m_pos == NULL
     ? NULL
     : m_obList.GetNext( m_pos ) ;
}

//
//  Subclass of CObList whose default behavior is to destroy
//    its contents during its own destruction
//
CObOwnedList :: CObOwnedList ( int nBlockSize )
    : CObList( nBlockSize ),
    m_b_owned( TRUE )
{
}

CObOwnedList :: ~ CObOwnedList ()
{
    RemoveAll() ;
}

void CObOwnedList :: RemoveAll ()
{
    if ( m_b_owned )
    {
        //
        //  Remove and discard all the objects
        //
        while ( ! IsEmpty() )
        {
            CObject * pob = RemoveHead() ;
            delete pob ;
        }
    }
    else
    {
        //  Just remove the object pointers
        CObList::RemoveAll() ;
    }
}

CObject * CObOwnedList :: Index ( int index )
{
   CObListIter oli( *this ) ;

   CObject * pob ;

   for ( int i = 0 ; (pob = oli.Next()) && i++ < index ; ) ;

   return pob ;
}

CObject * CObOwnedList :: RemoveIndex ( int index )
{
   POSITION pos ;
   CObListIter oli( *this ) ;
   int i ;
   CObject * pob ;

   for ( i = 0, pos = oli.QueryPosition() ;
     (pob = oli.Next()) && i < index ;
     i++, pos = oli.QueryPosition() ) ;

   if ( pob && i == index )
   {
        RemoveAt( pos ) ;
   }
   else
   {
        pob = NULL ;
   }
   return pob ;
}

    //  Remove the first (and hopefully only) occurrence of an object
    //  pointer from this list.
BOOL CObOwnedList :: Remove ( CObject * pob )
{
    POSITION pos = Find( pob ) ;

    if ( pos == NULL )
    return FALSE ;

    RemoveAt( pos ) ;
    return TRUE ;
}

    //  Set all elements to dirty or clean.  Return TRUE if
    //  any element was dirty.
BOOL CObOwnedList :: SetAll ( BOOL bDirty )
{
    int cDirtyItems = 0 ;
    CObListIter oli( *this ) ;
    CObjectPlus * pob ;

    while ( pob = (CObjectPlus *) oli.Next() )
    {
        cDirtyItems += pob->IsDirty() ;
        pob->SetDirty( bDirty ) ;
    }
    SetDirty( bDirty );

    return cDirtyItems > 0 ;
}


int CObOwnedList :: FindElement ( CObject * pobSought ) const
{
   CObListIter oli( *this ) ;
   CObject * pob ;

   for ( int i = 0 ;
     (pob = oli.Next()) && pob != pobSought ;
     i++ ) ;

   return pob ? i : -1 ;
}

    //  Override of CObList::AddTail() to control exception handling.
    //  Returns NULL if addition fails.

POSITION CObOwnedList :: AddTail (
    CObjectPlus * pobj,
    BOOL bThrowException )
{
    POSITION pos = NULL ;

    //  Catch only memory exceptions.
    TRY
    {
        pos = CObList::AddTail( pobj ) ;
    }
    CATCH( CMemoryException, e )
    {
        pos = NULL ;
    }
    END_CATCH

    if ( pos == NULL && bThrowException )
    {
        //  CObList::AddTail() threw an exception. Echo it.
        AfxThrowMemoryException() ;
    }
    return pos ;
}


typedef struct
{
    CObjectPlus * pObj ;            // Pointer to object to be sorted
    CObjectPlus::PCOBJPLUS_ORDER_FUNC  pFunc ;  // Pointer to ordering function
} CBOWNEDLIST_SORT_HELPER ;

    //  This static member function is used to quick sort an array of structures
    //  as declared above.  Each element contains the object pointer and a
    //  pointer to the object's member function to be invoked for comparison.

//int CDECL CObOwnedList :: SortHelper (
int _cdecl CObOwnedList :: SortHelper (
    const void * pa,
    const void * pb 
    )
{
    CBOWNEDLIST_SORT_HELPER
    * pHelp1 = (CBOWNEDLIST_SORT_HELPER *) pa,
    * pHelp2 = (CBOWNEDLIST_SORT_HELPER *) pb ;

    return (pHelp1->pObj->*pHelp1->pFunc)( pHelp2->pObj ) ;
}

    //  Sort the list by recreating it entirely.

LONG CObOwnedList :: Sort ( CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc )
{
    LONG err = 0 ;
    int cItems = (int)GetCount() ;

    if ( cItems < 2 )
    return NO_ERROR ;

    CObListIter obli( *this ) ;
    CObjectPlus * pObNext ;
    BOOL bOwned = SetOwnership( FALSE ) ;
    int i ;

    CBOWNEDLIST_SORT_HELPER * paSortHelpers = NULL ;

    CATCH_MEM_EXCEPTION
    {
    //  Allocate the helper array
    paSortHelpers = new CBOWNEDLIST_SORT_HELPER[ cItems ] ;

    /// Fill the helper array.
    for ( i = 0 ; pObNext = (CObjectPlus *) obli.Next() ; i++ )
    {
        paSortHelpers[i].pFunc = pOrderFunc ;
        paSortHelpers[i].pObj = pObNext ;
    }

    //  Release all object pointer references.  Note that we
    //  forced "owned" to FALSE above.
    RemoveAll() ;

    ASSERT( GetCount() == 0 ) ;

    //  Sort the helper array
    ::qsort( (void *) paSortHelpers,
         cItems,
         sizeof paSortHelpers[0],
         SortHelper ) ;

    //  Refill the list from the helper array.
    for ( i = 0 ; i < cItems ; i++ )
    {
        AddTail( paSortHelpers[i].pObj ) ;
    }

    ASSERT( GetCount() == cItems ) ;
    }
    END_MEM_EXCEPTION(err)

    //  Delete the working array
    delete [] paSortHelpers ;

    //  Restore the object ownership state
    SetOwnership( bOwned ) ;

    return err ;
}

//
//  Subclass of CObArray whose default behavior is to destroy
//    its contents during its own destruction
//
CObOwnedArray :: CObOwnedArray ()
    : CObArray(),
    m_b_owned( TRUE )
{
}
             
CObOwnedArray :: ~ CObOwnedArray ()
{
    RemoveAll() ;
}

void CObOwnedArray :: RemoveAll ()
{
    if ( m_b_owned )
    {
        int i, nElements;

        nElements = (int)GetSize();
        for (i = 0; i < nElements; ++i)
        {
            delete (CObject *)GetAt(i) ;
        }
    }
    //
    //  Just remove the object pointers
    //
    CObArray::RemoveAll() ;
}     



void
CObOwnedArray :: RemoveAt ( 
    int nIndex,
    int nCount
    )
{
    for (int i = 0; i < nCount; ++i)
    {
        delete (CObject *)GetAt(nIndex) ;
    }

    CObArray::RemoveAt(nIndex, nCount);
}


//
//  Set all elements to dirty or clean.  Return TRUE if
//  any element was dirty.
//
BOOL 
CObOwnedArray :: SetAll ( 
    BOOL bDirty 
    )
{
    int cDirtyItems = 0 ;
    CObjectPlus * pob ;
    int i;

    int nElements = (int)GetSize();

    for (i = 0; i < nElements; ++i)
    {
        pob = (CObjectPlus *)GetAt(i);
        cDirtyItems += pob->IsDirty() ;
        pob->SetDirty( bDirty ) ;
    }

    SetDirty( bDirty );

    return cDirtyItems > 0 ;
}


int 
CObOwnedArray :: FindElement ( 
    CObject * pobSought 
    ) const
{
    CObject * pob ;
    int i;
    int nElements = (int)GetSize();

    for ( i = 0, pob = NULL; i < nElements && pob != pobSought; ++i)
    {
        pob = (CObject *)GetAt(i);
    }

    return i < nElements ? i : -1 ;
}

void
CObOwnedArray :: Swap(
    int nIndx1,
    int nIndx2
    )
{
    CObject * pTmp = GetAt(nIndx1);
    SetAt(nIndx1, GetAt(nIndx2));
    SetAt(nIndx2, pTmp);
}

//
// This sort is pretty slow.  Why?
//

void
CObOwnedArray :: QuickSort(
    int nLow,
    int nHigh,    
    CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc 
    )
{
    int nUp, nDown;
    CObjectPlus * pBreak;

    if (nLow < nHigh)
    {
        if((nHigh - nLow) == 1) 
        {
            if (((CObjectPlus *)GetAt(nLow)->*pOrderFunc)((CObjectPlus *)GetAt(nHigh)) > 0)
            {
                Swap(nLow, nHigh);
            }
        }
        else 
        {
            pBreak = (CObjectPlus *)GetAt(nHigh);
            do 
            {
                nUp = nLow;
                nDown = nHigh;
                while(nUp < nDown && ((CObjectPlus *)GetAt(nUp)->*pOrderFunc)(pBreak) <= 0)
                {
                    ++nUp;
                }
                while(nDown > nUp && ((CObjectPlus *)GetAt(nDown)->*pOrderFunc)(pBreak) >= 0)
                {
                    --nDown;
                }
                if (nUp < nDown)
                {
                    Swap(nUp, nDown);
                }
            } while (nUp < nDown);

            Swap(nUp, nHigh);
            if ((nUp - nLow) < (nHigh - nUp) ) 
            {
                QuickSort(nLow, nUp - 1, pOrderFunc);
                QuickSort(nUp + 1, nHigh, pOrderFunc);
            }
            else 
            {
                QuickSort(nUp + 1, nHigh, pOrderFunc);
                QuickSort(nLow, nUp - 1, pOrderFunc);
            }
        }
    }
}

/*
LONG 
CObOwnedArray :: Sort ( 
    CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc 
    )
{
    LONG err = 0 ;
    int cItems = GetSize() ;

    if ( cItems < 2 )   
    {
        return NO_ERROR ;
    }
    
    QuickSort(0, GetUpperBound(), pOrderFunc);    

    return 0;
}
*/

typedef struct
{
    CObjectPlus * pObj ;            // Pointer to object to be sorted
    CObjectPlus::PCOBJPLUS_ORDER_FUNC  pFunc ;  // Pointer to ordering function
} CBOWNEDARRAY_SORT_HELPER ;

    //  This static member function is used to quick sort an array of structures
    //  as declared above.  Each element contains the object pointer and a
    //  pointer to the object's member function to be invoked for comparison.

//int CDECL CObOwnedArray :: SortHelper (
int _cdecl CObOwnedArray :: SortHelper (
    const void * pa,
    const void * pb 
    )
{
    CBOWNEDARRAY_SORT_HELPER
    * pHelp1 = (CBOWNEDARRAY_SORT_HELPER *) pa,
    * pHelp2 = (CBOWNEDARRAY_SORT_HELPER *) pb ;

    return (pHelp1->pObj->*pHelp1->pFunc)( pHelp2->pObj ) ;
}

    //  Sort the list by recreating it entirely.

LONG 
CObOwnedArray :: Sort ( 
    CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc 
    )
{
    LONG err = 0 ;
    int cItems = (int)GetSize() ;

    if ( cItems < 2 )
    {
        return NO_ERROR ;
    }

    CObjectPlus * pObNext ;
    BOOL bOwned = SetOwnership( FALSE ) ;
    int i ;

    CBOWNEDARRAY_SORT_HELPER * paSortHelpers = NULL ;

    CATCH_MEM_EXCEPTION
    {
        //  Allocate the helper array
        paSortHelpers = new CBOWNEDARRAY_SORT_HELPER[ cItems ] ;

        /// Fill the helper array.
        for ( i = 0 ; i < cItems ; ++i )
        {
            pObNext = (CObjectPlus *) GetAt(i);
            paSortHelpers[i].pFunc = pOrderFunc ;
            paSortHelpers[i].pObj = pObNext ;
        }

        //  Release all object pointer references.  Note that we
        //  forced "owned" to FALSE above.
        RemoveAll() ;

        ASSERT( GetSize() == 0 ) ;

        //  Sort the helper array
        ::qsort( (void *) paSortHelpers,
             cItems,
            sizeof paSortHelpers[0],
            SortHelper ) ;

        //  Refill the list from the helper array.
        for ( i = 0 ; i < cItems ; i++ )
        {
            Add( paSortHelpers[i].pObj ) ;
        }

        ASSERT( GetSize() == cItems ) ;
    }
    END_MEM_EXCEPTION(err)

    //  Delete the working array
    delete [] paSortHelpers ;

    //  Restore the object ownership state
    SetOwnership( bOwned ) ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\queryobj.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    queryobj.h
        Implementation for the background thread and query objects

    FILE HISTORY:
        
*/

#ifndef _QUERYOBJ_H
#define _QUERYOBJ_H

#ifndef _TFSINT_H
#include <tfsint.h>
#endif

#define IMPL

// NOTE:  Do not define any data types of this value.  This range is reservered
// for internal values for ITFSNode pointers.
#define QDATA_PNODE		0xabcdef29
#define QDATA_TIMER     0xabcdef2a

typedef struct QueueData_tag
{
	LPARAM Data;
	LPARAM Type;
}
QUEUEDATA, * LPQUEUEDATA;

class CBackgroundThread;
class CQueryObject;

//////////////////////////////////////////////////////////////////////
//
// CBackgroundThread
//
//////////////////////////////////////////////////////////////////////
class CBackgroundThread : public CWinThread
{
public:
	CBackgroundThread();
	virtual ~CBackgroundThread();
	
	void	SetQueryObj(ITFSQueryObject* pQuery);
	BOOL	Start();
	
	virtual BOOL InitInstance() { return TRUE; }	// MFC override
	virtual int Run();								// MFC override

	void	Lock() { ::EnterCriticalSection(&m_cs); }
	void	Unlock() { ::LeaveCriticalSection(&m_cs); }

private:
	CRITICAL_SECTION	m_cs;	// critical section to sync access to data

	SPITFSQueryObject	m_spQuery;
};


/*---------------------------------------------------------------------------
	Class:	CQueryObj

	This is the generic query object.  If you want to do something real
	with this, derive a class from this and do it yourself.
 ---------------------------------------------------------------------------*/

class CQueryObject :
    public ITFSQueryObject
{
public:
	CQueryObject();
	virtual ~CQueryObject();

	DeclareIUnknownMembers(IMPL)
	DeclareITFSQueryObjectMembers(IMPL)

protected:
	// Query objects will now have to perform the locking
	// functions themselves
	void Lock()	{ ::EnterCriticalSection(&m_cs); }
	void Unlock() { ::LeaveCriticalSection(&m_cs); }

	CRITICAL_SECTION	m_cs;
	HANDLE				m_hEventAbort;
	LONG				m_cRef;

	SPITFSThreadHandler	m_spHandler;
	SPITFSQueryObject	m_spQuery;

	HWND				m_hHiddenWnd;
	UINT				m_uMsgBase;
};


//////////////////////////////////////////////////////////////////////
//
// CNodeList 
// collection of nodes
//
//////////////////////////////////////////////////////////////////////
typedef CList<LPQUEUEDATA, LPQUEUEDATA> CQueueDataListBase;
typedef CList<ITFSNode *, ITFSNode *> CNodeListBase;

class CNodeList : public CNodeListBase
{
public:
	BOOL RemoveNode(ITFSNode* p)
	{
		POSITION pos = Find(p);
		if (pos == NULL)
			return FALSE;
		RemoveAt(pos);
		return TRUE;
	}
	void DeleteAllNodes() 
	{	
		while (!IsEmpty()) 
			RemoveTail()->Release();
	}
	BOOL HasNode(ITFSNode* p)
	{
		return NULL != Find(p);
	}
};

/*---------------------------------------------------------------------------
	Class:	CNodeQueryObject
 ---------------------------------------------------------------------------*/
class CNodeQueryObject : public CQueryObject
{
public:
	CNodeQueryObject() { m_nQueueCountMax = 1; } // default to notification on 
												 // every item enumed from thread
	virtual ~CNodeQueryObject();
	BOOL AddToQueue(ITFSNode* pNode);
	BOOL AddToQueue(LPARAM Data, LPARAM Type);

	LPQUEUEDATA RemoveFromQueue();
	BOOL IsQueueEmpty();
	BOOL IsQueueFull();
	
	STDMETHOD(OnThreadExit)();
	STDMETHOD(OnEventAbort());
	STDMETHOD(DoCleanup());

	BOOL	PostHaveData(LPARAM lParam);	
	BOOL	PostError(DWORD dwErr);
	virtual void OnEventAbort(LPARAM Data, LPARAM Type) { };

private:
	// communication with ComponentData object 
	BOOL PostMessageToComponentData(UINT uMsg, LPARAM lParam);

protected:
	int					m_nQueueCountMax;
	CQueueDataListBase	m_dataQueue;
};

/*---------------------------------------------------------------------------
	Class:	CNodeQueryObject
 ---------------------------------------------------------------------------*/
class CNodeTimerQueryObject : public CNodeQueryObject
{
public:
	virtual ~CNodeTimerQueryObject() { };

    STDMETHOD (Execute)(void);

    void    SetTimerInterval(DWORD dwTimerInterval) { m_dwTimerInterval = dwTimerInterval; }
    DWORD   GetTimerInterval() { return m_dwTimerInterval; }

private:

protected:
    DWORD   m_dwTimerInterval;
};

/*---------------------------------------------------------------------------
	Inlined functions
 ---------------------------------------------------------------------------*/

inline BOOL CNodeQueryObject::PostHaveData(LPARAM lParam)
{
	return PostMessageToComponentData(WM_HIDDENWND_INDEX_HAVEDATA, lParam);
}

inline BOOL CNodeQueryObject::PostError(DWORD dwErr)
{
	return PostMessageToComponentData(WM_HIDDENWND_INDEX_ERROR, dwErr);
}

inline STDMETHODIMP CQueryObject::Execute()
{
	return hrFalse;
}

// This function is called when the thread exits, this gives
// the query object a last chance to send a data notification
// to the node
inline STDMETHODIMP CQueryObject::OnThreadExit()
{
	return hrOK;
}

inline HANDLE CQueryObject::GetAbortEventHandle()
{
	return m_hEventAbort;
}

inline STDMETHODIMP CQueryObject::OnEventAbort()
{
	return hrOK;
}

inline STDMETHODIMP CQueryObject::DoCleanup()
{
	return hrOK;
}
	

#endif _QUERYOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\proppage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    proppage.cpp
        Implementation for property pages in MMC

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dialog.h"   // for FixupIpAddressHelp

#include <prsht.h>

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif


//////////////////////////////////////////////////////////////////////////
// private helper functions

BOOL CALLBACK EnumThreadWndProc(HWND hwnd, /* enumerated HWND */
								LPARAM lParam /* pass a HWND* for return value*/ )
{
	Assert(hwnd);
	HWND hParentWnd = GetParent(hwnd);
	// the main window of the MMC console should staitsfy this condition
	if ( ((hParentWnd == GetDesktopWindow()) || (hParentWnd == NULL))  && IsWindowVisible(hwnd) )
	{
		HWND* pH = (HWND*)lParam;
		*pH = hwnd;
		return FALSE; // stop enumerating
	}
	else if(hParentWnd)
	{
		HWND	hGrandParentWnd = GetParent(hParentWnd);
		// the main window of the MMC console should staitsfy this condition
		if ( ((hGrandParentWnd == GetDesktopWindow()) || (hGrandParentWnd == NULL))  && IsWindowVisible(hParentWnd) )
		{
			HWND* pH = (HWND*)lParam;
			*pH = hParentWnd;
			return FALSE; // stop enumerating
		}
	}
	return TRUE;
}
 


HWND FindMMCMainWindow()
{
	DWORD dwThreadID = ::GetCurrentThreadId();
	Assert(dwThreadID != 0);
	HWND hWnd = NULL;
	BOOL bEnum = EnumThreadWindows(dwThreadID, EnumThreadWndProc,(LPARAM)&hWnd);
	Assert(hWnd != NULL);
	return hWnd;
}


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderBase

CPropertyPageHolderBase::CPropertyPageHolderBase
(
	ITFSNode *		pNode,
	IComponentData *pComponentData,
	LPCTSTR			pszSheetName,
	BOOL			bIsScopePane
)
{
	m_stSheetTitle = pszSheetName;

	// default setting for a self deleting modeless property sheet,
	// automatically deleting all the pages
	m_bWizardMode = TRUE;
	m_bAutoDelete = TRUE;
	m_bAutoDeletePages = TRUE;

	m_nCreatedCount = 0; 
	m_hSheetWindow = NULL;
	m_hConsoleHandle = 0; 
	m_hEventHandle = NULL;
	m_bCalledFromConsole = FALSE;

	m_cDirty = 0;

	// setup from arguments
	SetNode(pNode);
	
	//Assert(pComponentData != NULL);
	m_spComponentData.Set(pComponentData);

	m_pPropChangePage = NULL;
	m_dwLastErr = 0;

    m_bSheetPosSet = FALSE;

    m_bIsScopePane = bIsScopePane;
	m_hThread = NULL;

    m_bWiz97 = FALSE;

	// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
    m_bPeekMessageDuringNotifyConsole = FALSE;
	m_fSetDefaultSheetPos = TRUE;
}

CPropertyPageHolderBase::CPropertyPageHolderBase
(
	ITFSNode *		pNode,
	IComponent *    pComponent,
	LPCTSTR			pszSheetName,
	BOOL			bIsScopePane
)
{
	m_stSheetTitle = pszSheetName;

	// default setting for a self deleting modeless property sheet,
	// automatically deleting all the pages
	m_bWizardMode = TRUE;
	m_bAutoDelete = TRUE;
	m_bAutoDeletePages = TRUE;

	m_nCreatedCount = 0; 
	m_hSheetWindow = NULL;
	m_hConsoleHandle = 0; 
	m_hEventHandle = NULL;
	m_bCalledFromConsole = FALSE;

	m_cDirty = 0;

	// setup from arguments
	SetNode(pNode);
	
	m_spComponent.Set(pComponent);

	m_pPropChangePage = NULL;
	m_dwLastErr = 0;

    m_bSheetPosSet = FALSE;

    m_bIsScopePane = bIsScopePane;
	m_hThread = NULL;

    m_bWiz97 = FALSE;

	// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
    m_bPeekMessageDuringNotifyConsole = FALSE;
}

CPropertyPageHolderBase::~CPropertyPageHolderBase()
{
// Remove this assert, we could be dirty if we cancelled the page
//	Assert(m_cDirty == 0);
	FinalDestruct();
	m_spSheetCallback.Release();
	if (m_hEventHandle != NULL)
	{
		VERIFY(::CloseHandle(m_hEventHandle));
		m_hEventHandle = NULL;
	}
}


HRESULT 
CPropertyPageHolderBase::CreateModelessSheet
(
	LPPROPERTYSHEETCALLBACK pSheetCallback, 
	LONG_PTR				hConsoleHandle
)
{
	Assert(pSheetCallback != NULL);
	Assert(m_spSheetCallback == NULL);

	Assert( (hConsoleHandle  != NULL) && (m_hConsoleHandle == NULL) );
	m_hConsoleHandle = hConsoleHandle;

	m_bCalledFromConsole = TRUE;
	m_bWizardMode = FALSE; // we go modeless
	
	// notify the node it has a sheet up
	int nMessage = m_bIsScopePane ? TFS_NOTIFY_CREATEPROPSHEET : 
									TFS_NOTIFY_RESULT_CREATEPROPSHEET;
	if (m_spNode)
		m_spNode->Notify(nMessage, (LPARAM) this);

	// temporarily attach the sheet callback to this object to add pages
	// do not addref, we will not hold on to it;
	m_spSheetCallback = pSheetCallback;
	
	HRESULT hr = AddAllPagesToSheet();
	m_spSheetCallback.Transfer(); // detach
	return hr;
}

HRESULT 
CPropertyPageHolderBase::DoModelessSheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIPropertySheetProvider	spSheetProvider;
	SPIPropertySheetCallback	spSheetCallback;
	SPIConsole					spConsole;
	SPIDataObject				spDataObject;
	MMC_COOKIE						cookie;
	HRESULT						hr = hrOK;
	HWND						hWnd;
	int							nMessage;

	m_bWizardMode = FALSE;

	// get an interface to a sheet provider
    CORg (::CoCreateInstance(CLSID_NodeManager, NULL, CLSCTX_INPROC, 
           IID_IPropertySheetProvider, reinterpret_cast<void **>(&spSheetProvider)));
    
    Assert(spSheetProvider != NULL);

	// get an interface to a sheet callback
	CORg( spSheetCallback.HrQuery(spSheetProvider) );
	
    Assert(spSheetCallback != NULL);

	m_spSheetCallback.Set(spSheetCallback); // save to add/remove pages
	
	// create a data object for this node
	cookie = m_spNode->GetData(TFS_DATA_COOKIE);

    if (m_bIsScopePane)
    {
	    CORg( m_spComponentData->QueryDataObject(cookie, CCT_SCOPE, &spDataObject) );
	    Assert(spDataObject != NULL);
    }
    else
    {
	    CORg( m_spComponent->QueryDataObject(cookie, CCT_RESULT, &spDataObject) );
	    Assert(spDataObject != NULL);
    }

	// create sheet
    // CODEWORK: ericdav -- need to possible set options flag -- 0 for now
    CORg( spSheetProvider->CreatePropertySheet(m_stSheetTitle,
								TRUE /* prop page */, cookie, spDataObject, 0) );

	// add pages to sheet
	CORg( AddAllPagesToSheet() );

	// add pages
	// HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle,
	//				HWND hNotifyWindow, BOOL bScopePane);
	if (m_bIsScopePane)
    {
        //Assert(m_spComponentData != NULL);
        CORg( spSheetProvider->AddPrimaryPages(NULL, FALSE, NULL, TRUE) );
    }
    else
    {
        //Assert(m_spComponent != NULL);
        CORg( spSheetProvider->AddPrimaryPages(NULL, FALSE, NULL, FALSE) );
    }

	spSheetProvider->AddExtensionPages();
	
	// for further dynamic page manipulation, don't use the Console's
	// sheet callback interface but resurt to the Win32 API's
	m_spSheetCallback.Release();
	
	hWnd = ::FindMMCMainWindow();
	Assert(hWnd != NULL);
	
    CORg( spSheetProvider->Show((LONG_PTR) hWnd, 0) );

    // notify the node it has a sheet up
	nMessage = m_bIsScopePane ? TFS_NOTIFY_CREATEPROPSHEET : 
								TFS_NOTIFY_RESULT_CREATEPROPSHEET;
	m_spNode->Notify(nMessage, (LPARAM) this);

Error:
	return hr;
}

// use this function for property pages on the scope pane
HRESULT DoPropertiesOurselvesSinceMMCSucks(ITFSNode *       pNode,
										   IComponentData * pComponentData,
										   LPCTSTR	        pszSheetTitle)
{
	Assert(pComponentData != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIPropertySheetProvider	spSheetProvider;
	SPIDataObject				spDataObject;
	MMC_COOKIE						cookie;
	HRESULT						hr = hrOK;
	HWND						hWnd = NULL;

	// get an interface to a sheet provider
    CORg (::CoCreateInstance(CLSID_NodeManager, NULL, CLSCTX_INPROC, 
           IID_IPropertySheetProvider, reinterpret_cast<void **>(&spSheetProvider)));
    Assert(spSheetProvider != NULL);

	// create a data object for this node
    cookie = pNode->GetData(TFS_DATA_COOKIE);
	CORg( pComponentData->QueryDataObject(cookie, CCT_SCOPE, &spDataObject) );
	Assert(spDataObject != NULL);

	// create sheet
    // CODEWORK: ericdav -- need to possible set options flag -- 0 for now
    CORg( spSheetProvider->CreatePropertySheet(pszSheetTitle,
								TRUE /* prop page */, cookie, spDataObject, 0) );

	// add pages
	// HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle,
	//				HWND hNotifyWindow, BOOL bScopePane);
	// This needs to be fixed.  Right now it only works if there is 
    // one view of the snapin.
    //
    // As of 5/21/99, we no longer need to do this.
    // ----------------------------------------------------------------
    // hWnd = ::FindMMCMainWindow();
    // hWnd = ::FindWindowEx(hWnd, NULL, L"MDIClient", NULL); 
    // hWnd = ::FindWindowEx(hWnd, NULL, L"MMCChildFrm", NULL); 
    // hWnd = ::FindWindowEx(hWnd, NULL, L"MMCView", NULL); 
    // Assert(hWnd != NULL);

	CORg( spSheetProvider->AddPrimaryPages(pComponentData, TRUE, hWnd, TRUE) );

	spSheetProvider->AddExtensionPages();

    CORg( spSheetProvider->Show((LONG_PTR) hWnd, 0) );

Error:
	return hr;
}

// Use this function for property pages on the result pane
HRESULT DoPropertiesOurselvesSinceMMCSucks(ITFSNode *   pNode,
										   IComponent * pComponent,
										   LPCTSTR	    pszSheetTitle,
                                           int          nVirtualIndex)
{
	Assert(pComponent != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIPropertySheetProvider	spSheetProvider;
	SPIDataObject				spDataObject;
	MMC_COOKIE						cookie;
	HRESULT						hr = hrOK;
	HWND						hWnd;

	// get an interface to a sheet provider
    CORg (::CoCreateInstance(CLSID_NodeManager, NULL, CLSCTX_INPROC, 
           IID_IPropertySheetProvider, reinterpret_cast<void **>(&spSheetProvider)));
    Assert(spSheetProvider != NULL);

	// create a data object for this node
	if (nVirtualIndex == -1)
    {
        cookie = pNode->GetData(TFS_DATA_COOKIE);
    }
    else
    {
        cookie = nVirtualIndex;
    }

	CORg( pComponent->QueryDataObject(cookie, CCT_RESULT, &spDataObject) );
	Assert(spDataObject != NULL);

	// create sheet
    // CODEWORK: ericdav -- need to possible set options flag -- 0 for now
    CORg( spSheetProvider->CreatePropertySheet(pszSheetTitle,
								TRUE /* prop page */, cookie, spDataObject, 0) );

	// add pages
	// HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle,
	//				HWND hNotifyWindow, BOOL bScopePane);
	// This needs to be fixed.  Right now it only works if there is 
    // one view of the snapin.
    hWnd = ::FindMMCMainWindow();
	hWnd = ::FindWindowEx(hWnd, NULL, L"MDIClient", NULL); 
	hWnd = ::FindWindowEx(hWnd, NULL, L"MMCChildFrm", NULL); 
	hWnd = ::FindWindowEx(hWnd, NULL, L"MMCView", NULL); 
	Assert(hWnd != NULL);

	CORg( spSheetProvider->AddPrimaryPages(pComponent, TRUE, hWnd, FALSE) );

	spSheetProvider->AddExtensionPages();

    CORg( spSheetProvider->Show((LONG_PTR) hWnd, 0) );

Error:
	return hr;
}


HRESULT 
CPropertyPageHolderBase::DoModalWizard()
{
	Assert(m_spComponentData != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIPropertySheetProvider	spSheetProvider;
	SPITFSComponentData			spTFSCompData;
	SPIConsole					spConsole;
	SPIPropertySheetCallback	spSheetCallback;
	SPIDataObject				spDataObject;
	HRESULT						hr = hrOK;
	HWND						hWnd;
	MMC_COOKIE					cookie;
    DWORD                       dwOptions = 0;

	m_bWizardMode = TRUE;

	CORg( spTFSCompData.HrQuery(m_spComponentData) );
	CORg( spTFSCompData->GetConsole(&spConsole) );

	// get an interface to a sheet provider
	CORg( spSheetProvider.HrQuery(spConsole) );
	Assert(spSheetProvider != NULL);

	// get an interface to a sheet callback
	CORg( spSheetCallback.HrQuery(spConsole) );
	Assert(spSheetCallback != NULL);

	m_spSheetCallback.Set(spSheetCallback); // save to add/remove pages

	// create a data object for this node
	cookie = m_spNode->GetData(TFS_DATA_COOKIE);
	
	// Create a dummy data object. AddPrimaryPages will call 
	// IextendPropertySheet2::QueryPagesFor() and
	// IextendPropertySheet2::CreatePropertyPages()
	// that will ignore the un-initialized data object
    CORg( m_spComponentData->QueryDataObject(-1, CCT_UNINITIALIZED, &spDataObject) );
	Assert(spDataObject != NULL);

	// create sheet
    dwOptions = (m_bWiz97) ? MMC_PSO_NEWWIZARDTYPE : 0;
    dwOptions &= ~PSH_WIZARDCONTEXTHELP;

    CORg( spSheetProvider->CreatePropertySheet( m_stSheetTitle, FALSE /* wizard*/, cookie, spDataObject, dwOptions) );

	// add pages to sheet
	CORg( AddAllPagesToSheet() );

	// add pages
	// HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle, HWND hNotifyWindow, BOOL bScopePane);
	if (m_bWiz97)
        CORg( spSheetProvider->AddPrimaryPages(spTFSCompData, FALSE, NULL, FALSE) );
    else
        CORg( spSheetProvider->AddPrimaryPages(NULL, FALSE, NULL, FALSE) );


	// for further dynamic page manipulation, don't use the Console's sheet callback interface
	// but resurt to the Win32 API's
	m_spSheetCallback.Release();

	//hWnd = ::FindMMCMainWindow();
    // To Support scripting of the MMC console, we need to get the parent from either the
    // active window or the desktop...
    hWnd = ::GetActiveWindow();
    if (hWnd == NULL)
    {
        hWnd = GetDesktopWindow();
    }

	Assert(hWnd != NULL);
	CORg( spSheetProvider->Show((LONG_PTR)hWnd, 0) );
	
Error:
	return hr;
}


void 
CPropertyPageHolderBase::SetSheetWindow
(
	HWND hSheetWindow
)
{
	Assert(hSheetWindow != NULL);
	Assert( (m_hSheetWindow == NULL) || ((m_hSheetWindow == hSheetWindow)) );
	m_hSheetWindow = hSheetWindow;

	if (!m_hThread)
	{
		HANDLE hPseudohandle;
		
		hPseudohandle = GetCurrentThread();
		BOOL bRet = DuplicateHandle(GetCurrentProcess(), 
									 hPseudohandle,
									 GetCurrentProcess(),
									 &m_hThread,
									 0,
									 FALSE,
									 DUPLICATE_SAME_ACCESS);
		if (!bRet)
		{
			DWORD dwLastErr = GetLastError();
		}

		Trace1("PROPERTY PAGE HOLDER BASE - Thread ID = %lx\n", GetCurrentThreadId());
	}

    if (m_hSheetWindow && m_fSetDefaultSheetPos)
        SetDefaultSheetPos();

    // turn of context sensitive help in the wizard... for some reason
    // mmc turns it on and we don't want it
    if (m_bWizardMode && m_hSheetWindow)
    {
        CWnd * pWnd = CWnd::FromHandle(m_hSheetWindow);

        if (pWnd)
            pWnd->ModifyStyleEx(WS_EX_CONTEXTHELP, 0, 0);
    }
}

BOOL
CPropertyPageHolderBase::SetDefaultSheetPos() 
{
    HRESULT                 hr = hrOK;
    HWND                    hwndMMC;
    RECT                    rectSheet, rectMMC, rectWorkArea;
	SPITFSComponentData	    spTFSCompData;
	SPITFSComponent	        spTFSComponent;
	SPIConsole				spConsole;

    int nX, nY;

    if (m_bSheetPosSet)
        return TRUE;

	if (m_bIsScopePane)
    {
        CORg( spTFSCompData.HrQuery(m_spComponentData) );
    	Assert(spTFSCompData);
    	CORg( spTFSCompData->GetConsole(&spConsole) );
    }
    else
    {
        CORg( spTFSComponent.HrQuery(m_spComponent) );
    	Assert(spTFSComponent);
    	CORg( spTFSComponent->GetConsole(&spConsole) );
    }

    spConsole->GetMainWindow(&hwndMMC);
    
    // get the MMC window and the PropSheet
    if (!GetWindowRect(hwndMMC, &rectMMC))
        return FALSE;

    if (!GetWindowRect(m_hSheetWindow, &rectSheet))
        return FALSE;

    nX = rectMMC.left + (((rectMMC.right - rectMMC.left) - (rectSheet.right - rectSheet.left)) / 2);
    nY = rectMMC.top + (((rectMMC.bottom - rectMMC.top) - (rectSheet.bottom - rectSheet.top)) / 2);
    
    // now check to make sure we're visible
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0);
    
    nX = (nX < 0) ? 1 : nX;
    nY = (nY < 0) ? 1 : nY;

    nX = (nX > (rectWorkArea.right - (rectSheet.right - rectSheet.left))) ? 
        (rectWorkArea.right - (rectSheet.right - rectSheet.left)) :
        nX;

    nY = (nY > (rectWorkArea.bottom - (rectSheet.bottom - rectSheet.top))) ? 
        (rectWorkArea.bottom - (rectSheet.bottom - rectSheet.top)) :
        nY;

    if (!SetWindowPos(m_hSheetWindow, HWND_TOP, nX, nY, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW))
        return FALSE;

    m_bSheetPosSet = TRUE;

Error:
    return hr == hrOK;
}

void 
CPropertyPageHolderBase::Release() 
{ 
	m_nCreatedCount--; 
	if ( m_bAutoDelete && (m_nCreatedCount == 0) )
		delete this;
}

void 
CPropertyPageHolderBase::ForceDestroy()
{
	Assert(!m_bWizardMode); // should never occur on modal wizard
	Assert(m_bAutoDelete); // should be self deleting sheet

	Assert(::IsWindow(m_hSheetWindow));

	HWND hSheetWindow = m_hSheetWindow;
	if (hSheetWindow != NULL)
	{
		// this message will cause the sheet to close all the pages,
		// and eventually the destruction of "this"
		VERIFY(::PostMessage(hSheetWindow, WM_COMMAND, IDCANCEL, 0L) != 0);
		//VERIFY(::SendMessage(hSheetWindow, WM_CLOSE, 0, 0) == 0);
	}
    else
	{
		// explicitely delete "this", there is no sheet created
		delete this;
        return;
	}

    // now, if we've been initialized then wait for the property sheet thread
    // to terminate.  The property sheet provider is holding onto our dataobject
    // that needs to be freed up before we can continue our cleanup.  Also,
    // the cleanup does a sendmessage which will block if we don't forward 
    // messages along.
    if (m_hThread)
    {
	    DWORD dwRet;
	    MSG msg;

	    while(1)
	    {
		    dwRet = MsgWaitForMultipleObjects(1, &m_hThread, FALSE, INFINITE, QS_ALLINPUT);

		    if (dwRet == WAIT_OBJECT_0)
			    return;    // The event was signaled

		    if (dwRet != WAIT_OBJECT_0 + 1)
			    break;          // Something else happened

		    // There is one or more window message available. Dispatch them
		    while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		    {
			    TranslateMessage(&msg);
			    DispatchMessage(&msg);
			    if (WaitForSingleObject(m_hThread, 0) == WAIT_OBJECT_0)
				    return; // Event is now signaled.
		    }
	    }
    }       
}

DWORD 
CPropertyPageHolderBase::NotifyConsole(CPropertyPageBase* pPage)
{
    MSG msg;

	Assert(m_spNode != NULL);
	if (m_bWizardMode)
	{
		Assert(m_hConsoleHandle == NULL);
		return 0;
	}
	
	m_pPropChangePage = pPage; // to pass to the main thread
	m_dwLastErr = 0x0;

	Assert(m_hConsoleHandle != NULL);
	if (m_hEventHandle == NULL)
	{
		m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
		Assert(m_hEventHandle != NULL);
	}
	
    MMCPropertyChangeNotify(m_hConsoleHandle, reinterpret_cast<LONG_PTR>(this));
	
    Trace0("before wait\n");
	while ( WAIT_OBJECT_0 != ::WaitForSingleObject(m_hEventHandle, 500) ) 
	{
		
		// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
		if(m_bPeekMessageDuringNotifyConsole) 
		{	
	        // clean out the message queue while we wait
    	    while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		}
	}

	Trace0("after wait\n");
	VERIFY(0 != ::ResetEvent(m_hEventHandle));

	return m_dwLastErr;
}

void 
CPropertyPageHolderBase::AcknowledgeNotify()
{
	Assert(!m_bWizardMode);
	Assert(m_hEventHandle != NULL);
	Trace0("before SetEvent\n");
	VERIFY(0 != ::SetEvent(m_hEventHandle));
	Trace0("after SetEvent\n");
}


BOOL 
CPropertyPageHolderBase::SetWizardButtons
(
	DWORD dwFlags
)
{
	Assert(m_bWizardMode);
	Assert(::IsWindow(m_hSheetWindow));
	return (BOOL)SendMessage(m_hSheetWindow, PSM_SETWIZBUTTONS, 0, dwFlags);
}

BOOL
CPropertyPageHolderBase::PressButton
(
    int nButton
)
{
    Assert(m_bWizardMode);
    Assert(::IsWindow(m_hSheetWindow));
    return (BOOL) SendMessage(m_hSheetWindow, PSM_PRESSBUTTON, nButton, 0);
}

HRESULT 
CPropertyPageHolderBase::AddPageToSheet
(
	CPropertyPageBase* pPage
)
{
	// remove the help button
	if (m_bWiz97)
        pPage->m_psp97.dwFlags &= ~PSP_HASHELP;
    else
        pPage->m_psp.dwFlags &= ~PSP_HASHELP;

	// call the MMC function because we are using MFC based pages
	if (!m_bWizardMode)
	{
		// if we are doing a property sheet then tell MMC to hook
		// the proc because we are running on a separate, non MFC thread.
		// Wizards don't run on a separate thread and therefore
		// don't need to make this call.
		if (m_bWiz97)
           VERIFY(SUCCEEDED(MMCPropPageCallback(&pPage->m_psp97)));
        else
           VERIFY(SUCCEEDED(MMCPropPageCallback(&pPage->m_psp)));
	}

	HPROPSHEETPAGE hPage;

    if (m_bWiz97)
        hPage = ::CreatePropertySheetPage(&pPage->m_psp97);
    else
        hPage = ::CreatePropertySheetPage(&pPage->m_psp);

	if (hPage == NULL)
		return E_UNEXPECTED;
	pPage->m_hPage = hPage;

	if (m_spSheetCallback != NULL)
		return m_spSheetCallback->AddPage(hPage);
	else
	{
		Assert(::IsWindow(m_hSheetWindow));
		return PropSheet_AddPage(m_hSheetWindow, hPage) ? S_OK : E_FAIL;
	}
}

HRESULT 
CPropertyPageHolderBase::RemovePageFromSheet
(
	CPropertyPageBase* pPage
)
{
	Assert(pPage->m_hPage != NULL);
	if (m_spSheetCallback != NULL)
		return m_spSheetCallback->RemovePage(pPage->m_hPage);
	else
	{
		Assert(::IsWindow(m_hSheetWindow));
		return PropSheet_RemovePage(m_hSheetWindow, 0, pPage->m_hPage) ? S_OK : E_FAIL;
	}
}


HRESULT 
CPropertyPageHolderBase::AddAllPagesToSheet()
{
	POSITION pos;
	for( pos = m_pageList.GetHeadPosition(); pos != NULL; )
	{
		CPropertyPageBase* pPropPage = m_pageList.GetNext(pos);
		HRESULT hr = AddPageToSheet(pPropPage);
		Assert(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
	}
	return S_OK;
}


void 
CPropertyPageHolderBase::AddPageToList
(
	CPropertyPageBase* pPage
)
{
	Assert(pPage != NULL);
	pPage->SetHolder(this);
	m_pageList.AddTail(pPage);
}

BOOL 
CPropertyPageHolderBase::RemovePageFromList
(
	CPropertyPageBase*	pPage, 
	BOOL				bDeleteObject
)
{
	Assert(pPage != NULL);
	POSITION pos = m_pageList.Find(pPage);
	if (pos == NULL)
		return FALSE;
	m_pageList.RemoveAt(pos);
	if (bDeleteObject)
		delete pPage;
	return TRUE;
}


void 
CPropertyPageHolderBase::DeleteAllPages()
{
	if (!m_bAutoDeletePages)
		return;
	// assume all pages out of the heap
	while (!m_pageList.IsEmpty())
	{
		delete m_pageList.RemoveTail();
	}
}

void 
CPropertyPageHolderBase::FinalDestruct()
{
	DeleteAllPages();
	if (m_bWizardMode)
		return;

	// if we were a modeless sheet, have to cleanup
	if (m_bCalledFromConsole)
	{
		Assert(m_hConsoleHandle != NULL);
		MMCFreeNotifyHandle(m_hConsoleHandle);

	}

	// Notify the node that this sheet is going away
	//
	int nMessage = m_bIsScopePane ? TFS_NOTIFY_DELETEPROPSHEET : 
									TFS_NOTIFY_RESULT_DELETEPROPSHEET;
	if (m_spNode)
	{
		m_spNode->Notify(nMessage, (LPARAM) this);
	}
}

HWND
CPropertyPageHolderBase::SetActiveWindow()
{
	return ::SetActiveWindow(m_hSheetWindow);
}

BOOL CPropertyPageHolderBase::OnPropertyChange(BOOL bScopePane, LONG_PTR * pChangeMask)
{ 
	ASSERT(!IsWizardMode());
	CPropertyPageBase* pPage = GetPropChangePage();
	if (pPage == NULL)
		return FALSE;
	return pPage->OnPropertyChange(bScopePane, pChangeMask);
}

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageBase

IMPLEMENT_DYNCREATE(CPropertyPageBase, CPropertyPage)

BEGIN_MESSAGE_MAP(CPropertyPageBase, CPropertyPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
// help overrides
    ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()


CPropertyPageBase::CPropertyPageBase
(
	UINT nIDTemplate, 
	UINT nIDCaption
) :	CPropertyPage(nIDTemplate, nIDCaption)
{
	m_hPage = NULL;
	m_pPageHolder = NULL;
	m_bIsDirty = FALSE;
}


CPropertyPageBase::~CPropertyPageBase()
{

}

int 
CPropertyPageBase::OnCreate
(
	LPCREATESTRUCT lpCreateStruct
)	
{
    if (m_pPageHolder)
        m_pPageHolder->AddRef();
	
    int res = CPropertyPage::OnCreate(lpCreateStruct);
	Assert(res == 0);
	Assert(m_hWnd != NULL);
	Assert(::IsWindow(m_hWnd));
	
    HWND hParent = ::GetParent(m_hWnd);
	Assert(hParent);
	
    if (m_pPageHolder)
        m_pPageHolder->SetSheetWindow(hParent);
	
    return res;
}

void 
CPropertyPageBase::OnDestroy() 
{
	Assert(m_hWnd != NULL);
    
    CPropertyPage::OnDestroy();
	
    if (m_pPageHolder)
        m_pPageHolder->Release();
}

BOOL 
CPropertyPageBase::OnApply()
{
	if (IsDirty())
	{
        if (!m_pPageHolder ||
            m_pPageHolder->NotifyConsole(this) == 0x0)
		{
			SetDirty(FALSE);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	
	return TRUE;
}

void CPropertyPageBase::CancelApply()
{
	if (m_pPageHolder)
		m_pPageHolder->NotifyConsole(this);
}

// NOTE:  This function must be called for all wizard 97 pages.
//        Since there are different sizes of the psp struct, depending
//        on how the project was compiled (common lib is compiled with 
//        the wiz97 propsheet header and the snapin directory may not)
//        this function should only be called when running wizard 97 pages.
//        This allows us to have snapins that use the same code for both
//        old and new style wizards.
void CPropertyPageBase::InitWiz97(BOOL bHideHeader, 
								  UINT nIDHeaderTitle, 
								  UINT nIDHeaderSubTitle)
{
    // hack to have new struct size with old MFC and new NT 5.0 headers
    ZeroMemory(&m_psp97, sizeof(PROPSHEETPAGE));
	memcpy(&m_psp97, &m_psp, m_psp.dwSize);
	m_psp97.dwSize = sizeof(PROPSHEETPAGE);

    if (bHideHeader)
	{
		// for first and last page of the wizard
		m_psp97.dwFlags |= PSP_HIDEHEADER;
	}
	else
	{
		// for intermediate pages
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

        m_szHeaderTitle.LoadString(nIDHeaderTitle);
		m_szHeaderSubTitle.LoadString(nIDHeaderSubTitle);

		m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
		m_psp97.pszHeaderTitle = (LPCTSTR)m_szHeaderTitle;
		m_psp97.pszHeaderSubTitle = (LPCTSTR)m_szHeaderSubTitle;
	}
}

/*!--------------------------------------------------------------------------
	CPropertyPageBase::OnHelpInfo
		Brings up the context-sensitive help for the controls.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL CPropertyPageBase::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	int		i;
	DWORD	dwCtrlId;

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		DWORD * pdwHelp = GetHelpMapInternal();

        if (pdwHelp)
        {
		    // Ok to fix the f**king help for the f**king IP address
		    // controls, we will need to add special case code.  If we
		    // can't find the id of our control in our list, then we look
		    // to see if this is the child of the "RtrIpAddress" control, if
		    // so then we change the pHelpInfo->hItemHandle to point to the
		    // handle of the ip address control rather than the control in
		    // the ip addrss control.  *SIGH*
		    dwCtrlId = ::GetDlgCtrlID((HWND) pHelpInfo->hItemHandle);
		    for (i=0; pdwHelp[i]; i+=2)
		    {
			    if (pdwHelp[i] == dwCtrlId)
				    break;
		    }

		    if (pdwHelp[i] == 0)
		    {
			    // Ok, we didn't find the control in our list, so let's
			    // check to see if it's part of the IP address control.
			    pHelpInfo->hItemHandle = FixupIpAddressHelp((HWND) pHelpInfo->hItemHandle);
		    }

            ::WinHelp ((HWND)pHelpInfo->hItemHandle,
			           AfxGetApp()->m_pszHelpFilePath,
			           HELP_WM_HELP,
			           (ULONG_PTR)pdwHelp);
        }
	}
	
	return TRUE;
}


/*!--------------------------------------------------------------------------
	CBaseDialog::OnContextMenu
		Brings up the help context menu for those controls that don't
		usually have context menus (i.e. buttons).  Note that this won't
		work for static controls since they just eat up all messages.
	Author: KennT
 ---------------------------------------------------------------------------*/
void CPropertyPageBase::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

   DWORD * pdwHelp = GetHelpMapInternal();

    if (pdwHelp)
    {
        ::WinHelp (pWnd->m_hWnd,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_CONTEXTMENU,
		           (ULONG_PTR)pdwHelp);
    }
}


// This can be found in dialog.cpp
extern PFN_FINDHELPMAP	g_pfnHelpMap;


DWORD * CPropertyPageBase::GetHelpMapInternal()
{
	DWORD	*	pdwHelpMap = NULL;
	DWORD		dwIDD = 0;

	if ((ULONG_PTR) m_lpszTemplateName < 0xFFFF)
		dwIDD = (WORD) m_lpszTemplateName;
	
	// If there is no dialog IDD, give up
	// If there is no global help map function, give up
	if ((dwIDD == 0) ||
		(g_pfnHelpMap == NULL) ||
		((pdwHelpMap = g_pfnHelpMap(dwIDD)) == NULL))
		return GetHelpMap();

	return pdwHelpMap;
}


struct EnableChildControlsEnumParam
{
	HWND	m_hWndParent;
	DWORD	m_dwFlags;
};

BOOL CALLBACK EnableChildControlsEnumProc(HWND hWnd, LPARAM lParam)
{
	EnableChildControlsEnumParam *	pParam;

	pParam = reinterpret_cast<EnableChildControlsEnumParam *>(lParam);

	// Enable/disable only if this is an immediate descendent
	if (GetParent(hWnd) == pParam->m_hWndParent)
	{
		if (pParam->m_dwFlags & PROPPAGE_CHILD_SHOW)
			::ShowWindow(hWnd, SW_SHOW);
		else if (pParam->m_dwFlags & PROPPAGE_CHILD_HIDE)
			::ShowWindow(hWnd, SW_HIDE);

		if (pParam->m_dwFlags & PROPPAGE_CHILD_ENABLE)
			::EnableWindow(hWnd, TRUE);
		else if (pParam->m_dwFlags & PROPPAGE_CHILD_DISABLE)
			::EnableWindow(hWnd, FALSE);
	}
	return TRUE;
}

HRESULT EnableChildControls(HWND hWnd, DWORD dwFlags)
{
	EnableChildControlsEnumParam	param;

	param.m_hWndParent = hWnd;
	param.m_dwFlags = dwFlags;
	
	EnumChildWindows(hWnd, EnableChildControlsEnumProc, (LPARAM) &param);
	return hrOK;
}

HRESULT MultiEnableWindow(HWND hWndParent, BOOL fEnable, UINT first, ...)
{
	UINT	nCtrlId = first;
	HWND	hWndCtrl;
	
	va_list	marker;

	va_start(marker, first);

	while (nCtrlId != 0)
	{
		hWndCtrl = ::GetDlgItem(hWndParent, nCtrlId);
		Assert(hWndCtrl);
		if (hWndCtrl)
			::EnableWindow(hWndCtrl, fEnable);

		// get the next item
		nCtrlId = va_arg(marker, UINT);
	}

	
	va_end(marker);

	return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by common.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        222
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         332
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\queryobj.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    queryobj.cpp
        Implementation for nodes in the MMC

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "queryobj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////
//
// CBackgroundThread
//
/////////////////////////////////////////////////////////////////////
DEBUG_DECLARE_INSTANCE_COUNTER(CBackgroundThread);

CBackgroundThread::CBackgroundThread()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CBackgroundThread);

	m_bAutoDelete = TRUE;
	::InitializeCriticalSection(&m_cs);
}

CBackgroundThread::~CBackgroundThread()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CBackgroundThread);

//  Trace0("CBackgroundThread::~CBackgroundThread()\n");
	::DeleteCriticalSection(&m_cs);
	m_spQuery.Release();
}

void 
CBackgroundThread::SetQueryObj(ITFSQueryObject *pQuery)
{ 
	Assert(pQuery != NULL);
	m_spQuery.Set(pQuery);
}

BOOL CBackgroundThread::Start()
{
    // NOTE:::  ericdav 10/23/97
    // the thread is initially suspended so we can duplicate the handle
    // if the query object exits very quickly, the background thread object
    // may be destroyed before we can duplicate the handle.  Right after
    // we duplicate the handle, it is started.
	return CreateThread(CREATE_SUSPENDED);
}

int 
CBackgroundThread::Run()
{
	DWORD	dwRet;
	DWORD	dwData;
	BOOL	fAbort = FALSE;
	
	Assert(m_spQuery);
//  Trace0("CBackgroundThread::Run() started\n");

	for (;;)
	{
		try
			{
			if (m_spQuery->Execute() != hrOK)
				break;
			}
		catch(...)
			{
//  		Trace1("%x Caught an exception while executing CQuerObj!\n",
//  			  GetCurrentThreadId());
			fAbort = TRUE;
			}

		//$ Review: kennt
		// Should we sleep a little while at this point? especially
		// since the thread has given us some data to process.

		// Check to see if the abort flag is set
		if (fAbort || FHrOK(m_spQuery->FCheckForAbort()))
		{
			break;
		}
	}

	// Notify the query object that we are exiting
	if (fAbort || FHrOK(m_spQuery->FCheckForAbort()))
		m_spQuery->OnEventAbort();
	else
		m_spQuery->OnThreadExit();

	m_spQuery->DoCleanup();
	
    Trace2("handle=%X id=%X CBackgroundThread::Run() terminated\n",
           m_hThread, m_nThreadID);
	return 0;
}


/*---------------------------------------------------------------------------
	CQueryObject implementation
 ---------------------------------------------------------------------------*/
DEBUG_DECLARE_INSTANCE_COUNTER(CQueryObject);

/*!--------------------------------------------------------------------------
	CQueryObject::CQueryObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CQueryObject::CQueryObject()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CQueryObject);

	m_cRef = 1;
	m_hEventAbort = NULL;
	::InitializeCriticalSection(&m_cs);
}

/*!--------------------------------------------------------------------------
	CQueryObject::~CQueryObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CQueryObject::~CQueryObject()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CQueryObject);

	Assert(m_cRef == 0);
	::DeleteCriticalSection(&m_cs);
	::CloseHandle(m_hEventAbort);
	m_hEventAbort = 0;
//  Trace1("%X CQueryObject::~CQueryObject()\n", GetCurrentThreadId());
}

IMPLEMENT_ADDREF_RELEASE(CQueryObject)

STDMETHODIMP CQueryObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_ITFSQueryObject)
		*ppv = (ITFSQueryObject *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
		((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}

/*!--------------------------------------------------------------------------
	CQueryObject::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CQueryObject::Init(ITFSThreadHandler *pHandler, HWND hwndHidden, UINT uMsgBase)
{
	Assert(m_spHandler == NULL);
	m_spHandler.Set(pHandler);

	m_hHiddenWnd = hwndHidden;
	m_uMsgBase = uMsgBase;
	
	m_hEventAbort = ::CreateEvent(NULL,
								  TRUE /*bManualReset*/,
								  FALSE /*signalled*/,
								  NULL);
	if (m_hEventAbort == NULL)
		return HRESULT_FROM_WIN32(GetLastError());
	else
		return hrOK;
}
	
/*!--------------------------------------------------------------------------
	CQueryObject::SetAbortEvent
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CQueryObject::SetAbortEvent()
{
//  Trace1("%X Signalling CQueryObject abort event.\n", GetCurrentThreadId());
	Assert(m_hEventAbort);
	
    ::SetEvent(m_hEventAbort);
	
    OnEventAbort();
	
    // flush out the message queue in case something is wait to be processed
    MSG msg;
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CQueryObject::FCheckForAbort
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CQueryObject::FCheckForAbort()
{
//	Assert(m_hEventAbort);

	// we may not be running as a background thread, but somebody may have
	// created this object to do somework...  In which case this isn't valid,
	// and just return ok
	if (!m_hEventAbort)
		return hrOK;

	DWORD dwRet = WaitForSingleObjectEx(m_hEventAbort, 0, FALSE);
#ifdef DEBUG
//  if (dwRet == WAIT_OBJECT_0)
//  	Trace1("%X CQueryObject() detects an abort event!\n", GetCurrentThreadId());
#endif
	return dwRet == WAIT_OBJECT_0 ? hrOK : hrFalse;
}




/*---------------------------------------------------------------------------
	CNodeQueryObject implementation
 ---------------------------------------------------------------------------*/

CNodeQueryObject::~CNodeQueryObject()
{
//  Trace2("%X CNodeQueryObject::~CNodeQueryObject has %d objects\n",
//  	   GetCurrentThreadId(), m_dataQueue.GetCount());
	Assert(m_dataQueue.IsEmpty());
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::AddToQueue
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNodeQueryObject::AddToQueue(ITFSNode *pNode)
{
	BOOL bSleep = FALSE;

	Lock();
	//::Sleep(1000);
	LPQUEUEDATA pQData = new QUEUEDATA;

	pQData->Type = QDATA_PNODE;
	pQData->Data = reinterpret_cast<LPARAM>(pNode);

	BOOL bRes = NULL != m_dataQueue.AddTail(pQData);
	pNode->AddRef();
	
	if (IsQueueFull())
	{
		bSleep = TRUE;
	}
	Unlock();

	// We have too much data, we've posted a notification to the node
	// so we can go to sleep here.

	// Note the danger here!  The code calling has to be aware that a
	// context switch will occur here (as well as not locking the data
	// structures).
	if (bSleep)
	{
		PostHaveData((LPARAM) (CNodeQueryObject *) this);
		::Sleep(0);
	}

	return bRes;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::AddToQueue
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNodeQueryObject::AddToQueue(LPARAM Data, LPARAM Type)
{
	BOOL bSleep = FALSE;

	Lock();
	//::Sleep(1000);
	LPQUEUEDATA pQData = new QUEUEDATA;

	pQData->Data = Data;
	pQData->Type = Type;

	BOOL bRes = NULL != m_dataQueue.AddTail(pQData);
	
	if (IsQueueFull())
	{
		bSleep = TRUE;
	}
	Unlock();

	// We have too much data, we've posted a notification to the node
	// so we can go to sleep here.

	// Note the danger here!  The code calling has to be aware that a
	// context switch will occur here (as well as not locking the data
	// structures).
	if (bSleep)
	{
		PostHaveData((LPARAM) (CNodeQueryObject *) this);
		::Sleep(0);
	}

	return bRes;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::RemoveFromQueue
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPQUEUEDATA
CNodeQueryObject::RemoveFromQueue()
{
	Lock();
	LPQUEUEDATA pQD = m_dataQueue.IsEmpty() ? NULL : m_dataQueue.RemoveHead(); 
	Unlock();
	return pQD;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::IsQueueEmpty
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL 
CNodeQueryObject::IsQueueEmpty()
{
	Lock();
	BOOL bRes = m_dataQueue.IsEmpty(); 
	Unlock();
	return bRes;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::IsQueueFull
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNodeQueryObject::IsQueueFull()
{
	Lock();
	BOOL bRes = m_dataQueue.GetCount() >= m_nQueueCountMax;
	Unlock();
	return bRes;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::OnThreadExit
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CNodeQueryObject::OnThreadExit()
{
	BOOL	fSomethingInQueue = FALSE;
	
	Lock();
	fSomethingInQueue = (m_dataQueue.GetCount() > 0);
	Unlock();

	// If there's anything in the queue, post
	if (fSomethingInQueue)
	{
		PostHaveData((LPARAM) (CNodeQueryObject *) this);
		::Sleep(0);
	}
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::OnEventAbort
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CNodeQueryObject::OnEventAbort()
{
//  Trace2("%X CNodeQueryObject::OnEventAbort Q has %d nodes.\n", GetCurrentThreadId(), m_dataQueue.GetCount());
	Lock();
    while (!m_dataQueue.IsEmpty())
	{
		LPQUEUEDATA pQD = m_dataQueue.RemoveHead();
		if (pQD->Type == QDATA_PNODE)
		{
			SPITFSNode spNode;
			spNode = reinterpret_cast<ITFSNode *>(pQD->Data);
		}
		else
		{
			// give the query object a chance to clean up this data
			OnEventAbort(pQD->Data, pQD->Type);
		}

		delete pQD;
	}

	Unlock();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::OnCleanup
		DO NOT override this function.  It provides a last cleanup 
		mechanism for the query object.  If you need notification 
		that a thread is exiting, then override the OnThreadExit call.
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP CNodeQueryObject::DoCleanup()
{
	PostMessageToComponentData(WM_HIDDENWND_INDEX_EXITING, (LPARAM) (CNodeQueryObject *) this);

	m_spQuery.Release();

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::PostMessageToComponentData
		Posts a message to the hidden window to get back on the main 
		MMC thread.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL 
CNodeQueryObject::PostMessageToComponentData(UINT uIndex, LPARAM lParam)
{
//	Assert(m_spHandler);
//	Assert(m_hHiddenWnd != NULL);
//	Assert(::IsWindow(m_hHiddenWnd));

	//$ Review: kennt, if the hidden window is bogus, should we still post
	// to it?  This could happen if our ComponentData went away but we were
	// still in our loop, posting away (we haven't had a chance to get the
	// abort signal).
	
	// maybe something like
		
	if (!m_hHiddenWnd)
		return 0;
		
	if (!::IsWindow(m_hHiddenWnd))
	{
//  	Trace2("%X The Hidden window is GONE, tried to send %08x.\n",
//  		  GetCurrentThreadId(), m_uMsgBase+uIndex);
		m_hHiddenWnd = NULL;
		return 0;
	}
	
	//Trace2("%X CBackgroundThread::PostMessageToComponentData(%08x)\n", GetCurrentThreadId(), m_uMsgBase+uIndex);

	if (!m_spHandler)
	{
//  	Trace0("PostMessageToCompData - m_spHandler == NULL, NOT posting a message\n");
		return 0;
	}

	return ::PostMessage(m_hHiddenWnd, m_uMsgBase + uIndex,
						 (WPARAM)(ITFSThreadHandler *)m_spHandler, lParam);
}

/*---------------------------------------------------------------------------
	CNodeTimerQueryObject implementation
 ---------------------------------------------------------------------------*/
HRESULT 
CNodeTimerQueryObject::Execute()
{

  	while (WaitForSingleObjectEx(m_hEventAbort, GetTimerInterval(), FALSE) != WAIT_OBJECT_0)
    {
        // we timed out.  Post a message to the ComponentData...
        AddToQueue(NULL, QDATA_TIMER);
    }

//  Trace0("CNodeTimerQueryObject::Execute - got abort event, exiting.\n");

    return hrFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\proppage.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    proppage.h
        Implementation for property pages in MMC

    FILE HISTORY:
        
*/

#ifndef _PROPPAGE_H
#define _PROPPAGE_H

// proppage.h : header file
//

#include "afxdlgs.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CPropertyPageBase; 
 
typedef CList< CPropertyPageBase*, CPropertyPageBase* > CPropertyPageBaseList;

HWND FindMMCMainWindow();

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderBase

class CPropertyPageHolderBase
{
public:
// construction
    // for scope pane property pages and wizards
	CPropertyPageHolderBase(ITFSNode *		pNode,
							IComponentData *pComponentData,
							LPCTSTR			pszSheetName,
							BOOL			bIsScopePane = TRUE);

    // for result pane property pages only 
    // result pane wizards should use the previous constructor
	CPropertyPageHolderBase(ITFSNode *		pNode,
							IComponent *    pComponent,
							LPCTSTR			pszSheetName,
							BOOL			bIsScopePane = FALSE);

    virtual ~CPropertyPageHolderBase();

// initialization
	// common
	// property sheet only
	HRESULT CreateModelessSheet(LPPROPERTYSHEETCALLBACK pSheetCallback, LONG_PTR hConsoleHandle); 

	// Property sheet, but do everything ourselves
	HRESULT DoModelessSheet(); 

	// wizard only
	HRESULT DoModalWizard();

// helpers
	// common
	void SetSheetWindow(HWND hSheetWindow);
	HWND GetSheetWindow();
	BOOL SetDefaultSheetPos();  // sets the sheet window centered to the MMC main window
    void AddRef();
	void Release();

	DWORD GetRefCount();
	
	// get/set for the node we are working on
	ITFSNode *	GetNode();
	void SetNode(ITFSNode* pNode);
	
	// get/set for the container we refer to
	ITFSNode *	GetContainer();
		
	BOOL IsWizardMode();
	void ForceDestroy();	// forcefull shut down running sheet

	void AddPageToList(CPropertyPageBase* pPage);
	BOOL RemovePageFromList(CPropertyPageBase* pPage, BOOL bDeleteObject);

	// property sheet only

	// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
	void EnablePeekMessageDuringNotifyConsole(BOOL bEnable)
	{
		m_bPeekMessageDuringNotifyConsole = bEnable;
	};
	
	DWORD NotifyConsole(CPropertyPageBase* pPage);	// notify console of property changes
	void AcknowledgeNotify();						// acknowledge from the console
	virtual void OnPropertyChange(BOOL bScopePane) {}

	// wizard only
	BOOL SetWizardButtons(DWORD dwFlags);
	BOOL SetWizardButtonsFirst(BOOL bValid);
	BOOL SetWizardButtonsMiddle(BOOL bValid); 
	BOOL SetWizardButtonsLast(BOOL bValid);
    BOOL PressButton(int nButton);
    

	virtual DWORD OnFinish() { return 0; } 
	virtual BOOL OnPropertyChange(BOOL bScopePane, LONG_PTR* pChangeMask); // execute from main thread

	HRESULT AddPageToSheet(CPropertyPageBase* pPage);
	HRESULT RemovePageFromSheet(CPropertyPageBase* pPage);

	HWND SetActiveWindow();

	void IncrementDirty(int cDirty) { m_cDirty += cDirty; };
	BOOL IsDirty() { return m_cDirty != 0; };

    BOOL IsWiz97() { return m_bWiz97; }

protected:
	// common
	HRESULT AddAllPagesToSheet();

private:
	void DeleteAllPages();
	void FinalDestruct();

// attributes
protected:
	// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
	BOOL		m_bPeekMessageDuringNotifyConsole; // Set to FALSE by default

	// common
	CString		m_stSheetTitle;			// title for the sheet/wizard window
	CPropertyPageBaseList	m_pageList;	// list of property page objects

	BOOL		m_bWizardMode;		// Wizard Mode (i.e. not modeless property sheet)
	BOOL		m_bCalledFromConsole;	// console told us to put up this page

	BOOL		m_bAutoDelete;		// delete itself when refcount is zero
	BOOL		m_bAutoDeletePages;	// explicitely delete the prop pages

    BOOL        m_bSheetPosSet;
    
    BOOL        m_bWiz97;

	SPIComponentData	m_spComponentData;
	SPIComponent    	m_spComponent;

	BOOL		m_bIsScopePane;		// is this sheet for a scope pane node
	DWORD		m_nCreatedCount;	// count of pages actually created
	SPITFSNode	m_spNode;			// node the pages (or wizard) refers to
	SPITFSNode	m_spParentNode;		// node the pages (or wizard) refers to
	
	HWND		m_hSheetWindow;		// window handle to the sheet

	// property sheet only
	LONG_PTR  m_hConsoleHandle;	// handle for notifications to console
	HANDLE	  m_hEventHandle;	// syncronization handle for property notifications

	// wizard only
	SPIPropertySheetCallback m_spSheetCallback;// cached pointer to add/remove pages

	int			m_cDirty;
	BOOL		m_fSetDefaultSheetPos;

private:
	// property sheet only
	// variables to use across thread boundaries
	DWORD				m_dwLastErr;		// generic error code
	CPropertyPageBase*	m_pPropChangePage;	// page for which notification is valid

public:
	HANDLE				m_hThread;

	void SetError(DWORD dwErr) { m_dwLastErr = dwErr;}
	DWORD GetError() { return m_dwLastErr; }

	CPropertyPageBase* GetPropChangePage() 
			{ ASSERT(m_pPropChangePage != NULL); return m_pPropChangePage; }

};

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageBase

class CPropertyPageBase : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropertyPageBase)
// Construction
private:
	CPropertyPageBase(){} // cannot use this constructor
public:
	CPropertyPageBase(UINT nIDTemplate, UINT nIDCaption = 0);
	virtual ~CPropertyPageBase();

// Overrides
public:
	virtual BOOL OnApply();
	virtual void CancelApply();

protected:
// Generated message map functions
	//{{AFX_MSG(CGeneralPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	
    // help messages
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);

    DECLARE_MESSAGE_MAP()

// attributes
public:
	void SetHolder(CPropertyPageHolderBase* pPageHolder);
	CPropertyPageHolderBase* GetHolder();

	PROPSHEETPAGE  m_psp97;
	HPROPSHEETPAGE m_hPage;

	// property seet only
	virtual BOOL OnPropertyChange(BOOL bScopePane, LONG_PTR* pChangeMask) // execute from main thread
						{ return FALSE; /* do not repaint UI */ } 


	
	// Use this call to get the actual help map
	// this version will check the global help map first.
	DWORD *		GetHelpMapInternal();
	
    // override this to return the pointer to the help map
    virtual LPDWORD GetHelpMap() { return NULL; }

	void InitWiz97(BOOL bHideHeader, UINT nIDHeaderTitle, UINT nIDHeaderSubTitle);
protected:
	// These functions set the dirty flag on the current page
	virtual void SetDirty(BOOL bDirty);
	virtual BOOL IsDirty() { return m_bIsDirty; }

private:
	CString                 m_szHeaderTitle;
	CString                 m_szHeaderSubTitle;
	CPropertyPageHolderBase* m_pPageHolder;             // backpointer to holder
	BOOL                    m_bIsDirty;					// dirty flag
};


/*---------------------------------------------------------------------------
	Inlined functions
 ---------------------------------------------------------------------------*/

inline void	CPropertyPageHolderBase::AddRef()
{
	m_nCreatedCount++;
}

inline DWORD CPropertyPageHolderBase::GetRefCount()
{
	return m_nCreatedCount;
}

inline HWND CPropertyPageHolderBase::GetSheetWindow()
{
	return m_hSheetWindow;
}

inline ITFSNode * CPropertyPageHolderBase::GetNode()
{
	if (m_spNode)
		m_spNode->AddRef();
	return m_spNode;
}

inline void CPropertyPageHolderBase::SetNode(ITFSNode *pNode)
{
	m_spNode.Set(pNode);
	m_spParentNode.Release();
	if (m_spNode)
		m_spNode->GetParent(&m_spParentNode);
}

inline ITFSNode * CPropertyPageHolderBase::GetContainer()
{
	if (m_spParentNode)
		m_spParentNode->AddRef();
	return m_spParentNode;
}

inline BOOL CPropertyPageHolderBase::IsWizardMode()
{
	return m_bWizardMode;
}

inline BOOL CPropertyPageHolderBase::SetWizardButtonsFirst(BOOL bValid) 
{ 
	return SetWizardButtons(bValid ? PSWIZB_NEXT : 0);
}

inline BOOL CPropertyPageHolderBase::SetWizardButtonsMiddle(BOOL bValid) 
{ 
	return SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_NEXT) : PSWIZB_BACK);
}

inline BOOL CPropertyPageHolderBase::SetWizardButtonsLast(BOOL bValid) 
{ 
	return SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_FINISH) : (PSWIZB_BACK|PSWIZB_DISABLEDFINISH));
}





inline void CPropertyPageBase::SetHolder(CPropertyPageHolderBase *pPageHolder)
{
	Assert((pPageHolder != NULL) && (m_pPageHolder == NULL));
	m_pPageHolder = pPageHolder;
}

inline CPropertyPageHolderBase * CPropertyPageBase::GetHolder()
{
	return m_pPageHolder;
}

inline void CPropertyPageBase::SetDirty(BOOL bDirty)
{
	SetModified(bDirty);
	m_bIsDirty = bDirty;
}

// Use this function for property pages on the Scope pane
HRESULT DoPropertiesOurselvesSinceMMCSucks(ITFSNode *pNode,
								  IComponentData *pComponentData,
								  LPCTSTR pszSheetTitle);

// Use this function for property pages on the result pane
HRESULT DoPropertiesOurselvesSinceMMCSucks(ITFSNode *   pNode,
										   IComponent * pComponent,
										   LPCTSTR	    pszSheetTitle,
                                           int          nVirtualIndex = -1);

/*!--------------------------------------------------------------------------
	EnableChildControls
		Use this function to enable/disable/hide/show all child controls
		on a page (actually it will work with any child windows, the
		parent does not have to be a property page).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT EnableChildControls(HWND hWnd, DWORD dwFlags);
#define PROPPAGE_CHILD_SHOW		0x00000001
#define PROPPAGE_CHILD_HIDE		0x00000002
#define PROPPAGE_CHILD_ENABLE	0x00000004
#define PROPPAGE_CHILD_DISABLE	0x00000008

/*!--------------------------------------------------------------------------
	MultiEnableWindow
		This function takes a variable length list of control ids,
		that will be enabled/disabled.  The last item in the control
		id list must be 0.

		The reason why I called this MultiEnableWindow instead of
		EnableMultiWindow is that we can grep for EnableWindow and
		still show these calls.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	MultiEnableWindow(HWND hWndParent, BOOL fEnable, UINT nCtrlId, ...);

#endif // _PROPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\snapbase.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    snapbase.h
	Common header file included by all snapins derived 
		from these base classes

    FILE HISTORY:
	
*/

const long UNINITIALIZED = -1;

/////////////////////////////////////////////////////////////////////////////
// Helper functions

#include <dbgutil.h>
#include <std.h>
#include <errutil.h>

#include <ipaddr.h>
#include "ipaddr.hpp"
#include "dataobj.h"
#include "compont.h"
#include "proppage.h"
#include "about.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\objplus.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1997 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _OBJPLUS_H_
#define _OBJPLUS_H_

//
//  Forward declarations
//
class CObjHelper ;
class CObjectPlus ;
class CObOwnedList ;
class CObListIter ;
class CObOwnedArray ;

//
//  Wrappers for the *BROKEN* C8 TRY/CATCH stuff
//
#define CATCH_MEM_EXCEPTION             \
    TRY

#define END_MEM_EXCEPTION(err)          \
    CATCH_ALL(e) {                      \
       err = ERROR_NOT_ENOUGH_MEMORY ;  \
    } END_CATCH_ALL

/****************************************************************************
DEBUGAFX.H
****************************************************************************/

//
//  ENUM for special debug output control tokens
//
enum ENUM_DEBUG_AFX { EDBUG_AFX_EOL = -1 } ;

#if defined(_DEBUG)
   #define TRACEFMTPGM      DbgFmtPgm( THIS_FILE, __LINE__ )
   #define TRACEOUT(x)      { afxDump << x ; }
   #define TRACEEOL(x)      { afxDump << x << EDBUG_AFX_EOL ; }
   #define TRACEEOLID(x)    { afxDump << TRACEFMTPGM << x << EDBUG_AFX_EOL ; }
   #define TRACEEOLERR(err,x)   { if (err) TRACEEOLID(x) }

#else
   #define TRACEOUT(x)      { ; }
   #define TRACEEOL(x)      { ; }
   #define TRACEEOLID(x)    { ; }
   #define TRACEEOLERR(err,x)   { ; }
#endif

//
//  Append an EOL onto the debug output stream
//
CDumpContext & operator << ( CDumpContext & out, ENUM_DEBUG_AFX edAfx ) ;

//
//  Format a program name and line number for output (removes the path info)
//
extern const char * DbgFmtPgm ( const char * szFn, int line ) ;

/****************************************************************************
OBJPLUS.H
****************************************************************************/

//
//  Helper class for control of construction and API errors
//
class CObjHelper
{
protected:
     LONG m_ctor_err ;
     LONG m_api_err ;
     DWORD m_time_created ;
     BOOL m_b_dirty ;

     CObjHelper () ;

public:
    void AssertValid () const ;

    virtual BOOL IsValid () const ;

    operator BOOL()
    {
        return (IsValid());
    }

    //
    //  Update the Dirty flag
    //
    void SetDirty ( BOOL bDirty = TRUE )
    {
        m_b_dirty = bDirty ;
    }

    //
    //  Query the Dirty flag
    //
    BOOL IsDirty () const
    {
        return m_b_dirty ;
    }

    //
    //  Return the creation time of this object
    //
    DWORD QueryCreationTime() const
    {
        return m_time_created ;
    }

    //
    //  Return the elapsed time this object has been alive.
    //
    DWORD QueryAge () const ;

    //
    //  Query/set constuction failure
    //
    void ReportError ( LONG errInConstruction ) ;
    LONG QueryError () const
    {
        return m_ctor_err ;
    }

    //
    //  Reset all error conditions.
    //
    void ResetErrors ()
    {
        m_ctor_err = m_api_err = 0 ;
    }

    //
    //  Query/set API errors.
    //
    LONG QueryApiErr () const
    {
        return m_api_err ;
    }

    //
    //  SetApiErr() echoes the error to the caller.for use in expressions.
    //
    LONG SetApiErr ( LONG errApi = 0 ) ;
};

class CObjectPlus : public CObject, public CObjHelper
{
public:
    CObjectPlus () ;

    //
    //  Compare one object with another
    //
    virtual int Compare ( const CObjectPlus * pob ) const ;

    //
    //  Define a typedef for an ordering function.
    //
    typedef int (CObjectPlus::*PCOBJPLUS_ORDER_FUNC) ( const CObjectPlus * pobOther ) const ;

    //
    //  Helper function to release RPC memory from RPC API calls.
    //
    static void FreeRpcMemory ( void * pvRpcData ) ;
};

class CObListIter : public CObjectPlus
{
protected:
    POSITION m_pos ;
    const CObOwnedList & m_obList ;

public:
    CObListIter ( const CObOwnedList & obList ) ;

    CObject * Next () ;

    void Reset () ;

    POSITION QueryPosition () const
    {
        return m_pos ;
    }

    void SetPosition(POSITION pos)
    {
        m_pos = pos;
    }
};

//
//  Object pointer list which "owns" the objects pointed to.
//
class CObOwnedList : public CObList, public CObjHelper
{
protected:
    BOOL m_b_owned ;

    static int _cdecl SortHelper ( const void * pa, const void * pb ) ;

public:
    CObOwnedList ( int nBlockSize = 10 ) ;
    virtual ~ CObOwnedList () ;

    BOOL SetOwnership ( BOOL bOwned = TRUE )
    {
        BOOL bOld = m_b_owned ;
        m_b_owned = bOwned ;

        return bOld ;
    }

    CObject * Index ( int index ) ;
    CObject * RemoveIndex ( int index ) ;
    BOOL Remove ( CObject * pob ) ;
    void RemoveAll () ;
    int FindElement ( CObject * pobSought ) const ;

    //
    //  Set all elements to dirty or clean.  Return TRUE if
    //  any element was dirty.
    //
    BOOL SetAll ( BOOL bDirty = FALSE ) ;

    //
    //  Override of CObList::AddTail() to control exception handling.
    //  Returns NULL if addition fails.
    //
    POSITION AddTail ( CObjectPlus * pobj, BOOL bThrowException = FALSE ) ;

    //
    //  Sort the list elements according to the
    //    given ordering function.
    //
    LONG Sort ( CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc ) ;
};

//
//  Object array which "owns" the objects pointed to.
//
class CObOwnedArray : public CObArray, public CObjHelper
{
protected:
    BOOL m_b_owned ;

    static int _cdecl SortHelper ( const void * pa, const void * pb ) ;

public:
    CObOwnedArray () ;
    virtual ~ CObOwnedArray () ;

    BOOL SetOwnership ( BOOL bOwned = TRUE )
    {
        BOOL bOld = m_b_owned ;
        m_b_owned = bOwned ;
        return bOld ;
    }

    void RemoveAt( int nIndex, int nCount = 1);
    void RemoveAll () ;
    int FindElement ( CObject * pobSought ) const ;

    //
    //  Set all elements to dirty or clean.  Return TRUE if
    //  any element was dirty.
    //
    BOOL SetAll ( BOOL bDirty = FALSE ) ;

    //
    //  Sort the list elements according to the
    //    given ordering function.
    //
    LONG Sort ( CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc ) ;

private:

    void QuickSort(
        int nLow,
        int nHigh,
        CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc
        );

    void Swap(
        int nIndex1,
        int nIndex2
        );
};

#endif  // _OBJPLUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\snaputil.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include "tfschar.h"
#include "tregkey.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW


#if _WIN32_WINNT < 0x0500

//
// CODEWORK This was taken from winbase.h.  MFC requires _WIN32_WINNT=0x4000 whereas
// winbase.h only includes this for _WIN32_WINNT=0x5000.  JonN 1/14/99
//
extern "C" {
typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;
WINBASEAPI
BOOL
WINAPI
GetComputerNameExA (
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    );
WINBASEAPI
BOOL
WINAPI
GetComputerNameExW (
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );
#ifdef UNICODE
#define GetComputerNameEx  GetComputerNameExW
#else
#define GetComputerNameEx  GetComputerNameExA
#endif // !UNICODE
} // extern "C"
#endif



/*!--------------------------------------------------------------------------
	IsLocalMachine
		Returns TRUE if the machine name passed in is the local machine,
		or if pszMachineName is NULL.

        This compares the NetBIOS name and the DNS (fully-qualified) name.

		Returns FALSE otherwise.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL	IsLocalMachine(LPCTSTR pszMachineName)
{
	static TCHAR	s_szLocalMachineName[MAX_PATH*2+1] = _T("");
	static TCHAR	s_szDnsLocalMachineName[MAX_PATH*2+1] = _T("");

	if ((pszMachineName == NULL) || (*pszMachineName == 0))
		return TRUE;

    // Bypass the beginning slashes
    if ((pszMachineName[0] == _T('\\')) && (pszMachineName[1] == _T('\\')))
        pszMachineName += 2;

    // Check again (for degenerate case of "\\")
    if (*pszMachineName == 0)
        return TRUE;

	if (s_szLocalMachineName[0] == 0)
	{
		DWORD dwSize = MAX_PATH*2;
		GetComputerName(s_szLocalMachineName, &dwSize);
		s_szLocalMachineName[MAX_PATH*2] = 0;
	}

    if (s_szDnsLocalMachineName[0] == 0)
    {
		DWORD dwSize = MAX_PATH*2;
		GetComputerNameEx(ComputerNameDnsFullyQualified,
                          s_szDnsLocalMachineName,
                          &dwSize);
		s_szDnsLocalMachineName[MAX_PATH*2] = 0;
    }
    
	return (StriCmp(pszMachineName, s_szLocalMachineName) == 0) ||
            (StriCmp(pszMachineName, s_szDnsLocalMachineName) == 0);
}

/*!--------------------------------------------------------------------------
	FUseTaskpadsByDefault
		See comments in header file.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL	FUseTaskpadsByDefault(LPCTSTR pszMachineName)
{
	static DWORD	s_dwStopTheInsanity = 42;
	RegKey	regkeyMMC;
	DWORD	dwErr;

	if (s_dwStopTheInsanity == 42)
	{
		// Set the default to TRUE (i.e. do not use taskpads by default)
		// ------------------------------------------------------------
		s_dwStopTheInsanity = 1;
		
		dwErr = regkeyMMC.Open(HKEY_LOCAL_MACHINE,
							   _T("Software\\Microsoft\\MMC"),
							   KEY_READ, pszMachineName);
		if (dwErr == ERROR_SUCCESS)
		{
			dwErr = regkeyMMC.QueryValue(_T("TFSCore_StopTheInsanity"), s_dwStopTheInsanity);
			if (dwErr != ERROR_SUCCESS)
				s_dwStopTheInsanity = 1;
		}
	}
		
	return !s_dwStopTheInsanity;
}


UINT	CalculateStringWidth(HWND hWndParent, LPCTSTR pszString)
{
	// Create a dummy list control, set this text width and use
	// that to determine the width of the string as used by MMC.

	// Create a dummy list control (that will be attached to the window)

	CListCtrl	listctrl;
	CRect		rect(0,0,0,0);
	UINT		nSize;
	HWND		hWnd;

	CString s_szHiddenWndClass = AfxRegisterWndClass(
			0x0,  //UINT nClassStyle, 
			NULL, //HCURSOR hCursor,        
			NULL, //HBRUSH hbrBackground, 
			NULL  //HICON hIcon
	);

	hWnd = ::CreateWindowEx(
					0x0,    //DWORD dwExStyle, 
					s_szHiddenWndClass,     //LPCTSTR lpszClassName, 
					NULL,   //LPCTSTR lpszWindowName, 
					0x0,    //DWORD dwStyle, 
					0,              //int x, 
					0,              //int y, 
					0,              //int nWidth, 
					0,              //int nHeight, 
					NULL,   //HWND hwndParent, 
					NULL,   //HMENU nIDorHMenu,
					AfxGetInstanceHandle(),
					NULL    //LPVOID lpParam = NULL
					);

	
	listctrl.Create(0, rect, CWnd::FromHandle(hWnd), 0);

	nSize = listctrl.GetStringWidth(pszString);

	// Now destroy the window that we created
	listctrl.DestroyWindow();

	SendMessage(hWnd, WM_CLOSE, 0, 0);

	return nSize;
}

/*!--------------------------------------------------------------------------
	SearchChildNodesForGuid
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SearchChildNodesForGuid(ITFSNode *pParent, const GUID *pGuid, ITFSNode **ppChild)
{
	HRESULT		hr = hrFalse;
	SPITFSNodeEnum	spNodeEnum;
	SPITFSNode	spNode;

	// Enumerate through all of the child nodes and return the
	// first node that matches the GUID.

	CORg( pParent->GetEnum(&spNodeEnum) );

	while ( spNodeEnum->Next(1, &spNode, NULL) == hrOK )
	{
		if (*(spNode->GetNodeType()) == *pGuid)
			break;
		
		spNode.Release();
	}

	if (spNode)
	{
		if (ppChild)
			*ppChild = spNode.Transfer();
		hr = hrOK;
	}


Error:
	return hr;
}



/*!--------------------------------------------------------------------------
	CheckIPAddressAndMask
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
UINT CheckIPAddressAndMask(DWORD ipAddress, DWORD ipMask, DWORD dwFlags)
{
    if (dwFlags & IPADDRESS_TEST_NONCONTIGUOUS_MASK)
    {
        DWORD   dwNewMask;
        
        // Hmm... how to do this?
        dwNewMask = 0;
        for (int i = 0; i < sizeof(ipMask)*8; i++)
        {            
            dwNewMask |= 1 << i;
            
            if (dwNewMask & ipMask)
            {
                dwNewMask &= ~(1 << i);
                break;
            }
        }

        // At this point dwNewMask is 000..0111
        // ~dwNewMask is 111..1000
        //  ~ipMask is   001..0111 (if noncontiguous)
        // ~dwNewMask & ~ipMask is 001..0000
        // So if this is non-zero then the mask is noncontiguous
        if (~dwNewMask & ~ipMask)
        {
            return IDS_COMMON_ERR_IPADDRESS_NONCONTIGUOUS_MASK;
        }
    }

    if (dwFlags & IPADDRESS_TEST_TOO_SPECIFIC)
    {
        if (ipAddress != (ipAddress & ipMask))
            return IDS_COMMON_ERR_IPADDRESS_TOO_SPECIFIC;
    }

    if (dwFlags & IPADDRESS_TEST_NORMAL_RANGE)
    {
        if ((ipAddress < MAKEIPADDRESS(1,0,0,0)) ||
            (ipAddress >= MAKEIPADDRESS(224,0,0,0)))
            return IDS_COMMON_ERR_IPADDRESS_NORMAL_RANGE;
    }

    if (dwFlags & IPADDRESS_TEST_NOT_127)
    {
        if ((ipAddress & 0xFF000000) == MAKEIPADDRESS(127,0,0,0))
            return IDS_COMMON_ERR_IPADDRESS_127;
    }

    if (dwFlags & IPADDRESS_TEST_ADDR_NOT_EQ_MASK)
    {
        if (ipAddress == ipMask)
            return IDS_COMMON_ERR_IPADDRESS_NOT_EQ_MASK;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\task.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	Task.cpp
        Implementation of the task holder/enumerator object
		
    FILE HISTORY:
	
*/
#include <stdafx.h>
#include "task.h"

DEBUG_DECLARE_INSTANCE_COUNTER(CTaskList);

CTaskList::CTaskList()
    : m_uIndex(0),
      m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CTaskList);
}


CTaskList::~CTaskList()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CTaskList);
}


IMPLEMENT_ADDREF_RELEASE(CTaskList)

STDMETHODIMP CTaskList::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
	else if (riid == IID_IEnumTASK)
		*ppv = (IEnumTASK *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
    }
    else
		return E_NOINTERFACE;
}

/*!--------------------------------------------------------------------------
    CTaskList::Next
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTaskList::Next
(
    ULONG celt, 
    MMC_TASK * rgelt, 
    ULONG * pceltFetched
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {

        // caller alloc's array of MMC_TASKs
        // callee fills MMC_TASK elements (via CoTaskMemAlloc)

        if ((rgelt == NULL) || (pceltFetched == NULL))
            return E_INVALIDARG;
    
        Assert(!IsBadWritePtr (rgelt, celt*sizeof(MMC_TASK)));
        Assert(!IsBadWritePtr (pceltFetched, sizeof(ULONG)));

        ULONG nTaskNumber = (ULONG)m_arrayTasks.GetSize();
        for (ULONG i = 0; i < celt; i++) 
        {
            if (m_uIndex >= nTaskNumber) // cannot fetch anymore
            {
                if (pceltFetched != NULL)
                    *pceltFetched = i;
                return S_FALSE;   // failure
            }
            
            if (FillTask(&rgelt[i], m_uIndex))
            {
                m_uIndex++;
            }
            else
            {
                if (pceltFetched)
                    *pceltFetched = i;
                return S_FALSE;   // failure
            }
        }
        
        // if we get here all is well
        if (pceltFetched)
            *pceltFetched = celt;

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::Skip
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTaskList::Skip
(
    ULONG celt
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        m_uIndex += celt;

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::Reset
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTaskList::Reset()
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        m_uIndex = 0;

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::Clone
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTaskList::Clone
(
    IEnumTASK ** ppEnumTASK
)
{
    CTaskList * pEnumTasks = NULL;
    SPIEnumTask spEnumTasks;
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        if (ppEnumTASK == NULL)
            return E_INVALIDARG;

        *ppEnumTASK = NULL;
    
        // clone maintaining state info 
        pEnumTasks = new CTaskList;
        spEnumTasks = pEnumTasks;

        pEnumTasks->_Clone(m_uIndex, m_arrayTasks); 
        CORg (pEnumTasks->QueryInterface(IID_IEnumTASK, (void**)ppEnumTASK));

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::AddTask
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTaskList::AddTask
(
    LPOLESTR        pszMouseOverBitmapResource,
    LPOLESTR        pszMouseOffBitmapResource,
    LPOLESTR        pszText,
    LPOLESTR        pszHelpString,
    MMC_ACTION_TYPE mmcAction,
    long            nCommandID
)
{
    HRESULT     hr = hrOK;
    MMC_TASK    mmcTask;

    COM_PROTECT_TRY
    {
        mmcTask.sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
		mmcTask.sDisplayObject.uBitmap.szMouseOverBitmap = pszMouseOverBitmapResource;
        mmcTask.sDisplayObject.uBitmap.szMouseOffBitmap = pszMouseOffBitmapResource;
        mmcTask.szText = pszText;
        mmcTask.szHelpString = pszHelpString;
        mmcTask.eActionType = mmcAction;
        mmcTask.nCommandID = nCommandID;

        m_arrayTasks.Add(mmcTask);

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::AddTask
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTaskList::AddTask
(
    LPOLESTR        pszMouseOverBitmapResource,
    LPOLESTR        pszMouseOffBitmapResource,
    LPOLESTR        pszText,
    LPOLESTR        pszHelpString,
    MMC_ACTION_TYPE mmcAction,
    LPOLESTR        pszActionURLorScript
)
{
    HRESULT     hr = hrOK;
    MMC_TASK    mmcTask;

    COM_PROTECT_TRY
    {
        mmcTask.sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
		mmcTask.sDisplayObject.uBitmap.szMouseOverBitmap = pszMouseOverBitmapResource;
        mmcTask.sDisplayObject.uBitmap.szMouseOffBitmap = pszMouseOffBitmapResource;
        mmcTask.szText = pszText;
        mmcTask.szHelpString = pszHelpString;
        mmcTask.eActionType = mmcAction;

        switch (mmcTask.eActionType) 
        {
            case MMC_ACTION_LINK:
                mmcTask.szActionURL = pszActionURLorScript;
                break;
            case MMC_ACTION_SCRIPT:
                mmcTask.szScript = pszActionURLorScript;
                break;
            default:
                Assert (FALSE);  // bad task
                break;
        }

        m_arrayTasks.Add(mmcTask);

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::FillTask
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL 
CTaskList::FillTask
(
    MMC_TASK *  pmmcTask,
    int         nIndex
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        // right now we only support bitmap display types
        pmmcTask->sDisplayObject.eDisplayType = m_arrayTasks[nIndex].sDisplayObject.eDisplayType;

        switch (m_arrayTasks[nIndex].sDisplayObject.eDisplayType)
        {
            case MMC_TASK_DISPLAY_TYPE_BITMAP:
                {
                    pmmcTask->sDisplayObject.uBitmap.szMouseOverBitmap = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].sDisplayObject.uBitmap.szMouseOverBitmap)+1));
                    if (pmmcTask->sDisplayObject.uBitmap.szMouseOverBitmap) 
                    {
                        lstrcpy (pmmcTask->sDisplayObject.uBitmap.szMouseOverBitmap, m_arrayTasks[nIndex].sDisplayObject.uBitmap.szMouseOverBitmap);
                    }
                     
                    pmmcTask->sDisplayObject.uBitmap.szMouseOffBitmap = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].sDisplayObject.uBitmap.szMouseOffBitmap)+1));
                    if (pmmcTask->sDisplayObject.uBitmap.szMouseOffBitmap) 
                    {
                        lstrcpy (pmmcTask->sDisplayObject.uBitmap.szMouseOffBitmap, m_arrayTasks[nIndex].sDisplayObject.uBitmap.szMouseOffBitmap);
                    }
                }
                break;

            default:
                Panic0("unsupported display type in task");
                break;
        }

        //
        // Add button text
        //
        pmmcTask->szText = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].szText)+1));
        if (pmmcTask->szText) 
        {
            lstrcpy (pmmcTask->szText, m_arrayTasks[nIndex].szText);
        
            //
            // Add help string
            //
            pmmcTask->szHelpString = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].szHelpString)+1));
            if (pmmcTask->szHelpString) 
            {
               lstrcpy (pmmcTask->szHelpString, m_arrayTasks[nIndex].szHelpString);
            }
        }
        
        pmmcTask->eActionType = m_arrayTasks[nIndex].eActionType;
        
        switch (pmmcTask->eActionType) 
        {
            case MMC_ACTION_ID:
                pmmcTask->nCommandID = m_arrayTasks[nIndex].nCommandID;
                break;

            case MMC_ACTION_LINK:
                pmmcTask->szActionURL = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].szActionURL)+1));
                if (pmmcTask->szActionURL) 
                {
                    lstrcpy (pmmcTask->szActionURL, m_arrayTasks[nIndex].szActionURL);
                }
                break;

            case MMC_ACTION_SCRIPT:
                pmmcTask->szScript = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].szScript)+1));
                if (pmmcTask->szActionURL) 
                {
                    lstrcpy (pmmcTask->szScript, m_arrayTasks[nIndex].szScript);
                }
                break;

            default:
                Assert (FALSE);  // bad task
                break;
        }

    }
    COM_PROTECT_CATCH

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
    CTaskList::_Clone
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTaskList::_Clone
(   
    int                 nIndex, 
    CTaskListArray &    arrayTasks
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        m_uIndex = nIndex;

        m_arrayTasks.RemoveAll();
        m_arrayTasks.Append(arrayTasks);
    }
    COM_PROTECT_CATCH

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <mmc.h>

extern LPCWSTR g_lpszNullString;

extern enum FOLDER_TYPES;

// New Clipboard format that has the Type and Cookie
extern const wchar_t*   SNAPIN_INTERNAL;

#include "snapbase.h"
#include "resource.h"
#include "commres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\statsdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
   statsdlg.h

   Header file for the base class of the Statistics dialogs.

    FILE HISTORY:
   
*/

#ifndef _STATSDLG_H
#define _STATSDLG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#include "commres.h"

// forward declarations
struct ColumnData;
class ConfigStream;

class CStatsListCtrl : public CListCtrl
{
public:
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
   
    void CopyToClipboard();

    DECLARE_MESSAGE_MAP();
};

/*---------------------------------------------------------------------------
   These are the available options (they get passed in through
   the StatsDialog constructor).

   STATSDLG_FULLWINDOW
   Makes the list control fill the entire window

   STATSDLG_CONTEXTMENU
   Provides a context menu over the list control.

   STATSDLG_SELECT_COLUMNS
   Allows the user the ability to change the available column set

   STATSDLG_VERTICAL
   The data is displayed with the column headers going vertical rather
   than horizontal.  The user has to be aware of this when writing the
   RefreshData() code.

 ---------------------------------------------------------------------------*/

#define STATSDLG_FULLWINDOW      0x00000001
#define STATSDLG_CONTEXTMENU  0x00000002
#define STATSDLG_SELECT_COLUMNS  0x00000004
#define STATSDLG_VERTICAL     0x00000008
#define STATSDLG_CLEAR        0x00000010
#define STATSDLG_DEFAULTSORT_ASCENDING	0x00010000

class StatsDialog : public CBaseDialog
{
public:
   StatsDialog(DWORD dwOptions);
   virtual ~StatsDialog();

   HRESULT SetColumnInfo(const ContainerColumnInfo *pColumnInfo, UINT cColumnInfo);

   int MapColumnToSubitem(UINT nColumnId);
   BOOL IsSubitemVisible(UINT nSubitemId);
   int MapSubitemToColumn(UINT nSubitemId);

   HANDLE   GetSignalEvent()
         { return m_hEventThreadKilled; }

   void  UnloadHeaders();
    void LoadHeaders();
    
    // sets the width of the columns to the maximum of the text
    void    SetColumnWidths(UINT uNumColumns);
    
   // Posts the command to do a refresh
   void  PostRefresh();

   // Override this to implement the actual insertion of data
   virtual HRESULT RefreshData(BOOL fGrabNewData);

   // This is called prior to deleting all items from the list control
   // This allows for the removal of any private data items
   virtual void PreDeleteAllItems();

   // Override this to implement sorting
   virtual void Sort(UINT nColumn);

   // MFC Overrides
   virtual BOOL OnInitDialog();
   virtual void OnOK();
   virtual void OnCancel();
   virtual void PostNcDestroy();
   virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

   // Sets the configuration info location and the column id
   // for this dialog
   void  SetConfigInfo(ConfigStream *pConfig, ULONG ulId);

   // Sets the preferred size and position
   void  SetPosition(RECT rc);
   void  GetPosition(RECT *prc);

   virtual HRESULT AddToContextMenu(CMenu* pMenu);

   // Deletes all items from the list control
   void  DeleteAllItems();

   // copy data to the clipboard
   void  CopyData();

	//{{AFX_DATA(ColumnDlg)
   CStatsListCtrl      m_listCtrl;
	//}}AFX_DATA

	//{{AFX_VIRTUAL(ColumnDlg)
protected:
	virtual VOID                DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL

   DWORD       m_dwOptions;
   ConfigStream * m_pConfig;
   ULONG       m_ulId;     // id to be used when saving/getting info
   ViewInfo    m_viewInfo;
   BOOL        m_bAfterInitDialog;
   BOOL        m_fSortDirection;
   BOOL        m_fDefaultSortDirection;

   RECT  m_rcPosition;

   // These hold the position of the buttons relative to the
   // right and bottom of the dialog.  They are used to hold
   // the resizing information.
   RECT  m_rcList;

   // This holds the minimum size rectangle
   SIZE  m_sizeMinimum;

   // This is used by the thread and the handler (the thread signals
   // the handler that it has cleaned up after itself).
   HANDLE   m_hEventThreadKilled;

protected:
   // These hold the position of the buttons relative to the
   // right and bottom of the dialog.  They are used to hold
   // the resizing information.
   enum
   {
      INDEX_CLOSE = 0,
      INDEX_REFRESH = 1,
      INDEX_SELECT = 2,
        INDEX_CLEAR = 3,
      INDEX_COUNT = 4,  // this is the number of enums
   };
   struct StatsDialogBtnInfo
   {
      ULONG m_ulId;
      RECT  m_rc;
   };

   StatsDialogBtnInfo   m_rgBtn[INDEX_COUNT];
   float m_ColWidthMultiple;
   DWORD m_ColWidthAdder;
   
protected:
	//{{AFX_MSG(StatsDialog)
    virtual afx_msg void OnRefresh();
    afx_msg void OnSelectColumns();
    afx_msg void OnMove(int x, int y);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO *pMinMax);
    afx_msg void OnContextMenu(CWnd *pWnd, CPoint pos);
    afx_msg void OnNotifyListControlClick(NMHDR *pNmHdr, LRESULT *pResult);
	//}}AFX_MSG

    DECLARE_MESSAGE_MAP();
};

void CreateNewStatisticsWindow(StatsDialog *pWndStats,
                        HWND hWndParent,
                        UINT  nIDD);
void WaitForStatisticsWindow(StatsDialog *pWndStats);

#endif // _STATSDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\snaputil.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    snaputil.h  
        various utility routines 

    FILE HISTORY:
	
*/

#ifndef _SNAPUTIL_H
#define _SNAPUTIL_H

#ifdef __cplusplus

typedef CArray<GUID, const GUID&> CTFSGUIDArrayBase;

class CGUIDArray : public CTFSGUIDArrayBase
{
public:
    void AddUnique(const GUID& guid)
    {
        for (INT_PTR i = GetUpperBound(); i >= 0; --i)
        {
            if (GetAt(i) == guid)
                break;
        }

        if (i < 0)
            Add(guid);
    }

    BOOL IsInList(GUID & guid)
    {
        for (int i = 0; i < GetSize(); i++)
        {
            if (GetAt(i) == guid)
                return TRUE;
        }

        return FALSE;
    }
};
#endif	// __cplusplus



#ifdef __cplusplus
extern "C"
{
#endif
	
/*!--------------------------------------------------------------------------
	IsLocalMachine
		Returns TRUE if the machine name passed in is the local machine,
		or if pszMachineName is NULL.

		Returns FALSE otherwise.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL	IsLocalMachine(LPCTSTR pszMachineName);

/*!--------------------------------------------------------------------------
	FUseTaskpadsByDefault
		Returns TRUE if we are to use taskpads by default.

		We check the
			HKLM\Software\Microsoft\MMC
				TFSCore_StopTheInsanity : REG_DWORD :
					= 1, don't use taskpads by default
					= 0 (or not there), use taskpads by default
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL	FUseTaskpadsByDefault(LPCTSTR pszMachineName);

#ifdef __cplusplus
};
#endif

UINT	CalculateStringWidth(HWND hWndParent, LPCTSTR pszString);



/*---------------------------------------------------------------------------
	IP address validation function

    This will return 0 (for success) or a string constant if the input
    is bogus.

    ipAddress and ipMask are assumed to be in host order.
 ---------------------------------------------------------------------------*/
UINT    CheckIPAddressAndMask(DWORD ipAddress, DWORD ipMask, DWORD dwFlags);

#define IPADDRESS_TEST_ALL      (0xFFFFFFFF)

// This test is to test the address only.  Tests involving the masks
// are not performed.
#define IPADDRESS_TEST_ADDRESS_ONLY \
                                    (IPADDRESS_TEST_NORMAL_RANGE | \
                                    IPADDRESS_TEST_NOT_127 )

// Tests to see that the mask is non-contiguous
// if this fail, function returns IDS_COMMON_ERR_IPADDRESS_NONCONTIGUOUS_MASK
#define IPADDRESS_TEST_NONCONTIGUOUS_MASK   0x00000001

// Tests to see that the address is not longer than the mask
// e.g. 172.31.248.1 / 255.255.255.0
// Returns IDS_COMMON_ERR_IPADDRESS_TOO_SPECIFIC
#define IPADDRESS_TEST_TOO_SPECIFIC         0x00000002

// Tests to to see that the ipaddress falls into the normal range
//    1.0.0.0 <= ipaddress < 224.0.0.0
// Returns IDS_COMMON_ERR_IPADDRESS_NORMAL_RANGE
#define IPADDRESS_TEST_NORMAL_RANGE         0x00000004

// Tests that ths is not a 127.x.x.x address
// Returns IDS_COMMON_ERR_IPADDRESS_127
#define IPADDRESS_TEST_NOT_127              0x00000008

// Tests that the ipaddress is not the same as the mask
// Retursn IDS_COMMOON_ERR_IPADDRESS_NOT_EQ_MASK
#define IPADDRESS_TEST_ADDR_NOT_EQ_MASK     0x00000010



#endif _SNAPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\statsdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       statsdlg.cpp
//
//--------------------------------------------------------------------------

// StatsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "StatsDlg.h"
#include "coldlg.h"
#include "modeless.h"   // ModelessThread

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


BEGIN_MESSAGE_MAP(CStatsListCtrl, CListCtrl)
    //{{AFX_MSG_MAP(CStatsListCtrl)
    ON_WM_KEYDOWN()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CStatsListCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    BOOL fControlDown;
    BOOL fShiftDown;

    fControlDown = (GetKeyState(VK_CONTROL) < 0);
    fShiftDown = (GetKeyState(VK_SHIFT) < 0);

    switch(nChar)
    {
        case 'c':
        case 'C':
        case VK_INSERT:
            if (fControlDown)
                CopyToClipboard();
            break;
    }
}

void CStatsListCtrl::CopyToClipboard()
{
    CString     strText, strLine, strData;
    int         nCount = GetItemCount();
    int         nColumns = 0;
    TCHAR       szBuffer[256];
    LV_COLUMN   ColumnInfo = {0};
    
    ColumnInfo.mask = LVCF_TEXT;
    ColumnInfo.pszText = szBuffer;
    ColumnInfo.cchTextMax = sizeof(szBuffer);

    // build up the column info
    while (GetColumn(nColumns, &ColumnInfo))
    {
        if (!strLine.IsEmpty())
            strLine += _T(",");

        strLine += ColumnInfo.pszText;

        nColumns++;
    }

    strLine += _T("\r\n");
    strData += strLine;
    strLine.Empty();

    // now get the other data
    for (int i = 0; i < nCount; i++)
    {
        for (int j = 0; j < nColumns; j++)
        {
            if (!strLine.IsEmpty())
                strLine += _T(",");
            
            strText = GetItemText(i, j);
    
            strLine += strText;
        }

        strLine += _T("\r\n");

        strData += strLine;
        strLine.Empty();
    }
 
    int nLength = strData.GetLength() + 1;
    nLength *= sizeof(TCHAR);

    HGLOBAL hMem = GlobalAlloc(GPTR, nLength);
    if (hMem)
    {
        memcpy (hMem, strData, nLength);
    
        if (!OpenClipboard())
	    {
		    GlobalFree(hMem);
            return;
	    }

        EmptyClipboard();

        SetClipboardData(CF_UNICODETEXT, hMem);

        CloseClipboard();
    }
}

/*!--------------------------------------------------------------------------
   StatsDialog::StatsDialog
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
StatsDialog::StatsDialog(DWORD dwOptions) :
   m_dwOptions(dwOptions),
   m_ulId(0),
   m_pConfig(NULL),
   m_bAfterInitDialog(FALSE)
{
   m_sizeMinimum.cx = m_sizeMinimum.cy = 0;

   m_hEventThreadKilled = ::CreateEvent(NULL, FALSE, FALSE, NULL);
   Assert(m_hEventThreadKilled);

   // Initialize the array of buttons
   ::ZeroMemory(m_rgBtn, sizeof(m_rgBtn));
   m_rgBtn[INDEX_CLOSE].m_ulId = IDCANCEL;
   m_rgBtn[INDEX_REFRESH].m_ulId = IDC_STATSDLG_BTN_REFRESH;
   m_rgBtn[INDEX_SELECT].m_ulId = IDC_STATSDLG_BTN_SELECT_COLUMNS;
   m_rgBtn[INDEX_CLEAR].m_ulId = IDC_STATSDLG_BTN_CLEAR;

   // Bug 134785 - create the ability to default to an ascending
   // rather than a descending sort.
   m_fSortDirection = !((dwOptions & STATSDLG_DEFAULTSORT_ASCENDING) != 0);
   m_fDefaultSortDirection = m_fSortDirection;

   // Multiply text header width with 2 for width of columns
   m_ColWidthMultiple = 2;
   m_ColWidthAdder = 0;
}


/*!--------------------------------------------------------------------------
   StatsDialog::~StatsDialog
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
StatsDialog::~StatsDialog()
{
   if (m_hEventThreadKilled)
      ::CloseHandle(m_hEventThreadKilled);
   m_hEventThreadKilled = 0;
}

/*!--------------------------------------------------------------------------
   StatsDialog::DoDataExchange
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::DoDataExchange(CDataExchange* pDX)
{
   CBaseDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(StatsDialog)
      // NOTE: the ClassWizard will add DDX and DDV calls here
   DDX_Control(pDX, IDC_STATSDLG_LIST, m_listCtrl);
   //}}AFX_DATA_MAP
}



BEGIN_MESSAGE_MAP(StatsDialog, CBaseDialog)
   //{{AFX_MSG_MAP(StatsDialog)
      ON_COMMAND(IDC_STATSDLG_BTN_REFRESH, OnRefresh)
      ON_COMMAND(IDC_STATSDLG_BTN_SELECT_COLUMNS, OnSelectColumns)
      ON_WM_MOVE()
      ON_WM_SIZE()
      ON_WM_GETMINMAXINFO()
      ON_WM_CONTEXTMENU()
      ON_NOTIFY(LVN_COLUMNCLICK, IDC_STATSDLG_LIST, OnNotifyListControlClick)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// StatsDialog message handlers




/*!--------------------------------------------------------------------------
   StatsDialog::SetColumnInfo
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT StatsDialog::SetColumnInfo(const ContainerColumnInfo *pColumnInfo, UINT cColumnInfo)
{
   if (m_pConfig)
   {
      m_pConfig->InitViewInfo(m_ulId, TRUE, cColumnInfo, m_fDefaultSortDirection, pColumnInfo);
   }
   else
   {
      m_viewInfo.InitViewInfo(cColumnInfo, TRUE, m_fDefaultSortDirection, pColumnInfo);
   }
   return hrOK;
}

/*!--------------------------------------------------------------------------
   StatsDialog::MapColumnToSubitem
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
int StatsDialog::MapColumnToSubitem(UINT nColumnId)
{
   if (m_pConfig)
      return m_pConfig->MapColumnToSubitem(m_ulId, nColumnId);
   else
      return m_viewInfo.MapColumnToSubitem(nColumnId);
}

/*!--------------------------------------------------------------------------
   StatsDialog::MapSubitemToColumn
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
int StatsDialog::MapSubitemToColumn(UINT nSubitemId)
{
   if (m_pConfig)
      return m_pConfig->MapSubitemToColumn(m_ulId, nSubitemId);
   else
      return m_viewInfo.MapSubitemToColumn(nSubitemId);
}

/*!--------------------------------------------------------------------------
   StatsDialog::IsSubitemVisible
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
BOOL StatsDialog::IsSubitemVisible(UINT nSubitemId)
{
   if (m_pConfig)
      return m_pConfig->IsSubitemVisible(m_ulId, nSubitemId);
   else
      return m_viewInfo.IsSubitemVisible(nSubitemId);
}

/*!--------------------------------------------------------------------------
   StatsDialog::RefreshData
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT StatsDialog::RefreshData(BOOL fGrabNewData)
{
   return hrOK;
}


/*!--------------------------------------------------------------------------
   StatsDialog::OnInitDialog
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
BOOL StatsDialog::OnInitDialog()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
        
    RECT  rcWnd, rcBtn;
    
    CBaseDialog::OnInitDialog();
    
    m_bAfterInitDialog = TRUE;
    
    // If this is the first time, get the location of the buttons and
    // list control relative to the edge of the screen
    if (m_sizeMinimum.cx == 0)
    {
        ::GetWindowRect(GetSafeHwnd(), &rcWnd);
        //    m_sizeMinimum.cx = rcWnd.right - rcWnd.left;
        //    m_sizeMinimum.cy = rcWnd.bottom - rcWnd.top;
        m_sizeMinimum.cx = 100;
        m_sizeMinimum.cy = 100;
        
        ::GetClientRect(GetSafeHwnd(), &rcWnd);
        
        // what are the button locations?
        for (int i=0; i<INDEX_COUNT; i++)
        {
            ::GetWindowRect(GetDlgItem(m_rgBtn[i].m_ulId)->GetSafeHwnd(),
                            &rcBtn);
            ScreenToClient(&rcBtn);
            m_rgBtn[i].m_rc.left = rcWnd.right - rcBtn.left;
            m_rgBtn[i].m_rc.right = rcWnd.right - rcBtn.right;
            m_rgBtn[i].m_rc.top = rcWnd.bottom - rcBtn.top;
            m_rgBtn[i].m_rc.bottom = rcWnd.bottom - rcBtn.bottom;
        }
        
        // what is the list control location?
        // The list control top, left is locked in position
        ::GetWindowRect(GetDlgItem(IDC_STATSDLG_LIST)->GetSafeHwnd(), &rcBtn);
        ScreenToClient(&rcBtn);
        m_rcList.left = rcBtn.left;
        m_rcList.top = rcBtn.top;
        
        // The bottom, right corner follows the expansion
        m_rcList.right = rcWnd.right - rcBtn.right;
        m_rcList.bottom = rcWnd.bottom - rcBtn.bottom;
    }

    // If we have a preferred position and size do that
    if (m_pConfig)
    {
        m_pConfig->GetStatsWindowRect(m_ulId, &m_rcPosition);
        m_fSortDirection = m_pConfig->GetSortDirection(m_ulId);
    }
    if (m_pConfig && (m_rcPosition.top != m_rcPosition.bottom))
    {
        MoveWindow(m_rcPosition.left, m_rcPosition.top,
                   m_rcPosition.right - m_rcPosition.left,
                   m_rcPosition.bottom - m_rcPosition.top);
    }
    
    if (m_dwOptions & STATSDLG_FULLWINDOW)
    {
        RECT  rcClient;
        
        // Resize the list control if needed
        GetClientRect(&rcClient);
        OnSize(SIZE_MAXIMIZED,  rcClient.right - rcClient.left,
               rcClient.bottom - rcClient.top);
        
        // Disable the buttons also
        for (int i=0; i<INDEX_COUNT; i++)
        {
            GetDlgItem(m_rgBtn[i].m_ulId)->ShowWindow(SW_HIDE);
            
            if (i != INDEX_CLOSE)
                GetDlgItem(m_rgBtn[i].m_ulId)->EnableWindow(FALSE);
        }
    }
    
    // If we do not have the select columns then we hide and disable
    // the select columns button.
    if ((m_dwOptions & STATSDLG_SELECT_COLUMNS) == 0)
    {
        GetDlgItem(m_rgBtn[INDEX_SELECT].m_ulId)->ShowWindow(SW_HIDE);
        GetDlgItem(m_rgBtn[INDEX_SELECT].m_ulId)->EnableWindow(FALSE);
    }
    
    // If we do not have the clear button then we hide and disable
    // the clear button.
    if ((m_dwOptions & STATSDLG_CLEAR) == 0)
    {
        GetDlgItem(m_rgBtn[INDEX_CLEAR].m_ulId)->ShowWindow(SW_HIDE);
        GetDlgItem(m_rgBtn[INDEX_CLEAR].m_ulId)->EnableWindow(FALSE);
    }
    
    ListView_SetExtendedListViewStyle(GetDlgItem(IDC_STATSDLG_LIST)->GetSafeHwnd(), LVS_EX_FULLROWSELECT);
    
    // Now initialize the headers
    LoadHeaders();
    
    RefreshData(TRUE);
    
    if (m_pConfig)
    {
        Sort( m_pConfig->GetSortColumn(m_ulId) );
    }
    
    if ((m_dwOptions & STATSDLG_FULLWINDOW) == 0)
    {
        GetDlgItem(IDCANCEL)->SetFocus();
        return FALSE;
    }
    
   return TRUE;
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnOK
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnOK()
{
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnCancel
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnCancel()
{
   DeleteAllItems();
   
   DestroyWindow();

   // Explicitly kill this thread.
   AfxPostQuitMessage(0);
}

/*!--------------------------------------------------------------------------
   StatsDialog::PostNcDestroy
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::PostNcDestroy()
{
   // Make sure that this is NULL since this is how we detect that
   // the dialog is showing
   m_hWnd = NULL;
   m_bAfterInitDialog = FALSE;
}

/*!--------------------------------------------------------------------------
   StatsDialog::PreCreateWindow
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
BOOL StatsDialog::PreCreateWindow(CREATESTRUCT& cs)
{
   // Have to refresh the event
   Verify( ResetEvent(m_hEventThreadKilled) );
   return CBaseDialog::PreCreateWindow(cs);
}


/*!--------------------------------------------------------------------------
   StatsDialog::OnRefresh
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnRefresh()
{
   if ((m_dwOptions & STATSDLG_VERTICAL) == 0)
   {
      DeleteAllItems();
   }

   RefreshData(TRUE);
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnSelectColumns
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnSelectColumns()
{
   // We should bring up the columns dialog
   ColumnDlg   columnDlg(NULL);
   ColumnData *pColumnData;
   ULONG    cColumns;
   ULONG    cVisible;
   int         i;
   DWORD    dwWidth;

   if (m_pConfig)
   {
      cColumns = m_pConfig->GetColumnCount(m_ulId);
      cVisible = m_pConfig->GetVisibleColumns(m_ulId);
   }
   else
   {
      cColumns = m_viewInfo.GetColumnCount();
      cVisible = m_viewInfo.GetVisibleColumns();
   }

   pColumnData = (ColumnData *) alloca(sizeof(ColumnData) * cColumns);

   if (m_pConfig)
      m_pConfig->GetColumnData(m_ulId, cColumns, pColumnData);
   else
      m_viewInfo.GetColumnData(cColumns, pColumnData);

   // Save the column width information
   if ((m_dwOptions & STATSDLG_VERTICAL) == 0)
   {
      for (i=0; i<(int) cVisible; i++)
      {
         dwWidth = m_listCtrl.GetColumnWidth(i);
         if (m_pConfig)
            pColumnData[m_pConfig->MapColumnToSubitem(m_ulId, i)].m_dwWidth = dwWidth;
         else
            pColumnData[m_viewInfo.MapColumnToSubitem(i)].m_dwWidth = dwWidth;
      }
   }

   columnDlg.Init(m_pConfig ?
                  m_pConfig->GetColumnInfo(m_ulId) :
                  m_viewInfo.GetColumnInfo(),
               cColumns,
               pColumnData
              );

   if (columnDlg.DoModal() == IDOK)
   {
      if (m_dwOptions & STATSDLG_VERTICAL)
      {
         //$ HACK HACK
         // To save the column info for vertical columns we will save the
         // width data in the first two "columns"
         pColumnData[0].m_dwWidth = m_listCtrl.GetColumnWidth(0);
         pColumnData[1].m_dwWidth = m_listCtrl.GetColumnWidth(1);
      }
      
      // Set the information back in
      if (m_pConfig)
         m_pConfig->SetColumnData(m_ulId, cColumns, pColumnData);
      else
         m_viewInfo.SetColumnData(cColumns, pColumnData);

      // Clear out the data
      DeleteAllItems();
      
      // Remove all of the columns
      if (m_dwOptions & STATSDLG_VERTICAL)
      {
         m_listCtrl.DeleteColumn(1);
         m_listCtrl.DeleteColumn(0);
      }
      else
      {
         for (i=(int) cVisible; --i >= 0; )
            m_listCtrl.DeleteColumn(i);
      }

      // Readd all of the columns
      LoadHeaders();
      
      // Do a refresh
      RefreshData(FALSE);
   }
}

void StatsDialog::OnMove(int x, int y)
{
   if (!m_bAfterInitDialog)
      return;
   
   GetWindowRect(&m_rcPosition);
   if (m_pConfig)
      m_pConfig->SetStatsWindowRect(m_ulId, m_rcPosition);
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnSize
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnSize(UINT nType, int cx, int cy)
{
   RECT  rcWnd;
   RECT  rcBtn;
   RECT  rcDlg;
   
   if (nType == SIZE_MINIMIZED)
      return;

   if (m_dwOptions & STATSDLG_FULLWINDOW)
   {
      // If we're full window, resize the list control to fill
      // the entire client area
      ::SetWindowPos(::GetDlgItem(GetSafeHwnd(), IDC_STATSDLG_LIST), NULL,
                  0, 0, cx, cy, SWP_NOZORDER);
   }
   else if (m_sizeMinimum.cx)
   {

      ::GetClientRect(GetSafeHwnd(), &rcDlg);

      // reposition the buttons

      // The widths are caluclated opposite of the normal order
      // since the positions are relative to the right and bottom.
      for (int i=0; i<INDEX_COUNT; i++)
      {
         ::SetWindowPos(::GetDlgItem(GetSafeHwnd(), m_rgBtn[i].m_ulId),
                     NULL,
                     rcDlg.right - m_rgBtn[i].m_rc.left,
                     rcDlg.bottom - m_rgBtn[i].m_rc.top,
                     m_rgBtn[i].m_rc.left - m_rgBtn[i].m_rc.right,
                     m_rgBtn[i].m_rc.top - m_rgBtn[i].m_rc.bottom,
                     SWP_NOZORDER);
      }

      // resize the list control

      ::SetWindowPos(::GetDlgItem(GetSafeHwnd(), IDC_STATSDLG_LIST),
                  NULL,
                  m_rcList.left,
                  m_rcList.top,
                  rcDlg.right - m_rcList.right - m_rcList.left,
                  rcDlg.bottom - m_rcList.bottom - m_rcList.top,
                  SWP_NOZORDER);
   }
   

   if (m_bAfterInitDialog)
   {
      GetWindowRect(&m_rcPosition);
      if (m_pConfig)
         m_pConfig->SetStatsWindowRect(m_ulId, m_rcPosition);
   }
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnGetMinMaxInfo
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnGetMinMaxInfo(MINMAXINFO *pMinMax)
{
   pMinMax->ptMinTrackSize.x = m_sizeMinimum.cx;
   pMinMax->ptMinTrackSize.y = m_sizeMinimum.cy;
}

/*!--------------------------------------------------------------------------
   StatsDialog::LoadHeaders
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::LoadHeaders()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
    ULONG cVis;
    ULONG i, iPos;
    ULONG ulId;
    CString  st;
    DWORD dwWidth;
    ColumnData  rgColumnData[2];  // used for vertical format
    
    // Load those headers that we have data for
    
    // Go through the column data finding the headers that we have
    if (m_pConfig)
        cVis = m_pConfig->GetVisibleColumns(m_ulId);
    else
        cVis = m_viewInfo.GetVisibleColumns();
    
    if (m_dwOptions & STATSDLG_VERTICAL)
    {
        if (m_pConfig)
            m_pConfig->GetColumnData(m_ulId, 2, rgColumnData);
        else
            m_viewInfo.GetColumnData(2, rgColumnData);
        
        // For the vertical format, the data is on a column
        // Thus we add two columns and fill in the data for the
        // first column
        st.LoadString(IDS_STATSDLG_DESCRIPTION);
        dwWidth = rgColumnData[0].m_dwWidth;
        if (dwWidth == AUTO_WIDTH)
        {
            dwWidth = m_ColWidthAdder + static_cast<DWORD>(m_ColWidthMultiple*m_listCtrl.GetStringWidth((LPCTSTR) st));
        }
        m_listCtrl.InsertColumn(0, st, rgColumnData[0].fmt, dwWidth, 0);
        
        st.LoadString(IDS_STATSDLG_DETAILS);
        dwWidth = rgColumnData[1].m_dwWidth;
        if (dwWidth == AUTO_WIDTH)
        {
            dwWidth = m_ColWidthAdder + static_cast<DWORD>(m_ColWidthMultiple*m_listCtrl.GetStringWidth((LPCTSTR) st));
        }  
        m_listCtrl.InsertColumn(1, st, rgColumnData[1].fmt, dwWidth, 1);
        
        // Now go through and add the rows for each of our "columns"
        for (i=0; i<cVis; i++)
        {
            // Now get the info for iPos
            if (m_pConfig)
                ulId = m_pConfig->GetStringId(m_ulId, i);
            else
                ulId = m_viewInfo.GetStringId(i);
            st.LoadString(ulId);
            Assert(st.GetLength());
            
            m_listCtrl.InsertItem(i, _T(""));
            m_listCtrl.SetItemText(i, 0, (LPCTSTR) st);
        }
    }
    else
    {
        // For the normal horizontal format, the data is on a row
        // so we need to add the various columnar data
        for (i=0; i<cVis; i++)
        {
			int fmt = LVCFMT_LEFT;

            iPos = MapColumnToSubitem(i);
            
            // Now get the info for iPos
            if (m_pConfig)
                ulId = m_pConfig->GetStringId(m_ulId, i);
            else
                ulId = m_viewInfo.GetStringId(i);

            st.LoadString(ulId);
            Assert(st.GetLength());
            
            if (m_pConfig)
			{
                dwWidth = m_pConfig->GetColumnWidth(m_ulId, i);
				m_pConfig->GetColumnData(m_ulId, i, 1, rgColumnData);
				fmt = rgColumnData[0].fmt;
			}
            else
			{
                dwWidth = m_viewInfo.GetColumnWidth(i);
				m_viewInfo.GetColumnData(i, 1, rgColumnData);
				fmt = rgColumnData[0].fmt;
			}
			
            if (dwWidth == AUTO_WIDTH)
            {
                dwWidth = m_ColWidthAdder + static_cast<DWORD>(m_ColWidthMultiple*m_listCtrl.GetStringWidth((LPCTSTR) st));
            }  
            m_listCtrl.InsertColumn(i, st, fmt, dwWidth, iPos);
        }
    }
}

HRESULT StatsDialog::AddToContextMenu(CMenu* pMenu)
{
   return S_OK;
}


/*!--------------------------------------------------------------------------
   StatsDialog::OnContextMenu
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnContextMenu(CWnd *pWnd, CPoint pos)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
    CMenu menu;
    CString  st;
    
    if ((m_dwOptions & STATSDLG_CONTEXTMENU) == 0)
        return;
    
    if (pWnd->GetDlgCtrlID() != IDC_STATSDLG_LIST)
        return;
    
    // Bring up a context menu if we need to
    menu.CreatePopupMenu();
    
    st.LoadString(IDS_STATSDLG_MENU_REFRESH);
    menu.AppendMenu(MF_STRING, IDC_STATSDLG_BTN_REFRESH, st);
    
    if (m_dwOptions & STATSDLG_SELECT_COLUMNS)
    {
        st.LoadString(IDS_STATSDLG_MENU_SELECT);
        menu.AppendMenu(MF_STRING, IDC_STATSDLG_BTN_SELECT_COLUMNS, st);
    }
    
    //virtual override to add additional context menus
    AddToContextMenu(&menu);
    
    menu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        pos.x,
                        pos.y,
                        this,
                        NULL);
}


void StatsDialog::OnNotifyListControlClick(NMHDR *pNmHdr, LRESULT *pResult)
{
   NM_LISTVIEW *  pnmlv = reinterpret_cast<NM_LISTVIEW *>(pNmHdr);

   if (m_pConfig)
      m_pConfig->SetSortColumn(m_ulId, pnmlv->iSubItem);

   // Call through to the user to sort
   Sort(pnmlv->iSubItem);

   if (m_pConfig)
      m_pConfig->SetSortDirection(m_ulId, m_fSortDirection);
}


void StatsDialog::Sort(UINT nColumn)
{
   // Default is to do nothing
}

void StatsDialog::PreDeleteAllItems()
{
}

void StatsDialog::DeleteAllItems()
{
   PreDeleteAllItems();
   m_listCtrl.DeleteAllItems();
}

void StatsDialog::PostRefresh()
{
   if (GetSafeHwnd())
      PostMessage(WM_COMMAND, IDC_STATSDLG_BTN_REFRESH);
}

/*!--------------------------------------------------------------------------
   StatsDialog::SetColumnWidths
      Loops through all items and calculates the max width for columns
        in a listbox.
   Author: EricDav
 ---------------------------------------------------------------------------*/
void StatsDialog::SetColumnWidths(UINT uNumColumns)
{
    // Set the default column widths to the width of the widest column
    int * aColWidth = (int *) alloca(uNumColumns * sizeof(int));
    int nRow, nCol;
    CString strTemp;
    
    ZeroMemory(aColWidth, uNumColumns * sizeof(int));

    // for each item, loop through each column and calculate the max width
    for (nRow = 0; nRow < m_listCtrl.GetItemCount(); nRow++)
    {
        for (nCol = 0; nCol < (int) uNumColumns; nCol++)
        {
            strTemp = m_listCtrl.GetItemText(nRow, nCol);
            if (aColWidth[nCol] < m_listCtrl.GetStringWidth(strTemp))
                aColWidth[nCol] = m_listCtrl.GetStringWidth(strTemp);
        }
    }
    
    // now update the column widths based on what we calculated
    for (nCol = 0; nCol < (int) uNumColumns; nCol++)
    {
        // GetStringWidth doesn't seem to report the right thing,
        // so we have to add a fudge factor of 15.... oh well.
        m_listCtrl.SetColumnWidth(nCol, aColWidth[nCol] + 15);
    }
}


void StatsDialog::SetConfigInfo(ConfigStream *pConfig, ULONG ulId)
{
   m_pConfig = pConfig;
   m_ulId = ulId;
}

void StatsDialog::SetPosition(RECT rc)
{
   m_rcPosition = rc;
}

void StatsDialog::GetPosition(RECT *prc)
{
   *prc = m_rcPosition;
}

void CreateNewStatisticsWindow(StatsDialog *pWndStats,
                        HWND hWndParent,
                        UINT  nIDD)
{                         
   ModelessThread *  pMT;

   // If the dialog is still up, don't create a new one
   if (pWndStats->GetSafeHwnd())
   {
      ::SetActiveWindow(pWndStats->GetSafeHwnd());
      return;
   }

   pMT = new ModelessThread(hWndParent,
                      nIDD,
                      pWndStats->GetSignalEvent(),
                      pWndStats);
   pMT->CreateThread();
}

void WaitForStatisticsWindow(StatsDialog *pWndStats)
{
   if (pWndStats->GetSafeHwnd())
   {
      // Post a cancel to that window
      // Do an explicit post so that it executes on the other thread
      pWndStats->PostMessage(WM_COMMAND, IDCANCEL, 0);

      // Now we need to wait for the event to be signalled so that
      // its memory can be cleaned up
      WaitForSingleObject(pWndStats->GetSignalEvent(), INFINITE);
   }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\task.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	Task.h
        Prototypes for the task holder/enumerator object
		
    FILE HISTORY:
	
*/

#ifndef _TASK_H
#define _TASK_H

typedef CArray<MMC_TASK, MMC_TASK&> CTaskListArray;

class CTaskList : public IEnumTASK
{
public:
    CTaskList();
    virtual ~CTaskList();

	DeclareIUnknownMembers(IMPL)

    // IEnumTASK members
    STDMETHOD(Next)(ULONG celt, MMC_TASK * rgelt, ULONG * pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumTASK ** ppEnumTask);

public:
    // helpers
    HRESULT     AddTask(LPOLESTR        pszMouseOverBitmapResource,
                        LPOLESTR        pszMouseOffBitmapResource,
                        LPOLESTR        pszText,
                        LPOLESTR        pszHelpString,
                        MMC_ACTION_TYPE mmcAction,
                        long            nCommandID);

    HRESULT     AddTask(LPOLESTR        pszMouseOverBitmapResource,
                        LPOLESTR        pszMouseOffBitmapResource,
                        LPOLESTR        pszText,
                        LPOLESTR        pszHelpString,
                        MMC_ACTION_TYPE mmcAction,
                        LPOLESTR        pszActionURLorScript);
protected:
    HRESULT     _Clone(int m_nIndex, CTaskListArray & arrayTasks);
    BOOL        FillTask(MMC_TASK *  pmmcTask, int nIndex);

protected:
    CTaskListArray  m_arrayTasks;
    ULONG           m_uIndex;
    long            m_cRef;
};

#endif _TASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\timeofday.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	timeofday.h
		Definition of timeofday convenient functions 

    FILE HISTORY:
        
*/
#ifndef ___TIME_OF_DAY_H__
#define ___TIME_OF_DAY_H__

#define	LOGHOURSDLL _T("loghours.dll")
#define DIALINHOURSEXAPI "DialinHoursDialogEx"

///////////////////////////////////////////////////////////////////////////////
// Flags for LogonScheduleDialogEx and DialinHoursDialogEx
///////////////////////////////////////////////////////////////////////////////
// The input data is in GMT
#define SCHED_FLAG_INPUT_GMT        0x00000000  // default

// The input data is in local time.
#define SCHED_FLAG_INPUT_LOCAL_TIME 0x00000001

// hour map is an array of bit, each bit maps to a hour
// total 1 week(7 days), 7 * 24 = 21 BYTES
void ReverseHourMap(BYTE *map, int nByte);
void ShiftHourMap(BYTE *map, int nByte, int nShiftByte);

HRESULT	OpenTimeOfDayDlgEx(
                        HWND hwndParent,       // parent window
                        BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                        LPCTSTR pszTitle,     // dialog title
                        DWORD	dwFlags
);

typedef HRESULT (APIENTRY *PFN_LOGONSCHEDULEDIALOGEX)(
                        HWND hwndParent,       // parent window
                        BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                        LPCTSTR pszTitle,     // dialog title
                        DWORD	dwFlags
);
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\timeofday.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	timeofday.cpp
		Implementation of convenient functions to start timeofday dialog

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "timeofday.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// hour map ( one bit for an hour of a week )
static BYTE		bitSetting[8] = { 0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};

//+---------------------------------------------------------------------------
//
// Function:  ReverseHourMap
//
// Synopsis:  reverse each byte in the hour map
//
// we have to do this because LogonUI changes the way HourMap is stored(they
// reversed all the bit. We need to do this so our conversion code can leave
// intact.
//
// Arguments: [in] BYTE* map - hour map
//            [in] INT nByte - how many bytes are in this hour map
//
// History:   byao  4/10/98 10:33:57 PM
//
//+---------------------------------------------------------------------------
void ReverseHourMap(BYTE *map, int nByte)
{
    int i, j, temp;

    for (i=0; i<nByte; i++)
    {
        temp = 0;
        for (j=0;j<8;j++)
        {
            // set the value temp
            if ( map[i] & bitSetting[j] )
            {
                temp |= bitSetting[7-j];
            }
        }
        map[i] = (BYTE) temp;
    }
}

void ShiftHourMap(BYTE* map, int nByte, int nShiftByte)
{
    ASSERT(nShiftByte);
    ASSERT(nByte > abs(nShiftByte));

    nShiftByte = (nByte + nShiftByte) % nByte;

    BYTE*   pTemp = (BYTE*)_alloca(nShiftByte);

    // put the tail to the buffer
    memmove(pTemp, map + nByte - nShiftByte, nShiftByte);
    // shift the body to right
    memmove(map + nShiftByte, map, nByte - nShiftByte);
    // put the tail back to the head
    memcpy(map, pTemp, nShiftByte);
}

HRESULT	OpenTimeOfDayDlgEx(
                        HWND hwndParent,       // parent window
                        BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                        LPCTSTR pszTitle,     // dialog title
                        DWORD   dwFlags
)
{
    PFN_LOGONSCHEDULEDIALOGEX		pfnLogonScheduleDialog = NULL;
    HMODULE						hLogonScheduleDLL      = NULL;
    HRESULT						hr = S_OK;
 
    // ReverseHourMap() will reverse each byte of the hour map, basically
    // reverse every bit in the byte.
    // we have to do this because LogonUI changes the way HourMap is stored(they
    // reversed all the bit. We need to do this so our conversion code can leave
    // intact.
    //
    // We reverse it here so it can be understood by the LogonSchedule api
    //
    ReverseHourMap(*pprgbData,21);

    hLogonScheduleDLL = LoadLibrary(LOGHOURSDLL);
    if ( NULL == hLogonScheduleDLL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AfxMessageBox(IDS_ERR_TOD_LOADLOGHOURDLL);
        goto L_ERR;
	}

	// load the API pointer
    pfnLogonScheduleDialog = (PFN_LOGONSCHEDULEDIALOGEX) GetProcAddress(hLogonScheduleDLL, DIALINHOURSEXAPI);

    if ( NULL == pfnLogonScheduleDialog )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AfxMessageBox(IDS_ERR_TOD_FINDLOGHOURSAPI);

        goto L_ERR;
    }

    //
    // now we do have this DLL, call the API
    //
    hr = pfnLogonScheduleDialog(hwndParent, pprgbData, pszTitle, dwFlags);
    if (FAILED(hr)) goto L_ERR;

    // We need to reverse it first so our conversion code can understand it.
    //
    ReverseHourMap(*pprgbData,21);

L_ERR:
    if(hLogonScheduleDLL != NULL)
        FreeLibrary(hLogonScheduleDLL);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\xstream.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	xstream.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tfschar.h"
#include "xstream.h"

/*!--------------------------------------------------------------------------
	XferStream::XferStream
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
XferStream::XferStream(IStream *pstm, Mode mode)
{
	m_spstm.Set(pstm);
	m_mode = mode;
	m_dwSize = 0;
}

/*!--------------------------------------------------------------------------
	XferStream::XferDWORD
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferDWORD(ULONG ulId, DWORD *pdwData)
{
	ULONG	id;
	HRESULT	hr = hrOK;

	CORg( _XferObjectId(&ulId) );

	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_DWORD );

	if (XFER_TYPE_FROM_TAG(ulId) != XFER_DWORD)
		return E_INVALIDARG;

	CORg( _XferDWORD(pdwData) );
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferCString(ULONG ulId, CString *pstData)
{
	HRESULT	hr = hrOK;
	ULONG	cbLength;
	LPWSTR	pswzData;

	CORg( _XferObjectId(&ulId) );

	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_STRING );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_STRING)
		return E_INVALIDARG;

    CORg( _XferCString(pstData) );

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferLARGEINTEGER
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferLARGEINTEGER(ULONG ulId, LARGE_INTEGER *pliData)
{
	ULONG	id;
	HRESULT	hr = hrOK;

	CORg( _XferObjectId(&ulId) );

	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_LARGEINTEGER );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_LARGEINTEGER)
		return E_INVALIDARG;

	CORg( _XferDWORD(&pliData->LowPart) );
	CORg( _XferLONG(&pliData->HighPart) );
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferDWORDArray
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferDWORDArray(ULONG ulId, ULONG *pcArray, DWORD *pdwArray)
{
	HRESULT	hr = hrOK;
	ULONG	i;

	CORg( _XferObjectId(&ulId) );
	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_DWORD_ARRAY );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_DWORD_ARRAY)
		return E_INVALIDARG;

	CORg( _XferDWORD(pcArray) );

	for (i=0; i<*pcArray; i++)
	{
		// Xfer each dword
		hr = _XferDWORD(pdwArray+i);
		if (!FHrSucceeded(hr))
			break;
	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferCStringArray
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferCStringArray(ULONG ulId, CStringArray *pstrArray)
{
	HRESULT	hr = hrOK;
	ULONG	i, cArray;
	LPWSTR	pswzData;

	CORg( _XferObjectId(&ulId) );

    Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_STRING_ARRAY );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_STRING_ARRAY)
		return E_INVALIDARG;

	if (m_mode == XferStream::MODE_WRITE)
    {
		cArray = (ULONG)pstrArray->GetSize();
    }

	CORg( _XferDWORD(&cArray) );

	if (m_mode == XferStream::MODE_READ)
    {
        pstrArray->SetSize(cArray);
    }

    for (i = 0; i < cArray; i++)
	{
        _XferCString( &((*pstrArray)[i]) );
		if (!FHrSucceeded(hr))
			break;
    }

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferDWORDArray
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferDWORDArray(ULONG ulId, CDWordArray * pdwArray)
{
	HRESULT	hr = hrOK;
	ULONG	i, cArray;

	CORg( _XferObjectId(&ulId) );
	
    Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_DWORD_ARRAY );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_DWORD_ARRAY)
		return E_INVALIDARG;

	if (m_mode == XferStream::MODE_WRITE)
    {
		cArray = (ULONG)pdwArray->GetSize();
    }

	CORg( _XferDWORD(&cArray) );

	if (m_mode == XferStream::MODE_READ)
    {
        pdwArray->SetSize(cArray);
    }

	for (i = 0; i < cArray; i++)
	{
		// Xfer each dword
		hr = _XferDWORD( &((*pdwArray)[i]) );
		if (!FHrSucceeded(hr))
			break;
	}

Error:
	return hr;
}




/*!--------------------------------------------------------------------------
	XferStream::_XferObjectId
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferObjectId(ULONG *pulId)
{
	ULONG	id = 0;
	HRESULT	hr = hrOK;
	
	if (m_mode == XferStream::MODE_WRITE)
		id = *pulId;
	hr = _XferDWORD(&id);
	*pulId = id;

	return hr;
}


/*!--------------------------------------------------------------------------
	XferStream::_XferDWORD
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferDWORD(DWORD *pdw)
{
	ULONG	cbBytes;
	HRESULT	hr = hrOK;

	switch (m_mode)
	{
		case XferStream::MODE_READ:
			hr = m_spstm->Read(pdw, sizeof(DWORD), &cbBytes);
			Assert(cbBytes == sizeof(DWORD));
			if (cbBytes != sizeof(DWORD))
				hr = E_FAIL;
			break;
		case XferStream::MODE_WRITE:
			hr = m_spstm->Write(pdw, sizeof(DWORD), &cbBytes);
			Assert(cbBytes == sizeof(DWORD));	
			break;
		case XferStream::MODE_SIZE:
			m_dwSize += sizeof(DWORD);
			break;
		default:
			hr = E_INVALIDARG;
			Panic1("Unknown XferStream mode! %d\n", m_mode);
			break;
	}
	
	return hr;
}


/*!--------------------------------------------------------------------------
	XferStream::_XferLONG
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferLONG(LONG * pdl)
{
	return _XferDWORD((DWORD *) pdl);
}

/*!--------------------------------------------------------------------------
	XferStream::_XferCString
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferCString(CString * pstData)
{
	HRESULT	hr = hrOK;
    ULONG   cbLength;
    LPWSTR  pswzData;

    Assert(pstData);
    
    switch (m_mode)
	{
		case XferStream::MODE_READ:
			hr = _XferDWORD(&cbLength);

			if (FHrSucceeded(hr))
			{
				pswzData = (LPWSTR) alloca(cbLength);
				hr = _XferBytes((LPBYTE) pswzData, cbLength);
				
				if (FHrSucceeded(hr))
					*pstData = W2CT(pswzData);
			}
			
			break;

		case XferStream::MODE_SIZE:
		case XferStream::MODE_WRITE:
			cbLength = (pstData->GetLength()+1) * sizeof(WCHAR);
			// round the length up to a multiple of 4
			cbLength  = (cbLength + 3) & 0xFFFFFFFC;
			
			hr = _XferDWORD(&cbLength);

			if (FHrSucceeded(hr))
			{
				pswzData = (LPWSTR) alloca(cbLength);
				StrCpyWFromT(pswzData, (LPCTSTR) *pstData);
			
				hr = _XferBytes((LPBYTE) pswzData, cbLength);
			}
			break;
			
		default:
			hr = E_INVALIDARG;
			Panic1("Unknown XferStream mode! %d\n", m_mode);
			break;
	}

    return hr;
}


/*!--------------------------------------------------------------------------
	XferStream::_XferBytes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferBytes(LPBYTE pData, ULONG cbLength)
{
	ULONG	cbBytes;
	HRESULT	hr = hrOK;

	switch (m_mode)
	{
		case XferStream::MODE_READ:
			hr = m_spstm->Read(pData, cbLength, &cbBytes);
			Assert(cbBytes == cbLength);
			break;
		case XferStream::MODE_WRITE:
			hr = m_spstm->Write(pData, cbLength, &cbBytes);
			Assert(cbBytes == cbLength);	
			break;
		case XferStream::MODE_SIZE:
			m_dwSize += cbLength;
			break;
		default:
			hr = E_INVALIDARG;
			Panic1("Unknown XferStream mode! %d\n", m_mode);
			break;
	}
	
	return hr;
}
/*!--------------------------------------------------------------------------
	XferStream::XferColumnData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferColumnData(ULONG ulId, ULONG *pcData, ColumnData *pData)
{
	HRESULT	hr = hrOK;
	ULONG	i;

	CORg( _XferObjectId(&ulId) );
	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_COLUMNDATA_ARRAY );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_COLUMNDATA_ARRAY)
		return E_INVALIDARG;

	CORg( _XferDWORD(pcData) );

	for (i=0; i<*pcData; i++)
	{
		// Xfer each dword
		hr = _XferLONG(&(pData[i].m_nPosition));
		Assert(pData[i].m_nPosition != 0);
		if (FHrSucceeded(hr))
			hr = _XferDWORD(&(pData[i].m_dwWidth));

		if (!FHrSucceeded(hr))
			break;
	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferRect
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferRect(ULONG ulId, RECT *prc)
{
	HRESULT	hr = hrOK;

	CORg( _XferObjectId(&ulId) );
	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_RECT );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_RECT)
		return E_INVALIDARG;

	CORg( _XferDWORD((DWORD *) &(prc->top)) );
	CORg( _XferDWORD((DWORD *) &(prc->left)) );
	CORg( _XferDWORD((DWORD *) &(prc->bottom)) );
	CORg( _XferDWORD((DWORD *) &(prc->right)) );

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addbootp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	AddBootp.cpp
		dialog to add a bootp entry
	
	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "addbootp.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddBootpEntry dialog


CAddBootpEntry::CAddBootpEntry
(
	ITFSNode *  pNode,	
	LPCTSTR		pServerAddress,
	CWnd*		pParent /*=NULL*/
)
	: CBaseDialog(CAddBootpEntry::IDD, pParent),
	  m_pBootpTable(NULL)
{
	//{{AFX_DATA_INIT(CAddBootpEntry)
	m_strFileName = _T("");
	m_strFileServer = _T("");
	m_strImageName = _T("");
	//}}AFX_DATA_INIT

	m_strServerAddress = pServerAddress;
	m_spNode.Set(pNode);
}

CAddBootpEntry::~CAddBootpEntry()
{
	if (m_pBootpTable)
		free(m_pBootpTable);
}

void CAddBootpEntry::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddBootpEntry)
	DDX_Control(pDX, IDOK, m_buttonOk);
	DDX_Control(pDX, IDC_EDIT_BOOTP_IMAGE_NAME, m_editImageName);
	DDX_Control(pDX, IDC_EDIT_BOOTP_FILE_NAME, m_editFileName);
	DDX_Control(pDX, IDC_EDIT_BOOTP_FILE_SERVER, m_editFileServer);
	DDX_Text(pDX, IDC_EDIT_BOOTP_FILE_NAME, m_strFileName);
	DDX_Text(pDX, IDC_EDIT_BOOTP_FILE_SERVER, m_strFileServer);
	DDX_Text(pDX, IDC_EDIT_BOOTP_IMAGE_NAME, m_strImageName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddBootpEntry, CBaseDialog)
	//{{AFX_MSG_MAP(CAddBootpEntry)
	ON_EN_CHANGE(IDC_EDIT_BOOTP_FILE_NAME, OnChangeEditBootpFileName)
	ON_EN_CHANGE(IDC_EDIT_BOOTP_FILE_SERVER, OnChangeEditBootpFileServer)
	ON_EN_CHANGE(IDC_EDIT_BOOTP_IMAGE_NAME, OnChangeEditBootpImageName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddBootpEntry message handlers

BOOL CAddBootpEntry::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	HandleActivation();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

DWORD CAddBootpEntry::GetBootpTable()
{
	DWORD dwError = 0;
	LPDHCP_SERVER_CONFIG_INFO_V4 pServerConfig = NULL;

    BEGIN_WAIT_CURSOR;
    dwError = ::DhcpServerGetConfigV4(m_strServerAddress, &pServerConfig);
    END_WAIT_CURSOR;

	if (dwError != ERROR_SUCCESS)
	{
		::DhcpMessageBox(dwError);
		return dwError;
	}

	Assert(pServerConfig);

	if (m_pBootpTable)
	{
		delete m_pBootpTable;
		m_pBootpTable = NULL;
	}

	m_nBootpTableLength = pServerConfig->cbBootTableString;
	
	if (m_nBootpTableLength > 0)
	{
		m_pBootpTable = (WCHAR *) malloc(m_nBootpTableLength);
		if (!m_pBootpTable)
			return ERROR_NOT_ENOUGH_MEMORY;

		// copy the bootp table into our local storage so we can modify it
		::CopyMemory(m_pBootpTable, pServerConfig->wszBootTableString, m_nBootpTableLength);
	}

	// release the rpc memory
	::DhcpRpcFreeMemory(pServerConfig);

	return dwError;
}

DWORD CAddBootpEntry::AddBootpEntryToTable()
{
	UpdateData();

	// calculate the length of the new entry.  Entries are stored as:
	// Image,FileServer,FileName<NULL>
	// So the length is the length of the three strings plus 3 characters
	// (two separators and a terminator).  There is also a null terminator
	// for the entire string.
	int nNewBootpEntrySize = (m_strImageName.GetLength() + 
							  m_strFileServer.GetLength() + 
							  m_strFileName.GetLength() + 3) * sizeof(WCHAR);

	int nNewBootpTableLength, nStartIndex;
	nNewBootpTableLength = m_nBootpTableLength + nNewBootpEntrySize;

	WCHAR * pNewBootpTable;
	if (m_nBootpTableLength > 0)
	{
		nStartIndex = m_nBootpTableLength/sizeof(WCHAR) - 1;
		pNewBootpTable = (WCHAR *) realloc(m_pBootpTable, nNewBootpTableLength);
	}
	else
	{
		nStartIndex = 0;
		nNewBootpEntrySize += sizeof(WCHAR);  // for the entire string terminator
		nNewBootpTableLength += sizeof(WCHAR);
		pNewBootpTable = (WCHAR *) malloc(nNewBootpEntrySize);
	}

	if (pNewBootpTable == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;

	// format the new entry
	CString strNewEntry;
	strNewEntry.Format(_T("%s,%s,%s"), 
					   (LPCTSTR)m_strImageName,
					   (LPCTSTR)m_strFileServer,
					   (LPCTSTR)m_strFileName);
	
	// copy in the new entry
	CopyMemory(&pNewBootpTable[nStartIndex], 
		       strNewEntry, 
			   strNewEntry.GetLength() * sizeof(WCHAR));


	// set the null terminator for this entry and the entire list
	pNewBootpTable[(nNewBootpTableLength/sizeof(WCHAR)) - 2] = '\0';
	pNewBootpTable[(nNewBootpTableLength/sizeof(WCHAR)) - 1] = '\0';

	m_pBootpTable = pNewBootpTable;
	m_nBootpTableLength = nNewBootpTableLength;

	return ERROR_SUCCESS;
}

DWORD CAddBootpEntry::SetBootpTable()
{
	DWORD dwError = 0;
	DHCP_SERVER_CONFIG_INFO_V4 dhcpServerInfo;

	::ZeroMemory(&dhcpServerInfo, sizeof(dhcpServerInfo));

	dhcpServerInfo.cbBootTableString = m_nBootpTableLength;
	dhcpServerInfo.wszBootTableString = m_pBootpTable;

	BEGIN_WAIT_CURSOR;
    dwError = ::DhcpServerSetConfigV4(m_strServerAddress,
									  Set_BootFileTable,
									  &dhcpServerInfo);
    END_WAIT_CURSOR;

	if (dwError != ERROR_SUCCESS)
	{
		::DhcpMessageBox(dwError);
	}

	return dwError;
}

void CAddBootpEntry::OnOK() 
{
	// If we haven't gotten the information yet, then do so now
	if (m_pBootpTable == NULL)
	{
		if (GetBootpTable() != ERROR_SUCCESS)
			return;
	}

	// Add whatever the user entered to the table
	if (AddBootpEntryToTable() != ERROR_SUCCESS)
		return;

	// write the table out 
	if (SetBootpTable() != ERROR_SUCCESS)
		return;

	m_editImageName.SetWindowText(_T(""));
	m_editFileName.SetWindowText(_T(""));
	m_editFileServer.SetWindowText(_T(""));

	m_editImageName.SetFocus();

	// tell the bootp folder to update it's contents
	// this is the easy way to update the info... we could create
	// and individual entry and add it, but we'll just let the 
	// refresh mechanism handle it
	CDhcpBootp * pBootp = GETHANDLER(CDhcpBootp, m_spNode);

	pBootp->OnRefresh(m_spNode, NULL, 0, 0, 0);
}

void CAddBootpEntry::OnChangeEditBootpFileName() 
{
	HandleActivation();
}

void CAddBootpEntry::OnChangeEditBootpFileServer() 
{
	HandleActivation();
}

void CAddBootpEntry::OnChangeEditBootpImageName() 
{
	HandleActivation();
}

void CAddBootpEntry::HandleActivation()
{
	UpdateData();

	if ( (m_strImageName.GetLength() > 0) &&
		 (m_strFileName.GetLength() > 0) &&
	     (m_strFileServer.GetLength() > 0) )
	{
		m_buttonOk.EnableWindow(TRUE);
	}
	else
	{
		m_buttonOk.EnableWindow(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addbootp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AddBootp.h
		Dialog to add a bootp entry

	FILE HISTORY:
        
*/

#if !defined(AFX_ADDBOOTP_H__7B0D5D17_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
#define AFX_ADDBOOTP_H__7B0D5D17_B501_11D0_AB8E_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddBootpEntry dialog

class CAddBootpEntry : public CBaseDialog
{
// Construction
public:
	CAddBootpEntry(ITFSNode * pNode, LPCTSTR pServerAddress, CWnd* pParent = NULL);   // standard constructor
	~CAddBootpEntry();

// Dialog Data
	//{{AFX_DATA(CAddBootpEntry)
	enum { IDD = IDD_BOOTP_NEW };
	CButton	m_buttonOk;
	CEdit	m_editImageName;
	CEdit	m_editFileName;
	CEdit	m_editFileServer;
	CString	m_strFileName;
	CString	m_strFileServer;
	CString	m_strImageName;
	//}}AFX_DATA

	DWORD GetBootpTable();
	DWORD AddBootpEntryToTable();
	DWORD SetBootpTable();

	void HandleActivation();

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddBootpEntry::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddBootpEntry)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddBootpEntry)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnChangeEditBootpFileName();
	afx_msg void OnChangeEditBootpFileServer();
	afx_msg void OnChangeEditBootpImageName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CString		m_strServerAddress;
	WCHAR *		m_pBootpTable;
	int			m_nBootpTableLength;
	SPITFSNode  m_spNode;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDBOOTP_H__7B0D5D17_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\common\xstream.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	xstream.h
		
    FILE HISTORY:
        
*/

#ifndef _XSTREAM_H
#define _XSTREAM_H


struct ColumnData
{
	ColumnData()
	{
		fmt = LVCFMT_LEFT;
	}
	// This value may be positive or negative.  If >0, then this column
	// is visible.  If <0 then the column is invisible.  In either case
	// the absolute value is the relative position of the column (this
	// position is used only for the "select columns" dialog.
	// If the value is ==0 then it's an error.
	LONG	m_nPosition;

	// Width of the column
	DWORD	m_dwWidth;

	// Format of the column:
	// LVCFMT_LEFT  Text is left-aligned. 
	// LVCFMT_RIGHT Text is right-aligned 
	int fmt;
};



class XferStream
{
public:
	enum Mode
	{
		MODE_READ,
		MODE_WRITE,
		MODE_SIZE
	};

	XferStream(IStream *pstm, Mode mode);

	HRESULT	XferDWORD(ULONG ulId, DWORD *pdwData);
	HRESULT XferCString(ULONG ulId, CString *pstData);
	HRESULT XferLARGEINTEGER(ULONG ulId, LARGE_INTEGER *pliData);
	HRESULT XferRect(ULONG ulId, RECT *prc);

	HRESULT	XferDWORDArray(ULONG ulId, ULONG *pcArray, DWORD *pdwArray);
	HRESULT	XferColumnData(ULONG ulId, ULONG *pcData, ColumnData *pdwData);

    HRESULT	XferDWORDArray(ULONG ulId, CDWordArray * pdwArray);
    HRESULT	XferCStringArray(ULONG ulId, CStringArray * pstrArray);

	DWORD	GetSize() { return m_dwSize; };

private:
	HRESULT	_XferCString(CString * pstData);
	HRESULT	_XferLONG(LONG *plData);
	HRESULT	_XferDWORD(DWORD *pdwData);
	HRESULT _XferBytes(LPBYTE pData, ULONG cbLength);
	HRESULT	_XferObjectId(ULONG *pulId);

	DWORD		m_dwSize;
	SPIStream	m_spstm;
	XferStream::Mode m_mode;
};

#define XFER_DWORD			    0x0001
#define XFER_STRING			    0x0002
#define XFER_COLUMNDATA		    0x0003
#define XFER_LARGEINTEGER       0x0004
#define XFER_RECT				0x0005

#define XFER_ARRAY			    0x8000
#define XFER_DWORD_ARRAY	    (XFER_DWORD | XFER_ARRAY)
#define XFER_COLUMNDATA_ARRAY   (XFER_COLUMNDATA | XFER_ARRAY)
#define XFER_STRING_ARRAY       (XFER_STRING | XFER_ARRAY)

#define XFER_TAG(id,type)	    (((id) << 16) | (type))

#define XFER_TYPE_FROM_TAG(x)	( 0x0000FFFF & (x) )
#define XFER_ID_FROM_TAG(x)		( 0x0000FFFF & ( (x) >> 16 ))

#endif _XSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addexcl.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	AddExcl.cpp
		Dialog to add an exclusion range

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "scope.h"
#include "mscope.h"
#include "addexcl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddExclusion dialog

CAddExclusion::CAddExclusion(ITFSNode * pScopeNode,
                             BOOL       bMulticast,
							 CWnd* pParent /*=NULL*/)
	: CBaseDialog(CAddExclusion::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddExclusion)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_spScopeNode.Set(pScopeNode);
    m_bMulticast = bMulticast;
}


void CAddExclusion::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddExclusion)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_EXCLUSION_FROM, m_ipaStart);
    DDX_Control(pDX, IDC_IPADDR_EXCLUSION_TO, m_ipaEnd);
}


BEGIN_MESSAGE_MAP(CAddExclusion, CBaseDialog)
	//{{AFX_MSG_MAP(CAddExclusion)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddExclusion message handlers

BOOL CAddExclusion::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddExclusion::OnOK() 
{
	CDhcpIpRange dhcpExclusionRange;
	DWORD dwStart, dwEnd, dwError = 0;

	m_ipaStart.GetAddress(&dwStart);
	dhcpExclusionRange.SetAddr(dwStart, TRUE);

	m_ipaEnd.GetAddress(&dwEnd);
	if (!dwEnd)
		dwEnd = dwStart;

	dhcpExclusionRange.SetAddr(dwEnd, FALSE);

	BEGIN_WAIT_CURSOR;
	dwError = IsValidExclusion(dhcpExclusionRange);
	if (dwError != 0)
	{
		::DhcpMessageBox(dwError);
		return;
	}

    dwError = AddExclusion(dhcpExclusionRange);
	END_WAIT_CURSOR;
    
    if (dwError != 0)
	{
		::DhcpMessageBox(dwError);
		return;
	}

	m_ipaStart.ClearAddress();
	m_ipaEnd.ClearAddress();

	m_ipaStart.SetFocus();

	//CBaseDialog::OnOK();
}

DWORD 
CAddExclusion::IsValidExclusion(CDhcpIpRange & dhcpExclusionRange)
{
    if (m_bMulticast)
    {
        CDhcpMScope * pScope = GETHANDLER(CDhcpMScope, m_spScopeNode);
        return pScope->IsValidExclusion(dhcpExclusionRange);
    }
    else
    {
        CDhcpScope * pScope = GETHANDLER(CDhcpScope, m_spScopeNode);
        return pScope->IsValidExclusion(dhcpExclusionRange);
    }
}

DWORD 
CAddExclusion::AddExclusion(CDhcpIpRange & dhcpExclusionRange)
{
    if (m_bMulticast)
    {
        CDhcpMScope * pScope = GETHANDLER(CDhcpMScope, m_spScopeNode);
        return pScope->AddExclusion(dhcpExclusionRange, TRUE);
    }
    else
    {
        CDhcpScope * pScope = GETHANDLER(CDhcpScope, m_spScopeNode);
        return pScope->AddExclusion(dhcpExclusionRange, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addres.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	AddRes.cpp
		Dialog to add a reservation

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "scope.h"
#include "addres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define RADIO_CLIENT_TYPE_BOTH  0
#define RADIO_CLIENT_TYPE_DHCP  1
#define RADIO_CLIENT_TYPE_BOOTP 2

/////////////////////////////////////////////////////////////////////////////
// CAddReservation dialog


CAddReservation::CAddReservation(ITFSNode *     pScopeNode,
                                 LARGE_INTEGER  liVersion,
								 CWnd*          pParent /*=NULL*/)
	: CBaseDialog(CAddReservation::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddReservation)
	m_nClientType = -1;
	//}}AFX_DATA_INIT

	m_spScopeNode.Set(pScopeNode);
	m_pScopeObject = GETHANDLER(CDhcpScope, pScopeNode);
	m_bChange = FALSE;  // We are creating new clients, not changing
    m_liVersion = liVersion;

    // the default client type is BOTH
    m_nClientType = RADIO_CLIENT_TYPE_BOTH;
}

void CAddReservation::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddReservation)
	DDX_Control(pDX, IDC_STATIC_CLIENT_TYPE, m_staticClientType);
	DDX_Control(pDX, IDC_EDIT_CLIENT_UID, m_editClientUID);
	DDX_Control(pDX, IDC_EDIT_CLIENT_NAME, m_editClientName);
	DDX_Control(pDX, IDC_EDIT_CLIENT_COMMENT, m_editClientComment);
	DDX_Radio(pDX, IDC_RADIO_TYPE_BOTH, m_nClientType);
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_RESERVATION_IP, m_ipaAddress);
}


BEGIN_MESSAGE_MAP(CAddReservation, CBaseDialog)
	//{{AFX_MSG_MAP(CAddReservation)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddReservation message handlers

BOOL CAddReservation::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();

    m_editClientName.LimitText( STRING_LENGTH_MAX ) ;
    m_editClientComment.LimitText( STRING_LENGTH_MAX ) ;

	FillInSubnetId();
	
    if (m_liVersion.QuadPart < DHCP_SP2_VERSION)
    {
        m_staticClientType.ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RADIO_TYPE_DHCP)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RADIO_TYPE_BOOTP)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RADIO_TYPE_BOTH)->ShowWindow(SW_HIDE);
    }
    
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddReservation::OnOK() 
{
	DWORD err = 0;
	CDhcpClient dhcpClient;

    UpdateData();

    if ( m_bChange ) 
    {   
        err = UpdateClient(&dhcpClient);
    }
    else
    {
        err = CreateClient(&dhcpClient);
    }

    if ( err == ERROR_SUCCESS )
    {
        //
        // the dialog only gets dismissed if we're editing an
        // existing client (because we may want to add more than
        // one client)
        //
        if (m_bChange)
        {
            CBaseDialog::OnOK();
        }
        else
        {
            //
            // Get ready for the next client to be added.
            //
            m_editClientUID.SetWindowText(_T(""));
            m_editClientName.SetWindowText(_T(""));
            m_editClientComment.SetWindowText(_T(""));
            FillInSubnetId();

            //
            // And continue on...
            //
        }
    }
    else
    {
        // don't put up another error box for this case, 
        // we already asked the user
        if (err != IDS_UID_MAY_BE_WRONG)
        {
            ::DhcpMessageBox(err);
        }

		return;
    }

	//CBaseDialog::OnOK();
}

//
//  For new clients, fill in what we can on the ip address control (i.e.
//  the subnet id portion
//
void 
CAddReservation::FillInSubnetId()
{
    DWORD dwIp = m_pScopeObject->GetAddress() & m_pScopeObject->QuerySubnetMask();

    m_ipaAddress.ClearAddress();
    int i = 0;
    while (i < sizeof(dwIp))
    {
        if (!dwIp)
        {
            break;
        }
        m_ipaAddress.SetField(i, TRUE, HIBYTE(HIWORD(dwIp)));
        dwIp <<= 8;

        ++i;
    }
    
	if (i < sizeof(dwIp))
    {
        m_ipaAddress.SetFocusField(i);
    }
}

//
//  Construct the client structure from the dialog's edit controls.             
//
LONG 
CAddReservation::BuildClient
(
	CDhcpClient * pClient
)
{
    DWORD				err = 0;
    CString				str;
    DATE_TIME			dt;
    DHCP_IP_ADDRESS		dhipa;
    CByteArray			cabUid;
	int					i;
	BOOL				fValidUID = TRUE;

    CATCH_MEM_EXCEPTION
    {
        do
        {
            dt.dwLowDateTime  = DHCP_DATE_TIME_ZERO_LOW;
            dt.dwHighDateTime = DHCP_DATE_TIME_ZERO_HIGH;

            pClient->SetExpiryDateTime( dt );

            m_ipaAddress.GetAddress( &dhipa );
            if ( dhipa == 0 ) 
            {
                err = IDS_ERR_INVALID_CLIENT_IPADDR ;
                m_ipaAddress.SetFocusField(-1);
                 break ;
            }

			m_editClientUID.GetWindowText(str);
			if (str.IsEmpty())
			{
                err = IDS_ERR_INVALID_UID ;
                m_editClientUID.SetSel(0,-1);
                m_editClientUID.SetFocus();
                break ; 
            }
			
			// 
            // Since the rest of the Windows UI displays MAC addresses as
            // 00-00-00-00-00-00, we must strip out the dashes before
            // processing the mac address
            //
            int nLength = str.GetLength();
	        LPTSTR pstrSource = str.GetBuffer(nLength);
	        LPTSTR pstrDest = pstrSource;
	        LPTSTR pstrEnd = pstrSource + nLength;

	        while (pstrSource < pstrEnd)
	        {
		        if (*pstrSource != '-')
		        {
			        *pstrDest = *pstrSource;
			        pstrDest = _tcsinc(pstrDest);
		        }
		        pstrSource = _tcsinc(pstrSource);
	        }
	        *pstrDest = '\0';

            str.ReleaseBuffer();

            //
			// Client UIDs should be 48 bits (6 bytes or 12 hex characters)
			//
			if (str.GetLength() != 6 * 2)
				fValidUID = FALSE;
			
			for (i = 0; i < str.GetLength(); i++)
			{
				if (!wcschr(rgchHex, str[i]))
					fValidUID = FALSE;
			}

			if (!::UtilCvtHexString(str, cabUid) && fValidUID)
			{
				err = IDS_ERR_INVALID_UID ;
                m_editClientUID.SetSel(0,-1);
                m_editClientUID.SetFocus();
                break ; 
			}

            // UIDs must be <= 255 bytes
            if (cabUid.GetSize() > 255)
            {
                err = IDS_UID_TOO_LONG;
                break;
            }

            if (!fValidUID)
			{
				if (IDYES != AfxMessageBox(IDS_UID_MAY_BE_WRONG, MB_ICONQUESTION | MB_YESNO))
				{
    	            m_editClientUID.SetSel(0,-1);
	                m_editClientUID.SetFocus();
					err = IDS_UID_MAY_BE_WRONG;
					break;
				}
			}

			pClient->SetHardwareAddress( cabUid ) ;

            m_editClientName.GetWindowText( str ) ;
            if ( str.GetLength() == 0 ) 
            {
                err = IDS_ERR_INVALID_CLIENT_NAME ;
                m_editClientName.SetFocus();
                break ;
            }

            //
            // Convert client name to oem
            //
            pClient->SetName( str ) ;
            m_editClientComment.GetWindowText( str ) ;
            pClient->SetComment( str ) ;

            //
            // Can't change IP address in change mode
            //
            ASSERT ( !m_bChange || dhipa == pClient->QueryIpAddress() ) ;

            pClient->SetIpAddress( dhipa ) ;

            // 
            // Set the client type
            //
            if (m_liVersion.QuadPart >= DHCP_SP2_VERSION)
            {
                switch (m_nClientType)
                {
                    case RADIO_CLIENT_TYPE_DHCP:
                        pClient->SetClientType(CLIENT_TYPE_DHCP);
                        break;
                    
                    case RADIO_CLIENT_TYPE_BOOTP:
                        pClient->SetClientType(CLIENT_TYPE_BOOTP);
                        break;

                    case RADIO_CLIENT_TYPE_BOTH:
                        pClient->SetClientType(CLIENT_TYPE_BOTH);
                        break;

                    default:
                        Assert(FALSE);  // should never get here
                        break;
                }
            }

        }
        while ( FALSE ) ;
    }
    END_MEM_EXCEPTION( err ) ;

    return err ;
}

//
//  Creates a new reservation for this scope
//
LONG 
CAddReservation::CreateClient
(
	CDhcpClient * pClient
)
{
    LONG err = BuildClient(pClient);
    if ( err == 0 ) 
    {
        BEGIN_WAIT_CURSOR;
        err = m_pScopeObject->CreateReservation(pClient);
        END_WAIT_CURSOR;
    }

    return err ;
}

LONG 
CAddReservation::UpdateClient
(
	CDhcpClient * pClient
)
{
    LONG err = BuildClient(pClient) ;
    if ( err == 0 ) 
    {
         err = m_pScopeObject->SetClientInfo(pClient);
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addres.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AddRes.h
		Dialog to add a reservation

	FILE HISTORY:
        
*/

#if !defined(AFX_ADDRES_H__7B0D5D16_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
#define AFX_ADDRES_H__7B0D5D16_B501_11D0_AB8E_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddReservation dialog

class CAddReservation : public CBaseDialog
{
// Construction
public:
	CAddReservation(ITFSNode *	    pNode,
                    LARGE_INTEGER   liVersion,
					CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddReservation)
	enum { IDD = IDD_RESERVATION_NEW };
	CStatic	m_staticClientType;
	CEdit	m_editClientUID;
	CEdit	m_editClientName;
	CEdit	m_editClientComment;
	int		m_nClientType;
	//}}AFX_DATA

    CWndIpAddress m_ipaAddress;       //  Reservation Address

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddReservation::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddReservation)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void FillInSubnetId();
	LONG CreateClient(CDhcpClient * pClient);
	LONG UpdateClient(CDhcpClient * pClient);
	LONG BuildClient(CDhcpClient * pClient);

	// Generated message map functions
	//{{AFX_MSG(CAddReservation)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	SPITFSNode			m_spScopeNode;
	CDhcpScope *		m_pScopeObject;
	BOOL				m_bChange;       // changing existing entry or creating new
    LARGE_INTEGER       m_liVersion;     // version of the server we are talking to
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDRES_H__7B0D5D16_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addexcl.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AddExcl.h
		dialog to add an exclusion range

	FILE HISTORY:
        
*/

#if !defined(AFX_ADDEXCL_H__7B0D5D15_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
#define AFX_ADDEXCL_H__7B0D5D15_B501_11D0_AB8E_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddExclusion dialog

class CAddExclusion : public CBaseDialog
{
// Construction
public:
	CAddExclusion(ITFSNode * pScopeNode, 
                  BOOL       bMulticast = FALSE,
				  CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddExclusion)
	enum { IDD = IDD_EXCLUSION_NEW };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    CWndIpAddress m_ipaStart;     //  Start Address
    CWndIpAddress m_ipaEnd;       //  End Address

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddExclusion::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddExclusion)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	DWORD IsValidExclusion(CDhcpIpRange & dhcpExclusionRange);
    DWORD AddExclusion(CDhcpIpRange & dhcpExclusionRange);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAddExclusion)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	SPITFSNode		m_spScopeNode;
    BOOL            m_bMulticast;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDEXCL_H__7B0D5D15_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addserv.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	addserv.cpp
		The add server dialog
		
    FILE HISTORY:
        
*/


#include "stdafx.h"
#include "AddServ.h"

#include <objpick.h> // for CGetComputer

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int CALLBACK AddServerCompareFunc
(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
)
{
    return ((CAddServer *) lParamSort)->HandleSort(lParam1, lParam2);
}

/////////////////////////////////////////////////////////////////////////////
// CAddServer dialog


CAddServer::CAddServer(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CAddServer::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddServer)
	//}}AFX_DATA_INIT

    ResetSort();
}


void CAddServer::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddServer)
	DDX_Control(pDX, IDC_RADIO_AUTHORIZED_SERVERS, m_radioAuthorizedServer);
	DDX_Control(pDX, IDOK, m_buttonOk);
	DDX_Control(pDX, IDC_RADIO_ANY_SERVER, m_radioAnyServer);
	DDX_Control(pDX, IDC_EDIT_ADD_SERVER_NAME, m_editServer);
	DDX_Control(pDX, IDC_BUTTON_BROWSE_SERVERS, m_buttonBrowse);
	DDX_Control(pDX, IDC_LIST_AUTHORIZED_SERVERS, m_listctrlServers);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddServer, CBaseDialog)
	//{{AFX_MSG_MAP(CAddServer)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_SERVERS, OnButtonBrowseServers)
	ON_BN_CLICKED(IDC_RADIO_ANY_SERVER, OnRadioAnyServer)
	ON_BN_CLICKED(IDC_RADIO_AUTHORIZED_SERVERS, OnRadioAuthorizedServers)
	ON_EN_CHANGE(IDC_EDIT_ADD_SERVER_NAME, OnChangeEditAddServerName)
	ON_WM_TIMER()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_AUTHORIZED_SERVERS, OnItemchangedListAuthorizedServers)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_AUTHORIZED_SERVERS, OnColumnclickListAuthorizedServers)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddServer message handlers

BOOL CAddServer::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    LV_COLUMN lvColumn;
    CString   strText;

    strText.LoadString(IDS_NAME);

    ListView_SetExtendedListViewStyle(m_listctrlServers.GetSafeHwnd(), LVS_EX_FULLROWSELECT);

    lvColumn.mask = LVCF_TEXT | LVCF_FMT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = 175;
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    
    m_listctrlServers.InsertColumn(0, &lvColumn);

    strText.LoadString(IDS_IP_ADDRESS);
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    lvColumn.cx = 100;
    m_listctrlServers.InsertColumn(1, &lvColumn);

    m_editServer.SetFocus();
    m_radioAnyServer.SetCheck(TRUE);

    UpdateControls();
    
    FillListCtrl();

    return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddServer::OnOK() 
{
    if (!GetInfo(m_strName, m_strIp))
        return;

    CleanupTimer();

	CBaseDialog::OnOK();
}

void CAddServer::OnCancel() 
{
    CleanupTimer();
    
	CBaseDialog::OnCancel();
}

void CAddServer::OnButtonBrowseServers() 
{
    CGetComputer dlgGetComputer;
    
    if (!dlgGetComputer.GetComputer(::FindMMCMainWindow()))
        return;

    m_editServer.SetWindowText(dlgGetComputer.m_strComputerName);
}

void CAddServer::OnRadioAnyServer() 
{
	UpdateControls();
}

void CAddServer::OnRadioAuthorizedServers() 
{
    UpdateControls();
}

void CAddServer::OnChangeEditAddServerName() 
{
    UpdateControls();
}

void CAddServer::OnTimer(UINT nIDEvent) 
{
    if (m_pServerList->IsInitialized())
    {
        m_radioAuthorizedServer.EnableWindow(TRUE);

        CleanupTimer();

        FillListCtrl();
    }
}

void CAddServer::OnItemchangedListAuthorizedServers(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    UpdateControls();

	*pResult = 0;
}



void CAddServer::FillListCtrl()
{
    CServerInfo ServerInfo;
    CString     strIp;
    int         nItem = 0;

    m_listctrlServers.DeleteAllItems();

    if (m_pServerList->IsInitialized())
    {
        // fill the list control with data
        POSITION pos = m_pServerList->GetHeadPosition();

        // walk the list and add items to the list control
        while (pos != NULL)
        {
            POSITION lastpos = pos;

            // get the next item
            ServerInfo = m_pServerList->GetNext(pos);

            UtilCvtIpAddrToWstr(ServerInfo.m_dwIp, &strIp);

            nItem = m_listctrlServers.InsertItem(nItem, ServerInfo.m_strName);
            m_listctrlServers.SetItemText(nItem, 1, strIp);

            // save off the position value for sorting later
            m_listctrlServers.SetItemData(nItem, (DWORD_PTR) lastpos);
        }

        if (m_listctrlServers.GetItemCount() > 0)
        {
            // select the first one by default
            m_listctrlServers.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
        }

        Sort(COLUMN_NAME);
    }
    else
    {
        // put some text in the list control and start a timer
        // so we can periodically check to see if initialization completes
        CString strMessage;

        strMessage.LoadString(IDS_ADD_SERVER_LOADING);
        m_listctrlServers.InsertItem(0, strMessage);

        ::SetTimer(GetSafeHwnd(), ADD_SERVER_TIMER_ID, 500, NULL);
    }
}

void CAddServer::UpdateControls()
{
    BOOL fAnyServer = TRUE;
    BOOL fAuthorizedServer = FALSE;
    BOOL fEnableOk = FALSE;

    if (!m_pServerList->IsInitialized())
    {
        m_radioAuthorizedServer.EnableWindow(FALSE);
    }

    if (!m_radioAnyServer.GetCheck())
    {
        // enable the auth server list
        fAnyServer = FALSE;
        fAuthorizedServer = TRUE;

        // check to see if something is selected
        CString strName, strIp;

        GetSelectedServer(strName, strIp);
        if (!strName.IsEmpty() ||
            !strIp.IsEmpty())
        {
            fEnableOk = TRUE;
        }
    }
    else
    {
        // check to see if the edit box is empty
        CString strText;
        m_editServer.GetWindowText(strText);
        if (!strText.IsEmpty())
        {
            fEnableOk = TRUE;
        }
    }

    m_editServer.EnableWindow(fAnyServer);
    m_buttonBrowse.EnableWindow(fAnyServer);

    m_listctrlServers.EnableWindow(fAuthorizedServer);

    m_buttonOk.EnableWindow(fEnableOk);
}

BOOL CAddServer::GetInfo(CString & strName, CString & strIp)
{
    BOOL fSuccess = TRUE;

    if (!m_radioAnyServer.GetCheck())
    {
        // check to see if something is selected
        GetSelectedServer(strName, strIp);
    }
    else
    {
        m_editServer.GetWindowText(strName);

        DWORD dwIpAddress = 0;
        DWORD err = ERROR_SUCCESS;
        DHC_HOST_INFO_STRUCT hostInfo;

        BEGIN_WAIT_CURSOR

        switch (::UtilCategorizeName(strName))
        {
            case HNM_TYPE_IP:
                dwIpAddress = ::UtilCvtWstrToIpAddr( strName ) ;
                strName.Empty();
                break ;

            case HNM_TYPE_NB:
            case HNM_TYPE_DNS:
                err = ::UtilGetHostAddress( strName, &dwIpAddress ) ;
			    break ;

            default:
                err = IDS_ERR_BAD_HOST_NAME ;
                break;
        }

        END_WAIT_CURSOR

        /*
        if (err != ERROR_SUCCESS)
        {
            DhcpMessageBox(err);
            fSuccess = FALSE;
            return fSuccess;
        }
        */

        if (err == ERROR_SUCCESS)
        {
            BEGIN_WAIT_CURSOR

            // get the FQDN for this machine and set it.
            err = ::UtilGetHostInfo(dwIpAddress, &hostInfo);

	    // Make sure we do not use 127.0.0.1
	    if (( INADDR_LOOPBACK ==  dwIpAddress ) &&
		( NO_ERROR == err )) {
		::UtilGetHostAddress( hostInfo._chHostName, &dwIpAddress );
	    } // if

            END_WAIT_CURSOR

            // only put up this error if the user typed in an IP address
            // and we couldn't resolve it to a name.
            // if we have a name but just can't resolve it to a FQDN
            // then we'll try to use that.
            /*
            if (err != ERROR_SUCCESS &&
                strName.IsEmpty())
            {
                ::DhcpMessageBox(WIN32_FROM_HRESULT(err));
                fSuccess = FALSE;
            }
            */

            CString strTemp = hostInfo._chHostName;

            if (!strTemp.IsEmpty())
                strName = hostInfo._chHostName;
        }

        ::UtilCvtIpAddrToWstr(dwIpAddress, &strIp);

    }

    return fSuccess;

}

void CAddServer::GetSelectedServer(CString & strName, CString & strIp)
{
    strName.Empty();
    strIp.Empty();

    int nSelectedItem = m_listctrlServers.GetNextItem(-1, LVNI_SELECTED);

    if (nSelectedItem != -1)
    {
        strName = m_listctrlServers.GetItemText(nSelectedItem, 0);
        strIp = m_listctrlServers.GetItemText(nSelectedItem, 1);
    }
}

void CAddServer::CleanupTimer()
{
    KillTimer(ADD_SERVER_TIMER_ID);
}


void CAddServer::OnColumnclickListAuthorizedServers(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    // sort depending on what column was clicked;
    Sort(pNMListView->iSubItem);
    
	*pResult = 0;
}

void CAddServer::Sort(int nCol) 
{
    if (m_nSortColumn == nCol)
    {
        // if the user is clicking the same column again, reverse the sort order
        m_aSortOrder[nCol] = m_aSortOrder[nCol] ? FALSE : TRUE;
    }
    else
    {
        m_nSortColumn = nCol;
    }

    m_listctrlServers.SortItems(AddServerCompareFunc, (LPARAM) this);
}

int CAddServer::HandleSort(LPARAM lParam1, LPARAM lParam2) 
{
    int nCompare = 0;
    CServerInfo ServerInfo1, ServerInfo2;

    ServerInfo1 = m_pServerList->GetAt((POSITION) lParam1);
    ServerInfo2 = m_pServerList->GetAt((POSITION) lParam2);

    switch (m_nSortColumn)
    {
        case COLUMN_NAME:
            {
                nCompare = ServerInfo1.m_strName.CompareNoCase(ServerInfo2.m_strName);
            }

            // if the names are the same, fall back to the IP address
            if (nCompare != 0)
            {
                break;
            }


        case COLUMN_IP:
            {
                if (ServerInfo1.m_dwIp > ServerInfo2.m_dwIp)
                    nCompare = 1;
                else
                if (ServerInfo1.m_dwIp < ServerInfo2.m_dwIp)
                    nCompare = -1;
            }
            break;
    }

    if (m_aSortOrder[m_nSortColumn] == FALSE)
    {
        // descending
        return -nCompare;
    }
    else
    {
        // ascending
        return nCompare;
    }
}

void CAddServer::ResetSort()
{
    m_nSortColumn = -1; 

    for (int i = 0; i < COLUMN_MAX; i++)
    {
        m_aSortOrder[i] = TRUE; // ascending
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\bootppp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	bootppp.cpp
		The bootp properties page
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "bootppp.h"
#include "nodes.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CBootpProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CBootpProperties::CBootpProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	//ASSERT(pFolderNode == GetContainerNode());

	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CBootpProperties::~CBootpProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// CBootpPropGeneral property page

IMPLEMENT_DYNCREATE(CBootpPropGeneral, CPropertyPageBase)

CBootpPropGeneral::CBootpPropGeneral() : CPropertyPageBase(CBootpPropGeneral::IDD)
{
	//{{AFX_DATA_INIT(CBootpPropGeneral)
	m_strFileName = _T("");
	m_strFileServer = _T("");
	m_strImageName = _T("");
	//}}AFX_DATA_INIT
}

CBootpPropGeneral::~CBootpPropGeneral()
{
}

void CBootpPropGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBootpPropGeneral)
	DDX_Text(pDX, IDC_EDIT_BOOTP_FILE_NAME, m_strFileName);
	DDX_Text(pDX, IDC_EDIT_BOOTP_FILE_SERVER, m_strFileServer);
	DDX_Text(pDX, IDC_EDIT_BOOTP_IMAGE_NAME, m_strImageName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBootpPropGeneral, CPropertyPageBase)
	//{{AFX_MSG_MAP(CBootpPropGeneral)
	ON_EN_CHANGE(IDC_EDIT_BOOTP_FILE_NAME, OnChangeEditBootpFileName)
	ON_EN_CHANGE(IDC_EDIT_BOOTP_FILE_SERVER, OnChangeEditBootpFileServer)
	ON_EN_CHANGE(IDC_EDIT_BOOTP_IMAGE_NAME, OnChangeEditBootpImageName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBootpPropGeneral message handlers


BOOL CBootpPropGeneral::OnApply() 
{
	UpdateData();

	BOOL bRet = CPropertyPageBase::OnApply();

	if (bRet == FALSE)
	{
		// Something bad happened... grab the error code
		AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		::DhcpMessageBox(GetHolder()->GetError());
	}

	return bRet;
}

BOOL CBootpPropGeneral::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	SPITFSNode spBootpNode, spBootpFolder;
	spBootpNode = GetHolder()->GetNode();

	CDhcpBootpEntry * pBootpEntry = GETHANDLER(CDhcpBootpEntry, spBootpNode);
	
	spBootpNode->GetParent(&spBootpFolder);

	// update the node's data
	pBootpEntry->SetBootImage(m_strImageName);
	pBootpEntry->SetFileServer(m_strFileServer);
	pBootpEntry->SetFileName(m_strFileName);
	
	*ChangeMask = RESULT_PANE_CHANGE_ITEM_DATA;

    // now we need to calculate how big of a string to allocate 
	// for the bootp table
	int nBootpTableLength = 0;
	SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;

    spBootpFolder->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		CDhcpBootpEntry * pCurBootpEntry = GETHANDLER(CDhcpBootpEntry, spCurrentNode); 
	
		nBootpTableLength += pCurBootpEntry->CchGetDataLength();

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	// allocate the memory
	int nBootpTableLengthBytes = nBootpTableLength * sizeof(WCHAR);
	WCHAR * pBootpTable = (WCHAR *) _alloca(nBootpTableLengthBytes);
	WCHAR * pBootpTableTemp = pBootpTable;
	ZeroMemory(pBootpTable, nBootpTableLengthBytes);
	
	spNodeEnum->Reset();

	// now enumerate again and store the strings
	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		CDhcpBootpEntry * pCurBootpEntry = GETHANDLER(CDhcpBootpEntry, spCurrentNode);
	
		pBootpTableTemp = pCurBootpEntry->PchStoreData(pBootpTableTemp);

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	// now write to the server
	DWORD dwError = 0;
	DHCP_SERVER_CONFIG_INFO_V4 dhcpServerInfo;

	::ZeroMemory(&dhcpServerInfo, sizeof(dhcpServerInfo));

	dhcpServerInfo.cbBootTableString = (DWORD) ((pBootpTableTemp - pBootpTable) + 1) * sizeof(WCHAR);
	dhcpServerInfo.wszBootTableString = pBootpTable;

	CDhcpBootp * pBootpFolder = GETHANDLER(CDhcpBootp, spBootpFolder);

	BEGIN_WAIT_CURSOR;
    dwError = ::DhcpServerSetConfigV4(pBootpFolder->GetServerObject(spBootpFolder)->GetIpAddress(),
									  Set_BootFileTable,
									  &dhcpServerInfo);
    END_WAIT_CURSOR;

	if (dwError != ERROR_SUCCESS)
	{
		GetHolder()->SetError(dwError);
		return FALSE;
	}

	return FALSE;
}

void CBootpPropGeneral::OnChangeEditBootpFileName() 
{
	SetDirty(TRUE);
}

void CBootpPropGeneral::OnChangeEditBootpFileServer() 
{
	SetDirty(TRUE);
}

void CBootpPropGeneral::OnChangeEditBootpImageName() 
{
	SetDirty(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addtoss.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	addtoss.h
		The add scope to superscope dialog
		
    FILE HISTORY:
        
*/

#if !defined(AFX_ADDTOSS_H__B5DA3C60_F6FE_11D0_BBF3_00C04FC3357A__INCLUDED_)
#define AFX_ADDTOSS_H__B5DA3C60_F6FE_11D0_BBF3_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddScopeToSuperscope dialog

class CAddScopeToSuperscope : public CBaseDialog
{
// Construction
public:
	CAddScopeToSuperscope(ITFSNode * pScopeNode, 
                          LPCTSTR    pszTitle = NULL, 
                          CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddScopeToSuperscope)
	enum { IDD = IDD_ADD_TO_SUPERSCOPE };
	CButton	m_buttonOk;
	CListBox	m_listSuperscopes;
	//}}AFX_DATA

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddScopeToSuperscope::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddScopeToSuperscope)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    void SetButtons();

	// Generated message map functions
	//{{AFX_MSG(CAddScopeToSuperscope)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeListSuperscopes();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    SPITFSNode m_spScopeNode;
    CString    m_strTitle;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDTOSS_H__B5DA3C60_F6FE_11D0_BBF3_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addtoss.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	addtoss.cpp
		The add scope to superscope dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "AddToSS.h"
#include "server.h"
#include "scope.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddScopeToSuperscope dialog


CAddScopeToSuperscope::CAddScopeToSuperscope
(
    ITFSNode * pScopeNode,
    LPCTSTR    pszTitle,
    CWnd* pParent /*=NULL*/
)	: CBaseDialog(CAddScopeToSuperscope::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddScopeToSuperscope)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_strTitle = pszTitle;
    m_spScopeNode.Set(pScopeNode);
}


void CAddScopeToSuperscope::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddScopeToSuperscope)
	DDX_Control(pDX, IDOK, m_buttonOk);
	DDX_Control(pDX, IDC_LIST_SUPERSCOPES, m_listSuperscopes);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddScopeToSuperscope, CBaseDialog)
	//{{AFX_MSG_MAP(CAddScopeToSuperscope)
	ON_LBN_SELCHANGE(IDC_LIST_SUPERSCOPES, OnSelchangeListSuperscopes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddScopeToSuperscope message handlers

BOOL CAddScopeToSuperscope::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    SPITFSNode      spServerNode;
    SPITFSNode      spCurrentNode;
    SPITFSNodeEnum  spNodeEnum;
    ULONG           nNumReturned = 0;

    m_spScopeNode->GetParent(&spServerNode);
    spServerNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SUPERSCOPE)
        {
			// found a superscope
			//
			CString strName;
            CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, spCurrentNode);
            
            strName = pSuperscope->GetName();

            m_listSuperscopes.AddString(strName);
		}

		spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

    SetButtons();

    if (!m_strTitle.IsEmpty())
        SetWindowText(m_strTitle);

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddScopeToSuperscope::OnOK() 
{
    DWORD   err;
    CString strSuperscope;
    
    // Get the currently selected node
    int nCurSel = m_listSuperscopes.GetCurSel();
    Assert(nCurSel != LB_ERR);
    
    m_listSuperscopes.GetText(nCurSel, strSuperscope);
    
    if (strSuperscope.IsEmpty())
        Assert(FALSE);

    // now try to set this scope as part of the superscope
    CDhcpScope * pScope = GETHANDLER(CDhcpScope, m_spScopeNode);
    
    BEGIN_WAIT_CURSOR;
    err = pScope->SetSuperscope(strSuperscope, FALSE);
    END_WAIT_CURSOR;

    if (err != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(err);
        return;
    }

    // that worked, now move the UI stuff around.
    SPITFSNode      spServerNode;
    SPITFSNode      spCurrentNode;
    SPITFSNodeEnum  spNodeEnum;
    ULONG           nNumReturned = 0;

    m_spScopeNode->GetParent(&spServerNode);
    spServerNode->GetEnum(&spNodeEnum);

    // remove the scope from the UI
    spServerNode->RemoveChild(m_spScopeNode);
    pScope->SetInSuperscope(FALSE);

    // find the superscope we want to add this scope to and refresh it so that
    // the scope shows up in that node
    spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SUPERSCOPE)
        {
			// found a superscope
			CString strName;
            CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, spCurrentNode);
            
            strName = pSuperscope->GetName();
    
            // is this the one?
            if (strName.Compare(strSuperscope) == 0)
            {
                // this is the one we are adding to.  Force a refresh.
                pSuperscope->OnRefresh(spCurrentNode, NULL, 0, 0, 0);
                break;
            }
		}

		// go to the next one
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

    CBaseDialog::OnOK();
}

void CAddScopeToSuperscope::OnSelchangeListSuperscopes() 
{
    SetButtons();	
}

void CAddScopeToSuperscope::SetButtons()
{
    if (m_listSuperscopes.GetCurSel() != LB_ERR)
    {
        m_buttonOk.EnableWindow(TRUE);
    }
    else
    {
        m_buttonOk.EnableWindow(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\addserv.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	addserv.h
		The add server dialog
		
    FILE HISTORY:
        
*/

#if !defined _ADDSERV_H
#define _ADDSERV_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _SERVBROW_H
#include "servbrow.h"
#endif

#define ADD_SERVER_TIMER_ID     500

/////////////////////////////////////////////////////////////////////////////
// CAddServer dialog

class CAddServer : public CBaseDialog
{
// Construction
public:
	CAddServer(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddServer)
	enum { IDD = IDD_ADD_SERVER };
	CButton	m_radioAuthorizedServer;
	CButton	m_buttonOk;
	CButton	m_radioAnyServer;
	CEdit	m_editServer;
	CButton	m_buttonBrowse;
	CListCtrl	m_listctrlServers;
	//}}AFX_DATA

    void SetServerList(CAuthServerList * pServerList) { m_pServerList = pServerList; }
    int HandleSort(LPARAM lParam1, LPARAM lParam2);
    void ResetSort();

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddServer::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddServer)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void FillListCtrl();
    void UpdateControls();
    BOOL GetInfo(CString & strName, CString & strIp);
    void GetSelectedServer(CString & strName, CString & strIp);
    void CleanupTimer();

    void Sort(int nCol);

	// Generated message map functions
	//{{AFX_MSG(CAddServer)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonBrowseServers();
	afx_msg void OnRadioAnyServer();
	afx_msg void OnRadioAuthorizedServers();
	virtual void OnCancel();
	afx_msg void OnChangeEditAddServerName();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnItemchangedListAuthorizedServers(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickListAuthorizedServers(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    CString m_strName;
    CString m_strIp;

private:
    CAuthServerList *	m_pServerList;
    int                 m_nSortColumn;
    BOOL                m_aSortOrder[COLUMN_MAX];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDSERV_H__B8909EC0_08BE_11D3_847A_00104BCA42CF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\classed.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGBINED.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Binary edit dialog for use by the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGBINED
#define _INC_REGBINED

#ifdef __cplusplus
extern "C" {
#endif

#define HEM_SETBUFFER                   (WM_USER + 1)

//
//  HexEdit context menu identifier and items.  The IDKEY_* identifier
//  correspond to the WM_CHAR message that it corresponds to.  For example,
//  IDKEY_COPY would send a control-c to the HexEdit_OnChar routine.
//

//  Surrogate AfxMessageBox replacement for error message filtering.
int DhcpMessageBox(DWORD dwIdPrompt, 
 				   UINT nType, 
				   const TCHAR * pszSuffixString,
				   UINT nHelpContext);

#define IDM_HEXEDIT_CONTEXT             108

#define IDKEY_COPY                      3
#define IDKEY_PASTE                     22
#define IDKEY_CUT                       24
#define ID_SELECTALL                    0x0400

#define HEXEDIT_CLASSNAME               TEXT("HEX")
#define MAXDATA_LENGTH		            256
		// Max length of a value data item

typedef struct _EDITVALUEPARAM {
    LPCTSTR pServer;
    LPTSTR pValueName;
    LPTSTR pValueComment;
    PBYTE pValueData;
    UINT cbValueData;
}   EDITVALUEPARAM, FAR *LPEDITVALUEPARAM;

//
//  Reference data for the HexEdit window.  Because we only ever expect one
//  instance of this class to exist, we can safely create one instance of this
//  structure now to avoid allocating and managing the structure later.
//

typedef struct _HEXEDITDATA {
    UINT Flags;
    PBYTE pBuffer;
    int cbBuffer;
    int cxWindow;                       //  Width of the window
    int cyWindow;                       //  Height of the window
    HFONT hFont;                        //  Font being used for output
    LONG FontHeight;                    //  Height of the above font
    LONG FontMaxWidth;                  //  Maximum width of the above font
    int LinesVisible;                   //  Number of lines can be displayed
    int MaximumLines;                   //  Total number of lines
    int FirstVisibleLine;               //  Line number of top of display
    int xHexDumpStart;
    int xHexDumpByteWidth;
    int xAsciiDumpStart;
    int CaretIndex;
    int MinimumSelectedIndex;
    int MaximumSelectedIndex;
    int xPrevMessagePos;                //  Cursor point on last mouse message
    int yPrevMessagePos;                //  Cursor point on last mouse message
}   HEXEDITDATA;

BOOL
CALLBACK
EditBinaryValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
RegisterHexEditClass(
    HINSTANCE hInstance
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _INC_REGBINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\classed.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       CLASSED.C
*
*  VERSION:     5.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Binary edit dialog for use by the Registry Editor.
*
*  Hexadecimal editor control for use by the Registry Editor.  Little attempt
*  is made to make this a generic control-- only one instance is assumed to
*  ever exist.
*
*  02 Oct 1997 modified to work with the DHCP snapin
*
*******************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <string.h>
#include <mbstring.h>
#include <tchar.h>
#include "resource.h"
#include "classed.h"
#include "dhcpapi.h"
#include "helparr.h"

//
//  Following structure and data are used to move the controls of the
//  EditBinaryValue dialog so that the HexEdit control fills up the appropriate
//  amount of space based on the system metrics.
//

typedef struct _MOVEWND {
    int ControlID;
    UINT SetWindowPosFlags;
}   MOVEWND;

const TCHAR s_HexEditClassName[] = HEXEDIT_CLASSNAME;

const TCHAR s_HexEditClipboardFormatName[] = TEXT("RegEdit_HexData");

const TCHAR s_HexWordFormatSpec[] = TEXT("%04X");
const TCHAR s_HexByteFormatSpec[] = TEXT("%02X");

COLORREF g_clrWindow;
COLORREF g_clrWindowText;
COLORREF g_clrHighlight;
COLORREF g_clrHighlightText;

PTSTR g_pHelpFileName;

HINSTANCE g_hInstance;

const MOVEWND s_EditBinaryValueMoveWnd[] = {
    IDOK,               SWP_NOSIZE | SWP_NOZORDER,
    IDCANCEL,           SWP_NOSIZE | SWP_NOZORDER,
    IDC_VALUENAME,      SWP_NOMOVE | SWP_NOZORDER,
    IDC_VALUEDATA,      SWP_NOMOVE | SWP_NOZORDER,
    IDC_VALUECOMMENT,   SWP_NOMOVE | SWP_NOZORDER
};

//  Number of bytes that are displayed per line.  NOTE:  Assumptions have been
//  made that this is power of two.
#define BYTES_PER_HEXEDIT_LINE          8
#define BYTES_PER_HEXEDIT_LINE_MASK     0x0007

//
//  This font is used by the HexEdit window for all output.  The lfHeight
//  member is calculated later based on the system configuration.
//

LOGFONT s_HexEditFont = {
    0,                                  //  lfHeight
    0,                                  //  lfWidth
    0,                                  //  lfEscapement
    0,                                  //  lfOrientation
    FW_NORMAL,                          //  lfWeight
    FALSE,                              //  lfItalic
    FALSE,                              //  lfUnderline
    FALSE,                              //  lfStrikeout
    ANSI_CHARSET,                       //  lfCharSet
    OUT_DEFAULT_PRECIS,                 //  lfOutPrecision
    CLIP_DEFAULT_PRECIS,                //  lfClipPrecision
    DEFAULT_QUALITY,                    //  lfQuality
    FIXED_PITCH | FF_DONTCARE,          //  lfPitchAndFamily
    TEXT("Courier")                     //  lfFaceName
};

//  Set if window has input focus, clear if not.
#define HEF_FOCUS                       0x00000001
#define HEF_NOFOCUS                     0x00000000
//  Set if dragging a range with mouse, clear if not.
#define HEF_DRAGGING                    0x00000002
#define HEF_NOTDRAGGING                 0x00000000
//  Set if editing ASCII column, clear if editing hexadecimal column.
#define HEF_CARETINASCIIDUMP            0x00000004
#define HEF_CARETINHEXDUMP              0x00000000
//
#define HEF_INSERTATLOWNIBBLE           0x00000008
#define HEF_INSERTATHIGHNIBBLE          0x00000000
//  Set if caret should be shown at the end of the previous line instead of at
//  the beginning of it's real caret line, clear if not.
#define HEF_CARETATENDOFLINE            0x00000010

HEXEDITDATA s_HexEditData;

typedef struct _HEXEDITCLIPBOARDDATA {
    DWORD cbSize;
    BYTE Data[1];
}   HEXEDITCLIPBOARDDATA, *LPHEXEDITCLIPBOARDDATA;

UINT s_HexEditClipboardFormat;

BOOL
PASCAL
EditBinaryValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

LRESULT
PASCAL
HexEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
HexEdit_OnNcCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    );

VOID
PASCAL
HexEdit_OnSize(
    HWND hWnd,
    UINT State,
    int cx,
    int cy
    );

VOID
PASCAL
HexEdit_SetScrollInfo(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnVScroll(
    HWND hWnd,
    HWND hCtlWnd,
    UINT Code,
    int Position
    );

VOID
PASCAL
HexEdit_OnPaint(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_PaintRect(
    HWND hWnd,
    HDC hDC,
    LPRECT lpUpdateRect
    );

VOID
PASCAL
HexEdit_OnSetFocus(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnKillFocus(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
HexEdit_OnMouseMove(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
HexEdit_OnLButtonUp(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    );

int
PASCAL
HexEdit_HitTest(
    HEXEDITDATA * pHexEditData,
    int x,
    int y
    );

VOID
PASCAL
HexEdit_OnKey(
    HWND hWnd,
    UINT VirtualKey,
    BOOL fDown,
    int cRepeat,
    UINT Flags
    );

VOID
PASCAL
HexEdit_OnChar(
    HWND hWnd,
    TCHAR Char,
    int cRepeat
    );

VOID
PASCAL
HexEdit_SetCaretPosition(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_EnsureCaretVisible(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_ChangeCaretIndex(
    HWND hWnd,
    int NewCaretIndex,
    BOOL fExtendSelection
    );

VOID
PASCAL
HexEdit_DeleteRange(
    HWND hWnd,
    UINT SourceKey
    );

BOOL
PASCAL
HexEdit_OnCopy(
    HWND hWnd
    );

BOOL
PASCAL
HexEdit_OnPaste(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnContextMenu(
    HWND hWnd,
    int x,
    int y
    );

/*******************************************************************************
*
*  EditBinaryValueDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
CALLBACK
EditBinaryValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;
    HEXEDITDATA *    pHexEditData;
    DWORD            dwErr;
    DHCP_CLASS_INFO  ClassInfo;

    switch (Message) {

        case WM_INITDIALOG:
            return EditBinaryValue_OnInitDialog(hWnd, (HWND)(wParam), lParam);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDOK:
                    lpEditValueParam = (LPEDITVALUEPARAM) GetWindowLongPtr(hWnd, DWLP_USER);
                    
                    pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(GetDlgItem(hWnd, IDC_VALUEDATA), GWLP_USERDATA);

                    if (pHexEditData->cbBuffer == 0)
                    {
                        // user didn't enter any data to describe the class
                        TCHAR szText[1024], szCaption[1024];

                        LoadString(g_hInstance, IDS_CLASSID_NO_DATA, szText, sizeof(szText)/sizeof(TCHAR));
                        LoadString(g_hInstance, IDS_SNAPIN_DESC, szCaption, sizeof(szCaption)/sizeof(TCHAR));

                        MessageBox(hWnd, szText, szCaption, MB_OK | MB_ICONSTOP);
                        
                        SetFocus(GetDlgItem(hWnd, IDC_VALUEDATA));

                        break;
                    }

                    lpEditValueParam->cbValueData = pHexEditData->cbBuffer;

                    GetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam->pValueName, 256);
                    if ( _tcslen(lpEditValueParam->pValueName) == 0)
                    {
                        TCHAR szText[1024], szCaption[1024];

                        LoadString(g_hInstance, IDS_CLASSID_NO_NAME, szText, sizeof(szText)/sizeof(TCHAR));
                        LoadString(g_hInstance, IDS_SNAPIN_DESC, szCaption, sizeof(szCaption)/sizeof(TCHAR));

                        MessageBox(hWnd, szText, szCaption, MB_OK | MB_ICONSTOP);
                     
                        SetFocus(GetDlgItem(hWnd, IDC_VALUENAME));

                        break;
                    }

                    GetDlgItemText(hWnd, IDC_VALUECOMMENT, lpEditValueParam->pValueComment, 256);
                    
                    // Everything looks good so far, let's try to create the class on the server
                    ClassInfo.ClassName = lpEditValueParam->pValueName;
                    ClassInfo.ClassComment = lpEditValueParam->pValueComment;
                    ClassInfo.ClassDataLength = lpEditValueParam->cbValueData;
                    ClassInfo.ClassData = lpEditValueParam->pValueData;

                    dwErr = DhcpCreateClass((LPTSTR) lpEditValueParam->pServer,
                                            0, 
                                            &ClassInfo);
                    if (dwErr != ERROR_SUCCESS)
                    {
                        DhcpMessageBox(dwErr, MB_OK, NULL, -1);
                        return FALSE;
                    }

                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

                default:
                    return FALSE;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) (LPVOID) g_aHelpIDs_IDD_CLASSID_NEW);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPVOID) g_aHelpIDs_IDD_CLASSID_NEW);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  EditBinaryValue_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd,
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

BOOL
PASCAL
EditBinaryValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;
    RECT Rect;
    int HexEditIdealWidth;
    int dxChange;
    HWND hControlWnd;
    UINT Counter;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(GetDlgItem(hWnd, IDC_VALUEDATA), GWLP_USERDATA);

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam->pValueName);

    SendDlgItemMessage(hWnd, IDC_VALUEDATA, HEM_SETBUFFER, (WPARAM)
        lpEditValueParam-> cbValueData, (LPARAM) lpEditValueParam-> pValueData);

    //
    //  Figure out how big the "ideally" size HexEdit should be-- this means
    //  displaying the address, hex dump, ASCII dump, and potentially a scroll
    //  bar.
    //

    GetWindowRect(GetDlgItem(hWnd, IDC_VALUEDATA), &Rect);

    HexEditIdealWidth = pHexEditData->xAsciiDumpStart +
        pHexEditData->FontMaxWidth * (BYTES_PER_HEXEDIT_LINE + 1) +
        GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXEDGE) * 2;

    dxChange = HexEditIdealWidth - (Rect.right - Rect.left);

    //
    //  Resize the dialog box.
    //

    GetWindowRect(hWnd, &Rect);

    MoveWindow(hWnd, Rect.left, Rect.top, Rect.right - Rect.left + dxChange,
        Rect.bottom - Rect.top, FALSE);

    //
    //  Resize or move the controls as necessary.
    //

    for (Counter = 0; Counter < (sizeof(s_EditBinaryValueMoveWnd) /
        sizeof(MOVEWND)); Counter++) {

        hControlWnd = GetDlgItem(hWnd,
            s_EditBinaryValueMoveWnd[Counter].ControlID);

        GetWindowRect(hControlWnd, &Rect);

        if (s_EditBinaryValueMoveWnd[Counter].SetWindowPosFlags & SWP_NOSIZE) {

            MapWindowPoints(NULL, hWnd, (LPPOINT) &Rect, 2);
            Rect.left += dxChange;

        }

        else
            Rect.right += dxChange;

        SetWindowPos(hControlWnd, NULL, Rect.left, Rect.top, Rect.right -
            Rect.left, Rect.bottom - Rect.top,
            s_EditBinaryValueMoveWnd[Counter].SetWindowPosFlags);

    }

    SetFocus(GetDlgItem(hWnd, IDC_VALUENAME));

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);

}

/*******************************************************************************
*
*  RegisterHexEditClass
*
*  DESCRIPTION:
*     Register the HexEdit window class with the system.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
RegisterHexEditClass(
    HINSTANCE hInstance
    )
{

    WNDCLASS WndClass;

    g_hInstance = hInstance;

    s_HexEditClipboardFormat =
        RegisterClipboardFormat(s_HexEditClipboardFormatName);

    WndClass.style = CS_DBLCLKS;
    WndClass.lpfnWndProc = HexEditWndProc;
    WndClass.cbClsExtra = 0;
    WndClass.cbWndExtra = 0;
    WndClass.hInstance = g_hInstance;
    WndClass.hIcon = NULL;
    WndClass.hCursor = LoadCursor(NULL, IDC_IBEAM);
    WndClass.hbrBackground = NULL;
    WndClass.lpszMenuName = NULL;
    WndClass.lpszClassName = s_HexEditClassName;

    return (RegisterClass(&WndClass) != 0);

}

/*******************************************************************************
*
*  HexEditWndProc
*
*  DESCRIPTION:
*     Callback procedure for the HexEdit window.
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

LRESULT
PASCAL
HexEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HEXEDITDATA * pHexEditData;

    switch (Message) {

        HANDLE_MSG(hWnd, WM_NCCREATE, HexEdit_OnNcCreate);
        HANDLE_MSG(hWnd, WM_SIZE, HexEdit_OnSize);
        HANDLE_MSG(hWnd, WM_VSCROLL, HexEdit_OnVScroll);
        HANDLE_MSG(hWnd, WM_PAINT, HexEdit_OnPaint);
        HANDLE_MSG(hWnd, WM_LBUTTONDOWN, HexEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_LBUTTONDBLCLK, HexEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_MOUSEMOVE, HexEdit_OnMouseMove);
        HANDLE_MSG(hWnd, WM_LBUTTONUP, HexEdit_OnLButtonUp);
        HANDLE_MSG(hWnd, WM_CHAR, HexEdit_OnChar);
        HANDLE_MSG(hWnd, WM_KEYDOWN, HexEdit_OnKey);

        case WM_SETFOCUS:
            HexEdit_OnSetFocus(hWnd);
            break;

        case WM_KILLFOCUS:
            HexEdit_OnKillFocus(hWnd);
            break;

        case WM_TIMER:
            pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
            HexEdit_OnMouseMove(hWnd, pHexEditData->xPrevMessagePos,
                pHexEditData->yPrevMessagePos, 0);
            break;

        case WM_GETDLGCODE:
            return (LPARAM) (DLGC_WANTCHARS | DLGC_WANTARROWS | DLGC_WANTTAB);

        case WM_ERASEBKGND:
            return TRUE;

        case WM_NCDESTROY:
            pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
            if (pHexEditData)
            {
                DeleteObject(pHexEditData->hFont);
                free(pHexEditData);
            }
            break;

        case WM_CONTEXTMENU:
            HexEdit_OnContextMenu(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        //  Message: HEM_SETBUFFER
        //  wParam:  Number of bytes in the buffer.
        //  lParam:  Pointer to the buffer.
        case HEM_SETBUFFER:
            pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
            pHexEditData->pBuffer = (PBYTE) lParam;
            pHexEditData->cbBuffer = (int) wParam;

            pHexEditData->CaretIndex = 0;
            pHexEditData->MinimumSelectedIndex = 0;
            pHexEditData->MaximumSelectedIndex = 0;

            pHexEditData->FirstVisibleLine = 0;

            HexEdit_SetScrollInfo(hWnd);

            break;

        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);

    }

    return 0;

}

/*******************************************************************************
*
*  HexEdit_OnNcCreate
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnNcCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    )
{

    HDC hDC;
    HFONT hPrevFont;
    TEXTMETRIC TextMetric;
    RECT    rect;
    BOOL    fDone = FALSE;
    int     nPoint = 10;  // starting point size
    int HexEditIdealWidth;

    HEXEDITDATA * pHexEditData = malloc(sizeof(HEXEDITDATA));
    if (!pHexEditData)
        return FALSE;

    SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pHexEditData);

    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);

    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindow = GetSysColor(COLOR_WINDOW);

    pHexEditData->cbBuffer = 0;

    pHexEditData->Flags = 0;

    pHexEditData->cxWindow = 0;
    pHexEditData->cyWindow = 0;
 
    pHexEditData->hFont = NULL;

    hDC = GetDC(hWnd);
    if (hDC)
    {
        GetWindowRect(hWnd, &rect);

        while (!fDone)
        {
            s_HexEditFont.lfHeight = -(nPoint * GetDeviceCaps(hDC, LOGPIXELSY) / 72);

            if ((pHexEditData->hFont = CreateFontIndirect(&s_HexEditFont)) != NULL) 
            {
                hPrevFont = SelectObject(hDC, pHexEditData->hFont);
                GetTextMetrics(hDC, &TextMetric);
                SelectObject(hDC, hPrevFont);

                pHexEditData->FontHeight = TextMetric.tmHeight;

                pHexEditData->LinesVisible = pHexEditData->cyWindow /
                    pHexEditData->FontHeight;

                pHexEditData->FontMaxWidth = TextMetric.tmMaxCharWidth;

                pHexEditData->xHexDumpByteWidth = pHexEditData->FontMaxWidth * 3;
                pHexEditData->xHexDumpStart = pHexEditData->FontMaxWidth * 11 / 2;
                pHexEditData->xAsciiDumpStart = pHexEditData->xHexDumpStart +
                    BYTES_PER_HEXEDIT_LINE * pHexEditData->xHexDumpByteWidth +
                    pHexEditData->FontMaxWidth * 3 / 2;

                // check to make sure we have room 
                HexEditIdealWidth = pHexEditData->xAsciiDumpStart +
                    pHexEditData->FontMaxWidth * (BYTES_PER_HEXEDIT_LINE) +
                    GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXEDGE) * 2;

                if (HexEditIdealWidth < (rect.right - rect.left) ||
                    (nPoint < 5) )
                {
                    fDone = TRUE;
                }
                else
                {
                    // try a smaller size
                    DeleteObject(pHexEditData->hFont);
                    pHexEditData->hFont = NULL;
                    nPoint--;
                }
            }
            else
            {
                break;
            }
        }

        ReleaseDC(hWnd, hDC);
    }

    if (pHexEditData->hFont == NULL)
        return FALSE;

    return (BOOL) DefWindowProc(hWnd, WM_NCCREATE, 0, (LPARAM) lpCreateStruct);

}

/*******************************************************************************
*
*  HexEdit_OnSize
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnSize(
    HWND hWnd,
    UINT State,
    int cx,
    int cy
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    
    pHexEditData->cxWindow = cx;
    pHexEditData->cyWindow = cy;

    pHexEditData->LinesVisible = cy / pHexEditData->FontHeight;

    HexEdit_SetScrollInfo(hWnd);

    UNREFERENCED_PARAMETER(State);
    UNREFERENCED_PARAMETER(cx);

}

/*******************************************************************************
*
*  HexEdit_SetScrollInfo
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_SetScrollInfo(
    HWND hWnd
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    SCROLLINFO ScrollInfo;

    pHexEditData->MaximumLines = (pHexEditData->cbBuffer +
        BYTES_PER_HEXEDIT_LINE) / BYTES_PER_HEXEDIT_LINE - 1;

    ScrollInfo.cbSize = sizeof(SCROLLINFO);
    ScrollInfo.fMask = (SIF_RANGE | SIF_PAGE | SIF_POS);
    ScrollInfo.nMin = 0;
    ScrollInfo.nMax = pHexEditData->MaximumLines;
    ScrollInfo.nPage = pHexEditData->LinesVisible;
    ScrollInfo.nPos = pHexEditData->FirstVisibleLine;

    SetScrollInfo(hWnd, SB_VERT, &ScrollInfo, TRUE);

}

/*******************************************************************************
*
*  HexEdit_OnVScroll
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnVScroll(
    HWND hWnd,
    HWND hCtlWnd,
    UINT Code,
    int Position
    )
{

    int NewFirstVisibleLine;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    SCROLLINFO ScrollInfo;

    NewFirstVisibleLine = pHexEditData->FirstVisibleLine;

    switch (Code) {

        case SB_LINEUP:
            NewFirstVisibleLine--;
            break;

        case SB_LINEDOWN:
            NewFirstVisibleLine++;
            break;

        case SB_PAGEUP:
            NewFirstVisibleLine -= pHexEditData->LinesVisible;
            break;

        case SB_PAGEDOWN:
            NewFirstVisibleLine += pHexEditData->LinesVisible;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            NewFirstVisibleLine = Position;
            break;

    }

    //
    //  Change the scroll bar position.  Note that SetScrollInfo will take into
    //  account the clipping between zero and the maximum value.  It will also
    //  return the final scroll bar position.
    //

    ScrollInfo.cbSize = sizeof(SCROLLINFO);
    ScrollInfo.fMask = SIF_POS;
    ScrollInfo.nPos = NewFirstVisibleLine;

    NewFirstVisibleLine = SetScrollInfo(hWnd, SB_VERT, &ScrollInfo, TRUE);

    if (pHexEditData->FirstVisibleLine != NewFirstVisibleLine) {

        ScrollWindowEx(hWnd, 0, (pHexEditData->FirstVisibleLine -
            NewFirstVisibleLine) * pHexEditData->FontHeight, NULL, NULL, NULL,
            NULL, SW_INVALIDATE);

        pHexEditData->FirstVisibleLine = NewFirstVisibleLine;

        HexEdit_SetCaretPosition(hWnd);

    }

    UNREFERENCED_PARAMETER(hCtlWnd);

}

/*******************************************************************************
*
*  HexEdit_OnPaint
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnPaint(
    HWND hWnd
    )
{

    PAINTSTRUCT PaintStruct;

    BeginPaint(hWnd, &PaintStruct);

    HexEdit_PaintRect(hWnd, PaintStruct.hdc, &PaintStruct.rcPaint);

    EndPaint(hWnd, &PaintStruct);

}

/*******************************************************************************
*
*  HexEdit_PaintRect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_PaintRect(
    HWND hWnd,
    HDC hDC,
    LPRECT lpUpdateRect
    )
{

    HFONT hPrevFont;
    int CurrentByteIndex;
    BYTE Byte;
    int CurrentLine;
    int LastLine;
    int BytesOnLastLine;
    int BytesOnLine;
    BOOL fUsingHighlight;
    int Counter;
    TCHAR Buffer[5];                     //  Room for four hex digits plus null
    RECT TextRect;
    RECT AsciiTextRect;
    int x;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (pHexEditData->hFont)
        hPrevFont = SelectFont(hDC, pHexEditData->hFont);

    SetBkColor(hDC, g_clrWindow);
    SetTextColor(hDC, g_clrWindowText);

    //
    //  Figure out the range of lines of the control that must be painted.
    //  Using this information we can compute the offset into the buffer to
    //  start reading from.
    //

    CurrentLine = lpUpdateRect-> top / pHexEditData->FontHeight;

    TextRect.bottom = CurrentLine * pHexEditData->FontHeight;
    AsciiTextRect.bottom = TextRect.bottom;

    CurrentByteIndex = (pHexEditData->FirstVisibleLine + CurrentLine) *
        BYTES_PER_HEXEDIT_LINE;

    LastLine = lpUpdateRect-> bottom / pHexEditData->FontHeight;

    //
    //  Figure out if there's enough in the buffer to fill up the entire window
    //  and the last line that we paint.
    //

    if (LastLine >= pHexEditData->MaximumLines -
        pHexEditData->FirstVisibleLine) {

        LastLine = pHexEditData->MaximumLines - pHexEditData->FirstVisibleLine;

        BytesOnLastLine = pHexEditData->cbBuffer % BYTES_PER_HEXEDIT_LINE;

    }

    else
        BytesOnLastLine = BYTES_PER_HEXEDIT_LINE;

    BytesOnLine = BYTES_PER_HEXEDIT_LINE;
    fUsingHighlight = FALSE;

    //
    //  Loop through each of the lines to be displayed.
    //

    while (CurrentLine <= LastLine) {

        //
        //  If we're on the last line of the display and this is at the end
        //  of the buffer, we may not have a complete line to paint.
        //

        if (CurrentLine == LastLine)
            BytesOnLine = BytesOnLastLine;

        TextRect.top = TextRect.bottom;
        TextRect.bottom += pHexEditData->FontHeight;

        TextRect.left = 0;
        TextRect.right = pHexEditData->xHexDumpStart;

        x = TextRect.right + pHexEditData->FontMaxWidth / 2;

        wsprintf(Buffer, s_HexWordFormatSpec, CurrentByteIndex);
        ExtTextOut(hDC, 0, TextRect.top, ETO_OPAQUE, &TextRect, Buffer, 4,
            NULL);

        AsciiTextRect.top = AsciiTextRect.bottom;
        AsciiTextRect.bottom += pHexEditData->FontHeight;
        AsciiTextRect.right = pHexEditData->xAsciiDumpStart;

        for (Counter = 0; Counter < BytesOnLine; Counter++,
            CurrentByteIndex++) {

            //
            //  Determine what colors to use to paint the current byte.
            //

            if (CurrentByteIndex >= pHexEditData->MinimumSelectedIndex) {

                if (CurrentByteIndex >= pHexEditData->MaximumSelectedIndex) {

                    if (fUsingHighlight) {

                        fUsingHighlight = FALSE;

                        SetBkColor(hDC, g_clrWindow);
                        SetTextColor(hDC, g_clrWindowText);

                    }

                }

                else {

                    if (!fUsingHighlight) {

                        fUsingHighlight = TRUE;

                        SetBkColor(hDC, g_clrHighlight);
                        SetTextColor(hDC, g_clrHighlightText);

                    }

                }

            }

            Byte = pHexEditData->pBuffer[CurrentByteIndex];

            //
            //  Paint the hexadecimal representation.
            //

            TextRect.left = TextRect.right;
            TextRect.right += pHexEditData->xHexDumpByteWidth;

            wsprintf(Buffer, s_HexByteFormatSpec, Byte);

            ExtTextOut(hDC, x, TextRect.top, ETO_OPAQUE, &TextRect,
                Buffer, 2, NULL);

            x += pHexEditData->xHexDumpByteWidth;

            //
            //  Paint the ASCII representation.
            //

            AsciiTextRect.left = AsciiTextRect.right;
            AsciiTextRect.right += pHexEditData->FontMaxWidth;

            Buffer[0] = (TCHAR) (((Byte & 0x7F) >= ' ') ? Byte : '.');

            ExtTextOut(hDC, AsciiTextRect.left, AsciiTextRect.top, ETO_OPAQUE,
                &AsciiTextRect, Buffer, 1, NULL);

        }

        //
        //  Paint any leftover strips between the hexadecimal and ASCII columns
        //  and the ASCII column and the right edge of the window.
        //

        if (fUsingHighlight) {

            fUsingHighlight = FALSE;

            SetBkColor(hDC, g_clrWindow);
            SetTextColor(hDC, g_clrWindowText);

        }

        TextRect.left = TextRect.right;
        TextRect.right = pHexEditData->xAsciiDumpStart;

        ExtTextOut(hDC, TextRect.left, TextRect.top, ETO_OPAQUE, &TextRect,
            NULL, 0, NULL);

        AsciiTextRect.left = AsciiTextRect.right;
        AsciiTextRect.right = pHexEditData->cxWindow;

        ExtTextOut(hDC, AsciiTextRect.left, AsciiTextRect.top, ETO_OPAQUE,
            &AsciiTextRect, NULL, 0, NULL);

        CurrentLine++;

    }

    //
    //  Paint any remaining space in the control by filling it with the
    //  background color.
    //

    if (TextRect.bottom < lpUpdateRect-> bottom) {

        TextRect.left = 0;
        TextRect.right = pHexEditData->cxWindow;
        TextRect.top = TextRect.bottom;
        TextRect.bottom = lpUpdateRect-> bottom;

        ExtTextOut(hDC, 0, TextRect.top, ETO_OPAQUE, &TextRect, NULL, 0, NULL);

    }

    if (pHexEditData->hFont)
        SelectFont(hDC, hPrevFont);

}

/*******************************************************************************
*
*  HexEdit_OnSetFocus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnSetFocus(
    HWND hWnd
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    pHexEditData->Flags |= HEF_FOCUS;

    CreateCaret(hWnd, NULL, 0, pHexEditData->FontHeight);
    HexEdit_SetCaretPosition(hWnd);
    ShowCaret(hWnd);

}

/*******************************************************************************
*
*  HexEdit_OnKillFocus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnKillFocus(
    HWND hWnd
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (pHexEditData->Flags & HEF_FOCUS) {

        pHexEditData->Flags &= ~HEF_FOCUS;

        DestroyCaret();

    }

}

/*******************************************************************************
*
*  HexEdit_OnLButtonDown
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     fDoubleClick, TRUE if this is a double-click message, else FALSE.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    )
{

    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    int NewCaretIndex;

    if (fDoubleClick) {

        if (pHexEditData->CaretIndex + 1 <= pHexEditData->cbBuffer)
        {
            HexEdit_ChangeCaretIndex(hWnd, pHexEditData->CaretIndex + 1, TRUE);
        }
        return;

    }

    NewCaretIndex = HexEdit_HitTest(pHexEditData, x, y);

    HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, (KeyFlags & MK_SHIFT));

    //
    //  If we don't already have the focus, try to get it.
    //

    if (!(pHexEditData->Flags & HEF_FOCUS))
        SetFocus(hWnd);

    SetCapture(hWnd);
    pHexEditData->Flags |= HEF_DRAGGING;

    pHexEditData->xPrevMessagePos = x;
    pHexEditData->yPrevMessagePos = y;

    SetTimer(hWnd, 1, 400, NULL);

    UNREFERENCED_PARAMETER(fDoubleClick);

}

/*******************************************************************************
*
*  HexEdit_OnMouseMove
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnMouseMove(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    )
{

    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    int NewCaretIndex;

    if (!(pHexEditData->Flags & HEF_DRAGGING))
        return;

    NewCaretIndex = HexEdit_HitTest(pHexEditData, x, y);

    HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, TRUE);

    pHexEditData->xPrevMessagePos = x;
    pHexEditData->yPrevMessagePos = y;

    {

    int i, j;

    i = y < 0 ? -y : y - pHexEditData->cyWindow;
    j = 400 - ((UINT)i << 4);
    if (j < 100)
        j = 100;
    SetTimer(hWnd, 1, j, NULL);

    }

    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  HexEdit_OnLButtonUp
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnLButtonUp(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (!(pHexEditData->Flags & HEF_DRAGGING))
        return;

    KillTimer(hWnd, 1);

    ReleaseCapture();
    pHexEditData->Flags &= ~HEF_DRAGGING;

    UNREFERENCED_PARAMETER(x);
    UNREFERENCED_PARAMETER(y);
    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  HexEdit_HitTest
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     (returns), index of "hit" byte.
*
*******************************************************************************/

int
PASCAL
HexEdit_HitTest(
    HEXEDITDATA * pHexEditData,
    int x,
    int y
    )
{

    int HitLine;
    int BytesOnHitLine;
    int HitByte;

    //
    //  Figure out which line the user clicked on and how many bytes are on that
    //  line.
    //

    if (y < 0)
        HitLine = -1;

    else if (y >= pHexEditData->cyWindow)
        HitLine = pHexEditData->LinesVisible + 1;

    else
        HitLine = y / pHexEditData->FontHeight;

    HitLine += pHexEditData->FirstVisibleLine;

    if (HitLine >= pHexEditData->MaximumLines) {

        HitLine = pHexEditData->MaximumLines;

        BytesOnHitLine = (pHexEditData->cbBuffer + 1) %
            BYTES_PER_HEXEDIT_LINE;

        if (BytesOnHitLine == 0)
            BytesOnHitLine = BYTES_PER_HEXEDIT_LINE;

    }

    else {

        if (HitLine < 0)
            HitLine = 0;

        BytesOnHitLine = BYTES_PER_HEXEDIT_LINE;

    }

    //
    //
    //

    if (x < pHexEditData->xHexDumpStart)
        x = pHexEditData->xHexDumpStart;

    if (x >= pHexEditData->xHexDumpStart && x <
        pHexEditData->xHexDumpStart + pHexEditData->xHexDumpByteWidth *
        BYTES_PER_HEXEDIT_LINE + pHexEditData->FontMaxWidth) {

        x -= pHexEditData->xHexDumpStart;

        HitByte = x / pHexEditData->xHexDumpByteWidth;

        pHexEditData->Flags &= ~HEF_CARETINASCIIDUMP;

    }

    else {

        HitByte = (x - (pHexEditData->xAsciiDumpStart -
            pHexEditData->FontMaxWidth / 2)) / pHexEditData->FontMaxWidth;

        pHexEditData->Flags |= HEF_CARETINASCIIDUMP;

    }

    //
    //  We allow the user to "hit" the first byte of any line via two ways:
    //      *  clicking before the first byte on that line.
    //      *  clicking beyond the last byte/character of either display of the
    //         previous line.
    //
    //  We would like to see the latter case so that dragging in the control
    //  works naturally-- it's possible to drag to the end of the line to select
    //  the entire range.
    //

    pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;

    if (HitByte >= BytesOnHitLine) {

        if (BytesOnHitLine == BYTES_PER_HEXEDIT_LINE) {

            HitByte = BYTES_PER_HEXEDIT_LINE;
            pHexEditData->Flags |= HEF_CARETATENDOFLINE;

        }

        else
            HitByte = BytesOnHitLine - 1;

    }

    return HitLine * BYTES_PER_HEXEDIT_LINE + HitByte;

}

/*******************************************************************************
*
*  HexEdit_OnKey
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Char,
*     cRepeat,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnKey(
    HWND hWnd,
    UINT VirtualKey,
    BOOL fDown,
    int cRepeat,
    UINT Flags
    )
{
    BOOL fControlDown;
    BOOL fShiftDown;
    int NewCaretIndex;
    UINT ScrollCode;
    BOOL bPrevious = FALSE;
    HWND hTabWnd;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    fControlDown = (GetKeyState(VK_CONTROL) < 0);
    fShiftDown = (GetKeyState(VK_SHIFT) < 0);

    NewCaretIndex = pHexEditData->CaretIndex;

    switch (VirtualKey) {

        case VK_TAB:
            if (fShiftDown && !fControlDown)
            {
                // tab to the previous control
                bPrevious = TRUE;
            }
            else 
            if (!fShiftDown && !fControlDown)
            {
                // tab to the next control
                bPrevious = FALSE;
            }

            hTabWnd = GetNextDlgTabItem(GetParent(hWnd), hWnd, bPrevious);
            SetFocus(hTabWnd);
            
            break;

        case VK_UP:
            if (fControlDown)
                break;

            NewCaretIndex -= BYTES_PER_HEXEDIT_LINE;
            goto onkey_CheckLowerBound;

        case VK_DOWN:
            if (fControlDown)
                break;

            NewCaretIndex += BYTES_PER_HEXEDIT_LINE;

            if (NewCaretIndex / BYTES_PER_HEXEDIT_LINE >
                pHexEditData->MaximumLines) {

                if (pHexEditData->Flags & HEF_CARETATENDOFLINE)
                    goto onkey_MoveToEndOfBuffer;

                break;

            }

            goto onkey_CheckUpperBound;

        case VK_HOME:
            if (fControlDown)
                NewCaretIndex = 0;

            else {

                if (pHexEditData->Flags & HEF_CARETATENDOFLINE)
                    NewCaretIndex -= BYTES_PER_HEXEDIT_LINE;

                else
                    NewCaretIndex &= (~BYTES_PER_HEXEDIT_LINE_MASK);

            }

            pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;

            goto onkey_ChangeCaretIndex;

        case VK_END:
            if (fControlDown) {

onkey_MoveToEndOfBuffer:
                pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;
                NewCaretIndex = pHexEditData->cbBuffer;

            }

            else {

                if (pHexEditData->Flags & HEF_CARETATENDOFLINE)
                    break;

                NewCaretIndex = (NewCaretIndex &
                    (~BYTES_PER_HEXEDIT_LINE_MASK)) + BYTES_PER_HEXEDIT_LINE;

                if (NewCaretIndex > pHexEditData->cbBuffer)
                    NewCaretIndex = pHexEditData->cbBuffer;

                else
                    pHexEditData->Flags |= HEF_CARETATENDOFLINE;

            }

            goto onkey_ChangeCaretIndex;

        case VK_PRIOR:
        case VK_NEXT:
            NewCaretIndex -= pHexEditData->FirstVisibleLine *
                BYTES_PER_HEXEDIT_LINE;

            ScrollCode = ((VirtualKey == VK_PRIOR) ? SB_PAGEUP : SB_PAGEDOWN);

            HexEdit_OnVScroll(hWnd, NULL, ScrollCode, 0);

            NewCaretIndex += pHexEditData->FirstVisibleLine *
                BYTES_PER_HEXEDIT_LINE;

            if (VirtualKey == VK_PRIOR)
                goto onkey_CheckLowerBound;

            else
                goto onkey_CheckUpperBound;

        case VK_LEFT:
            if (fControlDown)
            {
                // toggle back and forth between hex and ascii
                if (pHexEditData->Flags & HEF_CARETINASCIIDUMP)
                    pHexEditData->Flags &= ~HEF_CARETINASCIIDUMP;
                else
                    pHexEditData->Flags |= HEF_CARETINASCIIDUMP;
            
                goto onkey_ChangeCaretIndex;
            }

            pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;
            NewCaretIndex--;

onkey_CheckLowerBound:
            if (NewCaretIndex < 0)
                break;

            goto onkey_ChangeCaretIndex;

        case VK_RIGHT:
            if (fControlDown)
            {
                // toggle back and forth between hex and ascii
                if (pHexEditData->Flags & HEF_CARETINASCIIDUMP)
                    pHexEditData->Flags &= ~HEF_CARETINASCIIDUMP;
                else
                    pHexEditData->Flags |= HEF_CARETINASCIIDUMP;
            
                goto onkey_ChangeCaretIndex;
            }

            pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;
            NewCaretIndex++;

onkey_CheckUpperBound:
            if (NewCaretIndex > pHexEditData->cbBuffer)
                NewCaretIndex = pHexEditData->cbBuffer;

onkey_ChangeCaretIndex:
            HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, fShiftDown);
            break;

        case VK_DELETE:
            if (!fControlDown) {

                if (fShiftDown)
                    HexEdit_OnChar(hWnd, IDKEY_CUT, 0);
                else
                    HexEdit_DeleteRange(hWnd, VK_DELETE);

            }
            break;

        case VK_INSERT:
            if (fShiftDown) {

                if (!fControlDown)
                    HexEdit_OnChar(hWnd, IDKEY_PASTE, 0);

            }

            else if (fControlDown)
                HexEdit_OnChar(hWnd, IDKEY_COPY, 0);
            break;

    }
}

/*******************************************************************************
*
*  HexEdit_OnChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Char,
*     cRepeat,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnChar(
    HWND hWnd,
    TCHAR Char,
    int cRepeat
    )
{

    PBYTE pCaretByte;
    BYTE NewCaretByte;
    int PrevCaretIndex;
    RECT UpdateRect;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    //
    //  Check for any special control characters.
    //

    switch (Char) {

        case IDKEY_COPY:
            HexEdit_OnCopy(hWnd);
            return;

        case IDKEY_PASTE:
            PrevCaretIndex = pHexEditData->CaretIndex;

            if (HexEdit_OnPaste(hWnd))
                goto UpdateDisplay;

            return;

        case IDKEY_CUT:
            if (!HexEdit_OnCopy(hWnd))
                return;
            //  FALL THROUGH

        case VK_BACK:
            HexEdit_DeleteRange(hWnd, VK_BACK);
            return;

        case VK_TAB:
            return;
    }

    //
    //  Validate and convert the typed character depending on the "column" the
    //  user is typing in.
    //

    if (pHexEditData->Flags & HEF_CARETINASCIIDUMP) {

        if (Char < ' ') {

            MessageBeep(MB_OK);
            return;

        }

        NewCaretByte = (BYTE) Char;

    }

    else {

        Char = (TCHAR) CharLower((LPTSTR) Char);

        if (Char >= '0' && Char <= '9')
            NewCaretByte = (BYTE) (Char - '0');

        else if (Char >= 'a' && Char <= 'f')
            NewCaretByte = (BYTE) (Char - 'a' + 10);

        else {

            MessageBeep(MB_OK);
            return;

        }

    }

    if (!(pHexEditData->Flags & HEF_INSERTATLOWNIBBLE)) {

        //
        //  Check to see if we're inserting while a range is selected.  If so,
        //  delete the range and insert at the start of the range.
        //

        if (pHexEditData->MinimumSelectedIndex !=
            pHexEditData->MaximumSelectedIndex)
            HexEdit_DeleteRange(hWnd, 0);

        //
        //  Verify that we aren't overruning the value data buffer.
        //

        if (pHexEditData->cbBuffer >= MAXDATA_LENGTH) {

            MessageBeep(MB_OK);
            return;

        }

        //
        //  Make room for the new byte by shifting all bytes after the insertion
        //  point down one byte.
        //

        pCaretByte = pHexEditData->pBuffer + pHexEditData->CaretIndex;

        MoveMemory(pCaretByte + 1, pCaretByte, pHexEditData->cbBuffer -
            pHexEditData->CaretIndex);

        pHexEditData->cbBuffer++;

        HexEdit_SetScrollInfo(hWnd);

        if (pHexEditData->Flags & HEF_CARETINASCIIDUMP)
            *pCaretByte = NewCaretByte;

        else {

            pHexEditData->Flags |= HEF_INSERTATLOWNIBBLE;

            *pCaretByte = NewCaretByte << 4;

        }

    }

    else {

        pHexEditData->Flags &= ~HEF_INSERTATLOWNIBBLE;

        *(pHexEditData->pBuffer + pHexEditData->CaretIndex) |= NewCaretByte;

    }

    PrevCaretIndex = pHexEditData->CaretIndex;

    if (!(pHexEditData->Flags & HEF_INSERTATLOWNIBBLE)) {

        pHexEditData->CaretIndex++;

        pHexEditData->MinimumSelectedIndex = pHexEditData->CaretIndex;
        pHexEditData->MaximumSelectedIndex = pHexEditData->CaretIndex;

    }

UpdateDisplay:
    pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;
    HexEdit_EnsureCaretVisible(hWnd);

    UpdateRect.left = 0;
    UpdateRect.right = pHexEditData->cxWindow;
    UpdateRect.top = (PrevCaretIndex / BYTES_PER_HEXEDIT_LINE -
        pHexEditData->FirstVisibleLine) * pHexEditData->FontHeight;
    UpdateRect.bottom = pHexEditData->cyWindow;

    SendMessage(GetParent(hWnd), WM_COMMAND,
                MAKEWPARAM(GetWindowLongPtr(hWnd, GWLP_ID), EN_CHANGE), (LPARAM)hWnd);

    InvalidateRect(hWnd, &UpdateRect, FALSE);

}

/*******************************************************************************
*
*  HexEdit_SetCaretPosition
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_SetCaretPosition(
    HWND hWnd
    )
{

    int CaretByte;
    int xCaret;
    int yCaret;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    CaretByte = pHexEditData->CaretIndex % BYTES_PER_HEXEDIT_LINE;

    yCaret = (pHexEditData->CaretIndex / BYTES_PER_HEXEDIT_LINE -
        pHexEditData->FirstVisibleLine) * pHexEditData->FontHeight;

    //
    //  Check if caret should really be displayed at the end of the previous
    //  line.
    //

    if (pHexEditData->Flags & HEF_CARETATENDOFLINE) {

        CaretByte = BYTES_PER_HEXEDIT_LINE;
        yCaret -= pHexEditData->FontHeight;

    }

    //
    //  Figure out which "column" the user is editing in and thus should have
    //  the caret.
    //

    if (pHexEditData->Flags & HEF_CARETINASCIIDUMP) {

        xCaret = pHexEditData->xAsciiDumpStart + CaretByte *
            pHexEditData->FontMaxWidth;

    }

    else {

        xCaret = pHexEditData->xHexDumpStart + CaretByte *
            pHexEditData->xHexDumpByteWidth;

        if (pHexEditData->Flags & HEF_INSERTATLOWNIBBLE)
            xCaret += pHexEditData->FontMaxWidth * 3 / 2;

    }

    SetCaretPos(xCaret, yCaret);

}

/*******************************************************************************
*
*  HexEdit_EnsureCaretVisible
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_EnsureCaretVisible(
    HWND hWnd
    )
{

    int CaretLine;
    int LastVisibleLine;
    int Delta;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (!(pHexEditData->Flags & HEF_FOCUS))
        return;

    CaretLine = pHexEditData->CaretIndex / BYTES_PER_HEXEDIT_LINE;

    //
    //  Check if caret should really be displayed at the end of the previous
    //  line.
    //

    if (pHexEditData->Flags & HEF_CARETATENDOFLINE)
        CaretLine--;

    LastVisibleLine = pHexEditData->FirstVisibleLine +
        pHexEditData->LinesVisible - 1;

    if (CaretLine > LastVisibleLine)
        Delta = LastVisibleLine;

    else if (CaretLine < pHexEditData->FirstVisibleLine)
        Delta = pHexEditData->FirstVisibleLine;

    else
        Delta = -1;

    if (Delta != -1) {

        ScrollWindowEx(hWnd, 0, (Delta - CaretLine) * pHexEditData->FontHeight,
            NULL, NULL, NULL, NULL, SW_INVALIDATE);

        pHexEditData->FirstVisibleLine += CaretLine - Delta;

        HexEdit_SetScrollInfo(hWnd);

    }

    HexEdit_SetCaretPosition(hWnd);

}

/*******************************************************************************
*
*  HexEdit_ChangeCaretIndex
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     NewCaretIndex,
*     fExtendSelection,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_ChangeCaretIndex(
    HWND hWnd,
    int NewCaretIndex,
    BOOL fExtendSelection
    )
{

    int PrevMinimumSelectedIndex;
    int PrevMaximumSelectedIndex;
    int Swap;
    int UpdateRectCount;
    RECT UpdateRect[2];
    BOOL fPrevRangeEmpty;
    HDC hDC;
    int Index;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    pHexEditData->Flags &= ~HEF_INSERTATLOWNIBBLE;

    PrevMinimumSelectedIndex = pHexEditData->MinimumSelectedIndex;
    PrevMaximumSelectedIndex = pHexEditData->MaximumSelectedIndex;

    if (fExtendSelection) {

        if (pHexEditData->CaretIndex == pHexEditData->MaximumSelectedIndex)
            pHexEditData->MaximumSelectedIndex = NewCaretIndex;

        else
            pHexEditData->MinimumSelectedIndex = NewCaretIndex;

        if (pHexEditData->MinimumSelectedIndex >
            pHexEditData->MaximumSelectedIndex) {

            Swap = pHexEditData->MinimumSelectedIndex;
            pHexEditData->MinimumSelectedIndex =
                pHexEditData->MaximumSelectedIndex;
            pHexEditData->MaximumSelectedIndex = Swap;

        }

    }

    else {

        pHexEditData->MinimumSelectedIndex = NewCaretIndex;
        pHexEditData->MaximumSelectedIndex = NewCaretIndex;

    }

    pHexEditData->CaretIndex = NewCaretIndex;

    UpdateRectCount = 0;

    if (pHexEditData->MinimumSelectedIndex > PrevMinimumSelectedIndex) {

        UpdateRect[0].top = PrevMinimumSelectedIndex;
        UpdateRect[0].bottom = pHexEditData->MinimumSelectedIndex;

        UpdateRectCount++;

    }

    else if (pHexEditData->MinimumSelectedIndex < PrevMinimumSelectedIndex) {

        UpdateRect[0].top = pHexEditData->MinimumSelectedIndex;
        UpdateRect[0].bottom = PrevMinimumSelectedIndex;

        UpdateRectCount++;

    }

    if (pHexEditData->MaximumSelectedIndex > PrevMaximumSelectedIndex) {

        UpdateRect[UpdateRectCount].top = PrevMaximumSelectedIndex;
        UpdateRect[UpdateRectCount].bottom = pHexEditData->MaximumSelectedIndex;

        UpdateRectCount++;

    }

    else if (pHexEditData->MaximumSelectedIndex < PrevMaximumSelectedIndex) {

        UpdateRect[UpdateRectCount].top = pHexEditData->MaximumSelectedIndex;
        UpdateRect[UpdateRectCount].bottom = PrevMaximumSelectedIndex;

        UpdateRectCount++;

    }

    if (fPrevRangeEmpty = (PrevMinimumSelectedIndex ==
        PrevMaximumSelectedIndex)) {

        UpdateRect[0].top = pHexEditData->MinimumSelectedIndex;
        UpdateRect[0].bottom = pHexEditData->MaximumSelectedIndex;

        UpdateRectCount = 1;

    }

    if (pHexEditData->MinimumSelectedIndex ==
        pHexEditData->MaximumSelectedIndex) {

        if (!fPrevRangeEmpty) {

            UpdateRect[0].top = PrevMinimumSelectedIndex;
            UpdateRect[0].bottom = PrevMaximumSelectedIndex;

            UpdateRectCount = 1;

        }

        else
            UpdateRectCount = 0;

    }

    if (UpdateRectCount) {

        HideCaret(hWnd);

        hDC = GetDC(hWnd);
        if (hDC)
        {
            for (Index = 0; Index < UpdateRectCount; Index++) 
            {

                UpdateRect[Index].top = (UpdateRect[Index].top /
                    BYTES_PER_HEXEDIT_LINE - pHexEditData->FirstVisibleLine) *
                    pHexEditData->FontHeight;
                UpdateRect[Index].bottom = (UpdateRect[Index].bottom /
                    BYTES_PER_HEXEDIT_LINE - pHexEditData->FirstVisibleLine + 1) *
                    pHexEditData->FontHeight;

                if (UpdateRect[Index].top >= pHexEditData->cyWindow ||
                    UpdateRect[Index].bottom < 0)
                    continue;

                if (UpdateRect[Index].top < 0)
                    UpdateRect[Index].top = 0;

                if (UpdateRect[Index].bottom > pHexEditData->cyWindow)
                    UpdateRect[Index].bottom = pHexEditData->cyWindow;

                HexEdit_PaintRect(hWnd, hDC, &UpdateRect[Index]);
            }
    
            ReleaseDC(hWnd, hDC);
        }

        ShowCaret(hWnd);

    }


    HexEdit_EnsureCaretVisible(hWnd);

}

/*******************************************************************************
*
*  HexEdit_DeleteRange
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_DeleteRange(
    HWND hWnd,
    UINT SourceKey
    )
{

    int MinimumSelectedIndex;
    int MaximumSelectedIndex;
    PBYTE pMinimumSelectedByte;
    int Length;
    RECT UpdateRect;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;

    MinimumSelectedIndex = pHexEditData->MinimumSelectedIndex;
    MaximumSelectedIndex = pHexEditData->MaximumSelectedIndex;

    //
    //  Check to see if a range is selected.  If not, then artificially create
    //  one based on the key that caused this routine to be called.
    //

    if (MinimumSelectedIndex == MaximumSelectedIndex) {

        if (SourceKey == VK_DELETE || pHexEditData->Flags &
            HEF_INSERTATLOWNIBBLE) {

            pHexEditData->Flags &= ~HEF_INSERTATLOWNIBBLE;

            MaximumSelectedIndex++;

            if (MaximumSelectedIndex > pHexEditData->cbBuffer)
                return;

        }

        else if (SourceKey == VK_BACK) {

            MinimumSelectedIndex--;

            if (MinimumSelectedIndex < 0)
                return;

        }

        else
            return;

    }

    //
    //  Compute where to start deleting from and the number of bytes to delete.
    //

    pMinimumSelectedByte = pHexEditData->pBuffer + MinimumSelectedIndex;

    Length = MaximumSelectedIndex - MinimumSelectedIndex;

    //
    //  Delete the bytes and update all appropriate window data.
    //

    MoveMemory(pMinimumSelectedByte, pMinimumSelectedByte + Length,
        pHexEditData->cbBuffer - MaximumSelectedIndex);

    pHexEditData->cbBuffer -= Length;

    pHexEditData->CaretIndex = MinimumSelectedIndex;
    pHexEditData->MinimumSelectedIndex = MinimumSelectedIndex;
    pHexEditData->MaximumSelectedIndex = MinimumSelectedIndex;

    HexEdit_SetScrollInfo(hWnd);

    HexEdit_EnsureCaretVisible(hWnd);

    UpdateRect.left = 0;
    UpdateRect.right = pHexEditData->cxWindow;
    UpdateRect.top = (MinimumSelectedIndex / BYTES_PER_HEXEDIT_LINE -
        pHexEditData->FirstVisibleLine) * pHexEditData->FontHeight;
    UpdateRect.bottom = pHexEditData->cyWindow;

    SendMessage(GetParent(hWnd), WM_COMMAND,
                MAKEWPARAM(GetWindowLongPtr(hWnd, GWLP_ID), EN_CHANGE), (LPARAM)hWnd);

    InvalidateRect(hWnd, &UpdateRect, FALSE);

}

/*******************************************************************************
*
*  HexEdit_OnCopy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnCopy(
    HWND hWnd
    )
{

    BOOL fSuccess;
    int cbClipboardData;
    LPBYTE lpStartByte;
    HANDLE hClipboardData;
    LPHEXEDITCLIPBOARDDATA lpClipboardData;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    fSuccess = FALSE;

    cbClipboardData = pHexEditData->MaximumSelectedIndex -
        pHexEditData->MinimumSelectedIndex;

    if (cbClipboardData != 0) {

        lpStartByte = pHexEditData->pBuffer +
            pHexEditData->MinimumSelectedIndex;

        if (OpenClipboard(hWnd)) {

            if ((hClipboardData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                cbClipboardData + sizeof(HEXEDITCLIPBOARDDATA) - 1)) != NULL) {

                lpClipboardData = (LPHEXEDITCLIPBOARDDATA)
                    GlobalLock(hClipboardData);
                CopyMemory(lpClipboardData-> Data, lpStartByte,
                    cbClipboardData);
                lpClipboardData-> cbSize = cbClipboardData;
                GlobalUnlock(hClipboardData);

                EmptyClipboard();
                SetClipboardData(s_HexEditClipboardFormat, hClipboardData);

                fSuccess = TRUE;

            }

            CloseClipboard();

        }

    }

    return fSuccess;

}

/*******************************************************************************
*
*  HexEdit_OnPaste
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnPaste(
    HWND hWnd
    )
{

    BOOL fSuccess;
    HANDLE hClipboardData;
    LPHEXEDITCLIPBOARDDATA lpClipboardData;
    PBYTE pCaretByte;
    DWORD cbSize;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    fSuccess = FALSE;

    if (pHexEditData->Flags & HEF_INSERTATLOWNIBBLE) {

        pHexEditData->Flags &= ~HEF_INSERTATLOWNIBBLE;
        pHexEditData->CaretIndex++;

    }

    if (OpenClipboard(hWnd)) {

        if ((hClipboardData = GetClipboardData(s_HexEditClipboardFormat)) !=
            NULL) {

            lpClipboardData = (LPHEXEDITCLIPBOARDDATA)
                GlobalLock(hClipboardData);

            if (pHexEditData->cbBuffer + lpClipboardData-> cbSize <=
                MAXDATA_LENGTH) {

                if (pHexEditData->MinimumSelectedIndex !=
                    pHexEditData->MaximumSelectedIndex)
                    HexEdit_DeleteRange(hWnd, VK_BACK);

                //
                //  Make room for the new bytes by shifting all bytes after the
                //  the insertion point down the necessary amount.
                //

                pCaretByte = pHexEditData->pBuffer + pHexEditData->CaretIndex;
                cbSize = lpClipboardData-> cbSize;

                MoveMemory(pCaretByte + cbSize, pCaretByte,
                    pHexEditData->cbBuffer - pHexEditData->CaretIndex);
                CopyMemory(pCaretByte, lpClipboardData-> Data, cbSize);

                pHexEditData->cbBuffer += cbSize;
                pHexEditData->CaretIndex += cbSize;

                HexEdit_SetScrollInfo(hWnd);

                fSuccess = TRUE;

            }

            GlobalUnlock(hClipboardData);

        }

        CloseClipboard();

    }

    return fSuccess;

}

/*******************************************************************************
*
*  HexEdit_OnContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, horizontal position of the cursor.
*     y, vertical position of the cursor.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnContextMenu(
    HWND hWnd,
    int x,
    int y
    )
{

    HMENU hContextMenu;
    HMENU hContextPopupMenu;
    int MenuCommand;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    //
    //  Give us the focus if we don't already have it.
    //

    if (!(pHexEditData->Flags & HEF_FOCUS))
        SetFocus(hWnd);

    //
    //  Load the HexEdit context menu from our resources.
    //

    if ((hContextMenu = LoadMenu(g_hInstance,
        MAKEINTRESOURCE(IDM_HEXEDIT_CONTEXT))) == NULL)
        return;

    hContextPopupMenu = GetSubMenu(hContextMenu, 0);

    //
    //  Disable editing menu options as appropriate.
    //

    if (pHexEditData->MinimumSelectedIndex ==
        pHexEditData->MaximumSelectedIndex) {

        EnableMenuItem(hContextPopupMenu, IDKEY_COPY, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hContextPopupMenu, IDKEY_CUT, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hContextPopupMenu, VK_DELETE, MF_BYCOMMAND | MF_GRAYED);

    }

    if (!IsClipboardFormatAvailable(s_HexEditClipboardFormat))
        EnableMenuItem(hContextPopupMenu, IDKEY_PASTE, MF_BYCOMMAND |
            MF_GRAYED);

    if (pHexEditData->MinimumSelectedIndex == 0 &&
        pHexEditData->MaximumSelectedIndex == pHexEditData->cbBuffer)
        EnableMenuItem(hContextPopupMenu, ID_SELECTALL, MF_BYCOMMAND |
            MF_GRAYED);

    //
    //  Display and handle the selected command.
    //

    MenuCommand = TrackPopupMenuEx(hContextPopupMenu, TPM_RETURNCMD |
        TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, x, y, hWnd, NULL);

    DestroyMenu(hContextMenu);

    switch (MenuCommand) {

        case IDKEY_COPY:
        case IDKEY_PASTE:
        case IDKEY_CUT:
        case VK_DELETE:
            HexEdit_OnChar(hWnd, (TCHAR) MenuCommand, 0);
            break;

        case ID_SELECTALL:
            pHexEditData->MinimumSelectedIndex = 0;
            pHexEditData->MaximumSelectedIndex = pHexEditData->cbBuffer;
            pHexEditData->CaretIndex = pHexEditData->cbBuffer;
            HexEdit_SetCaretPosition(hWnd);
            InvalidateRect(hWnd, NULL, FALSE);
            break;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\bootppp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	bootppp.h
		The bootp properties page
		
    FILE HISTORY:
        
*/

#if !defined(AFX_BOOTPPP_H__A1A51386_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
#define AFX_BOOTPPP_H__A1A51386_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CBootpPropGeneral dialog

class CBootpPropGeneral : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CBootpPropGeneral)

// Construction
public:
	CBootpPropGeneral();
	~CBootpPropGeneral();

// Dialog Data
	//{{AFX_DATA(CBootpPropGeneral)
	enum { IDD = IDP_BOOTP_GENERAL };
	CString	m_strFileName;
	CString	m_strFileServer;
	CString	m_strImageName;
	//}}AFX_DATA

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CBootpPropGeneral::IDD); }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBootpPropGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CBootpPropGeneral)
	afx_msg void OnChangeEditBootpFileName();
	afx_msg void OnChangeEditBootpFileServer();
	afx_msg void OnChangeEditBootpImageName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CBootpProperties : public CPropertyPageHolderBase
{
	friend class CBootpPropGeneral;

public:
	CBootpProperties(ITFSNode *		  pNode,
					 IComponentData *	  pComponentData,
					 ITFSComponentData * pTFSCompData,
					 LPCTSTR			  pszSheetName);
	virtual ~CBootpProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}


public:
	CBootpPropGeneral		m_pageGeneral;

protected:
	SPITFSComponentData		m_spTFSCompData;
};

#endif // !defined(AFX_BOOTPPP_H__A1A51386_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\classes.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	Classes.h
		This file contains all of the prototypes for the 
		option class dialog.

    FILE HISTORY:
        
*/

#if !defined _CLASSES_H
#define _CLASSES_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _CLASSMOD_H
#include "classmod.h"
#endif 

/////////////////////////////////////////////////////////////////////////////
// CDhcpClasses dialog

class CDhcpClasses : public CBaseDialog
{
// Construction
public:
	CDhcpClasses(CClassInfoArray * pClassArray, LPCTSTR pszServer, DWORD dwType, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDhcpClasses)
	enum { IDD = IDD_CLASSES };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CDhcpClasses::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDhcpClasses)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDhcpClasses)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonDelete();
	afx_msg void OnButtonEdit();
	afx_msg void OnButtonNew();
	virtual void OnOK();
	afx_msg void OnItemchangedListClasses(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkListClasses(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void UpdateList();
    void UpdateButtons();

protected:
    CClassInfoArray *   m_pClassInfoArray;
    CString             m_strServer;

    DWORD               m_dwType;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLASSES_H__3995264E_96A1_11D1_93E0_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\classes.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	Classes.h
		This file contains all of the prototypes for the 
		option class dialog.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "classes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpClasses dialog


CDhcpClasses::CDhcpClasses(CClassInfoArray * pClassArray, LPCTSTR pszServer, DWORD dwType, CWnd* pParent /*=NULL*/)
	: CBaseDialog(CDhcpClasses::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDhcpClasses)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_dwType = dwType;
    m_strServer = pszServer;
    m_pClassInfoArray = pClassArray;
}


void CDhcpClasses::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDhcpClasses)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDhcpClasses, CBaseDialog)
	//{{AFX_MSG_MAP(CDhcpClasses)
	ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
	ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
	ON_BN_CLICKED(IDC_BUTTON_NEW, OnButtonNew)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_CLASSES, OnItemchangedListClasses)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_CLASSES, OnDblclkListClasses)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpClasses message handlers

BOOL CDhcpClasses::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strTitle;

	if (m_dwType == CLASS_TYPE_VENDOR)
    {
        strTitle.LoadString(IDS_VENDOR_CLASSES);
    }
    else
    {
        strTitle.LoadString(IDS_USER_CLASSES);
    }
	
    this->SetWindowText(strTitle);

    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);
    LV_COLUMN lvColumn;
    CString   strText;

    strText.LoadString(IDS_NAME);

    ListView_SetExtendedListViewStyle(pListCtrl->GetSafeHwnd(), LVS_EX_FULLROWSELECT);

    lvColumn.mask = LVCF_TEXT | LVCF_FMT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = 125;
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    
    pListCtrl->InsertColumn(0, &lvColumn);

    strText.LoadString(IDS_COMMENT);
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    lvColumn.cx = 175;
    pListCtrl->InsertColumn(1, &lvColumn);
       
    UpdateList();

    UpdateButtons();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDhcpClasses::OnButtonDelete() 
{
    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);
    int nSelectedItem = pListCtrl->GetNextItem(-1, LVNI_SELECTED);
    CClassInfo * pClassInfo = (CClassInfo *) pListCtrl->GetItemData(nSelectedItem);
    CString strMessage;

    AfxFormatString1(strMessage, IDS_CONFIRM_CLASS_DELETE, pClassInfo->strName);
    
    if (AfxMessageBox(strMessage, MB_YESNO) == IDYES)
    {
        DWORD dwError = ::DhcpDeleteClass((LPTSTR) ((LPCTSTR) m_strServer),
                                          0,
                                          (LPTSTR) ((LPCTSTR) pClassInfo->strName));
        if (dwError != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(dwError);
            return;
        }
        else
        {
            m_pClassInfoArray->RemoveClass(pClassInfo->strName);
            UpdateList();
            UpdateButtons();
        }
    }
}

void CDhcpClasses::OnButtonEdit() 
{
    CDhcpModifyClass dlgModify(m_pClassInfoArray, m_strServer, FALSE, m_dwType);
    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);

    // Find the selected item
    int nSelectedItem = pListCtrl->GetNextItem(-1, LVNI_SELECTED);

    CClassInfo * pClassInfo = (CClassInfo *) pListCtrl->GetItemData(nSelectedItem);

    dlgModify.m_EditValueParam.pValueName = (LPTSTR) ((LPCTSTR) pClassInfo->strName);
	dlgModify.m_EditValueParam.pValueComment = (LPTSTR) ((LPCTSTR) pClassInfo->strComment);
	dlgModify.m_EditValueParam.pValueData = pClassInfo->baData.GetData();
	dlgModify.m_EditValueParam.cbValueData = (UINT)pClassInfo->baData.GetSize();

    if (dlgModify.DoModal() == IDOK)
    {
        // need to refresh the view.
        UpdateList();
        UpdateButtons();
    }
}

void CDhcpClasses::OnButtonNew() 
{
    CDhcpModifyClass dlgModify(m_pClassInfoArray, m_strServer, TRUE, m_dwType);

    if (dlgModify.DoModal() == IDOK)
    {
        // need to refresh the view.
        UpdateList();
        UpdateButtons();
    }
}

void CDhcpClasses::OnOK() 
{
	CBaseDialog::OnOK();
}

void CDhcpClasses::UpdateList()
{
    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);
    pListCtrl->DeleteAllItems();

    for (int i = 0; i < m_pClassInfoArray->GetSize(); i++)
    {
        // add the appropriate classes depending on what we are looking at
        if ( (m_dwType == CLASS_TYPE_VENDOR &&
              (*m_pClassInfoArray)[i].bIsVendor) ||
             (m_dwType == CLASS_TYPE_USER &&
              !(*m_pClassInfoArray)[i].bIsVendor) )
        {
            int nPos = pListCtrl->InsertItem(i, (*m_pClassInfoArray)[i].strName);
            pListCtrl->SetItemText(nPos, 1, (*m_pClassInfoArray)[i].strComment);
            pListCtrl->SetItemData(nPos, (LPARAM) &(*m_pClassInfoArray)[i]);
        }
    }
}

void CDhcpClasses::UpdateButtons()
{
    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);
    BOOL bEnable = TRUE;
    CWnd * pCurFocus = GetFocus();

    if (pListCtrl->GetSelectedCount() == 0)
    {
        bEnable = FALSE;
    }

    CWnd * pEdit = GetDlgItem(IDC_BUTTON_EDIT);
    CWnd * pDelete = GetDlgItem(IDC_BUTTON_DELETE);

    if ( !bEnable &&
         ((pCurFocus == pEdit) ||
          (pCurFocus == pDelete)) )
    {
        GetDlgItem(IDCANCEL)->SetFocus();
        SetDefID(IDCANCEL);

        ((CButton *) pEdit)->SetButtonStyle(BS_PUSHBUTTON);
        ((CButton *) pDelete)->SetButtonStyle(BS_PUSHBUTTON);
    }

    // disable delete if this is the dynamic bootp class
    int nSelectedItem = pListCtrl->GetNextItem(-1, LVNI_SELECTED);
    if (nSelectedItem != -1)
    {
        CClassInfo * pClassInfo = (CClassInfo *) pListCtrl->GetItemData(nSelectedItem);
    
        if (pClassInfo->IsSystemClass() ||
			pClassInfo->IsRRASClass() ||
			pClassInfo->IsDynBootpClass())
        {
            bEnable = FALSE;
        }
    }

    pDelete->EnableWindow(bEnable);
    pEdit->EnableWindow(bEnable);
}

void CDhcpClasses::OnItemchangedListClasses(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    UpdateButtons();
	
	*pResult = 0;
}

void CDhcpClasses::OnDblclkListClasses(NMHDR* pNMHDR, LRESULT* pResult) 
{
    if (GetDlgItem(IDC_BUTTON_EDIT)->IsWindowEnabled())
        OnButtonEdit();
    
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\cred.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2000   **/
/**********************************************************************/

/*
	cred.cpp
		This file contains all of the prototypes for the 
		credentials dialog used for DDNS.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "cred.h"
#include "lsa.h"			// RtlEncodeW/RtlDecodeW

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCredentials dialog


CCredentials::CCredentials(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CCredentials::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCredentials)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CCredentials::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCredentials)
	DDX_Control(pDX, IDOK, m_buttonOk);
	DDX_Control(pDX, IDC_EDIT_CRED_USERNAME, m_editUsername);
	DDX_Control(pDX, IDC_EDIT_CRED_PASSWORD2, m_editPassword2);
	DDX_Control(pDX, IDC_EDIT_CRED_PASSWORD, m_editPassword);
	DDX_Control(pDX, IDC_EDIT_CRED_DOMAIN, m_editDomain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCredentials, CBaseDialog)
	//{{AFX_MSG_MAP(CCredentials)
	ON_EN_CHANGE(IDC_EDIT_CRED_USERNAME, OnChangeEditCredUsername)
	ON_EN_CHANGE(IDC_EDIT_CRED_DOMAIN, OnChangeEditCredDomain)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCredentials message handlers
BOOL CCredentials::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    CString strUsername, strDomain, dummyPasswd;
    LPTSTR pszUsername, pszDomain;

    pszUsername = strUsername.GetBuffer(MAX_PATH);
    pszDomain = strDomain.GetBuffer(MAX_PATH);

	// call the DHCP api to get the current username and domain
    DWORD err = DhcpServerQueryDnsRegCredentials((LPWSTR) ((LPCTSTR) m_strServerIp),
                                                 MAX_PATH,
                                                 pszUsername,
                                                 MAX_PATH,
                                                 pszDomain);

    strUsername.ReleaseBuffer();
    strDomain.ReleaseBuffer();

    if (err == ERROR_SUCCESS)
    {
        m_editUsername.SetWindowText(strUsername);
        m_editDomain.SetWindowText(strDomain);


        // set the password fields to something
        dummyPasswd = _T("xxxxxxxxxx");
        m_editPassword.SetWindowText( dummyPasswd  );
        m_editPassword2.SetWindowText( dummyPasswd );
    }
    else
    {
        ::DhcpMessageBox(err);
    }

    m_fNewUsernameOrDomain = FALSE;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCredentials::OnOK() 
{
    CString strUsername, strDomain, strPassword1, strPassword2, dummyPasswd;

    dummyPasswd = _T("xxxxxxxxxx");

    // grab the username and domain
    m_editUsername.GetWindowText(strUsername);
    m_editDomain.GetWindowText(strDomain);

    // grab the passwords and make sure they match
    m_editPassword.GetWindowText(strPassword1);
    m_editPassword2.GetWindowText(strPassword2);

    if (strPassword1.Compare(strPassword2) != 0)
    {
        // passwords don't match
        AfxMessageBox(IDS_PASSWORDS_DONT_MATCH);
        m_editPassword.SetFocus();
        return;
    }

    //
    // run through the following code if user changed passwd.
    //

    if ( strPassword2 != dummyPasswd )
    {

        // encode the password
        unsigned char ucSeed = DHCP_ENCODE_SEED;
        LPTSTR pszPassword = strPassword1.GetBuffer((strPassword1.GetLength() + 1) * sizeof(TCHAR));

        RtlEncodeW(&ucSeed, pszPassword);

        // send to the DHCP api.
        DWORD err = ERROR_SUCCESS;

        err = DhcpServerSetDnsRegCredentials((LPWSTR) ((LPCTSTR) m_strServerIp), 
                                         (LPWSTR) ((LPCTSTR) strUsername), 
                                         (LPWSTR) ((LPCTSTR) strDomain), 
                                         (LPWSTR) ((LPCTSTR) pszPassword));
        if (err != ERROR_SUCCESS)
        {
            // something failed, notify the user
            ::DhcpMessageBox(err);
            return;
        }
    }
	
	CBaseDialog::OnOK();
}

void CCredentials::OnChangeEditCredUsername() 
{
    if (!m_fNewUsernameOrDomain)
    {
        m_fNewUsernameOrDomain = TRUE;

        m_editPassword.SetWindowText(_T(""));
        m_editPassword2.SetWindowText(_T(""));
    }
}

void CCredentials::OnChangeEditCredDomain() 
{
    if (!m_fNewUsernameOrDomain)
    {
        m_fNewUsernameOrDomain = TRUE;

        m_editPassword.SetWindowText(_T(""));
        m_editPassword2.SetWindowText(_T(""));
    }
}

void CCredentials::SetServerIp(LPCTSTR pszServerIp)
{
    m_strServerIp = pszServerIp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\classmod.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ClassMod.h
		This file contains all of the prototypes for the 
		option class modification dialog.

    FILE HISTORY:
        
*/

#if !defined _CLASSMOD_H
#define _CLASSMOD_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#if !defined _CLASSED_H
    #include "classed.h"
#endif

#define     CLASS_TYPE_VENDOR  0
#define     CLASS_TYPE_USER    1

// CWnd based control for hex editor
class CWndHexEdit : public CWnd
{
    DECLARE_DYNAMIC(CWndHexEdit)

protected:
    static WNDPROC m_wproc_super ;
    static BOOL m_b_inited ;

public:

    CWndHexEdit () ;
    ~ CWndHexEdit () ;

    BOOL Create(LPCTSTR lpszText, 
        DWORD dwStyle,
        const RECT& rect, 
        CWnd* pParentWnd, 
        UINT nID = 0xffff
        );

    WNDPROC * GetSuperWndProcAddr() ;

    //  One-shot initialization
    static BOOL CreateWindowClass ( HINSTANCE hInstance );  
};

class CClassInfo
{
public:
    CClassInfo() {};
    CClassInfo(CClassInfo & classInfo)
    {
        *this = classInfo;
    }

    CClassInfo & operator = (const CClassInfo & ClassInfo)
    {
        strName = ClassInfo.strName;
        strComment = ClassInfo.strComment;
        bIsVendor = ClassInfo.bIsVendor;
        
        baData.RemoveAll();
        baData.Copy(ClassInfo.baData);

        return *this;
    }

    BOOL IsDynBootpClass()
    {
        BOOL fResult = FALSE;

	    if (baData.GetSize() == (int) strlen(DHCP_BOOTP_CLASS_TXT))
	    {
		    // now mem compare
		    if (memcmp(baData.GetData(), DHCP_BOOTP_CLASS_TXT, (size_t)baData.GetSize()) == 0)
		    {
			    // found it!
                fResult = TRUE;
            }
        }

        return fResult;
    }

    BOOL IsRRASClass()
    {
        BOOL fResult = FALSE;

	    if (baData.GetSize() == (int) strlen(DHCP_RAS_CLASS_TXT))
	    {
		    // now mem compare
		    if (memcmp(baData.GetData(), DHCP_RAS_CLASS_TXT, (size_t)baData.GetSize()) == 0)
		    {
			    // found it!
                fResult = TRUE;
            }
        }

        return fResult;
    }

    BOOL IsSystemClass()
    {
        BOOL fResult = FALSE;

		// check to see if this is one of the default clasess, if so disable
		if ( ((size_t) baData.GetSize() == strlen(DHCP_MSFT50_CLASS_TXT)) ||
			 ((size_t) baData.GetSize() == strlen(DHCP_MSFT98_CLASS_TXT)) ||
			 ((size_t) baData.GetSize() == strlen(DHCP_MSFT_CLASS_TXT)) )
		{
			if ( (memcmp(baData.GetData(), DHCP_MSFT50_CLASS_TXT, (size_t)baData.GetSize()) == 0) ||
				 (memcmp(baData.GetData(), DHCP_MSFT98_CLASS_TXT, (size_t)baData.GetSize()) == 0) ||
				 (memcmp(baData.GetData(), DHCP_MSFT_CLASS_TXT, (size_t)baData.GetSize()) == 0) )
			{
				fResult = TRUE;
			}
		}

        return fResult;
	}


public:    
    CString     strName;
    CString     strComment;
    BOOL        bIsVendor;
    CByteArray  baData;
};

typedef CArray<CClassInfo, CClassInfo&> CClassInfoArrayBase;

class CClassInfoArray : public CClassInfoArrayBase
{
public:
    CClassInfoArray();
    ~CClassInfoArray();

    DWORD   RefreshData(LPCTSTR pServer);
    BOOL    RemoveClass(LPCTSTR pClassName);
    DWORD   ModifyClass(LPCTSTR pServer, CClassInfo & ClassInfo);
    DWORD	AddClass(LPCTSTR pServer, CClassInfo & ClassInfo);
	BOOL    IsValidClass(LPCTSTR pClassName);
};


/////////////////////////////////////////////////////////////////////////////
// CDhcpModifyClass dialog

class CDhcpModifyClass : public CBaseDialog
{
// Construction
public:
	CDhcpModifyClass(CClassInfoArray * pClassArray, LPCTSTR pszServer, BOOL bCreate, DWORD dwType, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDhcpModifyClass)
	enum { IDD = IDD_CLASSID_NEW };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    CWndHexEdit	m_hexData;       //  Hex Data

    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CDhcpModifyClass::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDhcpModifyClass)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDhcpModifyClass)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeValuename();
	afx_msg void OnChangeValuecomment();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    afx_msg void OnChangeValueData();

    void    SetDirty(BOOL bDirty) { m_bDirty = bDirty; }

public:
    EDITVALUEPARAM      m_EditValueParam;

protected:
    HEXEDITDATA *       m_pHexEditData;
    CString             m_strName;
    CString             m_strComment;
    BYTE                m_buffer[MAXDATA_LENGTH];
    
    DWORD               m_dwType;

    CClassInfoArray *   m_pClassInfoArray;
    CString             m_strServer;

    BOOL                m_bDirty;
    BOOL                m_bCreate;   // are we creating or modifing a class
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLASSMOD_H__3995264F_96A1_11D1_93E0_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\croot.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	croot.h
		DHCP root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the servers in this snapin).
		
    FILE HISTORY:
        
*/

#ifndef _CROOT_H
#define _CROOT_H

#ifndef _DHCPHAND_H
#include "dhcphand.h"
#endif

#define COMPUTERNAME_LEN_MAX			255

/*---------------------------------------------------------------------------
	Class:	CDhcpRootHandler
 ---------------------------------------------------------------------------*/
class CDhcpRootHandler : public CDhcpHandler
{
// Interface
public:
	CDhcpRootHandler(ITFSComponentData *pCompData);

	// Node handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString();

	// base handler functionality we override
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

    // Result handler functionality
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_OnGetResultViewType();

public:
	// helper routines
	void	CreateLocalDhcpServer();
	HRESULT AddServer(LPCWSTR pServerIp, LPCTSTR pServerName, BOOL bNewServer, DWORD dwServerOptions = 0x00000000, DWORD dwRefreshInterval = 0xffffffff, BOOL bExtension = FALSE);
	HRESULT GetGroupName(CString * pstrGroupName);
	HRESULT SetGroupName(LPCTSTR pszGroupName);

	BOOL    IsServerInList(ITFSNode * pRootNode, DHCP_IP_ADDRESS dhcpIpAddressNew, CString & strName);
	DWORD   LoadOldServerList(ITFSNode * pRootNode);
    HRESULT AddServerSortedIp(ITFSNode * pNewNode, BOOL bNewServer);
    HRESULT AddServerSortedName(ITFSNode * pNewNode, BOOL bNewServer);

public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

// Implementation
private:
	// Command handlers
	HRESULT OnCreateNewServer(ITFSNode * pNode);
	HRESULT OnBrowseServers(ITFSNode * pNode);
	HRESULT OnImportOldList(ITFSNode * pNode);
    BOOL    OldServerListExists();
    // helpers
    HRESULT CheckMachine(ITFSNode * pRootNode, LPDATAOBJECT pDataObject);
	HRESULT RemoveOldEntries(ITFSNode * pRootNode, DHCP_IP_ADDRESS dhcpAddress);

    void    UpdateResultMessage(ITFSNode * pNode);

private:
    BOOL        m_bMachineAdded;
    BOOL        m_fViewMessage;
};

#endif _CROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\croot.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	croot.cpp
		DHCP root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the servers in this snapin).
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "croot.h"
#include "server.h"
#include "tregkey.h"
#include "service.h"
#include "servbrow.h"  // CAuthServerList
#include "ncglobal.h"  // network console global defines

#include "addserv.h"   // add server dialog
#include <clusapi.h>
#include "cluster.h"   // cluster routines

unsigned int g_cfMachineName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");

#define ROOT_MESSAGE_MAX_STRING  6

typedef enum _ROOT_MESSAGES
{
    ROOT_MESSAGE_NO_SERVERS,
    ROOT_MESSAGE_MAX
};

UINT g_uRootMessages[ROOT_MESSAGE_MAX][ROOT_MESSAGE_MAX_STRING] =
{
    {IDS_ROOT_MESSAGE_TITLE, Icon_Information, IDS_ROOT_MESSAGE_BODY1, IDS_ROOT_MESSAGE_BODY2, IDS_ROOT_MESSAGE_BODY3, 0},
};



/*---------------------------------------------------------------------------
	CDhcpRootHandler::CDhcpRootHandler
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpRootHandler::CDhcpRootHandler(ITFSComponentData *pCompData) 
    : CDhcpHandler(pCompData)
{
    m_bMachineAdded = FALSE;
    m_fViewMessage = TRUE;
}

/*!--------------------------------------------------------------------------
	CDhcpRootHandler::InitializeNode
		Initializes node specific data
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString strTemp;
	strTemp.LoadString(IDS_ROOT_NODENAME);

	SetDisplayName(strTemp);

	// Make the node immediately visible
	//pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_COOKIE, 0);
	pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_APPLICATION);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_APPLICATION);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_ROOT);

	SetColumnStringIDs(&aColumns[DHCPSNAP_ROOT][0]);
	SetColumnWidths(&aColumnWidths[DHCPSNAP_ROOT][0]);

    return hrOK;
}

/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CDhcpRootHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpRootHandler::GetString
(
	ITFSNode *	pNode, 
	int			nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();
	else
		return NULL;
}

HRESULT
CDhcpRootHandler::SetGroupName(LPCTSTR pszGroupName)
{
	CString strSnapinBaseName, strGroupName, szBuf;
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		strSnapinBaseName.LoadString(IDS_ROOT_NODENAME);
	}
	
    strGroupName = pszGroupName;
    if (strGroupName.IsEmpty())
        szBuf = strSnapinBaseName;
    else
	    szBuf.Format(_T("%s [%s]"), strSnapinBaseName, strGroupName);
	
	SetDisplayName(szBuf);

	return hrOK;
}

HRESULT
CDhcpRootHandler::GetGroupName(CString * pstrGroupName)	
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	CString strSnapinBaseName, strDisplayName;
	strSnapinBaseName.LoadString(IDS_ROOT_NODENAME);

	int nBaseLength = strSnapinBaseName.GetLength() + 1; // For the space
	strDisplayName = GetDisplayName();

	if (strDisplayName.GetLength() == nBaseLength)
		pstrGroupName->Empty();
	else
		*pstrGroupName = strDisplayName.Right(strDisplayName.GetLength() - nBaseLength);

	return hrOK;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::OnExpand
		Handles enumeration of a scope item
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::OnExpand
(
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg, 
	LPARAM			param
)
{
	HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    hr = CDhcpHandler::OnExpand(pNode, pDataObject, dwType, arg, param);

    if (dwType & TFS_COMPDATA_EXTENSION)
    {
        // we are extending somebody.  Get the computer name and check that machine
        hr = CheckMachine(pNode, pDataObject);
    }
    else
    {
		int nVisible, nTotal;
		HRESULT hr = pNode->GetChildCount(&nVisible, &nTotal);

        // only possibly add the local machine if the list is currently empty
        if (nTotal == 0)
        {
            // check to see if we need to add the local machine to the list
            hr = CheckMachine(pNode, NULL);
        }
    }

	return hr;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::OnAddMenuItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::OnAddMenuItems
(
	ITFSNode *				pNode,
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	LPDATAOBJECT			lpDataObject, 
	DATA_OBJECT_TYPES		type, 
	DWORD					dwType,
	long *					pInsertionAllowed
)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	CString strMenuItem;

	if (type == CCT_SCOPE)
	{
		// these menu items go in the new menu, 
		// only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
		    strMenuItem.LoadString(IDS_ADD_SERVER);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_ADD_SERVER,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     0 );
		    ASSERT( SUCCEEDED(hr) );

		    strMenuItem.LoadString(IDS_BROWSE_SERVERS);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_BROWSE_SERVERS,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     0 );
		    ASSERT( SUCCEEDED(hr) );

            if (OldServerListExists())
            {
                // these menu items go in the new menu, 
		        // only visible from scope pane
		        strMenuItem.LoadString(IDS_IMPORT_OLD_LIST);
		        hr = LoadAndAddMenuItem( pContextMenuCallback, 
								         strMenuItem, 
								         IDS_IMPORT_OLD_LIST,
								         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								         0 );
		        ASSERT( SUCCEEDED(hr) );
            }
        }
    }

	return hr; 
}

/*!--------------------------------------------------------------------------
	CDhcpRootHandler::AddMenuItems
		Over-ride this to add our view menu item
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	CString strMenuItem;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        strMenuItem.LoadString(IDS_MESSAGE_VIEW);
		hr = LoadAndAddMenuItem( pContextMenuCallback, 
								 strMenuItem, 
								 IDS_MESSAGE_VIEW,
								 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
                                 (m_fViewMessage) ? MF_CHECKED : 0 );
    }

    return hr;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::OnCommand
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::OnCommand
(
	ITFSNode *			pNode, 
	long				nCommandId, 
	DATA_OBJECT_TYPES	type, 
	LPDATAOBJECT		pDataObject, 
	DWORD				dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

	switch (nCommandId)
	{
		case IDS_ADD_SERVER:
			hr = OnCreateNewServer(pNode);
			break;

		case IDS_BROWSE_SERVERS:
			hr = OnBrowseServers(pNode);
			break;

		case IDS_IMPORT_OLD_LIST:
			hr = OnImportOldList(pNode);
			break;

        default:
            break;
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpRootHandler::Command
		Handles commands for the current view
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;
    SPITFSNode spNode;

	switch (nCommandID)
	{
        case MMCC_STANDARD_VIEW_SELECT:
            break;

        case IDS_MESSAGE_VIEW:
            m_fViewMessage = !m_fViewMessage;
            m_spNodeMgr->GetRootNode(&spNode);
            UpdateResultMessage(spNode);
            break;

        // this may have come from the scope pane handler, so pass it up
        default:
            hr = HandleScopeCommand(cookie, nCommandID, pDataObject);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpRootHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = hrFalse;
	}
	else
	{
		// we have property pages in the normal case
		hr = hrFalse;
	}
	return hr;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::CreatePropertyPages
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT	hr = hrOK;
	HPROPSHEETPAGE hPage;

	Assert(pNode->GetData(TFS_DATA_COOKIE) == 0);
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		//
		// We are loading this snapin for the first time, put up a property
		// page to allow them to name this thing.
		// 
	}
	else
	{
		//
		// Object gets deleted when the page is destroyed
		//
	}

	return hr;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::OnPropertyChange
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::OnPropertyChange
(	
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataobject, 
	DWORD			dwType, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return hrOK;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::OnGetResultViewType
		Return the result view that this node is going to support
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    return CDhcpHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions);
}

/*!--------------------------------------------------------------------------
	CDhcpRootHandler::OnResultSelect
		For nodes with task pads, we override the select message to set 
        the selected node.  Nodes with taskpads do not get the MMCN_SHOW
        message which is where we normall set the selected node
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpRootHandler::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT hr = hrOK;
    SPITFSNode spRootNode;

    CORg(CDhcpHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

    CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    UpdateResultMessage(spRootNode);

Error:
    return hr;
}

void CDhcpRootHandler::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = ROOT_MESSAGE_NO_SERVERS;   // default
    int nVisible, nTotal;
    int i;
    CString strTitle, strBody, strTemp;

    if (!m_fViewMessage)
    {
        ClearMessage(pNode);
    }
    else
    {
        CORg(pNode->GetChildCount(&nVisible, &nTotal));

        if (nTotal > 0)
		{
			ClearMessage(pNode);
		}
		else
		{
            nMessage = ROOT_MESSAGE_NO_SERVERS;

			// now build the text strings
			// first entry is the title
			strTitle.LoadString(g_uRootMessages[nMessage][0]);

			// second entry is the icon
			// third ... n entries are the body strings

			for (i = 2; g_uRootMessages[nMessage][i] != 0; i++)
			{
				strTemp.LoadString(g_uRootMessages[nMessage][i]);
				strBody += strTemp;
			}

			ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uRootMessages[nMessage][1]);
		}
    }

Error:
    return;
}

/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	CDhcpRootHandler::OnCreateNewServer
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::OnCreateNewServer
(
	ITFSNode *	pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
    HRESULT hr = hrOK;

    CAddServer dlgAddServer;
    BOOL       fServerAdded = FALSE;

    dlgAddServer.SetServerList(&g_AuthServerList);
    if (dlgAddServer.DoModal() == IDOK)
    {
        if (IsServerInList(pNode, ::UtilCvtWstrToIpAddr(dlgAddServer.m_strIp), dlgAddServer.m_strName))
        {
            DhcpMessageBox(IDS_ERR_HOST_ALREADY_CONNECTED);
        }
        else
        {
            AddServer(dlgAddServer.m_strIp,
                      dlgAddServer.m_strName,
                      TRUE);
            fServerAdded = TRUE;
        }
    }

    if (fServerAdded)
        UpdateResultMessage(pNode);

    return hr;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::OnBrowseServers
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::OnBrowseServers
(
	ITFSNode *	pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
    HRESULT         hr = hrOK;
    CServerBrowse   dlgBrowse;
    BOOL            fServerAdded = FALSE;

    BEGIN_WAIT_CURSOR;
    
    if (!g_AuthServerList.IsInitialized())
    {
        hr = g_AuthServerList.Init();
        hr = g_AuthServerList.EnumServers();
    }

    dlgBrowse.SetServerList(&g_AuthServerList);
    
    END_WAIT_CURSOR;

    if (dlgBrowse.DoModal() == IDOK)
    {
        for (int i = 0; i < dlgBrowse.m_astrName.GetSize(); i++)
        {
            if (IsServerInList(pNode, ::UtilCvtWstrToIpAddr(dlgBrowse.m_astrIp[i]), dlgBrowse.m_astrName[i]))
            {
                DhcpMessageBox(IDS_ERR_HOST_ALREADY_CONNECTED);
            }
            else
            {
                AddServer(dlgBrowse.m_astrIp[i], 
                          dlgBrowse.m_astrName[i],
                          TRUE);
                fServerAdded = TRUE;
            }
        }
    }

    if (fServerAdded)
        UpdateResultMessage(pNode);

    return hr;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::OnImportOldList
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::OnImportOldList
(
	ITFSNode *	pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	DWORD err = LoadOldServerList(pNode);
	if (err)
		::DhcpMessageBox(err);

	return err;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::CreateLocalDhcpServer
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpRootHandler::CreateLocalDhcpServer()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	CString strName;

	// Create the local machine 
	//
	strName.LoadString (IDS_LOOPBACK_IP_ADDR);
	AddServer(strName, NULL, TRUE);
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::AddServer
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::AddServer
(
	LPCWSTR			 pServerIp,
    LPCTSTR          pServerName,
	BOOL			 bNewServer,
    DWORD            dwServerOptions,
    DWORD			 dwRefreshInterval,
    BOOL             bExtension
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = hrOK;
	CDhcpServer *		pDhcpServer = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode, spRootNode;

	// Create a handler for the node
	try
	{
		pDhcpServer = new CDhcpServer(m_spTFSCompData, pServerIp);
        pDhcpServer->SetName(pServerName);
		
		// Do this so that it will get released correctly
		spHandler = pDhcpServer;
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}
	CORg( hr );
	
	//
	// Create the server container information
	// 
	CreateContainerTFSNode(&spNode,
						   &GUID_DhcpServerNodeType,
						   pDhcpServer,
						   pDhcpServer,
						   m_spNodeMgr);

	// Tell the handler to initialize any specific data
	pDhcpServer->InitializeNode((ITFSNode *) spNode);
    
    // tell the server to set the name differently in the extension case
    if (dwServerOptions & SERVER_OPTION_EXTENSION)
    {
        m_bMachineAdded = TRUE;
        pDhcpServer->SetExtensionName();
    }

    // Mask out the auto refresh option because we set it next
    pDhcpServer->SetServerOptions(dwServerOptions & ~SERVER_OPTION_AUTO_REFRESH);

    // if we got a valid refresh interval, then set it.
	if (dwRefreshInterval != 0xffffffff)
		pDhcpServer->SetAutoRefresh(spNode, dwServerOptions & SERVER_OPTION_AUTO_REFRESH, dwRefreshInterval);

    AddServerSortedName(spNode, bNewServer);

	if (bNewServer)
    {
        // need to get our node descriptor
	    CORg(m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
	return hr;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::IsServerInList
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CDhcpRootHandler::IsServerInList
(
	ITFSNode *		pRootNode,
	DHCP_IP_ADDRESS	dhcpIpAddressNew,
	CString &		strName
)
{
	HRESULT				hr = hrOK;
	SPITFSNodeEnum		spNodeEnum;
	SPITFSNode			spCurrentNode;
	ULONG				nNumReturned = 0;
	DHCP_IP_ADDRESS		dhcpIpAddressCurrent;
	BOOL				bFound = FALSE;
	CString				strCurrentName;

	// get the enumerator for this node
	pRootNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	while (nNumReturned)
	{
		// walk the list of servers and see if it already exists
		CDhcpServer * pServer = GETHANDLER(CDhcpServer, spCurrentNode);
		pServer->GetIpAddress(&dhcpIpAddressCurrent);

		//if (dhcpIpAddressCurrent == dhcpIpAddressNew)
		strCurrentName = pServer->GetName();
		if (!strCurrentName.IsEmpty() && 
			strName.CompareNoCase(strCurrentName) == 0)
		{
			bFound = TRUE;
			break;
		}

		// get the next Server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	return bFound;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::OldServerListExists
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CDhcpRootHandler::OldServerListExists()
{
    RegKey      rk;
    LONG        err;
    BOOL        bExists = TRUE;
    CStringList strList;

    err = rk.Open(HKEY_CURRENT_USER, DHCP_REG_USER_KEY_NAME);
	if (err != ERROR_SUCCESS)
	{
		// the key doesn't exist, so there's nothing to import...
		// just return ok
		bExists = FALSE;
	}

    err = rk.QueryValue(DHCP_REG_VALUE_HOSTS, strList);
    if (err != ERROR_SUCCESS)
        bExists = FALSE;

    return bExists;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::LoadOldServerList
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpRootHandler::LoadOldServerList
(
	ITFSNode * pNode
)
{
    RegKey		rk;
    CStringList strList ;
    CString *	pstr ;
    POSITION	pos ;
    LONG		err;
	BOOL		bServerAdded = FALSE;
	CString		strName;
    DHC_HOST_INFO_STRUCT hostInfo;
	
	err = rk.Open(HKEY_CURRENT_USER, DHCP_REG_USER_KEY_NAME);
	if (err == ERROR_FILE_NOT_FOUND)
	{
		// the key doesn't exist, so there's nothing to import...
		// just return ok
		return ERROR_SUCCESS;
	}
	else 
	if (err)
		return err;

	do
    {
        if ( err = rk.QueryValue( DHCP_REG_VALUE_HOSTS, strList ) )
        {
            break ;
        }

        pos = strList.GetHeadPosition();

        if (pos == NULL)
            break;

        for ( ; pos && (pstr = & strList.GetNext(pos)); /**/ )
        {
			DHCP_IP_ADDRESS dhcpIpAddress = UtilCvtWstrToIpAddr(*pstr);

            err = ::UtilGetHostInfo(dhcpIpAddress, &hostInfo);
            if (err == ERROR_SUCCESS)
            {
                strName = hostInfo._chHostName;
            }

			// check to see if the server already is in the list
			// if not then add
			if (!IsServerInList(pNode, dhcpIpAddress, strName))
			{
                // is this a local machine addr?  Convert to real IP
                if ((dhcpIpAddress & 0xFF000000) == 127)
                {
                    UtilGetLocalHostAddress(&dhcpIpAddress);
                    UtilCvtIpAddrToWstr(dhcpIpAddress, pstr);
                }   

                AddServer(*pstr, strName, TRUE, 0, DHCPSNAP_REFRESH_INTERVAL_DEFAULT);
				bServerAdded = TRUE;
			}
        }
    }
    while ( FALSE ) ;

    //
    //  Set the dirty flag if we added anything to the list
    //
    if (bServerAdded)
		pNode->SetData(TFS_DATA_DIRTY, TRUE);

    //
    // This isn't really an error -- it just means that we didn't
    // find the key name in the list
    //
    if (err == ERROR_FILE_NOT_FOUND)
    {
        Trace0("Didn't find old addresses registry key -- starting from scratch");
        err = ERROR_SUCCESS;
    }

    return err ;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::AddServerSortedIp
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::AddServerSortedIp
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
	HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
	SPITFSNode      spCurrentNode;
	SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
	ULONG           nNumReturned = 0;
	DHCP_IP_ADDRESS dhcpIpAddressCurrent = 0;
	DHCP_IP_ADDRESS dhcpIpAddressTarget;

    CDhcpServer *   pServer;

    // get our target address
	pServer = GETHANDLER(CDhcpServer, pNewNode);
	pServer->GetIpAddress(&dhcpIpAddressTarget);

    // need to get our node descriptor
	CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
	CORg(spRootNode->GetEnum(&spNodeEnum));

	CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
	while (nNumReturned)
	{
		// walk the list of servers and see if it already exists
		pServer = GETHANDLER(CDhcpServer, spCurrentNode);
		pServer->GetIpAddress(&dhcpIpAddressCurrent);

		if (dhcpIpAddressCurrent > dhcpIpAddressTarget)
		{
            // Found where we need to put it, break out
            break;
		}

		// get the next Server in the list
		spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::AddServerSortedName
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::AddServerSortedName
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
	HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
	SPITFSNode      spCurrentNode;
	SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
	ULONG           nNumReturned = 0;
    CString         strTarget, strCurrent;

    CDhcpServer *   pServer;

    // get our target address
	pServer = GETHANDLER(CDhcpServer, pNewNode);
	strTarget = pServer->GetName();

    // need to get our node descriptor
	CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
	CORg(spRootNode->GetEnum(&spNodeEnum));

	CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
	while (nNumReturned)
	{
		// walk the list of servers and see if it already exists
		pServer = GETHANDLER(CDhcpServer, spCurrentNode);
		strCurrent = pServer->GetName();

		if (strTarget.CompareNoCase(strCurrent) < 0)
		{
            // Found where we need to put it, break out
            break;
		}

		// get the next Server in the list
		spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
	CDhcpRootHandler::CheckMachine
		Checks to see if the DHCP server service is running on the local
        machine.  If it is, it adds it to the list of servers.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::CheckMachine
(
    ITFSNode *      pRootNode,
    LPDATAOBJECT    pDataObject
)
{
    HRESULT hr = hrOK;

    // Get the local machine name and check to see if the service
    // is installed.
    CString strMachineName;
    LPTSTR  pBuf;
    DWORD   dwLength = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    bExtension = (pDataObject != NULL);
	BOOL	fInCluster = FALSE;
    CString strLocalIp, strLocalName, strIp;
    DHC_HOST_INFO_STRUCT hostInfo;
    DHCP_IP_ADDRESS dhcpAddress;

    if (!bExtension)
    {
        // just check the local machine
        pBuf = strMachineName.GetBuffer(dwLength);
        GetComputerName(pBuf, &dwLength);
        strMachineName.ReleaseBuffer();

        UtilGetLocalHostAddress(&dhcpAddress);
    }
    else
    {
        // get the machine name from the data object
        strMachineName = Extract<TCHAR>(pDataObject, (CLIPFORMAT) g_cfMachineName, COMPUTERNAME_LEN_MAX);

        UtilGetHostAddress(strMachineName, &dhcpAddress);
		RemoveOldEntries(pRootNode, dhcpAddress);
    }

	fInCluster = ::FIsComputerInRunningCluster(strMachineName);
    if (fInCluster)
    {
        if (GetClusterResourceIp(strMachineName, _T("DHCP Service"), strIp) == ERROR_SUCCESS)
        {
            dhcpAddress = ::UtilCvtWstrToIpAddr(strIp);
        }
    }

	if (fInCluster)
	{
		// get the resource name for the IP address we just got
		UtilGetHostInfo(dhcpAddress, &hostInfo);
		strMachineName = hostInfo._chHostName;
	}

    // check to see if the service is running
	BOOL bServiceRunning;
	DWORD dwError = ::TFSIsServiceRunning(strMachineName, _T("DHCPServer"), &bServiceRunning);
	if (dwError != ERROR_SUCCESS ||
        !bServiceRunning)
	{
		// The following condition could happen to get here:
        //  o The service is not installed.
        //  o Couldn't access for some reason.
        //  o The service isn't running.
		
        // Don't add to the list.
		
        return hrOK;
	}

    if (!fInCluster)
	{
		UtilGetHostInfo(dhcpAddress, &hostInfo);
		strMachineName = hostInfo._chHostName;
	}

    // OK.  The service is installed, so lets and add it to the list.
    if (IsServerInList(pRootNode, dhcpAddress, strMachineName))
        return hr;

    // looks good, add to list
    UtilCvtIpAddrToWstr(dhcpAddress, &strLocalIp);

    DWORD dwFlags = SERVER_OPTION_SHOW_ROGUE;

    if (bExtension)
        dwFlags |= SERVER_OPTION_EXTENSION;

    AddServer(strLocalIp, strMachineName, TRUE, dwFlags, DHCPSNAP_REFRESH_INTERVAL_DEFAULT, bExtension);

    m_bMachineAdded = TRUE;

    return hr;
}

// when running as an extension, it is possible that we were saved as "local machine"
// which means that if the saved console file was moved to another machine we need to remove 
// the old entry that was saved
HRESULT 
CDhcpRootHandler::RemoveOldEntries(ITFSNode * pNode, DHCP_IP_ADDRESS dhcpAddress)
{
	HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
	SPITFSNode      spCurrentNode;
	ULONG           nNumReturned = 0;
	CDhcpServer *	pServer;

    // get the enumerator for this node
	CORg(pNode->GetEnum(&spNodeEnum));

	CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
	while (nNumReturned)
	{
		// walk the list of servers and see if it already exists
		pServer = GETHANDLER(CDhcpServer, spCurrentNode);

		DHCP_IP_ADDRESS ipaddrCurrent;

		pServer->GetIpAddress(&ipaddrCurrent);

		//if (ipaddrCurrent != dhcpAddress)
		{
			CORg (pNode->RemoveChild(spCurrentNode));
		}

        spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\classmod.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ClassMod.cpp
		This file contains all of the prototypes for the 
		option class modification dialog.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ClassMod.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*---------------------------------------------------------------------------
	Class CWndHexEdit implementation
 ---------------------------------------------------------------------------*/
//  Static class-level data

//  Super window proc address
WNDPROC CWndHexEdit::m_wproc_super = NULL;

//  Window class initialization flag                  
BOOL CWndHexEdit::m_b_inited = FALSE;

WNDPROC * 
CWndHexEdit::GetSuperWndProcAddr()
{
    return &m_wproc_super;
}


BOOL 
CWndHexEdit::CreateWindowClass ( HINSTANCE hInstance )
{
    Trace0("CWndHexEdit::CreateWindowClass\n");
    if ( ! m_b_inited ) 
    {
        m_b_inited = ::RegisterHexEditClass( hInstance )  ;
    }
    return m_b_inited ;
}

IMPLEMENT_DYNAMIC(CWndHexEdit, CWnd)

CWndHexEdit::CWndHexEdit()
{
}

CWndHexEdit::~CWndHexEdit()
{
    DestroyWindow();
}

BOOL 
CWndHexEdit::Create 
( 
    LPCTSTR			lpszText, 
    DWORD			dwStyle,
    const RECT &	rect, 
    CWnd *			pParentWnd, 
    UINT			nID 
)
{
    return CWnd::Create( TEXT("HEX"), lpszText, dwStyle, rect, pParentWnd, nID);
}

/*---------------------------------------------------------------------------
	Class CClassInfoArray implementation
 ---------------------------------------------------------------------------*/
CClassInfoArray::CClassInfoArray()
{

}

CClassInfoArray::~CClassInfoArray()
{

}

DWORD
CClassInfoArray::RefreshData(LPCTSTR pServer)
{
    DWORD                   dwErr;
    HRESULT                 hr = hrOK;
    DHCP_RESUME_HANDLE      dhcpResumeHandle = NULL;
    LPDHCP_CLASS_INFO_ARRAY pClassInfoArray = NULL;
    DWORD                   dwRead = 0, dwTotal = 0;
    CClassInfo              ClassInfo;
    UINT                    i, j;

    Assert(pServer != NULL);
    if (pServer == NULL)
        return ERROR_INVALID_PARAMETER;

    // clear all of the old entries
    RemoveAll();

    dwErr = ::DhcpEnumClasses((LPTSTR) pServer,
                              0,
                              &dhcpResumeHandle,
                              0xFFFFFFFF,
                              &pClassInfoArray,
                              &dwRead,
                              &dwTotal);
    
	Trace3("CClassInfoArray::RefreshData - DhcpEnumClasses returned %d, dwRead %d, dwTotal %d.\n", dwErr, dwRead, dwTotal);

    if (dwErr == ERROR_NO_MORE_ITEMS)
        return ERROR_SUCCESS;

    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    Assert(pClassInfoArray);

    for (i = 0; i < pClassInfoArray->NumElements; i++)
    {
        COM_PROTECT_TRY
        {
            // fill in our internal class info structure
            ClassInfo.strName = pClassInfoArray->Classes[i].ClassName;
            ClassInfo.strComment = pClassInfoArray->Classes[i].ClassComment;
            ClassInfo.bIsVendor = pClassInfoArray->Classes[i].IsVendor;
            
            ClassInfo.baData.RemoveAll();

            // now copy out the data
            for (j = 0; j < pClassInfoArray->Classes[i].ClassDataLength; j++)
            {
                ClassInfo.baData.Add(pClassInfoArray->Classes[i].ClassData[j]);
            }

            Add(ClassInfo);
        }
        COM_PROTECT_CATCH
    }

    if (pClassInfoArray)
        ::DhcpRpcFreeMemory(pClassInfoArray);

    if (dwErr == ERROR_NO_MORE_ITEMS)
        dwErr = ERROR_SUCCESS;
    
    return dwErr;
}

BOOL
CClassInfoArray::RemoveClass(LPCTSTR pClassName)
{
    BOOL bRemoved = FALSE;
    for (int i = 0; i < GetSize(); i++)
    {
        if (GetAt(i).strName.CompareNoCase(pClassName) == 0)
        {
            RemoveAt(i);
            bRemoved = TRUE;
            break;
        }
    }

    return bRemoved;
}

DWORD
CClassInfoArray::ModifyClass(LPCTSTR pServer, CClassInfo & classInfo)
{
	DWORD dwError = 0;
    DHCP_CLASS_INFO     dhcpClassInfo;

    dhcpClassInfo.ClassName = (LPWSTR) ((LPCTSTR) classInfo.strName);
    dhcpClassInfo.ClassComment = (LPWSTR) ((LPCTSTR) classInfo.strComment);
    dhcpClassInfo.ClassDataLength = (DWORD) classInfo.baData.GetSize();
    dhcpClassInfo.ClassData = classInfo.baData.GetData();
    dhcpClassInfo.IsVendor = classInfo.bIsVendor;

    dwError = ::DhcpModifyClass((LPWSTR) ((LPCTSTR) pServer), 0, &dhcpClassInfo);
	if (dwError == ERROR_SUCCESS)
	{
		for (int i = 0; i < GetSize(); i++)
		{
			if (GetAt(i).strName.CompareNoCase(classInfo.strName) == 0)
			{
				m_pData[i].strComment = classInfo.strComment;
				m_pData[i].baData.RemoveAll();
				for (int j = 0; j < classInfo.baData.GetSize(); j++)
				{
					m_pData[i].baData.Add(classInfo.baData[j]);
				}

				break;
			}
		}
	}

    return dwError;
}

BOOL 
CClassInfoArray::IsValidClass(LPCTSTR pClassName)
{
    BOOL bExists = FALSE;
    if (pClassName == NULL)
        return TRUE;

    for (int i = 0; i < GetSize(); i++)
    {
        if (GetAt(i).strName.CompareNoCase(pClassName) == 0)
        {
            bExists = TRUE;
            break;
        }
    }

    return bExists;
}

DWORD
CClassInfoArray::AddClass(LPCTSTR pServer, CClassInfo & classInfo)
{
	DWORD dwError = 0;
    DHCP_CLASS_INFO     dhcpClassInfo;

    dhcpClassInfo.ClassName = (LPWSTR) ((LPCTSTR) classInfo.strName);
    dhcpClassInfo.ClassComment = (LPWSTR) ((LPCTSTR) classInfo.strComment);
    dhcpClassInfo.ClassDataLength = (DWORD) classInfo.baData.GetSize();
    dhcpClassInfo.ClassData = classInfo.baData.GetData();
    dhcpClassInfo.IsVendor = classInfo.bIsVendor;

    dwError = ::DhcpCreateClass((LPWSTR) ((LPCTSTR) pServer), 0, &dhcpClassInfo);
    if (dwError == ERROR_SUCCESS)
	{
		Add(classInfo);
	}

	return dwError;
}

/////////////////////////////////////////////////////////////////////////////
// CDhcpModifyClass dialog


CDhcpModifyClass::CDhcpModifyClass(CClassInfoArray * pClassArray, LPCTSTR pszServer, BOOL bCreate, DWORD dwType, CWnd* pParent /*=NULL*/)
	: CBaseDialog(CDhcpModifyClass::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDhcpModifyClass)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_strServer = pszServer;
    m_pClassInfoArray = pClassArray;

    m_pHexEditData = NULL;
    m_bDirty = FALSE;

    m_dwType = dwType;

    m_bCreate = bCreate;
}


void CDhcpModifyClass::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDhcpModifyClass)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_VALUEDATA, m_hexData);
}


BEGIN_MESSAGE_MAP(CDhcpModifyClass, CBaseDialog)
	//{{AFX_MSG_MAP(CDhcpModifyClass)
	ON_EN_CHANGE(IDC_VALUENAME, OnChangeValuename)
	ON_EN_CHANGE(IDC_VALUECOMMENT, OnChangeValuecomment)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_VALUEDATA, OnChangeValueData)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpModifyClass message handlers

BOOL CDhcpModifyClass::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();

    CString strTitle;

    // initialze the name and comment
    if (!m_bCreate)
    {
        SetDlgItemText(IDC_VALUENAME, m_EditValueParam.pValueName);
        SetDlgItemText(IDC_VALUECOMMENT, m_EditValueParam.pValueComment);

        ((CEdit *) GetDlgItem(IDC_VALUENAME))->SetReadOnly(TRUE);

        // initialize the hexedit data
        // since the data can grow, we need to supply a buffer big enough
        ZeroMemory(m_buffer, sizeof(m_buffer));

        memcpy(m_buffer, m_EditValueParam.pValueData, m_EditValueParam.cbValueData);

        strTitle.LoadString(IDS_EDIT_CLASS_TITLE);
    }
    else
    {
        // we're creating a new class. No data yet.
        m_EditValueParam.cbValueData = 0;
        memset(m_buffer, 0, sizeof(m_buffer));

        strTitle.LoadString(IDS_NEW_CLASS_TITLE);
    }

    this->SetWindowText(strTitle);

    SendDlgItemMessage(IDC_VALUEDATA, HEM_SETBUFFER, (WPARAM)
        m_EditValueParam.cbValueData, (LPARAM) m_buffer);

    SetDirty(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDhcpModifyClass::OnChangeValuename() 
{
    SetDirty(TRUE);
}

void CDhcpModifyClass::OnChangeValuecomment() 
{
    SetDirty(TRUE);
}

void CDhcpModifyClass::OnChangeValueData() 
{
    SetDirty(TRUE);
}

void CDhcpModifyClass::OnOK() 
{
	DWORD			    dwError = 0;	
    DHCP_CLASS_INFO     dhcpClassInfo;

    GetDlgItemText(IDC_VALUENAME, m_strName);
    GetDlgItemText(IDC_VALUECOMMENT, m_strComment);
	
    m_pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(GetDlgItem(IDC_VALUEDATA)->GetSafeHwnd(), GWLP_USERDATA);
    Assert(m_pHexEditData);

    if (m_strName.IsEmpty())
    {
        // user didn't enter any data to describe the class
        AfxMessageBox(IDS_CLASSID_NO_NAME);
    
        GetDlgItem(IDC_VALUENAME)->SetFocus();
        return;
    }

    if (m_pHexEditData->cbBuffer == 0)
    {
        // user didn't enter any data to describe the class
        AfxMessageBox(IDS_CLASSID_NO_DATA);
    
        GetDlgItem(IDC_VALUEDATA)->SetFocus();
        return;
    }

    CClassInfo ClassInfo;

    ClassInfo.strName = m_strName;
    ClassInfo.strComment = m_strComment;
    ClassInfo.bIsVendor = (m_dwType == CLASS_TYPE_VENDOR) ? TRUE : FALSE;

    // now the data
    for (int i = 0; i < m_pHexEditData->cbBuffer; i++)
    {
        ClassInfo.baData.Add(m_pHexEditData->pBuffer[i]);
    }

    if (m_bCreate)
    {
        // create the class now
		dwError = m_pClassInfoArray->AddClass(m_strServer, ClassInfo);
        if (dwError != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(dwError);
            return;
        }
    }
    else
    {
        if (m_bDirty)
        {
            // we are modifing a class and something has changed.  Update now.
            BEGIN_WAIT_CURSOR;

			dwError = m_pClassInfoArray->ModifyClass(m_strServer, ClassInfo);
            if (dwError != ERROR_SUCCESS)
            {
		        DhcpMessageBox(dwError);

                GetDlgItem(IDC_VALUENAME)->SetFocus();
                return;
            }

            END_WAIT_CURSOR;
        }
    }

	CBaseDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\cred.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2000   **/
/**********************************************************************/

/*
	cred.h
		This file contains all of the prototypes for the 
		credentials dialog used for DDNS.

    FILE HISTORY:
        
*/

#if !defined(AFX_CRED_H__BDDD51D7_F6E6_4D9F_BBC2_102F1712538F__INCLUDED_)
#define AFX_CRED_H__BDDD51D7_F6E6_4D9F_BBC2_102F1712538F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CCredentials dialog

class CCredentials : public CBaseDialog
{
// Construction
public:
	CCredentials(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCredentials)
	enum { IDD = IDD_CREDENTIALS };
	CButton	m_buttonOk;
	CEdit	m_editUsername;
	CEdit	m_editPassword2;
	CEdit	m_editPassword;
	CEdit	m_editDomain;
	//}}AFX_DATA

    void SetServerIp(LPCTSTR pszServerIp);

    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CCredentials::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCredentials)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL    m_fNewUsernameOrDomain;
    CString m_strServerIp;

	// Generated message map functions
	//{{AFX_MSG(CCredentials)
	afx_msg void OnChangeEditCredUsername();
	afx_msg void OnChangeEditCredDomain();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CRED_H__BDDD51D7_F6E6_4D9F_BBC2_102F1712538F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\dhcphand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	dhcphand.cpp
		DHCP specifc handler base classes

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dhcphand.h"
#include "snaputil.h"  // For CGUIDArray
#include "extract.h"   // For ExtractInternalFormat
#include "nodes.h"
#include "classmod.h"

//
// Called by the result handler when a command comes in that isn't handled 
// by the result handler.  If appropriate it passes it to the scope pane hander.
//
HRESULT
CMTDhcpHandler::HandleScopeCommand
(
	MMC_COOKIE  	cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the handler to take care of this
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnCommand(spNode, nCommandID, dwType, pDataObject, (ULONG) spNode->GetData(TFS_DATA_TYPE));
    }
        
Error:
    return hr;
}

//
// Called by the result handler to add the scope pane menu items to the menu
// where appropriate.  Puts scope pane menu items in when action menu is clicked
// and the message view has focus as well as when a right click happens in the white 
// space of the result pane.
//
HRESULT
CMTDhcpHandler::HandleScopeMenus
(
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the normal handler to put up the menu items
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnAddMenuItems(spNode, pContextMenuCallback, pDataObject, CCT_SCOPE, (ULONG) spNode->GetData(TFS_DATA_TYPE), pInsertionAllowed);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
	CMTDhcpHandler::Command
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

    // this may have come from the scope pane handler, so pass it up
    hr = HandleScopeCommand(cookie, nCommandID, pDataObject);

    return hr;
}


/*!--------------------------------------------------------------------------
	CMTDhcpHandler::AddMenuItems
		Over-ride this to add our view menu item
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);
    
    return hr;
}

/*---------------------------------------------------------------------------
	CMTDhcpHandler::OnChangeState
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void CMTDhcpHandler::OnChangeState
(
	ITFSNode * pNode
)
{
	// Increment the state to the next position
	switch (m_nState)
	{
		case notLoaded:
		case loaded:
		case unableToLoad:
			{
				m_nState = loading;
				m_dwErr = 0;
			}
			break;

		case loading:
			{
				m_nState = (m_dwErr != 0) ? unableToLoad : loaded;
                
                if (m_dwErr)
                {
                    CString strTitle, strBody;
                    IconIdentifier icon;

                    GetErrorMessages(strTitle, strBody, &icon);

                    if (!strBody.IsEmpty())
                        ShowMessage(pNode, strTitle, strBody, icon);
                    else
                        ClearMessage(pNode);
                }
                else
                {
                    ClearMessage(pNode);
                }

                m_fSilent = FALSE;
			}
			break;
	
		default:
			ASSERT(FALSE);
	}

    // check to make sure we are still the visible node in the UI
    if (m_bSelected)
    {
        UpdateStandardVerbs(pNode, pNode->GetData(TFS_DATA_TYPE));

        SendUpdateToolbar(pNode, m_bSelected);
    }

    // Now check and see if there is a new image for this state for this handler
	int nImage, nOpenImage;

	nImage = GetImageIndex(FALSE);
	nOpenImage = GetImageIndex(TRUE);

	if (nImage >= 0)
		pNode->SetData(TFS_DATA_IMAGEINDEX, nImage);

	if (nOpenImage >= 0)
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
	
	VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM)));
}

 /*!--------------------------------------------------------------------------
	CMTDhcpHandler::GetErrorMessages
		Default message view text for errors
	Author: EricDav
 ---------------------------------------------------------------------------*/
void CMTDhcpHandler::GetErrorMessages
(
    CString & strTitle, 
    CString & strBody, 
    IconIdentifier * icon
)
{
    TCHAR chMesg [4000] = {0};
    BOOL bOk ;

    UINT nIdPrompt = (UINT) m_dwErr;
    CString strTemp;

    strTitle.LoadString(IDS_SERVER_MESSAGE_CONNECT_FAILED_TITLE);

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(chMesg[0]));

    AfxFormatString1(strBody, IDS_SERVER_MESSAGE_CONNECT_FAILED_BODY, chMesg);

    strTemp.LoadString(IDS_SERVER_MESSAGE_CONNECT_FAILED_REFRESH);
    strBody += strTemp;

    if (icon)
        *icon = Icon_Error;
}


 /*!--------------------------------------------------------------------------
	CMTDhcpHandler::UpdateStandardVerbs
		Tells the IComponent to update the verbs for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::UpdateStandardVerbs
(
    ITFSNode * pNode,
    LONG_PTR   dwNodeType
)
{
    HRESULT				hr = hrOK;
    SPIComponentData	spCompData;
	SPIConsole			spConsole;
    IDataObject*		pDataObject;

    m_spNodeMgr->GetComponentData(&spCompData);

    CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );

    CORg ( spConsole->UpdateAllViews(pDataObject, 
                                     reinterpret_cast<LONG_PTR>(pNode), 
                                     RESULT_PANE_UPDATE_VERBS) ); 

    pDataObject->Release();
	
Error:
    return;
}

 /*!--------------------------------------------------------------------------
	CMTDhcpHandler::SendUpdateToolbar
		Tells the IComponent to update the verbs for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::SendUpdateToolbar
(
    ITFSNode * pNode,
    BOOL       fSelected
)
{
    HRESULT				hr = hrOK;
    SPIComponentData	spCompData;
	SPIConsole			spConsole;
    IDataObject*		pDataObject = NULL;
    CToolbarInfo *      pToolbarInfo = NULL;

    COM_PROTECT_TRY
    {
        m_spNodeMgr->GetComponentData(&spCompData);

        CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );

        pToolbarInfo = new CToolbarInfo;

        pToolbarInfo->spNode.Set(pNode);
        pToolbarInfo->fSelected = fSelected;
        
        CORg ( spConsole->UpdateAllViews(pDataObject, 
                                         reinterpret_cast<LONG_PTR>(pToolbarInfo), 
                                         DHCPSNAP_UPDATE_TOOLBAR) ); 

    }
    COM_PROTECT_CATCH

    COM_PROTECT_ERROR_LABEL; 

    if (pDataObject)
        pDataObject->Release();              

    if (pToolbarInfo)
        delete pToolbarInfo;

    return;
}


 /*!--------------------------------------------------------------------------
	CMTDhcpHandler::ExpandNode
		Expands/compresses this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::ExpandNode
(
    ITFSNode *  pNode,
    BOOL        fExpand
)
{
    SPIComponentData	spCompData;
    SPIDataObject       spDataObject;
    LPDATAOBJECT        pDataObject;
    SPIConsole          spConsole;
    HRESULT             hr = hrOK;

    // don't expand the node if we are handling the EXPAND_SYNC message,
    // this screws up the insertion of item, getting duplicates.
    if (!m_fExpandSync)
    {
        m_spNodeMgr->GetComponentData(&spCompData);

	    CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
	    CORg ( spConsole->UpdateAllViews(pDataObject, TRUE, RESULT_PANE_EXPAND) ); 
    }

Error:
    return;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnCreateDataObject
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE	    	cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	    pObject = NULL;
	SPIDataObject	    spDataObject;

    pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CMTDhcpHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
	    {
		    SPITFSNode   spCurNode;
            const GUID * pGuid1;

		    spCurNode = listSelectedNodes.RemoveHead();
            pGuid1 = spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pGuid1);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
        
        pGuid = new GUID[UINT(rgGuids.GetSize())];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::SaveColumns
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTDhcpHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    if (m_spTFSCompData->GetTaskpadState(GetTaskpadIndex()))
        return hr;

    if (IsMessageView())
        return hr;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        hr = spHeaderCtrl->GetColumnWidth(nCol, &nColWidth);
        if (SUCCEEDED(hr) && 
            (nColWidth != 0) &&
            aColumnWidths[dwNodeType][nCol] != nColWidth)
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnExpandSync
		Handles the MMCN_EXPANDSYNC notifcation 
        We need to do syncronous enumeration.  We'll fire off the background 
        thread like before, but we'll wait for it to exit before we return.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTDhcpHandler::OnExpandSync
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    HRESULT hr = hrOK;
    MSG msg;

    m_fExpandSync = TRUE;

    hr = OnExpand(pNode, pDataObject, CCT_SCOPE, arg, lParam);

    // wait for the background thread to exit
    WaitForSingleObject(m_hThread, INFINITE);
    
    // The background thread posts messages to a hidden window to 
    // pass data back to the main thread. The messages won't go through since we are
    // blocking the main thread.  The data goes on a queue in the query object
    // which the handler has a pointer to so we can just fake the notification.
    if (m_spQuery.p)
        OnNotifyHaveData((LPARAM) m_spQuery.p);

    // Tell MMC we handled this message
    MMC_EXPANDSYNC_STRUCT * pES = reinterpret_cast<MMC_EXPANDSYNC_STRUCT *>(lParam);
    if (pES)
        pES->bHandled = TRUE;

    m_fExpandSync = FALSE;

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTDhcpHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    SPINTERNAL		spInternal;
    BOOL            bMultiSelect = FALSE;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    
    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    }

    UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnRefresh
		Default implementation for the refresh functionality
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnRefresh
(
	ITFSNode *		pNode,
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg,
	LPARAM			param
)
{
	HRESULT hr = hrOK;

    if (m_bExpanded == FALSE)
    {
        // we cannot refresh/add items to a node that hasn't been expanded yet.
        return hr;
    }

    BOOL bLocked = IsLocked();
	if (bLocked)
    {
        // cannot do refresh on locked node, the UI should prevent this
		return hr; 
    }
	
    pNode->DeleteAllChildren(TRUE);

	int nVisible, nTotal;
	pNode->GetChildCount(&nVisible, &nTotal);
	Assert(nVisible == 0);
	Assert(nTotal == 0);

	m_bExpanded = FALSE;
	OnExpand(pNode, pDataObject, dwType, arg, param); // will spawn a thread to do enumeration

    if (m_spTFSCompData->GetTaskpadState(GetTaskpadIndex()) && m_bSelected)
    {
        // tell the taskpad to update
        SPIConsole  spConsole;

        m_spTFSCompData->GetConsole(&spConsole);
        spConsole->SelectScopeItem(m_spNode->GetData(TFS_DATA_SCOPEID));
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnResultUpdateView
		Implementation of ITFSResultHandler::OnResultUpdateView
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CMTDhcpHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LPARAM        hint
)
{
	HRESULT hr = hrOK;

    if (hint == RESULT_PANE_UPDATE_VERBS)
    {
	    SPIConsoleVerb  spConsoleVerb;
        SPITFSNode      spNode;

        CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

        spNode.Set(reinterpret_cast<ITFSNode *>(data));

        UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE));
    }
    else 
    if (hint == DHCPSNAP_UPDATE_TOOLBAR)
    {
        SPIToolbar spToolbar;
        CToolbarInfo * pToolbarInfo;

        CORg (pComponent->GetToolbar(&spToolbar));

        pToolbarInfo = reinterpret_cast<CToolbarInfo *>(data);

        if (pToolbarInfo && spToolbar)
        {
            UpdateToolbar(spToolbar, pToolbarInfo->spNode->GetData(TFS_DATA_TYPE), pToolbarInfo->fSelected);
        }
    }
    else
    {
        return CBaseResultHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTDhcpHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
        szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
	CMTDhcpHandler::UpdateStandardVerbs
		Updates the standard verbs depending upon the state of the node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];	
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::EnableVerbs
		Enables the toolbar buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CMTDhcpHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }

	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}


 /*!--------------------------------------------------------------------------
	CMTDhcpHandler::UpdateToolbar
		Updates the toolbar depending upon the state of the node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::UpdateToolbar
(
    IToolbar *  pToolbar,
    LONG_PTR    dwNodeType,
    BOOL        bSelect
)
{
    // Enable/disable toolbar buttons
    int i;
    BOOL aEnable[TOOLBAR_IDX_MAX];

    switch (m_nState)
    {
        case loaded:
            for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = TRUE);
            break;
        
        case notLoaded:
        case loading:
            for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = FALSE);
            break;

        case unableToLoad:
            for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = FALSE);
            aEnable[TOOLBAR_IDX_REFRESH] = TRUE;
            break;
    }

    // if we are deselecting, then disable all
    if (!bSelect)
        for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = FALSE);

    EnableToolbar(pToolbar,
                  g_SnapinButtons,
                  ARRAYLEN(g_SnapinButtons),
                  g_SnapinButtonStates[dwNodeType],
                  aEnable);
}

 /*!--------------------------------------------------------------------------
	CMTDhcpHandler::UserResultNotify
		We override this to handle toolbar notification
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::UserResultNotify
(
	ITFSNode *	pNode, 
	LPARAM		dwParam1, 
	LPARAM		dwParam2
)
{
    HRESULT hr = hrOK;

    switch (dwParam1)
    {
        case DHCP_MSG_CONTROLBAR_NOTIFY:
            hr = OnResultControlbarNotify(pNode, reinterpret_cast<LPDHCPTOOLBARNOTIFY>(dwParam2));
            break;

        default:
            // we don't handle this message.  Forward it down the line...
            hr = CHandler::UserResultNotify(pNode, dwParam1, dwParam2);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::UserNotify
		We override this to handle toolbar notification
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::UserNotify
(
	ITFSNode *	pNode, 
	LPARAM		dwParam1, 
	LPARAM		dwParam2
)
{
    HRESULT hr = hrOK;

    switch (dwParam1)
    {
        case DHCP_MSG_CONTROLBAR_NOTIFY:
            hr = OnControlbarNotify(pNode, reinterpret_cast<LPDHCPTOOLBARNOTIFY>(dwParam2));
            break;

        default:
            // we don't handle this message.  Forward it down the line...
            hr = CHandler::UserNotify(pNode, dwParam1, dwParam2);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnResultRefresh
		Call into the MTHandler to do a refresh
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	HRESULT     hr = hrOK;
    SPITFSNode  spNode;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    OnRefresh(spNode, pDataObject, 0, arg, lParam);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnResultControlbarNotify
		Our implementation of the toobar handlers
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnResultControlbarNotify
(
    ITFSNode *          pNode, 
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    // mark this node as selected
    m_bSelected = pToolbarNotify->bSelect;
    
    SPITFSNode          spParent;
    SPITFSNodeHandler   spNodeHandler;

    switch (pToolbarNotify->event)
    {
        case MMCN_BTN_CLICK:
            // forward the button click to the parent because our result pane
            // items don't have any functions for the toolbar
            // our result pane items only use the standard verbs
            CORg(pNode->GetParent(&spParent));
            CORg(spParent->GetHandler(&spNodeHandler));

            if (spNodeHandler)
			    CORg( spNodeHandler->UserNotify(spParent, 
                                                (LPARAM) DHCP_MSG_CONTROLBAR_NOTIFY, 
                                                (LPARAM) pToolbarNotify) );
            break;

        case MMCN_SELECT:
            if (pNode->IsContainer())
            {
                hr = OnUpdateToolbarButtons(pNode, 
                                            pToolbarNotify);
            }
            break;

        default:
            Assert(FALSE);
            break;
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnControlbarNotify
		Our implementation of the toobar handlers
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnControlbarNotify
(
    ITFSNode *          pNode, 
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;
    
    // mark this node as selected
    m_bSelected = pToolbarNotify->bSelect;
    
    switch (pToolbarNotify->event)
    {
        case MMCN_BTN_CLICK:
            hr = OnToolbarButtonClick(pNode, 
                                      pToolbarNotify);
            break;

        case MMCN_SELECT:
            hr = OnUpdateToolbarButtons(pNode, 
                                        pToolbarNotify);
            break;

        default:
            Assert(FALSE);
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnToolbarButtonClick
		Default implementation of OnToolbarButtonClick
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnToolbarButtonClick
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    // forward this command to the normal command handler
    return OnCommand(pNode, (long) pToolbarNotify->id, (DATA_OBJECT_TYPES) 0, NULL, 0);    
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnUpdateToolbarButtons
		Default implementation of OnUpdateToolbarButtons
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnUpdateToolbarButtons
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    HRESULT hr = hrOK;

    if (pToolbarNotify->bSelect)
    {
        BOOL    bAttach = FALSE;
    
        // check to see if we should attach this toolbar
        for (int i = 0; i < TOOLBAR_IDX_MAX; i++)
        {
            if (g_SnapinButtonStates[pNode->GetData(TFS_DATA_TYPE)][i] == ENABLED)
            {
                bAttach = TRUE; 
                break;
            }
        }

        // attach the toolbar and enable the appropriate buttons
        if (pToolbarNotify->pControlbar)
        {
            if (bAttach)
            {
                pToolbarNotify->pControlbar->Attach(TOOLBAR, pToolbarNotify->pToolbar);
                UpdateToolbar(pToolbarNotify->pToolbar, pNode->GetData(TFS_DATA_TYPE), pToolbarNotify->bSelect);
            }
            else
            {
                pToolbarNotify->pControlbar->Detach(pToolbarNotify->pToolbar);
            }
        }
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::EnableToolbar
		Enables the toolbar buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CMTDhcpHandler::EnableToolbar
(
    LPTOOLBAR           pToolbar, 
    MMCBUTTON           rgSnapinButtons[], 
    int                 nRgSize,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pToolbar == NULL)
    {
        Assert(FALSE);
        return;
    }

#ifdef DBG
    CString strDbg;

    strDbg.Format(_T("CMTDhcpHandler::EnableToolbar - Calling on thread %lx\n"), GetCurrentThreadId());
    OutputDebugString(strDbg);
#endif

    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
        {
            if (ButtonState[i] == ENABLED)
            {
                // unhide this button before enabling
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         HIDDEN, 
                                         FALSE);
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         ButtonState[i], 
                                         bState[i]);
            }
            else
            {
                // hide this button
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         HIDDEN, 
                                         TRUE);
            }
        }
    }
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnRefreshStats
		Default implementation for the Stats refresh functionality
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnRefreshStats
(
	ITFSNode *		pNode,
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg,
	LPARAM			param
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
	SPITFSNodeHandler	spHandler;
	ITFSQueryObject *	pQuery = NULL;
	
//    if (m_bExpanded == FALSE)
//    {
        // we cannot get statistics if the node hasn't been expanded yet
//        return hr;
//    }

    // only do stats refresh if the server was loaded correctly.
    if (m_nState == unableToLoad)
        return hr;

    BOOL bLocked = IsLocked();
	if (bLocked)
    {
        // cannot refresh stats if this node is locked
		return hr; 
    }

    Lock();

	//OnChangeState(pNode);

	pQuery = OnCreateQuery(pNode);
	Assert(pQuery);

	// notify the UI to change icon, if needed
	//Verify(SUCCEEDED(pComponentData->ChangeNode(this, SCOPE_PANE_CHANGE_ITEM_ICON)));

	Verify(StartBackgroundThread(pNode, m_spTFSCompData->GetHiddenWnd(), pQuery));
	
	pQuery->Release();

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnResultUpdateOptions
		Updates the result pane of any of the option nodes
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnResultUpdateOptions
(
    ITFSComponent *     pComponent,
	ITFSNode *		    pNode,
    CClassInfoArray *   pClassInfoArray,
    COptionValueEnum *  aEnum[],
    int                 aImages[],
    int                 nCount
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    CDhcpOption *       pOption;

    //
    // Walk the list of children to see if there's anything
	// to put in the result pane
	//
    SPITFSNodeEnum  spNodeEnum;
    ITFSNode *      pCurrentNode;
    ULONG           nNumReturned = 0;
    SPIResultData   spResultData;
    int             i;

    if (IsMessageView())
        return hr;

    CORg ( pComponent->GetResultData(&spResultData) );
    spResultData->DeleteAllRsltItems();
    pNode->DeleteAllChildren(FALSE);

    for (i = 0; i < nCount; i++)
    {
        while (pOption = aEnum[i]->Next())
        {
            BOOL bValid = TRUE;
            BOOL bAdded = FALSE;

            pNode->GetEnum(&spNodeEnum);

	        spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
            while (nNumReturned)
	        {
                // so the node gets release correctly
                SPITFSNode spCurNode;
                spCurNode = pCurrentNode;

		        //
		        // All containers go into the scope pane and automatically get 
		        // put into the result pane for us by the MMC
		        //
	            CDhcpOptionItem * pCurOption = GETHANDLER(CDhcpOptionItem, pCurrentNode);
        
                if (!pCurrentNode->IsContainer())
		        {
                    if ( lstrlen(pCurOption->GetClassName()) > 0 && 
                         !pClassInfoArray->IsValidClass(pCurOption->GetClassName()) )
                    {
                        // user class is no longer valid
                        bValid = FALSE;
                        Trace2("CMTDhcpHandler::OnResultUpdateOptions - Filtering option %d, user class %s\n", pCurOption->GetOptionId(), pOption->GetClassName());
                        break;
                    }
                    else
                    if ( pOption->IsVendor() &&
                         !pClassInfoArray->IsValidClass(pOption->GetVendor()) )
                    {
                        // the vendor class for this option has gone away
                        bValid = FALSE;
                        Trace2("CMTDhcpHandler::OnResultUpdateOptions - Filtering option %d, vendor class %s\n", pCurOption->GetOptionId(), pOption->GetVendor());
                        break;
                    }
                    else
                    if ( pCurOption->GetOptionId() == pOption->QueryId() &&
                         (lstrcmp(pCurOption->GetVendor(), pOption->GetVendor()) == 0) &&
                         (lstrcmp(pCurOption->GetClassName(), pOption->GetClassName()) == 0) )
                    {
                        // option has already been created, just need to re-add to the result pane
                        // update the value in case it has changed
                        bAdded = TRUE;
                        break;
                    }
		        }

                spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
	        }

            if (!bAdded && bValid)
            {
                CDhcpOptionItem *   pOptionItem;
                SPITFSNode          spNode;

                if ( lstrlen(pOption->GetClassName()) > 0 && 
                     !pClassInfoArray->IsValidClass(pOption->GetClassName()) )
                {
                    // the user class for this option has gone away
                }
                else
                if ( pOption->IsVendor() &&
                     !pClassInfoArray->IsValidClass(pOption->GetVendor()) )
                {
                    // the vendor class for this option has gone away
                }
                else
                {
                    // option hasn't been added to the UI yet.  Make it so.
                    pOptionItem = new CDhcpOptionItem(m_spTFSCompData, pOption, aImages[i]);

                    CORg (CreateLeafTFSNode(&spNode,
      			  		                    &GUID_DhcpOptionNodeType,
					                        pOptionItem,
					                        pOptionItem,
					                        m_spNodeMgr));

	                // Tell the handler to initialize any specific data
	                pOptionItem->InitializeNode(spNode);
	                
                    // extra addref to keep the node alive while it is on the list
                    spNode->SetVisibilityState(TFS_VIS_HIDE);
                    pNode->AddChild(spNode);		                        
                    pOptionItem->Release();

                    AddResultPaneItem(pComponent, spNode);
                }
            }

            spNodeEnum.Set(NULL);
        }
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
	Class:	CDhcpHandler
 ---------------------------------------------------------------------------*/

//
// Called by the result handler when a command comes in that isn't handled 
// by the result handler.  If appropriate it passes it to the scope pane hander.
//
HRESULT
CDhcpHandler::HandleScopeCommand
(
	MMC_COOKIE  	cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the handler to take care of this
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnCommand(spNode, nCommandID, dwType, pDataObject, (ULONG) spNode->GetData(TFS_DATA_TYPE));
    }
        
Error:
    return hr;
}

//
// Called by the result handler to add the scope pane menu items to the menu
// where appropriate.  Puts scope pane menu items in when action menu is clicked
// and the message view has focus as well as when a right click happens in the white 
// space of the result pane.
//
HRESULT
CDhcpHandler::HandleScopeMenus
(
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the normal handler to put up the menu items
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnAddMenuItems(spNode, pContextMenuCallback, pDataObject, CCT_SCOPE, (ULONG) spNode->GetData(TFS_DATA_TYPE), pInsertionAllowed);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
	CDhcpHandler::Command
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

    // this may have come from the scope pane handler, so pass it up
    hr = HandleScopeCommand(cookie, nCommandID, pDataObject);

    return hr;
}


/*!--------------------------------------------------------------------------
	CDhcpHandler::AddMenuItems
		Over-ride this to add our view menu item
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);
    
    return hr;
}

 
 /*!--------------------------------------------------------------------------
	CDhcpHandler::SaveColumns
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    if (m_spTFSCompData->GetTaskpadState(GetTaskpadIndex()))
        return hr;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        hr = spHeaderCtrl->GetColumnWidth(nCol, &nColWidth);
        if (SUCCEEDED(hr) &&
            (nColWidth != 0) &&
            aColumnWidths[dwNodeType][nCol] != nColWidth)
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTDhcpHandler::OnCreateDataObject
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	
	pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CDhcpHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
	    {
		    SPITFSNode   spCurNode;
            const GUID * pGuid;

		    spCurNode = listSelectedNodes.RemoveHead();
            pGuid = spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pGuid);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT) (rgGuids.GetSize() * sizeof(GUID));
        
        pGuid = new GUID[(UINT)rgGuids.GetSize()];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

 /*---------------------------------------------------------------------------
	CDhcpHandler::OnResultDelete
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE		cookie, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	HRESULT hr = hrOK;

	Trace0("CDhcpHandler::OnResultDelete received\n");

	// translate this call to the parent and let it handle deletion 
	// of result pane items
	SPITFSNode spNode, spParent;
	SPITFSResultHandler spParentRH;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));
	CORg (spNode->GetParent(&spParent));

	if (spParent == NULL)
		return hr;

	CORg (spParent->GetResultHandler(&spParentRH));

	CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_DELETE, arg, lParam));

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

        szHelpFilePath.ReleaseBuffer();
	    szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
	CDhcpHandler::UserResultNotify
		We override this to handle toolbar notification
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::UserResultNotify
(
	ITFSNode *	pNode, 
	LPARAM		dwParam1, 
	LPARAM		dwParam2
)
{
    HRESULT hr = hrOK;

    switch (dwParam1)
    {
        case DHCP_MSG_CONTROLBAR_NOTIFY:
            hr = OnResultControlbarNotify(pNode, reinterpret_cast<LPDHCPTOOLBARNOTIFY>(dwParam2));
            break;

        default:
            // we don't handle this message.  Forward it down the line...
            hr = CHandler::UserResultNotify(pNode, dwParam1, dwParam2);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpHandler::UserNotify
		We override this to handle toolbar notification
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::UserNotify
(
	ITFSNode *	pNode, 
	LPARAM		dwParam1, 
	LPARAM		dwParam2
)
{
    HRESULT hr = hrOK;

    switch (dwParam1)
    {
        case DHCP_MSG_CONTROLBAR_NOTIFY:
            hr = OnControlbarNotify(pNode, reinterpret_cast<LPDHCPTOOLBARNOTIFY>(dwParam2));
            break;

        default:
            // we don't handle this message.  Forward it down the line...
            hr = CHandler::UserNotify(pNode, dwParam1, dwParam2);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpHandler::OnResultControlbarNotify
		On a result pane notification all we can do is enable/hide buttons.
        We cannot attach/detach toolbars.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpHandler::OnResultControlbarNotify
(
    ITFSNode *          pNode, 
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    SPITFSNode          spParent;
    SPITFSNodeHandler   spNodeHandler;

    switch (pToolbarNotify->event)
    {
        case MMCN_BTN_CLICK:
            // forward the button click to the parent because our result pane
            // items don't have any functions for the toolbar
            // our result pane items only use the standard verbs
            CORg(pNode->GetParent(&spParent));
            CORg(spParent->GetHandler(&spNodeHandler));

            if (spNodeHandler)
			    CORg( spNodeHandler->UserNotify(spParent, 
                                                DHCP_MSG_CONTROLBAR_NOTIFY, 
                                                (LPARAM) pToolbarNotify) );
            break;

        case MMCN_SELECT:
            if (!pNode->IsContainer())
            {
                // use the parent's toolbar info
                SPITFSNode spParentNode;
                pNode->GetParent(&spParentNode);
                
                hr = OnUpdateToolbarButtons(spParentNode, 
                                            pToolbarNotify);
            }
            else
            {
                hr = OnUpdateToolbarButtons(pNode, 
                                            pToolbarNotify);
            }

            break;

        default:
            Assert(FALSE);
            break;
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpHandler::OnControlbarNotify
		Our implementation of the toobar handlers
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpHandler::OnControlbarNotify
(
    ITFSNode *          pNode, 
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    switch (pToolbarNotify->event)
    {
        case MMCN_BTN_CLICK:
            hr = OnToolbarButtonClick(pNode, 
                                      pToolbarNotify);
            break;

        case MMCN_SELECT:
            hr = OnUpdateToolbarButtons(pNode, 
                                        pToolbarNotify);
            break;

        default:
            Assert(FALSE);
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpHandler::OnToolbarButtonClick
		Default implementation of OnToolbarButtonClick
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpHandler::OnToolbarButtonClick
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    // forward this command to the normal command handler
    return OnCommand(pNode, (long) pToolbarNotify->id, (DATA_OBJECT_TYPES) 0, NULL, 0);    
}

/*!--------------------------------------------------------------------------
	CDhcpHandler::OnUpdateToolbarButtons
		Default implementation of OnUpdateToolbarButtons
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpHandler::OnUpdateToolbarButtons
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    HRESULT hr = hrOK;

    LONG_PTR dwNodeType = pNode->GetData(TFS_DATA_TYPE);

    if (pToolbarNotify->bSelect)
    {
        BOOL bAttach = FALSE;

        // check to see if we should attach this toolbar
        for (int i = 0; i < TOOLBAR_IDX_MAX; i++)
        {
            if (g_SnapinButtonStates[pNode->GetData(TFS_DATA_TYPE)][i] == ENABLED)
            {
                bAttach = TRUE; 
                break;
            }
        }

        // attach the toolbar and enable the appropriate buttons
        if (pToolbarNotify->pControlbar)
        {
            if (bAttach)
            {
                // attach the toolbar and enable the appropriate buttons
                pToolbarNotify->pControlbar->Attach(TOOLBAR, pToolbarNotify->pToolbar);

                EnableToolbar(pToolbarNotify->pToolbar,
                              g_SnapinButtons,
                              ARRAYLEN(g_SnapinButtons),
                              g_SnapinButtonStates[dwNodeType]);
            }
            else
            {
                pToolbarNotify->pControlbar->Detach(pToolbarNotify->pToolbar);
            }
        }
    }
    else
    {
        // disable the buttons
        EnableToolbar(pToolbarNotify->pToolbar,
                      g_SnapinButtons,
                      ARRAYLEN(g_SnapinButtons),
                      g_SnapinButtonStates[dwNodeType],
                      FALSE);
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpHandler::EnableToolbar
		Enables the toolbar buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpHandler::EnableToolbar
(
    LPTOOLBAR           pToolbar, 
    MMCBUTTON           rgSnapinButtons[], 
    int                 nRgSize,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState
)
{
    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
        {
            if (ButtonState[i] == ENABLED)
            {
                // unhide this button before enabling
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         HIDDEN, 
                                         FALSE);
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         ButtonState[i], 
                                         bState);
            }
            else
            {
                // hide this button
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         HIDDEN, 
                                         TRUE);
            }

        }
    }
}


/*!--------------------------------------------------------------------------
	CDhcpHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[spNode->GetData(TFS_DATA_TYPE)], bStates);

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	CMTDhcpHandler::EnableVerbs
		Enables the toolbar buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }

	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\dhcpcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	dhcpcomp.cpp
		This file contains the derived implementations from CComponent
		and CComponentData for the DHCP admin snapin.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dhcpcomp.h"
#include "croot.h"
#include "server.h"
#include "servbrow.h"

#include <util.h>       // for InitWatermarkInfo

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DHCPSNAP_HELP_FILE_NAME   "dhcpsnap.chm"

LARGE_INTEGER gliDhcpsnapVersion;
CAuthServerList g_AuthServerList;

WATERMARKINFO g_WatermarkInfoServer = {0};
WATERMARKINFO g_WatermarkInfoScope = {0};

UINT aColumns[DHCPSNAP_NODETYPE_MAX][MAX_COLUMNS] =
{
	{IDS_ROOT_NAME,           IDS_STATUS,       0,                  0,          0,		 0,	          0},
	{IDS_DHCPSERVER_NAME,     IDS_STATUS,       IDS_DESCRIPTION,    0,          0,		 0,	          0},
	{IDS_BOOT_IMAGE,          IDS_FILE_NAME,    IDS_FILE_SERVER,    0,          0,		 0,	          0},
	{IDS_SUPERSCOPE_NAME,     IDS_STATUS,       IDS_DESCRIPTION,    0,          0,		 0,	          0},
	{IDS_SCOPE_NAME,          0,                0,                  0,          0,		 0,	          0},
	{IDS_SCOPE_NAME,          0,                0,                  0,          0,		 0,	          0},
	{IDS_START_IP_ADDR,       IDS_END_IP_ADDR,  IDS_DESCRIPTION,    0,          0,		 0,	          0},
	{IDS_CLIENT_IP_ADDR,      IDS_NAME,         IDS_LEASE,          IDS_TYPE,   IDS_UID, IDS_COMMENT, 0},
	{IDS_CLIENT_IP_ADDR,      IDS_NAME,         IDS_LEASE_START,    IDS_LEASE,  IDS_CLIENT_ID, 0, 0},
	{IDS_RESERVATIONS_FOLDER, 0,                0,                  0,          0,		 0,	          0},
	{IDS_OPTION_NAME,         IDS_VENDOR,       IDS_VALUE,          IDS_CLASS,  0,		 0,	          0},
	{IDS_OPTION_NAME,         IDS_VENDOR,       IDS_VALUE,          IDS_CLASS,  0,		 0,	          0},
	{IDS_OPTION_NAME,         IDS_VENDOR,       IDS_VALUE,          IDS_CLASS,  0,		 0,	          0},
	{IDS_NAME,                IDS_COMMENT,      0,                  0,          0,		 0,	          0},
	{0,0,0,0,0,0,0}
};

//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//
int aColumnWidths[DHCPSNAP_NODETYPE_MAX][MAX_COLUMNS] =
{	
	{200       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_ROOT
	{250       ,150       ,200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SERVER
	{175       ,175       ,175       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_BOOTP_TABLE
	{200	   ,150       ,200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SUPERSCOPE
	{150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SCOPE
	{150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_MSCOPE
	{150	   ,150       ,250       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_ADDRESS_POOL
	{125       ,125	      ,200       ,75        ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_ACTIVE_LEASES
	{125       ,125	      ,200       ,200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_MSCOPE_LEASES
	{200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_RESERVATIONS
	{175       ,100       ,200       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_RESERVATION_CLIENT
	{175       ,100       ,200       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SCOPE_OPTIONS
    {175       ,100       ,200       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SERVER_OPTIONS
    {175       ,200       ,200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}  // DHCPSNAP_CLASSID_HOLDER
};

// array to hold all of the possible toolbar buttons
MMCBUTTON g_SnapinButtons[] =
{
 { TOOLBAR_IDX_ADD_SERVER,        IDS_ADD_SERVER,                TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_REFRESH,           IDS_REFRESH,                   TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_CREATE_SCOPE,      IDS_CREATE_NEW_SCOPE,          TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_CREATE_SUPERSCOPE, IDS_CREATE_NEW_SUPERSCOPE,     TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_DEACTIVATE,        IDS_DEACTIVATE,                TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_ACTIVATE,          IDS_ACTIVATE,                  TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_ADD_BOOTP,         IDS_CREATE_NEW_BOOT_IMAGE,     TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_ADD_RESERVATION,   IDS_CREATE_NEW_RESERVATION,    TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_ADD_EXCLUSION,     IDS_CREATE_NEW_EXCLUSION,      TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_OPTION_GLOBAL,     IDS_CREATE_OPTION_GLOBAL,      TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_OPTION_SCOPE,      IDS_CREATE_OPTION_SCOPE,       TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_OPTION_RESERVATION,IDS_CREATE_OPTION_RESERVATION, TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
};

// array to hold resource IDs for the toolbar button text
int g_SnapinButtonStrings[TOOLBAR_IDX_MAX][2] =
{
    {IDS_TB_TEXT_ADD_SERVER,         IDS_TB_TOOLTIP_ADD_SERVER},         // TOOLBAR_IDX_ADD_SERVER
    {IDS_TB_TEXT_REFRESH,            IDS_TB_TOOLTIP_REFRESH},            // TOOLBAR_IDX_REFRESH
    {IDS_TB_TEXT_CREATE_SCOPE,       IDS_TB_TOOLTIP_CREATE_SCOPE},       // TOOLBAR_IDX_CREATE_SCOPE
    {IDS_TB_TEXT_CREATE_SUPERSCOPE,  IDS_TB_TOOLTIP_CREATE_SUPERSCOPE},  // TOOLBAR_IDX_CREATE_SUPERSCOPE
    {IDS_TB_TEXT_DEACTIVATE,         IDS_TB_TOOLTIP_DEACTIVATE},         // TOOLBAR_IDX_DEACTIVATE
    {IDS_TB_TEXT_ACTIVATE,           IDS_TB_TOOLTIP_ACTIVATE},           // TOOLBAR_IDX_ACTIVATE
    {IDS_TB_TEXT_ADD_BOOTP,          IDS_TB_TOOLTIP_ADD_BOOTP},          // TOOLBAR_IDX_ADD_BOOTP
    {IDS_TB_TEXT_ADD_RESERVATION,    IDS_TB_TOOLTIP_ADD_RESERVATION},    // TOOLBAR_IDX_ADD_RESERVATION
    {IDS_TB_TEXT_ADD_EXCLUSION,      IDS_TB_TOOLTIP_ADD_EXCLUSION},      // TOOLBAR_IDX_ADD_EXCLUSION
    {IDS_TB_TEXT_OPTION_GLOBAL,      IDS_TB_TOOLTIP_OPTION_GLOBAL},      // TOOLBAR_IDX_OPTION_GLOBAL
    {IDS_TB_TEXT_OPTION_SCOPE,       IDS_TB_TOOLTIP_OPTION_SCOPE},       // TOOLBAR_IDX_OPTION_SCOPE
    {IDS_TB_TEXT_OPTION_RESERVATION, IDS_TB_TOOLTIP_OPTION_RESERVATION}, // TOOLBAR_IDX_OPTION_RESERVATION
};

#define HI HIDDEN
#define EN ENABLED

// default states for the toolbar buttons (only scope pane items have toolbar buttons)
MMC_BUTTON_STATE g_SnapinButtonStates[DHCPSNAP_NODETYPE_MAX][TOOLBAR_IDX_MAX] =
{
	{EN, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ROOT
	{HI, HI, EN, EN, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_SERVER
	{HI, HI, HI, HI, HI, HI, EN, HI, HI, HI, HI, HI}, // DHCPSNAP_BOOTP_TABLE
	{HI, HI, EN, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_SUPERSCOPE
	{HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_SCOPE
	{HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_MSCOPE
	{HI, HI, HI, HI, HI, HI, HI, HI, EN, HI, HI, HI}, // DHCPSNAP_ADDRESS_POOL
	{HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ACTIVE_LEASES
	{HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_MSCOPE_LEASES
	{HI, HI, HI, HI, HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_RESERVATIONS
	{HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, EN}, // DHCPSNAP_RESERVATION_CLIENT
    {HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_SCOPE_OPTIONS
	{HI, HI, HI, HI, HI, HI, HI, HI, HI, EN, HI, HI}, // DHCPSNAP_SERVER_OPTIONS
    {HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_CLASSID_HOLDER
};

MMC_CONSOLE_VERB g_ConsoleVerbs[] =
{
	MMC_VERB_OPEN,
    MMC_VERB_COPY,
	MMC_VERB_PASTE,
	MMC_VERB_DELETE,
	MMC_VERB_PROPERTIES,
	MMC_VERB_RENAME,
	MMC_VERB_REFRESH,
	MMC_VERB_PRINT
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStates[DHCPSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
	{HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ROOT
	{HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_SERVER
	{HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_BOOTP_TABLE
	{HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_SUPERSCOPE
	{HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_SCOPE
	{HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_MSCOPE
	{HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_ADDRESS_POOL
	{HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_ACTIVE_LEASES
	{HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_MSCOPE_LEASES
	{HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_RESERVATIONS
	{HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_RESERVATION_CLIENT
    {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_SCOPE_OPTIONS
	{HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_SERVER_OPTIONS
	{HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_CLASSID_HOLDER
	{HI, HI, HI, EN, HI, HI, EN, HI}, // DHCPSNAP_ACTIVE_LEASE
	{HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_ALLOCATION_RANGE
	{HI, HI, HI, EN, HI, HI, EN, HI}, // DHCPSNAP_EXCLUSION_RANGE
	{HI, HI, HI, EN, HI, HI, EN, HI}, // DHCPSNAP_BOOTP_ENTRY
    {HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_OPTION_ITEM
    {HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_CLASSID
    {HI, HI, HI, EN, HI, HI, EN, HI}  // DHCPSNAP_MCAST_LEASE
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[DHCPSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
	{HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ROOT
	{HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_SERVER
	{HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_BOOTP_TABLE
	{HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_SUPERSCOPE
	{HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_SCOPE
	{HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_MSCOPE
	{HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_ADDRESS_POOL
	{HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_ACTIVE_LEASES
	{HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_MSCOPE_LEASES
	{HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_RESERVATIONS
	{HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_RESERVATION_CLIENT
    {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_SCOPE_OPTIONS
	{HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_SERVER_OPTIONS
	{HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_CLASSID_HOLDER
	{HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ACTIVE_LEASE
	{HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ALLOCATION_RANGE
	{HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_EXCLUSION_RANGE
	{HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_BOOTP_ENTRY
    {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_OPTION_ITEM
    {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_CLASSID
    {HI, HI, HI, HI, HI, HI, HI, HI}  // DHCPSNAP_MCAST_LEASE
};

// Help ID array for help on scope items
DWORD g_dwMMCHelp[DHCPSNAP_NODETYPE_MAX] =
{
	DHCPSNAP_HELP_ROOT,                 // DHCPSNAP_ROOT
	DHCPSNAP_HELP_SERVER,               // DHCPSNAP_SERVER
	DHCPSNAP_HELP_BOOTP_TABLE,          // DHCPSNAP_BOOTP_TABLE
	DHCPSNAP_HELP_SUPERSCOPE,           // DHCPSNAP_SUPERSCOPE
	DHCPSNAP_HELP_SCOPE,                // DHCPSNAP_SCOPE
	DHCPSNAP_HELP_MSCOPE,               // DHCPSNAP_MSCOPE
	DHCPSNAP_HELP_ADDRESS_POOL,         // DHCPSNAP_ADDRESS_POOL
	DHCPSNAP_HELP_ACTIVE_LEASES,        // DHCPSNAP_ACTIVE_LEASES
	DHCPSNAP_HELP_ACTIVE_LEASES,        // DHCPSNAP_MSCOPE_LEASES
	DHCPSNAP_HELP_RESERVATIONS,         // DHCPSNAP_RESERVATIONS
	DHCPSNAP_HELP_RESERVATION_CLIENT,   // DHCPSNAP_RESERVATION_CLIENT
    DHCPSNAP_HELP_SCOPE_OPTIONS,        // DHCPSNAP_SCOPE_OPTIONS
	DHCPSNAP_HELP_GLOBAL_OPTIONS,       // DHCPSNAP_SERVER_OPTIONS
	DHCPSNAP_HELP_CLASSID_HOLDER,       // DHCPSNAP_CLASSID_HOLDER
	DHCPSNAP_HELP_ACTIVE_LEASE,         // DHCPSNAP_ACTIVE_LEASE
	DHCPSNAP_HELP_ALLOCATION_RANGE,     // DHCPSNAP_ALLOCATION_RANGE
	DHCPSNAP_HELP_EXCLUSION_RANGE,      // DHCPSNAP_EXCLUSION_RANGE
	DHCPSNAP_HELP_BOOTP_ENTRY,          // DHCPSNAP_BOOTP_ENTRY
    DHCPSNAP_HELP_OPTION_ITEM,          // DHCPSNAP_OPTION_ITEM
    DHCPSNAP_HELP_CLASSID,              // DHCPSNAP_CLASSID
    DHCPSNAP_HELP_MCAST_LEASE           // DHCPSNAP_MCAST_LEASE
};

// help mapper for dialogs and property pages
struct ContextHelpMap
{
    UINT            uID;
    const DWORD *   pdwMap;
};

ContextHelpMap g_uContextHelp[DHCPSNAP_NUM_HELP_MAPS] =
{
    {IDD_ADD_SERVER,                    g_aHelpIDs_IDD_ADD_SERVER},
    {IDD_ADD_TO_SUPERSCOPE,             g_aHelpIDs_IDD_ADD_TO_SUPERSCOPE},
    {IDD_BINARY_EDITOR,                 g_aHelpIDs_IDD_BINARY_EDITOR},
    {IDD_BOOTP_NEW,                     g_aHelpIDs_IDD_BOOTP_NEW},
    {IDD_BROWSE_SERVERS,                g_aHelpIDs_IDD_BROWSE_SERVERS},
    {IDD_CLASSES,		                g_aHelpIDs_IDD_CLASSES},
    {IDD_CLASSID_NEW,                   g_aHelpIDs_IDD_CLASSID_NEW},
    {IDD_CREDENTIALS,                   g_aHelpIDs_IDD_CREDENTIALS},
    {IDD_DATA_ENTRY_BINARY,             g_aHelpIDs_IDD_DATA_ENTRY_BINARY},
    {IDD_DATA_ENTRY_BINARY_ARRAY,       g_aHelpIDs_IDD_DATA_ENTRY_BINARY_ARRAY},
    {IDD_DATA_ENTRY_DWORD,              g_aHelpIDs_IDD_DATA_ENTRY_DWORD},
    {IDD_DATA_ENTRY_IPADDRESS,          g_aHelpIDs_IDD_DATA_ENTRY_IPADDRESS},
    {IDD_DATA_ENTRY_IPADDRESS_ARRAY,    g_aHelpIDs_IDD_DATA_ENTRY_IPADDRESS_ARRAY},
    {IDD_DATA_ENTRY_NONE,               NULL},
    {IDD_DATA_ENTRY_STRING,             g_aHelpIDs_IDD_DATA_ENTRY_STRING},
    {IDD_DATA_ENTRY_ROUTE_ARRAY,        g_aHelpIDs_IDD_DATA_ENTRY_ROUTE_ARRAY},    
    {IDD_DEFAULT_VALUE,                 g_aHelpIDs_IDD_DEFAULT_VALUE},
    {IDD_DEFINE_PARAM,                  g_aHelpIDs_IDD_DEFINE_PARAM},
    {IDD_EXCLUSION_NEW,                 g_aHelpIDs_IDD_EXCLUSION_NEW},
	{IDD_GET_SERVER,					g_aHelpIDs_IDD_GET_SERVER},
	{IDD_GET_SERVER_CONFIRM,			g_aHelpIDs_IDD_GET_SERVER_CONFIRM},
    {IDD_IP_ARRAY_EDIT,                 g_aHelpIDs_IDD_IP_ARRAY_EDIT},
    {IDD_RECONCILIATION,                g_aHelpIDs_IDD_RECONCILIATION},
    {IDD_RESERVATION_NEW,               g_aHelpIDs_IDD_RESERVATION_NEW},
	{IDD_SERVER_BINDINGS,				g_aHelpIDs_IDD_SERVER_BINDINGS},
    {IDD_STATS_NARROW,                  NULL},
    {IDP_BOOTP_GENERAL,                 g_aHelpIDs_IDP_BOOTP_GENERAL},
    {IDP_DNS_INFORMATION,               g_aHelpIDs_IDP_DNS_INFORMATION},
    {IDP_MSCOPE_GENERAL,                g_aHelpIDs_IDP_MSCOPE_GENERAL},
    {IDP_MSCOPE_LIFETIME,               g_aHelpIDs_IDP_MSCOPE_LIFETIME},
    {IDP_OPTION_ADVANCED,               g_aHelpIDs_IDP_OPTION_ADVANCED},
    {IDP_OPTION_BASIC,                  g_aHelpIDs_IDP_OPTION_BASIC},
    {IDP_RESERVED_CLIENT_GENERAL,       g_aHelpIDs_IDP_RESERVED_CLIENT_GENERAL},
	{IDP_SCOPE_ADVANCED,			    g_aHelpIDs_IDP_SCOPE_ADVANCED},
    {IDP_SCOPE_GENERAL,                 g_aHelpIDs_IDP_SCOPE_GENERAL},
	{IDP_SERVER_ADVANCED,			    g_aHelpIDs_IDP_SERVER_ADVANCED},
    {IDP_SERVER_GENERAL,                g_aHelpIDs_IDP_SERVER_GENERAL},
    {IDP_SUPERSCOPE_GENERAL,            g_aHelpIDs_IDP_SUPERSCOPE_GENERAL},
};

CDhcpContextHelpMap     g_dhcpContextHelpMap;

DWORD * DhcpGetHelpMap(UINT uID) 
{
    DWORD * pdwMap = NULL;
    g_dhcpContextHelpMap.Lookup(uID, pdwMap);
    return pdwMap;
}

UINT g_uIconMap[ICON_IDX_MAX + 1][2] = 
{
    {IDI_ICON01,    ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN},
    {IDI_ICON02,	ICON_IDX_ACTIVE_LEASES_LEAF},
    {IDI_ICON03,	ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED},
    {IDI_ICON04,	ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_BUSY},
    {IDI_ICON05,	ICON_IDX_ACTIVE_LEASES_LEAF_BUSY},
    {IDI_ICON06,	ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_BUSY},
    {IDI_ICON07,	ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON08,    ICON_IDX_ACTIVE_LEASES_LEAF_LOST_CONNECTION},
    {IDI_ICON09,	ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON10,	ICON_IDX_ADDR_POOL_FOLDER_OPEN},
    {IDI_ICON11,	ICON_IDX_ADDR_POOL_LEAF},
    {IDI_ICON12,	ICON_IDX_ADDR_POOL_FOLDER_CLOSED},
    {IDI_ICON13,	ICON_IDX_ADDR_POOL_FOLDER_OPEN_BUSY},
    {IDI_ICON14,	ICON_IDX_ADDR_POOL_LEAF_BUSY},
    {IDI_ICON15,	ICON_IDX_ADDR_POOL_FOLDER_CLOSED_BUSY},
    {IDI_ICON16,	ICON_IDX_ADDR_POOL_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON17,	ICON_IDX_ADDR_POOL_LEAF_LOST_CONNECTION},
    {IDI_ICON18,	ICON_IDX_ADDR_POOL_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON19,	ICON_IDX_ALLOCATION_RANGE},
    {IDI_ICON20,	ICON_IDX_BOOTP_ENTRY},
	{IDI_ICON21,	ICON_IDX_BOOTP_TABLE_CLOSED},
	{IDI_ICON22,	ICON_IDX_BOOTP_TABLE_OPEN},
	{IDI_ICON87,	ICON_IDX_BOOTP_TABLE_OPEN_LOST_CONNECTION},
	{IDI_ICON88,	ICON_IDX_BOOTP_TABLE_OPEN_BUSY},
	{IDI_ICON89,	ICON_IDX_BOOTP_TABLE_CLOSED_LOST_CONNECTION},
	{IDI_ICON90,	ICON_IDX_BOOTP_TABLE_CLOSED_BUSY},
    {IDI_ICON23,	ICON_IDX_CLIENT},
    {IDI_ICON24,	ICON_IDX_CLIENT_DNS_REGISTERING},
    {IDI_ICON25,	ICON_IDX_CLIENT_EXPIRED},
    {IDI_ICON26,	ICON_IDX_CLIENT_RAS},
    {IDI_ICON27,	ICON_IDX_CLIENT_OPTION_FOLDER_OPEN},
    {IDI_ICON28,	ICON_IDX_CLIENT_OPTION_LEAF},
    {IDI_ICON29,	ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED},
    {IDI_ICON30,	ICON_IDX_CLIENT_OPTION_FOLDER_OPEN_BUSY},
    {IDI_ICON31,	ICON_IDX_CLIENT_OPTION_LEAF_BUSY},
    {IDI_ICON32,	ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED_BUSY},
    {IDI_ICON33,	ICON_IDX_CLIENT_OPTION_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON34,	ICON_IDX_CLIENT_OPTION_LEAF_LOST_CONNECTION},
    {IDI_ICON35,	ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON36,	ICON_IDX_EXCLUSION_RANGE},
    {IDI_ICON37,	ICON_IDX_FOLDER_CLOSED},
    {IDI_ICON38,	ICON_IDX_FOLDER_OPEN},
    {IDI_ICON39,	ICON_IDX_RES_CLIENT},
    {IDI_ICON40,	ICON_IDX_RES_CLIENT_BUSY},
    {IDI_ICON41,    ICON_IDX_RES_CLIENT_LOST_CONNECTION},
    {IDI_ICON42,    ICON_IDX_RESERVATIONS_FOLDER_OPEN},
    {IDI_ICON43,	ICON_IDX_RESERVATIONS_FOLDER_CLOSED},
    {IDI_ICON44,	ICON_IDX_RESERVATIONS_FOLDER_OPEN_BUSY},
    {IDI_ICON45,	ICON_IDX_RESERVATIONS_FOLDER_CLOSED_BUSY},
    {IDI_ICON46,	ICON_IDX_RESERVATIONS_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON47,	ICON_IDX_RESERVATIONS_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON48,	ICON_IDX_SCOPE_OPTION_FOLDER_OPEN},
    {IDI_ICON49,	ICON_IDX_SCOPE_OPTION_LEAF},
    {IDI_ICON50,	ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED},
    {IDI_ICON51,	ICON_IDX_SCOPE_OPTION_FOLDER_OPEN_BUSY},
    {IDI_ICON52,	ICON_IDX_SCOPE_OPTION_LEAF_BUSY},
    {IDI_ICON53,	ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED_BUSY},
    {IDI_ICON54,	ICON_IDX_SCOPE_OPTION_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON55,	ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON56,	ICON_IDX_SCOPE_OPTION_LEAF_LOST_CONNECTION},
    {IDI_ICON57,	ICON_IDX_SERVER},
    {IDI_ICON58,	ICON_IDX_SERVER_WARNING},
    {IDI_ICON59,	ICON_IDX_SERVER_BUSY},
    {IDI_ICON60,	ICON_IDX_SERVER_CONNECTED},
    {IDI_ICON61,	ICON_IDX_SERVER_GROUP},
    {IDI_ICON62,	ICON_IDX_SERVER_ROGUE},
    {IDI_ICON63,	ICON_IDX_SERVER_LOST_CONNECTION},
    {IDI_ICON64,	ICON_IDX_SERVER_NO_ACCESS},
    {IDI_ICON65,	ICON_IDX_SERVER_ALERT},
    {IDI_ICON66,	ICON_IDX_SERVER_OPTION_FOLDER_OPEN},
    {IDI_ICON67,	ICON_IDX_SERVER_OPTION_LEAF},
    {IDI_ICON68,	ICON_IDX_SERVER_OPTION_FOLDER_CLOSED},
    {IDI_ICON69,	ICON_IDX_SERVER_OPTION_FOLDER_OPEN_BUSY},
    {IDI_ICON70,	ICON_IDX_SERVER_OPTION_LEAF_BUSY},
    {IDI_ICON71,	ICON_IDX_SERVER_OPTION_FOLDER_CLOSED_BUSY},
    {IDI_ICON72,	ICON_IDX_SERVER_OPTION_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON73,	ICON_IDX_SERVER_OPTION_LEAF_LOST_CONNECTION},
    {IDI_ICON74,	ICON_IDX_SERVER_OPTION_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON75,	ICON_IDX_SCOPE_FOLDER_OPEN},
    {IDI_ICON91,	ICON_IDX_SCOPE_FOLDER_OPEN_BUSY},
	{IDI_ICON92,	ICON_IDX_SCOPE_FOLDER_CLOSED_BUSY},					
    {IDI_ICON76,	ICON_IDX_SCOPE_FOLDER_OPEN_WARNING},
    {IDI_ICON77,    ICON_IDX_SCOPE_FOLDER_CLOSED_WARNING},
    {IDI_ICON78,	ICON_IDX_SCOPE_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON79,	ICON_IDX_SCOPE_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON80,	ICON_IDX_SCOPE_FOLDER_OPEN_ALERT},
    {IDI_ICON81,	ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN},
    {IDI_ICON82,	ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED},
    {IDI_ICON83,	ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON84,	ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON85,	ICON_IDX_SCOPE_FOLDER_CLOSED},
    {IDI_ICON86,	ICON_IDX_SCOPE_FOLDER_CLOSED_ALERT},
	{IDI_DHCP_SNAPIN, ICON_IDX_APPLICATION},
    {0, 0}
};

/*!--------------------------------------------------------------------------
	FilterOption
		Filters returns whether or not to filter out the given option.
		Some options we don't want the user to see.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
FilterOption
(
    DHCP_OPTION_ID id
)
{
    //
    // Filter out subnet mask, lease duration,
    // T1, and T2
    //
    return (id == 1  ||  // Subnet mask
			id == 51 ||  // Client Lease Time
			id == 58 ||  // Time between addr assignment  to RENEWING state
			id == 59 ||  // Time from addr assignment to REBINDING state
			id == 81);   // Client DNS name registration
}

/*!--------------------------------------------------------------------------
	FilterUserClassOption
		Filters returns whether or not to filter out the given option for
        a user class. Some options we don't want the user to see.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
FilterUserClassOption
(
    DHCP_OPTION_ID id
)
{
    //
    // Filter out subnet mask, 
    // T1, and T2
    //
    return (id == 1  ||  // Subnet mask
			id == 58 ||  // Time between addr assignment  to RENEWING state
			id == 59 ||  // Time from addr assignment to REBINDING state
			id == 81);   // Client DNS name registration
}


/*!--------------------------------------------------------------------------
	IsBasicOption
		Returns whether the given option is what we've defined as a 
		basic option.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
IsBasicOption
(
    DHCP_OPTION_ID id
)
{
    //
    // Basic Options are:
	//	Router
	//	DNS Server
	//	Domain Name
	//	WINS/NBNS Servers
	//	WINS/NBT Node Type
    //
    return (id == 3  || 
			id == 6	 || 
			id == 15 || 
			id == 44 || 
			id == 46);
}

/*!--------------------------------------------------------------------------
	IsAdvancedOption
		Returns whether the given option is what we've defined as an
		advanced option.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
IsAdvancedOption
(
    DHCP_OPTION_ID id
)
{
    //
    // All non-basic and non-custom options are advanced.
    //
    return (id < 128 && !IsBasicOption(id)); 
}

/*!--------------------------------------------------------------------------
	IsCustomOption
		Returns whether the given option is a user defined option.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
IsCustomOption
(
    DHCP_OPTION_ID id
)
{
    //
    // Custom options are anything with an id > 128
	//
    return (id > 128);
}

/*!--------------------------------------------------------------------------
	GetSystemMessage
		Use FormatMessage() to get a system error message
	Author: EricDav
 ---------------------------------------------------------------------------*/
LONG 
GetSystemMessage 
(
    UINT	nId,
    TCHAR *	chBuffer,
    int		cbBuffSize 
)
{
    TCHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges, as well as
    //  dhcp server error messages.
    //

    if ( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = LoadLibraryEx( _T("netmsg.dll"), NULL,  LOAD_LIBRARY_AS_DATAFILE);
    }
    else 
	if ( nId >= 20000 && nId <= 20099 )
    {
		// DHCP Server error 
        hdll = LoadLibraryEx( _T("dhcpsapi.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE );
    }
	else
	if (nId >= 0x5000 && nId < 0x50FF)
	{
		// It's an ADSI error.  
		hdll = LoadLibraryEx( _T("activeds.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE );
		nId |= 0x80000000;
	}
    else 
	if( nId >= 0x40000000L )
    {
        hdll = LoadLibraryEx( _T("ntdll.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE );
    }

    if ( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    //  Let FormatMessage do the dirty work.
    //
    DWORD dwResult = ::FormatMessage( flags,
                      (LPVOID) hdll,
                      nId,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      chBuffer,
                      cbBuffSize,
                      NULL ) ;

    if ( hdll != NULL )
    {
        LONG err = GetLastError();
        FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? 0 : ::GetLastError() ;
}

/*!--------------------------------------------------------------------------
	LoadMessage
		Loads the error message from the correct DLL.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
LoadMessage 
(
    UINT	nIdPrompt,
    TCHAR *	chMsg,
    int		nMsgSize
)
{
    BOOL bOk;

    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
    if (nIdPrompt == EPT_S_NOT_REGISTERED ||
        nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
    {
        nIdPrompt = IDS_ERR_DHCP_DOWN;
    }
    else if (nIdPrompt == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        nIdPrompt = IDS_ERR_RPC_NO_ENTRY;      
    }

    //
    //  If it's a socket error or our error, the text is in our resource fork.
    //  Otherwise, use FormatMessage() and the appropriate DLL.
    //
    if ( (nIdPrompt >= IDS_ERR_BASE && nIdPrompt < IDS_MESG_MAX) || 
		 (nIdPrompt >= WSABASEERR && nIdPrompt < WSABASEERR + 2000)
       )
    {
        //
        //  It's in our resource fork
        //
        bOk = ::LoadString( AfxGetInstanceHandle(), nIdPrompt, chMsg, nMsgSize ) != 0 ;
    }
    else
	{
        //
        //  It's in the system somewhere.
        //
        bOk = GetSystemMessage( nIdPrompt, chMsg, nMsgSize ) == 0 ;
    }

    //
    //  If the error message did not compute, replace it.
    //
    if ( ! bOk ) 
    {
        TCHAR chBuff [STRING_LENGTH_MAX] ;
        static const TCHAR * pszReplacement = _T("System Error: %ld");
        const TCHAR * pszMsg = pszReplacement ;

        //
        //  Try to load the generic (translatable) error message text
        //
        if ( ::LoadString( AfxGetInstanceHandle(), IDS_ERR_MESSAGE_GENERIC, 
            chBuff, sizeof(chBuff)/sizeof(TCHAR) ) != 0 ) 
        {
            pszMsg = chBuff ;
        }
        ::wsprintf( chMsg, pszMsg, nIdPrompt ) ;
    }

    return bOk;
}

/*!--------------------------------------------------------------------------
	DhcpMessageBox
		Puts up a message box with the corresponding error text.
	Author: EricDav
 ---------------------------------------------------------------------------*/
int 
DhcpMessageBox 
(
    DWORD			dwIdPrompt,
    UINT			nType,
    const TCHAR *	pszSuffixString,
    UINT			nHelpContext 
)
{
    TCHAR chMesg [4000] ;
    BOOL bOk ;

    UINT        nIdPrompt = (UINT) dwIdPrompt;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszSuffixString ) 
    {
        ::lstrcat( chMesg, _T("  ") ) ;
        ::lstrcat( chMesg, pszSuffixString ) ; 
    }

    return ::AfxMessageBox( chMesg, nType, nHelpContext ) ;
}

/*!--------------------------------------------------------------------------
	DhcpMessageBoxEx
		Puts up a message box with the corresponding error text.
	Author: EricDav
 ---------------------------------------------------------------------------*/
int 
DhcpMessageBoxEx
(
    DWORD       dwIdPrompt,
    LPCTSTR     pszPrefixMessage,
    UINT        nType,
    UINT        nHelpContext
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR       chMesg[4000];
    CString     strMessage;
    BOOL        bOk;

    UINT        nIdPrompt = (UINT) dwIdPrompt;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszPrefixMessage ) 
    {
        strMessage = pszPrefixMessage;
        strMessage += _T("\n");
        strMessage += _T("\n");
        strMessage += chMesg;
    }
    else
    {
        strMessage = chMesg;
    }

    return AfxMessageBox(strMessage, nType, nHelpContext);
}

/*---------------------------------------------------------------------------
	Class CDhcpComponent implementation
 ---------------------------------------------------------------------------*/
CDhcpComponent::CDhcpComponent()
{
	m_pbmpToolbar = NULL;
}

CDhcpComponent::~CDhcpComponent()
{
    if (m_pbmpToolbar)
    {
        delete m_pbmpToolbar;
        m_pbmpToolbar = NULL;
    }
}

STDMETHODIMP CDhcpComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_spImageList != NULL);
    
    // Set the images
    HICON       hIcon;
    HRESULT     hr;
    LPOLESTR    pszGuid = NULL;
    long        lViewOptions = 0;
    CLSID       clsid;

    CORg (GetResultViewType(cookie, &pszGuid, &lViewOptions));
    CLSIDFromString(pszGuid, &clsid);

    // if the result pane is not the message view then add the icons
    if (clsid != CLSID_MessageView)
    {
        for (int i = 0; i < ICON_IDX_MAX; i++)
        {
            hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
            {
                // call mmc
                hr = m_spImageList->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1]);
            }
        }
    }
    
Error:
	return S_OK;
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::QueryDataObject
		For multiple select we need to add things to the data object.....
        In order to do this we need to call into the result handler for 
        the node
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDhcpComponent::QueryDataObject
(
    MMC_COOKIE          cookie, 
    DATA_OBJECT_TYPES   type,
    LPDATAOBJECT*       ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;
    SPITFSNode spRootNode;

    // this is a special case for multiple select.  We need to build a list
    // of GUIDs and the code to do this is in the handler...
    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        SPITFSNode spNode;
        SPITFSResultHandler spResultHandler;

        CORg (GetSelectedNode(&spNode));
        CORg (spNode->GetResultHandler(&spResultHandler));

        spResultHandler->OnCreateDataObject(this, cookie, type, ppDataObject);
    }
    else
    if (cookie == MMC_WINDOW_COOKIE)
    {
        // this cookie needs the text for the static root node, so build the DO with
        // the root node cookie
        m_spNodeMgr->GetRootNode(&spRootNode);
        CORg (m_spComponentData->QueryDataObject((MMC_COOKIE) spRootNode->GetData(TFS_DATA_COOKIE), type, ppDataObject));
    }
    else
    {
        // Delegate it to the IComponentData
        Assert(m_spComponentData != NULL);
        CORg (m_spComponentData->QueryDataObject(cookie, type, ppDataObject));
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::SetControlbar
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpComponent::SetControlbar
(
	LPCONTROLBAR	pControlbar
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;
    SPIToolbar  spToolbar;

    COM_PROTECT_TRY
    {
        if (pControlbar)
        {
            // Create the Toolbar
            GetToolbar(&spToolbar);

            if (!spToolbar)
            {
		        CORg(pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&spToolbar)));
		        
                if (!spToolbar)
                    goto Error;

                SetToolbar(spToolbar);

		        // Add the bitmap
                m_pbmpToolbar = new CBitmap;
		        m_pbmpToolbar->LoadBitmap(IDB_TOOLBAR);
		        hr = spToolbar->AddBitmap(TOOLBAR_IDX_MAX, *m_pbmpToolbar, 16, 16, RGB(192, 192, 192));
		        ASSERT(SUCCEEDED(hr));

		        // Add the buttons to the toolbar
		        for (int i = 0; i < TOOLBAR_IDX_MAX; i++)
                {
                    CString strText, strTooltip;
                
                    strText.LoadString(g_SnapinButtonStrings[i][0]);
                    strTooltip.LoadString(g_SnapinButtonStrings[i][1]);

                    g_SnapinButtons[i].lpButtonText = (LPOLESTR) ((LPCTSTR) strText);
                    g_SnapinButtons[i].lpTooltipText = (LPOLESTR) ((LPCTSTR) strTooltip);

                    hr = spToolbar->InsertButton(i, &g_SnapinButtons[i]);
		            ASSERT(SUCCEEDED(hr));
                }
            }
        }
    }
    COM_PROTECT_CATCH

    // store the control bar away for future use
Error:
    m_spControlbar.Set(pControlbar);

	return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::ControlbarNotify
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponent::ControlbarNotify
(
	MMC_NOTIFY_TYPE event, 
	LPARAM			arg, 
	LPARAM			param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
	SPINTERNAL		    spInternal;
	SPITFSNode          spNode;
    MMC_COOKIE          cookie;
    LPDATAOBJECT        pDataObject;
    SPIDataObject       spDataObject;
    DHCPTOOLBARNOTIFY   dhcpToolbarNotify;
	SPIControlBar       spControlbar;
    SPIToolbar          spToolbar;
    SPITFSNodeHandler   spNodeHandler;
    SPITFSResultHandler spResultHandler;
    BOOL                bScope;
    BOOL                bSelect;

    COM_PROTECT_TRY
    {
        CORg(GetControlbar(&spControlbar));
        Assert(spControlbar != NULL);

        CORg(GetToolbar(&spToolbar));
        Assert(spToolbar != NULL);

        // set the controlbar and toolbar pointers in the notify struct
        dhcpToolbarNotify.pControlbar = spControlbar;
        dhcpToolbarNotify.pToolbar = spToolbar;
        
        switch (event)
        {
            case MMCN_SELECT:
                // extract the node information from the data object
                bScope = LOWORD(arg);
                bSelect = HIWORD(arg);
    
                if (!bScope)
                {
                    Assert(param);
                    pDataObject = reinterpret_cast<LPDATAOBJECT>(param);
                    if (pDataObject == NULL)
                        return hr;

                    if ( IS_SPECIAL_DATAOBJECT(pDataObject) ||
                         IsMMCMultiSelectDataObject(pDataObject) )
                    {
                        // CODEWORK:  Do we need to do anything special to the toolbar
                        // during multiselect?  Disable our toolbar buttons?
                        GetSelectedNode(&spNode);
                    }
                    else
                    {
                        CORg(ExtractNodeFromDataObject(m_spNodeMgr,
							                           m_spTFSComponentData->GetCoClassID(),
							                           pDataObject, 
                                                       FALSE,
							                           &spNode,
                                                       NULL, 
                                                       &spInternal));

                        if (spInternal->m_type == CCT_RESULT)
                        {
                            // a result item was selected
                            cookie = spNode->GetData(TFS_DATA_COOKIE);
                        }
                        else
                        {
                            // a scope item in the result pane was selected
                            cookie = NULL;
                        }
                    }
                    
                    if (spNode)
                    {
                        CORg( spNode->GetResultHandler(&spResultHandler) );

                        dhcpToolbarNotify.event = event;
                        dhcpToolbarNotify.id = param;
                        dhcpToolbarNotify.bSelect = bSelect;

                        if (spResultHandler)
			                CORg( spResultHandler->UserResultNotify(spNode, DHCP_MSG_CONTROLBAR_NOTIFY, (LPARAM) &dhcpToolbarNotify) );
                    }
                }
                else
                {
                    dhcpToolbarNotify.cookie = 0;
                    dhcpToolbarNotify.event = event;
                    dhcpToolbarNotify.id = 0;
                    dhcpToolbarNotify.bSelect = bSelect;

                    // check to see if an item is being deselected
                    Assert(param);
                    pDataObject = reinterpret_cast<LPDATAOBJECT>(param);
                    if (pDataObject == NULL)
                        return hr;

                    CORg(ExtractNodeFromDataObject(m_spNodeMgr,
							                       m_spTFSComponentData->GetCoClassID(),
							                       pDataObject, 
                                                   FALSE,
							                       &spNode,
                                                   NULL, 
                                                   &spInternal));

                    CORg( spNode->GetHandler(&spNodeHandler) );
        
            
                    if (spNodeHandler)
			            CORg( spNodeHandler->UserNotify(spNode, DHCP_MSG_CONTROLBAR_NOTIFY, (LPARAM) &dhcpToolbarNotify) );
                }
                break;

            case MMCN_BTN_CLICK:
                Assert(arg);
                pDataObject = reinterpret_cast<LPDATAOBJECT>(arg);
                if (pDataObject == NULL)
                    return hr;

                if ( IS_SPECIAL_DATAOBJECT(pDataObject) )
                {
                    // get a data object for the selected node.
                    GetSelectedNode(&spNode);

                    CORg(QueryDataObject((MMC_COOKIE) spNode->GetData(TFS_DATA_COOKIE), CCT_SCOPE, &spDataObject));
                    spNode.Release();                

                    pDataObject = spDataObject;
                }

                CORg(ExtractNodeFromDataObject(m_spNodeMgr,
							                   m_spTFSComponentData->GetCoClassID(),
							                   pDataObject, 
                                               FALSE,
							                   &spNode,
                                               NULL, 
                                               &spInternal));

                if (spInternal)
                {
                    switch (spInternal->m_type)
                    {
                        case CCT_RESULT:
                            cookie = spNode->GetData(TFS_DATA_COOKIE);
                            CORg( spNode->GetResultHandler(&spResultHandler) );
		                    
                            dhcpToolbarNotify.cookie = cookie;
                            dhcpToolbarNotify.event = event;
                            dhcpToolbarNotify.id = param;
                            dhcpToolbarNotify.bSelect = TRUE;

                            if (spResultHandler)
			                    CORg( spResultHandler->UserResultNotify(spNode, 
                                                                        DHCP_MSG_CONTROLBAR_NOTIFY, 
                                                                        (LPARAM) &dhcpToolbarNotify) );

                            break;

                        case CCT_SCOPE:
                            CORg( spNode->GetHandler(&spNodeHandler) );
		                    
                            dhcpToolbarNotify.cookie = 0;
                            dhcpToolbarNotify.event = event;
                            dhcpToolbarNotify.id = param;
                            dhcpToolbarNotify.bSelect = TRUE;

                            if (spNodeHandler)
			                    CORg( spNodeHandler->UserNotify(spNode, 
                                                                DHCP_MSG_CONTROLBAR_NOTIFY, 
                                                                (LPARAM) &dhcpToolbarNotify) );
                            break;
    
                        default:
                            Assert(FALSE);
                            break;
                    }
                }
                break;

            case MMCN_DESELECT_ALL:
                // what are we supposed to do here???
                break;

            default:
                Panic1("CDhcpComponent::ControlbarNotify - Unknown event %d", event);
                break;

        }
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::OnSnapinHelp
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponent::OnSnapinHelp
(
	LPDATAOBJECT	pDataObject,
	LPARAM			arg, 
	LPARAM			param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

    HtmlHelpA(NULL, DHCPSNAP_HELP_FILE_NAME, HH_DISPLAY_TOPIC, 0);

	return hr;
}

/*---------------------------------------------------------------------------
	Class CDhcpComponentData implementation
 ---------------------------------------------------------------------------*/
CDhcpComponentData::CDhcpComponentData()
{
    gliDhcpsnapVersion.LowPart = DHCPSNAP_MINOR_VERSION;
	gliDhcpsnapVersion.HighPart = DHCPSNAP_MAJOR_VERSION;

    // initialize our global help map
    for (int i = 0; i < DHCPSNAP_NUM_HELP_MAPS; i++)
    {
        g_dhcpContextHelpMap.SetAt(g_uContextHelp[i].uID, (LPDWORD) g_uContextHelp[i].pdwMap);
    }
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::OnInitialize
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDhcpComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HICON   hIcon;

    // thread deletes itself
    CStandaloneAuthServerWorker * pWorker = new CStandaloneAuthServerWorker();
    pWorker->CreateThread();

    // initialize icon images with MMC
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(pScopeImage->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::OnDestroy
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDhcpComponentData::OnDestroy()
{
	m_spNodeMgr.Release();

    if (g_bDhcpDsInitialized)
    {
        ::DhcpDsCleanup();
        g_bDhcpDsInitialized = FALSE;
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::OnInitializeNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponentData::OnInitializeNodeMgr
(
	ITFSComponentData *	pTFSCompData, 
	ITFSNodeMgr *		pNodeMgr
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	CDhcpRootHandler *	pHandler = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode;
	HRESULT				hr = hrOK;

	try
	{
		pHandler = new CDhcpRootHandler(pTFSCompData);

		// Do this so that it will get released correctly
		spHandler = pHandler;
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}
	CORg( hr );
	
	// Create the root node for this sick puppy
	CORg( CreateContainerTFSNode(&spNode,
								 &GUID_DhcpRootNodeType,
								 pHandler,
								 pHandler,		 /* result handler */
								 pNodeMgr) );

	// Need to initialize the data for the root node
	pHandler->InitializeNode(spNode);	

	CORg( pNodeMgr->SetRootNode(spNode) );
	m_spRootNode.Set(spNode);

    // setup watermark info
    if (g_WatermarkInfoServer.hHeader == NULL)
    {
        // haven't been initialized yet
        InitWatermarkInfo(AfxGetInstanceHandle(),
                          &g_WatermarkInfoServer,      
                          IDB_SRVWIZ_BANNER,        // Header ID
                          IDB_SRVWIZ_WATERMARK,     // Watermark ID
                          NULL,                     // hPalette
                          FALSE);                   // bStretch

        InitWatermarkInfo(AfxGetInstanceHandle(),
                          &g_WatermarkInfoScope,      
                          IDB_SCPWIZ_BANNER,        // Header ID
                          IDB_SCPWIZ_WATERMARK,     // Watermark ID
                          NULL,                     // hPalette
                          FALSE);                   // bStretch
    }

    pTFSCompData->SetHTMLHelpFileName(_T(DHCPSNAP_HELP_FILE_NAME));
    
	// disable taskpads by default
	pTFSCompData->SetTaskpadState(TASKPAD_ROOT_INDEX, FALSE);
    pTFSCompData->SetTaskpadState(TASKPAD_SERVER_INDEX, FALSE);


Error:	
	return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::OnCreateComponent
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponentData::OnCreateComponent
(
	LPCOMPONENT *ppComponent
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ppComponent != NULL);
	
	HRESULT			  hr = hrOK;
	CDhcpComponent *  pComp = NULL;

	try
	{
		pComp = new CDhcpComponent;
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}

	if (FHrSucceeded(hr))
	{
		pComp->Construct(m_spNodeMgr,
						static_cast<IComponentData *>(this),
						m_spTFSComponentData);
		*ppComponent = static_cast<IComponent *>(pComp);
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::GetCoClassID
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) 
CDhcpComponentData::GetCoClassID()
{
	return &CLSID_DhcpSnapin;
}

/*!--------------------------------------------------------------------------
	CDhcpComponentData::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponentData::OnCreateDataObject
(
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	
	pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*GetCoClassID());

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP 
CDhcpComponentData::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_DhcpSnapin;

    return hrOK;
}

STDMETHODIMP 
CDhcpComponentData::IsDirty()
{
	return m_spRootNode->GetData(TFS_DATA_DIRTY) ? hrOK : hrFalse;
}

STDMETHODIMP 
CDhcpComponentData::Load
(
	IStream *pStm
)
{
	HRESULT         hr = hrOK;
	LARGE_INTEGER   liSavedVersion;
	CString         str;
    
	ASSERT(pStm);

    CStringArray    strArrayIp;
    CStringArray    strArrayName;
    CDWordArray     dwArrayServerOptions;
    CDWordArray     dwArrayRefreshInterval;
	CDWordArray     dwArrayColumnInfo;
    DWORD           dwFileVersion;
    CDhcpRootHandler * pRootHandler;
    DWORD           dwFlags = 0;
    int             i, j;

    ASSERT(pStm);
    
    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_READ);    
    
    // read the version of the file format
    CORg(xferStream.XferDWORD(DHCPSTRM_TAG_VERSION, &dwFileVersion));
	if (dwFileVersion < DHCPSNAP_FILE_VERSION)
	{
	    AFX_MANAGE_STATE(AfxGetStaticModuleState());
		AfxMessageBox(_T("This console file was saved with a previous version of the snapin and is not compatible.  The settings could not be restored."));
		return hr;
	}

    // Read the version # of the admin tool
    CORg(xferStream.XferLARGEINTEGER(DHCPSTRM_TAG_VERSIONADMIN, &liSavedVersion));
	if (liSavedVersion.QuadPart < gliDhcpsnapVersion.QuadPart)
	{
		// File is an older version.  Warn the user and then don't
		// load anything else
		Assert(FALSE);
	}

	// Read the root node name
    CORg(xferStream.XferCString(DHCPSTRM_TAB_SNAPIN_NAME, &str));
	Assert(m_spRootNode);
	pRootHandler = GETHANDLER(CDhcpRootHandler, m_spRootNode);
	pRootHandler->SetDisplayName(str);
    
    // now read all of the server information
    CORg(xferStream.XferCStringArray(DHCPSTRM_TAG_SERVER_IP, &strArrayIp));
    CORg(xferStream.XferCStringArray(DHCPSTRM_TAG_SERVER_NAME, &strArrayName));
    CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_SERVER_OPTIONS, &dwArrayServerOptions));
    CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval));

	// now load the column information
	for (i = 0; i < NUM_SCOPE_ITEMS; i++)
	{
		CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));

		for (j = 0; j < MAX_COLUMNS; j++)
		{
            // mmc now saves column widths for us, but we don't want to change the
            // format of this file, so just don't set our internal struct
			//aColumnWidths[i][j] = dwArrayColumnInfo[j];
		}

	}

    // now create the servers based on the information
    for (i = 0; i < strArrayIp.GetSize(); i++)
	{
		//
		// now create the server object
		//
		pRootHandler->AddServer((LPCWSTR) strArrayIp[i], 
                                strArrayName[i],
                                FALSE, 
                                dwArrayServerOptions[i], 
                                dwArrayRefreshInterval[i]);
	}

    // read in flags (for taskpads)
    CORg(xferStream.XferDWORD(DHCPSTRM_TAG_SNAPIN_OPTIONS, &dwFlags));

    if (!FUseTaskpadsByDefault(NULL))
        dwFlags = 0;

	// disable taskpads, the default is off
    //m_spTFSComponentData->SetTaskpadState(TASKPAD_ROOT_INDEX, dwFlags & TASKPAD_ROOT_FLAG);
    //m_spTFSComponentData->SetTaskpadState(TASKPAD_SERVER_INDEX, dwFlags & TASKPAD_SERVER_FLAG);

Error:
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}


STDMETHODIMP 
CDhcpComponentData::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	HRESULT			hr = hrOK;
    CStringArray	strArrayIp;
    CStringArray	strArrayName;
    CDWordArray		dwArrayServerOptions;
    CDWordArray		dwArrayRefreshInterval;
	CDWordArray		dwArrayColumnInfo;
	CString			str;
    DWORD			dwFileVersion = DHCPSNAP_FILE_VERSION;
	CDhcpRootHandler * pRootHandler;
	SPITFSNodeEnum	spNodeEnum;
    SPITFSNode		spCurrentNode;
    ULONG			nNumReturned = 0;
    int             nNumServers = 0, nVisibleCount = 0;
    int				i, j, nCount = 0;
    CDhcpServer *   pServer;
    DWORD           dwFlags = 0;

    ASSERT(pStm);
    
    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_WRITE);    

    // Write the version # of the file format
    CORg(xferStream.XferDWORD(DHCPSTRM_TAG_VERSION, &dwFileVersion));
	
    // Write the version # of the admin tool
    CORg(xferStream.XferLARGEINTEGER(DHCPSTRM_TAG_VERSIONADMIN, &gliDhcpsnapVersion));

	// write the root node name
    Assert(m_spRootNode);
	pRootHandler = GETHANDLER(CDhcpRootHandler, m_spRootNode);
	str = pRootHandler->GetDisplayName();

    CORg(xferStream.XferCString(DHCPSTRM_TAB_SNAPIN_NAME, &str));

	//
	// Build our array of servers
	//
	hr = m_spRootNode->GetChildCount(&nVisibleCount, &nNumServers);

    strArrayIp.SetSize(nNumServers);
    strArrayName.SetSize(nNumServers);
    dwArrayServerOptions.SetSize(nNumServers);
    dwArrayRefreshInterval.SetSize(nNumServers);
	dwArrayColumnInfo.SetSize(MAX_COLUMNS);

	//
	// loop and save off all the server's attributes
	//
    m_spRootNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		pServer = GETHANDLER(CDhcpServer, spCurrentNode);

        // query the server for it's options:
        // auto refresh, bootp and classid visibility
        // NOTE: the audit logging state is also kept in here, but
        // it will get updated when the server node is enumerated
        dwArrayServerOptions[nCount] = pServer->GetServerOptions();
        pServer->GetAutoRefresh(NULL, &dwArrayRefreshInterval[nCount]);

		// put the information in our array
		strArrayIp[nCount] = pServer->GetIpAddress();
        strArrayName[nCount] = pServer->GetName();

        // go to the next node
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        nCount++;
	}

    // now write out all of the server information
    CORg(xferStream.XferCStringArray(DHCPSTRM_TAG_SERVER_IP, &strArrayIp));
    CORg(xferStream.XferCStringArray(DHCPSTRM_TAG_SERVER_NAME, &strArrayName));
    CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_SERVER_OPTIONS, &dwArrayServerOptions));
    CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval));

	// now save the column information
	for (i = 0; i < NUM_SCOPE_ITEMS; i++)
	{
		CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));

		for (j = 0; j < MAX_COLUMNS; j++)
		{
			dwArrayColumnInfo[j] = aColumnWidths[i][j];
		}
	}

	if (fClearDirty)
	{
		m_spRootNode->SetData(TFS_DATA_DIRTY, FALSE);
	}

    // save off taskpad states

    // root node taskpad state
    if (m_spTFSComponentData->GetTaskpadState(TASKPAD_ROOT_INDEX))
        dwFlags |= TASKPAD_ROOT_FLAG;

    // server node taskpad state
    if (m_spTFSComponentData->GetTaskpadState(TASKPAD_SERVER_INDEX))
        dwFlags |= TASKPAD_SERVER_FLAG;

    CORg(xferStream.XferDWORD(DHCPSTRM_TAG_SNAPIN_OPTIONS, &dwFlags));

Error:
    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}


STDMETHODIMP 
CDhcpComponentData::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 10240);

    return S_OK;
}

STDMETHODIMP 
CDhcpComponentData::InitNew()
{
	return hrOK;
}

HRESULT 
CDhcpComponentData::FinalConstruct()
{
	HRESULT				hr = hrOK;
	
	hr = CComponentData::FinalConstruct();
	
	if (FHrSucceeded(hr))
	{
		m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
	}
	return hr;
}

void 
CDhcpComponentData::FinalRelease()
{
	CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\dhcphand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	dhcphand.h
		Header file for dhcp specific base handler classes and query obj

    FILE HISTORY:
        
*/

#ifndef _DHCPHAND_H
#define _DHCPHAND_H

#define DHCP_IP_ADDRESS_INVALID  ((DHCP_IP_ADDRESS)0)

#ifndef _HANDLERS_H
#include <handlers.h>
#endif

#ifndef _QUERYOBJ_H
#include <queryobj.h>
#endif

class CClassInfoArray;
class COptionValueEnum;

class CToolbarInfo
{
public:
    CToolbarInfo() : fSelected(FALSE) {};
    SPITFSNode  spNode;
    BOOL        fSelected;
};

/*---------------------------------------------------------------------------
	Class:	CHandlerEx
 ---------------------------------------------------------------------------*/
class CHandlerEx
{
// Interface
public:
    virtual HRESULT InitializeNode(ITFSNode * pNode) = 0;
	LPCTSTR GetDisplayName() { return m_strDisplayName; }
	void    SetDisplayName(LPCTSTR pName) { m_strDisplayName = pName; }

private:
	CString m_strDisplayName;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpHandler
 ---------------------------------------------------------------------------*/
class CDhcpHandler : 
        public CHandler,
		public CHandlerEx
{
public:
    CDhcpHandler(ITFSComponentData *pCompData) 
        : CHandler(pCompData), 
          m_verbDefault(MMC_VERB_OPEN) {};
	~CDhcpHandler() {};

    // base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // by default we don't allow nodes to be renamed
    OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }

    // Toolbar functionality        
    OVERRIDE_NodeHandler_UserNotify();
    OVERRIDE_ResultHandler_UserResultNotify();

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    // menu stuff
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

    HRESULT HandleScopeCommand(MMC_COOKIE cookie, int nCommandID, LPDATAOBJECT pDataObject);
    HRESULT HandleScopeMenus(MMC_COOKIE	cookie,	LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pContextMenuCallback, long * pInsertionAllowed);

    // toolbar stuff
    virtual HRESULT OnControlbarNotify(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);
    virtual HRESULT OnResultControlbarNotify(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);

    virtual HRESULT OnToolbarButtonClick(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);
    virtual HRESULT OnUpdateToolbarButtons(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);

    void EnableToolbar(LPTOOLBAR        pToolbar, 
                       MMCBUTTON        rgSnapinButtons[], 
                       int              nRgSize,
                       MMC_BUTTON_STATE ButtonState[],
                       BOOL             bState = TRUE);

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);

    virtual DWORD UpdateStatistics(ITFSNode * pNode) { return 0; }

    // any node with taskpads should override this to identify itself
    virtual int   GetTaskpadIndex() { return 0; }

protected:
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);

public:
    // This is the default verb, by default it is set to MMC_VERB_OPEN
	MMC_CONSOLE_VERB	m_verbDefault;
};

/*---------------------------------------------------------------------------
	Class:	CMTDhcpHandler
 ---------------------------------------------------------------------------*/
class CMTDhcpHandler : 
		public CMTHandler,
		public CHandlerEx
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad
	} nodeStateType;

	CMTDhcpHandler(ITFSComponentData *pCompData) 
        : CMTHandler(pCompData), 
          m_verbDefault(MMC_VERB_OPEN),
          m_bSelected(FALSE),
          m_fSilent(FALSE),
          m_fExpandSync(FALSE)
		{  m_nState = notLoaded; }

	~CMTDhcpHandler() {};

    // base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // by default we don't allow nodes to be renamed
	OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }
    OVERRIDE_BaseHandlerNotify_OnExpandSync();

    // base result handler overrides
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
	OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    // Toolbar functionality        
    OVERRIDE_NodeHandler_UserNotify();
    OVERRIDE_ResultHandler_UserResultNotify();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    virtual HRESULT OnControlbarNotify(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);
    virtual HRESULT OnResultControlbarNotify(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);

    virtual HRESULT OnToolbarButtonClick(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);
    virtual HRESULT OnUpdateToolbarButtons(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);

    // menu stuff
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

    HRESULT HandleScopeCommand(MMC_COOKIE cookie, int nCommandID, LPDATAOBJECT pDataObject);
    HRESULT HandleScopeMenus(MMC_COOKIE	cookie,	LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pContextMenuCallback, long * pInsertionAllowed);

    void EnableToolbar(LPTOOLBAR        pToolbar, 
                       MMCBUTTON        rgSnapinButtons[], 
                       int              nRgSize,
                       MMC_BUTTON_STATE ButtonState[],
                       BOOL             Enable[]);

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);
    
    // for statistics notification
    HRESULT OnRefreshStats(ITFSNode *	pNode,
                           LPDATAOBJECT	pDataObject,
                           DWORD		dwType,
                           LPARAM		arg,
                           LPARAM		param);
    virtual DWORD UpdateStatistics(ITFSNode * pNode) { return 0; }
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);
    HRESULT OnResultUpdateOptions(ITFSComponent *     pComponent,
                                  ITFSNode *		  pNode,
                                  CClassInfoArray *   pClassInfoArray,
                                  COptionValueEnum *  aEnum[],
                                  int                 aImages[],
                                  int                 nCount);

protected:
    virtual void GetErrorMessages(CString & strTitle, CString & strBody, IconIdentifier * icon);
    virtual void OnChangeState(ITFSNode* pNode);
	virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNewNode)
	{
		if (pNewNode->IsContainer())
		{
			// assume all the child containers are derived from this class
			//((CDHCPMTContainer*)pNode)->SetServer(GetServer());
		}
		pParentNode->AddChild(pNewNode);
	}

    void    UpdateStandardVerbs(ITFSNode * pToolbar, LONG_PTR dwNodeType);
    void    SendUpdateToolbar(ITFSNode * pNode, BOOL fSelected);
    virtual void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);
    virtual void    UpdateToolbar(IToolbar * pToolbar, LONG_PTR dwNodeType, BOOL bSelect);
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);
    void    ExpandNode(ITFSNode * pNode, BOOL fExpand);

    // any node with taskpads should override this to identify itself
    virtual int   GetTaskpadIndex() { return 0; }

protected:
    BOOL        m_bSelected;
    BOOL        m_fSilent;
    BOOL        m_fExpandSync;

    // This is the default verb, by default it is set to MMC_VERB_OPEN
	MMC_CONSOLE_VERB	m_verbDefault;
};

/*---------------------------------------------------------------------------
	Class:	CDHCPQueryObj : general purpose base class
 ---------------------------------------------------------------------------*/
class CDHCPQueryObj : public CNodeQueryObject
{
public:
	CDHCPQueryObj
	(
		ITFSComponentData *	pTFSCompData, 
		ITFSNodeMgr *		pNodeMgr
	) : m_dwErr(0)
	{
		m_spTFSCompData.Set(pTFSCompData); 
	    m_spNodeMgr.Set(pNodeMgr);
	}

	CQueueDataListBase & GetQueue() { return m_dataQueue; }

public:
	CString				 m_strServer;
	SPITFSComponentData  m_spTFSCompData;
	SPITFSNodeMgr		 m_spNodeMgr;
	DWORD				 m_dwErr;
};

#endif _DHCPHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\dhcpcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dhcpcomp.h
		This file contains the derived prototypes from CComponent
		and CComponentData for the DHCP admin snapin.

    FILE HISTORY:
        
*/

#ifndef _DHCPCOMP_H
#define _DHCPCOMP_H

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _COMPONT_H_
#include "compont.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _SERVBROW_H
#include "servbrow.h"
#endif

#define COLORREF_PINK	0x00FF00FF

extern CAuthServerList g_AuthServerList;

#ifdef __cplusplus
extern "C" {
#endif

extern   WATERMARKINFO   g_WatermarkInfoServer;
extern   WATERMARKINFO   g_WatermarkInfoScope;

BOOL FilterOption(DHCP_OPTION_ID id);
BOOL FilterUserClassOption(DHCP_OPTION_ID id);
BOOL IsBasicOption(DHCP_OPTION_ID id);
BOOL IsAdvancedOption(DHCP_OPTION_ID id);
BOOL IsCustomOption(DHCP_OPTION_ID id);

//  Use FormatMessage() to get a system error message
LONG GetSystemMessage ( UINT nId, TCHAR * chBuffer, int cbBuffSize ) ;

BOOL LoadMessage (UINT nIdPrompt, TCHAR * chMsg, int nMsgSize);

//  Surrogate AfxMessageBox replacement for error message filtering.
int DhcpMessageBox(DWORD dwIdPrompt, 
 				   UINT nType = MB_OK, 
				   const TCHAR * pszSuffixString = NULL,
				   UINT nHelpContext = -1);

int DhcpMessageBoxEx(DWORD   dwIdPrompt, 
 				     LPCTSTR pszPrefixMessage,
                     UINT    nType = (UINT) MB_OK, 
  				     UINT    nHelpContext = -1);

#ifdef __cplusplus
} // extern "C"
#endif

#define TASKPAD_ROOT_FLAG       0x00000001
#define TASKPAD_SERVER_FLAG     0x00000002

#define TASKPAD_ROOT_INDEX      0x00000000
#define TASKPAD_SERVER_INDEX    0x00000001

enum DHCPSTRM_TAG
{
	DHCPSTRM_TAG_VERSION =		            XFER_TAG(1, XFER_DWORD),
	DHCPSTRM_TAG_VERSIONADMIN =	            XFER_TAG(2, XFER_LARGEINTEGER),
    DHCPSTRM_TAB_SNAPIN_NAME =              XFER_TAG(3, XFER_STRING),
    DHCPSTRM_TAG_SERVER_IP =		        XFER_TAG(4, XFER_STRING_ARRAY),
	DHCPSTRM_TAG_SERVER_NAME =		        XFER_TAG(5, XFER_STRING_ARRAY),
	DHCPSTRM_TAG_SERVER_OPTIONS =	        XFER_TAG(6, XFER_DWORD_ARRAY),
	DHCPSTRM_TAG_SERVER_REFRESH_INTERVAL =	XFER_TAG(7, XFER_DWORD_ARRAY),
	DHCPSTRM_TAG_COLUMN_INFO =				XFER_TAG(8, XFER_DWORD_ARRAY),
	DHCPSTRM_TAG_SNAPIN_OPTIONS =		    XFER_TAG(9, XFER_DWORD)
};

/////////////////////////////////////////////////////////////////////////////
// CDhcpComponentData

class CDhcpComponentData :
	public CComponentData,
	public CComObjectRoot
{
public:
	
BEGIN_COM_MAP(CDhcpComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet2)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()
			
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	CDhcpComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
	SPITFSNode		m_spRootNode;

// Notify handler declarations
private:
};

/////////////////////////////////////////////////////////////////////////////
// CDhcpComponent
class CDhcpComponent : 
	public TFSComponent
{
public:
	CDhcpComponent();
	~CDhcpComponent();

	STDMETHOD(InitializeBitmaps)(MMC_COOKIE cookie);
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param); 
    STDMETHOD(QueryDataObject)(MMC_COOKIE           cookie, 
                               DATA_OBJECT_TYPES    type,
                               LPDATAOBJECT*        ppDataObject);
	STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);

//Attributes
private:
    CBitmap*			m_pbmpToolbar;  // Imagelist for toolbar
};

/*---------------------------------------------------------------------------
	This is how the DHCP snapin implements its extension functionality.
	It actually exposes two interfaces that are CoCreate-able.  One is the 
	primary interface, the other the extension interface.
	
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CDhcpComponentDataPrimary : public CDhcpComponentData,
	public CComCoClass<CDhcpComponentDataPrimary, &CLSID_DhcpSnapin>
{
public:
	DECLARE_REGISTRY(CDhcpComponentDataPrimary, 
					 _T("DhcpSnapin.DhcpSnapin.1"), 
					 _T("DhcpSnapin.DhcpSnapin"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

	STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_DhcpSnapin; }
};


class CDhcpComponentDataExtension : public CDhcpComponentData,
    public CComCoClass<CDhcpComponentDataExtension, &CLSID_DhcpSnapinExtension>
{
public:
	DECLARE_REGISTRY(CDhcpComponentDataExtension, 
					 _T("DhcpSnapinExtension.DhcpSnapinExtension.1"), 
					 _T("DhcpSnapinExtension.DhcpSnapinExtension"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_DhcpSnapinExtension; }
};


/*---------------------------------------------------------------------------
	This is the derived class for handling the IAbout interface from MMC
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CDhcpAbout : 
	public CAbout,
    public CComCoClass<CDhcpAbout, &CLSID_DhcpSnapinAbout>
{
public:
DECLARE_REGISTRY(CDhcpAbout, _T("DhcpSnapin.About.1"), 
							 _T("DhcpSnapin.About"), 
							 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CDhcpAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDhcpAbout)

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_PROVIDER; }
	virtual UINT GetAboutVersionId()	 { return IDS_ABOUT_VERSION; }
	virtual UINT GetAboutIconId()		 { return IDI_DHCP_SNAPIN; }

	virtual UINT GetSmallRootId()		 { return IDB_ROOT_SMALL; }
	virtual UINT GetSmallOpenRootId()	 { return IDB_ROOT_SMALL; }
	virtual UINT GetLargeRootId()		 { return IDB_ROOT_LARGE; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) COLORREF_PINK; } 

};
    
#endif _DHCPCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\dhcp\dlgbined.cpp ===
/**********************************************************************/
/**               Microsoft Windows NT                               **/
/**            Copyright(c) Microsoft Corporation, 1991 - 1999 **/
/**********************************************************************/

/*
    DLGBINED
        Binary Editor dialog    

    FILE HISTORY:

*/

#include "stdafx.h"
#include "dlgbined.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgBinEd dialog

CDlgBinEd::CDlgBinEd
(
   CDhcpOption * pdhcType,
   DHCP_OPTION_SCOPE_TYPE dhcScopeType,
   CWnd* pParent /*=NULL*/
)
   : CBaseDialog(CDlgBinEd::IDD, pParent),
     m_p_type( pdhcType ),
     m_b_decimal( TRUE ),
     m_b_changed( FALSE ),
     m_option_type( dhcScopeType )
{
    //{{AFX_DATA_INIT(CDlgBinEd)
    //}}AFX_DATA_INIT

    ASSERT( m_p_type != NULL ) ;
}

void 
CDlgBinEd::DoDataExchange
(
    CDataExchange* pDX
)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgBinEd)
    DDX_Control(pDX, IDC_RADIO_HEX, m_butn_hex);
    DDX_Control(pDX, IDC_RADIO_DECIMAL, m_butn_decimal);
    DDX_Control(pDX, IDC_STATIC_UNIT_SIZE, m_static_unit_size);
    DDX_Control(pDX, IDC_STATIC_OPTION_NAME, m_static_option_name);
    DDX_Control(pDX, IDC_STATIC_APPLICATION, m_static_application);
    DDX_Control(pDX, IDC_LIST_VALUES, m_list_values);
    DDX_Control(pDX, IDC_EDIT_VALUE, m_edit_value);
    DDX_Control(pDX, IDC_BUTN_DELETE, m_butn_delete);
    DDX_Control(pDX, IDC_BUTN_ADD, m_butn_add);
    DDX_Control(pDX, IDC_BUTN_UP, m_button_Up);
    DDX_Control(pDX, IDC_BUTN_DOWN, m_button_Down);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDlgBinEd, CBaseDialog)
    //{{AFX_MSG_MAP(CDlgBinEd)
    ON_BN_CLICKED(IDC_RADIO_DECIMAL, OnClickedRadioDecimal)
    ON_BN_CLICKED(IDC_RADIO_HEX, OnClickedRadioHex)
    ON_BN_CLICKED(IDC_BUTN_ADD, OnClickedButnAdd)
    ON_BN_CLICKED(IDC_BUTN_DELETE, OnClickedButnDelete)
    ON_BN_CLICKED(IDC_BUTN_DOWN, OnClickedButnDown)
    ON_BN_CLICKED(IDC_BUTN_UP, OnClickedButnUp)
    ON_LBN_SELCHANGE(IDC_LIST_VALUES, OnSelchangeListValues)
    ON_EN_CHANGE(IDC_EDIT_VALUE, OnChangeEditValue)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgBinEd message handlers

BOOL 
CDlgBinEd::OnInitDialog()
{
    CBaseDialog::OnInitDialog();
    CString str ;
    CString strNum ;
    DWORD err = 0 ;
    int cUnitSize = 1 ;
    int cStrId = m_option_type == DhcpDefaultOptions
           ? IDS_INFO_TITLE_DEFAULT_OPTIONS
           : (m_option_type == DhcpGlobalOptions
                        ? IDS_INFO_TITLE_GLOBAL_OPTIONS
                        : IDS_INFO_TITLE_SCOPE_OPTIONS  ) ;

    switch ( m_p_type->QueryValue().QueryDataType() )
    {
        case DhcpWordOption:
            cUnitSize = 2 ;
            break ;

        case DhcpDWordOption:
            cUnitSize = 4 ;
            break ;

        case DhcpDWordDWordOption:
            cUnitSize = 8 ;
            break ;
    }

    CATCH_MEM_EXCEPTION
    {

        strNum.Format(_T("%d"), cUnitSize);
        m_static_unit_size.SetWindowText( strNum ) ;

        m_static_option_name.SetWindowText( m_p_type->QueryName() ) ;

        str.LoadString( cStrId ) ;
        m_static_application.SetWindowText( str ) ;

        //
        //  Fill the internal list from the current value.
        //
        FillArray() ;
        Fill( 0, TRUE ) ;

        //
        //  Set focus on the new value edit control.
 