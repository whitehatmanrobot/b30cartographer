
            usErr = pdgi->Generate(&cb, 1, SHRT_MAX);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }

            if(S_OK == hr)
            {
                // Create a new stream

                hr = pIStorage->CreateStream(
                        poszNewName,
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, 
                        0,
                        0,
                        &pIStreamNew);

                DH_HRCHECK(hr, TEXT("IStorage::CreateStream")) ;
            }

            // Write into stream

            if(S_OK == hr)
            {
                hr = GenerateRandomName(pdgu, cb, cb, &ptszNewData);

                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
            }

            if(S_OK == hr)
            {
                // Convert ptcsName to OLECHAR

                hr = TStringToOleString(ptszNewData, &poszNewData);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pIStreamNew->Write(poszNewData, cb, &culWritten);
            
                DH_HRCHECK(hr, TEXT("VirtualStmNode::Write")) ;
            }

            // Close the stream

            if(S_OK == hr)
            {
                ulRef = pIStreamNew->Release();
                DH_ASSERT(0 == ulRef);
                pIStreamNew = NULL;
            }
        }
    }

    // Clean up

    if(NULL != ptszNewName)
    {
        delete ptszNewName;
        ptszNewName = NULL;
    }

    if(NULL != poszNewName)
    {
        delete poszNewName;
        poszNewName = NULL;
    }

    if(NULL != ptszNewData)
    {
        delete ptszNewData;
        ptszNewData = NULL;
    }

    if(NULL != poszNewName)
    {
        delete poszNewName;
        poszNewName = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: ChangeStreamData
//
// Synopsis: Randomly changes size or data of an IStream object in a DocFile 
//
// Arguments: [pIStorage] - Pointer to parent storage
//            [pStatStg] - Pointer to STATSTG structure 
//            [pdgi] - Pointer to data generator integer object
//            [pdgu] - Pointer to data generator unicode object
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
//----------------------------------------------------------------------------

HRESULT ChangeStreamData(
    LPSTORAGE       pIStorage,
    STATSTG         *pStatStg,
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu)
{
    HRESULT         hr              =   S_OK;
    USHORT          usErr           =   0;
    LPTSTR          ptszName        =   NULL;
    LPOLESTR        poszName        =   NULL;
    LPTSTR          ptszNewData     =   NULL;
    LPOLESTR        poszNewData     =   NULL;
    ULONG           cb              =   0;
    ULONG           culWritten      =   0;
    ULONG           ulStreamOffset  =   0;
    LONG            lOffset         =   0;
    INT             cSign           =   0;
    UINT            cRandomVar      =   0;
    LPSTREAM        pIStream        =   NULL;
    ULONG           ulRef           =   0;
    LARGE_INTEGER   liStreamPos;
    LARGE_INTEGER   liSeek;
    ULARGE_INTEGER  uli;
    ULARGE_INTEGER  uliSetSize;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChangeStreamData"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTRIN(pStatStg, STATSTG) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pStatStg);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    if(S_OK == hr)
    {
        // Convert WCHAR to TCHAR

        hr = OleStringToTString(pStatStg->pwcsName, &ptszName);

        DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
    }

    if(S_OK == hr)
    {
        // Convert TCHAR to OLECHAR

        hr = TStringToOleString(ptszName, &poszName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Open the stream if it is not open

    if(S_OK == hr)
    {
        hr = pIStorage->OpenStream(
                poszName,
                NULL, 
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                0,
                &pIStream);

        DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
    }

    // Seek to end of stream and get its size

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        //  Position the stream header to the postion from begining

        hr = pIStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulStreamOffset = ULIGetLow(uli);
    }

    // Generate size and direction of change.  Magnitude is 1- SHRT_MAX bytes
    // or 1 - streamsize if SHRT_MAX is greater than stream size. 50 % of time,
    // direction will be positive, and rest times negative.

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&lOffset, 1, SHRT_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if((S_OK == hr) && ((ULONG) lOffset > ulStreamOffset))
    {
        usErr = pdgi->Generate(&lOffset, 1, ulStreamOffset);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cSign, 1, 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        if(S_OK == hr) 
        {
            cSign = (cSign == 1) ? 1 : -1;
        }
    }

    // Generate Random number to do wither a SetSize or Seek/Write operation 
    // to change stream data

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cRandomVar, 1, 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        switch (cRandomVar)
        {
            case 1:
            {
                ulStreamOffset = ulStreamOffset + (lOffset * cSign);

                ULISet32(uliSetSize, ulStreamOffset);

                hr = pIStream->SetSize(uliSetSize);

                break;
            }
            case 2:
            {

                // Seek either beyond or before the curretn seek position and
                // write a random number of bytes from there.

                LISet32(liSeek, lOffset*cSign);

                hr = pIStream->Seek(liSeek, STREAM_SEEK_CUR, &uli);

                if(S_OK == hr)
                {
                    hr = GenerateRandomName(pdgu, 1, SHRT_MAX, &ptszNewData);

                    DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
                }

                if(S_OK == hr)
                {
                    // Convert ptcsName to OLECHAR

                    hr = TStringToOleString(ptszNewData, &poszNewData);

                    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
                }

                if(S_OK == hr)
                {
                    hr = pIStream->Write(poszNewData, cb, &culWritten);
            
                    DH_HRCHECK(hr, TEXT("VirtualStmNode::Write")) ;
                }
        
                break;
            }
        } 
    }

    // Close the stream

    if(S_OK == hr)
    {
        ulRef = pIStream->Release();
        DH_ASSERT(0 == ulRef);
        pIStream = NULL;
    }

    // Clean up

    if(NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    if(NULL != poszName)
    {
        delete poszName;
        poszName = NULL;
    }

    if(NULL != ptszNewData)
    {
        delete ptszNewData;
        ptszNewData = NULL;
    }

    if(NULL != poszNewData)
    {
        delete poszNewData;
        poszNewData = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: ChangeExistingObject 
//
// Synopsis: Randomly destorys/renames a stream or storage object in a DocFile.
//           Randomly changes data of object if it is a stream.  This impl.
//           is for case when it a storage object that needs to be changed 
//
// Arguments: [pIStorage] - Pointer to parent storage
//            [pStatStg] - Pointer to STATSTG structure 
//            [pdgi] - Pointer to data generator integer object
//            [pdgu] - Pointer to data generator unicode object
//            [fStgDeleted] - Out value to indicate storage is deleted
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
//----------------------------------------------------------------------------

HRESULT ChangeExistingObject(
    LPSTORAGE       pIStorage,
    STATSTG         *pStatStg,
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu,
    BOOL            *pfStgDeleted)
{
    HRESULT         hr              =   S_OK;
    USHORT          usErr           =   0;
    UINT            cRandomAction   =   0;
    LPTSTR          ptszNewName     =   NULL;
    LPOLESTR        poszNewName     =   NULL;
    LPTSTR          ptszName        =   NULL;
    LPOLESTR        poszName        =   NULL;
    LPSTORAGE       pIStorageRenamed=   NULL;
    LPMALLOC        pMalloc         =   NULL;
    ULONG           ulRef           =   0;
    BOOL            fRenamed        =   FALSE;
    STATSTG         statStgRenamed;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChangeExistingObject"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTRIN(pStatStg, STATSTG) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pStatStg);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    if(S_OK == hr)
    {
        // Convert WCHAR to TCHAR

        hr = OleStringToTString(pStatStg->pwcsName, &ptszName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert TCHAR to OLECHAR

        hr = TStringToOleString(ptszName, &poszName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }


    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cRandomAction, 1, 3);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        switch (cRandomAction)
        {
            case 1:
            {
                hr = pIStorage->DestroyElement(poszName);

                DH_HRCHECK(hr, TEXT("IStorage::DestoryElement")) ;

                if(S_OK == hr)
                {
                    *pfStgDeleted = TRUE;
                }

                if (S_OK != hr)
                {    
                    DH_LOG((
                        LOG_INFO,
                        TEXT("IStorage::DestroyElement failed, hr=0x%lx.\n"),
                        hr));
                }
                break;
            }
            case 2:
            case 3:
            {
                // Generate random new name

                hr = GenerateRandomName(
                        pdgu,
                        MINLENGTH,
                        MAXLENGTH,
                        &ptszNewName);

                if(S_OK == hr)
                {
                    // Convert TCHAR to OLECHAR

                    hr = TStringToOleString(ptszNewName, &poszNewName);

                    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
                }

                if(S_OK == hr)
                {
                    hr = pIStorage->RenameElement(
                            poszName,
                            poszNewName);

                    DH_HRCHECK(hr, TEXT("IStorage::Rename")) ;

                    if (S_OK != hr)
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("IStorage::RenameElem failed, hr=0x%lx.\n"),
                            hr));
                    }
                }
            
                if(S_OK == hr)
                {
                    fRenamed = TRUE; 
                }

                break;
            }
            case 4:
            case 5:
            case 6:
            {
                hr = ChangeStreamData(pIStorage, pStatStg, pdgi, pdgu);

                DH_HRCHECK(hr, TEXT("ChangeStreamData")) ;
 
                break;
            }
        }
    }

// ----------- flatfile change ---------------
    if( StorageIsFlat() && 
        (0 == _wcsicmp(poszName, L"CONTENTS")) &&
        (STG_E_ACCESSDENIED == hr))
    {
        DH_LOG((
            LOG_INFO,
            TEXT("ChangeExistingObject on %ws failed as exp, hr=0x%lx.\n"),
            pStatStg->pwcsName,
            hr));
        hr = S_OK; 
    }
// ----------- flatfile change ---------------

    if((S_OK == hr)         &&
       (TRUE == fRenamed)   &&
       (STGTY_STORAGE == pStatStg->type))
    {
        // Get pMalloc to free pwcsName of STATSTG struct.

        if ( S_OK == hr )
        {
            hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

            DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
        }
    
        // Free the pStatStg->pwcsName

        if((S_OK == hr) && (NULL != pStatStg->pwcsName))
        {
            pMalloc->Free(pStatStg->pwcsName);
            pStatStg->pwcsName = NULL;
        }

        // Open the storage and stat it, copy name and close it.

        if(S_OK == hr)
        {
            hr = pIStorage->OpenStorage(
                    poszNewName,
                    NULL,
                    STGM_SHARE_EXCLUSIVE | STGM_READ,
                    NULL,
                    0,
                    &pIStorageRenamed);

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::OpenStorage failed, hr=0x%lx.\n"),
                    hr));
            }
        }

        if(S_OK == hr)
        {
            hr = pIStorageRenamed->Stat(&statStgRenamed, STATFLAG_DEFAULT);

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::Stat failed, hr=0x%lx.\n"),
                    hr));
            }
        }

        if(S_OK == hr)
        {
            pStatStg->pwcsName = statStgRenamed.pwcsName;
        }

        if(S_OK == hr)
        {
            ulRef = pIStorageRenamed->Release();
            DH_ASSERT(0 == ulRef);
            pIStorageRenamed = NULL;
        }
    }

    // Clean up
    
    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }
 
    if(NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    if(NULL != poszName)
    {
        delete poszName;
        poszName = NULL;
    }

    if(NULL != ptszNewName)
    {
        delete ptszNewName;
        ptszNewName = NULL;
    }

    if(NULL != poszNewName)
    {
        delete poszNewName;
        poszNewName = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: EnumerateAndProcessIStorage 
//
// Synopsis: Iterates through a  supplied IStorage, recursing and changing
//           objects.
//
// Arguments: [pVirtualDF] - Pointer to VirtualDF tree.
//            [pvcn] - Pointer to VirtualCtrNode
//            [pdgi] - Pointer to data generator integer object
//            [pdgu] - Pointer to data generator unicode object
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
// Notes:   The VirtualDF tree is not used in this function, because of over
//          head of maintaining the tree as in several recursions of the
//          DocFile, there will be several random reverts and commits.
//----------------------------------------------------------------------------

HRESULT EnumerateAndProcessIStorage(
    LPSTORAGE       pIStorage,
    DWORD           dwStgMode,
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu)
{
    HRESULT         hr              =   S_OK;
    USHORT          usErr           =   0;
    LPSTORAGE       pIStorageChild  =   NULL;
    LPMALLOC        pMalloc         =   NULL;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL; 
    BOOL            fStorageDeleted =   FALSE;
    BOOL            fCommit         =   FALSE;
    UINT            cRandomAction   =   0;
    ULONG           ulRef           =   0;
    static  USHORT  usNumElementEnum=   0;
    LPTSTR          ptszName        =   NULL;
    LPOLESTR        poszName        =   NULL;
    STATSTG         statStg;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("EnumerateAndProcessIStorage"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    if(S_OK == hr)
    {
        // Get enumerator

        hr = pIStorage->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    if (S_OK != hr)
    {
        DH_LOG((
           LOG_INFO,
           TEXT("IStorage::EnumElements unsuccessful, hr=0x%lx.\n"),
           hr));
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Stat on passed storage

    if(S_OK == hr)
    {
        hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);

        DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_LOG((
           LOG_INFO,
           TEXT("IStorage::Stat unsuccessful, hr=0x%lx.\n"),
           hr));
    }

    // Free the statStg.pwcsName

    if(NULL != statStg.pwcsName)
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    // Loop to get next element

    while((S_OK == lpEnumStatStg->Next(1, &statStg, NULL)) &&
          (S_OK == hr))
    {
        // approx 10% chance of changing an element

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(&cRandomAction, 1, 10);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if((S_OK == hr) && (cRandomAction == 1))
        {
            hr = ChangeExistingObject(
                    pIStorage, 
                    &statStg, 
                    pdgi, 
                    pdgu, 
                    &fStorageDeleted);

            DH_HRCHECK(hr, TEXT("ChangeExistingObject")) ;

            fCommit = TRUE;

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("ChangeExistingObject unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }

        // every 1 to 64 objects enumerated, create a new object in current 
        // storage

        if((S_OK == hr) && (0 == usNumElementEnum--))
        {
            usErr = pdgi->Generate(&usNumElementEnum, 1, 64);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        
            if(S_OK == hr)
            {
                hr = CreateNewObject(pIStorage, dwStgMode, pdgi, pdgu);

                DH_HRCHECK(hr, TEXT("CreateNewObject")) ;

                fCommit = TRUE;
            }

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("CreateNewObject unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }

        // Randomly commit the storage 50 % of time if it is not deleted

        if((S_OK == hr) && (TRUE == fCommit))
        {
            usErr = pdgi->Generate(&cRandomAction, 1, 2);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }

            if((S_OK == hr) && (cRandomAction == 1))
            {
                // Commit

                hr = pIStorage->Commit(STGC_DEFAULT);

                // Reset variable
            
                fCommit = FALSE;
            }

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::Commit unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }

        // if current storage is an IStorage and it wasn't deleted, then
        // recurse into it and process it.

        if((S_OK == hr)                     && 
           (STGTY_STORAGE == statStg.type)  && 
           (FALSE == fStorageDeleted))
        {
            // Convert WCHAR to TCHAR

            hr = OleStringToTString(statStg.pwcsName, &ptszName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

            if(S_OK == hr)
            {
                // Convert TCHAR to OLECHAR

                hr = TStringToOleString(ptszName, &poszName);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                // Open storage

                hr = pIStorage->OpenStorage(
                    poszName,
                    NULL, 
                    dwStgMode, 
                    NULL, 
                    0,
                    &pIStorageChild);

                if (S_OK != hr)
                {
                    DH_LOG((
                        LOG_INFO,
                        TEXT("IStorage::OpenStorage unsuccessful, hr=0x%lx.\n"),
                        hr));
                }
            }

            if(S_OK == hr)
            {
                // Recurse into child storage and process it recursively.

                hr = EnumerateAndProcessIStorage(
                        pIStorageChild, 
                        dwStgMode, 
                        pdgi, 
                        pdgu);

                if (S_OK != hr)
                {
                    DH_LOG((
                        LOG_INFO,
                        TEXT("EnumerateAndProcessIStorage failed, hr=0x%lx.\n"),
                        hr));
                }
            }

            // Close the storage

            if(S_OK == hr)
            {
                ulRef = pIStorageChild->Release();
                DH_ASSERT(0 == ulRef);
                pIStorageChild = NULL;
            }
        }
        
        // Free the statStg.pwcsName

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszName)
        {
            delete ptszName;
            ptszName = NULL;
        }

        if(NULL != poszName)
        {
            delete poszName;
            poszName = NULL;
        }

        // Reset variables

        fStorageDeleted = FALSE;
    }

    // Randomly commit changes

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cRandomAction, 0, 3);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        if(0 != cRandomAction)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::Commit unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }
        else
        {
            hr = pIStorage->Revert();

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::Revert unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }
    }

    // Cleanup
   
    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }
 
    return hr;
}

//  Function:   IsEqualStream
//
//  Synopsis:   Determines whether the two streams passed as arguments
//              are identical in length and content.
//
//  Arguments:  [pIOrigional]  -  Origional Stream
//              [pICompare]    -  The stream to compare with Origional 
//                                Stream 
//
//  Returns:    HRESULT
//
//  History:    July 31, 1996       T-Scottg        Created
//
//  Note:       Although a more elegent solution can be created using
//              CRCs, this particular implementation has been designed
//              so that it better tests the HGLOBAL implementation
//              of IStream
//
//+-------------------------------------------------------------------------

HRESULT IsEqualStream(IStream * pIOrigional, IStream * pICompare) 
{
    HRESULT             hr              =   S_OK;
    BYTE *              pbOrigionalBuf  =   NULL;
    BYTE *              pbCompareBuf    =   NULL;
    STATSTG             statOrigional;  
    STATSTG             statCompare;
    LARGE_INTEGER       liSeek;


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("IsEqualStream"));

    DH_VDATEPTRIN(pIOrigional, IStream *);
    DH_VDATEPTRIN(pICompare, IStream *);

    DH_ASSERT(NULL != pIOrigional);
    DH_ASSERT(NULL != pICompare);


    // Note: STATFLAG_NONAME is passed to IStream::Stat(...).  
    // This requests that the statistics not include the pwcsName member 
    // of the STATSTG structure. Hence, there is no need for pwcsName to
    // be freed after use.


    if (S_OK == hr) 
    {
        hr = pIOrigional->Stat(&statOrigional, STATFLAG_NONAME);
        DH_HRCHECK(hr, TEXT("IsEqualStream: pIOrigional->Stat Failure"));
    }

    if (S_OK == hr) 
    {
        hr = pICompare->Stat(&statCompare, STATFLAG_NONAME);
        DH_HRCHECK(hr, TEXT("IsEqualStream: pICompare->Stat Failure"));
    }


    // If the size of the two streams is not equal, then the streams
    // can't be equal.  

    if (S_OK == hr) 
    {
        if (statOrigional.cbSize.LowPart != statCompare.cbSize.LowPart) 
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("Stream Sizes Not Equal"));
        }
    }


    // Allocate buffer to hold the stream contents

    if (S_OK == hr) 
    {
        pbOrigionalBuf = new BYTE [statOrigional.cbSize.LowPart];

        if (NULL == pbOrigionalBuf) 
        {    
            hr = E_OUTOFMEMORY;
        }

        DH_HRCHECK(hr, TEXT("IsEqualStream: new pbOrigionalBuf failed"));
    }

    
    // Initialize Buffer

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pbOrigionalBuf);

        memset(pbOrigionalBuf, '\0', statOrigional.cbSize.LowPart);
    }


    // Allocate buffer to hold the stream contents

    if (S_OK == hr) 
    {
        pbCompareBuf = new BYTE [statCompare.cbSize.LowPart];
                
        if (NULL == pbCompareBuf) 
        {
            hr = E_OUTOFMEMORY;
        }

        DH_HRCHECK(hr, TEXT("IsEqualStream: new pbCompareBuf failed"));
    }


    // Initialize Buffer

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pbOrigionalBuf);

        memset(pbOrigionalBuf, '\0', statOrigional.cbSize.LowPart);
    }


    // Set Origional Seek pointer back to beginning of stream

    if (S_OK == hr)
    {
        LISet32(liSeek, 0);

        hr = pIOrigional->Seek(liSeek, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Seek Failed"));
    }


    // Set Compare Seek pointer back to beginning of stream

    if (S_OK == hr)
    {
        LISet32(liSeek, 0);

        hr = pICompare->Seek(liSeek, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Seek Failed"));
    }

        
    // Read pIOrigional Stream data into buffer.  

    if (S_OK == hr)
    {
        hr = pIOrigional->Read( pbOrigionalBuf, 
                                statOrigional.cbSize.LowPart, 
                                NULL );

        DH_HRCHECK(hr, TEXT("IsEqualStream: pIOrigional->Read Failure"));
    }


    // Read pICompare Stream data into buffer.  

    if (S_OK == hr) 
    {
        hr = pICompare->Read( pbCompareBuf, 
                              statCompare.cbSize.LowPart, 
                              NULL );

        DH_HRCHECK(hr, TEXT("IsEqualStream: pICompare->Read Failure"));
    }


    // Compare memory buffers.  If they are not equal, set hr to S_FALSE;

    if (S_OK == hr)
    {
        if (0 != memcmp( pbOrigionalBuf, 
                         pbCompareBuf, 
                         statOrigional.cbSize.LowPart )) 
        {               
            hr = S_FALSE;
        }

        DH_HRCHECK(hr, TEXT("Buffer data not equal"));
    }


    // Cleanup dynamic memory

    if (NULL != pbOrigionalBuf)
    {
        delete [] pbOrigionalBuf;
        pbOrigionalBuf = NULL;
    }


    if (NULL != pbCompareBuf) 
    {
        delete [] pbCompareBuf;
        pbCompareBuf = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("IsEqualStream Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:  ILockBytesWriteTest
//
//  Synopsis:  Writes data to the provided ILockBytes (calling 
//             ILockBytes::Flush in between writes).  When all data
//             is written, the function verifies that the ILockBytes
//             is of the correct length.
//
//  Arguments: [pILockBytes]  - ILockBytes to Write Data to
//             [dwSeed]       - Seed to Randomizer
//             [dwSize]       - Byte count of data to write to ILockBytes
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
//+-------------------------------------------------------------------------

HRESULT ILockBytesWriteTest ( ILockBytes *  pILockBytes, 
                              DWORD         dwSeed, 
                              DWORD         dwSize )
{
    HRESULT             hr              =       S_OK;
    CHAR *              pbBuffer        =       NULL;    
    DWORD               dwWritten       =       0;
    DWORD               dwIdx           =       0;
    ULARGE_INTEGER      li;
    STATSTG             LockBytesStat;
    DG_ASCII            dga(dwSeed);


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("ILockBytesWriteTest"));

    DH_VDATEPTRIN(pILockBytes, ILockBytes *);
    DH_ASSERT(NULL != pILockBytes);


    // Create Data Buffer with Random Data in It

    if (0 != (dga.Generate( &pbBuffer, 
                            DG_APRINT_MIN, 
                            DG_APRINT_MAX,  
                            dwSize,
                            dwSize )))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
    }


    // Write Data into ILockBytes

    if (S_OK == hr)
    {
        for (dwIdx = 0; (dwIdx + HGLOBAL_PACKET_SIZE) <= dwSize; dwIdx += HGLOBAL_PACKET_SIZE)
        {

            ULISet32(li, dwIdx);

            hr = pILockBytes->WriteAt( li,
                                       pbBuffer,
                                       HGLOBAL_PACKET_SIZE,
                                       &dwWritten );

            DH_HRCHECK(hr, TEXT("pILockBytes->WriteAt Failed"));

            
            // Verify that all of the data was written

            if ((S_OK == hr) && (HGLOBAL_PACKET_SIZE != dwWritten))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("Written Data length mismatch"));
            }

            
            // Flush ILockBytes to Memory

            if (S_OK == hr)
            {
                hr = pILockBytes->Flush();
                DH_HRCHECK(hr, TEXT("pILockBytes->Flush Failed"));
            }


            // Break out of loop if error occurs

            if (S_OK != hr)
            {
                break;
            }
        }
    }

    
    // Obtain STATSTG structure from ILockBytes

    if (S_OK == hr)
    {
        hr = pILockBytes->Stat( &LockBytesStat, 
                                STATFLAG_NONAME );

        DH_HRCHECK(hr, TEXT("pILockBytes->Stat Failed"));
    }


    // Verify that the ILockBytes is of the correct length

    if (S_OK == hr)
    {
        if (LockBytesStat.cbSize.LowPart != dwSize)
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("ILockBytes not of correct length"));
        }
    }


    // Free dynamic memory

    if (NULL != pbBuffer)
    {
        delete [] pbBuffer;
        pbBuffer = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("ILockBytesWriteTest Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:  ILockBytesReadTest
//
//  Synopsis:  Reads data from the provided ILockBytes
//
//  Arguments: [pILockBytes]  - ILockBytes to Read Data from
//             [dwSize]       - Byte count of data to read from ILockBytes
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
//+-------------------------------------------------------------------------

HRESULT ILockBytesReadTest (ILockBytes * pILockBytes, DWORD dwSize)
{
    HRESULT             hr              =       S_OK;
    BYTE *              pbBuffer        =       NULL;    
    DWORD               dwRead          =       0;
    DWORD               dwIndex         =       0;
    ULARGE_INTEGER      li;


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("ILockBytesReadTest"));

    DH_VDATEPTRIN(pILockBytes, ILockBytes *);
    DH_ASSERT(NULL != pILockBytes);


    // Create buffer to hold data

    if (S_OK == hr)
    {
        pbBuffer = new BYTE[HGLOBAL_PACKET_SIZE];

        if (NULL == pbBuffer)
        {
            hr = E_OUTOFMEMORY;
        }

        DH_HRCHECK(hr, TEXT("new BYTE call failed"));
    }


    // Initialize Buffer

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pbBuffer);

        memset(pbBuffer, '\0', HGLOBAL_PACKET_SIZE);
    }


    // Read Data from ILockBytes

    if (S_OK == hr)
    {
        for (dwIndex = 0; (dwIndex+HGLOBAL_PACKET_SIZE) <= dwSize; dwIndex+=HGLOBAL_PACKET_SIZE)
        {

            ULISet32(li, dwIndex);

            hr = pILockBytes->ReadAt( li,
                                      pbBuffer,
                                      HGLOBAL_PACKET_SIZE,
                                      &dwRead );

            DH_HRCHECK(hr, TEXT("pILockBytes->ReadAt Failed"));

            
            // Verify that all of the data was written

            if ((S_OK == hr) && (HGLOBAL_PACKET_SIZE != dwRead))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("Read Data length mismatch"));
            }


            // Break out of loop if error occurs

            if (S_OK != hr)
            {
                break;
            }
        }
    }

    
    // Free dynamic memory

    if (NULL != pbBuffer)
    {
        delete [] pbBuffer;
        pbBuffer = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("ILockBytesReadTest Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:  IStreamWriteTest
//
//  Synopsis:  Writes data to the provided IStream
//
//  Arguments: [pIStream]     - IStream to Write Data to
//             [dwSize]       - Byte count of data to write to IStream
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
//+-------------------------------------------------------------------------

HRESULT IStreamWriteTest ( IStream *    pIStream, 
                           DWORD        dwSeed,
                           DWORD        dwSize )
{
    HRESULT             hr              =       S_OK;
    CHAR *              pbBuffer        =       NULL;    
    DWORD               dwWritten       =       0;
    DWORD               dwIndex         =       0;
    LARGE_INTEGER       li;
    STATSTG             StreamStat;
    DG_ASCII            dga(dwSeed);


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("IStreamWriteTest"));

    DH_VDATEPTRIN(pIStream, IStream *);
    DH_ASSERT(NULL != pIStream);


    // Create Data Buffer with Random Data in It

    if (0 != (dga.Generate( &pbBuffer, 
                            DG_APRINT_MIN, 
                            DG_APRINT_MAX,  
                            dwSize,
                            dwSize )))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
    }


    // Write Data into IStream

    if (S_OK == hr)
    {
        for (dwIndex = 0; (dwIndex+HGLOBAL_PACKET_SIZE) <= dwSize; dwIndex+=HGLOBAL_PACKET_SIZE)
        {
        
            // Assign seek index to Large Integer Structure

            LISet32(li, dwIndex);


            // Seek to correct position in stream

            if (S_OK == hr)
            {
                hr = pIStream->Seek( li,
                                     STREAM_SEEK_SET,
                                     NULL );

                DH_HRCHECK(hr, TEXT("pIStream->Seek Failed"));
            }


            // Write Data to stream

            if (S_OK == hr)
            {
                hr = pIStream->Write( pbBuffer,
                                      HGLOBAL_PACKET_SIZE,
                                      &dwWritten );

                DH_HRCHECK(hr, TEXT("pIStream->Write Failed"));
            }

            
            // Verify that all of the data was written

            if ((S_OK == hr) && (HGLOBAL_PACKET_SIZE != dwWritten))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("Written Data length mismatch"));
            }


            // Break out of loop if error occurs

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Obtain STATSTG structure from ILockBytes

    if (S_OK == hr)
    {
        hr = pIStream->Stat( &StreamStat, 
                             STATFLAG_NONAME );

        DH_HRCHECK(hr, TEXT("pIStream->Stat Failed"));
    }


    // Verify that the IStream is of the correct length

    if (S_OK == hr)
    {
        if (StreamStat.cbSize.LowPart != dwSize)
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("IStream not of correct length"));
        }
    }

    
    // Free dynamic memory

    if (NULL != pbBuffer)
    {
        delete [] pbBuffer;
        pbBuffer = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("IStreamWriteTest Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:  IStreamReadTest
//
//  Synopsis:  Reads data from the provided IStream
//
//  Arguments: [pIStream]     - IStream to Read Data From
//             [dwSize]       - Byte count of data to read from IStream
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
//+-------------------------------------------------------------------------

HRESULT IStreamReadTest (IStream * pIStream, DWORD dwSize)
{
    HRESULT             hr              =       S_OK;
    BYTE *              pbBuffer        =       NULL;    
    DWORD               dwWritten       =       0;
    DWORD               dwIndex         =       0;
    LARGE_INTEGER       li;


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("IStreamReadTest"));

    DH_VDATEPTRIN(pIStream, IStream *);
    DH_ASSERT(NULL != pIStream);


    // Create buffer to hold data

    if (S_OK == hr)
    {
        pbBuffer = new BYTE[HGLOBAL_PACKET_SIZE];

        if (NULL == pbBuffer)
        {
            hr = E_OUTOFMEMORY;
        }

        DH_HRCHECK(hr, TEXT("new BYTE call failed"));
    }


    // Initialize Buffer

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pbBuffer);

        memset(pbBuffer, '\0', HGLOBAL_PACKET_SIZE);
    }


    // Read Data from IStream

    if (S_OK == hr)
    {
        for (dwIndex = 0; (dwIndex+HGLOBAL_PACKET_SIZE) <= dwSize; dwIndex+=HGLOBAL_PACKET_SIZE)
        {
        
            // Assign seek index to Large Integer Structure

            LISet32(li, dwIndex);


            // Seek to correct position in stream

            if (S_OK == hr)
            {
                hr = pIStream->Seek( li,
                                     STREAM_SEEK_SET,
                                     NULL );

                DH_HRCHECK(hr, TEXT("pIStream->Seek Failed"));
            }


            // Read Data from stream

            if (S_OK == hr)
            {
                hr = pIStream->Read( pbBuffer,
                                     HGLOBAL_PACKET_SIZE,
                                     &dwWritten );

                DH_HRCHECK(hr, TEXT("pIStream->Read Failed"));
            }

            
            // Verify that all of the data was written

            if ((S_OK == hr) && (HGLOBAL_PACKET_SIZE != dwWritten))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("Written Data length mismatch"));
            }


            // Break out of loop if error occurs

            if (S_OK != hr)
            {
                break;
            }
        }
    }

    
    // Free dynamic memory

    if (NULL != pbBuffer)
    {
        delete [] pbBuffer;
        pbBuffer = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("IStreamReadTest Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

//----------------------------------------------------------------------------
//
// Function: TraverseDocFileAndWriteOrReadSNB 
//
// Synopsis: Traverse DocFile one level and either writes/reads SNB
//
// Effects: Traverse the children storages and streams of root storage,
//          when fSelectObjectsToExclude == TRUE, then for each object
//          returned, there is a 50% chance that the object name will
//          be added to an SNB block of names to exclude upon reinstantiation,
//          when fIllegitFlag == TRUE, then there is a 50% change that a
//          bogus name instead of ture object name will be generated and 
//          be added into SNB block. When fSelectObjectsToExclude == FALSE, 
//          then each object name returned is checked to see if it exists in 
//          the SNB.  If an object name is returned that *is* in the SNB, 
//          that object is checked to ensure that its contents are empty.
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode
//            [pdgi] - Pointer to Data Integer object
//            [pdgu] - Pointer to Data Unicode object
//            [dwStgMode] - Access Mode for the storage
//            [snbNamesToExclude] - SNB specifying elements to be excluded
//            [fIllegitFlag] - Indicating whether it's a legit or illegit 
//                             limited test: if TRUE, it is a illegit one, 
//                             otherwise, it is a legit one.
//            [fSelectObjectsToExclude] - if TRUE, the function builds the
//                                        SNB, otherwise the function checks
//                                        names against the SNB.
//
// Returns: HResult
//
// History: 29-Jul-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT TraverseDocfileAndWriteOrReadSNB(
    VirtualCtrNode  *pvcn, 
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu,
    DWORD           dwStgMode,
    SNB             snbNamesToExclude,
    BOOL            fIllegitFlag,
    BOOL            fSelectObjectsToExclude)
{
    HRESULT         hr                  =   S_OK;
    ULONG           culRandomExclude    =   0;
    ULONG           culRandomBogus      =   0;
    ULONG           culThisName         =   0;
    ULONG           ulRef               =   0;  
    ULONG           ulStmLength         =   0;
    USHORT          usErr               =   0;
    LPTSTR          ptszStgName         =   NULL;
    LPTSTR          ptszBogusName       =   NULL;
    LPTSTR          ptszStmName         =   NULL;
    LPTSTR          pTStr               =   NULL;
    VirtualCtrNode  *pvcnTrav           =   NULL;
    VirtualStmNode  *pvsnTrav           =   NULL;
    LPENUMSTATSTG   lpEnumStatStg       =   NULL;
    STATSTG         *pstatStgEnum       =   NULL;       
    BOOL            fLocalPass          =   TRUE;
    LARGE_INTEGER   liZero;
    ULARGE_INTEGER  uli;
    SNB             snbIndex;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("TraverseDocfileAndWriteOrReadSNB"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode);
    DH_VDATEPTRIN(pdgi, DG_INTEGER);
    DH_VDATEPTRIN(pdgu, DG_STRING);
    
    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    // pointer SNB to start of global SNB

    snbIndex = snbNamesToExclude;
    
    // First traverse the child storages of the root storage

    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

    while ((S_OK == hr) && (NULL != pvcnTrav))
    {
        if (TRUE == fSelectObjectsToExclude)
        {
            // 50% chance of adding name to SNB for exclude on reinstantiation
            // when a name is added to the SNB, memory is allocated for that
            // name, the name of current VirtualCtrNode name is copied in, and
            // the SNB index is incremented to point to the location for the
            // next OLECHAR string.

            usErr = pdgi->Generate(&culRandomExclude, 1, 100);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        
            if ((S_OK == hr) && (culRandomExclude > 50))
            {
                // 50% chance of placing a bogus name in the snbExclude block

                ptszStgName = pvcnTrav->GetVirtualCtrNodeName();
                DH_ASSERT(NULL != ptszStgName);

                culThisName = _tcslen(ptszStgName);
 
                if (S_OK == hr)
                {              
                    if (TRUE == fIllegitFlag)
                    {
                        // if it is a illegit test, then 50% chance that
                        // a bogus name will generated instead of true 
                        // object name

                        usErr = pdgi->Generate(&culRandomBogus, 1, 100);

                        if (DG_RC_SUCCESS != usErr)
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        // if it is a legit test, then make sure culRandomBogus
                        // greater than 50,i.e. use the true object name

                        culRandomBogus = 100;
                    }
                }

                if (S_OK == hr) 
                {
                    if (culRandomBogus > 50)
                    {                  
                        hr = TStringToOleString(ptszStgName, snbIndex);
                        DH_HRCHECK(hr, TEXT("TStringToOleString"));
                    }
                    else
                    { 
                        hr = GenerateRandomString(
                                pdgu,
                                culThisName,
                                culThisName,
                                &ptszBogusName);
                        
                        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
                         
                        if (S_OK == hr)
                        {
                            hr = TStringToOleString(ptszBogusName, snbIndex);
                            DH_HRCHECK(hr, TEXT("TStringToOleString"));
                        }

                        if (NULL != ptszBogusName)
                        {
                            delete []ptszBogusName;
                            ptszBogusName = NULL;
                        }
                    }
                }

                snbIndex++;
            }
        }
        else
        {
            // Starting with the first entry in the SNB, loop through and
            // compare the current name of the VirtualCtrNode against
            // each name in the SNB. If there is a match, check the
            // storage and verify that its contents are empty.
             
            ptszStgName = pvcnTrav->GetVirtualCtrNodeName();
            snbIndex = snbNamesToExclude;

            hr = OleStringToTString(*snbIndex, &pTStr);
            DH_HRCHECK(hr, TEXT("OleStringToTString"));

            while ((S_OK == hr) && (*snbIndex))
            {
                if (0 == _tcscmp(pTStr, ptszStgName))
                {
                    hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
                    
                    if (S_OK == hr)
                    {
                        hr = pvcnTrav->EnumElements(0, NULL, 0, &lpEnumStatStg);
                        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements"));
                    }

                    // Allocate memory for STASTG structure

                    if (S_OK == hr)
                    {
                        pstatStgEnum = (STATSTG *) new STATSTG;

                        if (NULL == pstatStgEnum)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if (S_OK == hr)
                    {
                        if (S_OK == lpEnumStatStg->Next(1, pstatStgEnum, NULL))
                        {
                            DH_LOG((
                                LOG_INFO,
                                TEXT("Should no objects in excluded Stg.\n")));

                            fLocalPass = FALSE;
                        }
                    }

                    if (NULL != pstatStgEnum)
                    {
                        delete [] pstatStgEnum;
                        pstatStgEnum = NULL;
                    }

                    if (NULL != lpEnumStatStg)
                    {
                        ulRef = lpEnumStatStg->Release();
                        DH_ASSERT(NULL == ulRef);
                        lpEnumStatStg = NULL;
                    }

                    break;
                } 

                snbIndex++;
            }
        }        
 
        if (NULL != pTStr)
        {
            delete []pTStr;
            pTStr = NULL;
        }
        
        if ((S_OK == hr) && (TRUE == fLocalPass))
        {
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
        }
        else
        {
            break;
        }
    }

    // Now, traverse the child streams of the root storage

    pvsnTrav = pvcn->GetFirstChildVirtualStmNode();

    while ((S_OK == hr) && (TRUE == fLocalPass) && (NULL != pvsnTrav))
    {
        if (TRUE == fSelectObjectsToExclude)
        {
            // 50% chance of adding name to SNB for exclude on reinstantiation
            // when a name is added to the SNB, memory is allocated for that
            // name, the name of current VirtualStmNode name is copied in, and
            // the SNB index is incremented to point to the location for the
            // next OLECHAR string.

            usErr = pdgi->Generate(&culRandomExclude, 1, 100);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        
            if ((S_OK == hr) && (culRandomExclude > 50))
            {
                // 50% chance of placing a bogus name in the snbExclude block

                ptszStmName = pvsnTrav->GetVirtualStmNodeName();
                DH_ASSERT(NULL != ptszStmName);

                culThisName = _tcslen(ptszStmName);
 
                if (S_OK == hr)
                {              
                    if (TRUE == fIllegitFlag)
                    {
                        // if it is a illegit test, then 50% chance that
                        // a bogus name will generated instead of true 
                        // object name

                        usErr = pdgi->Generate(&culRandomBogus, 1, 100);

                        if (DG_RC_SUCCESS != usErr)
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        // if it is a legit test, then make sure culRandomBogus
                        // greater than 50,i.e. use the true object name

                        culRandomBogus = 100;
                    }
                }

                if (S_OK == hr) 
                {
                    if (culRandomBogus > 50)
                    {                  
                        hr = TStringToOleString(ptszStmName, snbIndex);
                        DH_HRCHECK(hr, TEXT("TStringToOleString"));
                    }
                    else
                    { 
                        hr = GenerateRandomString(
                                pdgu,
                                culThisName,
                                culThisName,
                                &ptszBogusName);
                        
                        DH_HRCHECK(hr, TEXT("GenerateRandomString"));

                        if (S_OK == hr)
                        {
                            hr = TStringToOleString(ptszBogusName, snbIndex);
                            DH_HRCHECK(hr, TEXT("TStringToOleString"));
                        }
 
                        if (NULL != ptszBogusName)
                        {
                            delete []ptszBogusName;
                            ptszBogusName = NULL;
                        } 
                    }
                }

                snbIndex++;
            }
        }
        else
        {
            // Starting with the first entry in the SNB, loop through and
            // compare the current name of the VirtualStmNode against
            // each name in the SNB. If there is a match, check the
            // stream and verify that its length is zero.
             
            snbIndex = snbNamesToExclude;
            ptszStmName = pvsnTrav->GetVirtualStmNodeName();

            hr = OleStringToTString(*snbIndex, &pTStr);
            DH_HRCHECK(hr, TEXT("OleStringToTString"));

            while ((S_OK == hr) && (*snbIndex))
            {
                if (0 == _tcscmp(pTStr, ptszStmName))
                {
                    LISet32(liZero, 0L);
                    
                    hr = pvsnTrav->Open(
                            NULL, 
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                            0);

                    DH_HRCHECK(hr, TEXT("VirutalStmNode::Open"));

                    if (S_OK == hr)
                    {            
                        hr = pvsnTrav->Seek(liZero, STREAM_SEEK_END, &uli);
                        ulStmLength = ULIGetLow(uli);

                        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
                    }
                
                    if (S_OK != hr)
                    { 
                        DH_LOG((
                            LOG_INFO,
                            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx\n"),
                            hr));
                    }

                    if (0 != ulStmLength)                    
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("The length of excluded Stm should be 0.\n")));

                        fLocalPass = FALSE;
                    }

                    break;
                } 

                snbIndex++;
            }
        }        

        if (NULL != pTStr)
        {
            delete []pTStr;
            pTStr = NULL;
        }
        
        if ((S_OK == hr) && (TRUE == fLocalPass))
        {
            pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
        }
        else
        {
            break;
        }
    }

    if ((S_OK == hr) && (TRUE == fSelectObjectsToExclude))
    {
        // Last entry in SNB block is NIL to designate the end

        *snbIndex = NULL;
    }
    
    if (FALSE == fLocalPass)
    {
        hr = E_FAIL;
    }

    return hr;
}

 
//----------------------------------------------------------------------------
//
// Function: GetSeedFromCmdLineArgs 
//
// Synopsis: Gets the seed value from command line args if required for test 
//
// Arguments: [argc] - arg count
//            [argv] - arg list
//
// Returns: ULONG 
//
// History: 2-Aug-1996   Narindk   Made into separate func. 
//
//-----------------------------------------------------------------------------

ULONG GetSeedFromCmdLineArgs(int argc, char *argv[])
{
    HRESULT             hr      = S_OK ;
    ULONG               ulSeed  = 0;
    CCmdline            CCmdlineArgs(argc, argv);
    CUlongCmdlineObj    Seed(OLESTR("seed"), OLESTR(""), OLESTR("0")) ;
    CBaseCmdlineObj     *CArgList[] = {&Seed} ;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetSeedFromCmdLineArgs"));

    // Verify that the CCmdlineArgs object was constructed without
    // problems

    if (CMDLINE_NO_ERROR != CCmdlineArgs.QueryError()) 
    {   
        hr = E_FAIL ;
    }

    // Parse Commandline Arguments 

    if (S_OK == hr) 
    {
        if (CMDLINE_NO_ERROR != CCmdlineArgs.Parse(CArgList,
                                    sizeof(CArgList) / sizeof(CArgList[0]),
                                    FALSE) ) 
        {
            hr = E_FAIL ;
        }
    }

    // Obtain Seed from CommandLine

    if (S_OK == hr) 
    {
        if ( ulSeed != *(Seed.GetValue()) ) 
        {
            ulSeed = *(Seed.GetValue());
        }
    }

    return ulSeed; 
}


//----------------------------------------------------------------------------
//
// Function: StreamCreate
//
// Synopsis: Create a stream or a file in a docfile or C-runtime condition,
//           and record the time of creation in both cases: the stream or
//           file existing and not existing.
//
// Arguments: [dwRootMode] - Access modes to root storage
//            [pdgu] - Pointer to Data Unicode object
//            [usTimeIndex] - Indicate which category this test is
//            [dwFlags] - Indicate DOCFILE or RUNTIME file and also 
//                        the stream or file exists or not
//            [usNumCreates] - Indicate this is usNumCreates'th creation
//
// Returns: HResult
//
// History: 8-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT StreamCreate(
    DWORD       dwRootMode,
    DG_STRING  *pdgu,
    USHORT      usTimeIndex, 
    DWORD       dwFlags, 
    USHORT      usNumCreates)
{
    HRESULT     hr              = S_OK; 
    LPSTORAGE   pstgRoot        = NULL;
    LPSTREAM    pstmStream      = NULL;
    LPOLESTR    pOleName        = NULL;
    ULONG       bufferSize      = 0;
    FILE        *fileFile       = NULL;
    DWORD       StartTime       = 0;
    DWORD       EndTime         = 0;
    DWORD       dwModifiers     = 0;
    ULONG       ulRef           = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("StreamCreate"));
    
    DH_VDATEPTRIN(pdgu, DG_STRING);

    DH_ASSERT(NULL != pdgu);

    while ((S_OK == hr) && (0 < usNumCreates))
    {
        usNumCreates--;

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszNames[0]);

        DH_HRCHECK(hr, TEXT("GenerateRandomName"));

        if ((S_OK == hr) && (dwFlags & DOCFILE))
        {
            // Create a docfile
            
            hr = TStringToOleString(ptszNames[0], &pOleName);
            DH_HRCHECK(hr, TEXT("TStringToOleString"));

            if (S_OK == hr)
            {
                hr = StgCreateDocfile(
                        pOleName,
                        dwRootMode | STGM_CREATE,
                        0,
                        &pstgRoot);

                DH_HRCHECK(hr, TEXT("StgCreateDocfile"));
            }
        }

        if ((S_OK == hr) && (dwFlags & EXIST))
        {
            dwFlags |= CREATE;

            if (dwFlags & DOCFILE)
            {
                // Create existing stream

                if (S_OK == hr)
                {
                    hr = pstgRoot->CreateStream(
                            pOleName,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                            0,
                            0,
                            &pstmStream);
                    
                    DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
                }

                if (S_OK == hr)
                {
                    ulRef = pstmStream->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream = NULL;
                }
            }
            else
            {

#if  (defined _NT1X_ && !defined _MAC)
                // Create existing file
                
                fileFile = _wfopen(ptszNames[0],TEXT("w"));

                if (NULL == fileFile)
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                }                

#else
                fileFile = fopen(ptszNames[0],"w");

                if (NULL == fileFile)
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;                   
                }
#endif
                if (S_OK == hr)
                {
                    fclose(fileFile);
                }
            }
        }

        if (S_OK == hr)
        {
            dwModifiers |= (dwFlags & CREATE ? STGM_CREATE : STGM_FAILIFTHERE);

            if (dwFlags & DOCFILE)
            {                
                if (S_OK == hr)
                {
                    GET_TIME(StartTime);

                    hr = pstgRoot->CreateStream(
                            pOleName,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE | dwModifiers,
                            0,
                            0,
                            &pstmStream);
                    
                    GET_TIME(EndTime);
                    
                    Time[usTimeIndex].plDocfileTime[usNumCreates] = 
                        DiffTime(EndTime, StartTime);
                    
                    DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
                }
 
                if ((S_OK == hr) && (dwFlags & COMMIT))
                {
                    hr = pstgRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                }

                if (S_OK == hr)
                {
                    ulRef = pstmStream->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream = NULL;

                    ulRef = pstgRoot->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot = NULL;
                }

                if (NULL != pOleName)
                {
                    delete []pOleName;
                    pOleName = NULL;
                }

            }
            else
            {
#if (defined _NT1X_ && !defined _MAC)
                GET_TIME(StartTime);
                fileFile = _wfopen(ptszNames[0], TEXT("w+b"));
                GET_TIME(EndTime);
#else
                GET_TIME(StartTime);                
                fileFile = fopen(ptszNames[0], "w+b");
                GET_TIME(EndTime);
#endif
                Time[usTimeIndex].plRuntimeTime[usNumCreates] = 
                    DiffTime(EndTime,StartTime);

                if (NULL == fileFile)
                {      
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    hr = E_FAIL;
                }

                if (S_OK == hr)
                {
                    fclose(fileFile);
                }
            }
        }

        if (NULL != ptszNames[0])
        {
            if(FALSE == DeleteFile(ptszNames[0]))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;

                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
        }

        if (NULL != ptszNames[0])
        {
            delete []ptszNames[0];
            ptszNames[0] = NULL;
        }
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// Function: DocfileCreate
//
// Synopsis: Create a docfile is similar to creating a directory in C-runtime,
//           this test measures the time in several cases of creating a docfile, 
//           like create a existing or non-exist or NULL docfile. RUNTIME only 
//           support creating a non-exist directory.
//
// Arguments: [dwRootMode] - Access modes to root storage
//            [pdgu] - Pointer to Data Unicode object
//            [usTimeIndex] - Indicate which category this test is
//            [dwFlags] - Indicate DOCFILE or RUNTIME file and also 
//                        the stream or file exists or not
//            [usNumCreates] - Indicate this is usNumCreates'th creation
//
// Returns: HResult
//
// History: 6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT DocfileCreate(
    DWORD       dwRootMode,
    DG_STRING  *pdgu,
    USHORT      usTimeIndex, 
    DWORD       dwFlags, 
    USHORT      usNumCreates)
{
    HRESULT     hr              = S_OK; 
    LPSTORAGE   pstgRoot        = NULL;
    LPSTREAM    pstmStream      = NULL;
    LPOLESTR    pOleName        = NULL;
    LPTSTR      ptTmpName       = NULL;
    LPTSTR      ptszCurDir      = NULL;
    int         Temp            = 0;      
    ULONG       bufferSize      = 0;
    DWORD       StartTime       = 0;
    DWORD       EndTime         = 0;
    DWORD       dwModifiers     = 0;
    ULONG       ulRef           = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DocfileCreate"));
    
    DH_VDATEPTRIN(pdgu, DG_STRING);

    DH_ASSERT(NULL != pdgu);
 
    while ((S_OK == hr) && (0 < usNumCreates))
    {
        usNumCreates--;

        if ((dwFlags & DOCFILE) && (dwFlags & NONAME))
        {
            ptszNames[0] = NULL;
        }
        else
        {
            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &ptszNames[0]);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")); 

            if (S_OK == hr)
            {
                hr = TStringToOleString(ptszNames[0], &pOleName);
                DH_HRCHECK(hr, TEXT("TStringToOleString"));
            }
        }

        if ((S_OK == hr) && (dwFlags & DOCFILE) && (dwFlags & EXIST)
                && ~(dwFlags & NONAME))
        {
            // Create a existing docfile
         
            dwFlags |= CREATE;

            hr = StgCreateDocfile(
                    pOleName,
                    dwRootMode | STGM_CREATE,
                    0,
                    &pstgRoot);

            DH_HRCHECK(hr, TEXT("StgCreateDocfile"));       

            if (S_OK == hr)
            {
                ulRef = pstgRoot->Release();
                DH_ASSERT(0 == ulRef);
                pstgRoot = NULL;
            }
        }

        if (S_OK == hr)
        {
            dwModifiers |= (dwFlags & CREATE ? STGM_CREATE : STGM_FAILIFTHERE);

            if (dwFlags & DOCFILE)
            {
                GET_TIME(StartTime);

                hr = StgCreateDocfile(
                        pOleName,
                        dwRootMode | dwModifiers,
                        0,
                        &pstgRoot);

                GET_TIME(EndTime);
                
                Time[usTimeIndex].plDocfileTime[usNumCreates] = 
                    DiffTime(EndTime, StartTime);

                DH_HRCHECK(hr, TEXT("StgCreateDocfile"));

                if ((S_OK == hr) && (dwFlags & COMMIT))
                {
                    hr = pstgRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                }

                // if NONAME, we need to get the name so we can
                // delete the file when we are done.
                if (S_OK == hr && (dwFlags & NONAME))
                {
                    STATSTG statstg;
                    hr = pstgRoot->Stat (&statstg, STATFLAG_DEFAULT);
                    DH_HRCHECK (hr, TEXT("IStorage::Stat"));

                    if (S_OK == hr)
                    {
                        //retrieve the filename
                        OleStringToTString (statstg.pwcsName, &ptTmpName);
                        DH_HRCHECK (hr, TEXT("OleStringToTString"));

                        //now that we have the name, it up from statstg
                        CoTaskMemFree (statstg.pwcsName);
                    }
                }

                if (S_OK == hr)
                {
                    ulRef = pstgRoot->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot = NULL;
                }
            }
            else
            {
                if (~(dwFlags & NONAME) && ~(dwFlags & EXIST))
                {
#if (defined _NT1X_ && !defined _MAC)
                    ptszCurDir = (TCHAR *) new TCHAR[MAX_PATH_LENGTH];
                    
                    if (NULL == ptszCurDir)
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if (S_OK == hr)
                    {
                        memset(ptszCurDir,'\0',MAX_PATH_LENGTH*sizeof(TCHAR));

                        if (NULL == _wgetcwd(ptszCurDir, MAX_PATH_LENGTH))
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in getting Current directory\n")));

                            hr = E_FAIL;
                        }
                    }

                    if (S_OK == hr)
                    {
                        GET_TIME(StartTime);

                        Temp = _wmkdir(ptszNames[0]);

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumCreates] = 
                            DiffTime(EndTime, StartTime);

                        if (0 != Temp)
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in creating a directory\n")));

                            hr = E_FAIL;
                        }
                    }

                    // Clean up

                    if (S_OK == hr)
                    {
                        if (0 != _wchdir(ptszCurDir))
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in changing directory\n")));

                            hr = E_FAIL;
                        }

                        if (S_OK == hr)
                        {
                            if (0 != _wrmdir(ptszNames[0]))
                            {
                                DH_LOG((
                                    LOG_INFO,
                                    TEXT("Error in removing directory\n")));

                                hr = E_FAIL;
                            }
                        }
                        
                        if (NULL != ptszCurDir)
                        {
                            delete []ptszCurDir;
                            ptszCurDir = NULL;
                        }
                    }
#else
                    ptszCurDir = (TCHAR *) new TCHAR[MAX_PATH_LENGTH];
                    
                    if (NULL == ptszCurDir)
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if (S_OK == hr)
                    {
                        memset(ptszCurDir,'\0',MAX_PATH_LENGTH*sizeof(TCHAR));

                        if (NULL == _getcwd(ptszCurDir, MAX_PATH_LENGTH))
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in getting Current directory\n")));

                            hr = E_FAIL;
                        }
                    }

                    if (S_OK == hr)
                    {
                        GET_TIME(StartTime);

                        Temp = _mkdir(ptszNames[0]);

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumCreates] = 
                            DiffTime(EndTime, StartTime);

                        if (0 != Temp)
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in creating a directory\n")));

                            hr = E_FAIL;
                        }
                    }

                    // Clean up

                    if (S_OK == hr)
                    {
                        if (0 != _chdir(ptszCurDir))
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in changing directory\n")));

                            hr = E_FAIL;
                        }

                        if (S_OK == hr)
                        {
                            if (0 != _rmdir(ptszNames[0]))
                            {
                                DH_LOG((
                                    LOG_INFO,
                                    TEXT("Error in removing directory\n")));

                                hr = E_FAIL;
                            }
                        }
                        
                        if (NULL != ptszCurDir)
                        {
                            delete []ptszCurDir;
                            ptszCurDir = NULL;
                        }
                    }
#endif
                }
                else
                {
                    DH_LOG((
                        LOG_INFO, 
                        TEXT("RUNTIME not supported this function\n")));

                    hr = E_FAIL;
                }
            }
        }

        // Clean up

        if (NULL != pOleName)
        {
            delete []pOleName;
            pOleName = NULL;
        }

        if ((NULL != ptszNames[0]) && (dwFlags & DOCFILE))
        {
            if (FALSE == DeleteFile(ptszNames[0]))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;

                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
        }
        else if (NULL != ptTmpName)
        {
            if (FALSE == DeleteFile(ptTmpName))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
            delete []ptTmpName;
            ptTmpName = NULL;
        }


        if (NULL != ptszNames[0])
        {
            delete []ptszNames[0];
            ptszNames[0] = NULL;
        }
    }

    return hr;
}


//----------------------------------------------------------------------------
//
// Function: StreamOpen
//
// Synopsis: Open a stroage and its child stream is similar to find a directory
//           and open a file in this directory in C-runtime. This test measures
//           the time in opening both storage and stream or opening stream only
//           and also the time in corresponding C-runtime operations.
//
// Arguments: [dwRootMode] - Access modes to root storage
//            [pdgu] - Pointer to Data Unicode object
//            [usTimeIndex] - Indicate which category this test is
//            [dwFlags] - Indicate DOCFILE or RUNTIME file and also 
//                        open both storage and stream or not.
//            [usNumOpens] - Indicate this is usNumOpens'th opening
// 
// Returns: HResult
//
// History: 9-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT StreamOpen(
    DWORD       dwRootMode,
    DG_STRING  *pdgu,
    USHORT      usTimeIndex, 
    DWORD       dwFlags, 
    USHORT      usNumOpens)
{
    HRESULT     hr              = S_OK; 
    LPSTORAGE   pstgRoot        = NULL;
    LPSTREAM    pstmStream      = NULL;
    LPOLESTR    pOleName        = NULL;
    LPTSTR      ptszCurDir      = NULL;
    LPTSTR      ptszNewDir      = NULL;
    ULONG       bufferSize      = 0;
    DWORD       StartTime       = 0;
    DWORD       EndTime         = 0;
    FILE        *fileFile       = NULL;
    ULONG       ulRef           = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("StreamOpen"));
    
    DH_VDATEPTRIN(pdgu, DG_STRING);

    DH_ASSERT(NULL != pdgu);
 
    while ((S_OK == hr) && (0 < usNumOpens))
    {
        usNumOpens--;

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszNames[0]);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")); 

        if (S_OK == hr)
        {
            hr = TStringToOleString(ptszNames[0], &pOleName);
            DH_HRCHECK(hr, TEXT("TStringToOleString"));
        }
        
        if (S_OK == hr)
        {
            if (dwFlags & DOCFILE)
            {
                // Create a root storage and a stream inside it.
 
                hr = StgCreateDocfile(
                        pOleName,
                        dwRootMode | STGM_CREATE,
                        0,
                        &pstgRoot);

                DH_HRCHECK(hr, TEXT("StgCreateDocfile"));
            
                if (S_OK == hr)
                {
                    hr = pstgRoot->CreateStream(
                            pOleName,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                            0,
                            0,
                            &pstmStream);
                    
                    DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
                }

                if ((S_OK == hr) && (dwFlags & COMMIT))
                {
                    hr = pstgRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                }

                if (S_OK == hr)
                {
                    ulRef = pstmStream->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream = NULL;

                    ulRef = pstgRoot->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot = NULL;
                }
            }
            else
            {
                // Create a directory and a file under it.

                ptszCurDir = (TCHAR *) new TCHAR[MAX_PATH_LENGTH];
                ptszNewDir = (TCHAR *) new TCHAR[MAX_PATH_LENGTH];    

                if ((NULL == ptszCurDir) || (NULL == ptszNewDir))
                {
                    hr = E_OUTOFMEMORY;
                }

                if (S_OK == hr)
                {
                    memset(ptszCurDir,'\0',MAX_PATH_LENGTH * sizeof(TCHAR));
                    memset(ptszNewDir,'\0',MAX_PATH_LENGTH * sizeof(TCHAR));
                }

#if (defined _NT1X_ && !defined _MAC)
 
                if (NULL == _wgetcwd(ptszCurDir, MAX_PATH_LENGTH))
                {
                    DH_LOG((
                        LOG_INFO, 
                        TEXT("Error in getting Current directory\n")));

                    hr = E_FAIL;
                }

                if (S_OK == hr)
                { 
                    if (0 != _wmkdir(ptszNames[0]))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in creating a directory\n")));

                        hr = E_FAIL;
                    }
                }

                if (S_OK == hr)
                {                    
                    _tcscpy(ptszNewDir, ptszCurDir);
                    _tcscat(ptszNewDir, TEXT("\\"));
                    _tcscat(ptszNewDir, ptszNames[0]);
                }

                if (S_OK == hr)
                { 
                    if (0 != _wchdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                }

                if (S_OK == hr)
                {
                    fileFile = _wfopen(ptszNames[0],TEXT("w"));

                    if (NULL == fileFile)
                    {
                        DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                        hr = E_FAIL;
                    }
                }          

#else                 
                if (NULL == _getcwd(ptszCurDir, MAX_PATH_LENGTH))
                {
                    DH_LOG((
                        LOG_INFO, 
                        TEXT("Error in getting Current directory\n")));

                    hr = E_FAIL;
                }

                if (S_OK == hr)
                {                        
                    if (0 != _mkdir(ptszNames[0]))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in creating a directory\n")));

                        hr = E_FAIL;
                    }
                } 

                if (S_OK == hr)
                {                    
                    _tcscpy(ptszNewDir, ptszCurDir);
                    _tcscat(ptszNewDir, TEXT("\\"));
                    _tcscat(ptszNewDir, ptszNames[0]);
                }

                if (S_OK == hr)
                { 
                    if (0 != _chdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                }

                if (S_OK == hr)
                {
                    fileFile = fopen(ptszNames[0],"w");

                    if (NULL == fileFile)
                    {
                        DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                        hr = E_FAIL;                   
                    }
                }
#endif
                if (S_OK == hr)
                {
                    fclose(fileFile);
                }
            }
        }

        if (S_OK == hr)
        {
            if (dwFlags & DOCFILE)
            {
                if (dwFlags & OPENBOTH)
                {
                    GET_TIME(StartTime);
                
                    hr = StgOpenStorage(
                            pOleName,
                            NULL,
                            dwRootMode,
                            NULL,
                            0,
                            &pstgRoot);
              
                    if (S_OK == hr)
                    {
                        hr = pstgRoot->OpenStream(
                                pOleName,
                                NULL,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0,
                                &pstmStream);

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plDocfileTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                    }

                    if (S_OK != hr)
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("Open storage or stream, hr=0x%lx\n"),
                            hr));
                    }
                }
                else
                {
                    hr = StgOpenStorage(
                            pOleName,
                            NULL,
                            dwRootMode,
                            NULL,
                            0,
                            &pstgRoot);
              
                    if (S_OK == hr)
                    {
                        GET_TIME(StartTime);

                        hr = pstgRoot->OpenStream(
                                pOleName,
                                NULL,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0,
                                &pstmStream);

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plDocfileTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                    }

                    if (S_OK != hr)
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("Open storage or stream, hr=0x%lx\n"),
                            hr));
                    }
                }

                if (S_OK == hr)
                {
                    ulRef = pstmStream->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream = NULL;

                    ulRef = pstgRoot->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot = NULL;
                }
            }
            else
            {
                if (dwFlags & OPENBOTH)
                {
#if (defined _NT1X_ && !defined _MAC)
                    GET_TIME(StartTime);
                     
                    if (0 != _wchdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                
                    if (S_OK == hr)
                    {               
                        fileFile = _wfopen(ptszNames[0],TEXT("r+"));

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                        if (NULL == fileFile)
                        {
                            DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                            hr = E_FAIL;
                        }
                    }          
#else

                    GET_TIME(StartTime);
                     
                    if (0 != _chdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                
                    if (S_OK == hr)
                    {               
                        fileFile = fopen(ptszNames[0],"r+");

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                        if (NULL == fileFile)
                        {
                            DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                            hr = E_FAIL;
                        }
                    }          
#endif
                    if (S_OK == hr)
                    {
                        fclose(fileFile);
                    }
                }
                else
                {

#if (defined _NT1X_ && !defined _MAC)
                    if (0 != _wchdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                
                    if (S_OK == hr)
                    {  
                        GET_TIME(StartTime);

                        fileFile = _wfopen(ptszNames[0],TEXT("r+"));

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                        if (NULL == fileFile)
                        {
                            DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                            hr = E_FAIL;
                        }
                    }          
#else
                     
                    if (0 != _chdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                
                    if (S_OK == hr)
                    {               
                        GET_TIME(StartTime);
                        
                        fileFile = fopen(ptszNames[0],"r+");

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                        if (NULL == fileFile)
                        {
                            DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                            hr = E_FAIL;
                        }
                    }          
#endif
                    if (S_OK == hr)
                    {
                        fclose(fileFile);
                    }
                }
            }
        }

        // Clean up

        if ((S_OK == hr) && (dwFlags & RUNTIME))
        {
            // Remove the directory and the file under it

            if ((S_OK == hr) && (NULL != ptszNames[0]))
            {
                if (FALSE == DeleteFile(ptszNames[0]))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError()) ;

                    DH_HRCHECK(hr, TEXT("DeleteFile")) ;
                }
            }

#if (defined _NT1X_ && !defined _MAC)
            
            if (0 != _wchdir(ptszCurDir))
            {
                DH_LOG((
                    LOG_INFO, 
                    TEXT("Error in changing directory\n")));

                hr = E_FAIL;
            }

            if (S_OK == hr)
            {
                if (0 != _wrmdir(ptszNames[0]))
                {
                    DH_LOG((
                        LOG_INFO,
                        TEXT("Error in removing directory\n")));

                    hr = E_FAIL;
                }
            }
                        
#else
            if (0 != _chdir(ptszCurDir))
            {
                DH_LOG((
                    LOG_INFO, 
                    TEXT("Error in changing directory\n")));

                hr = E_FAIL;
            }

            if (S_OK == hr)
            {
                if (0 != _rmdir(ptszNames[0]))
                {
                    DH_LOG((
                        LOG_INFO,
                        TEXT("Error in removing directory\n")));

                    hr = E_FAIL;
                }
            }
#endif                        
            if (NULL != ptszNewDir)
            {
                delete []ptszNewDir;
                ptszNewDir = NULL;
            }

            if (NULL != ptszCurDir)
            {
                delete []ptszCurDir;
                ptszCurDir = NULL;
            }
        }

        if (NULL != pOleName)
        {
            delete []pOleName;
            pOleName = NULL;
        }

        if ((NULL != ptszNames[0]) && (dwFlags & DOCFILE))
        {
            if (FALSE == DeleteFile(ptszNames[0]))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;

                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
        }

        if (NULL != ptszNames[0])
        {
            delete []ptszNames[0];
            ptszNames[0] = NULL;
        }
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// Function: WriteStreamInSameSizeChunks
//
// Synopsis: Create and open all the docfiles or C-runtime files, and then
//           write data in the same size chunks to docfiles or C-runtime
//           files, also record the time of the all the write operations
//           in Time[]. Each WRITE could be RANDOM_WRITE or SEQUENTIAL_WRITE.
//
// Arguments: [dwRootMode] - The access mode for the root docfile
//            [pdgu] - Pointer to Data Unicode object
//            [usTimeIndex] - Indicate it is RANDOM_WRITE or SEQUENTIAL_WRITE
//            [dwFlags] - Indicate write to DOCFILE or RUNTIME file
//            [ulChunkSize] - The size of each chunk to write
//            [usIteration] - Indicate this is the usIteration'th write
//
// Returns: HResult
//
// History: 6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT WriteStreamInSameSizeChunks(
    DWORD       dwRootMode,
    DG_STRING  *pdgu,
    USHORT      usTimeIndex,
    DWORD       dwFlags,
    ULONG       ulChunkSize,
    USHORT      usIteration)
{
    HRESULT         hr                  = S_OK;
    DWORD           StartTime           = 0;
    DWORD           EndTime             = 0;
    ULONG           culBytesLeftToWrite = 0;
    LPTSTR          ptcsBuffer          = NULL;
    LPOLESTR        pOleName            = NULL;
    ULONG           pcbCount            = 0;
    USHORT          usSeekIndex         = 0;
    USHORT          usIndex             = 0;
    ULONG           ulUserChunk         = 0;
    ULONG           bufferSize          = 0;
    DWORD           dwWriteCRC          = 0;
    DWORD           dwReadCRC           = 0;
    ULONG           ulRef               = 0;
    LPSTORAGE       pstgRoot[MAX_DOCFILES];
    LPSTREAM        pstmStream[MAX_DOCFILES];
    FILE            *fileFile[MAX_DOCFILES];
    LARGE_INTEGER   liStreamPos;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("WriteStreamInSameSizeChunks"));
    
    DH_VDATEPTRIN(pdgu, DG_STRING);

    DH_ASSERT(NULL != pdgu);

    // Initialization

    culBytesLeftToWrite = ulStreamSize;
    ulUserChunk = ulChunkSize;

    // Create & open all the docfiles or C-runtime files

    if (S_OK == hr)
    {
        for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
        {
            if (dwFlags & DOCFILE)
            {
                hr = TStringToOleString(ptszNames[usIndex], &pOleName);
                DH_HRCHECK(hr, TEXT("TStringToOleString"));

                if (S_OK == hr)
                {
                    hr = StgCreateDocfile(
                            pOleName,
                            dwRootMode | STGM_CREATE,
                            0,
                            &pstgRoot[usIndex]);

                    DH_HRCHECK(hr, TEXT("StgCreateDocfile"));
                }

                if (S_OK == hr)
                {
                    hr = pstgRoot[usIndex]->CreateStream(
                            pOleName,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0,
                            0,
                            &pstmStream[usIndex]);

                    DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
                }

                if (S_OK == hr)
                {
                    hr = pstgRoot[usIndex]->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                }
                
                if (NULL != pOleName)
                {
                    delete []pOleName;
                    pOleName = NULL;
                }

                if (S_OK != hr)
                {
                    break;
                }
            }
            else
            {

#if (defined _NT1X_ && !defined _MAC)
                 
                fileFile[usIndex] = _wfopen(ptszNames[usIndex],TEXT("w+b"));

                if (NULL == fileFile[usIndex])
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                    break;
                }
                
#else
                fileFile[usIndex] = fopen(ptszNames[usIndex],"w+b");

                if (NULL == fileFile[usIndex])
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                    break;
                }
#endif
            }
        }
    }

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu,
                ulChunkSize,
                ulChunkSize,
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        GET_TIME(StartTime);

        // Perform write operations on each of the MAX_DOCFILES files

        for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
        {
            culBytesLeftToWrite = ulStreamSize;
            usSeekIndex = 0;
            ulChunkSize = ulUserChunk;

            while (0 != culBytesLeftToWrite)
            {
                if (ulChunkSize > culBytesLeftToWrite)
                {
                    ulChunkSize = culBytesLeftToWrite;
                }
                culBytesLeftToWrite -= ulChunkSize;

                if (dwFlags & DOCFILE)
                {
                    if (RANDOM_WRITE == usTimeIndex)
                    {
                        LISet32(liStreamPos,ulSeekOffset[usSeekIndex]);
                        usSeekIndex++;

                        hr = pstmStream[usIndex]->Seek(
                                liStreamPos,
                                STREAM_SEEK_SET,
                                NULL);

                        DH_HRCHECK(hr, TEXT("IStream::Seek"));
                    }

                    if (S_OK == hr)
                    {
                        hr = pstmStream[usIndex]->Write(
                                (LPBYTE)ptcsBuffer,
                                ulChunkSize,
                                &pcbCount);

                        DH_HRCHECK(hr, TEXT("IStream::Write"));
                    }
                }
                else 
                {
                    if (RANDOM_WRITE == usTimeIndex)
                    {
                        fseek(
                            fileFile[usIndex], 
                            (LONG) ulSeekOffset[usSeekIndex++],
                            SEEK_SET);

                        if (ferror(fileFile[usIndex]))
                        {
                            DH_LOG((LOG_INFO, TEXT("Error seeking file\n")));

                            hr = E_FAIL;
                        }
                    }
                    
                    if (S_OK == hr)
                    {
                        fwrite(
                            (LPBYTE)ptcsBuffer, 
                            (size_t)ulChunkSize, 
                            1,
                            fileFile[usIndex]);

                        if (ferror(fileFile[usIndex]))
                        {
                            DH_LOG((LOG_INFO, TEXT("Error writing file\n")));

                            hr = E_FAIL;
                        }
                    }
                }
                
                if (S_OK != hr)
                {
                    break;
                }
            }

            if (S_OK == hr)
            {
                if (dwFlags & DOCFILE)
                {
                    if (dwFlags & COMMIT)
                    {
                        hr = pstgRoot[usIndex]->Commit(STGC_DEFAULT);

                        DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                    }

                    if (S_OK == hr)
                    {
                        ulRef = pstmStream[usIndex]->Release();
                        DH_ASSERT(0 == ulRef);
                        pstmStream[usIndex] = NULL;

                        ulRef = pstgRoot[usIndex]->Release();
                        DH_ASSERT(0 == ulRef);
                        pstgRoot[usIndex] = NULL;
                    }
                }
                else
                {
                    fclose(fileFile[usIndex]);
                }               
            }

            if (S_OK != hr)
            {
                break;
            }
        }

        if (S_OK == hr)
        {
            GET_TIME(EndTime);
 
            if (dwFlags & DOCFILE)
            {
                Time[usTimeIndex].plDocfileTime[usIteration] = 
                    DiffTime(EndTime, StartTime) / MAX_DOCFILES;
            }
            else
            {
                Time[usTimeIndex].plRuntimeTime[usIteration] = 
                    DiffTime(EndTime, StartTime) / MAX_DOCFILES;
            }
        }
    }

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: ReadStreamInSameSizeChunks
//
// Synopsis: Open all the docfiles or C-runtime files created before, then
//           read data in the same size chunks from docfiles or C-runtime
//           files, also record the time of the all the read operations
//           in Time[]. Each READ could be RANDOM_READ or SEQUENTIAL_READ.
//
// Arguments: [dwRootMode] - Access Mode for the root storage
//            [usTimeIndex] - Indicate it is RANDOM_WRITE or SEQUENTIAL_WRITE
//            [dwFlags] - Indicate reading from DOCFILE or RUNTIME file
//            [ulChunkSize] - The size of each chunk to read
//            [usIteration] - Indicate this is the usIteration'th read
//
// Returns: HResult
//
// History: 8-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------


HRESULT ReadStreamInSameSizeChunks(
    DWORD   dwRootMode,
    USHORT  usTimeIndex,
    DWORD   dwFlags,
    ULONG   ulChunkSize,
    USHORT  usIteration)
{
    HRESULT         hr                  = S_OK;
    DWORD           StartTime           = 0;
    DWORD           EndTime             = 0;
    ULONG           culBytesLeftToRead  = 0;
    LPBYTE          pbBuffer            = NULL;
    LPOLESTR        pOleName            = NULL;
    ULONG           pcbCount            = 0;
    USHORT          usSeekIndex         = 0;
    USHORT          usIndex             = 0;
    ULONG           ulUserChunk         = 0;
    ULONG           bufferSize          = 0;
    DWORD           dwWriteCRC          = 0;
    DWORD           dwReadCRC           = 0;
    ULONG           ulRef               = 0;
    LPSTORAGE       pstgRoot[MAX_DOCFILES];
    LPSTREAM        pstmStream[MAX_DOCFILES];
    FILE            *fileFile[MAX_DOCFILES];
    LARGE_INTEGER   liStreamPos;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ReadStreamInSameSizeChunks"));
    
    // Initialization

    culBytesLeftToRead = ulStreamSize;
    ulUserChunk = ulChunkSize;

    // Open all the docfiles or C-runtime files

    if (S_OK == hr)
    {
        for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
        {
            if (dwFlags & DOCFILE)
            {
                hr = TStringToOleString(ptszNames[usIndex], &pOleName);
                DH_HRCHECK(hr, TEXT("TStringToOleString"));

                if (S_OK == hr)
                {
                    hr = StgOpenStorage(
                            pOleName,
                            NULL,
                            dwRootMode,
                            NULL,
                            0,
                            &pstgRoot[usIndex]);

                    DH_HRCHECK(hr, TEXT("StgOpenStorage"));
                }

                if (S_OK == hr)
                {
                    hr = pstgRoot[usIndex]->OpenStream(
                            pOleName,
                            NULL,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0,
                            &pstmStream[usIndex]);

                    DH_HRCHECK(hr, TEXT("IStorage::OpenStream"));
                }
                
                if (NULL != pOleName)
                {
                    delete []pOleName;
                    pOleName = NULL;
                }

                if (S_OK != hr)
                {
                    break;
                }
            }
            else
            {

#if (defined _NT1X_ && !defined _MAC)
  
                fileFile[usIndex] = _wfopen(ptszNames[usIndex], TEXT("r+b"));

                if (NULL == fileFile[usIndex])
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                    break;
                }
                
#else
                fileFile[usIndex] = fopen(ptszNames[usIndex],"r+b");

                if (NULL == fileFile[usIndex])
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                    break;
                }
#endif
            }
        }
    }

    if (S_OK == hr)
    {
        GET_TIME(StartTime);

        // Perform write operations on each of the MAX_DOCFILES files

        for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
        {
            culBytesLeftToRead = ulStreamSize;
            usSeekIndex = 0;
            ulChunkSize = ulUserChunk;

            while (0 != culBytesLeftToRead)
            {
                if (ulChunkSize > culBytesLeftToRead)
                {
                    ulChunkSize = culBytesLeftToRead;
                }
                culBytesLeftToRead -= ulChunkSize;

                pbBuffer = new BYTE[ulChunkSize];

                if (NULL == pbBuffer)
                {
                    hr = E_OUTOFMEMORY;
                }

                if (S_OK == hr)
                {
                    memset(pbBuffer, '\0', ulChunkSize * sizeof(BYTE));
                }

                if ((S_OK == hr) && (dwFlags & DOCFILE))
                {
                    if (RANDOM_READ == usTimeIndex)
                    {
                        LISet32(liStreamPos,ulSeekOffset[usSeekIndex]);
                        usSeekIndex++;

                        hr = pstmStream[usIndex]->Seek(
                                liStreamPos,
                                STREAM_SEEK_SET,
                                NULL);

                        DH_HRCHECK(hr, TEXT("IStream::Seek"));
                    }

                    if (S_OK == hr)
                    {
                        hr = pstmStream[usIndex]->Read(
                                pbBuffer,
                                ulChunkSize,
                                &pcbCount);

                        DH_HRCHECK(hr, TEXT("IStream::Read"));
                    }
                }
                else 
                {
                    if ((S_OK == hr) && (RANDOM_READ == usTimeIndex))
                    {
                        fseek(
                            fileFile[usIndex], 
                            (LONG) ulSeekOffset[usSeekIndex++],
                            SEEK_SET);

                        if (ferror(fileFile[usIndex]))
                        {
                            DH_LOG((LOG_INFO, TEXT("Error seeking file\n")));

                            hr = E_FAIL;
                        }
                    }
                    
                    if (S_OK == hr)
                    {
                        fread(
                            pbBuffer, 
                            (size_t)ulChunkSize, 
                            1,
                            fileFile[usIndex]);

                        if (ferror(fileFile[usIndex]))
                        {
                            DH_LOG((LOG_INFO, TEXT("Error reading file\n")));

                            hr = E_FAIL;
                        }
                    }
                }
            
                if (NULL != pbBuffer)
                {
                    delete []pbBuffer;
                    pbBuffer = NULL;
                }

                if (S_OK != hr)
                {
                    break;
                }
            }

            if (S_OK != hr)
            {
                break;
            }
        }

        if (S_OK == hr)
        {
            GET_TIME(EndTime);

            for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
            {
                if (dwFlags & DOCFILE)
                {
                    ulRef = pstmStream[usIndex]->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream[usIndex] = NULL;
                    
                    ulRef = pstgRoot[usIndex]->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot[usIndex] = NULL;
                }
                else
                {
                    fclose(fileFile[usIndex]);
                }
            }
        }

        if (S_OK == hr)
        {
            if (dwFlags & DOCFILE)
            {
                Time[usTimeIndex].plDocfileTime[usIteration] = 
                    DiffTime(EndTime, StartTime) / MAX_DOCFILES;
            }
            else
            {
                Time[usTimeIndex].plRuntimeTime[usIteration] = 
                    DiffTime(EndTime, StartTime) / MAX_DOCFILES;
            }
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: Statistics
//
// Synopsis: Generate statistics data: average, total and square difference.
//
// Arguments: [pdData] - pointer to data
//            [usItems] - Number of data items
//            [pdAverage] - Average value of data
//            [pdTotal] - Total value of data
//            [pdSD] - Square difference of data
//
// Returns: None
//
// History: 6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

void    Statistics(
    double  *pdData, 
    USHORT  usItems, 
    double  *pdAverage, 
    double  *pdTotal,
    double  *pdSD)
{
    USHORT  usIndex = 0;
    double  dTemp;

    *pdTotal = 0;

    for (usIndex=0; usIndex<usItems; usIndex++)
    {
        *pdTotal += pdData[usIndex];
    }

    *pdAverage = *pdTotal / usItems;
    *pdSD = 0;

    for (usIndex=0; usIndex<usItems; usIndex++)
    {
        dTemp = (pdData[usIndex] - *pdAverage);
        *pdSD += (dTemp * dTemp);
    }

    if (usItems > 1)
    {
        *pdSD = *pdSD / (usItems - 1);
    }

    *pdSD = sqrt(*pdSD); 
}

//----------------------------------------------------------------------------
//
// Function: Statistics
//
// Synopsis: Generate statistics data: average, total and square difference.
//
// Arguments: [pdData] - pointer to data
//            [usItems] - Number of data items
//            [pdAverage] - Average value of data
//            [pdTotal] - Total value of data
//            [pdSD] - Square difference of data
//
// Returns: None
//
// History: 6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------
 
void    Statistics(
    LONG    *plData, 
    USHORT  usItems, 
    LONG    *plAverage, 
    double  *pdTotal,
    double  *pdSD)
{
    USHORT  usIndex     = 0;
    double  dAverage;
    double  *pdData;

    pdData = new double[usItems];

    for (usIndex=0; usIndex<usItems; usIndex++)
    {
        pdData[usIndex] = plData[usIndex];
    }

    Statistics(pdData, usItems, &dAverage, pdTotal, pdSD);

    *plAverage = (LONG)dAverage;

    delete [] pdData;
}

//----------------------------------------------------------------------------
//
// Function: DiffTime
//
// Synopsis: Calculate and return the difference of two time.
//
// Arguments: [EndTime] - the time when an operation ended
//            [StartTime] - the time when an operation started
//   
// Returns:  LONG
//
// History:  6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

LONG DiffTime(DWORD EndTime, DWORD StartTime)
{
    LONG lResult    = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DiffTime"));
    
    DH_ASSERT(StartTime <= EndTime);

    lResult = EndTime - StartTime;

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\stmtests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      stmtsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStream interface 
//
//  Functions:  
//
//  History:    28-June-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

// externs
extern BOOL     g_fDoLargeSeekAndWrite;
extern BOOL     g_fUseStdBlk;
extern USHORT   ausSIZE_ARRAY[];

#define SECTORSIZE  512
#define SMALL_OBJ_SIZE  4096

//----------------------------------------------------------------------------
//
// Test:    STMTEST_100 
//
// Synopsis:  Creates a root docfile with a random name.
//       Creates an IStream in the root docfile and writes and CRCs a
//       random number of bytes then releases the IStream.  The root
//       is then committed and released.  The root docfile and child IStream
//       are then instantiated.  CRC's are compared to verify.
//       A random offset is chosen within the child IStream and a random number
//       of bytes are written to the IStream, taking care *NOT* to grow the 
//       length of the IStream. The IStream and root are then released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    28-June-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LSCHANGE.CXX
// 2.  Old name of test : LegitStreamChange test 
//     New Name of test : STMTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-100
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-100
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-100
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: STMTEST-100
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    ULONG           cb                      = 0;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           culRandomPos            = 0;
    ULONG           culRemWritten           = 0;
    DWORD           dwRootMode              = 0;
    BOOL            fPass                   = TRUE;
    LARGE_INTEGER   liStreamPos;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    DWCRCSTM        dwMemCRC;
    DWCRCSTM        dwActCRC;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream change operations")) );

    // Initialize CRC values to zero

    dwMemCRC.dwCRCSum = dwActCRC.dwCRCSum = 0;

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }

    // Call VirtualStmNode::Write to create random bytes in the stream.  For
    // our test purposes, we generate a random string of size 1 to cb using
    // GenerateRandomString function.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                ptcsBuffer,
                cb,
                &culWritten);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Calculate the CRC for stream name and data

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnRootNewChildStream,
                ptcsBuffer,
                cb,
                &dwMemCRC);

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx.")));
        }
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Open root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Open stream
  
    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  ,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open unsuccessful,hr=0x%lx."),
            hr));
        }
    }

    // Read and verify

    if(S_OK == hr)
    {
        hr = ReadAndCalculateDiskCRCForStm(pvsnRootNewChildStream,&dwActCRC);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ReadAndCalculateDiskCRCForStm function successful.")));

            if(dwActCRC.dwCRCSum == dwMemCRC.dwCRCSum)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's for pvsnNewChildStream match.")));

            }
            else
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for pvsnNewChildStream don't match.")));

                fPass = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ReadAndCalculateDiskCRCForStm not successful, hr=0x%lx."),
                hr));
        } 
    }

    // If it is ok till now, then all the bytes were written correctly into 
    // stream and read correctly from there, so choose any postion b/w 1 and
    // culWritten - number of bytes written and therafter read.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&culRandomPos, 1, culWritten);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Now seek to this position

    if(S_OK == hr)
    {
        LISet32(liStreamPos, culRandomPos);

        //  Position the stream header to the postion from begining

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek function wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Now write into this part of stream with random data w/o growing the
    // stream

    if(S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culWritten - culRandomPos, 
                culWritten - culRandomPos, 
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                ptcsBuffer,
                culWritten - culRandomPos,
                &culRemWritten);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Check length of stream not grown if stream written to correctly.

    if(S_OK == hr)
    {
        if(culRemWritten == culWritten - culRandomPos)
        {
            DH_TRACE((
               DH_LVL_TRACE1, 
               TEXT("Stream data changed okay w/o changing stream len.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1, 
               TEXT("Stream data change not okay.")));
            
            fPass = FALSE;
        }
    }

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_101 
//
// Synopsis: The test creates a root docfile and a child IStream.  A random
//       number of bytes are written to the IStream and then the IStream
//       is cloned.
//       From 1 to 5 times, either the ORIGINAL or CLONE IStream is
//       randomly chosen as the operation target.  The current seek
//       pointer positions of both IStreams are saved.  There is then a
//       33% chance each that the target stream will be used for a
//       seek, write, or read operation.  Next, the stream that was
//       *NOT* the target IStream is seeked upon to determine the
//       current pointer position.  Verify that the *non target*
//       IStream pointer hasn't changed.  Repeat.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    28-June-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LSCLONE.CXX
// 2.  Old name of test : LegitStreamClone test 
//     New Name of test : STMTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-101
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-101
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-101
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: STMTEST-101
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    ULONG           cb                      = 0;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    DWORD           dwRootMode              = 0;
    BOOL            fPass                   = TRUE;
    BOOL            fFindSeekPosition       = FALSE;
    LARGE_INTEGER   liStreamPos;
    ULONG           culRandIOBytes          = 0;
    ULONG           culBytesLeftToWrite     = 0;
    LPSTREAM        pIStreamClone           = NULL;
    ULONG           ulCurPosition[2];
    ULONG           ulOldPosition[2];
    ULONG           culRandomVar            = 0;
    ULONG           culRandomPos            = 0;
    ULONG           culRandomCommit         = 0;
    ULONG           cStreamInUse            = 0;
    ULONG           cStreamNotInUse         = 0;
    ULONG           cOpInUse                = 0;
    ULONG           ulRef                   = 0;
    LPSTREAM        pIStream[2];
    ULARGE_INTEGER  uli;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream clone operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_101, Access mode: %lx"),
            dwRootMode));
    }


    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu);
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 4L, and MIN_SIZE * 1.5
        // (range taken from old test).

        usErr = pdgi->Generate(&cb, 4,  (ULONG) (MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            culBytesLeftToWrite = cb;

            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
        }
    }

    // Loop to write new IStream in RAND_IO size chunks unless size
    // remaining to write is less than RAND_IO, then write the remaining bytes

    while((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        if (S_OK == hr)
        {
            // Generate random number of bytes to write b/w RAND_IO_MIN ,
            // RAND_IO_MAX  (range taken from old test).

            usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
    
        if(culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size 1 to cb using
        // GenerateRandomString function.

        if(S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);

            if (S_OK == hr)
            {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
            }
            else
            {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
            }
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // Now seek to the current stream to end of stream

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        //  Position the stream header to the postion from begining

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulCurPosition[ORIGINAL] = ULIGetLow(uli);

        if(S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
        }
    }

    // Clone the stream

    if(S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Clone(&pIStreamClone);

        DH_HRCHECK(hr, TEXT("IStream::Clone")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Clone completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Clone not successful, hr=0x%lx."),
            hr));
        }
    }

    //clone IStream should really already be positioned to the end since
    //the original IStream was there.  The seek below simply ensures
    //this plus gets the seek position into the Clone current position
    //array element

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        //  Position the stream header to the postion from begining

        hr = pIStreamClone->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;

        ulCurPosition[CLONE] = ULIGetLow(uli);

        if(S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
        }
    }

    // Copy the ulCurPosition array to ulOldPosition array.  Now in a loop,
    // in a random fashion, select either the original stream or Clone stream,
    // do either seek, read or write operation on it.  Check that the unused
    // stream's seek pointer hasn't changed.  Update the ulOldPosition array
    // with ulCurPostion araay and repeat the loop random number of times.

    if (S_OK == hr)
    {
        // Generate random variations for while loop 

        usErr = pdgi->Generate(&culRandomVar, 1, 5);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        // Also fill up stream pointer array

        pIStream[0] = pvsnRootNewChildStream->GetIStreamPointer();
        pIStream[1] = pIStreamClone;
    }
 
    while ((S_OK == hr) && (culRandomVar--))
    {
        //save current seek pointer positions

        ulOldPosition[ORIGINAL] = ulCurPosition[ORIGINAL];
        ulOldPosition[CLONE] = ulCurPosition[CLONE];

        // pick an IStream to use (either ORIGINAL or CLONE) then
        // decide whether to seek on it, write it, or read it

        usErr = pdgi->Generate(&cStreamInUse, ORIGINAL, CLONE);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        //pick an operation to do on the stream (either SEEK, WRITE, READ) 

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(&cOpInUse, SEEK, READ);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if(S_OK == hr)
        {
            //Seek to a random position in stream

            usErr = pdgi->Generate(&culRandomPos, 0, culWritten);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }

            if(S_OK == hr)
            {
                LISet32(liStreamPos, culRandomPos);

                //  Position stream header to the postion from begining

                hr = pIStream[cStreamInUse]->Seek(
                         liStreamPos, 
                         STREAM_SEEK_SET, 
                         &uli);

                DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("IStream::Seek completed successfully.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("IStream::Seek not successful.")));
                }
            }
        }


        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("cOpInUse %d on cStreamInUse %d"),
                cOpInUse,
                cStreamInUse));
                
            switch(cOpInUse)
            {
                case SEEK:
                {
                    ulCurPosition[cStreamInUse] = ULIGetLow(uli);
                    fFindSeekPosition = FALSE;
                    break;
                }

                case WRITE:
                {
                    hr = GenerateRandomString(
                            pdgu, 
                            0,
                            STM_BUFLEN, 
                            &ptcsBuffer);

                    DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;

                    if (S_OK == hr)
                    {
                        hr =  pIStream[cStreamInUse]->Write(
                                ptcsBuffer,
                                _tcslen(ptcsBuffer),
                                NULL);
                    }
 
                    fFindSeekPosition = TRUE;
                    break;
                }

                case READ:
                {
                    ptcsBuffer = new TCHAR [STM_BUFLEN];

                    if (ptcsBuffer == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                   
                    if(S_OK == hr)
                    {
                        // Initialize buffer
                        memset(ptcsBuffer, '\0', STM_BUFLEN);
 
                        hr =  pIStream[cStreamInUse]->Read(
                                ptcsBuffer,
                                STM_BUFLEN,
                                NULL);
                    }
 
                    fFindSeekPosition = TRUE;
                
                    break;
                }
            }

            if(S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("cOpInUse %d on cStreamInUse %d failed, hr = 0x%lx"),
                    cOpInUse,
                    cStreamInUse,
                    hr));

                fPass = FALSE;

                // Break out of while loop
                break;
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("cOpInUse %d on cStreamInUse %d passed. "),
                    cOpInUse,
                    cStreamInUse));
            }
        }

        // Determine current seek position if above operation might have change
        // it on the stream operated upon by seeking on it.

        if((S_OK == hr) && (TRUE == fFindSeekPosition))
        {
            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

            hr = pIStream[cStreamInUse]->Seek(
                    liStreamPos, 
                    STREAM_SEEK_CUR, 
                    &uli);

            DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
        
            if(S_OK == hr)
            {
                ulCurPosition[cStreamInUse] = ULIGetLow(uli);

                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek completed successfully.")));
            }
            else
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek not successful.")));
            }
        }

        // Determine the seek pointer of the stream that was NOT operated upon
        // hasn't changed.

        if(S_OK == hr)
        {
            cStreamNotInUse = (cStreamInUse == ORIGINAL) ? CLONE : ORIGINAL;

            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

            hr = pIStream[cStreamNotInUse]->Seek(
                    liStreamPos, 
                    STREAM_SEEK_CUR, 
                    &uli);

            DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
        
            if(S_OK == hr)
            {
                ulCurPosition[cStreamNotInUse] = ULIGetLow(uli);

                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek completed successfully.")));
            }
            else
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful.")));
            }
        }

        if((S_OK == hr) && 
           (ulCurPosition[cStreamNotInUse] == ulOldPosition[cStreamNotInUse]))
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Old & new seek ptr for unused stream same as exp.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Old & new seek ptr for unused stream different unexp")));
            fPass = FALSE;
            break;
        }

        // Commit the root storage half of time.

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(&culRandomCommit, 1, 100);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if((S_OK == hr) && (culRandomCommit > 50))
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
            if (S_OK == hr)
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
            }
            else
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit not successful.")));

                fPass = FALSE;
                break;
            }
        }
    }

    // Release original stream

    if (NULL != pvsnRootNewChildStream)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful.")));
        }
    }

    // Release Clone stream

    if (NULL != pIStreamClone)
    {
        ulRef = pIStreamClone->Release();
        DH_ASSERT(0 == ulRef);

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Close unsuccessful.")));
        }
    }

    // Release root 

    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful.")));
        }

    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, TEXT("Test variation STMTEST_101 failed.")) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_102 
//
// Synopsis: Create a root docfile with a child IStream.  Write a random number
//        of bytes to the IStream and commit the root docfile.  Do the same
//        with a child IStorage inside of the root docfile.
//        The root docfile is instantiated and the IStream is instantiated.
//        MAX_SIZE_ARRAY SetSize calls are made on the IStream, the size for
//        the setsize is a random ulong. After each setsize, there is a 50% 
//        chance that change will be immediately commited.After all setsizes are
//        complete, the IStream is released, the root docfile is commited
//        and then the root docfile is deleted.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    1-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LSETSIZE.CXX
// 2.  Old name of test : LegitStreamSetSize test 
//     New Name of test : STMTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:xactReadWriteShDenyW 
//     d. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:dirReadWriteShEx  /stdblock
//     e. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:xactReadWriteShEx /stdblock
//     f. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:xactReadWriteShDenyW /stdblock 
//
// BUGNOTE: Conversion: STMTEST-102
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    VirtualStmNode  *pvsnChildStgNewChildStm= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          pChildStgNewChildStmName= NULL;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    DWORD           dwRootMode              = 0;
    ULONG           ulThisSetSize           = 0;
    ULONG           culRandIOBytes          = 0;
    ULONG           culBytesLeftToWrite     = 0;
    ULONG           culRandomCommit         = 0;
    ULONG           culArrayIndex           = 0;
    ULONG           i                       = 0;
    ULONG           j                       = 0;
    VirtualCtrNode  *pvcnInUse              = NULL; 
    VirtualStmNode  *pvsnInUse              = NULL; 
    LARGE_INTEGER   liStreamPos;
    ULARGE_INTEGER  uli;
    ULARGE_INTEGER  uliCopy;
    ULARGE_INTEGER  uliSet;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream SetSize operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }
// ----------- flatfile change ---------------
    }
    else
    {
        pvcnRootNewChildStorage = pVirtualDFRoot;
    }
// ----------- flatfile change ---------------

    // Create a stream inside this child storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pChildStgNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStorage,
                pChildStgNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnChildStgNewChildStm);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 0L, and MIN_SIZE * 1.5
        // (range taken from old test).

        usErr = pdgi->Generate(&culBytesLeftToWrite, 0,(ULONG)(MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Loop to write new IStream in RAND_IO size chunks unless size
    // remaining to write is less than RAND_IO, then write the remaining bytes

    while((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        culRandIOBytes = RAND_IO_MIN;

        if(culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size culRandomBytes
        // using GenerateRandomString function.

        if(S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);

            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Write function completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                    hr));
            }
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Now seek to the start of this stream

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        //  Position the stream header to the postion from begining

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_SET, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek not successful.")));
        }
    }

    //Copy this stream pvsnRootNewChildStream to pvsnChildStgNewChildStm

    if(S_OK == hr)
    {
        ULISet32(uliCopy, ULONG_MAX);

        hr = pvsnRootNewChildStream->CopyTo(
                pvsnChildStgNewChildStm,
                uliCopy,  
                0,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::CopyTo")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::CopyTo completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::CopyTo not successful.")));
        }
    }

    // Commit child storage.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit couldn't complete successfully.")));
        }
    }

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit couldn't complete successfully.")));
        }
    }


    //do MAX_SIZE_ARRAY setsize calls on just created IStreams.  Size
    //to use in SetSize call for each iteration through the loop is
    //a random ulong. 

    if(S_OK == hr)
    {
     for (j=0; j <= 1; j++)
     {
        if (j == 0)
        {
            pvsnInUse = pvsnRootNewChildStream;
            pvcnInUse = pVirtualDFRoot;
        }
        else
        {
            pvsnInUse = pvsnChildStgNewChildStm;
            pvcnInUse = pvcnRootNewChildStorage;
        }

        for(i=0; i<=MAX_SIZE_ARRAY; i++)
        {
            if(TRUE == g_fUseStdBlk)
            {
                // Pick up a random array element.

                usErr = pdgi->Generate(&culArrayIndex, 0, MAX_SIZE_ARRAY);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
                else
                {
                    ulThisSetSize= ausSIZE_ARRAY[culArrayIndex];
                }
            }
            else
            {
                usErr = pdgi->Generate(&ulThisSetSize, 0, MIN_SIZE * 3);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            if(S_OK == hr)
            {
                ULISet32(uliSet, ulThisSetSize);

                hr = pvsnInUse->SetSize(uliSet);

                if (S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualStmNode::SetSize completed successfully.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualStmNode::SetSize not successful, hr=0x%lx."),
                        hr));
                }
            }

            // Commit the storage in use, half of time.

            if(S_OK == hr)
            {
                usErr = pdgi->Generate(&culRandomCommit, 1, 100);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            if((S_OK == hr) && (culRandomCommit > 50))
            {
                hr = pvcnInUse->Commit(STGC_DEFAULT);
       
                if (S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualCtrNode::Commit completed successfully.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualCtrNode::Commit not successful, hr =0x%lx"),
                        hr));
                }
            }

            if (S_OK == hr)
            {
                memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

                //  Position the stream header to the end of stream 

                hr = pvsnInUse->Seek(liStreamPos, STREAM_SEEK_END, &uli);

                DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

                if (S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualStmNode::Seek completed successfully.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualStmNode::Seek not successful, hr = 0x%lx."),
                        hr));
                }
            }

            if(S_OK != hr)
            {
                break;
            }
        }
     }
    }

    // Release root's child stream

    if (NULL != pvsnRootNewChildStream)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful.")));
        }
    }

    // Release child stg's child stream 

    if (NULL != pvsnChildStgNewChildStm)
    {
        hr = pvsnChildStgNewChildStm->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful.")));
        }
    }

    // Commit child storage.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit couldn't complete successfully.")));
        }
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Release child storage

    if (NULL != pvcnRootNewChildStorage)
    {
        hr = pvcnRootNewChildStorage->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful.")));
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit couldn't complete successfully.")));
        }
    }

    // Release root 

    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful.")));
        }
    }

    // if everything goes well, log test as passed else failed.
    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, TEXT("Test variation STMTEST_102 failed.")) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if(NULL != pChildStgNewChildStmName)
    {
        delete pChildStgNewChildStmName;
        pChildStgNewChildStmName = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_103 
//
// Synopsis: The test create a root docfile with a child IStream. Writes and 
//           CRCs a random number of bytes to the IStream in random block 
//           size chunks, or if the /stdblock (use size array) option is 
//           specified in cmdline, then in random block size from 
//           ausSIZE_ARRAY[] chunks, then releases the IStream. The root 
//           docfile is then committed and released. 
//           The root docfile is instantiated and the IStream is instantiated.
//           The IStream is read in same random block size chunks as written,
//           and CRCs are compared to verify. The stream and the root docfile 
//           are then released and the root file is deleted.
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LSREAD.CXX LSWRITE.CXX
// 2.  Old name of test(s) : LegitStreamRead LegitStreamWrite tests 
//     New Name of test(s) : STMTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:xactReadWriteShDenyW 
//     d. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:dirReadWriteShEx /stdblock
//     e. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:xactReadWriteShEx /stdblock
//     f. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:xactReadWriteShDenyW /stdblock
//
// History:  Jiminli	08-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-103
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           culRead                 = 0;
    DWORD           dwRootMode              = 0; 
    ULONG           culRandIOBytes          = 0;
    ULONG           culBytesLeftToWrite     = 0;
    ULONG           culBytesLeftToRead      = 0;
    ULONG           tmpBytes                = 0;
    ULONG           culArrayIndex           = 0;
    ULONG           cStartIndex             = 6;
    DWCRCSTM        *dwMemCRC               = NULL;
    DWCRCSTM        *dwActCRC               = NULL;
    ULONG           numofchunks             = 0;
    ULONG           index                   = 0;
    BOOL            fPass                   = TRUE; 

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream Read operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
        }
    }
 
    if (S_OK == hr)
    {
        // Generate random size for stream between 0L, and MIN_SIZE * 2 

        usErr = pdgi->Generate(&culBytesLeftToWrite, 0,  MIN_SIZE * 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        // Record for later use.

        culBytesLeftToRead = culBytesLeftToWrite;
        tmpBytes = culBytesLeftToWrite;
    }

    if (S_OK == hr)
    {
        if (TRUE == g_fUseStdBlk)
        {
            // Pick up a random array element.  Choosing cStartIndex of the
            // array (with random blocks) as 6 because do not want to write
            // byte by byte or in too small chunks a large docfile. 

            usErr = pdgi->Generate(&culArrayIndex, cStartIndex, MAX_SIZE_ARRAY);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
            else
            {
                culRandIOBytes = ausSIZE_ARRAY[culArrayIndex];
            }
        }
        else
        {
            // Generate random number of bytes to write per chunk b/w 
            // RAND_IO_MIN and RAND_IO_MAX.

            usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
    }

    // Calculate how many chunks be written, i.e how many CRC's be calculated

    if (S_OK == hr)
    {
        if (0 == culRandIOBytes) 
        {
            hr = E_FAIL;
        }
        else
        {
            while (0 != culBytesLeftToWrite)
            {
                numofchunks++;

                if (culBytesLeftToWrite >= culRandIOBytes)
                {
                    culBytesLeftToWrite -= culRandIOBytes;
                }
                else
                {				
                    culBytesLeftToWrite = 0;
                }
            }
        }
    }

    if (S_OK == hr)
    {
        culBytesLeftToWrite = tmpBytes;

        tmpBytes = culRandIOBytes;
    }

    // Allocate memory

    if (S_OK == hr)
    {
        dwMemCRC = new DWCRCSTM[numofchunks];
        dwActCRC = new DWCRCSTM[numofchunks];

        if ((NULL == dwMemCRC) || (NULL == dwActCRC))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Initilize each CRC to zero

    if (S_OK == hr)
    {
        for (index=0; index<numofchunks; index++)
        {
            (*(dwMemCRC + index)).dwCRCSum = 0;
            (*(dwActCRC + index)).dwCRCSum = 0;
        }
    }

    // Loop to write new IStream in RAND_IO size chunks unless size
    // remaining to write is less than RAND_IO, then write the remaining bytes

    index = 0;

    while ((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        if (culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream. For
        // our test purposes, we generate a random string of size culRandIOBytes
        // using GenerateRandomString function.

        if (S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);
        }

        if(S_OK != hr) 
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Calculate the CRC for stream name and data

        if (S_OK == hr)
        {
            hr = CalculateInMemoryCRCForStm(
                    pvsnRootNewChildStream,
                    ptcsBuffer,
                    culRandIOBytes,
                    (dwMemCRC+index));
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
        }

        index++;
    }

    // Log while loop result

    DH_HRCHECK(hr, TEXT("While loop - GenrateRandomName/IStream::Write,CRC"));
	
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write completed successfully.")));
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtulaStmNode::Close unsuccessful, hr=0x%lx."), 
                hr));
        }
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successfully, hr=0x%lx."),
            hr));
        }
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open wasn't successfully, hr=0x%lx."),
            hr));
    }

    // Open stream
  
    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  ,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open wasn't successfully, hr=0x%lx."),
            hr));
    }

    // Read and verify

    index = 0;

    culRandIOBytes = tmpBytes;

    while ((S_OK == hr) && (0 != culBytesLeftToRead))
    {

        if (culBytesLeftToRead > culRandIOBytes)
        {
            culBytesLeftToRead = culBytesLeftToRead - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToRead;
            culBytesLeftToRead = 0;
        }

        // Allocate a buffer of required size

        if (S_OK == hr)
        {
            ptcsBuffer = new TCHAR [culRandIOBytes];

            if (NULL == ptcsBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            memset(ptcsBuffer, '\0',  culRandIOBytes*sizeof(TCHAR));

            hr =  pvsnRootNewChildStream->Read(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culRead);
        }

        if (S_OK != hr) 
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Calculate the CRC for stream name and data

        if (S_OK == hr)
        {
            hr = CalculateInMemoryCRCForStm(
                    pvsnRootNewChildStream,
                    ptcsBuffer,
                    culRandIOBytes,
                    (dwActCRC+index));

            DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm"));
        }

        // Compare corresponding dwMemCRC and dwActCRC and verify

        if (S_OK == hr)
        {
            if ( (*(dwActCRC+index)).dwCRCSum != (*(dwMemCRC+index)).dwCRCSum )
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for pvsnNewChildStream don't match. ")));
				
                fPass = FALSE;
                break;
            }
        }

        // Delete temp buffer

        if (NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
        }

        index++;
    }

    // Log results of while loop

    DH_HRCHECK(hr, TEXT("While loop - GenrateRandomName/IStream::Write,CRC"));
	
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write completed successfully.")));
    }

    if (S_OK == hr)
    {
        if (TRUE == fPass)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for pvsnNewChildStream all matched.")));
        }
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_103 failed, hr=0x%lx."),
            hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    if (NULL != dwMemCRC)
    {
        delete []dwMemCRC;
        dwMemCRC = NULL;
    }

    if (NULL != dwActCRC)
    {
        delete []dwActCRC;
        dwActCRC = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_104 
//
// Synopsis: Create a root docfile and an IStream in that. Write to IStream.
//       The test seeks to the end of the IStream to determine the size
//       and then makes 4 seek passes through the IStream:
//       
//          1)  Seek cumulative offset from STREAM_SEEK_SET (beginning)
//              to end, then rewind IStream to beginning
//          2)  Seek relative offset from STREAM_SEEK_CUR (current)
//              to end, then seek IStream to end
//          3)  Seek negative cumulative offset from STREAM_SEEK_END (end)
//              to beginning, then seek IStream to end
//          4)  Seek negative relative offset from STREAM_SEEK_CUR (current)
//              to beginning
//          5)  Perform several random large offset seeks from
//              STREAM_SEEK_SET (beginning)
//          6)  Attempt to write one byte at the current position in stream
//
//          The root docfile and stream are then releases and root docfile
//          deleted
//
//          Note: It is an error to seek before beginning of stream (tested
//          in part 4, but it is not an error to seek past end of stream.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    2-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LSSEEK.CXX
// 2.  Old name of test : LegitStreamSeek test 
//     New Name of test : STMTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:dirReadWriteShEx  /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShEx /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /labmode 
//     d. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:dirReadWriteShEx  /labmode /stdblock
//     e. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShEx /labmode /stdblock
//     f. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /labmode /stdblock 
//     g. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:dirReadWriteShEx  /labmode /stdblock /lgseekwrite
//     h. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShEx /labmode /stdblock /lgseekwrite
//     i. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /labmode /stdblock /lgseekwrite
//
// BUGNOTE: Conversion: STMTEST-104
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    DWORD           dwRootMode              = 0;
    ULONG           culRandIOBytes          = 0;
    ULONG           culBytesLeftToWrite     = 0;
    ULONG           ulStreamSize            = 0;
    LONG            lSeekThisTime           = 0;
    ULONG           cArrayIndex             = 0;
    ULONG           ulCurrentPosition       = 0;
    ULONG           cNumVars                = 0;
    ULONG           cMinVars                = 5;
    ULONG           cMaxVars                = 10;
    BOOL            fPass                   = TRUE;
    LARGE_INTEGER   liStreamPos;
    LARGE_INTEGER   liSeekThisTime;
    ULARGE_INTEGER  uli;
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream Seek operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 0L, and MIN_SIZE * 1.5
        // (range taken from old test).

        usErr = pdgi->Generate(&culBytesLeftToWrite, 0,(ULONG)(MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Loop to write new IStream in RAND_IO size chunks unless size
    // remaining to write is less than RAND_IO, then write the remaining bytes

    while((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        culRandIOBytes = RAND_IO_MIN;

        if(culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size culRandomBytes
        // using GenerateRandomString function.

        if(S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Now seek to the end of this stream and determine its size

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        // Seek to end of stream and determine size of stream 

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
    }

    if(S_OK == hr)
    {
        ulStreamSize = ULIGetLow(uli);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // loop through the entire IStream, each time seeking relative to the
    // beginning of the IStream (STREAM_SEEK_SET).  The amount to add to
    // the offset from the beginning is a random number or a random array
    // element of ausSIZE_ARRAY if command line option specifies that. 

    memset(&uli, 0, sizeof(LARGE_INTEGER));

    while ((ulCurrentPosition < ulStreamSize) && (S_OK == hr))
    {
        hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

        DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

        if(S_OK == hr)
        {
            LISet32(liSeekThisTime, lSeekThisTime);
            hr = pvsnRootNewChildStream->Seek(
                    liSeekThisTime, 
                    STREAM_SEEK_SET, 
                    &uli);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

            ulCurrentPosition = ULIGetLow(uli);
        }
    }

    DH_TRACE((
        DH_LVL_TRACE1, 
        TEXT("Current position is now %lu"), 
        ulCurrentPosition));

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(
                liStreamPos, 
                STREAM_SEEK_SET, 
                &uli);

        ulCurrentPosition = ULIGetLow(uli);
    
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // loop through the entire IStream, each time seeking relative to the
    // current seek pointer (STREAM_SEEK_CUR).  The distance to seek is a
    // random ushort.

    lSeekThisTime = 0;

    memset(&uli, 0, sizeof(LARGE_INTEGER));

    while ((ulCurrentPosition < ulStreamSize) && (S_OK == hr))
    {
        hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

        DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

        if(S_OK == hr)
        {    
            LISet32(liSeekThisTime, lSeekThisTime);

            hr = pvsnRootNewChildStream->Seek(
                    liSeekThisTime, 
                    STREAM_SEEK_CUR, 
                    &uli);

            ulCurrentPosition = ULIGetLow(uli);
    
            DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
        }
    }

    DH_TRACE((
        DH_LVL_TRACE1, 
        TEXT("Current position is now %lu"), 
        ulCurrentPosition));

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // Seek to the end of Stream.  Then we would seek negative cumulative 
    // offset from the STREAM_SEEK_END.

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        memset(&uli, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(
                liStreamPos, 
                STREAM_SEEK_END, 
                &uli);
    
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulCurrentPosition = ULIGetLow(uli);
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // loop through the entire IStream, each time seeking relative to the
    // end of the IStream (STREAM_SEEK_END).  The amount to add to
    // the offset from the end is a random ushort
 
    lSeekThisTime = 0;

    memset(&uli, 0, sizeof(LARGE_INTEGER));
    
    while ((ulCurrentPosition != 0) && (S_OK == hr))
    {
        hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

        DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

        // if generated seek offset would cause a seek to before beginning 
        // of file, ensure that it won't do that by enforcing to seek to
        // the beginnining.

        if(S_OK == hr)
        {
            if(lSeekThisTime > (LONG) ulStreamSize)
            {
                lSeekThisTime = (LONG) ulStreamSize;
            }

            // Unary minus opeartion is applied to seek offset to cause a neg
            // seek opeartion
 
            LISet32(liSeekThisTime, -lSeekThisTime);

            hr = pvsnRootNewChildStream->Seek(
                    liSeekThisTime, 
                    STREAM_SEEK_END, 
                    &uli);
    
            DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

            ulCurrentPosition = ULIGetLow(uli);
        }
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        memset(&uli, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(
                liStreamPos, 
                STREAM_SEEK_END, 
                &uli);
    
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulCurrentPosition = ULIGetLow(uli);
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    //loop through the entire IStream, each time seeking relative to the
    //current seek pointer (STREAM_SEEK_CUR).  The distance to seek is a
    //random ushort or a random block size chosen from ausSIZE_ARRAY[].
    //This loop seeks in a negative direction.

    lSeekThisTime = 0;

    memset(&uli, 0, sizeof(LARGE_INTEGER));
    
    while ((ulCurrentPosition != 0) && (S_OK == hr))
    {
        hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

        DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

        // if generated seek offset would cause a seek to before beginning 
        // of file, ensure that it won't do that by enforcing to seek to
        // the beginnining.

        if(S_OK == hr)
        {
            if(lSeekThisTime > (LONG) ulCurrentPosition)
            {
                lSeekThisTime = (LONG) ulCurrentPosition;
            }

            // Unary minus operation is applied to seek offset to cause a neg
            // seek opeartion
 
            LISet32(liSeekThisTime, -lSeekThisTime);

            hr = pvsnRootNewChildStream->Seek(
                    liSeekThisTime, 
                    STREAM_SEEK_CUR, 
                    &uli);
    
            DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

            ulCurrentPosition = ULIGetLow(uli);
        }
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        memset(&uli, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(
                liStreamPos, 
                STREAM_SEEK_SET, 
                &uli);
    
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulCurrentPosition = ULIGetLow(uli);
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // Peform random number of seeks before beginning of the stream.

    if (S_OK == hr)
    {
        // Generate random number of variations to be done.

        usErr = pdgi->Generate(&cNumVars, cMinVars, cMaxVars);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        while((cNumVars--) && (S_OK == hr))
        {
            hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

            DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

            if(S_OK == hr)
            {
                // Unary minus operation is applied to seek offset to cause a
                // negative seek opeartion
 
                LISet32(liSeekThisTime, -lSeekThisTime);

                hr = pvsnRootNewChildStream->Seek(
                        liSeekThisTime, 
                        STREAM_SEEK_CUR, 
                        &uli);
    
                ulCurrentPosition = ULIGetLow(uli);

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Seek to pos - %ld on IStream should have failed."),
                        lSeekThisTime));

                    fPass = FALSE;
                    break;
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Seek pos -%ld on IStream failed as exp, hr=0x%lx."),
                        lSeekThisTime,
                        hr));

                    hr = S_OK;
                }
            }
        }
    }

    // Now perform large offset seeks on IStream and the try to write 1 byte
    // at the last offset if g_fDoLargeSeekAndWrite is set.

    if (S_OK == hr)
    {
        // Generate random number of variations to be done.

        usErr = pdgi->Generate(&cNumVars, cMinVars, cMaxVars);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        while((cNumVars--) && (S_OK == hr))
        {
            hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

            DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

            if(S_OK == hr)
            {    
                LISet32(liSeekThisTime, lSeekThisTime);

                hr = pvsnRootNewChildStream->Seek(
                        liSeekThisTime, 
                        STREAM_SEEK_SET, 
                        &uli);
    
                ulCurrentPosition = ULIGetLow(uli);
            }   
        }
    }
    
    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // Now atempt to write

    LPTSTR  ptszSample = TEXT("Test");

    if((TRUE == g_fDoLargeSeekAndWrite) && (S_OK == hr))
    {
        hr =  pvsnRootNewChildStream->Write(
                ptszSample,
                1,
                NULL);

        if((S_OK == hr)             || 
           (STG_E_MEDIUMFULL == hr) || 
           (STG_E_INSUFFICIENTMEMORY == hr))
        {
            DH_TRACE((DH_LVL_TRACE1,
                    TEXT("Attempt to write 1 byte at offset %lu, hr = 0x%lx"),
                    ulCurrentPosition,  
                    hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1,
                    TEXT("Attempt to write 1 byte ar offset %lu, hr = 0x%lx"),
                    ulCurrentPosition,  
                    hr));
        }
    }

    // Release root's child stream

    if (NULL != pvsnRootNewChildStream)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // Release root 

    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
              TEXT("Test variation STMTEST_104 failed, hr=0x%lx."),
              hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    STMTEST_105 
//
// Synopsis: The test create a root docfile with a child IStream. Write a
//           random number of bytes to the IStream and commit the root
//           docfile. 
//
//           The test seeks to a position before the end of the IStream,
//           SetSizes() the IStream to a size less than the current seek
//           pointer position. The root docfile is committed. Verify that 
//           the seek pointer didn't change during the SetSize() call. Now
//           write 0 bytes at the current seek pointer position(which is 
//           beyond the end of the IStream). The seek pointer still should 
//           not move and no error should occur. Finally, seek to the end of
//           the IStream and verify the correct IStream size, then stream and 
//           the root docfile are released and the root file is deleted upon 
//           success.
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LSETSIZA.CXX
// 2.  Old name of test(s) : LegitStreamSetSizeAbandon test 
//     New Name of test(s) : STMTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-105
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-105
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-105
//        /dfRootMode:xactReadWriteShDenyW 
//
// History:  Jiminli	16-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-105
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_105(int argc, char *argv[])
{

    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    DG_STRING      *pdgu                       = NULL;
    DG_INTEGER      *pdgi                       = NULL;
    USHORT          usErr                       = 0;
    VirtualStmNode  *pvsnRootNewChildStream     = NULL;
    LPTSTR          pRootNewChildStmName        = NULL;
    LPTSTR          ptcsBuffer                  = NULL;
    ULONG           culBytesLeftToWrite         = 0;
    ULONG           culWritten                  = 0;
    ULONG           culRead                     = 0;
    DWORD           dwRootMode                  = 0; 
    ULONG           culRandIOBytes              = 0;
    ULONG           ulRandOffset                  = 0;  
    ULONG           ulOriginalPosition          = 0;
    ULONG           ulNewPosition               = 0;
    ULONG           ulSizeParam                 = 0;
    BOOL            fPass                       = TRUE;
    ULARGE_INTEGER  uli;
    ULARGE_INTEGER  uliOffset;
    LARGE_INTEGER   liStreamPos;
    LARGE_INTEGER   liOffset;


    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_105 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt SetSize using the IStream interface.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 4L, and MIN_SIZE * 1.5
        // (from old test)

        usErr = pdgi->Generate(&culBytesLeftToWrite,4L,(ULONG)(MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        // Generate random number of bytes to write per chunk b/w 
        // RAND_IO_MIN and RAND_IO_MAX.
		
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Loop to write new IStream in culRandIOBytes size chunks unless size 
    // remaining to write is less than culRandIOBytes, then write the 
    // remaining bytes. CRC is not important for this test, so no check for it.

    while ((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        if (culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size culRandIOBytes
        // using GenerateRandomString function.

        if (S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }
	
    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    // Seek to the end of stream

    if (S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulOriginalPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed Ok. EndofStream = %lu"),
			ulOriginalPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx. EndofStream = %lu"),
            hr, 
			ulOriginalPosition));
    }

    // Seeking to a negative value from end

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulRandOffset, 1L, ulOriginalPosition / 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Seek to end of IStream - %lu bytes"),
                ulRandOffset));
        }
    }
 
    if(S_OK == hr)
    {
        LISet32(liOffset, (- (LONG)ulRandOffset));

        hr = pvsnRootNewChildStream->Seek(liOffset, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulOriginalPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed Ok. New seek ptr=%lu"),
			ulOriginalPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Seek wasn't Ok, hr=0x%lx. New seek ptr=%lu"),
            hr, 
			ulOriginalPosition));
    }

    // Generate number of bytes less than current seek pointer to 
    // SetSize the stream to.

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulRandOffset, 1L, ulOriginalPosition / 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Random offset(i.e. new size of stream) = %lu bytes"),
                ulRandOffset));
        }
    }

    if (S_OK == hr)
    {
        ulSizeParam = ulOriginalPosition - ulRandOffset;

        ULISet32(uliOffset, ulSizeParam);

        hr = pvsnRootNewChildStream->SetSize(uliOffset);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize")) ;
    }
	
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::SetSize completed successfully. Size=%lu"),
            ulSizeParam));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::SetSize unsuccessful, hr=0x%lx, Size=%lu"),
            hr,
            ulSizeParam));
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    // Get current seek pointer, should be same as ulOriginalPosition

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_CUR, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulNewPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully. Seek ptr=%lu"),
			ulNewPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx, seek ptr=%lu"),
            hr, 
			ulNewPosition));
    }	

    if (S_OK == hr)
    {
        if (ulOriginalPosition != ulNewPosition)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::SetSize changed seek ptr position.")));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Ok, VirtualCtrNode::SetSize not change seek ptr.")));
        }
    }

    // Tset 0 byte write beyond end of IStream, shouldn't move seek pointer

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                0,
                0, 
                &ptcsBuffer);	 

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Write(
                ptcsBuffer,
                0,
                &culWritten);
    } 

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Get current seek pointer, should be same as ulOriginalPosition

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_CUR, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulNewPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully. Seek ptr=%lu"),
            ulNewPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx, Seek ptr=%lu"),
            hr, 
            ulNewPosition));
    }	

    if (S_OK == hr)
    {
        if (ulOriginalPosition != ulNewPosition)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("0 byte write changed seek pointer position.")));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Ok, 0 byte write not change seek pointer position.")));
        }
    }

    // Verify correct end of IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulNewPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully. EndofStm=%lu"),
			ulNewPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx, EndofStm=%lu"),
            hr, 
            ulNewPosition));
    }	

    if (S_OK == hr)
    {
        if (ulSizeParam != ulNewPosition)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Seek to end is not same position as SetSize().")));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Ok, Seek to end is the same position as SetSize().")));
        }
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_105 failed, hr=0x%lx."),
            hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_106 
//
// Synopsis: The test create a root docfile with a child IStream. 3 random 
//           SECTORSIZE byte blocks are generated and the CRC is computed. 
//           The data is written to the IStream. then the IStream is 
//           rewound and read back, and the CRC returned from the read is
//           compared with the CRC when written. The seek pointer is changed
//           to an offset somewhere in the first sector, but not the first
//           or last byte. A SECTORSIZE block of the in-memory buffer is 
//           changed starting at the same offset used for the seek. The CRC
//           is computed for the entire memory buffer. The block is written
//           to the IStream, the IStream is rewound, read, and the CRCs are
//           again compared. Finally, the root docfile is committed and the
//           read/CRC compare is repeated. Then stream and the root docfile 
//           are released and the root file is deleted upon success.
//           
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LSECTSPN.CXX
// 2.  Old name of test(s) : LegitStreamSectorSpan test 
//     New Name of test(s) : STMTEST_106 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-106
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-106
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-106
//        /dfRootMode:xactReadWriteShDenyW 
//
// History:  Jiminli	18-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-106
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_106(int argc, char *argv[])
{

    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          ptTempBuf1              = NULL;
    LPTSTR          ptTempBuf2              = NULL;
    LPBYTE          ptcsBuffer              = NULL;
    LPBYTE          ptcsDataBuffer          = NULL;
    ULONG           culNumBytes             = 0;
    ULONG           culWritten              = 0;
    ULONG           ulRandOffset            = 0; 
    ULONG           culRead                 = 0;
    ULONG           index1                  = 0;
    ULONG           index2                  = 0;
    DWORD           dwRootMode              = 0; 
    DWORD           dwBufCRC                = 0;
    DWORD           dwActCRC                = 0; 
    BOOL            fPass                   = TRUE; 
    LARGE_INTEGER   liZero;
    LARGE_INTEGER   liOffset;
    ULARGE_INTEGER  uli;
    ULONG           ulOriginalPosition      = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_106 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt SectorSpan using the Stm interface.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_106, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds a new stream to the root storage.

    if (S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // Generate three sectors worth of random bytes and compute CRC
    // then write the bytes to the IStream, rewind IStream, then read
    // back the data and compare CRCs to ensure valid write/read

    if (S_OK == hr)
    {
        // Generate a random string of size culNumBytes

        culNumBytes = SECTORSIZE * 3;

        hr = GenerateRandomString(
                pdgu, 
                culNumBytes,
                culNumBytes, 
                &ptTempBuf1);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }
 
    if (S_OK == hr)
    {
        // Let ptcsBuffer point to temporary buffer(for purpose of 
        // type casting, because IStream:Seek proceeds by BYTE)

        ptcsBuffer = (LPBYTE)ptTempBuf1;

        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsBuffer,
                culNumBytes,
                &dwBufCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Write(
                ptcsBuffer,
                culNumBytes,
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write function not successful, hr=0x%lx."),
            hr));
    }

    // Allocate required space

    if (S_OK == hr)
    {
        ptcsDataBuffer = new BYTE[culNumBytes];

        if (NULL == ptcsDataBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        memset(ptcsDataBuffer, '\0', culNumBytes * sizeof(BYTE));

        while (culNumBytes--)
        {
           ptcsDataBuffer[index1] = ptcsBuffer[index1];
           index1++;
        }

        culNumBytes = SECTORSIZE * 3;
    }
    
    // delete temp buffer (ptcsBuffer and ptTempBuf1 point to the same memory)

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
        ptTempBuf1 = NULL;
    }

    if (S_OK == hr)
    {
		LISet32(liZero, 0L);

		hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        ptcsBuffer = new BYTE[culNumBytes];

        if (NULL == ptcsBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        memset(ptcsBuffer, '\0', culNumBytes * sizeof(BYTE));

        hr = pvsnRootNewChildStream->Read(
                ptcsBuffer,
                culNumBytes,
                &culRead);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsBuffer,
                culNumBytes,
                &dwActCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Compare CRCs 

    if (S_OK == hr)
    {
        if (dwBufCRC != dwActCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read mismatch before change, hr=0x%lx."),
                hr));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read matched before change.")));
        }
    }
 
    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }
  
    // Pick a random offset somewhere in the first sector, but not the first
    // or last byte. Seek to the new position. Starting at the same offset in 
    // the in-memory buffer, replace 1 SECTORSIZE block with new random data.
    // After the replace, re-compute the CRC for the entire buffer.
 
    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulRandOffset, 1, (SECTORSIZE - 1));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Seek to position of the first SECTOR: %lu"),
                (ULONG)ulRandOffset));
        }
    }
 
	if (S_OK == hr)
    {
        LISet32(liOffset, ulRandOffset);

        hr = pvsnRootNewChildStream->Seek(liOffset, STREAM_SEEK_SET, &uli);
 
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulOriginalPosition = ULIGetLow(uli);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Seekpos = %lu"),
            ulOriginalPosition));         
 	}

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Seek wasn't successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate a random string of size SECTORSIZE

        hr = GenerateRandomString(
                pdgu, 
                SECTORSIZE,
                SECTORSIZE, 
                &ptTempBuf2);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }
  
    if (S_OK == hr)
    {
        // Let ptcsBuffer point to the temporary buffer(for purpose of 
        // typecasting, because IStream::Seek proceeds by BYTE)

        ptcsBuffer = (LPBYTE)ptTempBuf2;

        // Change the memory buffer ptcsDataBuffer

        culNumBytes = SECTORSIZE;
        index1 = ulRandOffset;
        index2 = 0;

        while (culNumBytes--)
        {
            ptcsDataBuffer[index1++] = ptcsBuffer[index2++];            
        }

        culNumBytes = SECTORSIZE * 3;

        // Calculate CRC for the changed buffer

        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsDataBuffer,
                culNumBytes,
                &dwBufCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }
 
    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Write(
                ptcsBuffer,
                SECTORSIZE,
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write function not successful, hr=0x%lx."),
            hr));
    }
 
    // delete temp buffer (ptcsBuffer and ptTempBuf2 point to the same memory)

    if ( NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
        ptTempBuf2 = NULL;
    }

    if (S_OK == hr)
    { 
        memset(&liZero, 0, sizeof(LARGE_INTEGER));

		hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        ptcsBuffer = new BYTE[culNumBytes];

        if (NULL == ptcsBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        memset(ptcsBuffer, '\0', culNumBytes * sizeof(BYTE));

        hr = pvsnRootNewChildStream->Read(
                ptcsBuffer,
                culNumBytes,
                &culRead);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsBuffer,
                culNumBytes,
                &dwActCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Compare CRCs 

    if (S_OK == hr)
    {
        if (dwBufCRC != dwActCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read mismatch after change, hr=0x%lx."),
                hr));
 
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read matched after change.")));
        }
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    if ( NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    if (S_OK == hr)
    { 
        memset(&liZero, 0, sizeof(LARGE_INTEGER));

		hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        ptcsBuffer = new BYTE[culNumBytes];

        if (NULL == ptcsBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        memset(ptcsBuffer, '\0', culNumBytes * sizeof(BYTE));

        hr = pvsnRootNewChildStream->Read(
                ptcsBuffer,
                culNumBytes,
                &culRead);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsBuffer,
                culNumBytes,
                &dwActCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Compare CRCs 

    if (S_OK == hr)
    {
        if (dwBufCRC != dwActCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read mismatch after commit, hr=0x%lx."),
                hr));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read matched after commit.")));
        }
    }
    
    // Delete temp buffers

    if (NULL != ptcsDataBuffer)
    {
        delete []ptcsDataBuffer;
        ptcsDataBuffer = NULL;
    }
 
    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
              TEXT("Test variation STMTEST_106 failed, hr=0x%lx."),
              hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

	DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_106 finished")) );
	DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

	return hr;
}


//----------------------------------------------------------------------------
//
// Test:    STMTEST_107 
//
// Synopsis: The test create a root docfile with a child IStream. Then perform
//           various illegitimate operating using the IStream interface. The 
//           stream and the root docfile are then released and the root file 
//           is deleted upon success.
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): ISNORM.CXX
// 2.  Old name of test(s) : IllegitStreamNorm test 
//     New Name of test(s) : STMTEST_107 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-107
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-107
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-107
//        /dfRootMode:xactReadWriteShDenyW 
//
// History:  Jiminli	14-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-107
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_107(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    HRESULT         hr1                         = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    DG_STRING      *pdgu                       = NULL;
    DG_INTEGER      *pdgi                       = NULL;
    USHORT          usErr                       = 0;
    VirtualStmNode  *pvsnRootNewChildStream0    = NULL;
    VirtualStmNode  *pvsnRootNewChildStream1    = NULL;
    LPSTREAM        pstm0                       = NULL;
    LPSTREAM        pstm1                       = NULL;
    LPSTREAM        pCloneStm                   = NULL;
    LPTSTR          pRootNewChildStmName0       = NULL;
    LPTSTR          pRootNewChildStmName1       = NULL;
    LPTSTR          ptcsBuffer                  = NULL;
    ULONG           culWritten                  = 0;
    ULONG           culRead                     = 0;
    DWORD           dwRootMode                  = 0; 
    ULONG           culRandIOBytes              = 0;
    ULONG           ulRef                       = 0;
    BOOL            fPass                       = TRUE; 
    ULARGE_INTEGER  uliCopy;
    LARGE_INTEGER   liOffset;
    LARGE_INTEGER   liZero;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_107"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_107 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt illegitimate operations on IStream.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_107, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootNewChildStmName0);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName0,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream0);

        DH_HRCHECK(hr, TEXT("AddFirstStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode0::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode0::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // Generate random number of bytes to write to stream b/w
    // RAND_IO_MIN and RAND_IO_MAX.

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Call Virtual::Write to create random bytes in the stream. For our test
    // purposes, we generate a random string of size culRandIOBytes using
    // GenerateRandomString function.

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu,
                culRandIOBytes,
                culRandIOBytes,
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream0->Write(
                ptcsBuffer,
                culRandIOBytes,
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Adds another new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootNewChildStmName1);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName1,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream1);

        DH_HRCHECK(hr, TEXT("AddSecondStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode1::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode1::AddStream not successful, hr=0x%lx."),
            hr));
    }
	
    // Pass NULL pv to read call, should fail

    if (S_OK == hr)
    {
        pstm0 = pvsnRootNewChildStream0->GetIStreamPointer();
        pstm1 = pvsnRootNewChildStream1->GetIStreamPointer();

        DH_ASSERT(NULL != pstm0);
        DH_ASSERT(NULL != pstm1);
    }

    if (S_OK == hr)
    {
        hr1 = pstm0->Read(
                NULL,
                culRandIOBytes,
                &culRead);

        if (STG_E_INVALIDPOINTER != hr1)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Read should return STG_E_INVALIDPOINTER, hr=0x%lx."),
                hr1));
		
            fPass = FALSE;
		
        }
        else 
        {	
            // Reset hr value for other tests

            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Read failed as expected, hr=0x%lx."),
                hr1));

            hr1 = S_OK;
        }
    }

    //
    // coverage for bug# 143546
    // 
    
    //
    // commented out to avoid av'ing;
    // we should activate it when bug it's fixed
    //

/*
    if (S_OK == hr)
    {
        const char *szDummy = "foo"; // readonly        
        
        // make stream nonempty

         HRESULT hr2 = pstm0->Write(szDummy, strlen(szDummy), &culWritten);
        DH_HRCHECK(hr2, TEXT("IStream::Write"));

        if (S_OK == hr2)
        {
            LARGE_INTEGER li;
            LISet32(li, 0L);
            hr2 = pstm0->Seek(li, SEEK_SET,NULL);
            DH_HRCHECK(hr2, TEXT("IStream::Seek SEEK_SET"));
        }

        if(S_OK == hr2)
        {
        
            hr1 = pstm0->Read((void*)szDummy,
                              strlen(szDummy),
                              &culRead);
            if (STG_E_INVALIDPOINTER != hr1)
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("Read should return STG_E_INVALIDPOINTER when in buffer is readonly, hr=0x%lx."),
                    hr1));
		    
                fPass = FALSE;
		    
            }
            else 
            {	
                // Reset hr value for other tests

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Read failed as expected, hr=0x%lx."),
                    hr1));

                hr1 = S_OK;
            }
        }

        if(S_OK == hr2)
        {
            // restore empty stream

            ULARGE_INTEGER uli;
            LISet32(uli, 0L);
            hr = pstm1->SetSize(uli);
            DH_HRCHECK(hr, TEXT("IStream::SetSize 0"));
        }
    }

*/

    // Pass NULL pv to write call, should fail

    if (S_OK == hr)
    {
        hr1 = pstm1->Write(
                NULL,
                culRandIOBytes,
                &culWritten);

        if (STG_E_INVALIDPOINTER != hr1)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Write should return STG_E_INVALIDPOINTER, hr=0x%lx."),
            hr1));
		
            fPass = FALSE;
        }
        else 
        { 	
            // Reset hr value for other tests
		
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Write failed as expected, hr=0x%lx."),
            hr1));

            hr1 = S_OK;
        }
    }

    // Pass NULL ppstm to clone call, should fail

    if (S_OK == hr)
    {
        hr1 = pstm0->Clone(
                NULL);

        if (STG_E_INVALIDPOINTER != hr1)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Clone should have failed, hr=0x%lx."),
            hr1));

            fPass = FALSE;
        }
        else 
        {	
            // Reset hr value for other tests

            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Clone failed as expected, hr=0x%lx."),
            hr1));

            hr1 = S_OK;
        }
    }
	
    // Pass NULL pstm to CopyTo call, should fail
    
    if(S_OK == hr)
    {
        ULISet32(uliCopy, culRandIOBytes);

        hr1 = pstm0->CopyTo(NULL, uliCopy, NULL, NULL);

        if (STG_E_INVALIDPOINTER != hr1)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CopyTo should have failed, hr=0x%lx."),
                hr1));
		
            fPass = FALSE;
        }
        else 
        {	
            // Reset hr value for other tests

            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("CopyTo failed as expected, hr=0x%lx."),
            hr1));

            hr1 = S_OK;
        }
    }

    // Pass 'cb' > length of stream to CopyTo(), should pass

    if (S_OK == hr)
    {
        ULISet32(uliCopy, ULONG_MAX);

        hr1 = pvsnRootNewChildStream0->CopyTo(
                pvsnRootNewChildStream1,
                uliCopy,
                NULL,
                NULL);

        if (S_OK == hr1)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo not successful, hr=0x%lx."),
            hr1));
        }
    }

    // Release Stream1

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream1->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode1::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode1::Close unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // Pass 'cb' > length of stream to CopyTo() w/dest Clone() of Istream,
    // should pass

    if(S_OK == hr)
    {
        LISet32(liZero, 0L);

        hr1 = pvsnRootNewChildStream0->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr1, TEXT("IStream::Seek")) ;
        if (S_OK == hr1)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream0::Seek function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream0::Seek function wasn't successful, hr=0x%lx."),
                hr1));
        }
    }

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream0->Clone(&pCloneStm);

        DH_HRCHECK(hr, TEXT("IStream::Clone"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Clone function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Clone function wasn't successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pstm0->CopyTo(pCloneStm, uliCopy, NULL, NULL);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo not successful, hr=0x%lx."),
            hr));
    }

    // Pass 'cb' > length of stream to CopyTo() w/dest Clone() of IStream,
    // and seek pointer in source stream past end of file, should pass
    // This also tests seek function in case of seeking past end of stream

    if(S_OK == hr)
    {
        LISet32(liOffset, culRandIOBytes);

        hr = pvsnRootNewChildStream0->Seek(liOffset, STREAM_SEEK_CUR, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::Seeking past the end of stream successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::Seek past end of stream not Ok, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pstm0->CopyTo(pCloneStm, uliCopy, NULL, NULL);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo not successful, hr=0x%lx."),
            hr));
    }

    // Pass invalid dwOrigin(from old test) to seek call, should fail

    if (S_OK == hr)
    {
        hr1 = pstm0->Seek(
                liZero, 
                STREAM_SEEK_SET | STREAM_SEEK_CUR | STREAM_SEEK_END, 
                NULL);

        if (STG_E_INVALIDFUNCTION != hr1)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Seek should have failed, hr=0x%lx."),
            hr1));
		
            fPass = FALSE;
        }
        else 
        {	
            // Reset hr value for other tests

            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Seek failed as expected, hr=0x%lx."),
            hr1));

            hr1 = S_OK;
        }
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
	    DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    //Release streams

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream0->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode0::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode0::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Clone stream

    if (NULL != pCloneStm)
    {
        ulRef = pCloneStm->Release();

        DH_ASSERT(0 == ulRef);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream1::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream1::Close unsuccessful.")));
    }
	
    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_107 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_107 failed, hr=0x%lx."),
            hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName0)
    {
        delete pRootNewChildStmName0;
        pRootNewChildStmName0 = NULL;
    }

    if (NULL != pRootNewChildStmName1)
    {
        delete pRootNewChildStmName1;
        pRootNewChildStmName1 = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_107 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_108 
//
// Synopsis: The test create a root docfile with an IStream inside of it.   
//           A random block small object size block is generated and the CRC 
//           is computed. The data is written to the IStream. The IStream is
//           rewound and read back. The CRC returned from the read is compared
//           with the CRC computed during generation. A new random block bigger
//           larger than small object size is generated at a random offset
//           in the data buffer, and then the block is written to the IStream
//           at that offset.  This has the effect of transforming the small
//           object into a regular object.  The IStream is then rewound, read,
//           and the read/write CRCs are compared.  After a commit of the root
//           docfile, the rewind, read, CRC compare is repeated.  A random
//           small object size is then chosen and the IStream is SetSized
//           back to that size.  The CRC is computed for the in-memory data
//           buffer up to the new size.  The IStream is rewound, read back,
//           and CRC'd.  The read/write CRCs are again compared to verify
//           that the shrink back to small object size retained the correct
//           data.  After the root docfile is committed, we rewind, read,
//           and compare read/write CRCs again.  From 10 to 20 small objects
//           are processed this way.
//           Then stream and the root docfile are released and the root file 
//           is deleted upon success.
//           
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LSSMALLO.CXX
// 2.  Old name of test(s) : LegitStreamSmallObjects test 
//     New Name of test(s) : STMTEST_108 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-108
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-108
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-108
//        /dfRootMode:xactReadWriteShDenyW 
//
// History:  Jiminli	23-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-108
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_108(int argc, char *argv[])
{

    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          ptTempBuf1              = NULL;
    LPTSTR          ptTempBuf2              = NULL;
    LPBYTE          ptcsBuffer              = NULL;
    LPBYTE          ptcsReadBuffer          = NULL;
    LPBYTE          ptChangeBuf             = NULL;
    USHORT          cusNumSmallObjects      = 0;
    USHORT          cusMinSmallObjects      = 10;
    USHORT          cusMaxSmallObjects      = 20;
    ULONG           culNumBytes             = 0;
    ULONG           culIOBytes              = 0;
    ULONG           culWritten              = 0;
    ULONG           ulRandOffset            = 0; 
    ULONG           culRead                 = 0;
    ULONG           index                   = 0;
    DWORD           dwRootMode              = 0; 
    DWORD           dwBufCRC                = 0;
    DWORD           dwActCRC                = 0; 
    BOOL            fPass                   = TRUE; 
    LARGE_INTEGER   liZero;
    LARGE_INTEGER   liOffset;
    ULARGE_INTEGER  uliOffset;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_108"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_108 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt IStream operations on small objects.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_108, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds a new stream to the root storage.

    if (S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate random # of small objects for test between  
        // cusMinSmallObjects and cusMaxSmallObjects

        usErr = pdgi->Generate(
                   &cusNumSmallObjects, 
                   cusMinSmallObjects,
                   cusMaxSmallObjects);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Random # of small objects to test is: %d"),
            cusNumSmallObjects));
    }

    // Loop for testing each small object

    while ((cusNumSmallObjects--) && (S_OK == hr))
    {
        // Pick a random size for this small object, generate data to 
        // write in memory, compute CRC for databuffer, and write it.

        usErr = pdgi->Generate(&culIOBytes, 0L, SMALL_OBJ_SIZE);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }     

        if (S_OK == hr)
        {
            culNumBytes = SMALL_OBJ_SIZE * 4 + 1;

            hr = GenerateRandomString(
                    pdgu, 
                    culNumBytes,
                    culNumBytes, 
                    &ptTempBuf1);
        }
 
        if (S_OK == hr)
        {
            // Let ptcsBuffer point to temporary buffer(for purpose of 
            // type casting, because IStream:Seek proceeds by BYTE)

            ptcsBuffer = (LPBYTE)ptTempBuf1;
            culNumBytes = culIOBytes;

            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsBuffer,
                    culNumBytes,
                    &dwBufCRC);
        }

        if (S_OK == hr)
        {
            hr = pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culNumBytes,
                    &culWritten);
        }

        if (S_OK != hr)
        {            
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Write wasn't successful, hr=0x%lx."),
                hr));
        }
 
        if (S_OK == hr)
        {
		    LISet32(liZero, 0L);
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {  
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }

        // read all data in the IStream(SMALL_OBJ_SIZE * 4) and compute CRC. 
        // We attempt to read SMALL_OBJ_SIZE * 4 instead of the number of bytes
        // actually written so we catch the case of extra data pegged onto the 
        // end of the stream. IStream::Read() returns the number of bytes 
        // actually read, which in this case should be culIOBytes. Next, 
        // compare r/w CRCs.

        if (S_OK == hr)
        {
            culNumBytes = SMALL_OBJ_SIZE * 4;
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Small object w/r mismatch before grow, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }         
        }
 
        // Delete temp buffer

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }
 
        // Pick a random offset somewhere in the small object to begin changing
        // data at. Position the IStream pointer to this location. Generate a
        // random number of bytes into the in-memory buffer starting at this
        // position, we generate enough new bytes to replace some that were
        // already in the IStream and to expand the IStream beyond small object
        // size.

        if (S_OK == hr)
        {
            usErr = pdgi->Generate(&ulRandOffset, 0L, culIOBytes);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }     
        }
 
        // Seek to the random offset

        if(S_OK == hr)
        {
            LISet32(liOffset, ulRandOffset);
            hr = pvsnRootNewChildStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek wasn't successful, hr=0x%lx"),
                hr)); 
	    }

        // Generate random nubmer of bytes to grow

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(
                    &culIOBytes, SMALL_OBJ_SIZE+1, SMALL_OBJ_SIZE*3);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }     

        if (S_OK == hr)
        {
            culNumBytes = culIOBytes;

            hr = GenerateRandomString(
                    pdgu, 
                    culNumBytes,
                    culNumBytes, 
                    &ptTempBuf2);
        }

        if (S_OK == hr)
        {
            ptChangeBuf = (LPBYTE)ptTempBuf2;

            for (index = 0; index < culIOBytes; index++)
            {
                ptcsBuffer[ulRandOffset+index] = ptChangeBuf[index];
            }
        }

        if (S_OK == hr)
        {
            // Calculate the new length of the object, and compute CRC for the
            // whole buffer

            culNumBytes = culIOBytes + ulRandOffset;

            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsBuffer,
                    culNumBytes,
                    &dwBufCRC);
        }

        if (S_OK == hr)
        {
            // Write growing data from seek pointer

            hr = pvsnRootNewChildStream->Write(
                    ptChangeBuf,
                    culIOBytes,
                    &culWritten);
        }

        if (S_OK != hr)
        {            
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Write wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
		    LISet32(liZero, 0L);
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {  
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }
 
        // Read back the entire IStream, compute the CRC, and compare r/w CRCs
        // Commit the root docfile and repeat this step

        if (S_OK == hr)
        {
            culNumBytes = SMALL_OBJ_SIZE * 4;
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Small object w/r mismatch after grow, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }         
        }
 
        // Delete temp buffer

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // Commit root. BUGBUG: Use random modes

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        }

        if (S_OK != hr)
        {             
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        { 
            memset(&liZero, 0, sizeof(LARGE_INTEGER));
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL); 
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream w/r mismatch after grow/commit, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }
         }
    
        // Delete temp buffers

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // Pick a random small object size to set the IStream to. Shrink the 
        // IStream with SetSize. Compute the CRC for the in-memory data buffer
        // up to the new size of the IStream.

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(&culIOBytes, 1L, SMALL_OBJ_SIZE);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }     

        if (S_OK == hr)
        { 
            ULISet32(uliOffset, culIOBytes);
            hr = pvsnRootNewChildStream->SetSize(uliOffset);
        }
	
        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::SetSize unsuccessful, hr=0x%lx"),
                hr));
        }
 
        if (S_OK == hr)
        { 
            culNumBytes = culIOBytes;  

            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsBuffer,
                    culNumBytes,
                    &dwBufCRC);
        }

        // Seek to beginning of IStream we just shrank, read the whole thing 
        // back, compute CRC, and compare r/w CRCs. Finally, commit the root 
        // docfile and repeat this step.

        if (S_OK == hr)
        {
		    LISet32(liZero, 0L);
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {  
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }
 
        if (S_OK == hr)
        {
            culNumBytes = SMALL_OBJ_SIZE * 4;
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Small object w/r mismatch after shrink, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }         
        }
 
        // Delete temp buffer

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // Commit root. BUGBUG: Use random modes

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        }

        if (S_OK != hr)
        {             
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        { 
            memset(&liZero, 0, sizeof(LARGE_INTEGER));
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL); 
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream w/r mismatch after shrink/commit,hr=0x%lx"),
                    hr));

                fPass = FALSE;
            }
         }
    
        // Delete temp buffers 
        // ptcsBuffer and ptTempBuf1 point to the same memory chunk
        // ptChangeBuf and ptTempBuf2 point to the same memory chunk

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        if (NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
            ptTempBuf1 = NULL;
        }

        if (NULL != ptTempBuf1)
        {
            delete []ptTempBuf1;
            ptTempBuf1 = NULL;
            ptcsBuffer = NULL;
        }

        if (NULL != ptTempBuf2)
        {
            delete []ptTempBuf2;
            ptTempBuf2 = NULL;
            ptChangeBuf = NULL;
        }

        // Reset IStream for next iteration of the loop

        if (S_OK == hr)
        {    
            ULISet32(uliOffset, 0L);
            hr = pvsnRootNewChildStream->SetSize(uliOffset);
        }
        
        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::SetSize unsuccessful, hr=0x%lx"),
                hr));   
        }
            
        if (S_OK == hr)
        {
            LISet32(liOffset, 0L);
            hr = pvsnRootNewChildStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek unsuccessful, hr=0x%lx"),
                hr));   
        }
        
        if ((S_OK != hr) || (TRUE != fPass))
        {
            break;
        }            
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_108 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
              TEXT("Test variation STMTEST_108 failed, hr=0x%lx."),
              hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_108 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_109 
//
// Synopsis:  Creates a root docfile with a random name. Creates an IStream in 
//       the root docfile and writes random number of bytes.  ILockRegion,
//       IUnlockRegion and Stat operations are attempted on stream.
//       The IStream and root are then released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    13-Aug-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: -part of common.cxx-
// 2.  Old name of test : 
//     New Name of test : STMTEST_109 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-109
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-109
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-109
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: STMTEST-109
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_109(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    ULONG           cb                      = 0;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    DWORD           dwRootMode              = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    BOOL            fPass                   = TRUE;
    LPMALLOC        pMalloc                 = NULL;
    STATSTG         statStg;
    ULARGE_INTEGER  uliOffset;
    ULARGE_INTEGER  uliBytes;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_109"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_109 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stm LockRegion/UnLockRegion/Stat ops")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_109, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE, 
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }

    // Call VirtualStmNode::Write to create random bytes in the stream.  For
    // our test purposes, we generate a random string of size 1 to cb using
    // GenerateRandomString function.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                ptcsBuffer,
                cb,
                &culWritten);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Attemp IStream::LockRegion.  Ole's implementation doesn't have this
    // function implemented and returns STG_E_INVALIDFUNCTION for the call.
 
    if (S_OK == hr)
    {
        ULISet32(uliOffset, 0);
        ULISet32(uliBytes, 20);

        hr =  pvsnRootNewChildStream->LockRegion(
                uliOffset,
                uliBytes,
                LOCK_WRITE);
  
        // Check STG_E_INVALIDFUNCTION returned as expected.
        if (STG_E_INVALIDFUNCTION == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::LockRegion return STG_E_INVALIDFUNCTION as exp")));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::LockRegion didn't return hr as exp, hr=0x%lx."),
                hr));

            hr = E_FAIL;
        }
    }

    // Attempt IStream::Stat and check the locks supported.

    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    if (S_OK == hr)
    {
        statStg.pwcsName = NULL;
        hr =  pvsnRootNewChildStream->Stat(&statStg, STATFLAG_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat")) ;
    }

    // Check that locks suupported are zero.

    if (S_OK == hr)
    {
        if(0 == statStg.grfLocksSupported)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Locks supported zero as exp.")));
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Locks supported not zero as exp.")));

            hr = E_FAIL;
        }
    }
	
	// Release resources

    if (( NULL != statStg.pwcsName) && ( NULL != pMalloc))
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    // Attempt IStream::UnlockRegion.  Ole's implementation doesn't have this
    // function implemented and returns STG_E_INVALIDFUNCTION for the call.
    
    if (S_OK == hr)
    {
        ULISet32(uliOffset, 0);
        ULISet32(uliBytes, 20);

        hr =  pvsnRootNewChildStream->UnlockRegion(
                uliOffset,
                uliBytes,
                LOCK_WRITE);

        // Check STG_E_INVALIDFUNCTION returned as expected.
        if (STG_E_INVALIDFUNCTION == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStm::UnlockRegion return STG_E_INVALIDFUNCTION as exp")));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::UnlockRegion didn't return hr as exp, hr=0x%lx."),
                hr));

            hr = E_FAIL;
        }
    }

    // Attempt IStream::Stat again and check the locks supported.

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Stat(&statStg, STATFLAG_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat")) ;
    }

    // Check that locks suupported are zero.

    if (S_OK == hr)
    {
        DH_ASSERT(statStg.type == STGTY_STREAM);

        if(0 == statStg.grfLocksSupported)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Locks supported zero as exp.")));
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Locks supported not zero as exp.")));

            fPass = FALSE;
        }
    }

    // Release resources

    if ((NULL != statStg.pwcsName) && (NULL != pMalloc))
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

     
	// Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx.")));
        }
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_109 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_109 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Release pMalloc

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete [] ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_109 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgdrt\headers.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       headers.cxx
//
//  Contents:   Precompiled headers
//
//  History:    05-Nov-92 AlexT    Created
//
//--------------------------------------------------------------------------

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>


#include <windows.h>
#include <ole2.h>

#ifdef _CAIRO_
#define _DCOM_
#define _CAIROSTG_
#include <oleext.h>
#endif

#include <debnot.h>

#include <drt.hxx>
#include <wrap.hxx>
#include <util.hxx>
#include <strlist.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\stgtests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      stgtsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStorage interface 
//
//  Functions:  
//
//  History:    10-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//              06-Aug-97        FarzanaR    cleaned up tests for stress
//  BUGBUG : this file still requires to be cleaned up for stress.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

// externs
extern BOOL     g_fRevert;

//----------------------------------------------------------------------------
//
// Test:    STGTEST_100 
//
// Synopsis: A root docfile and child IStorage are created and committed.
//       The child IStorage is released and then destroyed.  The root is
//       then committed and a new child IStorage is created with the same
//       name as the original one.  The child IStorage and root docfile
//       are then released without committing.  The root docfile is then
//       reinstantiated.  The test attempts to instantiate a child
//       IStorage with the name used for the original one.  The test
//       verifies that no such IStorage exists because it should have been
//       deleted.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    10-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: DFCOMREL.CXX
// 2.  Old name of test : MiscCommitRelease Test 
//     New Name of test : STGTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: STGTEST-100
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt storage commit/release operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,   
                dwStgMode,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
        }
    }

    // Destroy child storage

    if (S_OK == hr)
    {
        hr = DestroyStorage(pTestVirtualDF, pvcnRootNewChildStg);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("DestroyStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("DestroyStorage unsuccessful, hr=0x%lx.")));
        }
    }

    // Commit root.  

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Add a child storage to root with same name

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,   
                dwStgMode,
                &pvcnRootNewChildStg);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }

    // Release root w/o commiting 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
        }
    }

    // Open root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Open child storage that was deleted first time, and second time when
    // created wasn't committed. 
  
    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(
                NULL,
                dwStgMode, 
                NULL,
                0);

        if (STG_E_FILENOTFOUND == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful as exp,hr=0x%lx."),
                hr));
        }
        else
        {
            HRESULT hr2;
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Open should fail with STG_E_FILENOTFOUND, hr=0x%lx."),
                hr));
            fPass = FALSE; 

            // close it coz we found & opened it
            if (S_OK == hr)
            {
                hr2 = pvcnRootNewChildStg->Close();  
                DH_HRCHECK(hr2, TEXT("VirtualStgNode::Close")) ;
            }
        }
        hr = S_OK;
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_101 
//
// Synopsis: Creates a root docfile, stats, and verifies that the CLSID == NULL
//       and state bits = 0.  The test tries various random combinations
//       of setting state bits, changing class ids, committing changes
//       sometimes, reverting at others.  After every event, the test
//       checks to ensure that the state bits and class id are set
//       correctly.  It then creates a child IStorage and repeats the
//       above actions.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    14-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: DFSET.CXX
// 2.  Old name of test : MiscSetItems Test 
//     New Name of test : STGTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-101
//        /dfRootMode:dirReadWriteShEx  
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-101
//        /dfRootMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-3 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-101
//        /dfRootMode:xactReadWriteShDenyW 
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-101
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt Misc setting state bits/class id'")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Call Stat on  root.

    if (S_OK == hr)
    {
        statStg.grfStateBits = 0;
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    	if (S_OK == hr)
    	{
           DH_TRACE((
           	DH_LVL_TRACE1,
           	TEXT("VirtualCtrNode::Stat completed successfully.")));
    	}
    	else
    	{
           DH_TRACE((
           	DH_LVL_TRACE1,
           	TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           	hr));
    	}

        // Check CLSID from STATSTG structure

        if((S_OK == hr) && (IsEqualCLSID(statStg.clsid, CLSID_NULL)))
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Root DocFile has CLSID_NULL as expected.")));

        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Root DocFile doesn't have CLSID_NULL unexpectedly.")));
    
            fPass = FALSE;
        }

        // Check state bits from STATSTG structure.

        if((S_OK == hr) && (0 == statStg.grfStateBits))
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Root DocFile has grfStateBits equal to 0 as expected.")));

        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Root DocFile doesn't have grfStateBits = 0 unexpectedly.")));
    
            fPass = FALSE;
        }
    
    }


    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Call SetItemsInStorage on Root

    if (S_OK == hr)
    {
        hr = SetItemsInStorage(pVirtualDFRoot, pdgi);

        DH_HRCHECK(hr, TEXT("SetItemsInStorage")) ;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,   
                dwStgMode,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Call Stat on  new child storage.

    if (S_OK == hr)
    {
        statStg.grfStateBits = 0;
        hr = pvcnRootNewChildStg->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
        // Check CLSID from STATSTG structure

        if((S_OK == hr) && (IsEqualCLSID(statStg.clsid, CLSID_NULL)))
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Child Storage has CLSID_NULL as expected.")));

        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Child storage doesn't have CLSID_NULL unexpectedly.")));
    
            fPass = FALSE;
        }

        // Check state bits from STATSTG structure.

        if((S_OK == hr) && (0 == statStg.grfStateBits))
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Child Storage has grfStateBits equal to 0 as expected.")));

        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Child Storage doesn't have grfStateBits=0 unexpectedly.")));
    
            fPass = FALSE;
        }
    }



    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Call SetItemsInStorage on Child storage

    if (S_OK == hr)
    {
        hr = SetItemsInStorage(pvcnRootNewChildStg, pdgi);

        DH_HRCHECK(hr, TEXT("SetItemsInStorage")) ;
    }

    // Release child storage.  

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release root.  

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr)  && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_101 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_102 
//
// Synopsis: The test attempts various illegitimate operations regarding the
//           renaming and deletion of contained IStorages. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    10-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: IRENDEST.CXX
// 2.  Old name of test : IllegitRenDest Test 
//     New Name of test : STGTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-102
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx /labmode 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /labmode 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//        /labmode 
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-102
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg0   = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg1   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPTSTR          ptszNonExist            = TEXT("NonExistStg");
    LPTSTR          ptszNonExistNew         = TEXT("NonExistStgNew");
    LPOLESTR        poszNonExist            = NULL;
    LPOLESTR        poszNonExistNew         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    ULONG           i                       = 0;
    LPSTORAGE       pStgRoot                = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt illegitimate storage rename/del ops")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // create two new IStorages and save their names.

    for (i=0;i<2;i++)
    {
        // Adds a new storage to the root storage.

        if(S_OK == hr)
        {
            // Generate random name for storage

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStgName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            hr = AddStorage(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStgName,   
                    dwStgMode,
                    &pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("AddStorage")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::AddStorage completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                    hr));
            }
        }

        // Commit root. 

        if(S_OK == hr)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
       
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                    hr));
            }
        }

        // Release child storage

        if (S_OK == hr)
        {
            hr = pvcnRootNewChildStg->Close();

            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Close completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
            }
        }

        if(S_OK == hr)
        {
            if(i == 0)
            {
                pvcnRootNewChildStg0 = pvcnRootNewChildStg;
            }
            else
            {
                pvcnRootNewChildStg1 = pvcnRootNewChildStg;
            }
        }

        // Delete temp strings

        if(NULL != pRootNewChildStgName)
        {
            delete pRootNewChildStgName;
            pRootNewChildStgName = NULL;
        }
    
        // Break out of loop under failure conditions
        
        if(S_OK != hr)
        {
            break;
        }
    }

    // verify that the IStorages have been created by attempting to
    // instantiate them
    // Break out of loop under failure conditions
    for (i=0; i<2 && S_OK == hr; i++)
    {
        if(i == 0)
        {
           pvcnRootNewChildStg = pvcnRootNewChildStg0;
        }
        else
        {
           pvcnRootNewChildStg = pvcnRootNewChildStg1;
        }

        hr = pvcnRootNewChildStg->Open(
                    NULL,
                    dwStgMode | STGM_FAILIFTHERE,
                    NULL,
                    0);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }

        // Release child storage

        if (S_OK == hr)
        {
            hr = pvcnRootNewChildStg->Close();

            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Close completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
            }
        }
    }

    // Attempt to rename the storage to a name that already exists.

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStg0->Rename(
                pvcnRootNewChildStg1->GetVirtualCtrNodeName()); 
        if(STG_E_ACCESSDENIED == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename failed as exp, hr = 0x%lx."),
                hr));
         
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename didn't fail as exp, hr = 0x%lx."),
                hr));
        
            fPass = FALSE;
        }
    }


    // Attempt to rename an element that doesn't exist.

    // Covert the names to OLECHAR

    if(S_OK == hr)
    {
        // Convert test name to OLECHAR

        hr = TStringToOleString(ptszNonExist, &poszNonExist);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert test name to OLECHAR

        hr = TStringToOleString(ptszNonExistNew, &poszNonExistNew);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // First get IStorage pointer for root

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();  

        DH_ASSERT(NULL != pStgRoot); 
    
        hr = pStgRoot->RenameElement(
                poszNonExist,
                poszNonExistNew); 
        if(STG_E_FILENOTFOUND == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Rename failed as exp, hr = 0x%lx."),
                hr));
         
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Rename didn't fail as exp, hr = 0x%lx."),
                hr));
        
            fPass = FALSE;
        }
    }


    // Attempt to delete an element that doesn't exist.

    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszNonExist);
        if(STG_E_FILENOTFOUND == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Destroy failed as exp, hr = 0x%lx."),
                hr));
         
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Destroy didn't fail as exp, hr = 0x%lx."),
                hr));
        
            fPass = FALSE;
        }
    }


    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_102 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != poszNonExist)
    {
        delete poszNonExist;
        poszNonExist = NULL;
    }

    if(NULL != poszNonExistNew)
    {
        delete poszNonExistNew;
        poszNonExistNew = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_103 
//
// Synopsis: A random docfile with some storages and some streams is generated.
//       The root docfile is commited and closed.  
//       The root docfile is then instantiated & an enumerator is obtained.  For
//       each object found, the object is renamed to a new name but the old
//       name is saved.  An attempt is made to instantiate the object with
//       the old name, this attempt should fail.  The renamed object is then
//       instantiated with the new name to verify that the rename worked.  The
//       object is then destroyed.  This occurs for every object returned by
//       the enumerator.  The root docfile is then committed, the enumerator
//       is released, and a new enumerator is obtained.  The root docfile
//       is enumerated to verify that no elements exist. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    11-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LDRENDES.CXX
// 2.  Old name of test : LegitRenDestNormal Test 
//     New Name of test : STGTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-103
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-103
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPMALLOC        pMalloc                 = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTREAM        pStmChild               = NULL;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;
    BOOL            fRenamedOK              = TRUE;
    LPTSTR          ptszNewName             = NULL;
    LPOLESTR        poszNewName             = NULL;
    LPTSTR          ptszOldName             = NULL;
    LPOLESTR        poszOldName             = NULL;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt legit rename/deleted ops on stgs/stms")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Commit substorages BUGBUG df already commited

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Release root and all substorages/streams too 

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Release root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Reopen the root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Call EnumElements to get a enumerator 

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements passed as expected")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements unexpectedly failed hr=0x%lx"),
                hr));
        }
    }


    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();  

        DH_ASSERT(NULL != pStgRoot); 

        // Get DG_STRING object pointer

        if (S_OK == hr)
        {
            pdgu = pTestVirtualDF->GetDataGenUnicode();

            DH_ASSERT(NULL != pdgu) ;
        }
    }

    while(S_OK == hr && S_OK == penumWalk->Next(1, &statStg, NULL))
    {
        // loop to rename object until a unique name is found, typically
        // this will happen the first time and we'll fall out of the loop,
        // but in the event of a duplicate name we have to keep trying.

        fRenamedOK = FALSE;

        while ((fRenamedOK == FALSE) && (S_OK == hr))
        {
            if(S_OK == hr)
            {
                // Generate random name for the element 

                hr = GenerateRandomName(
                        pdgu,
                        MINLENGTH,
                        MAXLENGTH,
                        &ptszNewName);

                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
            }

            if(S_OK == hr)
            {
                // Convert above name to OLECHAR
                hr = TStringToOleString(ptszNewName, &poszNewName);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            // Convert old name as retrieved from STATSTG structure to OLECHAR
            // by first converting it to TSTR and then to OLECHAR.

            if(S_OK == hr)
            {
                // Convert old name statStg.pwcsName to TCHAR
                hr = OleStringToTString(statStg.pwcsName, &ptszOldName);

                DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
            }

            if(S_OK == hr)
            {
                // Now Convert old name to OLECHAR
                hr = TStringToOleString(ptszOldName, &poszOldName);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                // Rename the element to new name
        
                hr = pStgRoot->RenameElement(
                        poszOldName,
                        poszNewName); 
            }

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::RenameElement successful as exp.")));
                
                fRenamedOK = TRUE;
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::RenameElement failed unexp, hr = 0x%lx."),
                    hr));

                break;
            }
        } // ((fRenamedOK == FALSE) && (S_OK == hr))
   
        // verify that the rename worked by first trying to instantiate
        // the object with the original name (this should fail) and
        // then instantiate it with the new name.

        if((S_OK == hr) && (statStg.type == STGTY_STORAGE))
        {
            hr = pStgRoot->OpenStorage(
                    poszOldName,
                    NULL,
                    dwStgMode,
                    NULL,
                    0,
                    &pStgChild);

            if((NULL == pStgChild) && (STG_E_FILENOTFOUND == hr))
            {
                DH_TRACE((
                   DH_LVL_TRACE1,
                   TEXT("Instantiation with old name fail exp, hr = 0x%lx "),
                   hr));

                hr = S_OK;
            }
            else
            {
                DH_TRACE((
                   DH_LVL_TRACE1,
                   TEXT("Instantiation with old name pass unexp, hr = 0x%lx"),
                   hr));

                hr = S_FALSE;
            }
        
            if(S_OK == hr)  
            {
                hr = pStgRoot->OpenStorage(
                        poszNewName,
                        NULL,
                        dwStgMode,
                        NULL,
                        0,
                        &pStgChild);

                DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;
                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Instantiation with new name pass as exp")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Instantiation with new name fail unexp, hr=0x%lx"),
                        hr));
                }
            }
            

            // Release the element
            
            if(NULL != pStgChild)
            {
                ulRef = pStgChild->Release();
                DH_ASSERT(0 == ulRef);
                pStgChild = NULL;
            }
        } // ((S_OK == hr) && (statStg.type == STGTY_STORAGE))
        
        if ((S_OK == hr) && (statStg.type == STGTY_STREAM))
        {
            //element is a stream

            hr = pStgRoot->OpenStream(
                    poszOldName,
                    NULL,
                    STGM_READ | STGM_SHARE_EXCLUSIVE,
                    0,
                    &pStmChild);

            if((NULL == pStmChild) && (STG_E_FILENOTFOUND == hr))
            {
                DH_TRACE((
                   DH_LVL_TRACE1,
                   TEXT("Instantiation with old name fail exp, hr = 0x%lx "),
                   hr));

                hr = S_OK;
            }
            else
            {
                DH_TRACE((
                   DH_LVL_TRACE1,
                   TEXT("Instantiation with old name pass unexp,hr = 0x%lx "),
                   hr));

                hr = S_FALSE;
            }
        
            if(S_OK == hr)  
            {
                hr = pStgRoot->OpenStream(
                        poszNewName,
                        NULL,
                        STGM_READ | STGM_SHARE_EXCLUSIVE,
                        0,
                        &pStmChild);

                DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Instantiation with new name pass as exp")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Instantiation with new name fail unexp, hr=0x%lx"),
                        hr));
                }
            }
            

            // Release the element
            
            if(NULL != pStmChild)
            {
                ulRef = pStmChild->Release();
                DH_ASSERT(0 == ulRef);
                pStmChild = NULL;
            }
        } // if ((S_OK == hr) && (statStg.type == STGTY_STREAM))

        // Destroy the element

        if(S_OK == hr)  
        {
            hr = pStgRoot->DestroyElement(poszNewName);

            DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::DestoryElement succeeded as expected.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::DestoryElement fail unexp, hr = 0x%lx."),
                    hr));
            }
        }


        // Release resources

        if ( NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszNewName)
        {
            delete ptszNewName;
            ptszNewName = NULL;
        }

        if(NULL != poszNewName)
        {
            delete poszNewName;
            poszNewName = NULL;
        }

        if(NULL != ptszOldName)
        {
            delete ptszOldName;
            ptszOldName = NULL;
        }

        if(NULL != poszOldName)
        {
            delete poszOldName;
            poszOldName = NULL;
        }
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }
   

    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // Call EnumElements to get a enumerator again

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements passed as expected")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements unexpectedly failed hr=0x%lx"),
                hr));
        }
    }


    // Try to call next on it.  All elements should have been deleted

    while(S_OK == hr && S_OK == penumWalk->Next(1, &statStg, NULL))
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("All elements should have been deleted.")));
        
        fPass = FALSE;
    }

    // Release root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release pMalloc

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_103 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_104 
//
// Synopsis: This test first creates a root docfile.  Two child IStorages
//       are created inside of it.
//       Child IStorage A is renamed to name C, child IStorage B is
//       renamed to name A, child IStorage C (was originally A) is
//       renames to B.  The root docfile is committed.  Verify
//       proper renaming and no errors.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    11-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LDRENSWP.CXX
// 2.  Old name of test : LegitRenDestSwap Test 
//     New Name of test : STGTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-104
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-104
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootNewChildStg0   = NULL;
    LPTSTR          pRootNewChildStgName0   = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg1   = NULL;
    LPTSTR          pRootNewChildStgName1   = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt rename swap operations on child stgs")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Adds first new child storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for first child storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootNewChildStgName0);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName0,   
                dwStgMode,
                &pvcnRootNewChildStg0);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Adds second new child storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for first child storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootNewChildStgName1);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName1,   
                dwStgMode,
                &pvcnRootNewChildStg1);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Can't rename open storages so release the child storages

    // Release first child storage.

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg0->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
        }
    }


    // Release second child storage.

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg1->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
        }
    }


    // Attempt to rename the first child storage to RootDocFile's name

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("pvcnRootNewChildStg0's old name, %s."),
            pvcnRootNewChildStg0->GetVirtualCtrNodeName()));

        hr = pvcnRootNewChildStg0->Rename(
                pVirtualDFRoot->GetVirtualCtrNodeName()); 
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename passed as exp, new name %s."),
                pvcnRootNewChildStg0->GetVirtualCtrNodeName()));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Attempt to rename the second child storage to first child stg's name

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("pvcnRootNewChildStg1's old name, %s."),
            pvcnRootNewChildStg1->GetVirtualCtrNodeName()));

        hr = pvcnRootNewChildStg1->Rename(pRootNewChildStgName0); 
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename passed as exp, new name %s."),
                pvcnRootNewChildStg1->GetVirtualCtrNodeName()));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Attempt to rename third child storage (was originally first child 
    // storage) to second child stg's name

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("pvcnRootNewChildStg0's old name, %s."),
            pvcnRootNewChildStg0->GetVirtualCtrNodeName()));

        hr = pvcnRootNewChildStg0->Rename(pRootNewChildStgName1); 
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename passed as exp, new name %s."),
                pvcnRootNewChildStg0->GetVirtualCtrNodeName()));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_104 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName0)
    {
        delete pRootNewChildStgName0;
        pRootNewChildStgName0 = NULL;
    }

    if(NULL != pRootNewChildStgName1)
    {
        delete pRootNewChildStgName1;
        pRootNewChildStgName1 = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_105 
//
// Synopsis: A random docfile with random number of storages and streams is
//          generated.  Root is committed and closed.
//          The root docfile is instantiated and the CRC is computed for the
//          entire docfile.  A new root docfile with a random name is then
//          created and a CRC is generated for the empty root docfile.  An
//          enumerator is obtained on the source docfile, each element returned
//          is MoveElementTo()'d the destination docfile.  If fRevertAfterMove
//          equals TRUE, the dest is reverted, else the dest is committed.
//          The dest is released and reinstantiated and CRC'd.  If the dest
//          was reverted, the CRC is compared against the empty CRC for a match.
//          Otherwise, we compare against the original root docfile CRC.  The
//          original file is CRC'd again to verify that STGMOVE_COPY didn't
//          move the elements from orginal position but copied them, the CRC
//          now computed should match with the one calculated originally. 
//
//          This tests differs from STGTEST-107 in the way that MoveElementTo
//          is called with STGMOVE_COPY flag instead of STGMOVE_MOVE.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    12-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LVROOT.CXX
// 2.  Old name of test : LegitMoveDFToRootDF Test 
//     New Name of test : STGTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:dirReadWriteShEx  
//     b. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:xactReadWriteShDenyW 
//     d. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:xactReadWriteShEx /frevertaftermove
//     e. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:xactReadWriteShDenyW /frevertaftermove 
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//     BUGBUG: dont have /stdblock up yet. -scousens
//     BUGBUG: note this fails sometimes for nssfiles need to dig deeper -scousens working seed=21590084
//
//  In case of direct mode, the flag revertaftermove is not meaningful since
//  changes are always directly written to disk doc file.
//
// BUGNOTE: Conversion: STGTEST-105
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszRootNewDocFile      = NULL;
    LPOLESTR        poszRootNewDocFile      = NULL;
    DWORD           dwRootMode              = 0;
    LPSTORAGE       pStgRoot1               = NULL;
    LPSTORAGE       pStgRoot2               = NULL;
    LPSTORAGE       pStgRoot11              = NULL;
    ULONG           ulRef                   = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    DWORD           dwCRC3                  = 0;
    DWORD           dwCRC4                  = 0;
    LPMALLOC        pMalloc                 = NULL;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPTSTR          ptszElementName         = NULL;
    LPOLESTR        poszElementName         = NULL;
    BOOL            fPass                   = TRUE;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_105 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt MoveElementTo-STGMOVE_COPY operations")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Commit substorages 

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Release root and all substorages/streams too 

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Open the root only

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Calculate CRC for entire DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRoot1 = pVirtualDFRoot->GetIStoragePointer();  

        DH_ASSERT(NULL != pStgRoot1); 

        hr = CalculateCRCForDocFile(pStgRoot1, VERIFY_EXC_TOPSTG_NAME, &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }


    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    if(S_OK == hr)
    {
        // Generate random name for first child storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(ptszRootNewDocFile, &poszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (S_OK == hr)
    {
        hr = StgCreateDocfile(
                poszRootNewDocFile,
                dwRootMode,
                0,
                &pStgRoot2);

        DH_HRCHECK(hr, TEXT("StgCreateDocFile")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile successful as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile not successful, hr=0x%lx."),
                hr));
        }
    }


    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(pStgRoot2, VERIFY_EXC_TOPSTG_NAME, &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Call EnumElements to get a enumerator for first DocFile

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements passed as expected")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements unexpectedly failed hr=0x%lx"),
                hr));
        }
    }


    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while((S_OK == hr) && (S_OK == penumWalk->Next(1, &statStg, NULL)))
    {
        if(S_OK == hr)
        {
            // Convert statStg.pwcsName to TCHAR
            hr = OleStringToTString(statStg.pwcsName, &ptszElementName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Now Convert old name to OLECHAR
            hr = TStringToOleString(ptszElementName, &poszElementName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        if(S_OK == hr)
        {
            // Move the element to second DocFile

            hr = pStgRoot1->MoveElementTo(
                    poszElementName,
                    pStgRoot2,
                    poszElementName,
                    STGMOVE_COPY);
    
            DH_HRCHECK(hr, TEXT("IStorage::MoveElementTo")) ;
            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::MoveElementTo passed as expected")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::MoveElementTo unexpectedly failed hr=0x%lx"),
                    hr));
            }
        }


        // Release resources

        if ( NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszElementName)
        {
            delete ptszElementName;
            ptszElementName = NULL;
        }

        if(NULL != poszElementName)
        {
            delete poszElementName;
            poszElementName = NULL;
        }

        // Break out of loop in error case

        if(S_OK != hr)
        {
            break;
        }
    }
 
    // Commit or Revert the second docfile as the case may be. 

    if((S_OK == hr) && (FALSE == g_fRevert))
    {
        hr = pStgRoot2->Commit(STGC_DEFAULT);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }
    else
    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        hr = pStgRoot2->Revert();

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Revert completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Revert unsuccessful, hr=0x%lx."),
                hr));
        }
    }
   
    // Close the second DocFile

    if(NULL != pStgRoot2)
    {
        ulRef = pStgRoot2->Release();
        DH_ASSERT(0 == ulRef);
        pStgRoot2 = NULL;
    }

    // Open it again and do StgIsStorageFile to verify.

    if(S_OK == hr)
    {
        hr = StgOpenStorage(
                poszRootNewDocFile,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pStgRoot2);

       DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage completed successfully.")));

            DH_ASSERT(NULL != pStgRoot2);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage unsuccessful, hr=0x%lx."),
                hr));
        }
    }
        

    // Do StgIsStorageFile to verify

    if(S_OK == hr)
    {
        hr = StgIsStorageFile(poszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("StgIsStorageFile")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorageFile completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorageFile unsuccessful, hr=0x%lx."),
                hr));
        }
    }
        

    // Calculate CRC on this second Root DocFile.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(pStgRoot2, VERIFY_EXC_TOPSTG_NAME, &dwCRC3);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        // Compare CRC's

        if((S_OK == hr) && ( FALSE == g_fRevert))
        {
            if (dwCRC3 == dwCRC1)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for docfile1 & docfile2 after commit match.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for docfile1 & docfile2 aftr commit don't match")));
            
                fPass = FALSE;
            }
        }
        else
        if((S_OK == hr) && ( TRUE == g_fRevert))
        {
            if (dwCRC3 == dwCRC2)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for docfile2 before & after Revert match.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for docfile2 before & after Revert don't match")));
            
                fPass = FALSE;
            }
        }
    }


    // Close the second DocFile

    if(NULL != pStgRoot2)
    {
        ulRef = pStgRoot2->Release();
        DH_ASSERT(0 == ulRef);
        pStgRoot2 = NULL;
    }
        
    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // Release root  

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Open the Root DocFile again to verify the STGMOVE_COPY flags specified
    // while doing MoveElementTo

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Now get the CRC again on the original DocFile to verify that flag
    // STGMOVE_COPY copied the elements and not moved them, so this CRC
    // should match with CRC originally  obtained on this DocFile.

    if(S_OK == hr)
    {
        pStgRoot11 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot11);

        hr = CalculateCRCForDocFile(pStgRoot11, VERIFY_EXC_TOPSTG_NAME,&dwCRC4);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        if(S_OK == hr)
        {
            if (dwCRC4 == dwCRC1)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for original docfle match after move as copy.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for original DF don't match after move as copy.")));
            
                fPass = FALSE;
            }
        }
    }


    // Release the first root docfile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr)  && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_105 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Release pMalloc

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Delete strings

    if(NULL != poszRootNewDocFile)
    {
        delete poszRootNewDocFile;
        poszRootNewDocFile = NULL;
    }

    // Delete the second docfile on disk

    if((S_OK == hr) && (NULL != ptszRootNewDocFile))
    {
        if(FALSE == DeleteFile(ptszRootNewDocFile))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != ptszRootNewDocFile)
    {
        delete ptszRootNewDocFile;
        ptszRootNewDocFile = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:  STGTEST_106 
//
// Synopsis: This test first creates a root docfile.  A child IStorage is
//        then created with STGM_DENY_WRITE set.  An IStream is created
//        inside the child IStorage and a random number of bytes are
//        written to it.  The stream is released, the child and root
//        IStorages are committed, and the child IStorage is released.
//        The child IStorage is instantiated in STGM_TRANSACTED mode
//        and then released.  A count of the files in the current directory
//        is then made and saved.  The child IStorage is then instantiated
//        in STGM_TRANSACTED | STGM_DENY_WRITE mode and another count is
//        made.  We then verify that only 1 scratch file was created,
//        indicating that for STGM_DENY_WRITE mode, no copy is made of
//        the instantiated IStorage.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-July-1996     NarindK     Created.
//
// Notes:   THIS TEST IS NOT APPLICABLE WITH PRESENT STORAGE CODE, PRESENT
//          ONLY FOR DOCUMENTATION/REFERENCE PURPOSES.  BY DESIGN, THE PRESENT
//          DOCFILE REQUIRES THAT ALL SUBSTORAGES/SUBSTREAMS BE CREATED/OPENED 
//          WITH STGM_SHARE_EXCLUSIVE FLAG. 
//
// This test runs in transacted modes
//
// New Test Notes:
// 1.  Old File: LITWWDW.CXX
// 2.  Old name of test : LegitInstRootTwwDenyWrite test 
//     New Name of test : STGTEST_106 
// 3.  To run the test, do the following at command prompt. 
//       stgbase /t:STGTEST-106
// 4.  To run for conversion, add /dfStgType:conversion to the above
// 5.  To run for nssfile, add /dfStgType:nssfile to the above
//
// BUGNOTE: Conversion: STGTEST-106
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_106(ULONG ulSeed)
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!STGTEST_106 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    VirtualStmNode  *pvsnNewChildStream     = NULL;
    DWORD           dwRootMode              = STGM_READWRITE | STGM_TRANSACTED;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszRootName            = NULL;
    LPTSTR          ptszRootNewChildStgName = NULL;
    LPTSTR          ptszStreamName          = NULL;
    BOOL            fPass                   = TRUE;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           culFilesInDirectory     = 0;
    ULONG           cb                      = 0;
    DWCRCSTM        dwMemCRC;
    DWCRCSTM        dwActCRC;
    CDFD            cdfd;

    dwMemCRC.dwCRCSum = dwActCRC.dwCRCSum = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_106 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt operations on child storage in transacted mode.")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
           hr = E_OUTOFMEMORY;
        }
        else
        {
            //want to create only one seed. Once that has been done, 
            //use what we created from now on.
            ulSeed = pdgu->GetSeed ();
        }
    }
        
    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszRootName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = ulSeed;
        cdfd.dwRootMode   = dwRootMode | STGM_CREATE;

        hr = CreateTestDocfile (&cdfd, 
                ptszRootName,
                &pVirtualDFRoot,
                &pTestVirtualDF,
                &pTestChanceDF);

        DH_HRCHECK(hr, TEXT("CreateTestDocfile"));
    }

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                ptszRootNewChildStgName,
                dwRootMode | STGM_SHARE_DENY_WRITE | STGM_FAILIFTHERE,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Now add a stream to this child storage

    // Generate random name for stream

    if(S_OK == hr)
    {
        hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszStreamName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, 1, USHRT_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStg,
                ptszStreamName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }


    // Write random data into stream

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if(S_OK == hr)
    {
        hr = pvsnNewChildStream->Write(
                ptcsBuffer, 
                cb, 
                &culWritten);

        DH_HRCHECK(hr, TEXT("IStream::Write")) ;
    }

    // Calculate the CRC for stream name and data

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnNewChildStream,
                ptcsBuffer,
                cb,
                &dwMemCRC);

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx.")));
        }
    }


    // Now do a commit of child storage with STGC_ONLYIFCURRENT.

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Commit(STGC_ONLYIFCURRENT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Now do a commit of root storage with STGC_ONLYIFCURRENT.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_ONLYIFCURRENT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Close the child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Open the child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(
                NULL, 
                dwRootMode | STGM_SHARE_EXCLUSIVE, 
                NULL, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Close the child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // count number of files in directory

    if (S_OK == hr)
    {
        culFilesInDirectory = CountFilesInDirectory(WILD_MASK);
    }

    // Open the with STGM_SHARE_DENY_WRITE

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(
                NULL, 
                dwRootMode | STGM_SHARE_DENY_WRITE, 
                NULL, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Check number of files

    if(S_OK == hr)
    {
        if((culFilesInDirectory + 1) != CountFilesInDirectory(WILD_MASK))
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT(">1 scratch file unexp STGM_SHARE_DENY_WRITE inst.")));

            hr = S_FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("1 scratchfile as exp STGM_SHARE_DENY_WRITE inst")));

        }
    }

    // OpenStream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Open(
                NULL, 
                dwRootMode | STGM_SHARE_DENY_WRITE, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Read stream, CRC and verify

    if(S_OK == hr)
    {
        hr = ReadAndCalculateDiskCRCForStm(pvsnNewChildStream,&dwActCRC);

        DH_HRCHECK(hr, TEXT("ReadAndCalculateDiskCRCForStm")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ReadAndCalculateDiskCRCForStm function successful.")));

            if(dwActCRC.dwCRCSum == dwMemCRC.dwCRCSum)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's for pvsnNewChildStream match.")));

            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for pvsnNewChildStream don't match.")));

                fPass = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ReadAndCalculateDiskCRCForStm not successful, hr=0x%lx."),
                hr));
        }
    }


    // Close the stream in child storage 

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Close the child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Close the root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)           
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_106 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_106 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete DataGen object
    
    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Delete temp string

    if(NULL != ptszRootNewChildStgName)
    {
        delete ptszRootNewChildStgName;
        ptszRootNewChildStgName = NULL;
    }

    if(NULL != ptszStreamName)
    {
        delete ptszStreamName;
        ptszStreamName = NULL;
    }

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Delete temp string

    if(NULL != ptszRootName)
    {
        delete ptszRootName;
        ptszRootName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_106 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_107 
//
// Synopsis: A random docfile with random number of storages and streams is
//          generated.  Root is committed and closed.
//          The root docfile is instantiated and the CRC is computed for the
//          entire docfile.  A new root docfile with a random name is then
//          created and a CRC is generated for the empty root docfile.  An
//          enumerator is obtained on the source docfile, each element returned
//          is MoveElementTo()'d with STGM_MOVE to the destination docfile.  
//          If fRevertAfterMove equals TRUE, the dest is reverted, else the 
//          dest is committed. The dest is released and reinstantiated and 
//          CRC'd.  If the dest was reverted, the CRC is compared against the 
//          empty CRC for a match. Otherwise, we compare against the original 
//          root docfile CRC. Original file is CRC'd again to verify that 
//          STGMOVE_MOVE moved the elements from orginal position instead of
//          copying, the CRC now computed should differ from the one calculated
//          originally. 
//
//          This tests differs from STGTEST-105 in the way that MoveElementTo
//          is called with STGMOVE_MOVE flag instead of STGMOVE_COPY.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    8-Aug-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File:  A part of STORAGE.CXX
// 2.  Old name of test : A part of STORAGE_TEST Test 
//     New Name of test : STGTEST_107 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//     d. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//        /frevertaftermove
//     e. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//        /frevertaftermove 
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//     BUGBUG: dont have /stdblock up yet. -scousens
//
//  In case of direct mode, the flag revertaftermove is not meaningful since
//  changes are always directly written to disk doc file.
//
// BUGNOTE: Conversion: STGTEST-107
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_107(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszRootNewDocFile      = NULL;
    LPOLESTR        poszRootNewDocFile      = NULL;
    DWORD           dwRootMode              = 0;
    LPSTORAGE       pStgRoot1               = NULL;
    LPSTORAGE       pStgRoot2               = NULL;
    LPSTORAGE       pStgRoot11              = NULL;
    ULONG           ulRef                   = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    DWORD           dwCRC3                  = 0;
    DWORD           dwCRC4                  = 0;
    LPMALLOC        pMalloc                 = NULL;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPTSTR          ptszElementName         = NULL;
    LPOLESTR        poszElementName         = NULL;
    BOOL            fPass                   = TRUE;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_107"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_107 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt MoveElementTo-STGMOVE_MOVE operations")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_107, Access mode: %lx"),
            dwRootMode));
    }

    // Commit all substgs BUGBUG df already commited

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Release root and all substorages/streams too 

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Open the root only

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Calculate CRC for entire DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRoot1 = pVirtualDFRoot->GetIStoragePointer();  

        DH_ASSERT(NULL != pStgRoot1); 

        hr = CalculateCRCForDocFile(pStgRoot1, VERIFY_EXC_TOPSTG_NAME, &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }


    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    if(S_OK == hr)
    {
        // Generate random name for first child storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(ptszRootNewDocFile, &poszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (S_OK == hr)
    {
        hr = StgCreateDocfile(
                poszRootNewDocFile,
                dwRootMode,
                0,
                &pStgRoot2);

        DH_HRCHECK(hr, TEXT("StgCreateDocFile")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile successful as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile not successful, hr=0x%lx."),
                hr));
        }
    }


    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(pStgRoot2, VERIFY_EXC_TOPSTG_NAME, &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Call EnumElements to get a enumerator for first DocFile

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements passed as expected")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements unexpectedly failed hr=0x%lx"),
                hr));
        }
    }


    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while(S_OK == hr && S_OK == penumWalk->Next(1, &statStg, NULL))
    {
        if(S_OK == hr)
        {
            // Convert statStg.pwcsName to TCHAR
            hr = OleStringToTString(statStg.pwcsName, &ptszElementName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Now Convert old name to OLECHAR
            hr = TStringToOleString(ptszElementName, &poszElementName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        if(S_OK == hr)
        {
            // Move the element to second DocFile

            hr = pStgRoot1->MoveElementTo(
                    poszElementName,
                    pStgRoot2,
                    poszElementName,
                    STGMOVE_COPY);
    
            DH_HRCHECK(hr, TEXT("IStorage::MoveElementTo")) ;
            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::MoveElementTo passed as expected")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::MoveElementTo unexpectedly failed hr=0x%lx"),
                    hr));
            }
        }


        // Release resources

        if ( NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszElementName)
        {
            delete ptszElementName;
            ptszElementName = NULL;
        }

        if(NULL != poszElementName)
        {
            delete poszElementName;
            poszElementName = NULL;
        }
    }
 
    // Commit or Revert the second docfile as the case may be. 

    if((S_OK == hr) && (FALSE == g_fRevert))
    {
        hr = pStgRoot2->Commit(STGC_DEFAULT);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }
    else
    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        hr = pStgRoot2->Revert();

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Revert completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Revert unsuccessful, hr=0x%lx."),
                hr));
        }
    }
   
    // Close the second DocFile

    if(NULL != pStgRoot2)
    {
        ulRef = pStgRoot2->Release();
        DH_ASSERT(0 == ulRef);
        pStgRoot2 = NULL;
    }

    // Open it again and do StgIsStorageFile to verify.

    if(S_OK == hr)
    {
        hr = StgOpenStorage(
                poszRootNewDocFile,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pStgRoot2);

       DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage unsuccessful, hr=0x%lx."),
                hr));
        }
    }
        

    // Do StgIsStorageFile to verify

    if(S_OK == hr)
    {
        hr = StgIsStorageFile(poszRootNewDocFile);

       DH_HRCHECK(hr, TEXT("StgIsStorageFile")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorageFile completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorageFile unsuccessful, hr=0x%lx."),
                hr));
        }
    }
        

    // Calculate CRC on this second Root DocFile.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(pStgRoot2, VERIFY_EXC_TOPSTG_NAME, &dwCRC3);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's

    if((S_OK == hr) && ( FALSE == g_fRevert))
    {
        if (dwCRC3 == dwCRC1)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for docfile1 & docfile2 after commit match.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC for docfile1 & docfile2 aftr commit don't match")));
            
            fPass = FALSE;
        }
    }
    else
    if((S_OK == hr) && ( TRUE == g_fRevert))
    {
        if (dwCRC3 == dwCRC2)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for docfile2 before & after Revert match.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC for docfile2 before & after Revert don't match")));
            
            fPass = FALSE;
        }
    }

    // Close the second DocFile

    if(NULL != pStgRoot2)
    {
        ulRef = pStgRoot2->Release();
        DH_ASSERT(0 == ulRef);
        pStgRoot2 = NULL;
    }
        
    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // Release the first root docfile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Open the Root DocFile again to verify the STGMOVE_MOVE flags specified
    // while doing MoveElementTo

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Now get the CRC again on the original DocFile to verify that flag
    // STGMOVE_COPY copied the elements and not moved them, so this CRC
    // should match with CRC originally  obtained on this DocFile.

    if(S_OK == hr)
    {
        pStgRoot11 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot11);

        hr = CalculateCRCForDocFile(pStgRoot11, VERIFY_EXC_TOPSTG_NAME,&dwCRC4);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        if(S_OK == hr)
        {
            if (dwCRC4 == dwCRC1)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for org docfile don't match as exp-move as move")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for org docfile match unexp -move as move")));
            
                fPass = FALSE;
            }
        }
    }


    // Release the first root docfile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release pMalloc
    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr)  && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_107 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_107 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != poszRootNewDocFile)
    {
        delete poszRootNewDocFile;
        poszRootNewDocFile = NULL;
    }

    // Delete the second docfile on disk

    if((S_OK == hr) && (NULL != ptszRootNewDocFile))
    {
        if(FALSE == DeleteFile(ptszRootNewDocFile))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != ptszRootNewDocFile)
    {
        delete ptszRootNewDocFile;
        ptszRootNewDocFile = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_107 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    STGTEST_108
//
// Synopsis: A root docfile with a child storage is created, then check if 
//           Set/GetConvertStorage APIs work correctly as expected by passed 
//           in a storage pointer(here, we test both root storage and child
//           storage pointer). Also have some illegitmate tests by passing 
//           invalid arguments to these APIs.           
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    14-Aug-1996     JiminLi     Created.
//
// New Test Notes:
// 1.  Old File:  A part of STORAGE.CXX
// 2.  Old name of test : A part of STORAGE_TEST Test 
//     New Name of test : STGTEST_108 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-108
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-108
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-108
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-108
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_108(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPSTORAGE       pRootStg                = NULL;
    LPSTORAGE       pChildStg               = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_108"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_108 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legit and illegit tests on Set/GetConvertStg APIs")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_108, Access mode: %lx"),
            dwRootMode));
    }

    // Get root storage pointer
    if (NULL != pVirtualDFRoot)
    {
        pRootStg = pVirtualDFRoot->GetIStoragePointer();
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode,
                &pvcnRootNewChildStg);

        pChildStg = pvcnRootNewChildStg->GetIStoragePointer();

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Legit tests of Set/GetConvertStg on the root storage

    if (S_OK == hr)
    {
        hr = SetConvertStg(pRootStg, TRUE);
        if (S_OK == hr)
        {
            hr = GetConvertStg(pRootStg);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetConvertStg did not return S_OK as expected.")));
        }
        if (S_OK == hr)
        {
            hr = SetConvertStg(pRootStg, FALSE);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetConvertStg did not return S_OK as expected.")));
        }
        if (S_OK == hr)
        {
            hr = GetConvertStg(pRootStg);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetConvertStg did not return S_OK as expected.")));
        }
        if (S_FALSE == hr)
        {
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetConvertStg did not return S_FALSE as expected.")));

            hr = E_FAIL;
        }
    }


    // Legit tests of Set/GetConvertStg on the child storage

    if (S_OK == hr)
    {
        hr = SetConvertStg(pChildStg, TRUE);
        if (S_OK == hr)
        {
            hr = GetConvertStg(pChildStg);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetConvertStg did not return S_OK as expected.")));
        }

        if (S_OK == hr)
        {
            hr = SetConvertStg(pChildStg, FALSE);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetConvertStg did not return S_OK as expected.")));
        }

        if (S_OK == hr)
        {
            hr = GetConvertStg(pChildStg);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetConvertStg did not return S_OK as expected.")));
        }

        if (S_FALSE == hr)
        {
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetConvertStg did not return S_FALSE as expected.")));

            hr = E_FAIL;
        }
    }


    // Illegit tests

#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!SetConvertStg with NULL IStorage skipped")) );

#else
    
    // Pass NULL as IStorage pointer, it should fail

    if (S_OK == hr)
    {
        hr = SetConvertStg(NULL, TRUE);
        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("SetConvertStg did not return E_INVALIDARG as expected")));

            hr = E_FAIL;
        }

        if (S_OK == hr)
        {
            hr = GetConvertStg(NULL);
        }

        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("GetConvertStg did not return E_INVALIDARG as expected")));

            hr = E_FAIL;
        }
    }


#endif //_MAC
    
    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release child and root storages

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_108 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_108 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);
    
    // Delete temp strings

    if (NULL != pRootNewChildStgName)
    {
        delete []pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_108 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_109
//
// Synopsis: A root docfile is created with a child storage. Check StgSetTimes 
//           API work as expected to set times on root Storage and IStorage::
//           SetElementTimes on child storage. Verify by stat'ng on Storages 
//           and comparing stat'd times.  Then attempt setting times with NULL
//           time parameters.  Verify that earlier time set on storage remain
//           untouched.  Attempt illegitmate ops on the API. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    15-Aug-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File:  A part of OLECMN.CXX
// 2.  Old name of test : TestStgSetTime 
//     New Name of test : STGTEST_109 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-109
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-109
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-109
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, NA (add /dfStgType:conversion to each of the above)
// 5.  To run for nssfile, NA (add /dfStgType:nssfile to each of the above)
//     BUGBUG: -scousens  StgSetTimes not supported for nssfiles????
//
// BUGNOTE: Conversion: STGTEST-109
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_109(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPOLESTR        poszVirtualDFRootName   = NULL;
    DG_STRING       *pdgu                   = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fRet                    = FALSE;
    BOOL            fPass                   = TRUE;
    FILETIME        cNewRootStgFileTime     = {dwDefLowDateTime,
                                              dwDefHighDateTime};
    FILETIME        cNewChildStgFileTime    = {dwDefLowDateTime,
                                              dwDefHighDateTime};
    SYSTEMTIME      cCurrentSystemTime;    
    STATSTG         statStg;
    STATSTG         statStgChild;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_109"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_109 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legit/illegit tests on StgSetTimes API")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_109, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // StgSetTimes on Root stg

    if(S_OK == hr)
    {
        // Convert test name to OLECHAR

        hr = TStringToOleString(
                pVirtualDFRoot->GetVirtualCtrNodeName(), 
                &poszVirtualDFRootName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        GetSystemTime(&cCurrentSystemTime);

        fRet = SystemTimeToFileTime(&cCurrentSystemTime, &cNewRootStgFileTime);

        DH_ASSERT(TRUE == fRet);
        DH_ASSERT(dwDefLowDateTime != cNewRootStgFileTime.dwLowDateTime);
        DH_ASSERT(dwDefHighDateTime != cNewRootStgFileTime.dwHighDateTime);

        hr = StgSetTimes(
                poszVirtualDFRootName,
                &cNewRootStgFileTime,
                &cNewRootStgFileTime,
                &cNewRootStgFileTime);

        DH_HRCHECK(hr, TEXT("StgSetTimes")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API passed as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Now stat on root storage to see times are set correctly.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
    }


    // Compare times from  STATSTG structure.  FAT doesn't have enough 
    // resolution, so we would retrict to comapring dwHighDateTime part only
    // for mtime and ctime.

    if(S_OK == hr) 
    {
        if(cNewRootStgFileTime.dwHighDateTime == statStg.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile mtime set as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile mtime didn't set unexpectedly.")));
    
            fPass = FALSE;
        }

        if(cNewRootStgFileTime.dwHighDateTime == statStg.ctime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile ctime set as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile ctime didn't set unexpectedly.")));
    
            fPass = FALSE;
        }
    }

    // Release child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // SetElementTimes on Child Storage

    if(S_OK == hr)
    {
        GetSystemTime(&cCurrentSystemTime);

        fRet = SystemTimeToFileTime(&cCurrentSystemTime, &cNewChildStgFileTime);

        DH_ASSERT(TRUE == fRet);
        DH_ASSERT(dwDefLowDateTime != cNewChildStgFileTime.dwLowDateTime);
        DH_ASSERT(dwDefHighDateTime != cNewChildStgFileTime.dwHighDateTime);

        hr = pvcnRootNewChildStg->SetElementTimes(
                &cNewChildStgFileTime,
                &cNewChildStgFileTime,
                &cNewChildStgFileTime);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::SetElementTimes")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::SetElementTimes passed as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::SetElementTimes failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Now open and stat on child storage to see times are set correctly.

    // Open child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(NULL, dwStgMode, NULL, 0);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Stat on child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Stat(&statStgChild, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
    }


    // Compare times from  STATSTG structure.  FAT doesn't have enough 
    // resolution, so we would retrict to comapring dwHighDateTime part only
    // for mtime and ctime.

    if(S_OK == hr) 
    {
        if(cNewChildStgFileTime.dwHighDateTime == 
            statStgChild.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child Stg mtime set as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child stg mtime didn't set unexpectedly.")));
    
            fPass = FALSE;
        }

        if(cNewChildStgFileTime.dwHighDateTime == 
            statStgChild.ctime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child stg ctime set as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child Stg ctime didn't set unexpectedly.")));
    
            fPass = FALSE;
        }
    }

    // Release child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // StgSetTimes on Root stg with all NULL time elements.  Verify that the
    // time doesn't change,

    if(S_OK == hr)
    {
        hr = StgSetTimes(
                poszVirtualDFRootName,
                NULL,
                NULL,
                NULL);

        DH_HRCHECK(hr, TEXT("StgSetTimes with NULL time parameters")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API with NULL time param passed as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API with NULL time param fail unexp, hr=0x%lx"),
                hr));
        }
    }


    // Now stat on root storage to seeearlier times have remain untouched. 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
    }


    // Compare times from  STATSTG structure.  FAT doesn't have enough 
    // resolution, so we would retrict to comapring dwHighDateTime part only
    // for mtime and ctime.

    if(S_OK == hr) 
    {
        if(cNewRootStgFileTime.dwHighDateTime == statStg.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile mtime unchanged as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile mtime changed unexpectedly.")));
    
            fPass = FALSE;
        }

        if(cNewRootStgFileTime.dwHighDateTime == statStg.ctime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile ctime unchanged as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile ctime changed unexpectedly.")));
    
            fPass = FALSE;
        }
    }

    // SetElementTimes on Child Storage with all NULL times.  Verify that
    // the times remain unchanged.

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStg->SetElementTimes(NULL,NULL,NULL);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::SetElementTimes")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VCN::SetElementTimes with NULL times passed as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VCN:SetElementTimes with NULL times failed unexp,hr=0x%lx"),
                hr));
        }
    }


    // Now open and stat on child storage to see times are set correctly.

    // Open child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(NULL, dwStgMode, NULL, 0);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Stat on child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Stat(&statStgChild, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
    }


    // Compare times from  STATSTG structure.  FAT doesn't have enough 
    // resolution, so we would retrict to comapring dwHighDateTime part only
    // for mtime and ctime.

    if(S_OK == hr) 
    {
        if(cNewChildStgFileTime.dwHighDateTime == 
            statStgChild.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child Stg mtime unchanged as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child stg mtime changed unexpectedly.")));
    
            fPass = FALSE;
        }

        if(cNewChildStgFileTime.dwHighDateTime == 
            statStgChild.ctime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child stg ctime unchanged as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child Stg ctime changed unexpectedly.")));
    
            fPass = FALSE;
        }
    }

    // Release child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Attempt calling StgSetTimes with NULL name.

    if(S_OK == hr)
    {
        GetSystemTime(&cCurrentSystemTime);

        fRet = SystemTimeToFileTime(&cCurrentSystemTime, &cNewRootStgFileTime);

        DH_ASSERT(TRUE == fRet);
        DH_ASSERT(dwDefLowDateTime != cNewRootStgFileTime.dwLowDateTime);
        DH_ASSERT(dwDefHighDateTime != cNewRootStgFileTime.dwHighDateTime);

        hr = StgSetTimes(
                NULL,
                &cNewRootStgFileTime,
                &cNewRootStgFileTime,
                &cNewRootStgFileTime);

        DH_HRCHECK(hr, TEXT("StgSetTimes")) ;
        if(STG_E_INVALIDNAME == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API with NULL name failed as exp, hr = 0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes with NULL name didn't fail as exp, hr=0x%lx"),
                hr));
        }
    }


    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    
    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_109 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_109 failed, hr = 0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != poszVirtualDFRootName)
    {
        delete poszVirtualDFRootName;
        poszVirtualDFRootName = NULL;
    }

    if (NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_109 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_110
//
// Synopsis: A root docfile is created, then add a random number of streams
//           under the root storage, make sure the last stream's size is
//           less than 4K(ministream), then commit and release the docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    29-Oct-1996     JiminLi     Created.
//
// Notes:
//   To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-110
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-110
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-110
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-110
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_110(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    VirtualStmNode  **pvsnRootNewChildStream    = NULL;
    LPTSTR          *pRootNewChildStmName       = NULL;
    ULONG           culBytesWrite               = 0;
    DG_INTEGER      *pdgi                       = NULL;
    LPTSTR          ptcsBuffer                  = NULL;
    DG_STRING       *pdgu                       = NULL;
    DWORD           dwRootMode                  = 0;
    ULONG           ulIndex                     = 0;
    ULONG           ulStmNum                    = 0;
    ULONG           ulMinStm                    = 2;
    ULONG           ulMaxStm                    = 5;
    ULONG           culWritten                  = 0;
    USHORT          usErr                       = 0;


    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_110"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_110 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Test on adding a ministream into the root storage")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
 
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_110, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_UNICODE object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Generate the number of streams to create

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulStmNum, ulMinStm, ulMaxStm);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Initialization

    if (S_OK == hr)
    {
        pvsnRootNewChildStream = new VirtualStmNode*[ulStmNum];
        pRootNewChildStmName = new LPTSTR[ulStmNum];
 
        if ((NULL == pvsnRootNewChildStream) || (NULL == pRootNewChildStmName))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
        {
            pvsnRootNewChildStream[ulIndex] = NULL;
            pRootNewChildStmName[ulIndex] = NULL;
         }
    }

    // Create ulStmNum streams under the root storage

    for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
    {
        if (S_OK == hr)
        {
            // Generate random name for stream

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStmName[ulIndex]);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if (S_OK == hr)
        {
            hr = AddStream(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStmName[ulIndex],
                    0,
                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                    &pvsnRootNewChildStream[ulIndex]);

            DH_HRCHECK(hr, TEXT("AddStream")) ;
            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::AddStream completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx"),
                    hr));
            }
        }


        if (S_OK == hr)
        {
            // Generate random size for stream between MIN_STMSIZE and
            // MAX_STMSIZE if it's not the last stream, otherwise generate a 
            // size between 0 and MAXSIZEOFMINISTM(4k).
 
            if (ulStmNum-1 == ulIndex)
            {
                usErr = pdgi->Generate(&culBytesWrite,0L,MAXSIZEOFMINISTM);
            }
            else
            {
                usErr = pdgi->Generate(&culBytesWrite,MIN_STMSIZE,MAX_STMSIZE);
            }

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if (S_OK == hr)
        {
            // Generate a random string of size culBytesWrite

            hr = GenerateRandomString(
                    pdgu,
                    culBytesWrite,
                    culBytesWrite,
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr = pvsnRootNewChildStream[ulIndex]->Write(
                    ptcsBuffer,
                    culBytesWrite,
                    &culWritten);
            if (S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::Write not successful, hr=0x%lx."),
                    hr));
            }
        }


        // Delete the temp buffer

        if (NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_110 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_110 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);
    
    // Delete temp strings

    if (NULL != pvsnRootNewChildStream)
    {
        delete []pvsnRootNewChildStream;
        pvsnRootNewChildStream = NULL;
    }

    for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
    {
        if (NULL != pRootNewChildStmName[ulIndex])
        {
            delete pRootNewChildStmName[ulIndex];
            pRootNewChildStmName[ulIndex] = NULL;
        }
    }

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_110 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\dll\dllinit.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       dllinit.cxx
//
//  Contents:   OLE storage base tests
//
//  Functions:  dllinit 
//              RunTests
//
//  History:    22-Jan-1998    SCousens     Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "init.hxx"

extern int __cdecl main(int argc, char *argv[]);

#define STGBASE_INI "stgbase.ini"

HINSTANCE ghinstDll;


__declspec(dllexport) BOOL WINAPI DllMain( 
    HINSTANCE  hinstDLL, 
    DWORD  fdwReason,  
    LPVOID  lpvReserved)  
{ 
    if(fdwReason == DLL_PROCESS_ATTACH) 
    { 
        ghinstDll = hinstDLL; 
    } 
    return TRUE; 
} 

// read all the commandlines in from a .ini file and call main with them.
extern "C" __declspec(dllexport) void RunTest (void)
{
    HRESULT hr;
    FILE*   fp;
    CHAR    szLine[2048];
    int     count;
    int     argc;
    char  **argv;

    DH_FUNCENTRY (&hr, DH_LVL_TRACE1, TEXT("RunTests"));

    //Open the .ini file
    if (NULL == (fp = fopen (STGBASE_INI, "r")))
    {
        DH_TRACE ((DH_LVL_ERROR, 
                TEXT("Error opening stgbase.ini  Err=%ld"),
                GetLastError ()));
        MessageBox (NULL, 
                TEXT("Error Occured while opening stgbase.ini"), 
                TEXT("Sandbox Test"), 
                MB_ICONERROR | MB_ICONSTOP);
        return;
    }
    
    // read a line
    while (fgets (szLine, sizeof(szLine), fp) != NULL)
    {
        // safety check - if 1st char is alphanum assume ok.
        if (*szLine >= 'A' && *szLine <= 'Z' ||
            *szLine >= 'a' && *szLine <= 'z' ||
            *szLine >= '1' && *szLine <= '0')
        {
            // convert to argc argv and call main
            hr = CmdlineToArgs (szLine, &argc, &argv);
            DH_HRCHECK (hr, TEXT("CmdlineToArgs"));
            if (S_OK == hr)
            {
                hr = main (argc, argv);
                DH_HRCHECK (hr, TEXT("Call to Stgbase::main"));
            }

           // cleanup for arguments strings
           if (NULL != argv)
           {
               for (count=0; count<argc; count++)
                   delete argv[count];
               delete [] argv;
           }
        }
    }
    fclose (fp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgdrt\drt.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       drt.cxx
//
//  Contents:   DRT main routine
//
//  History:    22-Sep-92       DrewB   Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "tests.hxx"
#include "illeg.hxx"

// Test flags and type
typedef ULONG FLAGS;

#define TF_NONE                 0x00000000

// Suppression flags
#define TF_SUPPRESS             0x0000FFFF
#define TFS_ILLEGITIMATE        0x00000001
#define TFS_16BIT               0x00000002

// Enabling flags
#define TF_ENABLE               0xFFFF0000
#define TFE_DIRECT              0x00010000
#define TFE_TRANSACTED          0x00020000
#define TFE_INDEPENDENT         0x00040000
#define TFE_ANY                 (TFE_DIRECT | TFE_TRANSACTED | TFE_INDEPENDENT)

// Pointer to a test function
typedef void (*TestFn)(void);

static struct
{
    char *pszName;
    char *pszDesc;
    TestFn tfn;
    FLAGS flags;
} tests[] =
{
    "Create",   "Creation",
        t_create, TFE_ANY,
    "Open",     "Opening",
        t_open, TFE_ANY,
    "AddRef",   "AddRef/Release",
        t_addref, TFE_ANY,
    "TModify",  "Transacted modify/Commit/Revert",
        t_tmodify, TFE_TRANSACTED | TFE_INDEPENDENT,
    "DModify",  "Direct modifications",
        t_dmodify, TFE_DIRECT,
    "Stat",     "Stat",
        t_stat, TFE_ANY,
    "Stream",   "Stream operations",
        t_stream, TFE_ANY,
    "Enum",     "Enumerator operations",
        t_enum, TFE_ANY,
    "StgCopyTo", "IStorage::CopyTo",
        t_stgcopyto, TFE_ANY,
    "MoveCopy", "IStorage::MoveElementTo",
        t_movecopy, TFE_ANY,
    "Marshal",  "IMarshal operations",
        t_marshal, TFE_ANY,
    "ILockBytes", "ILockBytes usage",
        t_ilb, TFE_ANY,
    "StgMisc",  "Miscellaneous Stg functions",
        t_stgmisc, TFE_ANY,

    "IllStg", "Illegitimate IStorage calls",
        i_storage, TFE_ANY | TFS_ILLEGITIMATE,
    "IllStm", "Illegitimate IStream calls",
        i_stream, TFE_ANY | TFS_ILLEGITIMATE,
    "IllEnum", "Illegitimate enumerator calls",
        i_enum, TFE_ANY | TFS_ILLEGITIMATE
};
#define NTESTS (sizeof(tests)/sizeof(tests[0]))

DWORD dwTransacted = 0;
DWORD dwRootDenyWrite = STGM_SHARE_DENY_WRITE;
BOOL fVerbose = FALSE;
BOOL fOfs = FALSE;
OLECHAR atcDrtDocfile[_MAX_PATH];

static BOOL fRun[NTESTS];
#ifdef FLAT
static FLAGS flTests = TF_NONE;
#else
static FLAGS flTests = TF_NONE | TFS_16BIT;
#endif

static void Initialize(void)
{
    SCODE sc;

    SetData();
#if WIN32 == 300
    if (FAILED(sc = DfGetScode(CoInitializeEx(NULL, COINIT_MULTITHREADED))))
        error(EXIT_UNKNOWN,
              "CoInitializeEx failed with sc = 0x%lX\n", sc);
#else
    if (FAILED(sc = DfGetScode(CoInitialize(NULL))))
        error(EXIT_UNKNOWN,
              "CoInitialize failed with sc = 0x%lX\n", sc);
#endif
}

static void Uninitialize(void)
{
    UnsetData();
    CoUninitialize();
}

static int FindTest(char *pszName)
{
    int i, cchName;

    cchName = strlen(pszName);
    for (i = 0; i<NTESTS; i++)
        if (!_strnicmp(pszName, tests[i].pszName, cchName))
            return i;
    return -1;
}

static void RunTests(void)
{
    int i;

    for (i = 0; i<NTESTS; i++)
        // For a test to run:
        // 1)  fRun[test] must be TRUE
        // 2)  No suppression flags can be set that are not set in flTests
        // 3)  At least one enabling flag must be set that is set in flTests
        if (fRun[i] &&
            (tests[i].flags & ~flTests & TF_SUPPRESS) == 0 &&
            (tests[i].flags & flTests & TF_ENABLE) != 0)
        {
            out("\n----- Test #%2d - %s -----\n", i+1, tests[i].pszDesc);
            tests[i].tfn();
            CheckMemory();
            CleanData();
        }
}

static void Usage(void)
{
    int i;

    printf("Usage: drt [options]\n");
    printf("Options are:\n");
    printf("  -h        - This message\n");
    printf("  -d        - Suppress direct tests\n");
    printf("  -t        - Suppress transacted tests\n");
    printf("  -w        - Suppress independent tests\n");
    printf("  -i        - Enable illegitimate tests\n");
    printf("  -v        - Display test output\n");
#if WIN32 == 300
    printf("  -o        - Enable tests to run on OFS\n");
#endif
    printf("  -y<kind>  - Control debug output (a, d, m, i, M, L)\n");
    printf("  -#[+|-]<number>   - Turn test <number> on (+) or off (-)\n");
    printf("                      No number means all\n");
    printf("  -n[+|-]<prefix>   - Turn test <prefix> on or off\n");
    printf("  -N<file>  - Set file to use for tests\n");
    printf("Prefix can be any prefix of:\n");
    for (i = 0; i<NTESTS; i++)
        printf("  %s\n", tests[i].pszName);
    exit(1);
}

int __cdecl main(int argc, char **argv)
{
    int i, iTest;
    BOOL fDirect = TRUE, fTrans = TRUE, fIndep = TRUE;

    SetDebug(0x101, 0x101);
    for (i = 0; i<NTESTS; i++)
        fRun[i] = TRUE;
    ATOOLE("drt.dfl", atcDrtDocfile, _MAX_PATH);
    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case '#':
                if (sscanf(argv[0]+3, "%d", &iTest) != 1)
                    iTest = -1;
                else
                    iTest--;
                for (i = 0; i<NTESTS; i++)
                    if (iTest == -1 || iTest == i)
                        fRun[i] = argv[0][2] == '+';
                break;
            case 'd':
                fDirect = FALSE;
                break;
            case 'i':
                flTests |= TFS_ILLEGITIMATE;
                break;
            case 'n':
                iTest = FindTest(argv[0]+3);
                if (iTest >= 0)
                    fRun[iTest] = argv[0][2] == '+';
                break;
            case 'N':
                ATOOLE(argv[0]+2, atcDrtDocfile, _MAX_PATH);
                break;
            case 't':
                fTrans = FALSE;
                break;
            case 'v':
                fVerbose = TRUE;
                break;
            case 'w':
                fIndep = FALSE;
                break;
            case 'y':
                switch(argv[0][2])
                {
                case 'a':
                    SetDebug(0xffffffff, 0xffffffff);
                    break;
                case 'd':
                    SetDebug(0xffffffff, 0x101);
                    break;
                case 'm':
                    SetDebug(0x101, 0xffffffff);
                    break;
                case 'i':
                    SetDebug(0x101, 0x101);
                    break;
                case 'M':
                    SetDebug(0x01100000, 0);
                    break;
                case 'L':
                    SetDebug(0x00100000, 0);
                    break;
                }
                break;
#if WIN32 == 300
            case 'o':
                fOfs = TRUE;
                break;
#endif
            case 'h':
            default:
                Usage();
            }
        }
        else
            Usage();
    }

    Initialize();

    if (fDirect)
    {
        out("\n---------- Direct ----------\n");
        dwTransacted = 0;
        dwRootDenyWrite = STGM_SHARE_EXCLUSIVE;
        flTests |= TFE_DIRECT;
        RunTests();
        flTests &= ~TFE_DIRECT;
    }

#if WIN32 == 300
    if (fTrans && !fOfs)  // turn off transacted tests for OFS
#else
    if (fTrans)
#endif
    {
        out("\n---------- Transacted ----------\n");
        dwTransacted = STGM_TRANSACTED;
        dwRootDenyWrite = STGM_SHARE_DENY_WRITE;
        flTests |= TFE_TRANSACTED;
        RunTests();
        flTests &= ~TFE_TRANSACTED;
    }

#if WIN32 == 300
    if (fIndep && !fOfs)  // turn off transacted tests for OFS
#else
    if (fIndep)
#endif
    {
        out("\n---------- Independent ----------\n");
        dwTransacted = STGM_TRANSACTED;
        dwRootDenyWrite = STGM_SHARE_DENY_NONE;
        flTests |= TFE_INDEPENDENT;
        RunTests();
        flTests &= ~TFE_INDEPENDENT;
    }

    printf("Storage DRT - PASSED\n");

    Uninitialize();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgdrt\drtguid.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	drtguid.cxx
//
//  Contents:	Define GUIDs needed by the DRT
//
//  History:	04-Nov-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <initguid.h>

#if WIN32 == 100 || WIN32 == 200
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\trktest\trktest.cxx ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

WCHAR *Convert(char *psz)
{	int c;
	WCHAR *pwsz = new WCHAR [ c = strlen(psz) + 1 ];
	if (pwsz)
		mbstowcs(pwsz, psz, c);
	return pwsz;
}

#define CHECKNE(hr, stat, string, errRet) \
if (hr != stat) { iLine = __LINE__; pszErr = string; goto errRet; }

HRESULT TouchFile(WCHAR *pwszSource)
{
    FILETIME ftc;
    SYSTEMTIME st;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftc);
    return StgSetTimes(pwszSource, &ftc, NULL, NULL);
}

HRESULT CreateLink(WCHAR *pwszClient, WCHAR *pwszSource)
{
	HRESULT hr;
	IBindCtx *pbc=NULL;
	ULONG ulEaten;
	IMoniker *pmkSource=NULL;
	IStorage *pstg=NULL;
	IOleObject *poo=NULL;
	IMoniker *pmkThis=NULL;
	IMoniker *pmkLink=NULL;
	IPersistStorage *pps=NULL;
	char *pszErr;
	int iLine=0;

	hr = CreateFileMoniker(pwszClient, &pmkThis);
	CHECKNE(hr, S_OK, "CreateFileMoniker", errRet);
	hr = CreateItemMoniker(L"!", L"Link", &pmkLink);
	CHECKNE(hr, S_OK, "CreateItemMoniker", errRet);
	hr = StgCreateDocfile(pwszClient, STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
		0, &pstg);
	CHECKNE(hr, S_OK, "StgCreateDocfile", errRet);
	hr = CreateBindCtx(0, &pbc);
	CHECKNE(hr, S_OK, "CreateBindCtx", errRet);
	hr = MkParseDisplayName(pbc, pwszSource, &ulEaten, &pmkSource);
	CHECKNE(hr, S_OK, "MkParseDisplayName", errRet);
	hr = OleCreateLink(pmkSource, IID_IOleObject, OLERENDER_NONE, NULL, NULL, pstg, (void**)&poo);
	CHECKNE(hr, S_OK, "OleCreateLink", errRet);
	hr = poo->SetMoniker(OLEWHICHMK_CONTAINER, pmkThis);
	CHECKNE(hr, S_OK, "SetMonikerOLEWHICHMK_CONTAINER", errRet);
	hr = poo->SetMoniker(OLEWHICHMK_OBJREL, pmkLink);
	CHECKNE(hr, S_OK, "SetMonikerOLEWHICHMK_OBJREL", errRet);
	hr = poo->QueryInterface(IID_IPersistStorage, (void**)&pps);
	CHECKNE(hr, S_OK, "QueryInterface(IID_IPersistStorage", errRet);
	hr = OleSave(pps, pstg, TRUE);
	CHECKNE(hr, S_OK, "OleSave", errRet);

errRet:
	if (hr != S_OK)
            printf("CreateLink at %s line %d with hr=%08x\n", pszErr, iLine, hr);

	if (pbc) pbc->Release();
	if (pmkSource) pmkSource->Release();
	if (pstg) pstg->Release();
	if (poo) poo->Release();
	if (pmkThis) pmkThis->Release();
	if (pmkLink) pmkLink->Release();
	if (pps) pps->Release();

	return hr;
}

HRESULT ResolveLink(WCHAR *pwszClient, WCHAR *pwszSource, BOOL fReSave)
{
	HRESULT hr;
	IStorage *pstg = NULL;
	IOleLink *pol = NULL;
	WCHAR *pwszSourceFound = NULL;
	IPersistStorage *pps = NULL;
	char *pszErr;
	int iLine;

	hr = StgOpenStorage(pwszClient, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
		NULL, 0, &pstg);
	CHECKNE(hr, S_OK, "StgOpenStorage(pwszClient", errRet);
	hr = OleLoad(pstg, IID_IOleLink, NULL, (void**)&pol);
	CHECKNE(hr, S_OK, "OleLoad(pstg, IID_IOleLink", errRet);
	hr = pol->BindToSource(0, NULL);
	CHECKNE(hr, S_OK, "pol->BindToSource", errRet);
	hr = pol->GetSourceDisplayName(&pwszSourceFound);
	CHECKNE(hr, S_OK, "pol->GetSourceDisplayName", errRet);
	if (wcsicmp(pwszSourceFound, pwszSource) != 0)
	{
		printf("SourceFound=%ls, SourceExpected=%ls\n", pwszSourceFound, pwszSource);
                pszErr = "'path compare'";
		hr = E_FAIL;
		goto errRet;
	}

	if (fReSave)
	{
		hr = pol->QueryInterface(IID_IPersistStorage, (void**)&pps);
		CHECKNE(hr, S_OK, "pol->QueryInterface(IID_IPersistStorage", errRet);
		hr = OleSave(pps, pstg, TRUE);
		CHECKNE(hr, S_OK, "OleSave(pps, pstg, TRUE)", errRet);
	}

errRet:
	if (hr != S_OK)
            printf("ResolveLink at %s line %d with hr=%08x\n", pszErr, iLine, hr);

	CoTaskMemFree(pwszSourceFound);
	if (pol) pol->Release();
	if (pstg) pstg->Release();
	if (pps) pps->Release();
	return hr;
}

int __cdecl main(int argc, char **argv)
{
	char * pszExit = "TEST FAILED.";
	int iExit = 1;
	WCHAR *pwszClient = NULL;
	WCHAR *pwszSource = NULL;
	HRESULT hr=E_FAIL;
	BOOL fArgsOk = FALSE;
        HRESULT hrExpected=S_OK;

	CoInitialize(NULL);
	OleInitialize(NULL);

        if (argc >= 3)
        {
		pwszClient = Convert(argv[2]);
        }

        if (argc >= 5)
        {
		pwszSource = Convert(argv[3]);
                sscanf(argv[4], "%x", &hrExpected);
		if (!pwszClient || !pwszSource)
		{
			pszExit = "Out of memory.";
			goto errExit;
		}
        }

        if (argc == 3)
        {
		if (stricmp(argv[1], "/t") == 0 || stricmp(argv[1], "-t") == 0)
		{
			// touch file creation date
			hr = TouchFile(pwszClient);
			fArgsOk = TRUE;
		}
        }
        else
	if (argc == 5)
	{
		if (stricmp(argv[1], "/c") == 0 || stricmp(argv[1], "-c") == 0)
		{
			// create link
			hr = CreateLink(pwszClient, pwszSource);
			fArgsOk = TRUE;
		}
	}
	else
	if (argc == 6)
	{
		if (stricmp(argv[1], "/r") == 0 || stricmp(argv[1], "-r") == 0)
		{
			// resolve link
			hr = ResolveLink(pwszClient, pwszSource, argv[5][0] == 's');
			fArgsOk = TRUE;
		}
	}

	if (!fArgsOk)
	{
		pszExit = "Usage: /c client source expected_status -- create .lts file linked to source\n"
			  "       /r client expected_source expected_status save/nosave  -- resolve .lts file, checked linked to source\n"
                          "       expected_source is ignored(but required) if not found during resolve.\n"
                          "       /t source -- change the creation date\n";

	}
        else
        {
            if (hrExpected != hr)
            {
                printf("Expected status = %08X, actual status = %08X\n",
                    hrExpected,
                    hr);
            }
            else
            {
                pszExit = "TEST PASSED.";
                iExit = 0;
            }
        }
	
errExit:

	OleUninitialize();
	CoUninitialize();

	delete pwszClient;
	delete pwszSource;

	puts(pszExit);

	return iExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgdrt\util.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	util.cxx
//
//  Contents:	DRT support routines
//
//  History:	22-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <stdarg.h>
#include <direct.h>
#include <io.h>

#if DBG == 1
#include <dfdeb.hxx>
#endif

#define DEFAULT_DATA_DIR "."

BOOL fExitOnFail = TRUE;

char szOrigDir[_MAX_PATH] = ".";

// Preserve the current directory and change
// directory into the data directory
void SetData(void)
{
    char *pszDataDir;

    _getcwd(szOrigDir, _MAX_PATH);
    pszDataDir = getenv("DRTDATA");
    if (pszDataDir == NULL)
	pszDataDir = DEFAULT_DATA_DIR;
    _chdir(pszDataDir);
}

// Clean up the data directory
void CleanData(void)
{
    _unlink(OlecsOut(DRTDF));
    _unlink(OlecsOut(MARSHALDF));
}

// Restore the original directory
void UnsetData(void)
{
    _chdir(szOrigDir);
}

// Output a message if fVerbose is true
void out(char *fmt, ...)
{
    va_list args;

    if (fVerbose)
    {
	va_start(args, fmt);
	vprintf(fmt, args);
	va_end(args);
    }
}

//  internal error print
void _errorprint (char *fmt, va_list args)
{
#if !defined(FLAT) || defined(FPRINTF_WORKS)
    fprintf(stderr, "** Fatal error **: ");
    vfprintf(stderr, fmt, args);
#else
    printf("** Fatal error **: ");
    vprintf(fmt, args);
#endif
}

//  error print
void errorprint (char *fmt, ...)
{
    va_list args;

    va_start (args, fmt);

    _errorprint (fmt, args);

    va_end (args);
}

// Print out an error message and terminate the DRT
void error(int code, char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);

    _errorprint (fmt, args);

    va_end(args);
    CleanData();
    UnsetData();
    exit(code);
}


// Converts a TCHAR string to a char pointer in a temporary buffer
// This implementation treats the conversion buffer as a circular
// buffer so more than one string can be held (depending on the size
// of the strings)

#define BUFSIZE 1024

char *OlecsOut(OLECHAR const *ptcs)
{
#ifdef OLEWIDECHAR
    static char szBuffer[BUFSIZE];
    static char *pszBuf = szBuffer;
    char *pszTmp;

    if (ptcs == NULL)
        return NULL;
    if (wcslen(ptcs) >= (size_t)(BUFSIZE-(pszBuf-szBuffer)))
        pszBuf = szBuffer;
    wcstombs(pszBuf, ptcs, BUFSIZE);
    szBuffer[BUFSIZE-1] = 0;
    pszTmp = pszBuf;
    pszBuf += strlen(pszBuf)+1;
    return pszTmp;
#else
    return (char *)ptcs;
#endif
}

typedef struct
{
    SCODE sc;
    char *text;
} StatusCodeText;

static StatusCodeText scodes[] =
{
    S_OK, "S_OK",
    S_FALSE, "S_FALSE",
    STG_E_INVALIDFUNCTION, "STG_E_INVALIDFUNCTION",
    STG_E_FILENOTFOUND, "STG_E_FILENOTFOUND",
    STG_E_PATHNOTFOUND, "STG_E_PATHNOTFOUND",
    STG_E_TOOMANYOPENFILES, "STG_E_TOOMANYOPENFILES",
    STG_E_ACCESSDENIED, "STG_E_ACCESSDENIED",
    STG_E_INVALIDHANDLE, "STG_E_INVALIDHANDLE",
    STG_E_INSUFFICIENTMEMORY, "STG_E_INSUFFICIENTMEMORY",
    STG_E_INVALIDPOINTER, "STG_E_INVALIDPOINTER",
    STG_E_NOMOREFILES, "STG_E_NOMOREFILES",
    STG_E_DISKISWRITEPROTECTED, "STG_E_DISKISWRITEPROTECTED",
    STG_E_SEEKERROR, "STG_E_SEEKERROR",
    STG_E_WRITEFAULT, "STG_E_WRITEFAULT",
    STG_E_READFAULT, "STG_E_READFAULT",
    STG_E_SHAREVIOLATION, "STG_E_SHAREVIOLATION",
    STG_E_LOCKVIOLATION, "STG_E_LOCKVIOLATION",
    STG_E_FILEALREADYEXISTS, "STG_E_FILEALREADYEXISTS",
    STG_E_INVALIDPARAMETER, "STG_E_INVALIDPARAMETER",
    STG_E_MEDIUMFULL, "STG_E_MEDIUMFULL",
    STG_E_ABNORMALAPIEXIT, "STG_E_ABNORMALAPIEXIT",
    STG_E_INVALIDHEADER, "STG_E_INVALIDHEADER",
    STG_E_INVALIDNAME, "STG_E_INVALIDNAME",
    STG_E_UNKNOWN, "STG_E_UNKNOWN",
    STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
    STG_E_INVALIDFLAG, "STG_E_INVALIDFLAG",
    STG_E_INUSE, "STG_E_INUSE",
    STG_E_NOTCURRENT, "STG_E_NOTCURRENT",
    STG_E_REVERTED, "STG_E_REVERTED",
    STG_E_CANTSAVE, "STG_E_CANTSAVE",
    STG_E_OLDFORMAT, "STG_E_OLDFORMAT",
    STG_E_OLDDLL, "STG_E_OLDDLL",
    STG_E_SHAREREQUIRED, "STG_E_SHAREREQUIRED",
    STG_E_NOTFILEBASEDSTORAGE, "STG_E_NOTFILEBASEDSTORAGE",
    STG_E_EXTANTMARSHALLINGS, "STG_E_EXTANTMARSHALLINGS",
    STG_S_CONVERTED, "STG_S_CONVERTED"
};
#define NSCODETEXT (sizeof(scodes)/sizeof(scodes[0]))

// Convert a status code to text
char *ScText(SCODE sc)
{
    int i;

    for (i = 0; i<NSCODETEXT; i++)
	if (scodes[i].sc == sc)
	    return scodes[i].text;
    return "?";
}

// Output a call result and check for failure
HRESULT Result(HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out(" - %s (0x%lX)\n", ScText(sc), sc);
    if (FAILED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call failure\n");
    return hr;
}

// Perform Result() when the expectation is failure
HRESULT IllResult(char *pszText, HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out("%s - %s (0x%lX)\n", pszText, ScText(sc), sc);
    if (SUCCEEDED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call success\n");
    return hr;
}

// DEBUG - Check for memory leaks
void CheckMemory(void)
{
#if DBG == 1
    if (fVerbose || DfGetMemAlloced() != 0)
    {
	out("Memory held: %lu bytes\n", DfGetMemAlloced());
	if (DfGetMemAlloced() != 0)
	{
	    DfPrintAllocs();
            error(EXIT_BADSC, "Memory leak\n");
	}
    }
#endif
}

// DEBUG - Set the debugging level
void SetDebug(ULONG ulDf, ULONG ulMsf)
{
#if DBG == 1
    DfDebug(ulDf, ulMsf);
#endif
}

// Check whether a given storage has a certain
// structure or not
// Structure is given as a string with elements:
//   <Type><Name><Options>[,...]
//   Type - d for docfile and s for stream
//   Name - Characters up to a '(' or ','
//   Options - For a docfile, you can specify a recursive check
//     in parentheses
//
// Example:  dDocfile(sStream,dDocfile)
char *VerifyStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    char chType;
    SCODE sc;
    CStrList sl;
    SStrEntry *pse;
    IEnumSTATSTG *penm;
    STATSTG stat;
    OLECHAR atcName[CWCSTORAGENAME];

    if (FAILED(sc = DfGetScode(pstg->EnumElements(0, NULL, 0, &penm))))
	error(EXIT_BADSC, "VerifyStructure: Unable to create enumerator - "
	      "%s (0x%lX)\n", ScText(sc), sc);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, &stat, NULL));
	if (sc == S_FALSE)
	    break;
	else if (FAILED(sc))
	    error(EXIT_BADSC, "VerifyStructure: Unable to enumerate - "
	      "%s (0x%lX)\n", ScText(sc), sc);
	pse = sl.Add(stat.pwcsName);
	if (pse == NULL)
	    error(EXIT_OOM, "VerifyStructure: Unable to allocate string\n");
	pse->user.dw = stat.type;
	drtMemFree(stat.pwcsName);
    }
    penm->Release();
    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	pse = sl.Find(atcName);
	if (pse == NULL)
	    error(EXIT_BADSC, "VerifyStructure: '%s' not found\n", szName);
	switch(chType)
	{
	case 'd':
	    if (pse->user.dw != STGTY_STORAGE)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a storage\n",
		      szName);
	    sc = DfGetScode(pstg->OpenStorage(atcName, NULL,
                                              STGP(STGM_READWRITE), NULL,
                                              0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "VerifyStructure: can't open storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = VerifyStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    if (pse->user.dw != STGTY_STREAM)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a stream\n",
		      szName);
	    break;
	}
	sl.Remove(pse);
	if (*pszStructure == ',')
	    pszStructure++;
    }
    for (pse = sl.GetHead(); pse; pse = pse->pseNext)
	error(EXIT_BADSC, "VerifyStructure: additional member '%s'\n",
	      OlecsOut(pse->atc));
    return pszStructure;
}

// Creates a structure using the same syntax
// as VerifyStructure
char *CreateStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    IStream *pstmChild;
    char chType;
    SCODE sc;
    OLECHAR atcName[CWCSTORAGENAME];

    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	switch(chType)
	{
	case 'd':
	    sc = DfGetScode(pstg->CreateStorage(atcName, STGP(STGM_READWRITE),
                                                0, 0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = CreateStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    sc = DfGetScode(pstg->CreateStream(atcName, STMP(STGM_READWRITE),
                                               0, 0, &pstmChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create stream "
		      "'%s' - %s\n", szName, ScText(sc));
	    pstmChild->Release();
	    break;
	}
	if (*pszStructure == ',')
	    pszStructure++;
    }
    pstg->Commit(0);
    return pszStructure;
}

// Verifies the fields of a STATSTG
void VerifyStat(STATSTG *pstat, OLECHAR *ptcsName, DWORD type, DWORD grfMode)
{
    if (ptcsName == NULL)
    {
        if (pstat->pwcsName != NULL)
	    error(EXIT_BADSC, "Stat name should be NULL - is %p\n",
                  pstat->pwcsName);
    }
    else if (olecscmp(pstat->pwcsName, ptcsName))
	error(EXIT_BADSC, "Stat name mismatch - has '%s' vs. '%s'\n",
	      OlecsOut(pstat->pwcsName), OlecsOut(ptcsName));
    if (pstat->type != type)
	error(EXIT_BADSC, "Stat type mismatch - has %lu vs. %lu\n",
	      pstat->type, type);
    if (pstat->grfMode != grfMode)
	error(EXIT_BADSC, "Stat mode mismatch - has 0x%lX vs. 0x%lX\n",
	      pstat->grfMode, grfMode);
}

// Checks on a file's existence
BOOL Exists(OLECHAR *file)
{
    OFSTRUCT of;

#ifndef OLEWIDECHAR
    return OpenFile(file, &of, OF_EXIST | OF_SHARE_DENY_NONE) !=
	HFILE_ERROR ? TRUE : FALSE;
#else
    char szName[_MAX_PATH];
    wcstombs(szName, file, _MAX_PATH);
    return OpenFile(szName, &of, OF_EXIST | OF_SHARE_DENY_NONE) !=
	HFILE_ERROR ? TRUE : FALSE;
#endif
}

// Gets a file's length
ULONG Length(OLECHAR *file)
{
    ULONG cb;

#ifndef WIN32

    OFSTRUCT of;
    int hf;
    hf = OpenFile(file, &of, OF_READ | OF_SHARE_DENY_NONE);
    if (hf == HFILE_ERROR)
        error(EXIT_BADSC, "Length: Unable to open '%s'\n", OlecsOut(file));
    cb = (ULONG)_llseek(hf, 0, SEEK_END);
    if (cb == (ULONG)HFILE_ERROR)
        error(EXIT_BADSC, "Length: Unable to get length for '%s'\n",
              OlecsOut(file));
    _lclose(hf);

#else

    // use WIN32 APIs

    HANDLE hf;

#if !defined(UNICODE)

    // Chicago - call ANSI CreateFile

    char szName[_MAX_PATH];
    if (wcstombs(szName, file, _MAX_PATH) == (size_t)-1)
        return 0;

    hf = CreateFile (
        szName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

#else

    hf = CreateFile (
        file,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

#endif // !defined(UNICODE)

    if (hf == INVALID_HANDLE_VALUE)
        error(EXIT_BADSC, "Length: Unable to open '%s'\n", OlecsOut(file));
    cb = (ULONG)GetFileSize(hf, NULL);
    if (cb == (ULONG)0xFFFFFFFF)
        error(EXIT_BADSC, "Length: Unable to get length for '%s'\n",
              OlecsOut(file));
    CloseHandle(hf);

#endif // !WIN32

    return cb;
}

// Original mode when a new mode is forced
// Used by ForceDirect, ForceTransacted and Unforce
static DWORD dwTransOld;
static DWORD dwRDWOld;

// Forces direct mode to be active
// Note:  this uses a static variable so it can\'t be nested
void ForceDirect(void)
{
    dwTransOld = dwTransacted;
    dwTransacted = STGM_DIRECT;
    dwRDWOld = dwRootDenyWrite;
    dwRootDenyWrite = STGM_SHARE_EXCLUSIVE;
}

// Forces transacted mode similarly to ForceDirect
void ForceTransacted(void)
{
    dwTransOld = dwTransacted;
    dwRDWOld = dwRootDenyWrite;
    dwTransacted = STGM_TRANSACTED;
}

// Returns to the original mode after a ForceDirect or ForceTransacted
void Unforce(void)
{
    dwTransacted = dwTransOld;
    dwRootDenyWrite = dwRDWOld;
}

// Equality for FILETIME
BOOL IsEqualTime(FILETIME ttTime, FILETIME ttCheck)
{
    //  File times can be off by as much as 2 seconds due to FAT rounding
    LONGLONG tmTime = *(LONGLONG *)&ttTime;
    LONGLONG tmCheck = *(LONGLONG *)&ttCheck;
    LONGLONG tmDelta = tmTime - tmCheck;

    return tmDelta < 20000000i64 && tmDelta > -2i64 ;
}

// Get a fully qualified path for a file name
void GetFullPath(OLECHAR *file, OLECHAR *path)
{
#ifndef UNICODE
    char buf[_MAX_PATH];
    OFSTRUCT of;

    OLETOA(file, buf, _MAX_PATH);
    OpenFile(buf, &of, OF_PARSE);
    ATOOLE((char *)of.szPathName, path, _MAX_PATH);
#else
    OLECHAR *ptcsFile;

    GetFullPathName(file, _MAX_PATH, path, &ptcsFile);
#endif
}

//  Memory helper functions

HRESULT drtMemAlloc(ULONG ulcb, void **ppv)
{
    HRESULT hr;
    IMalloc *pMalloc = NULL;

    if (SUCCEEDED(DfGetScode(hr = CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        *ppv = pMalloc->Alloc(ulcb);
        pMalloc->Release();

        if (*ppv == NULL)
            return ResultFromScode(E_OUTOFMEMORY);
    }

    return hr;
}

void drtMemFree(void *pv)
{
    IMalloc FAR* pMalloc;
    if (SUCCEEDED(GetScode(CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

char *GuidText(GUID const *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgdrt\ilb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	ilbmem.cx
//
//  Contents:	ILockBytes memory implementation
//
//  Classes:	CMapBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <memory.h>
#include <ilb.hxx>

#if DBG == 1

DECLARE_INFOLEVEL(ol);

#endif

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::CMapBytes, public
//
//  Synopsis:   constructor
//
//  Effects:    initialize member variables
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:      Returns a fully initialized CMapBytes (ref count == 1)
//
//--------------------------------------------------------------------------

CMapBytes::CMapBytes(void)
{
    _ulSize = 0;
    _pv = 0;

    _ulRef = 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::QueryInterface, public
//
//  Arguments:	[riid] - interface id
//		[ppvObj] - place holder for interface
//
//  Returns:    Always fails
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:      Not used in tests
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::AddRef, public
//
//  Synopsis:	add reference
//
//  Returns:    post reference count
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::AddRef(void)
{
    AtomicInc(&_ulRef);
    return(_ulRef);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Release, public
//
//  Synopsis:	release reference
//
//  Effects:	deletes object when reference count reaches zero
//
//  Returns:	post reference count
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::Release(void)
{
    AtomicDec(&_ulRef);

    if (_ulRef > 0)
        return(_ulRef);

    free(_pv);

    delete this;

    return(0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::ReadAt
//
//  Synopsis:   Reads bytes from memory
//
//  Arguments:  [ulOffset] - byte offset
//		[pv]       - input buffer
//		[cb]       - count of bytes to read
//		[pcbRead]  - count of bytes read
//
//  Returns:    SCODE
//
//  Modifies:   pv, pcbRead
//
//  Derivation: ILockBytes
//
//  History:    30-Oct-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::ReadAt(ULARGE_INTEGER uliOffset,
			       VOID HUGEP *pv,
			       ULONG cb,
			       ULONG *pcbRead)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    if (ulOffset >= _ulSize)
    {
        //  truncate read
        cb = 0;
    }
    else if (cb > (_ulSize - ulOffset))
    {
        //  truncate range that exceeds size
        cb = _ulSize - ulOffset;
    }

    memcpy(pv, (void*)(((BYTE*)_pv) + ulOffset), (size_t) cb);
    *pcbRead = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::WriteAt, public
//
//  Synopsis:	Writes bytes to memory
//
//  Effects:	May change memory size
//
//  Arguments:	[uliOffset]  - byte offset
//		[pv]         - output buffer
//		[cb]         - count of bytes to write
//		[pcbWritten] - count of bytes written
//
//  Returns:	SCODE
//
//  Modifies:	pcbWritten
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:	This implementation doesn't write partial buffers.
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::WriteAt(ULARGE_INTEGER uliOffset,
				VOID const HUGEP *pv,
				ULONG cb,
				ULONG FAR *pcbWritten)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    HRESULT hr;

    if (ulOffset + cb > _ulSize)
    {
        //  increase memory buffer to accomodate write

        ULARGE_INTEGER uliSize;

        ULISetHigh(uliSize, 0);
        ULISetLow(uliSize, ulOffset + cb);
        hr = SetSize(uliSize);

        if (FAILED(DfGetScode(hr)))
        {
            //  don't bother writing partial buffers

            *pcbWritten = 0;
            return hr;
        }
    }

    memcpy((void *)(((BYTE*)_pv) + ulOffset), pv, (size_t) cb);
    *pcbWritten = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Flush, public
//
//  Synopsis:	flushes memory - not appropriate for this implementation
//
//  Effects:	none
//
//  Returns:    SUCCESS_SUCCESS
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Flush(void)
{
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::GetSize, public
//
//  Synopsis:	gets memory buffer size
//
//  Arguments:	[pcb] - size place holder
//
//  Returns:	SUCCESS_SUCCESS
//
//  Modifies:	pcb
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::GetSize(ULARGE_INTEGER FAR *pcb)
{
    ULISetHigh(*pcb, 0);
    ULISetLow(*pcb, _ulSize);
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::SetSize, public
//
//  Synopsis:	sets memory buffer size
//
//  Effects:	may change buffer size
//
//  Arguments:	[ulicb] - new memory size
//
//  Returns:	SCODE
//
//  Derivation: ILockBytes
//
//  Algorithm:  realloc the buffer
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::SetSize(ULARGE_INTEGER ulicb)
{
    olAssert(ULIGetHigh(ulicb) == 0);

    ULONG cb = ULIGetLow(ulicb);

    if (cb == _ulSize)
        return NOERROR;

    void *pv = realloc(_pv, (size_t) cb);

    if ((cb > 0) && (pv == NULL))
    {
        //  Unable to allocate memory
        //  Leave current memory and size alone

        return ResultFromScode(E_OUTOFMEMORY);
    }

    _pv = pv;
    _ulSize = cb;

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::LockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::LockRegion(ULARGE_INTEGER libOffset,
				   ULARGE_INTEGER cb,
				   DWORD dwLockType)
{
    olAssert(0 && "Can't lock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::UnLockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::UnlockRegion(ULARGE_INTEGER libOffset,
				     ULARGE_INTEGER cb,
				     DWORD dwLockType)
{
    olAssert(0 && "Can't unlock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Stat, public
//
//  Synopsis:	Provide instance information
//
//  Arguments:	[pstatstg]    - status buffer
//		[grfStatFlag] - status flags
//
//  Returns:	SCODE
//
//  Modifies:	pstatstg
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:	No time stamps
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        static char const abName[] = "Memory";

        HRESULT hr;

        if (FAILED(DfGetScode(hr = drtMemAlloc(sizeof(abName),
                                             (void **) &pstatstg->pwcsName))))
            return hr;

        memcpy(pstatstg->pwcsName, abName, sizeof(abName));
    }

    pstatstg->type = STGTY_LOCKBYTES;

    ULISetHigh(pstatstg->cbSize, 0);
    ULISetLow(pstatstg->cbSize, _ulSize);

    pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgdrt\illeg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	illeg.cxx
//
//  Contents:	Illegitimate tests
//
//  History:	17-Nov-92	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "illeg.hxx"

void i_storage(void)
{
    WStorage *pwstg;
    IStorage *pstg, *pstg2;
    IStream *pstm;

    IllResult("StgCreateDocfile with NULL ppstg",
             StgCreateDocfile(NULL, 0, 0, NULL));
    IllResult("StgCreateDocfile with non-zero reserved",
             StgCreateDocfile(NULL, 0, 1, &pstg));
    IllResult("StgCreateDocfile with illegal permissions",
             StgCreateDocfile(NULL, 0, 0, &pstg));

    int fd;
    fd = _creat(OlecsOut(DRTDF), _S_IREAD);
    if (fd<0)
        error(EXIT_BADSC, "Unable to create file '%s'\n", OlecsOut(DRTDF));
    _close(fd);
    IllResult("StgCreateDocfile with STGM_WRITE over read-only file",
             StgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pstg));
    _chmod(OlecsOut(DRTDF), _S_IREAD | _S_IWRITE);

    IllResult("StgOpenStorage with NULL ppstg",
             StgOpenStorage(NULL, NULL, 0, NULL, 0, NULL));
    IllResult("StgOpenStorage with NULL name",
             StgOpenStorage(NULL, NULL, 0, NULL, 0, &pstg));
    IllResult("StgOpenStorage with illegal permissions",
             StgOpenStorage(DRTDF, NULL, 0xffffffff, NULL, 0, &pstg));
    IllResult("StgOpenStorage with non-zero reserved",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            1, &pstg));
#if WIN32 != 300
    // This will work on Cairo because it will open a file storage
    IllResult("StgOpenStorage on non-docfile",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            0, &pstg));
#endif
    
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE) | STGM_CREATE, 0, &pwstg);
    pstg = pwstg->GetI();
    IllResult("OpenStream that doesn't exist",
             pstg->OpenStream(STR("NoName"), 0, STMP(STGM_READWRITE),
                              0, &pstm));
    IllResult("OpenStorage that doesn't exist",
             pstg->OpenStorage(STR("NoName"), NULL, STGP(STGM_READWRITE),
                               NULL, 0, &pstg2));
    pwstg->Unwrap();
}

#define STREAMSIZE 128

void i_stream(void)
{
    WStorage *pwstg;
    WStream *pwstm;
    IStream *pstm;
    BYTE bBuffer[STREAMSIZE];
    ULONG cbRead;
    LARGE_INTEGER liSeek;
    ULARGE_INTEGER uliPos;
    ULARGE_INTEGER uliSize;
    ULARGE_INTEGER cb;

    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pwstg->CreateStream(STR("Stream"), STMP(STGM_READ), 0, 0, &pwstm);
    pstm = pwstm->GetI();
    
    IllResult("Read with NULL buffer",
             pstm->Read(NULL, STREAMSIZE, NULL));
    fExitOnFail = FALSE;
    pwstm->Read(bBuffer, STREAMSIZE, &cbRead);
    fExitOnFail = TRUE;
    if (cbRead != 0)
        error(EXIT_BADSC, "Read %lu bytes on zero-length stream\n", cbRead);

    IllResult("Write with NULL buffer",
             pstm->Write(NULL, STREAMSIZE, NULL));
    IllResult("Write on read-only stream",
             pstm->Write(bBuffer, STREAMSIZE, NULL));

    LISet32(liSeek, 0);
    IllResult("Seek with invalid origin",
             pstm->Seek(liSeek, (DWORD)(~STREAM_SEEK_SET), NULL));
#pragma warning(disable:4245)
    // LISet32 in objbase.h has a bug that issues warning for negative values
    LISet32(liSeek, -1);
#pragma warning(default:4245)
    IllResult("Seek before beginning",
             pstm->Seek(liSeek, STREAM_SEEK_CUR, NULL));

    ULISet32(uliSize, STREAMSIZE);
    IllResult("SetSize on read-only stream",
             pstm->SetSize(uliSize));

    ULISet32(uliPos, 0);
    ULISet32(cb, STREAMSIZE);
    IllResult("LockRegion attempt",
             pstm->LockRegion(uliPos, cb, LOCK_ONLYONCE));
    IllResult("UnlockRegion attempt",
             pstm->UnlockRegion(uliPos, cb, LOCK_ONLYONCE));
    
    pwstm->Unwrap();
    pwstg->Unwrap();
}

void i_enum(void)
{
    WStorage *pwstg;
    IStorage *pstg;
    IEnumSTATSTG *penm;
    
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pstg = pwstg->GetI();
    
    IllResult("EnumElements with NULL ppenm",
             pstg->EnumElements(0, NULL, 0, NULL));
    IllResult("EnumElements with non-zero reserved1",
             pstg->EnumElements(1, NULL, 0, &penm));
    IllResult("EnumElements with non-zero reserved2",
             pstg->EnumElements(0, (void *)1, 0, &penm));
    IllResult("EnumElements with non-zero reserved3",
             pstg->EnumElements(0, NULL, 1, &penm));
    
    pwstg->Unwrap();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgdrt\strlist.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	strlist.cxx
//
//  Contents:	CStrList implementation
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <string.h>

//+--------------------------------------------------------------
//
//  Member:	CStrList::CStrList, public
//
//  Synopsis:	Ctor
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

CStrList::CStrList(void)
{
    _pseHead = NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::~CStrList, public
//
//  Synopsis:	Dtor
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

CStrList::~CStrList(void)
{
    Empty();
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Add, public
//
//  Synopsis:	Adds a string to the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Pointer to entry or NULL
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

SStrEntry *CStrList::Add(OLECHAR *ptcs)
{
    SStrEntry *pse;

    // One char of string already counted in sizeof
    pse = (SStrEntry *)new
        char[sizeof(SStrEntry)+olecslen(ptcs)*sizeof(OLECHAR)];
    if (pse == NULL)
	return NULL;
    pse->pseNext = _pseHead;
    pse->psePrev = NULL;
    if (_pseHead)
	_pseHead->psePrev = pse;
    _pseHead = pse;
    olecscpy(pse->atc, ptcs);
    return pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Remove, public
//
//  Synopsis:	Removes an entry from the list
//
//  Arguments:	[pse] - Entry
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

void CStrList::Remove(SStrEntry *pse)
{
    if (pse->psePrev)
	pse->psePrev->pseNext = pse->pseNext;
    else
	_pseHead = pse->pseNext;
    if (pse->pseNext)
	pse->pseNext->psePrev = pse->psePrev;
    delete pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Find, public
//
//  Synopsis:	Attempts to find a string in the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Entry or NULL
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

SStrEntry *CStrList::Find(OLECHAR *ptcs)
{
    SStrEntry *pse;

    for (pse = _pseHead; pse; pse = pse->pseNext)
	if (!olecscmp(ptcs, pse->atc))
	    return pse;
    return NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Empty, public
//
//  Synopsis:	Frees all elements in list
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

void CStrList::Empty(void)
{
    SStrEntry *pse;

    while (_pseHead)
    {
	pse = _pseHead->pseNext;
	delete _pseHead;
	_pseHead = pse;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgdrt\tests.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	tests.cxx
//
//  Contents:	DRT tests
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "tests.hxx"
#include "ilb.hxx"

void t_create(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStorage(STR("Child2"), STGP(WSTG_READWRITE), 0, 0,
			     &pstgChild2);
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild2->Commit(0);
    pstgChild2->Unwrap();
    pstgChild->Commit(0);
    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Unwrap();
}

void t_open(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		     0, &pstgRoot);
    CreateStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Commit(0);
    pstgRoot->Unwrap();

    WStgOpenStorage(DRTDF, NULL, ROOTP(WSTG_READWRITE), NULL,
		    0, &pstgRoot);
    pstgRoot->OpenStorage(STR("Child"), NULL, STGP(WSTG_READWRITE), NULL, 0,
			  &pstgChild);
    pstgChild->OpenStorage(STR("Child2"), NULL, STGP(WSTG_READWRITE), NULL, 0,
			   &pstgChild2);
    pstgChild2->OpenStream(STR("Stream"), NULL, STMP(WSTG_READWRITE), 0,
			   &pstm);
    pstm->Unwrap();
    pstgChild2->Unwrap();
    pstgChild->Unwrap();
    pstgRoot->Unwrap();
}

void t_addref(void)
{
    WStorage *pstg;
    WStream *pstm;
    ULONG ul;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstg);
    pstg->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
#ifndef FLAT
    if ((ul = pstm->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#else
    if ((ul = pstm->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#endif
    pstg->Unwrap();
}

void t_tmodify(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    // This test must use transacted mode to reproduce the
    // expected behavior
    ForceTransacted();

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0,
                            0, &pstgChild);
    pstgChild->CreateStorage(STR("Child2"), STGP(WSTG_READWRITE), 0,
			     0, &pstgChild2);
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Unwrap();
    pstgChild2->Commit(0);
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test renaming a closed stream
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");

    // Test rename reversion
    pstgChild2->Revert();
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test destruction of closed object
    pstgChild2->DestroyElement(STR("Stream"));
    pstgChild2->Commit(0);

    // Test create of previously deleted object
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstgChild2->Commit(0);
    VerifyStructure(pstgChild2->GetI(), "sStream");

#if 0
    // 08/11/93 - Renaming open children no longer allowed
    // Test renaming an open stream
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");
#endif

    pstgChild2->Revert();
    VerifyStructure(pstgChild2->GetI(), "sStream");
    pstgChild2->DestroyElement(STR("Stream"));
    pstgChild2->Commit(0);
    pstm->Unwrap();

    pstgChild2->Unwrap();
    VerifyStructure(pstgChild->GetI(), "dChild2()");

    // Test rename of storage
    pstgChild->RenameElement(STR("Child2"), STR("RenamedChild"));
    pstgChild->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild->DestroyElement(STR("Stream"));
    pstgChild->Commit(0);

    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;

    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x01bcdef0;

    // Set when element not open
    pstgChild->SetElementTimes(STR("RenamedChild"), &tm, NULL, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, &tm, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, NULL, &tm);

    pstgChild->OpenStorage(STR("RenamedChild"), NULL, STGP(WSTG_READWRITE),
                           NULL, 0, &pstgChild2);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");

    // Test SetClass and SetStateBits
    pstgChild2->SetClass(IID_IStorage);
    fExitOnFail = FALSE;
    pstgChild2->SetStateBits(0xff00ff00, 0xffffffff);
    pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee);
    fExitOnFail = TRUE;
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set to %s\n", GuidText(&stat.clsid));
    if (stat.grfStateBits != 0x11881188)
        errorprint("State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Revert();
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, CLSID_NULL))
        error(EXIT_BADSC, "Class ID reverted to %s\n", GuidText(&stat.clsid));
    if (stat.grfStateBits != 0)
        errorprint("State bits reverted improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0);
    pstgChild2->Unwrap();

    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Revert();
    VerifyStructure(pstgRoot->GetI(), "");
    pstgRoot->Commit(0);
    VerifyStructure(pstgRoot->GetI(), "");
    pstgRoot->Unwrap();
    Unforce();
}

void t_dmodify(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;
    ULONG cbSize1, cbSize2;

    // This test must use direct mode to reproduce the
    // expected behavior
    ForceDirect();

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0,
                            0, &pstgChild);
    pstgChild->CreateStorage(STR("Child2"), STGP(WSTG_READWRITE), 0,
			     0, &pstgChild2);
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Unwrap();
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test renaming a closed stream
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");

    // Test destroying a stream
    pstgChild2->DestroyElement(STR("RenamedStream"));

#if 0
    // 08/11/93 - Renaming open child no longer allowed
    // Test renaming an open stream
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    VerifyStructure(pstgChild2->GetI(), "sStream");
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");
    pstgChild2->DestroyElement(STR("RenamedStream"));
    pstm->Unwrap();
#endif

    pstgChild2->Unwrap();
    VerifyStructure(pstgChild->GetI(), "dChild2()");

    // Test renaming a storage
    pstgChild->RenameElement(STR("Child2"), STR("RenamedChild"));
    pstgChild->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild->DestroyElement(STR("Stream"));

    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;

    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x01bcdef0;

    // Set when element not open
    pstgChild->SetElementTimes(STR("RenamedChild"), &tm, NULL, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, &tm, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, NULL, &tm);

    pstgChild->OpenStorage(STR("RenamedChild"), NULL, STMP(WSTG_READWRITE),
                           NULL, 0, &pstgChild2);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");

    // Test SetClass and SetStateBits
    pstgChild2->SetClass(IID_IStorage);
    fExitOnFail = FALSE;
    pstgChild2->SetStateBits(0xff00ff00, 0xffffffff);
    pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee);
    fExitOnFail = TRUE;
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set improperly\n");
    if (stat.grfStateBits != 0x11881188)
        errorprint("State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Unwrap();

    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Revert();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Commit(0);
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->DestroyElement(STR("Child"));
    VerifyStructure(pstgRoot->GetI(), "");

    // Verify that space is reclaimed after modifications
    pstgRoot->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize1 = Length(DRTDF);
    pstgRoot->DestroyElement(STR("Stream"));
    pstgRoot->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize2 = Length(DRTDF);
    if (cbSize1 != cbSize2)
        error(EXIT_BADSC, "Space is not being reclaimed, original %lu, "
              "now %lu\n", cbSize1, cbSize2);

    pstgRoot->Unwrap();

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgRoot);

    //  removal cases
    //    1) no right child

    CreateStructure(pstgRoot->GetI(), "d64,d32");
    VerifyStructure(pstgRoot->GetI(), "d64,d32");
    pstgRoot->DestroyElement(STR("64"));
    VerifyStructure(pstgRoot->GetI(), "d32");

    //    2) right child has no left child

    CreateStructure(pstgRoot->GetI(), "d64");
    VerifyStructure(pstgRoot->GetI(), "d32,d64");
    pstgRoot->DestroyElement(STR("32"));
    VerifyStructure(pstgRoot->GetI(), "d64");

    //    3) right child has left child

    CreateStructure(pstgRoot->GetI(), "d96,d80");
    VerifyStructure(pstgRoot->GetI(), "d64,d80,d96");
    pstgRoot->DestroyElement(STR("64"));
    VerifyStructure(pstgRoot->GetI(), "d80,d96");

    //    4) right child's left child has children

    CreateStructure(pstgRoot->GetI(), "d88,d84,d92");
    VerifyStructure(pstgRoot->GetI(), "d80,d84,d88,d92,d96");
    pstgRoot->DestroyElement(STR("80"));
    VerifyStructure(pstgRoot->GetI(), "d84,d88,d92,d96");

    pstgRoot->Unwrap();

    Unforce();
}

void t_stat(void)
{
    WStorage *pstgRoot, *pstgChild;
    WStream *pstm;
    STATSTG stat;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);

    pstm->Stat(&stat, 0);
    VerifyStat(&stat, STR("Stream"), STGTY_STREAM, STMP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstm->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STREAM, STMP(WSTG_READWRITE));

    pstm->Unwrap();

    pstgChild->Stat(&stat, 0);
    VerifyStat(&stat, STR("Child"), STGTY_STORAGE, STGP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgChild->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, STGP(WSTG_READWRITE));

    pstgChild->Unwrap();

    pstgRoot->Stat(&stat, 0);
    OLECHAR atcFullPath[_MAX_PATH];
    GetFullPath(DRTDF, atcFullPath);
    VerifyStat(&stat, atcFullPath, STGTY_STORAGE, ROOTP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgRoot->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, ROOTP(WSTG_READWRITE));

    pstgRoot->Unwrap();
}

static char NUMBERS[] = "12345678901234567890123456789012345678901234567890";

void t_stream(void)
{
    WStorage *pstg;
    WStream *pstm, *pstmC;
    char buf[sizeof(NUMBERS)*2];
    ULONG cb, ulPos;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    pstg->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Write(NUMBERS, sizeof(NUMBERS), &cb);
    pstm->Commit(0);
    pstm->Seek(0, WSTM_SEEK_SET, &ulPos);
    if (ulPos != 0)
	error(EXIT_BADSC, "Incorrect seek, ptr is %lu\n", ulPos);
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    if (strcmp(buf, NUMBERS))
	error(EXIT_BADSC, "Incorrect stream contents\n");
    pstm->SetSize(sizeof(NUMBERS)/2);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    fExitOnFail = FALSE;
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    fExitOnFail = TRUE;
    if (cb != sizeof(NUMBERS)/2)
	error(EXIT_BADSC, "SetSize failed to size stream properly\n");
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "SetSize corrupted contents\n");
    pstm->Clone(&pstmC);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)/2, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)&~1, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->Read(buf, (sizeof(NUMBERS)&~1)*2, &cb);
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+sizeof(NUMBERS)/2, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+(sizeof(NUMBERS)&~1), NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+3*(sizeof(NUMBERS)/2), NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "Stream contents incorrect\n");
    pstmC->Unwrap();
    pstm->Unwrap();
    pstg->Unwrap();
}

// Number of entries for enumeration test
#define ENUMENTRIES 10

// Flag indicating a name has already shown up in enumeration,
// must not conflict with STGTY_*
#define ENTRY_SEEN 0x100

// Check the validity of an enumeration element
static void elt_check(STATSTG *pstat, CStrList *psl)
{
    SStrEntry *pse;

    pse = psl->Find(pstat->pwcsName);
    if (pse == NULL)
        error(EXIT_BADSC, "Spurious element '%s'\n", pstat->pwcsName);
    else if ((pse->user.dw & ~ENTRY_SEEN) != pstat->type)
        error(EXIT_BADSC, "Element '%s' has wrong type - "
              "has %lX vs. %lX\n", pstat->pwcsName, pstat->type,
              pse->user.dw & ~ENTRY_SEEN);
    else if (pse->user.dw & ENTRY_SEEN)
        error(EXIT_BADSC, "Element '%s' has already been seen\n",
              pstat->pwcsName);
    pse->user.dw |= ENTRY_SEEN;
}

// Do final validity checks for enumeration
static void enum_list_check(CStrList *psl)
{
    SStrEntry *pse;

    for (pse = psl->GetHead(); pse; pse = pse->pseNext)
    {
        if ((pse->user.dw & ENTRY_SEEN) == 0)
            error(EXIT_BADSC, "Element '%s' not found\n", pse->atc);
        pse->user.dw &= ~ENTRY_SEEN;
    }
}

void t_enum(void)
{
    int i;
    OLECHAR atcName[CWCSTORAGENAME];
    WStorage *pstg, *pstg2;
    WStream *pstm;
    SStrEntry *pse;
    CStrList sl;

    // Create some entries to enumerate
    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    for (i = 0; i<ENUMENTRIES; i++)
    {
	olecsprintf(atcName, STR("Name%d"), rand());
	pse = sl.Add(atcName);
	if (rand()%100 < 50)
	{
	    pse->user.dw = STGTY_STORAGE;
	    pstg->CreateStorage(atcName, STGP(WSTG_READWRITE), 0, 0, &pstg2);
	    pstg2->Unwrap();
	}
	else
	{
	    pse->user.dw = STGTY_STREAM;
	    pstg->CreateStream(atcName, STMP(WSTG_READWRITE), 0, 0, &pstm);
	    pstm->Unwrap();
	}
    }

    WEnumSTATSTG *penm;
    STATSTG stat[2*ENUMENTRIES];
    SCODE sc;

    // Test plain, single element enumeration
    pstg->EnumElements(0, NULL, 0, &penm);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, stat, NULL));
	if (sc == S_FALSE)
	    break;
        elt_check(stat, &sl);
        drtMemFree(stat->pwcsName);

    }
    enum_list_check(&sl);

    ULONG cFound;

    // Test rewind and multiple element enumeration with too many elements
    penm->Reset();
    sc = DfGetScode(penm->Next(ENUMENTRIES*2, stat, &cFound));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    enum_list_check(&sl);

    // Test skip and multiple enumeration with exact number of elements
    penm->Reset();
    penm->Skip(ENUMENTRIES/2);
    sc = DfGetScode(penm->Next(ENUMENTRIES-ENUMENTRIES/2, stat, &cFound));
    if (sc != S_OK)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_OK\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES-ENUMENTRIES/2)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES-ENUMENTRIES/2);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    sc = DfGetScode(penm->Next(1, stat, NULL));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);

    penm->Unwrap();
    pstg->Unwrap();
}

#define SCT_CLASSID IID_ILockBytes
#define SCT_STATEBITS 0xfef1f0f0

void t_stgcopyto(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    // Set some interesting values to make sure they're copied
    pstgFrom->SetClass(SCT_CLASSID);
    fExitOnFail = FALSE;
    pstgFrom->SetStateBits(SCT_STATEBITS, 0xffffffff);
    fExitOnFail = TRUE;

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");
    CreateStructure(pstgTo->GetI(), "dA(dY(sZ),sBs)");

    pstgFrom->CopyTo(0, NULL, NULL, pstgTo);

    VerifyStructure(pstgTo->GetI(),
		    "dA(dB(dC(sA,sB,sC),sCs),dY(sZ),sBs),sAs");
    pstgTo->Stat(&statTo, 0);
    if (!IsEqualCLSID(statTo.clsid, SCT_CLASSID))
        error(EXIT_BADSC, "Class ID mismatch after copy\n");
    if (statTo.grfStateBits != SCT_STATEBITS)
        errorprint("State bits mismatch: has %lX vs. %lX\n",
              statTo.grfStateBits, SCT_STATEBITS);

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}

#define MARSHAL_STM STR("Marshal")

void do_marshal(WStorage *pstg, WStream *pstm)
{
    WStorage *pstgMarshal;
    WStream *pstmMarshal;

    WStgCreateDocfile(MARSHALDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgMarshal);
    pstgMarshal->CreateStream(MARSHAL_STM, STMP(WSTG_READWRITE), 0, 0,
			      &pstmMarshal);
    WCoMarshalInterface(pstmMarshal, IID_IStorage, pstg->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    WCoMarshalInterface(pstmMarshal, IID_IStream, pstm->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    WCoMarshalInterface(pstmMarshal, IID_IUnknown, pstg->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    WCoMarshalInterface(pstmMarshal, IID_IUnknown, pstm->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    pstmMarshal->Unwrap();
    pstgMarshal->Commit(0);
    pstgMarshal->Unwrap();
}

static char STREAM_DATA[] = "This is data to be written";

void do_unmarshal(WStorage **ppstg, WStream **ppstm,
                  IUnknown **ppstg2, IUnknown **ppstm2)
{
    IStorage *pistg;
    WStorage *pstgMarshal;
    WStream *pstmMarshal;
    IStream *pistm;

    WStgOpenStorage(MARSHALDF, NULL, ROOTP(WSTG_READWRITE), NULL, 0,
		    &pstgMarshal);
    pstgMarshal->OpenStream(MARSHAL_STM, NULL, STMP(WSTG_READWRITE), 0,
			    &pstmMarshal);
    WCoUnmarshalInterface(pstmMarshal, IID_IStorage, (void **)&pistg);
    *ppstg = WStorage::Wrap(pistg);
    WCoUnmarshalInterface(pstmMarshal, IID_IStream, (void **)&pistm);
    *ppstm = WStream::Wrap(pistm);
    WCoUnmarshalInterface(pstmMarshal, IID_IUnknown, (void **)ppstg2);
    WCoUnmarshalInterface(pstmMarshal, IID_IUnknown, (void **)ppstm2);
    pstmMarshal->Unwrap();
    pstgMarshal->Unwrap();
}

void t_marshal(void)
{
    WStorage *pstg, *pstgM;
    WStream *pstm, *pstmM;
    IUnknown *pstgM2, *pstmM2;
    ULONG cbRead, cbWritten;
    char buf[sizeof(STREAM_DATA)];

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstg);
    pstg->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Write(STREAM_DATA, sizeof(STREAM_DATA), &cbWritten);
    CreateStructure(pstg->GetI(), "dChild(dChild(sStream))");

    do_marshal(pstg, pstm);
    do_unmarshal(&pstgM, &pstmM, &pstgM2, &pstmM2);
    pstm->Unwrap();
    pstg->Unwrap();

    pstmM->Seek(0, WSTM_SEEK_SET, NULL);
    pstmM->Read(buf, sizeof(STREAM_DATA), &cbRead);
    if (strcmp(buf, STREAM_DATA))
	error(EXIT_BADSC, "Stream data mismatch\n");
    pstmM->Unwrap();
    pstmM2->Release();

    VerifyStructure(pstgM->GetI(), "dChild(dChild(sStream)),sStream");
    pstgM->Unwrap();
    pstgM2->Release();
}

void t_stgmisc(void)
{
    WStorage *pstg;
    SCODE sc;
    STATSTG stat;

    // Can't make this call in transacted mode because we want
    // the storage signature to make it into the file right away
    WStgCreateDocfile(DRTDF, WSTG_READWRITE | WSTG_CREATE |
	WSTG_SHARE_EXCLUSIVE, 0, &pstg);
    if (!fOfs)
    {
    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open file - Should be a storage object\n");
    pstg->Unwrap();
    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Closed file - Should be a storage object\n");
    }
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
	    WSTG_DELETEONRELEASE, 0, &pstg);
    pstg->Stat(&stat, 0);
    if (!Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not created\n", stat.pwcsName);
    pstg->Unwrap();
    if (Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted on release\n",
	    stat.pwcsName);
    drtMemFree(stat.pwcsName);
}

void t_ilb(void)
{
    WStorage *pstg;
    SCODE sc;
    //  create an ILockBytes

    ILockBytes *pilb = new CMapBytes();
    if (pilb == NULL)
	error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");

    //  create a storage on the ILockBytes

    WStgCreateDocfileOnILockBytes(pilb,
				  WSTG_READWRITE |
                                  WSTG_CREATE    |
                                  WSTG_SHARE_EXCLUSIVE,
                                  0, &pstg);

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open ILockBytes - Should be a storage object\n");

    //  release the storage

    pstg->Unwrap();

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));

    if (sc == S_FALSE)
	error(EXIT_BADSC, "Released ILockBytes - Should be a storage object\n");

    //  open the ILockBytes

    WStgOpenStorageOnILockBytes(pilb, NULL, ROOTP(WSTG_READWRITE),
				NULL, 0, &pstg);


    //  release the storage

    pstg->Unwrap();

    //  release the ILockBytes

    pilb->Release();
}

void t_movecopy(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    //  create a source
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    //  create a destination
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    pstgTo->Stat(&statTo, 0);

    //  populate source
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");

    //  move a storage
    pstgFrom->MoveElementTo(STR("A"), pstgTo, STR("M"), STGMOVE_MOVE);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs)");

    //  copy a stream
    pstgFrom->MoveElementTo(STR("As"), pstgTo, STR("Bs"), STGMOVE_COPY);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs),sBs");

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgdrt\wrap.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	wrap.cxx
//
//  Contents:	Wrapper implementations
//
//  History:	22-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <dfentry.hxx>

// Retrieve interface pointer for possibly NULL objects
#define SAFEI(obj) ((obj) ? (obj)->GetI() : NULL)

//+--------------------------------------------------------------
//
//  IStorage wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WStorage *WStorage::Wrap(IStorage *pistg)
{
    WStorage *wstg;

    wstg = new WStorage(pistg);
    if (wstg == NULL)
	error(EXIT_OOM, "Unable to wrap IStorage\n");
    return wstg;
}

WStorage::WStorage(IStorage *pstg)
{
    // Note:  takes ownership of pstg
    _pstg = pstg;
}

WStorage::~WStorage(void)
{
    if (_pstg)
	Release();
}

void WStorage::Unwrap(void)
{
    delete this;
}

HRESULT WStorage::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStorage %p::QueryInterface(riid, %p)", _pstg, ppvObj);
    return Result(_pstg->QueryInterface(riid, ppvObj));
}

ULONG WStorage::AddRef(void)
{
    ULONG ul;

    ul = _pstg->AddRef();
    out("IStorage %p::AddRef() - %lu\n", _pstg, ul);
    return ul;
}

ULONG WStorage::Release(void)
{
    ULONG ul;

    ul = _pstg->Release();
    out("IStorage %p::Release() - %lu\n", _pstg, ul);
    if (ul == 0)
	_pstg = NULL;
    return ul;
}

HRESULT WStorage::CreateStream(const OLECHAR * pwcsName,
			     const DWORD grfMode,
			     DWORD reserved1,
			     DWORD reserved2,
			     WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::CreateStream(%s, 0x%lX, %lu, %lu, %p)", _pstg,
	OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstm);
    hr = Result(_pstg->CreateStream(pwcsName, grfMode, reserved1,
                                    reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::OpenStream(const OLECHAR * pwcsName,
			   void *reserved1,
			   const DWORD grfMode,
			   DWORD reserved2,
			   WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::OpenStream(%s, %p, 0x%lX, %lu, %p)", _pstg,
	OlecsOut(pwcsName), reserved1, grfMode, reserved2, ppstm);
    hr = Result(_pstg->OpenStream(pwcsName, reserved1, grfMode,
				 reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::CreateStorage(const OLECHAR * pwcsName,
			      const DWORD grfMode,
			      DWORD reserved1,
                              DWORD reserved2,
			      WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::CreateStorage(%s, 0x%lX, %lu, %lu, %p)", _pstg,
        OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstg);
    hr = Result(_pstg->CreateStorage(pwcsName, grfMode, reserved1,
                                     reserved2, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::OpenStorage(const OLECHAR * pwcsName,
			    WStorage *pstgPriority,
			    const DWORD grfMode,
			    SNB snbExclude,
			    DWORD reserved,
			    WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::OpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", _pstg,
	OlecsOut(pwcsName), SAFEI(pstgPriority), grfMode,
	snbExclude, reserved, ppstg);
    hr = Result(_pstg->OpenStorage(pwcsName, SAFEI(pstgPriority),
                                   grfMode, snbExclude,
                                   reserved, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::CopyTo(DWORD ciidExclude,
		       IID *rgiidExclude,
		       SNB snbExclude,
		       WStorage *pstgDest)
{
    out("IStorage %p::CopyTo(%lu, %p, %p, %p)", _pstg, ciidExclude,
	rgiidExclude, snbExclude, pstgDest->GetI());
    return Result(_pstg->CopyTo(ciidExclude, rgiidExclude, snbExclude,
                                pstgDest->GetI()));
}

HRESULT WStorage::MoveElementTo(OLECHAR const FAR* lpszName,
    			WStorage FAR *pstgDest,
                        OLECHAR const FAR* lpszNewName,
                        DWORD grfFlags)
{
    out("IStorage %p::MoveElementTo(%p, %p, %p, %lu)", _pstg, lpszName,
	pstgDest->GetI(), lpszNewName, grfFlags);
    return Result(_pstg->MoveElementTo(lpszName, pstgDest->GetI(),
                                       lpszNewName, grfFlags));
}

HRESULT WStorage::Commit(const DWORD grfCommitFlags)
{
    out("IStorage %p::Commit(0x%lX)", _pstg, grfCommitFlags);
    return Result(_pstg->Commit(grfCommitFlags));
}

HRESULT WStorage::Revert(void)
{
    out("IStorage %p::Revert()", _pstg);
    return Result(_pstg->Revert());
}

HRESULT WStorage::EnumElements(DWORD reserved1,
			     void *reserved2,
			     DWORD reserved3,
			     WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IStorage %p::EnumElements(%lu, %p, %lu, %p)", _pstg,
	reserved1, reserved2, reserved3, ppenm);
    hr = Result(_pstg->EnumElements(reserved1, reserved2, reserved3, &pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

HRESULT WStorage::DestroyElement(const OLECHAR * pwcsName)
{
    out("IStorage %p::DestroyElement(%s)", _pstg, OlecsOut(pwcsName));
    return Result(_pstg->DestroyElement(pwcsName));
}

HRESULT WStorage::RenameElement(const OLECHAR * pwcsOldName,
			      const OLECHAR * pwcsNewName)
{
    out("IStorage %p::RenameElement(%s, %s)", _pstg, OlecsOut(pwcsOldName),
	OlecsOut(pwcsNewName));
    return Result(_pstg->RenameElement(pwcsOldName, pwcsNewName));
}

HRESULT WStorage::SetElementTimes(const OLECHAR *lpszName,
                                FILETIME const *pctime,
                                FILETIME const *patime,
                                FILETIME const *pmtime)
{
    out("IStorage %p::SetElementTimes(%s, %p, %p, %p)", _pstg,
        OlecsOut(lpszName), pctime, patime, pmtime);
    return Result(_pstg->SetElementTimes(lpszName, pctime, patime, pmtime));
}

HRESULT WStorage::SetClass(REFCLSID clsid)
{
    out("IStorage %p::SetClass(%s)", _pstg, GuidText(&clsid));
    return Result(_pstg->SetClass(clsid));
}

HRESULT WStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    out("IStorage %p::SetStateBits(0x%lX, 0x%lX)", _pstg, grfStateBits,
        grfMask);
    return Result(_pstg->SetStateBits(grfStateBits, grfMask));
}

HRESULT WStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStorage %p::Stat(%p, %lu)", _pstg, pstatstg, grfStatFlag);
    return Result(_pstg->Stat(pstatstg, grfStatFlag));
}

//+--------------------------------------------------------------
//
//  IStream wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WStream *WStream::Wrap(IStream *pistm)
{
    WStream *wstm;

    wstm = new WStream(pistm);
    if (wstm == NULL)
	error(EXIT_OOM, "Unable to wrap IStream\n");
    return wstm;
}

WStream::WStream(IStream *pstm)
{
    // Note:  takes ownership of pstm
    _pstm = pstm;
}

WStream::~WStream(void)
{
    if (_pstm)
	Release();
}

void WStream::Unwrap(void)
{
    delete this;
}

HRESULT WStream::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStream %p::QueryInterface(riid, %p)", _pstm, ppvObj);
    return Result(_pstm->QueryInterface(riid, ppvObj));
}

ULONG WStream::AddRef(void)
{
    ULONG ul;

    ul = _pstm->AddRef();
    out("IStream %p::AddRef() - %lu\n", _pstm, ul);
    return ul;
}

ULONG WStream::Release(void)
{
    ULONG ul;

    ul = _pstm->Release();
    out("IStream %p::Release() - %lu\n", _pstm, ul);
    if (ul == 0)
	_pstm = NULL;
    return ul;
}

HRESULT WStream::Read(VOID *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;

    out("IStream %p::Read(%p, %lu, %p)", _pstm, pv, cb, pcbRead);
    hr = _pstm->Read(pv, cb, pcbRead);
    if (pcbRead)
	out(" - %lu bytes", *pcbRead);
    Result(hr);
    if (pcbRead && *pcbRead != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't read data\n");
    return hr;
}

HRESULT WStream::Write(VOID *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr;

    out("IStream %p::Write(%p, %lu, %p)", _pstm, pv, cb, pcbWritten);
    hr = _pstm->Write(pv, cb, pcbWritten);
    if (pcbWritten)
	out(" - %lu bytes", *pcbWritten);
    Result(hr);
    if (pcbWritten && *pcbWritten != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't write data\n");
    return hr;
}

HRESULT WStream::Seek(LONG dlibMove,
		    DWORD dwOrigin,
		    ULONG *plibNewPosition)
{
    HRESULT hr;
    LARGE_INTEGER dlib;
    ULARGE_INTEGER plib;

    out("IStream %p::Seek(%ld, %lu, %p)", _pstm, dlibMove, dwOrigin,
	plibNewPosition);
    LISet32(dlib, dlibMove);
    hr = _pstm->Seek(dlib, dwOrigin, &plib);
    if (plibNewPosition)
    {
        *plibNewPosition = ULIGetLow(plib);
	out(" - ptr %lu", *plibNewPosition);
    }
    return Result(hr);
}

HRESULT WStream::SetSize(ULONG libNewSize)
{
    ULARGE_INTEGER lib;
    
    out("IStream %p::SetSize(%lu)", _pstm, libNewSize);
    ULISet32(lib, libNewSize);
    return Result(_pstm->SetSize(lib));
}

HRESULT WStream::Commit(const DWORD dwFlags)
{
    out("IStream %p:Commit(%lu)", _pstm, dwFlags);
    return Result(_pstm->Commit(dwFlags));
}

HRESULT WStream::CopyTo(WStream *pstm,
		      ULONG cb,
		      ULONG *pcbRead,
		      ULONG *pcbWritten)
{
    ULARGE_INTEGER lcb, pcbr, pcbw;
    HRESULT hr;
    
    out("IStream %p::CopyTo(%p, %lu, %p, %p)", _pstm, pstm->GetI(), cb,
	pcbRead, pcbWritten);
    ULISet32(lcb, cb);
    hr = Result(_pstm->CopyTo(pstm->GetI(), lcb, &pcbr, &pcbw));
    if (pcbRead)
        *pcbRead = ULIGetLow(pcbr);
    if (pcbWritten)
        *pcbWritten = ULIGetLow(pcbw);
    return hr;
}

HRESULT WStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStream %p::Stat(%p, %lu)", _pstm, pstatstg, grfStatFlag);
    return Result(_pstm->Stat(pstatstg, grfStatFlag));
}

HRESULT WStream::Clone(WStream * *ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStream %p::Clone(%p)", _pstm, ppstm);
    hr = Result(_pstm->Clone(&pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

//+--------------------------------------------------------------
//
//  IEnumSTATSTG wrappers
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WEnumSTATSTG *WEnumSTATSTG::Wrap(IEnumSTATSTG *pienm)
{
    WEnumSTATSTG *wenm;

    wenm = new WEnumSTATSTG(pienm);
    if (wenm == NULL)
	error(EXIT_OOM, "Unable to wrap IEnumSTATSTG\n");
    return wenm;
}

WEnumSTATSTG::WEnumSTATSTG(IEnumSTATSTG *penm)
{
    // Note:  takes ownership of penm
    _penm = penm;
}

WEnumSTATSTG::~WEnumSTATSTG(void)
{
    if (_penm)
	Release();
}

void WEnumSTATSTG::Unwrap(void)
{
    delete this;
}

HRESULT WEnumSTATSTG::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IEnumSTATSTG %p::QueryInterface(riid, %p)", _penm, ppvObj);
    return Result(_penm->QueryInterface(riid, ppvObj));
}

ULONG WEnumSTATSTG::AddRef(void)
{
    ULONG ul;

    ul = _penm->AddRef();
    out("IEnumSTATSTG %p::AddRef() - %lu\n", _penm, ul);
    return ul;
}

ULONG WEnumSTATSTG::Release(void)
{
    ULONG ul;

    ul = _penm->Release();
    out("IEnumSTATSTG %p::Release() - %lu\n", _penm, ul);
    if (ul == 0)
	_penm = NULL;
    return ul;
}

HRESULT WEnumSTATSTG::Next(ULONG celt, STATSTG rgelt[], ULONG *pceltFetched)
{
    out("IEnumSTATSTG %p::Next(%lu, rgelt, %p)", _penm, celt, pceltFetched);
    return Result(_penm->Next(celt, rgelt, pceltFetched));
}

HRESULT WEnumSTATSTG::Skip(ULONG celt)
{
    out("IEnumSTATSTG %p::Skip(%lu)", _penm, celt);
    return Result(_penm->Skip(celt));
}

HRESULT WEnumSTATSTG::Reset(void)
{
    out("IEnumSTATSTG %p::Reset()", _penm);
    return Result(_penm->Reset());
}

HRESULT WEnumSTATSTG::Clone(WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IEnumSTATSTG %p::Clone(%p)", _penm, ppenm);
    hr = Result(_penm->Clone(&pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

//+--------------------------------------------------------------
//
//  IMarshal wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WMarshal *WMarshal::Wrap(IMarshal *pimsh)
{
    WMarshal *wmsh;

    wmsh = new WMarshal(pimsh);
    if (wmsh == NULL)
	error(EXIT_OOM, "Unable to wrap IMarshal\n");
    return wmsh;
}

WMarshal::WMarshal(IMarshal *pmsh)
{
    // Note:  takes ownership of pmsh
    _pmsh = pmsh;
}

WMarshal::~WMarshal(void)
{
    if (_pmsh)
	Release();
}

void WMarshal::Unwrap(void)
{
    delete this;
}

HRESULT WMarshal::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IMarshal %p::QueryInterface(riid, %p)", _pmsh, ppvObj);
    return Result(_pmsh->QueryInterface(riid, ppvObj));
}

ULONG WMarshal::AddRef(void)
{
    ULONG ul;

    ul = _pmsh->AddRef();
    out("IMarshal %p::AddRef() - %lu\n", _pmsh, ul);
    return ul;
}

ULONG WMarshal::Release(void)
{
    ULONG ul;

    ul = _pmsh->Release();
    out("IMarshal %p::Release() - %lu\n", _pmsh, ul);
    if (ul == 0)
	_pmsh = NULL;
    return ul;
}

HRESULT WMarshal::MarshalInterface(WStream * pStm,
                                   REFIID riid,
                                   LPVOID pv,
                                   DWORD dwDestContext,
				   LPVOID pvDestContext,
                                   DWORD mshlflags)
{
    out("IMarshal %p::MarshalInterface(%p, riid, %p, %lu, %lu, %lu)",
	_pmsh, pStm->GetI(), pv, dwDestContext, pvDestContext, mshlflags);
    return Result(_pmsh->MarshalInterface(pStm->GetI(), riid, pv,
#ifdef OLDMARSHAL
                                          dwDestContext
#ifdef NEWMARSHAL
                                          , mshlflags
#endif                                          
                                          ));
#else
                                          dwDestContext,
					  pvDestContext,
                                          mshlflags));
#endif
}

//+--------------------------------------------------------------
//
//  Root level wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

HRESULT WStgCreateDocfile(const OLECHAR * pwcsName,
			const DWORD grfMode,
			DWORD reserved,
			WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

#ifndef _CAIRO_
    out("StgCreateDocfile(%s, 0x%lX, %lu, %p)", OlecsOut(pwcsName), grfMode,
	reserved, ppstgOpen);

    hr = Result(StgCreateDocfile(pwcsName, grfMode,
                                 reserved, &pistg));
#else ELSE == 300
    out("StgCreateStorage(%s, 0x%lX, %lu, %p)", OlecsOut(pwcsName), grfMode,
	reserved, ppstgOpen);

    hr = Result(StgCreateStorage(pwcsName, grfMode,
                                 STGFMT_DOCUMENT,
                                 (LPSECURITY_ATTRIBUTES)reserved, &pistg));
#endif

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgCreateDocfileOnILockBytes(ILockBytes *plkbyt,
				    const DWORD grfMode,
				    DWORD reserved,
				    WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgCreateDocfileOnILockBytes(%p, 0x%lX, %lu, %p)",
	plkbyt, grfMode, reserved, ppstgOpen);
    hr = Result(StgCreateDocfileOnILockBytes(plkbyt, grfMode,
                                             reserved, &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorage(const OLECHAR * pwcsName,
		      WStorage *pstgPriority,
		      const DWORD grfMode,
		      SNB snbExclude,
		      DWORD reserved,
		      WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", OlecsOut(pwcsName),
	SAFEI(pstgPriority), grfMode, snbExclude, reserved, ppstgOpen);
    hr = Result(StgOpenStorage(pwcsName, SAFEI(pstgPriority), grfMode,
			      snbExclude,
                               reserved, &pistg));

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorageOnILockBytes(ILockBytes *plkbyt,
				  WStorage *pstgPriority,
				  const DWORD grfMode,
				  SNB snbExclude,
				  DWORD reserved,
				  WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorageOnILockBytes(%p, %p, 0x%lX, %p, %lu, %p)",
	plkbyt, SAFEI(pstgPriority), grfMode, snbExclude, reserved,
	ppstgOpen);
    hr = Result(StgOpenStorageOnILockBytes(plkbyt, SAFEI(pstgPriority),
					  grfMode, snbExclude, reserved,
					  &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgIsStorageFile(const OLECHAR * pwcsName)
{
    out("StgIsStorageFile(%s)", OlecsOut(pwcsName));
    return Result(StgIsStorageFile(pwcsName));
}

HRESULT WStgIsStorageILockBytes(ILockBytes * plkbyt)
{
    out("StgIsStorageILockBytes(%p)", plkbyt);
    return Result(StgIsStorageILockBytes(plkbyt));
}

HRESULT WCoMarshalInterface(WStream *pStm,
                            REFIID iid,
                            IUnknown *pUnk,
                            DWORD dwDestContext,
                            LPVOID pvDestContext,
                            DWORD mshlflags)
{
    out("CoMarshalInterface(%p, iid, %p, %lu, %p, %lX)", pStm->GetI(),
        pUnk, dwDestContext, pvDestContext, mshlflags);
#ifdef OLDMARSHAL
    return Result(CoMarshalInterface(pStm->GetI(), iid, pUnk, dwDestContext,
                                     mshlflags));
#else    
    return Result(CoMarshalInterface(pStm->GetI(), iid, pUnk, dwDestContext,
                                     pvDestContext, mshlflags));
#endif
}

HRESULT WCoUnmarshalInterface(WStream *pStm,
                              REFIID riid,
                              LPVOID *ppv)
{
    out("CoUnmarshalInterface(%p, iid, %p)", pStm->GetI(), ppv);
    return Result(CoUnmarshalInterface(pStm->GetI(), riid, ppv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\ole2ui\res\usa\verlocal.h ===
/*
 * VERLOCAL.H
 *
 * Version resource file for the OLE 2.0 UI Support DLL.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved.
 *
 * This file contains the text that needs to be translated in the version
 * resource.  All of the following variables must be localized:
 *
 * wLanguage
 * szTranslation
 * szzCompanyName
 * szzProductName
 * szzLegalCopyright
 */

/* wLanguage comes from the table of "langID" values on page 218 of
   the Windows 3.1 SDK Programmer's Reference, Volume 4: Resources.
   This page is in Chapter 13, "Resource-Definition Statements", in the
   description of the "VERSIONINFO" statment.

   For example, 
   0x0407  German
   0x0409  U.S. English
   0x0809  U.K. English
   0x040C  French
   0x040A  Castilian Spanish
*/
#define wLanguage 0x0409           /* U.S. English */

/* The first 4 characters of szTranslation must be the same as wLanguage,
   without the "0x".  The last 4 characters of szTranslation MUST be
   04E4.  Note that any alphabetic characters in szTranslation must
   be capitalized. */
#define szTranslation "040904E4"   /* U.S. English */


/* The following szz strings must all end with the two characters "\0" */
/* Note that the "\251" in szzLegalCopyright stands for the "circle c"
   copyright symbol, and it should be left as \251 rather than
   substituting the actual ANSI copyright character in the string. */
#define szzCompanyName     "Microsoft Corporation\0"
#define szzFileDescription "Microsoft Windows(TM) OLE 2.0 User Interface Support\0"
#define szzLegalCopyright  "Copyright \251 1992-1993 Microsoft Corp.  All rights reserved.\0"

#ifdef PUBLISHER
#define szzProductName "Microsoft Publisher for Windows 2.0\0"
#else
#define szzProductName szzFileDescription
#endif


/* DO NOT CHANGE ANY LINES BELOW THIS POINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\makefile.inc ===
# 16-bit makefile
#
# Copyright (c) 1991, Microsoft Corporation
#
# History:
#
#   18-Feb-1994 KevinRo
#   24-Feb-1994 DrewB, added OBJDIR and some other niceties from win40.mk
#

.SUFFIXES:
.SUFFIXES: .c  .cxx  .cpp .asm .h   .inc .obj .lst
.SUFFIXES: .sys .exe .com .map .sym .def .lib .rc .res

!if "$(TARGET)" == ""
!error TARGET must be defined
!endif

OUTNUL= 1>nul 2>nul

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"
OBJDIR = objd
!else
OBJDIR = objr
!endif

# Build up lists of files to produce from sources

!if "$(CFILES)" != ""
OBJFILES = $(OBJFILES) $(CFILES:.c=.obj)
!endif
!if "$(CXXFILES)" != ""
OBJFILES = $(OBJFILES) $(CXXFILES:.cxx=.obj)
!endif
!if "$(CPPFILES)" != ""
OBJFILES = $(OBJFILES) $(CPPFILES:.cpp=.obj)
!endif

!if "$(ASMFILES)" != ""
OBJFILES = $(OBJFILES) $(ASMFILES:.asm=.obj)
!endif

!if "$(RCFILES)" != ""
RESFILES = $(RCFILES:.rc=.res)
!endif

# Replace .\ with $(OBJDIR)
# Unfortunately we can't do this directly so we have to explicitly check
# the value of OBJDIR

!if "$(OBJDIR)" == "objd"
OBJFILES = $(OBJFILES:.\=objd\)
RESFILES = $(RESFILES:.\=objd\)

!elseif "$(OBJDIR)" == "objr"
OBJFILES = $(OBJFILES:.\=objr\)
RESFILES = $(RESFILES:.\=objr\)

!else
!error Unknown OBJDIR: $(OBJDIR)
!endif

# Default target

all: $(OBJDIR)\$(TARGET)

# Determine target type and base name

# Is it a DLL?
TARGETBASE=$(TARGET:.dll=)
!if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=dll
!else

# Is it an EXE?
TARGETBASE=$(TARGET:.exe=)
! if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=exe
! else

# Is it a LIB?
TARGETBASE=$(TARGET:.lib=)
!  if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=lib
!  endif
! endif
!endif

!if "$(TARGETTYPE)" == ""
!error Unknown target type for "$(TARGET)"
!endif

!if "$(BUILDDETAILS)" != ""
BLDKEEP=        KEEP
!endif

OLETHUNK= $(_NTDRIVE)$(_NTROOT)\private\ole32\olethunk
OLE16= $(OLETHUNK)\ole16

RCINC = $(RCINC) -i$(OLE16)\inc
INCS = -I$(OLE16)\inc -I$(OLETHUNK)\h -I$(_NTDRIVE)$(_NTROOT)\private\cinc


PATH     = $(OLE16)\tools;$(PATH)
LINK    = link16
RC      = rc16
CL      = cl16
IMPLIB  = implib
LIBUTIL = lib16
MAPSYM  = mapsym
MASM    = masm

DEFINES = -DWOW

AOBJ    = -Mx -t $(DEFINES) $(INCS)

!if "$(TARGETTYPE)" == "exe"
CW16    = -GA
!else
CW16    = -GD
DEFINES = $(DEFINES) -D_WINDLL
!endif

CW16    = $(CW16) -G2 -AL $(DEFINES) $(INCS) /NMSEG_CODE

LFLAGS  = $(LFLAGS) /nod /noe /map:0 /align:16

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"

DEFINES = $(DEFINES) -DDBG=1 -DDEVL=1

!if "$(NTDEBUGTYPE)" == "windbg"
AOBJ    = $(AOBJ) -Zi
CW16    = $(CW16) /Odi /Zip /FA
LFLAGS  = $(LFLAGS) /CO
!else
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Odi /Zd
LFLAGS  = $(LFLAGS) /LI
!endif

!else
CW16    = $(CW16) /Os /Zp /Gs
DEFINES = $(DEFINES) -DDBG=0 -DDEVL=1
!endif

!if "$(TARGETTYPE)" == "dll"
W16LIBS = $(OLE16)\lib\ldllcew.lib
!else
!if "$(QUICKWINDOWS)" != ""
W16LIBS = $(OLE16)\lib\llibcewq.lib
!else
W16LIBS = $(OLE16)\lib\llibcew.lib
!endif
!endif

W16LIBS = $(W16LIBS) $(OLE16)\lib\libw.lib

!if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "exe"
LIBS = $(LIBS) $(W16LIBS)
!endif

.asm{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) $*,$*;

.asm.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) -l $*,nul,$*.lst;


.c{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
$<
<<$(BLDKEEP)

.c.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fonul
-Fc$*.lst
$<
<<$(BLDKEEP)

.cxx{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cxx.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cxx.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.cpp{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cpp.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cpp.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.def{$(OBJDIR)}.lib:
        @-md $(OBJDIR) $(OUTNUL)
        $(IMPLIB) $*.lib $<

{$(OBJDIR)}.map{$(OBJDIR)}.sym:
        @-md $(OBJDIR) $(OUTNUL)
        $(MAPSYM) $<

.rc{$(OBJDIR)}.res:
                @-md $(OBJDIR) $(OUTNUL)
        $(RC) -r  $(RCINC) -fo $*.res $<


cleanup:
    if exist $(OBJDIR)\*.lrf del $(OBJDIR)\*.lrf
    if exist $(OBJDIR)\*.obj del $(OBJDIR)\*.obj
    if exist $(OBJDIR)\*.exe del $(OBJDIR)\*.exe
    if exist $(OBJDIR)\*.map del $(OBJDIR)\*.map
    if exist $(OBJDIR)\*.sym del $(OBJDIR)\*.sym
    if exist $(OBJDIR)\*.res del $(OBJDIR)\*.res

clean: cleanup

!if "$(TARGETTYPE)" == "dll"

$(OBJDIR)\$(TARGETBASE).lib: $(TARGETBASE).def

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(OBJDIR)\$(TARGETBASE).lib $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map
!if "$(RCFILES)" != ""
        $(RC)  -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif

!elseif "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGET): $(OBJFILES) $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        -del $@ $(OUTNUL)
        $(LIBUTIL) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJFILES: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(BLDKEEP)

!elseif "$(TARGETTYPE)" == "exe"

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
!if "$(RCFILES)" != ""
       $(RC) -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpleApp
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

#include <ole2.h>

class CSimpleDoc;

class CSimpleApp : public IUnknown
{
public:

        int m_nCount;           // reference count
        HWND m_hAppWnd;         // main window handle
        HWND m_hDriverWnd;      // window handle for the driver app.
        HINSTANCE m_hInst;      // application instance
        CSimpleDoc FAR * m_lpDoc;   // pointer to document object
        BOOL m_fInitialized;    // OLE initialization flag
        HMENU           m_hMainMenu;
        HMENU           m_hFileMenu;
        HMENU           m_hEditMenu;
        HMENU           m_hHelpMenu;
        HMENU           m_hCascadeMenu;     // OLE object's verb


        // Drag/Drop related fields
        int m_nDragDelay;       // time delay (in msec) before drag should start
        int m_nDragMinDist;     // min. distance (radius) before drag should start
        int m_nScrollDelay;     // time delay (in msec) before scroll should start
        int m_nScrollInset;     // Border inset distance to start drag scroll
        int m_nScrollInterval;  // scroll interval time (in msec)

        CSimpleApp();           // Constructor
        ~CSimpleApp();          // Destructor

        // IUnknown Interfaces
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // Initialization methods

        BOOL fInitApplication (HANDLE hInstance);
        BOOL fInitInstance (HANDLE hInstance, int nCmdShow);

        // Message handling methods

        long lCommandHandler (HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
        long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
        long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
        BOOL HandleAccelerators (LPMSG lpMsg);
        void PaintApp(HDC hDC);
        void DestroyDocs();
};

#endif  // _APP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\ole2ui\res\localole.h ===
/*
 * OLE2UI.H
 *
 * Published definitions, structures, types, and function prototypes for the
 * OLE 2.0 User Interface support library.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 */


#define NONAMELESSUNION     // use strict ANSI standard (for DVOBJ.H)

#ifndef _OLE2UI_H_
#define _OLE2UI_H_

#ifndef RC_INVOKED
#pragma message ("Including OLE2UI.H from " __FILE__)
#endif  //RC_INVOKED

#include <windows.h>
#include <shellapi.h>
#include <ole2.h>
#include <string.h>
#include "olestd.h"
#include "uiclass.h"
// -- see below

#ifdef __TURBOC__
#define _getcwd getcwd
#define _itoa   itoa
#define __max   max
#define _find_t find_t
#endif // __TURBOC__

/*
 * Initialization / Uninitialization routines.  OleUIInitialize
 * MUST be called prior to using any functions in OLE2UI.
 */

STDAPI_(BOOL) OleUIInitialize(HINSTANCE);
STDAPI_(BOOL) OleUIUnInitialize(void);  // Must be called when completed using functions in OLE2UI

//Dialog Identifiers as passed in Help messages to identify the source.
#define IDD_INSERTOBJECT        1000
#define IDD_CHANGEICON          1001
#define IDD_CONVERT             1002
#define IDD_PASTESPECIAL        1003
#define IDD_EDITLINKS           1004
#define IDD_FILEOPEN            1005
#define IDD_BUSY                1006
#define IDD_LINKSOURCEUNAVAILABLE   1007
#define IDD_CANNOTUPDATELINK    1008
#define IDD_SERVERNOTREG        1009
#define IDD_LINKTYPECHANGED     1010
#define IDD_SERVERNOTFOUND      1011
#define IDD_UPDATELINKS         1012
#define IDD_OUTOFMEMORY         1013

#define IDOK    1
#define IDCANCEL 2

// Stringtable identifers
#define IDS_OLE2UIUNKNOWN       300
#define IDS_OLE2UILINK          301
#define IDS_OLE2UIOBJECT        302
#define IDS_OLE2UIEDIT          303
#define IDS_OLE2UICONVERT       304
#define IDS_OLE2UIEDITLINKCMD_1VERB     305
#define IDS_OLE2UIEDITOBJECTCMD_1VERB   306
#define IDS_OLE2UIEDITLINKCMD_NVERB     307
#define IDS_OLE2UIEDITOBJECTCMD_NVERB   308
#define IDS_OLE2UIEDITNOOBJCMD  309
#define IDS_DEFICONLABEL        310     // def. icon label (usu. "Document")


#define IDS_FILTERS             64
#define IDS_ICONFILTERS         65

//Resource identifiers for bitmaps
#define IDB_RESULTSEGA                  10
#define IDB_RESULTSVGA                  11
#define IDB_RESULTSHIRESVGA             12


//Missing from windows.h
#ifndef PVOID
typedef VOID *PVOID;
#endif


//Hook type used in all structures.
typedef UINT (CALLBACK *LPFNOLEUIHOOK)(HWND, UINT, WPARAM, LPARAM);


//Strings for registered messages
#define SZOLEUI_MSG_HELP                "OLEUI_MSG_HELP"
#define SZOLEUI_MSG_ENDDIALOG           "OLEUI_MSG_ENDDIALOG"
#define SZOLEUI_MSG_BROWSE              "OLEUI_MSG_BROWSE"
#define SZOLEUI_MSG_CHANGEICON          "OLEUI_MSG_CHANGEICON"
#define SZOLEUI_MSG_CLOSEBUSYDIALOG     "OLEUI_MSG_CLOSEBUSYDIALOG"
#define SZOLEUI_MSG_FILEOKSTRING        "OLEUI_MSG_FILEOKSTRING"

// Define the classname strings.  The strings below define the custom
// control classnames for the controls used in the UI dialogs.  
//
// **************************************************************
// These classnames must be distinct for each application
// which uses this library, or your application will generate an
// fatal error under the debugging version of Windows 3.1.
// **************************************************************
//
// The MAKEFILE for this library automatically generates a file
// uiclass.h which contains distinct definitions for these
// classname strings, as long as you use a distinct name when
// you build the library.  See the MAKEFILE for more information
// on setting the name of the library.

#define SZCLASSICONBOX                 OLEUICLASS1
#define SZCLASSRESULTIMAGE             OLEUICLASS2

#define OLEUI_ERR_STANDARDMIN           100
#define OLEUI_ERR_STRUCTURENULL         101   //Standard field validation
#define OLEUI_ERR_STRUCTUREINVALID      102
#define OLEUI_ERR_CBSTRUCTINCORRECT     103
#define OLEUI_ERR_HWNDOWNERINVALID      104
#define OLEUI_ERR_LPSZCAPTIONINVALID    105
#define OLEUI_ERR_LPFNHOOKINVALID       106
#define OLEUI_ERR_HINSTANCEINVALID      107
#define OLEUI_ERR_LPSZTEMPLATEINVALID   108
#define OLEUI_ERR_HRESOURCEINVALID      109

#define OLEUI_ERR_FINDTEMPLATEFAILURE   110   //Initialization errors
#define OLEUI_ERR_LOADTEMPLATEFAILURE   111
#define OLEUI_ERR_DIALOGFAILURE         112
#define OLEUI_ERR_LOCALMEMALLOC         113
#define OLEUI_ERR_GLOBALMEMALLOC        114
#define OLEUI_ERR_LOADSTRING            115

#define OLEUI_ERR_STANDARDMAX           116   //Start here for specific errors.



//Help Button Identifier
#define ID_OLEUIHELP                    99

// Help button for fileopen.dlg  (need this for resizing) 1038 is pshHelp
#define IDHELP  1038

// Static text control (use this instead of -1 so things work correctly for
// localization
#define  ID_STATIC                      98

//Maximum key size we read from the RegDB.
#define OLEUI_CCHKEYMAX                 256  // make any changes to this in geticon.c too

//Maximum verb length and length of Object menu
#define OLEUI_CCHVERBMAX                32
#define OLEUI_OBJECTMENUMAX             64

//Maximum MS-DOS pathname.
#define OLEUI_CCHPATHMAX                256 // make any changes to this in geticon.c too
#define OLEUI_CCHFILEMAX                13

//Icon label length
#define OLEUI_CCHLABELMAX               40  // make any changes to this in geticon.c too

//Length of the CLSID string
#define OLEUI_CCHCLSIDSTRING            39


/*
 * What follows here are first function prototypes for general utility
 * functions, then sections laid out by dialog.  Each dialog section
 * defines the dialog structure, the API prototype, flags for the dwFlags
 * field, the dialog-specific error values, and dialog control IDs (for
 * hooks and custom templates.
 */


//Miscellaneous utility functions.
STDAPI_(BOOL) OleUIAddVerbMenu(LPOLEOBJECT lpOleObj,
                             LPSTR lpszShortType,
                             HMENU hMenu,
                             UINT uPos,
                             UINT uIDVerbMin,
                             BOOL bAddConvert,
                             UINT idConvert,
                             HMENU FAR *lphMenu);
        
//Metafile utility functions
STDAPI_(HGLOBAL) OleUIMetafilePictFromIconAndLabel(HICON, LPSTR, LPSTR, UINT);
STDAPI_(void)    OleUIMetafilePictIconFree(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictIconDraw(HDC, LPRECT, HGLOBAL, BOOL);
STDAPI_(UINT)    OleUIMetafilePictExtractLabel(HGLOBAL, LPSTR, UINT, LPDWORD);
STDAPI_(HICON)   OleUIMetafilePictExtractIcon(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictExtractIconSource(HGLOBAL,LPSTR,UINT FAR *);





/*************************************************************************
** INSERT OBJECT DIALOG
*************************************************************************/


typedef struct tagOLEUIINSERTOBJECT
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;         //Structure Size
    DWORD           dwFlags;          //IN-OUT:  Flags
    HWND            hWndOwner;        //Owning window
    LPCSTR          lpszCaption;      //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;         //Hook callback
    LPARAM          lCustData;        //Custom data to pass to hook
    HINSTANCE       hInstance;        //Instance for customized template name
    LPCSTR          lpszTemplate;     //Customized template name
    HRSRC           hResource;        //Customized template handle

    //Specifics for OLEUIINSERTOBJECT.  All are IN-OUT unless otherwise spec.
    CLSID           clsid;            //Return space for class ID
    LPSTR           lpszFile;         //Filename for inserts or links
    UINT            cchFile;          //Size of lpszFile buffer: OLEUI_CCHPATHMAX
    UINT            cClsidExclude;    //IN only:  CLSIDs in lpClsidExclude
    LPCLSID         lpClsidExclude;   //List of CLSIDs to exclude from listing.

    //Specific to create objects if flags say so
    IID             iid;              //Requested interface on creation.
    DWORD           oleRender;        //Rendering option
    LPFORMATETC     lpFormatEtc;      //Desired format
    LPOLECLIENTSITE lpIOleClientSite; //Site to be use for the object.
    LPSTORAGE       lpIStorage;       //Storage used for the object
    LPVOID FAR     *ppvObj;           //Where the object is returned.
    SCODE           sc;               //Result of creation calls.
    HGLOBAL         hMetaPict;        //OUT: METAFILEPICT containing iconic aspect.
                                      //IFF we couldn't stuff it in the cache.
    } OLEUIINSERTOBJECT, *POLEUIINSERTOBJECT, FAR *LPOLEUIINSERTOBJECT;

//API prototype
STDAPI_(UINT) OleUIInsertObject(LPOLEUIINSERTOBJECT);


//Insert Object flags
#define IOF_SHOWHELP                0x00000001L
#define IOF_SELECTCREATENEW         0x00000002L
#define IOF_SELECTCREATEFROMFILE    0x00000004L
#define IOF_CHECKLINK               0x00000008L
#define IOF_CHECKDISPLAYASICON      0x00000010L
#define IOF_CREATENEWOBJECT         0x00000020L
#define IOF_CREATEFILEOBJECT        0x00000040L
#define IOF_CREATELINKOBJECT        0x00000080L
#define IOF_DISABLELINK             0x00000100L
#define IOF_VERIFYSERVERSEXIST      0x00000200L


//Insert Object specific error codes
#define OLEUI_IOERR_LPSZFILEINVALID         (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_LPSZLABELINVALID        (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_HICONINVALID            (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_IOERR_LPFORMATETCINVALID      (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_IOERR_PPVOBJINVALID           (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_IOERR_LPIOLECLIENTSITEINVALID (OLEUI_ERR_STANDARDMAX+5)
#define OLEUI_IOERR_LPISTORAGEINVALID       (OLEUI_ERR_STANDARDMAX+6)
#define OLEUI_IOERR_SCODEHASERROR           (OLEUI_ERR_STANDARDMAX+7)
#define OLEUI_IOERR_LPCLSIDEXCLUDEINVALID   (OLEUI_ERR_STANDARDMAX+8)
#define OLEUI_IOERR_CCHFILEINVALID          (OLEUI_ERR_STANDARDMAX+9)


//Insert Object Dialog identifiers
#define ID_IO_CREATENEW                 2100
#define ID_IO_CREATEFROMFILE            2101
#define ID_IO_LINKFILE                  2102
#define ID_IO_OBJECTTYPELIST            2103
#define ID_IO_DISPLAYASICON             2104
#define ID_IO_CHANGEICON                2105
#define ID_IO_FILE                      2106
#define ID_IO_FILEDISPLAY               2107
#define ID_IO_RESULTIMAGE               2108
#define ID_IO_RESULTTEXT                2109
#define ID_IO_ICONDISPLAY               2110
#define ID_IO_OBJECTTYPETEXT            2111
#define ID_IO_FILETEXT                  2112
#define ID_IO_FILETYPE                  2113
                                        
// Strings in OLE2UI resources
#define IDS_IORESULTNEW                 256
#define IDS_IORESULTNEWICON             257
#define IDS_IORESULTFROMFILE1           258
#define IDS_IORESULTFROMFILE2           259
#define IDS_IORESULTFROMFILEICON2       260
#define IDS_IORESULTLINKFILE1           261     
#define IDS_IORESULTLINKFILE2           262
#define IDS_IORESULTLINKFILEICON1       263 
#define IDS_IORESULTLINKFILEICON2       264

/*************************************************************************
** PASTE SPECIAL DIALOG
*************************************************************************/

// Maximum number of link types
#define     PS_MAXLINKTYPES  8

//NOTE: OLEUIPASTEENTRY and OLEUIPASTEFLAG structs are defined in OLESTD.H

typedef struct tagOLEUIPASTESPECIAL
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;       //Structure Size
    DWORD           dwFlags;        //IN-OUT:  Flags
    HWND            hWndOwner;      //Owning window
    LPCSTR          lpszCaption;    //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;       //Hook callback
    LPARAM          lCustData;      //Custom data to pass to hook
    HINSTANCE       hInstance;      //Instance for customized template name
    LPCSTR          lpszTemplate;   //Customized template name
    HRSRC           hResource;      //Customized template handle

    //Specifics for OLEUIPASTESPECIAL.

    //IN  fields
    LPDATAOBJECT    lpSrcDataObj;       //Source IDataObject* (on the clipboard) for data to paste

    LPOLEUIPASTEENTRY arrPasteEntries;  //OLEUIPASTEENTRY array which specifies acceptable formats. See
                                        //  OLEUIPASTEENTRY for more information.
    int             cPasteEntries;      //Number of OLEUIPASTEENTRY array entries

    UINT        FAR *arrLinkTypes;      //List of link types that are acceptable. Link types are referred
                                        //  to using OLEUIPASTEFLAGS in arrPasteEntries
    int             cLinkTypes;         //Number of link types

    //OUT fields
    int             nSelectedIndex;    //Index of arrPasteEntries[] that the user selected
    BOOL            fLink;             //Indicates if Paste or Paste Link was selected by the user
    HGLOBAL         hMetaPict;         //Handle to Metafile containing icon and icon title selected by the user
                                       //  Use the Metafile utility functions defined in this header to
                                       //  manipulate hMetaPict
    } OLEUIPASTESPECIAL, *POLEUIPASTESPECIAL, FAR *LPOLEUIPASTESPECIAL;


//API to bring up PasteSpecial dialog
STDAPI_(UINT) OleUIPasteSpecial(LPOLEUIPASTESPECIAL);


//Paste Special flags
// Show Help button. IN flag.
#define PSF_SHOWHELP                0x00000001L
// Select Paste radio button at dialog startup. This is the default if PSF_SELECTPASTE or PSF_SELECTPASTELINK
// are not specified. Also specifies state of button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTE             0x00000002L
// Select PasteLink radio button at dialog startup. Also specifies state of button on dialog termination.
// IN/OUT flag.
#define PSF_SELECTPASTELINK         0x00000004L
// Specfies if DisplayAsIcon button was checked on dialog termination. OUT flag.
#define PSF_CHECKDISPLAYASICON      0x00000008L


//Paste Special specific error codes
#define OLEUI_IOERR_SRCDATAOBJECTINVALID      (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_ARRPASTEENTRIESINVALID    (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_ARRLINKTYPESINVALID       (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_PSERR_CLIPBOARDCHANGED          (OLEUI_ERR_STANDARDMAX+3)

//Paste Special Dialog identifiers
#define ID_PS_PASTE                    500
#define ID_PS_PASTELINK                501
#define ID_PS_SOURCETEXT               502
#define ID_PS_PASTELIST                503
#define ID_PS_PASTELINKLIST            504
#define ID_PS_DISPLAYLIST              505
#define ID_PS_DISPLAYASICON            506
#define ID_PS_ICONDISPLAY              507
#define ID_PS_CHANGEICON               508
#define ID_PS_RESULTIMAGE              509
#define ID_PS_RESULTTEXT               510
#define ID_PS_RESULTGROUP              511
#define ID_PS_STXSOURCE                512
#define ID_PS_STXAS                    513

// Paste Special String IDs
#define IDS_PSPASTEDATA                400
#define IDS_PSPASTEOBJECT              401
#define IDS_PSPASTEOBJECTASICON        402
#define IDS_PSPASTELINKDATA            403
#define IDS_PSPASTELINKOBJECT          404
#define IDS_PSPASTELINKOBJECTASICON    405
#define IDS_PSNONOLE                   406
#define IDS_PSUNKNOWNTYPE              407
#define IDS_PSUNKNOWNSRC               408
#define IDS_PSUNKNOWNAPP               409


/*************************************************************************
** EDIT LINKS DIALOG
*************************************************************************/



/* IOleUILinkContainer Interface
** -----------------------------
**    This interface must be implemented by container applications that
**    want to use the EditLinks dialog. the EditLinks dialog calls back
**    to the container app to perform the OLE functions to manipulate
**    the links within the container.
*/

#define LPOLEUILINKCONTAINER     IOleUILinkContainer FAR*

#undef  INTERFACE
#define INTERFACE   IOleUILinkContainer

DECLARE_INTERFACE_(IOleUILinkContainer, IUnknown)
{
    //*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink) PURE;
    STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD dwUpdateOpt) PURE;
    STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD FAR* lpdwUpdateOpt) PURE;
    STDMETHOD(SetLinkSource) (THIS_
            DWORD       dwLink,
            LPSTR       lpszDisplayName,
            ULONG       lenFileName,
            ULONG FAR*  pchEaten,
            BOOL        fValidateSource) PURE;
    STDMETHOD(GetLinkSource) (THIS_
            DWORD       dwLink,
            LPSTR FAR*  lplpszDisplayName,
            ULONG FAR*  lplenFileName,
            LPSTR FAR*  lplpszFullLinkType,
            LPSTR FAR*  lplpszShortLinkType,
            BOOL FAR*   lpfSourceAvailable,
            BOOL FAR*   lpfIsSelected) PURE;
    STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink) PURE;
    STDMETHOD(UpdateLink) (THIS_ 
            DWORD dwLink, 
            BOOL fErrorMessage,
            BOOL fErrorAction) PURE;
    STDMETHOD(CancelLink) (THIS_ DWORD dwLink) PURE;
};


typedef struct tagOLEUIEDITLINKS
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;       //Structure Size
    DWORD           dwFlags;        //IN-OUT:  Flags
    HWND            hWndOwner;      //Owning window
    LPCSTR          lpszCaption;    //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;       //Hook callback
    LPARAM          lCustData;      //Custom data to pass to hook
    HINSTANCE       hInstance;      //Instance for customized template name
    LPCSTR          lpszTemplate;   //Customized template name
    HRSRC           hResource;      //Customized template handle

    //Specifics for OLEUI<STRUCT>.  All are IN-OUT unless otherwise spec.

    LPOLEUILINKCONTAINER lpOleUILinkContainer;  //IN: Interface to manipulate
                                                //links in the container
    } OLEUIEDITLINKS, *POLEUIEDITLINKS, FAR *LPOLEUIEDITLINKS;


//API Prototype
STDAPI_(UINT) OleUIEditLinks(LPOLEUIEDITLINKS);


// Edit Links flags
#define ELF_SHOWHELP                0x00000001L

// Edit Links Dialog identifiers
#define ID_EL_CHANGESOURCE             201
#define ID_EL_AUTOMATIC                202
#define ID_EL_CLOSE                    208
#define ID_EL_CANCELLINK               209
#define ID_EL_UPDATENOW                210
#define ID_EL_OPENSOURCE               211
#define ID_EL_MANUAL                   212
#define ID_EL_LINKSOURCE               216
#define ID_EL_LINKTYPE                 217
#define ID_EL_UPDATE                   218
#define ID_EL_NULL                     -1
#define ID_EL_LINKSLISTBOX             206
#define ID_EL_HELP                     207
#define ID_EL_COL1                     223
#define ID_EL_COL2                     221
#define ID_EL_COL3                     222



/*************************************************************************
** CHANGE ICON DIALOG
*************************************************************************/

typedef struct tagOLEUICHANGEICON
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;       //Structure Size
    DWORD           dwFlags;        //IN-OUT:  Flags
    HWND            hWndOwner;      //Owning window
    LPCSTR          lpszCaption;    //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;       //Hook callback
    LPARAM          lCustData;      //Custom data to pass to hook
    HINSTANCE       hInstance;      //Instance for customized template name
    LPCSTR          lpszTemplate;   //Customized template name
    HRSRC           hResource;      //Customized template handle

    //Specifics for OLEUICHANGEICON.  All are IN-OUT unless otherwise spec.
    HGLOBAL         hMetaPict;      //Current and final image.  Source of the
                                    //icon is embedded in the metafile itself.
    CLSID           clsid;          //IN only: class used to get Default icon
    char            szIconExe[OLEUI_CCHPATHMAX];
    int             cchIconExe;
    } OLEUICHANGEICON, *POLEUICHANGEICON, FAR *LPOLEUICHANGEICON;


//API prototype
STDAPI_(UINT) OleUIChangeIcon(LPOLEUICHANGEICON);


//Change Icon flags
#define CIF_SHOWHELP                0x00000001L
#define CIF_SELECTCURRENT           0x00000002L
#define CIF_SELECTDEFAULT           0x00000004L
#define CIF_SELECTFROMFILE          0x00000008L
#define CIF_USEICONEXE              0x0000000aL


//Change Icon specific error codes
#define OLEUI_CIERR_MUSTHAVECLSID           (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_CIERR_MUSTHAVECURRENTMETAFILE (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CIERR_SZICONEXEINVALID        (OLEUI_ERR_STANDARDMAX+2)


//Change Icon Dialog identifiers
#define ID_GROUP                    120
#define ID_CURRENT                  121
#define ID_CURRENTICON              122
#define ID_DEFAULT                  123
#define ID_DEFAULTICON              124
#define ID_FROMFILE                 125
#define ID_FROMFILEEDIT             126
#define ID_ICONLIST                 127
#define ID_LABEL                    128
#define ID_LABELEDIT                129
#define ID_BROWSE                   130
#define ID_RESULTICON               132
#define ID_RESULTLABEL              133

// Stringtable defines for Change Icon
#define IDS_CINOICONSINFILE         288
#define IDS_CIINVALIDFILE           289
#define IDS_CIFILEACCESS            290
#define IDS_CIFILESHARE             291
#define IDS_CIFILEOPENFAIL          292



/*************************************************************************
** CONVERT DIALOG
*************************************************************************/

typedef struct tagOLEUICONVERT
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;         //Structure Size
    DWORD           dwFlags;          //IN-OUT:  Flags
    HWND            hWndOwner;        //Owning window
    LPCSTR          lpszCaption;      //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;         //Hook callback
    LPARAM          lCustData;        //Custom data to pass to hook
    HINSTANCE       hInstance;        //Instance for customized template name
    LPCSTR          lpszTemplate;     //Customized template name
    HRSRC           hResource;        //Customized template handle

    //Specifics for OLEUICONVERT.  All are IN-OUT unless otherwise spec.
    CLSID           clsid;            //Class ID sent in to dialog: IN only
    CLSID           clsidConvertDefault;  //Class ID to use as convert default: IN only
    CLSID           clsidActivateDefault;  //Class ID to use as activate default: IN only

    CLSID           clsidNew;         //Selected Class ID: OUT only
    DWORD           dvAspect;         //IN-OUT, either DVASPECT_CONTENT or
                                      //DVASPECT_ICON
    WORD            wFormat;          //Original data format
    BOOL            fIsLinkedObject;  //IN only; true if object is linked
    HGLOBAL         hMetaPict;        //IN-OUT: METAFILEPICT containing iconic aspect.
    LPSTR           lpszUserType;     //IN: user type name of original class. We'll do lookup if it's NULL.
                                      //This gets freed on exit.
    BOOL            fObjectsIconChanged;  // OUT; TRUE if ChangeIcon was called (and not cancelled)

    } OLEUICONVERT, *POLEUICONVERT, FAR *LPOLEUICONVERT;


//API prototype
STDAPI_(UINT) OleUIConvert(LPOLEUICONVERT);

//Convert Dialog flags

// IN only: Shows "HELP" button
#define CF_SHOWHELPBUTTON          0x00000001L

// IN only: lets you set the convert default object - the one that is
// selected as default in the convert listbox.
#define CF_SETCONVERTDEFAULT       0x00000002L


// IN only: lets you set the activate default object - the one that is
// selected as default in the activate listbox.

#define CF_SETACTIVATEDEFAULT       0x00000004L


// IN/OUT: Selects the "Convert To" radio button, is set on exit if
// this button was selected
#define CF_SELECTCONVERTTO         0x00000008L

// IN/OUT: Selects the "Activate As" radio button, is set on exit if
// this button was selected
#define CF_SELECTACTIVATEAS        0x00000010L


//Convert specific error codes
#define OLEUI_CTERR_CLASSIDINVALID      (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CTERR_DVASPECTINVALID     (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_CTERR_CBFORMATINVALID     (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_CTERR_HMETAPICTINVALID    (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_CTERR_STRINGINVALID       (OLEUI_ERR_STANDARDMAX+5)


//Convert Dialog identifiers
#define IDCV_OBJECTTYPE             150
#define IDCV_HELP                   151
#define IDCV_DISPLAYASICON          152
#define IDCV_CHANGEICON             153
#define IDCV_ACTIVATELIST           154
#define IDCV_CONVERTTO              155
#define IDCV_ACTIVATEAS             156
#define IDCV_RESULTTEXT             157
#define IDCV_CONVERTLIST            158
#define IDCV_ICON                   159
#define IDCV_ICONLABEL1             160
#define IDCV_ICONLABEL2             161
#define IDCV_STXCURTYPE             162
#define IDCV_GRPRESULT              163
#define IDCV_STXCONVERTTO           164

// String IDs for Convert dialog
#define IDS_CVRESULTCONVERTLINK     500
#define IDS_CVRESULTCONVERTTO       501
#define IDS_CVRESULTNOCHANGE        502
#define IDS_CVRESULTDISPLAYASICON   503
#define IDS_CVRESULTACTIVATEAS      504
#define IDS_CVRESULTACTIVATEDIFF    505


/*************************************************************************
** BUSY DIALOG
*************************************************************************/

typedef struct tagOLEUIBUSY
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;         //Structure Size
    DWORD           dwFlags;          //IN-OUT:  Flags ** NOTE ** this dialog has no flags
    HWND            hWndOwner;        //Owning window
    LPCSTR          lpszCaption;      //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;         //Hook callback
    LPARAM          lCustData;        //Custom data to pass to hook
    HINSTANCE       hInstance;        //Instance for customized template name
    LPCSTR          lpszTemplate;     //Customized template name
    HRSRC           hResource;        //Customized template handle

    //Specifics for OLEUIBUSY.
    HTASK           hTask;            //IN: HTask which is blocking
    HWND FAR *      lphWndDialog;     //IN: Dialog's HWND is placed here
    } OLEUIBUSY, *POLEUIBUSY, FAR *LPOLEUIBUSY;

//API prototype
STDAPI_(UINT) OleUIBusy(LPOLEUIBUSY);

// Flags for this dialog

// IN only: Disables "Cancel" button
#define BZ_DISABLECANCELBUTTON          0x00000001L

// IN only: Disables "Switch To..." button
#define BZ_DISABLESWITCHTOBUTTON        0x00000002L

// IN only: Disables "Retry" button
#define BZ_DISABLERETRYBUTTON           0x00000004L

// IN only: Generates a "Not Responding" dialog as opposed to the
// "Busy" dialog.  The wording in the text is slightly different, and
// the "Cancel" button is grayed out if you set this flag.
#define BZ_NOTRESPONDINGDIALOG          0x00000008L

// Busy specific error/return codes
#define OLEUI_BZERR_HTASKINVALID     (OLEUI_ERR_STANDARDMAX+0)

// SWITCHTOSELECTED is returned when user hit "switch to"
#define OLEUI_BZ_SWITCHTOSELECTED    (OLEUI_ERR_STANDARDMAX+1)

// RETRYSELECTED is returned when user hit "retry"
#define OLEUI_BZ_RETRYSELECTED       (OLEUI_ERR_STANDARDMAX+2)

// CALLUNBLOCKED is returned when call has been unblocked
#define OLEUI_BZ_CALLUNBLOCKED       (OLEUI_ERR_STANDARDMAX+3)

// Busy dialog identifiers
#define IDBZ_RETRY                      600
#define IDBZ_ICON                       601
#define IDBZ_MESSAGE1                   602
#define IDBZ_SWITCHTO                   604

// Busy dialog stringtable defines
#define IDS_BZRESULTTEXTBUSY            601
#define IDS_BZRESULTTEXTNOTRESPONDING   602

// Links dialog stringtable defines
#define IDS_LINK_AUTO           800
#define IDS_LINK_MANUAL         801
#define IDS_LINK_UNKNOWN        802
#define IDS_LINKS               803
#define IDS_FAILED              804
#define IDS_CHANGESOURCE        805
#define IDS_INVALIDSOURCE       806
#define IDS_ERR_GETLINKSOURCE   807
#define IDS_ERR_GETLINKUPDATEOPTIONS    808
#define IDS_ERR_ADDSTRING       809
#define IDS_CHANGEADDITIONALLINKS   810


/*************************************************************************
** PROMPT USER DIALOGS
*************************************************************************/
#define ID_PU_LINKS             900
#define ID_PU_TEXT              901
#define ID_PU_CONVERT           902
#define ID_PU_HELP              903
#define ID_PU_BROWSE            904
#define ID_PU_METER             905
#define ID_PU_PERCENT           906
#define ID_PU_STOP              907

// used for -1 ids in dialogs:
#define ID_DUMMY    999

/* inside ole2ui.c */
#ifdef __cplusplus
extern "C" 
#endif
int __export FAR CDECL OleUIPromptUser(int nTemplate, HWND hwndParent, ...);
STDAPI_(BOOL) OleUIUpdateLinks(
        LPOLEUILINKCONTAINER lpOleUILinkCntr, 
        HWND hwndParent, 
        LPSTR lpszTitle, 
        int cLinks);


/*************************************************************************
** OLE OBJECT FEEDBACK EFFECTS
*************************************************************************/

#define OLEUI_HANDLES_USEINVERSE    0x00000001L
#define OLEUI_HANDLES_NOBORDER      0x00000002L
#define OLEUI_HANDLES_INSIDE        0x00000004L
#define OLEUI_HANDLES_OUTSIDE       0x00000008L


/* objfdbk.c function prototypes */
STDAPI_(void) OleUIDrawHandles(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cSize, BOOL fDraw);
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth);
STDAPI_(void) OleUIShowObject(LPCRECT lprc, HDC hdc, BOOL fIsLink);


/*************************************************************************
** Hatch window definitions and prototypes                              **
*************************************************************************/
#define DEFAULT_HATCHBORDER_WIDTH   4

STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst);
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst);
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch);
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lpHatchRect);
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect);
STDAPI_(void) SetHatchWindowSize(
        HWND        hWndHatch,
        LPRECT      lprcIPObjRect,
        LPRECT      lprcClipRect,
        LPPOINT     lpptOffset
);



/*************************************************************************
** VERSION VERIFICATION INFORMATION
*************************************************************************/

// The following magic number is used to verify that the resources we bind
// to our EXE are the same "version" as the LIB (or DLL) file which
// contains these routines.  This is not the same as the Version information
// resource that we place in OLE2UI.RC, this is a special ID that we will
// have compiled in to our EXE.  Upon initialization of OLE2UI, we will
// look in our resources for an RCDATA called "VERIFICATION" (see OLE2UI.RC),
// and make sure that the magic number there equals the magic number below.

#define OLEUI_VERSION_MAGIC 0x4D42

#endif  //_OLE2UI_H_
/*****************************************************************************\
*                                                                             *
* dlgs.h -      Common dialog's dialog element ID numbers                     *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DLGS
#define _INC_DLGS

#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#endif  /* !_INC_DLGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\ole2ui\ole2ui.h ===
/*
 * OLE2UI.H
 *
 * Published definitions, structures, types, and function prototypes for the
 * OLE 2.0 User Interface support library.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 */

/* NOTE: All dialog and string resource ID's defined in this file are
 *    in the range:
 *          32248 - 32504   (0x7DF8 - 0x7EF8)
*/


#ifndef _OLE2UI_H_
#define _OLE2UI_H_

#ifndef RC_INVOKED
#pragma message ("Including OLE2UI.H from " __FILE__)
#endif  //RC_INVOKED

#ifdef WIN32
#define _INC_OLE
#define __RPC_H__
#endif

#if !defined(__cplusplus) && !defined( __TURBOC__)
#define NONAMELESSUNION     // use strict ANSI standard (for DVOBJ.H)
#endif

#include <windows.h>
#include <shellapi.h>
#include <ole2.h>
#include <string.h>
#include <dlgs.h>           //For fileopen dlg; standard include
#include "olestd.h"

#ifdef __TURBOC__
#define _getcwd getcwd
#define _itoa   itoa
#define __max   max
#define _find_t find_t
#endif // __TURBOC__

#ifdef WIN32
#define _fmemset memset
#define _fmemcpy memcpy
#define _fmemcmp memcmp
#define _fstrcpy strcpy
#define _fstrlen strlen
#define _fstrrchr strrchr
#define _fstrtok strtok
#define lstrcpyn strncpy

// BUGBUG32: isspace function does not seem to work properly
#undef isspace
#define isspace(j) (j==' ' || j=='\t' || j=='\n')
#endif  // WIN32

#if !defined( EXPORT )
#ifdef WIN32
#define EXPORT
#else
#define EXPORT  __export
#endif  // WIN32
#endif  // !EXPORT

/*
 * Initialization / Uninitialization routines.  OleUIInitialize
 * must be called prior to using any functions in OLE2UI, and OleUIUnInitialize
 * must be called before you app shuts down and when you are done using the
 * library.
 *
 * NOTE:  If you are using the DLL version of this library, these functions
 * are automatically called in the DLL's LibMain and WEP, so you should
 * not call them directly from your application.
 */

// Backward compatibility with older library
#define OleUIUninitialize OleUIUnInitialize

STDAPI_(BOOL) OleUIInitialize(HINSTANCE hInstance, HINSTANCE hPrevInst);
STDAPI_(BOOL) OleUIUninitialize(void);

#if !defined( SZCLASSICONBOX )
#define SZCLASSICONBOX  "ole2uiIBCls"
#endif

#if !defined( SZCLASSRESULTIMAGE )
#define SZCLASSRESULTIMAGE  "ole2uiRICls"
#endif

// object count, used to support DllCanUnloadNow and OleUICanUnloadNow
extern DWORD g_dwObjectCount;

STDAPI OleUICanUnloadNow(void);
STDAPI OleUILockLibrary(BOOL fLock);


//Dialog Identifiers as passed in Help messages to identify the source.
#define IDD_INSERTOBJECT        32248
#define IDD_CHANGEICON          32249
#define IDD_CONVERT             32250
#define IDD_PASTESPECIAL        32251
#define IDD_EDITLINKS           32252
#define IDD_FILEOPEN            32253
#define IDD_BUSY                32254
#define IDD_UPDATELINKS         32255
#define IDD_CANNOTUPDATELINK    32256
#define IDD_CHANGESOURCE        32257
#define IDD_INSERTFILEBROWSE    32258
#define IDD_CHANGEICONBROWSE    32259

// The following Dialogs are message dialogs used by OleUIPromptUser API
#define IDD_LINKSOURCEUNAVAILABLE   32260
#define IDD_SERVERNOTREG        32261
#define IDD_LINKTYPECHANGED     32262
#define IDD_SERVERNOTFOUND      32263
#define IDD_OUTOFMEMORY         32264

// Stringtable identifers
#define IDS_OLE2UIUNKNOWN       32300
#define IDS_OLE2UILINK          32301
#define IDS_OLE2UIOBJECT        32302
#define IDS_OLE2UIEDIT          32303
#define IDS_OLE2UICONVERT       32304
#define IDS_OLE2UIEDITLINKCMD_1VERB     32305
#define IDS_OLE2UIEDITOBJECTCMD_1VERB   32306
#define IDS_OLE2UIEDITLINKCMD_NVERB     32307
#define IDS_OLE2UIEDITOBJECTCMD_NVERB   32308
#define IDS_OLE2UIEDITNOOBJCMD  32309
// def. icon label (usu. "Document")
#define IDS_DEFICONLABEL        32310
#define IDS_OLE2UIPASTELINKEDTYPE  32311


#define IDS_FILTERS             32320
#define IDS_ICONFILTERS         32321
#define IDS_BROWSE              32322

//Resource identifiers for bitmaps
#define IDB_RESULTSEGA                  32325
#define IDB_RESULTSVGA                  32326
#define IDB_RESULTSHIRESVGA             32327


//Missing from windows.h
#ifndef PVOID
typedef VOID *PVOID;
#endif


//Hook type used in all structures.
typedef UINT (CALLBACK *LPFNOLEUIHOOK)(HWND, UINT, WPARAM, LPARAM);


//Strings for registered messages
#define SZOLEUI_MSG_HELP                "OLEUI_MSG_HELP"
#define SZOLEUI_MSG_ENDDIALOG           "OLEUI_MSG_ENDDIALOG"
#define SZOLEUI_MSG_BROWSE              "OLEUI_MSG_BROWSE"
#define SZOLEUI_MSG_CHANGEICON          "OLEUI_MSG_CHANGEICON"
#define SZOLEUI_MSG_CLOSEBUSYDIALOG     "OLEUI_MSG_CLOSEBUSYDIALOG"
#define SZOLEUI_MSG_FILEOKSTRING        "OLEUI_MSG_FILEOKSTRING"

//Standard error definitions
#define OLEUI_FALSE                     0
#define OLEUI_SUCCESS                   1     //No error, same as OLEUI_OK
#define OLEUI_OK                        1     //OK button pressed
#define OLEUI_CANCEL                    2     //Cancel button pressed

#define OLEUI_ERR_STANDARDMIN           100
#define OLEUI_ERR_STRUCTURENULL         101   //Standard field validation
#define OLEUI_ERR_STRUCTUREINVALID      102
#define OLEUI_ERR_CBSTRUCTINCORRECT     103
#define OLEUI_ERR_HWNDOWNERINVALID      104
#define OLEUI_ERR_LPSZCAPTIONINVALID    105
#define OLEUI_ERR_LPFNHOOKINVALID       106
#define OLEUI_ERR_HINSTANCEINVALID      107
#define OLEUI_ERR_LPSZTEMPLATEINVALID   108
#define OLEUI_ERR_HRESOURCEINVALID      109

#define OLEUI_ERR_FINDTEMPLATEFAILURE   110   //Initialization errors
#define OLEUI_ERR_LOADTEMPLATEFAILURE   111
#define OLEUI_ERR_DIALOGFAILURE         112
#define OLEUI_ERR_LOCALMEMALLOC         113
#define OLEUI_ERR_GLOBALMEMALLOC        114
#define OLEUI_ERR_LOADSTRING            115

#define OLEUI_ERR_STANDARDMAX           116   //Start here for specific errors.



//Help Button Identifier
#define ID_OLEUIHELP                    99

// Help button for fileopen.dlg  (need this for resizing) 1038 is pshHelp
#define IDHELP  1038

// Static text control (use this instead of -1 so things work correctly for
// localization
#define  ID_STATIC                      98

//Maximum key size we read from the RegDB.
#define OLEUI_CCHKEYMAX                 256  // make any changes to this in geticon.c too

//Maximum verb length and length of Object menu
#define OLEUI_CCHVERBMAX                32
#define OLEUI_OBJECTMENUMAX             256

//Maximum MS-DOS pathname.
#define OLEUI_CCHPATHMAX                256 // make any changes to this in geticon.c too
#define OLEUI_CCHFILEMAX                13

//Icon label length
#define OLEUI_CCHLABELMAX               40  // make any changes to this in geticon.c too

//Length of the CLSID string
#define OLEUI_CCHCLSIDSTRING            39


/*
 * What follows here are first function prototypes for general utility
 * functions, then sections laid out by dialog.  Each dialog section
 * defines the dialog structure, the API prototype, flags for the dwFlags
 * field, the dialog-specific error values, and dialog control IDs (for
 * hooks and custom templates.
 */


//Miscellaneous utility functions.
STDAPI_(BOOL) OleUIAddVerbMenu(LPOLEOBJECT lpOleObj,
							 LPSTR lpszShortType,
							 HMENU hMenu,
							 UINT uPos,
							 UINT uIDVerbMin,
							 UINT uIDVerbMax,
							 BOOL bAddConvert,
							 UINT idConvert,
							 HMENU FAR *lphMenu);

//Metafile utility functions
STDAPI_(HGLOBAL) OleUIMetafilePictFromIconAndLabel(HICON, LPSTR, LPSTR, UINT);
STDAPI_(void)    OleUIMetafilePictIconFree(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictIconDraw(HDC, LPRECT, HGLOBAL, BOOL);
STDAPI_(UINT)    OleUIMetafilePictExtractLabel(HGLOBAL, LPSTR, UINT, LPDWORD);
STDAPI_(HICON)   OleUIMetafilePictExtractIcon(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictExtractIconSource(HGLOBAL,LPSTR,UINT FAR *);





/*************************************************************************
** INSERT OBJECT DIALOG
*************************************************************************/


typedef struct tagOLEUIINSERTOBJECT
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUIINSERTOBJECT.  All are IN-OUT unless otherwise spec.
	CLSID           clsid;            //Return space for class ID
	LPSTR           lpszFile;         //Filename for inserts or links
	UINT            cchFile;          //Size of lpszFile buffer: OLEUI_CCHPATHMAX
	UINT            cClsidExclude;    //IN only:  CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;   //List of CLSIDs to exclude from listing.

	//Specific to create objects if flags say so
	IID             iid;              //Requested interface on creation.
	DWORD           oleRender;        //Rendering option
	LPFORMATETC     lpFormatEtc;      //Desired format
	LPOLECLIENTSITE lpIOleClientSite; //Site to be use for the object.
	LPSTORAGE       lpIStorage;       //Storage used for the object
	LPVOID FAR     *ppvObj;           //Where the object is returned.
	SCODE           sc;               //Result of creation calls.
	HGLOBAL         hMetaPict;        //OUT: METAFILEPICT containing iconic aspect.
									  //IFF we couldn't stuff it in the cache.
	} OLEUIINSERTOBJECT, *POLEUIINSERTOBJECT, FAR *LPOLEUIINSERTOBJECT;

//API prototype
STDAPI_(UINT) OleUIInsertObject(LPOLEUIINSERTOBJECT);


//Insert Object flags
#define IOF_SHOWHELP                0x00000001L
#define IOF_SELECTCREATENEW         0x00000002L
#define IOF_SELECTCREATEFROMFILE    0x00000004L
#define IOF_CHECKLINK               0x00000008L
#define IOF_CHECKDISPLAYASICON      0x00000010L
#define IOF_CREATENEWOBJECT         0x00000020L
#define IOF_CREATEFILEOBJECT        0x00000040L
#define IOF_CREATELINKOBJECT        0x00000080L
#define IOF_DISABLELINK             0x00000100L
#define IOF_VERIFYSERVERSEXIST      0x00000200L
#define IOF_DISABLEDISPLAYASICON    0x00000400L


//Insert Object specific error codes
#define OLEUI_IOERR_LPSZFILEINVALID         (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_LPSZLABELINVALID        (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_HICONINVALID            (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_IOERR_LPFORMATETCINVALID      (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_IOERR_PPVOBJINVALID           (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_IOERR_LPIOLECLIENTSITEINVALID (OLEUI_ERR_STANDARDMAX+5)
#define OLEUI_IOERR_LPISTORAGEINVALID       (OLEUI_ERR_STANDARDMAX+6)
#define OLEUI_IOERR_SCODEHASERROR           (OLEUI_ERR_STANDARDMAX+7)
#define OLEUI_IOERR_LPCLSIDEXCLUDEINVALID   (OLEUI_ERR_STANDARDMAX+8)
#define OLEUI_IOERR_CCHFILEINVALID          (OLEUI_ERR_STANDARDMAX+9)


//Insert Object Dialog identifiers
#define ID_IO_CREATENEW                 2100
#define ID_IO_CREATEFROMFILE            2101
#define ID_IO_LINKFILE                  2102
#define ID_IO_OBJECTTYPELIST            2103
#define ID_IO_DISPLAYASICON             2104
#define ID_IO_CHANGEICON                2105
#define ID_IO_FILE                      2106
#define ID_IO_FILEDISPLAY               2107
#define ID_IO_RESULTIMAGE               2108
#define ID_IO_RESULTTEXT                2109
#define ID_IO_ICONDISPLAY               2110
#define ID_IO_OBJECTTYPETEXT            2111
#define ID_IO_FILETEXT                  2112
#define ID_IO_FILETYPE                  2113

// Strings in OLE2UI resources
#define IDS_IORESULTNEW                 32400
#define IDS_IORESULTNEWICON             32401
#define IDS_IORESULTFROMFILE1           32402
#define IDS_IORESULTFROMFILE2           32403
#define IDS_IORESULTFROMFILEICON2       32404
#define IDS_IORESULTLINKFILE1           32405
#define IDS_IORESULTLINKFILE2           32406
#define IDS_IORESULTLINKFILEICON1       32407
#define IDS_IORESULTLINKFILEICON2       32408

/*************************************************************************
** PASTE SPECIAL DIALOG
*************************************************************************/

// Maximum number of link types
#define     PS_MAXLINKTYPES  8

//NOTE: OLEUIPASTEENTRY and OLEUIPASTEFLAG structs are defined in OLESTD.H

typedef struct tagOLEUIPASTESPECIAL
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUIPASTESPECIAL.

	//IN  fields
	LPDATAOBJECT    lpSrcDataObj;       //Source IDataObject* (on the
										// clipboard) for data to paste

	LPOLEUIPASTEENTRY arrPasteEntries;  //OLEUIPASTEENTRY array which
										// specifies acceptable formats. See
										// OLEUIPASTEENTRY for more info.
	int             cPasteEntries;      //No. of OLEUIPASTEENTRY array entries

	UINT        FAR *arrLinkTypes;      //List of link types that are
										// acceptable. Link types are referred
										// to using OLEUIPASTEFLAGS in
										// arrPasteEntries
	int             cLinkTypes;         //Number of link types
	UINT            cClsidExclude;      //Number of CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;     //List of CLSIDs to exclude from list.

	//OUT fields
	int             nSelectedIndex;     //Index of arrPasteEntries[] that the
										// user selected
	BOOL            fLink;              //Indicates if Paste or Paste Link was
										// selected by the user
	HGLOBAL         hMetaPict;          //Handle to Metafile containing icon
										// and icon title selected by the user
										// Use the Metafile utility functions
										// defined in this header to
										// manipulate hMetaPict
	SIZEL           sizel;              // size of object/link in its source
										//  if the display aspect chosen by
										//  the user matches the aspect
										//  displayed in the source. if
										//  different aspect is chosen then
										//  sizel.cx=sizel.cy=0 is returned.
										//  sizel displayed in source is
										//  retrieved from the
										//  ObjectDescriptor if fLink is FALSE
										//  LinkSrcDescriptor if fLink is TRUE
	} OLEUIPASTESPECIAL, *POLEUIPASTESPECIAL, FAR *LPOLEUIPASTESPECIAL;


//API to bring up PasteSpecial dialog
STDAPI_(UINT) OleUIPasteSpecial(LPOLEUIPASTESPECIAL);


//Paste Special flags
// Show Help button. IN flag.
#define PSF_SHOWHELP                0x00000001L

//Select Paste radio button at dialog startup. This is the default if
// PSF_SELECTPASTE or PSF_SELECTPASTELINK are not specified. Also specifies
// state of button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTE             0x00000002L

//Select PasteLink radio button at dialog startup. Also specifies state of
// button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTELINK         0x00000004L

//Specfies if DisplayAsIcon button was checked on dialog termination. OUT flag
#define PSF_CHECKDISPLAYASICON      0x00000008L
#define PSF_DISABLEDISPLAYASICON    0x00000010L


//Paste Special specific error codes
#define OLEUI_IOERR_SRCDATAOBJECTINVALID      (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_ARRPASTEENTRIESINVALID    (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_ARRLINKTYPESINVALID       (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_PSERR_CLIPBOARDCHANGED          (OLEUI_ERR_STANDARDMAX+3)

//Paste Special Dialog identifiers
#define ID_PS_PASTE                    500
#define ID_PS_PASTELINK                501
#define ID_PS_SOURCETEXT               502
#define ID_PS_PASTELIST                503
#define ID_PS_PASTELINKLIST            504
#define ID_PS_DISPLAYLIST              505
#define ID_PS_DISPLAYASICON            506
#define ID_PS_ICONDISPLAY              507
#define ID_PS_CHANGEICON               508
#define ID_PS_RESULTIMAGE              509
#define ID_PS_RESULTTEXT               510
#define ID_PS_RESULTGROUP              511
#define ID_PS_STXSOURCE                512
#define ID_PS_STXAS                    513

// Paste Special String IDs
#define IDS_PSPASTEDATA                32410
#define IDS_PSPASTEOBJECT              32411
#define IDS_PSPASTEOBJECTASICON        32412
#define IDS_PSPASTELINKDATA            32413
#define IDS_PSPASTELINKOBJECT          32414
#define IDS_PSPASTELINKOBJECTASICON    32415
#define IDS_PSNONOLE                   32416
#define IDS_PSUNKNOWNTYPE              32417
#define IDS_PSUNKNOWNSRC               32418
#define IDS_PSUNKNOWNAPP               32419


/*************************************************************************
** EDIT LINKS DIALOG
*************************************************************************/



/* IOleUILinkContainer Interface
** -----------------------------
**    This interface must be implemented by container applications that
**    want to use the EditLinks dialog. the EditLinks dialog calls back
**    to the container app to perform the OLE functions to manipulate
**    the links within the container.
*/

#define LPOLEUILINKCONTAINER     IOleUILinkContainer FAR*

#undef  INTERFACE
#define INTERFACE   IOleUILinkContainer

DECLARE_INTERFACE_(IOleUILinkContainer, IUnknown)
{
	//*** IUnknown methods ***/
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink) PURE;
	STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD dwUpdateOpt) PURE;
	STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD FAR* lpdwUpdateOpt) PURE;
	STDMETHOD(SetLinkSource) (THIS_
			DWORD       dwLink,
			LPSTR       lpszDisplayName,
			ULONG       lenFileName,
			ULONG FAR*  pchEaten,
			BOOL        fValidateSource) PURE;
	STDMETHOD(GetLinkSource) (THIS_
			DWORD       dwLink,
			LPSTR FAR*  lplpszDisplayName,
			ULONG FAR*  lplenFileName,
			LPSTR FAR*  lplpszFullLinkType,
			LPSTR FAR*  lplpszShortLinkType,
			BOOL FAR*   lpfSourceAvailable,
			BOOL FAR*   lpfIsSelected) PURE;
	STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink) PURE;
	STDMETHOD(UpdateLink) (THIS_
			DWORD dwLink,
			BOOL fErrorMessage,
			BOOL fErrorAction) PURE;
	STDMETHOD(CancelLink) (THIS_ DWORD dwLink) PURE;
};


typedef struct tagOLEUIEDITLINKS
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUI<STRUCT>.  All are IN-OUT unless otherwise spec.

	LPOLEUILINKCONTAINER lpOleUILinkContainer;  //IN: Interface to manipulate
												//links in the container
	} OLEUIEDITLINKS, *POLEUIEDITLINKS, FAR *LPOLEUIEDITLINKS;


//API Prototype
STDAPI_(UINT) OleUIEditLinks(LPOLEUIEDITLINKS);


// Edit Links flags
#define ELF_SHOWHELP                0x00000001L
#define ELF_DISABLEUPDATENOW        0x00000002L
#define ELF_DISABLEOPENSOURCE       0x00000004L
#define ELF_DISABLECHANGESOURCE     0x00000008L
#define ELF_DISABLECANCELLINK       0x00000010L

// Edit Links Dialog identifiers
#define ID_EL_CHANGESOURCE             201
#define ID_EL_AUTOMATIC                202
#define ID_EL_CLOSE                    208
#define ID_EL_CANCELLINK               209
#define ID_EL_UPDATENOW                210
#define ID_EL_OPENSOURCE               211
#define ID_EL_MANUAL                   212
#define ID_EL_LINKSOURCE               216
#define ID_EL_LINKTYPE                 217
#define ID_EL_UPDATE                   218
#define ID_EL_NULL                     -1
#define ID_EL_LINKSLISTBOX             206
#define ID_EL_COL1                     220
#define ID_EL_COL2                     221
#define ID_EL_COL3                     222



/*************************************************************************
** CHANGE ICON DIALOG
*************************************************************************/

typedef struct tagOLEUICHANGEICON
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUICHANGEICON.  All are IN-OUT unless otherwise spec.
	HGLOBAL         hMetaPict;      //Current and final image.  Source of the
									//icon is embedded in the metafile itself.
	CLSID           clsid;          //IN only: class used to get Default icon
	char            szIconExe[OLEUI_CCHPATHMAX];
	int             cchIconExe;
	} OLEUICHANGEICON, *POLEUICHANGEICON, FAR *LPOLEUICHANGEICON;


//API prototype
STDAPI_(UINT) OleUIChangeIcon(LPOLEUICHANGEICON);


//Change Icon flags
#define CIF_SHOWHELP                0x00000001L
#define CIF_SELECTCURRENT           0x00000002L
#define CIF_SELECTDEFAULT           0x00000004L
#define CIF_SELECTFROMFILE          0x00000008L
#define CIF_USEICONEXE              0x0000000aL


//Change Icon specific error codes
#define OLEUI_CIERR_MUSTHAVECLSID           (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_CIERR_MUSTHAVECURRENTMETAFILE (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CIERR_SZICONEXEINVALID        (OLEUI_ERR_STANDARDMAX+2)


//Change Icon Dialog identifiers
#define ID_GROUP                    120
#define ID_CURRENT                  121
#define ID_CURRENTICON              122
#define ID_DEFAULT                  123
#define ID_DEFAULTICON              124
#define ID_FROMFILE                 125
#define ID_FROMFILEEDIT             126
#define ID_ICONLIST                 127
#define ID_LABEL                    128
#define ID_LABELEDIT                129
#define ID_BROWSE                   130
#define ID_RESULTICON               132
#define ID_RESULTLABEL              133

// Stringtable defines for Change Icon
#define IDS_CINOICONSINFILE         32430
#define IDS_CIINVALIDFILE           32431
#define IDS_CIFILEACCESS            32432
#define IDS_CIFILESHARE             32433
#define IDS_CIFILEOPENFAIL          32434



/*************************************************************************
** CONVERT DIALOG
*************************************************************************/

typedef struct tagOLEUICONVERT
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUICONVERT.  All are IN-OUT unless otherwise spec.
	CLSID           clsid;            //Class ID sent in to dialog: IN only
	CLSID           clsidConvertDefault;  //Class ID to use as convert default: IN only
	CLSID           clsidActivateDefault;  //Class ID to use as activate default: IN only

	CLSID           clsidNew;         //Selected Class ID: OUT only
	DWORD           dvAspect;         //IN-OUT, either DVASPECT_CONTENT or
									  //DVASPECT_ICON
	WORD            wFormat;          //Original data format
	BOOL            fIsLinkedObject;  //IN only; true if object is linked
	HGLOBAL         hMetaPict;        //IN-OUT: METAFILEPICT containing iconic aspect.
	LPSTR           lpszUserType;     //IN-OUT: user type name of original class.
									  //  We'll do lookup if it's NULL.
									  //  This gets freed on exit.
	BOOL            fObjectsIconChanged;  // OUT; TRUE if ChangeIcon was called (and not cancelled)
	LPSTR           lpszDefLabel;     //IN-OUT: default label to use for icon.
									  //  if NULL, the short user type name
									  //  will be used. if the object is a
									  //  link, the caller should pass the
									  //  DisplayName of the link source
									  //  This gets freed on exit.

	UINT            cClsidExclude;    //IN: No. of CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;   //IN: List of CLSIDs to exclude from list
	} OLEUICONVERT, *POLEUICONVERT, FAR *LPOLEUICONVERT;


//API prototype
STDAPI_(UINT) OleUIConvert(LPOLEUICONVERT);

// Determine if there is at least one class that can Convert or ActivateAs
// the given clsid.
STDAPI_(BOOL) OleUICanConvertOrActivateAs(
		REFCLSID    rClsid,
		BOOL        fIsLinkedObject,
		WORD        wFormat
);

//Convert Dialog flags

// IN only: Shows "HELP" button
#define CF_SHOWHELPBUTTON          0x00000001L

// IN only: lets you set the convert default object - the one that is
// selected as default in the convert listbox.
#define CF_SETCONVERTDEFAULT       0x00000002L


// IN only: lets you set the activate default object - the one that is
// selected as default in the activate listbox.

#define CF_SETACTIVATEDEFAULT       0x00000004L


// IN/OUT: Selects the "Convert To" radio button, is set on exit if
// this button was selected
#define CF_SELECTCONVERTTO         0x00000008L

// IN/OUT: Selects the "Activate As" radio button, is set on exit if
// this button was selected
#define CF_SELECTACTIVATEAS        0x00000010L
#define CF_DISABLEDISPLAYASICON    0x00000020L
#define CF_DISABLEACTIVATEAS       0x00000040L


//Convert specific error codes
#define OLEUI_CTERR_CLASSIDINVALID      (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CTERR_DVASPECTINVALID     (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_CTERR_CBFORMATINVALID     (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_CTERR_HMETAPICTINVALID    (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_CTERR_STRINGINVALID       (OLEUI_ERR_STANDARDMAX+5)


//Convert Dialog identifiers
#define IDCV_OBJECTTYPE             150
#define IDCV_DISPLAYASICON          152
#define IDCV_CHANGEICON             153
#define IDCV_ACTIVATELIST           154
#define IDCV_CONVERTTO              155
#define IDCV_ACTIVATEAS             156
#define IDCV_RESULTTEXT             157
#define IDCV_CONVERTLIST            158
#define IDCV_ICON                   159
#define IDCV_ICONLABEL1             160
#define IDCV_ICONLABEL2             161
#define IDCV_STXCURTYPE             162
#define IDCV_GRPRESULT              163
#define IDCV_STXCONVERTTO           164

// String IDs for Convert dialog
#define IDS_CVRESULTCONVERTLINK     32440
#define IDS_CVRESULTCONVERTTO       32441
#define IDS_CVRESULTNOCHANGE        32442
#define IDS_CVRESULTDISPLAYASICON   32443
#define IDS_CVRESULTACTIVATEAS      32444
#define IDS_CVRESULTACTIVATEDIFF    32445


/*************************************************************************
** BUSY DIALOG
*************************************************************************/

typedef struct tagOLEUIBUSY
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags ** NOTE ** this dialog has no flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUIBUSY.
	HTASK           hTask;            //IN: HTask which is blocking
	HWND FAR *      lphWndDialog;     //IN: Dialog's HWND is placed here
	} OLEUIBUSY, *POLEUIBUSY, FAR *LPOLEUIBUSY;

//API prototype
STDAPI_(UINT) OleUIBusy(LPOLEUIBUSY);

// Flags for this dialog

// IN only: Disables "Cancel" button
#define BZ_DISABLECANCELBUTTON          0x00000001L

// IN only: Disables "Switch To..." button
#define BZ_DISABLESWITCHTOBUTTON        0x00000002L

// IN only: Disables "Retry" button
#define BZ_DISABLERETRYBUTTON           0x00000004L

// IN only: Generates a "Not Responding" dialog as opposed to the
// "Busy" dialog.  The wording in the text is slightly different, and
// the "Cancel" button is grayed out if you set this flag.
#define BZ_NOTRESPONDINGDIALOG          0x00000008L

// Busy specific error/return codes
#define OLEUI_BZERR_HTASKINVALID     (OLEUI_ERR_STANDARDMAX+0)

// SWITCHTOSELECTED is returned when user hit "switch to"
#define OLEUI_BZ_SWITCHTOSELECTED    (OLEUI_ERR_STANDARDMAX+1)

// RETRYSELECTED is returned when user hit "retry"
#define OLEUI_BZ_RETRYSELECTED       (OLEUI_ERR_STANDARDMAX+2)

// CALLUNBLOCKED is returned when call has been unblocked
#define OLEUI_BZ_CALLUNBLOCKED       (OLEUI_ERR_STANDARDMAX+3)

// Busy dialog identifiers
#define IDBZ_RETRY                      600
#define IDBZ_ICON                       601
#define IDBZ_MESSAGE1                   602
#define IDBZ_SWITCHTO                   604

// Busy dialog stringtable defines
#define IDS_BZRESULTTEXTBUSY            32447
#define IDS_BZRESULTTEXTNOTRESPONDING   32448

// Links dialog stringtable defines
#define IDS_LINK_AUTO           32450
#define IDS_LINK_MANUAL         32451
#define IDS_LINK_UNKNOWN        32452
#define IDS_LINKS               32453
#define IDS_FAILED              32454
#define IDS_CHANGESOURCE        32455
#define IDS_INVALIDSOURCE       32456
#define IDS_ERR_GETLINKSOURCE   32457
#define IDS_ERR_GETLINKUPDATEOPTIONS    32458
#define IDS_ERR_ADDSTRING       32459
#define IDS_CHANGEADDITIONALLINKS   32460
#define IDS_CLOSE               32461


/*************************************************************************
** PROMPT USER DIALOGS
*************************************************************************/
#define ID_PU_LINKS             900
#define ID_PU_TEXT              901
#define ID_PU_CONVERT           902
#define ID_PU_BROWSE            904
#define ID_PU_METER             905
#define ID_PU_PERCENT           906
#define ID_PU_STOP              907

// used for -1 ids in dialogs:
#define ID_DUMMY    999

/* inside ole2ui.c */
#ifdef __cplusplus
extern "C"
#endif
int EXPORT FAR CDECL OleUIPromptUser(WORD nTemplate, HWND hwndParent, ...);

#define UPDATELINKS_STARTDELAY  2000    // Delay before 1st link updates
										//  to give the user a chance to
										//  dismiss the dialog before any
										//  links update.

STDAPI_(BOOL) OleUIUpdateLinks(
		LPOLEUILINKCONTAINER lpOleUILinkCntr,
		HWND hwndParent,
		LPSTR lpszTitle,
		int cLinks);


/*************************************************************************
** OLE OBJECT FEEDBACK EFFECTS
*************************************************************************/

#define OLEUI_HANDLES_USEINVERSE    0x00000001L
#define OLEUI_HANDLES_NOBORDER      0x00000002L
#define OLEUI_HANDLES_INSIDE        0x00000004L
#define OLEUI_HANDLES_OUTSIDE       0x00000008L


#define OLEUI_SHADE_FULLRECT        1
#define OLEUI_SHADE_BORDERIN        2
#define OLEUI_SHADE_BORDEROUT       3

/* objfdbk.c function prototypes */
STDAPI_(void) OleUIDrawHandles(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cSize, BOOL fDraw);
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth);
STDAPI_(void) OleUIShowObject(LPCRECT lprc, HDC hdc, BOOL fIsLink);


/*************************************************************************
** Hatch window definitions and prototypes                              **
*************************************************************************/
#define DEFAULT_HATCHBORDER_WIDTH   4

STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst);
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst);
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch);
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lpHatchRect);
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect);
STDAPI_(void) SetHatchWindowSize(
		HWND        hWndHatch,
		LPRECT      lprcIPObjRect,
		LPRECT      lprcClipRect,
		LPPOINT     lpptOffset
);



/*************************************************************************
** VERSION VERIFICATION INFORMATION
*************************************************************************/

// The following magic number is used to verify that the resources we bind
// to our EXE are the same "version" as the LIB (or DLL) file which
// contains these routines.  This is not the same as the Version information
// resource that we place in OLE2UI.RC, this is a special ID that we will
// have compiled in to our EXE.  Upon initialization of OLE2UI, we will
// look in our resources for an RCDATA called "VERIFICATION" (see OLE2UI.RC),
// and make sure that the magic number there equals the magic number below.

#define OLEUI_VERSION_MAGIC 0x4D42

#endif  //_OLE2UI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpleDoc
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

#include "idt.h"
#include "ids.h"

class CSimpleSite;
class CSimpleApp;

class CSimpleDoc : public IUnknown
{
public:
	int             m_nCount;           // reference count
	LPSTORAGE       m_lpStorage;        // IStorage* pointer for Doc
	BOOL            m_fModifiedMenu;    // is object's verb menu on menu

	// Drag/Drop related fields
	BOOL            m_fRegDragDrop;     // is doc registered as drop target?
	BOOL            m_fLocalDrag;       // is doc source of the drag
	BOOL            m_fLocalDrop;       // was doc target of the drop
	BOOL            m_fCanDropCopy;     // is Drag/Drop copy/move possible?
	BOOL            m_fCanDropLink;     // is Drag/Drop link possible?
	BOOL            m_fDragLeave;       // has drag left
	BOOL            m_fPendingDrag;     // LButtonDown--possible drag pending
	POINT           m_ptButDown;        // LButtonDown coordinates

	CSimpleSite FAR * m_lpSite;
	CSimpleApp FAR * m_lpApp;

	HWND m_hDocWnd;

	CDropTarget m_DropTarget;
	CDropSource m_DropSource;

	static CSimpleDoc FAR* Create(CSimpleApp FAR *lpApp, LPRECT lpRect,
			HWND hWnd);

	void Close(void);

	CSimpleDoc();
	CSimpleDoc(CSimpleApp FAR *lpApp, HWND hWnd);
	~CSimpleDoc();

	// IUnknown Interface
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	void InsertObject(void);
	void DisableInsertObject(void);
	long lResizeDoc(LPRECT lpRect);
	long lAddVerbs(void);
	void PaintDoc(HDC hDC);

	// Drag/Drop and clipboard support methods
	void CopyObjectToClip(void);
	BOOL QueryDrag(POINT pt);
	DWORD DoDragDrop(void);
	void Scroll(DWORD dwScrollDir) { /*...scroll Doc here...*/ }
};

#endif  // _DOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpleDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "idt.h"
#include "dxferobj.h"

//**********************************************************************
//
// CSimpleDoc::Create
//
// Purpose:
//
//      Creation for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      RegisterDragDrop            OLE API
//      CoLockObjectExternal        OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpleDoc FAR * CSimpleDoc::Create(CSimpleApp FAR *lpApp, LPRECT lpRect,HWND hWnd)
{
	CSimpleDoc FAR * lpTemp = new CSimpleDoc(lpApp, hWnd);

	if (!lpTemp)
		return NULL;

	// create storage for the doc.
	HRESULT hErr = StgCreateDocfile (
		NULL,       // generate temp name
		STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
		0, &lpTemp->m_lpStorage);

	if (hErr != NOERROR)
		goto error;

	// create the document Window
	lpTemp->m_hDocWnd = CreateWindow(
			"SimpDndDocWClass",
			NULL,
			WS_CHILD | WS_CLIPCHILDREN,
			lpRect->left,
			lpRect->top,
			lpRect->right,
			lpRect->bottom,
			hWnd,
			NULL,
			lpApp->m_hInst,
			NULL);

	if (!lpTemp->m_hDocWnd)
		goto error;

	ShowWindow(lpTemp->m_hDocWnd, SW_SHOWNORMAL);  // Show the window
	UpdateWindow(lpTemp->m_hDocWnd);               // Sends WM_PAINT message

	// Ensable InsertObject menu choice
	EnableMenuItem( lpApp->m_hEditMenu, 1, MF_BYPOSITION | MF_ENABLED);
	// Disable Copy menu choice
	EnableMenuItem( lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_DISABLED | MF_GRAYED);

	// It is *REQUIRED* to hold a strong LOCK on the object that is
	// registered as drop target. this call will result in at least one
	// ref count held on our document. later in CSimpleDoc::Close we will
	// unlock this lock which will make our document's ref count go to 0.
	// when the document's ref count goes to 0, it will be deleted.
	CoLockObjectExternal (&lpTemp->m_DropTarget, TRUE, 0);

	// Register our window as a DropTarget
	RegisterDragDrop(lpTemp->m_hDocWnd, &lpTemp->m_DropTarget);
	lpTemp->m_fRegDragDrop = TRUE;

	return (lpTemp);

error:
	delete (lpTemp);
	return NULL;

}

//**********************************************************************
//
// CSimpleDoc::Close
//
// Purpose:
//
//      Close CSimpleDoc object.
//      when the document's reference count goes to 0, the document
//      will be destroyed.
//
// Parameters:
//
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      CoLockObjectExternal        OLE API
//      OleFlushClipboard           OLE API
//      ShowWindow                  Windows API
//
// Comments:
//
//********************************************************************

void CSimpleDoc::Close(void)
{
	TestDebugOut("In CSimpleDoc::Close\r\n");

	ShowWindow(m_hDocWnd, SW_HIDE);  // Hide the window

	// Remove our data transfer object from clipboard if it is there.
	//  this will leave HGLOBAL based data behind on the clipboard
	//  including OLE 1.0 compatibility formats.
	OleFlushClipboard();

	// Revoke our window as a DropTarget
	if (m_fRegDragDrop) {
		RevokeDragDrop(m_hDocWnd);
		m_fRegDragDrop = FALSE;
	}

	// Close the OLE object in our document
	if (m_lpSite)
		m_lpSite->CloseOleObject();

	// Unlock the lock added in CSimpleDoc::Create. this will make
	// the document's ref count go to 0, and the document will be deleted.
	CoLockObjectExternal (&m_DropTarget, FALSE, TRUE);
}

//**********************************************************************
//
// CSimpleDoc::CSimpleDoc
//
// Purpose:
//
//      Constructor for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
// Comments:
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
								// tells us that we are passing this in
								// an initializer, before "this" is through
								// initializing.  This is ok, because
								// we just store the ptr in the other
								// constructor

CSimpleDoc::CSimpleDoc(CSimpleApp FAR * lpApp,HWND hWnd)
		: m_DropTarget(this), m_DropSource(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
	TestDebugOut("In CSimpleDoc's Constructor\r\n");
	m_lpApp = lpApp;
	m_lpSite = NULL;
	m_nCount = 0;
	// set up menu handles
	lpApp->m_hMainMenu = GetMenu(hWnd);
	lpApp->m_hFileMenu = GetSubMenu(lpApp->m_hMainMenu, 0);
	lpApp->m_hEditMenu = GetSubMenu(lpApp->m_hMainMenu, 1);
	lpApp->m_hHelpMenu = GetSubMenu(lpApp->m_hMainMenu, 2);
	lpApp->m_hCascadeMenu = NULL;
	m_fModifiedMenu = FALSE;

	// drag/drop related stuff
	m_fRegDragDrop = FALSE;       // is doc registered as drop target?
	m_fLocalDrag = FALSE;         // is doc source of the drag
	m_fLocalDrop = FALSE;         // was doc target of the drop
	m_fCanDropCopy = FALSE;       // is Drag/Drop copy/move possible?
	m_fCanDropLink = FALSE;       // is Drag/Drop link possible?
	m_fDragLeave = FALSE;         // has drag left
	m_fPendingDrag = FALSE;       // LButtonDown--possible drag pending
	m_ptButDown.x = m_ptButDown.y = 0; // LButtonDown coordinates
}

//**********************************************************************
//
// CSimpleDoc::~CSimpleDoc
//
// Purpose:
//
//      Destructor for CSimpleDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Release        SITE.CPP
//      IStorage::Release           OLE API
//
// Comments:
//
//********************************************************************

CSimpleDoc::~CSimpleDoc()
{
	TestDebugOut("In CSimpleDoc's Destructor\r\n");

	// Release all pointers we hold to the OLE object. also release
	// the ref count added in CSimpleSite::Create. this will make
	// the Site's ref count go to 0, and the Site will be deleted.
	if (m_lpSite) {
		m_lpSite->UnloadOleObject();
		m_lpSite->Release();
		m_lpSite = NULL;
	}

	// Release the Storage
	if (m_lpStorage) {
		m_lpStorage->Release();
		m_lpStorage = NULL;
	}

	// if the edit menu was modified, remove the menu item and
	// destroy the popup if it exists
	if (m_fModifiedMenu)
		{
		int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);
		RemoveMenu(m_lpApp->m_hEditMenu, nCount-1, MF_BYPOSITION);
		if (m_lpApp->m_hCascadeMenu)
			DestroyMenu(m_lpApp->m_hCascadeMenu);
		}

	DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpleDoc::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CSimpleDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CSimpleDoc::QueryInterface\r\n");

	*ppvObj = NULL;     // must set out pointer parameters to NULL

	// looking for IUnknown
	if ( riid == IID_IUnknown)
		{
		AddRef();
		*ppvObj = this;
		return ResultFromScode(S_OK);
		}

	// looking for IDropTarget
	if ( riid == IID_IDropTarget)
		{
		m_DropTarget.AddRef();
		*ppvObj=&m_DropTarget;
		return ResultFromScode(S_OK);
		}

	// looking for IDropSource
	if ( riid == IID_IDropSource)
		{
		m_DropSource.AddRef();
		*ppvObj=&m_DropSource;
		return ResultFromScode(S_OK);
		}

	// Not a supported interface
	return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleDoc::AddRef
//
// Purpose:
//
//      Increments the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::AddRef          APP.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::AddRef()
{
	TestDebugOut("In CSimpleDoc::AddRef\r\n");
	return ++m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::Release
//
// Purpose:
//
//      Decrements the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::Release()
{
	TestDebugOut("In CSimpleDoc::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
		return 0;
	}
	return m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::InsertObject
//
// Purpose:
//
//      Inserts a new object to this document
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CSimpleSite    SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      memset                      C Runtime
//      OleUIInsertObject           OUTLUI function
//      CSimpleDoc::DisableInsertObject DOC.CPP
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::InsertObject()
{
	OLEUIINSERTOBJECT io;
	UINT iret;
	char szFile[OLEUI_CCHPATHMAX];

	m_lpSite = CSimpleSite::Create(this);

	// clear the structure
	_fmemset(&io, 0, sizeof(OLEUIINSERTOBJECT));

	// fill the structure
	io.cbStruct = sizeof(OLEUIINSERTOBJECT);
	io.dwFlags = IOF_SELECTCREATENEW |
					IOF_DISABLELINK | IOF_DISABLEDISPLAYASICON |
					IOF_CREATENEWOBJECT | IOF_CREATEFILEOBJECT;
	io.hWndOwner = m_hDocWnd;
	io.lpszCaption = (LPSTR)"Insert Object";
	io.iid = IID_IOleObject;
	io.oleRender = OLERENDER_DRAW;
	io.lpIOleClientSite = &m_lpSite->m_OleClientSite;
	io.lpIStorage = m_lpSite->m_lpObjStorage;
	io.ppvObj = (LPVOID FAR *)&m_lpSite->m_lpOleObject;
	io.lpszFile = szFile;
	io.cchFile = sizeof(szFile);
	_fmemset((LPSTR)szFile, 0, sizeof(szFile));

	// call OUTLUI to do all the hard work
	iret = OleUIInsertObject(&io);

	if (iret == OLEUI_OK)
		{
		m_lpSite->InitObject((BOOL)(io.dwFlags & IOF_SELECTCREATENEW));
		// disable Insert Object menu item
		DisableInsertObject();
		}
	else
		{
		m_lpSite->Release();
		m_lpSite = NULL;
		m_lpStorage->Revert();
		}

}

//**********************************************************************
//
// CSimpleDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      MoveWindow                              Windows API
//
// Comments:
//
//********************************************************************

long CSimpleDoc::lResizeDoc(LPRECT lpRect)
{
	MoveWindow(
			m_hDocWnd,
			lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, TRUE);

	return NULL;
}

//**********************************************************************
//
// CSimpleDoc::lAddVerbs
//
// Purpose:
//
//      Adds the objects verbs to the edit menu.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      OleUIAddVerbMenu            OUTLUI function
//
// Comments:
//
//********************************************************************

long CSimpleDoc::lAddVerbs(void)
{
	// m_fModifiedMenu is TRUE if the menu has already been modified
	// once.  Since we only support one obect every time the application
	// is run, then once the menu is modified, it doesn't have
	// to be done again.
	if (m_lpSite && !m_fModifiedMenu)
		{
		int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);

		OleUIAddVerbMenu ( m_lpSite->m_lpOleObject,
						   NULL,
						   m_lpApp->m_hEditMenu,
						   nCount + 1,
						   IDM_VERB0,
						   0,           // no maximum verb IDM enforced
						   FALSE,
						   1,
						   &m_lpApp->m_hCascadeMenu);

		m_fModifiedMenu = TRUE;
		}
	return (NULL);
}

//**********************************************************************
//
// CSimpleDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::PaintObj       SITE.CPP
//
// Comments:
//
//********************************************************************

void CSimpleDoc::PaintDoc (HDC hDC)
{
	// if we supported multiple objects, then we would enumerate
	// the objects and call paint on each of them from here.

	if (m_lpSite)
		m_lpSite->PaintObj(hDC);

}

//**********************************************************************
//
// CSimpleDoc::DisableInsertObject
//
// Purpose:
//
//      Disable the ability to insert a new object in this document.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another. Also we revoke ourself as
//      a potential drop target.
//
//********************************************************************

void CSimpleDoc::DisableInsertObject(void)
{
	// Disable InsertObject menu choice
	EnableMenuItem( m_lpApp->m_hEditMenu, 1, MF_BYPOSITION | MF_DISABLED | MF_GRAYED);
	// Enable Copy menu choice
	EnableMenuItem( m_lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_ENABLED);

	// We no longer accept dropping of objects
	if (m_fRegDragDrop) {
		RevokeDragDrop(m_hDocWnd);
		m_fRegDragDrop = FALSE;
	}
}

//**********************************************************************
//
// CSimpleDoc::CopyObjectToClip
//
// Purpose:
//
//      Copy the embedded OLE object to the clipboard
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CDataXferObj::Create        DXFEROBJ.CPP
//      CDataXferObj::QueryInterface DXFEROBJ.CPP
//      OleSetClipboard             OLE API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Copy menu choice is enabled.
//
//********************************************************************

void CSimpleDoc::CopyObjectToClip(void)
{
	LPDATAOBJECT lpDataObj;

	// Create a data transfer object by cloning the existing OLE object
	CDataXferObj FAR* pDataXferObj = CDataXferObj::Create(m_lpSite,NULL);
	if (! pDataXferObj) {
		MessageBox(NULL,"Out-of-memory","SimpDnD",MB_SYSTEMMODAL|MB_ICONHAND);
		return;
	}
	// initially obj is created with 0 refcnt. this QI will make it go to 1.
	pDataXferObj->QueryInterface(IID_IDataObject, (LPVOID FAR*)&lpDataObj);

	// put out data transfer object on the clipboard. this API will AddRef.
	OleSetClipboard(lpDataObj);

	// Give ownership of data transfer object to clipboard
	pDataXferObj->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\dxferobj.cpp ===
//**********************************************************************
// File name: DXFEROBJ.CPP
//
//      Implementation file for CDataXferObj, data transfer object
//      implementation of IDataObject interface.
//
// Functions:
//
//      See DXFEROBJ.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "enumfetc.h"
#include <assert.h>
#include "dxferobj.h"
#include "site.h"

CLIPFORMAT g_cfEmbeddedObject = RegisterClipboardFormat(CF_EMBEDDEDOBJECT);
CLIPFORMAT g_cfObjectDescriptor =RegisterClipboardFormat(CF_OBJECTDESCRIPTOR);

// List of formats offered by our data transfer object via EnumFormatEtc
static FORMATETC s_arrGetFmtEtcs[] =
{
        { g_cfEmbeddedObject, NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},
        { g_cfObjectDescriptor, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        { CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT}
};


//**********************************************************************
//
// CDataXferObj::Create
//
// Purpose:
//
//      Creation routine for CDataXferObj
//
// Parameters:
//
//      CSimpleSite FAR *lpSite   - Pointer to source CSimpleSite
//                                  this is the container site of the
//                                  source OLE object to be transfered
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      assert                      C Runtime
//
// Comments:
//      reference count of CDataXferObj will be 0 on return.
//
//********************************************************************

CDataXferObj FAR * CDataXferObj::Create(
                CSimpleSite FAR *lpSite,
                POINTL FAR* pPointl
)
{
        CDataXferObj FAR * lpTemp = new CDataXferObj();

        if (!lpTemp)
                return NULL;

        // create a sub-storage for the object
        HRESULT hErr = StgCreateDocfile(
                                NULL,
                                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE |
                                        STGM_DELETEONRELEASE,
                                0,
                                &lpTemp->m_lpObjStorage);

        assert(hErr == NOERROR);

        if (hErr != NOERROR)
                {
                delete lpTemp;
                return NULL;
                }

        // Clone the source object
        if (lpSite->m_lpOleObject) {
                // Object is loaded; ask the object to save into the new storage
                LPPERSISTSTORAGE pPersistStorage;

                lpSite->m_lpOleObject->QueryInterface(IID_IPersistStorage,
                                (LPVOID FAR*)&pPersistStorage);
                assert(pPersistStorage);
                OleSave(pPersistStorage, lpTemp->m_lpObjStorage, FALSE);

                // pass NULL so that object application won't forget the real stg
                pPersistStorage->SaveCompleted(NULL);
                pPersistStorage->Release();
        } else {
                // Object not loaded so use cheaper IStorage CopyTo operation
                lpSite->m_lpObjStorage->CopyTo(0, NULL, NULL, lpTemp->m_lpObjStorage);
        }

        OleLoad(lpTemp->m_lpObjStorage, IID_IOleObject, NULL,
                        (LPVOID FAR*)&lpTemp->m_lpOleObject);
        assert(lpTemp->m_lpOleObject);

        lpTemp->m_sizel = lpSite->m_sizel;
        if (pPointl)
                lpTemp->m_pointl = *pPointl;
        else
                lpTemp->m_pointl.x = lpTemp->m_pointl.y = 0;
        return lpTemp;
}

//**********************************************************************
//
// CDataXferObj::CDataXferObj
//
// Purpose:
//
//      Constructor for CDataXferObj
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************

CDataXferObj::CDataXferObj (void)
{
        // clear the reference count
        m_nCount = 0;

        m_lpObjStorage = NULL;
        m_lpOleObject = NULL;
        m_sizel.cx = m_sizel.cy = 0;
        m_pointl.x = m_pointl.y = 0;
}

//**********************************************************************
//
// CDataXferObj::~CDataXferObj
//
// Purpose:
//
//      Destructor for CDataXferObj
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

CDataXferObj::~CDataXferObj ()
{
        TestDebugOut ("In CDataXferObj's Destructor \r\n");

        if (m_lpOleObject)
           {
           m_lpOleObject->Release();
           m_lpOleObject = NULL;

           // Release the storage for this object
           m_lpObjStorage->Release();
           m_lpObjStorage = NULL;
           }
}



//**********************************************************************
//
// CDataXferObj::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the CDataXferObj instance
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CDataXferObj::AddRef        DXFEROBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CDataXferObj::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CDataXferObj::QueryInterface\r\n");

        if ( riid == IID_IUnknown || riid == IID_IDataObject)
                {
                AddRef();
                *ppvObj = this;
                return NOERROR;
                }

        // unknown interface requested
        *ppvObj = NULL;     // must set out pointer parameters to NULL
        return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CDataXferObj::AddRef
//
// Purpose:
//
//      Increments the reference count of the CDataXferObj instance
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataXferObj::AddRef()
{
        TestDebugOut("In CDataXferObj::AddRef\r\n");

        return ++m_nCount;
}

//**********************************************************************
//
// CDataXferObj::Release
//
// Purpose:
//
//      Decrements the reference count of the CDataXferObj object
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataXferObj::Release()
{
        TestDebugOut("In CDataXferObj::Release\r\n");

        if (--m_nCount == 0) {
                delete this;
                return 0;
        }
        return m_nCount;
}


/********************************************************************
** This IDataObject implementation is used for data transfer.
**
** The following methods are NOT supported for data transfer:
**      IDataObject::SetData    -- return E_NOTIMPL
**      IDataObject::DAdvise    -- return OLE_E_ADVISENOTSUPPORTED
**                 ::DUnadvise
**                 ::EnumDAdvise
**      IDataObject::GetCanonicalFormatEtc -- return E_NOTIMPL
**                      (NOTE: must set pformatetcOut->ptd = NULL)
*********************************************************************/


//**********************************************************************
//
// CDataXferObj::QueryGetData
//
// Purpose:
//
//      Called to determine if our object supports a particular
//      FORMATETC.
//
// Parameters:
//
//      LPFORMATETC pformatetc  - Pointer to the FORMATETC being queried for.
//
// Return Value:
//
//      DV_E_FORMATETC    - The FORMATETC is not supported
//      S_OK              - The FORMATETC is supported.
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//      we support the following formats:
//          "Embedded Object"
//          "Object Descriptor"
//          CF_METAFILEPICT
//
//********************************************************************
STDMETHODIMP CDataXferObj::QueryGetData (LPFORMATETC pformatetc)
{
        SCODE sc = DV_E_FORMATETC;

        TestDebugOut("In CDataXferObj::QueryGetData\r\n");

        // check the validity of the formatetc.

        if ( (pformatetc->cfFormat == g_cfEmbeddedObject) &&
                 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetc->tymed == TYMED_ISTORAGE) )
                sc = S_OK;

        else if ( (pformatetc->cfFormat == g_cfObjectDescriptor) &&
                 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetc->tymed == TYMED_HGLOBAL) )
                sc = S_OK;

        else if ( (pformatetc->cfFormat == CF_METAFILEPICT) &&
                 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetc->tymed == TYMED_MFPICT) )
                sc = S_OK;

        return ResultFromScode(sc);
}


STDMETHODIMP CDataXferObj::EnumFormatEtc(
                DWORD dwDirection,
                LPENUMFORMATETC FAR* ppenumFormatEtc
)
{
        SCODE sc = E_NOTIMPL;

        TestDebugOut("In CDataXferObj::EnumFormatEtc\r\n");
        *ppenumFormatEtc = NULL;

        if (dwDirection == DATADIR_GET) {
                *ppenumFormatEtc = OleStdEnumFmtEtc_Create(
                                sizeof(s_arrGetFmtEtcs)/sizeof(s_arrGetFmtEtcs[0]),
                                s_arrGetFmtEtcs);
                if (*ppenumFormatEtc == NULL)
                        sc = E_OUTOFMEMORY;
                else
                        sc = S_OK;
        }
        return ResultFromScode(sc);
}


//**********************************************************************
//
// CDataXferObj::GetData
//
// Purpose:
//
//      Returns the data in the format specified in pformatetcIn.
//
// Parameters:
//
//      LPFORMATETC pformatetcIn    -   The format requested by the caller
//
//      LPSTGMEDIUM pmedium         -   The medium requested by the caller
//
// Return Value:
//
//      DV_E_FORMATETC    - Format not supported
//      S_OK                - Success
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      OleStdGetOleObjectData          OLE2UI API
//      OleStdGetMetafilePictFromOleObject OLE2UI API
//      ResultFromScode                 OLE API
//
// Comments:
//      we support GetData for the following formats:
//          "Embedded Object"
//          "Object Descriptor"
//          CF_METAFILEPICT
//
//********************************************************************

STDMETHODIMP CDataXferObj::GetData (
                LPFORMATETC pformatetcIn,
                LPSTGMEDIUM pmedium
)
{
        SCODE sc = DV_E_FORMATETC;

        TestDebugOut("In CDataXferObj::GetData\r\n");

        // we must set all out pointer parameters to NULL. */
        pmedium->tymed = TYMED_NULL;
        pmedium->pUnkForRelease = NULL;    // we transfer ownership to caller
        pmedium->hGlobal = NULL;

        // Check the FORMATETC and fill pmedium if valid.
        if ( (pformatetcIn->cfFormat == g_cfEmbeddedObject) &&
                 (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetcIn->tymed == TYMED_ISTORAGE) ) {
                 LPPERSISTSTORAGE pPersistStorage;

                 /* render CF_EMBEDDEDOBJECT by asking the object to save
                 **    into a temporary, DELETEONRELEASE IStorage allocated by us.
                 */
                 m_lpOleObject->QueryInterface(
                                 IID_IPersistStorage, (LPVOID FAR*)&pPersistStorage);
                 assert(pPersistStorage);
                 HRESULT hrErr = OleStdGetOleObjectData(
                                        pPersistStorage,
                                        pformatetcIn,
                                        pmedium,
                                        FALSE   /* fUseMemory -- (use file-base stg) */
                 );
                 pPersistStorage->Release();
                 sc = GetScode( hrErr );

        } else if ( (pformatetcIn->cfFormat == g_cfObjectDescriptor) &&
                 (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetcIn->tymed == TYMED_HGLOBAL) ) {

                 // render CF_OBJECTDESCRIPTOR data
                 pmedium->hGlobal = OleStdGetObjectDescriptorDataFromOleObject(
                                 m_lpOleObject,
                                 "Simple OLE 2.0 Container",    // string to identify source
                                 DVASPECT_CONTENT,
                                 m_pointl,
                                 (LPSIZEL)&m_sizel
                        );
                 if (! pmedium->hGlobal)
                         sc = E_OUTOFMEMORY;
                 else {
                         pmedium->tymed = TYMED_HGLOBAL;
                         sc = S_OK;
                 }

        } else if ( (pformatetcIn->cfFormat == CF_METAFILEPICT) &&
                 (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetcIn->tymed == TYMED_MFPICT) ) {

                 // render CF_METAFILEPICT by drawing the object into a metafile DC
                 pmedium->hGlobal = OleStdGetMetafilePictFromOleObject(
                                 m_lpOleObject, DVASPECT_CONTENT, NULL, pformatetcIn->ptd);
                 if (! pmedium->hGlobal)
                         sc = E_OUTOFMEMORY;
                 else {
                         pmedium->tymed = TYMED_MFPICT;
                         sc = S_OK;
                 }
        }

        return ResultFromScode( sc );
}

//**********************************************************************
//
// CDataXferObj::GetDataHere
//
// Purpose:
//
//      Called to get a data format in a caller supplied location
//
// Parameters:
//
//      LPFORMATETC pformatetc  - FORMATETC requested
//
//      LPSTGMEDIUM pmedium     - Medium to return the data
//
// Return Value:
//
//      DATA_E_FORMATETC    - We don't support the requested format
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleStdGetOleObjectData      OLE2UI API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDataXferObj::GetDataHere (
                LPFORMATETC pformatetc,
                LPSTGMEDIUM pmedium
)
{
        SCODE sc = DV_E_FORMATETC;

        TestDebugOut("In CDataXferObj::GetDataHere\r\n");

        // NOTE: pmedium is an IN parameter. we should NOT set
        //           pmedium->pUnkForRelease to NULL

        // Check the FORMATETC and fill pmedium if valid.
        if ( (pformatetc->cfFormat == g_cfEmbeddedObject) &&
                 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetc->tymed == TYMED_ISTORAGE) ) {
                 LPPERSISTSTORAGE pPersistStorage;

                 /* render CF_EMBEDDEDOBJECT by asking the object to save
                 **    into the IStorage allocated by the caller.
                 */
                 m_lpOleObject->QueryInterface(
                                 IID_IPersistStorage, (LPVOID FAR*)&pPersistStorage);
                 assert(pPersistStorage);
                 HRESULT hrErr = OleStdGetOleObjectData(
                                 pPersistStorage, pformatetc, pmedium,0 /*fUseMemory--N/A*/ );
                 pPersistStorage->Release();
                 sc = GetScode( hrErr );
        }
        return ResultFromScode( sc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpleApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>

//**********************************************************************
//
// CSimpleApp::CSimpleApp()
//
// Purpose:
//
//      Constructor for CSimpleApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//********************************************************************
CSimpleApp::CSimpleApp()
{
        TestDebugOut("In CSimpleApp's Constructor \r\n");

        // Set Ref Count
        m_nCount = 0;

        // clear members
        m_hAppWnd = NULL;
        m_hDriverWnd = NULL;
        m_hInst = NULL;
        m_lpDoc = NULL;

        // clear flags
        m_fInitialized = FALSE;
}

//**********************************************************************
//
// CSimpleApp::~CSimpleApp()
//
// Purpose:
//
//      Destructor for CSimpleApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleUninitialize             OLE API
//
// Comments:
//
//********************************************************************

CSimpleApp::~CSimpleApp()
{
        TestDebugOut("In CSimpleApp's Destructor\r\n");

        // need to uninit the library...
        if (m_fInitialized)
                OleUninitialize();
}

//**********************************************************************
//
// CSimpleApp::DestroyDocs()
//
// Purpose:
//
//      Destroys all of the open documents in the application (Only one
//      since this is an SDI app, but could easily be modified to
//      support MDI).
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************

void CSimpleApp::DestroyDocs()
{
        m_lpDoc->Close();   // we have only 1 document
}

//**********************************************************************
//
// CSimpleApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Frame level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CSimpleApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CSimpleApp::QueryInterface\r\n");

        *ppvObj = NULL;     // must set out pointer parameters to NULL

        // Not a supported interface
        return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::AddRef()
{
        TestDebugOut("In CSimpleApp::AddRef\r\n");
        return ++m_nCount;
}

//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::Release()
{
        TestDebugOut("In CSimpleApp::Release\r\n");

        if (--m_nCount == 0) {
                delete this;
                return 0;
        }
        return m_nCount;
}

//**********************************************************************
//
// CSimpleApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//
// Comments:
//
//********************************************************************

BOOL CSimpleApp::fInitApplication(HANDLE hInstance)
{
        WNDCLASS  wc;

        // Fill in window class structure with parameters that describe the
        // main window.

        wc.style = NULL;                    // Class style(s).
        wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                                                                // windows of this class.
        wc.cbClsExtra = 0;                  // No per-class extra data.
        wc.cbWndExtra = 0;                  // No per-window extra data.
        wc.hInstance = hInstance;           // Application that owns the class.
        wc.hIcon = LoadIcon(hInstance,"SimpDnd");
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  "SIMPLEMENU";    // Name of menu resource in .RC file.
        wc.lpszClassName = "SimpDndAppWClass";  // Name used in CreateWindow call.

        if (!RegisterClass(&wc))
                return FALSE;

        wc.style = CS_DBLCLKS;              // Class style(s). allow DBLCLK's
        wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                                                                // windows of this class.
        wc.cbClsExtra = 0;                  // No per-class extra data.
        wc.cbWndExtra = 0;                  // No per-window extra data.
        wc.hInstance = hInstance;           // Application that owns the class.
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  NULL;
        wc.lpszClassName = "SimpDndDocWClass"; // Name used in CreateWindow call.

        // Register the window class and return success/failure code.

        return (RegisterClass(&wc));
}

//**********************************************************************
//
// CSimpleApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpleApp::fInitInstance (HANDLE hInstance, int nCmdShow)
{
        DWORD dwVer = OleBuildVersion();
        LPMALLOC lpMalloc = NULL;

#ifdef NO
        // check to see if we are compatible with this version of the libraries
        if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup) {
#ifdef _DEBUG
                TestDebugOut("WARNING: Incompatible OLE library version\r\n");
#else
                return FALSE;
#endif
        }

#endif

#if defined( _DEBUG )
        /* OLE2NOTE: Use a special debug allocator to help track down
        **    memory leaks.
        */
        OleStdCreateDbAlloc(0, &lpMalloc);
#endif

        if (OleInitialize(lpMalloc) == NOERROR)
                m_fInitialized = TRUE;

#if defined( _DEBUG )
        /* OLE2NOTE: release the special debug allocator so that only OLE is
        **    holding on to it. later when OleUninitialize is called, then
        **    the debug allocator object will be destroyed. when the debug
        **    allocator object is destoyed, it will report (to the Output
        **    Debug Terminal) whether there are any memory leaks.
        */
        if (lpMalloc) lpMalloc->Release();
#endif

        m_hInst = hInstance;

        // Create the "application" windows
        m_hAppWnd = CreateWindow ("SimpDndAppWClass",
                                                          "Simple OLE 2.0 Drag/Drop Container",
                                                          WS_OVERLAPPEDWINDOW,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          NULL,
                                                          NULL,
                                                          hInstance,
                                                          NULL);

        if (!m_hAppWnd)
                return FALSE;

        // if we have been launched by the test driver, tell it our window handle

        if( m_hDriverWnd )
        {
            PostMessage(m_hDriverWnd, WM_TESTREG, (WPARAM)m_hAppWnd, 0);
        }

        // delay before dragging should start, in milliseconds
        m_nDragDelay = GetProfileInt(
                        "windows",
                        "DragDelay",
                        DD_DEFDRAGDELAY
        );

        // minimum distance (radius) before drag should start, in pixels
        m_nDragMinDist = GetProfileInt(
                        "windows",
                        "DragMinDist",
                        DD_DEFDRAGMINDIST
        );

        // delay before scrolling, in milliseconds
        m_nScrollDelay = GetProfileInt(
                        "windows",
                        "DragScrollDelay",
                        DD_DEFSCROLLDELAY
        );

        // inset-width of the hot zone, in pixels
        m_nScrollInset = GetProfileInt(
                        "windows",
                        "DragScrollInset",
                        DD_DEFSCROLLINSET
        );

        // scroll interval, in milliseconds
        m_nScrollInterval = GetProfileInt(
                        "windows",
                        "DragScrollInterval",
                        DD_DEFSCROLLINTERVAL
        );

        ShowWindow (m_hAppWnd, nCmdShow);
        UpdateWindow (m_hAppWnd);

        return m_fInitialized;
}

//**********************************************************************
//
// CSimpleApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      IOleObject::DoVerb                          Object
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      CSimpleDoc::InsertObject                    DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpleApp::lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        // see if the command is a verb selections
        if (wParam >= IDM_VERB0)
                {
                // get the rectangle of the object
                m_lpDoc->m_lpSite->GetObjRect(&rect);

                m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                                wParam - IDM_VERB0, NULL,
                                &m_lpDoc->m_lpSite->m_OleClientSite, -1,
                                m_lpDoc->m_hDocWnd, &rect);
                }
        else
                {
                switch (wParam) {
                        // bring up the About box
                        case IDM_ABOUT:
                                {
                                FARPROC lpProcAbout = MakeProcInstance((FARPROC)About, m_hInst);

                                DialogBox(m_hInst,               // current instance
                                        "AboutBox",                  // resource to use
                                        m_hAppWnd,                   // parent handle
                                        lpProcAbout);                // About() instance address

                                FreeProcInstance(lpProcAbout);
                                break;
                                }

                        // bring up the InsertObject Dialog
                        case IDM_INSERTOBJECT:
                                m_lpDoc->InsertObject();
                                break;

                        // Copy the object to the Clipboard
                        case IDM_COPY:
                                m_lpDoc->CopyObjectToClip();
                                break;

                        // exit the application
                        case IDM_EXIT:
                                SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                                break;

                        case IDM_NEW:
                                m_lpDoc->Close();
                                m_lpDoc = NULL;
                                lCreateDoc(hWnd, 0, 0, 0);
                                break;

                        default:
                                return (DefWindowProc(hWnd, message, wParam, lParam));
                        }   // end of switch
                }  // end of else
        return NULL;
}

//**********************************************************************
//
// CSimpleApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::lResizeDoc      DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpleApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        GetClientRect(m_hAppWnd, &rect);
        return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpleApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::CSimpleDoc      DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpleApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        GetClientRect(hWnd, &rect);

        m_lpDoc = CSimpleDoc::Create(this, &rect, hWnd);

        return NULL;
}

//**********************************************************************
//
// CSimpleApp::HandleAccelerators
//
// Purpose:
//
//      To properly handle accelerators in the Message Loop
//
// Parameters:
//
//      LPMSG lpMsg -   A pointer to the message structure.
//
// Return Value:
//
//      TRUE    -   The accelerator was handled
//      FALSE   -   The accelerator was not handled
//
// Function Calls:
//      Function                                        Location
//
// Comments:
//
//********************************************************************

BOOL CSimpleApp::HandleAccelerators(LPMSG lpMsg)
{
        BOOL retval = FALSE;

        // we do not have any accelerators

        return retval;
}

//**********************************************************************
//
// CSimpleApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::PaintDoc        DOC.CPP
//
// Comments:
//
//      This is an app level function in case we want to do palette
//      management.
//
//********************************************************************

void CSimpleApp::PaintApp (HDC hDC)
{
        // at this level, we could enumerate through all of the
        // visible objects in the application, so that a palette
        // that best fits all of the objects can be built.

        // This app is designed to take on the same palette
        // functionality that was provided in OLE 1.0, the palette
        // of the last object drawn is realized.  Since we only
        // support one object at a time, it shouldn't be a big
        // deal.

        // if we supported multiple documents, we would enumerate
        // through each of the open documents and call paint.

        if (m_lpDoc)
                m_lpDoc->PaintDoc(hDC);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\dxferobj.h ===
//**********************************************************************
// File name: dxferobj.h
//
//      Definition of CDataXferObj
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DATAXFEROBJ_H_)
#define _DATAXFEROBJ_H_

class CSimpleSite;

interface CDataObject;

class CDataXferObj : public IDataObject
{
private:
	int m_nCount;                       // reference count
	SIZEL m_sizel;
	POINTL m_pointl;
	LPSTORAGE m_lpObjStorage;
	LPOLEOBJECT m_lpOleObject;

	// construction/destruction
	CDataXferObj();
	~CDataXferObj();

public:
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
	LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
		{ return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
	STDMETHODIMP DUnadvise  ( DWORD dwConnection)
		{ return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
	STDMETHODIMP EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
		{ return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
	STDMETHODIMP EnumFormatEtc  ( DWORD dwDirection,
			LPENUMFORMATETC FAR* ppenumFormatEtc);
			STDMETHODIMP GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
			LPFORMATETC pformatetcOut)
		{ pformatetcOut->ptd = NULL; return ResultFromScode(E_NOTIMPL); }
	STDMETHODIMP GetData  (LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium );
	STDMETHODIMP GetDataHere  (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium);
	STDMETHODIMP QueryGetData  (LPFORMATETC pformatetc );
	STDMETHODIMP SetData  (LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
			BOOL fRelease)
		{ return ResultFromScode(E_NOTIMPL); }

	static CDataXferObj FAR* Create(CSimpleSite FAR* lpSite,
			POINTL FAR* pPointl);

};
#endif  // _DATAXFEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\ias.h ===
//**********************************************************************
// File name: IAS.H
//
//      Definition of CAdviseSink
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IAS_H_ )
#define _IAS_H_

#include <assert.h>

class CSimpleSite;

interface CAdviseSink : public IAdviseSink
{
	int m_nCount;
	CSimpleSite FAR * m_pSite;

	CAdviseSink(CSimpleSite FAR * pSite) {
		TestDebugOut("In IAS's constructor\r\n");
		m_pSite = pSite;
		m_nCount = 0;
		};

	~CAdviseSink() {
		TestDebugOut("In IAS's destructor\r\n");
		assert(m_nCount == 0);
		} ;

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	// *** IAdviseSink methods ***
	STDMETHODIMP_(void) OnDataChange (FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed);
	STDMETHODIMP_(void) OnViewChange (DWORD dwAspect, LONG lindex);
	STDMETHODIMP_(void) OnRename (LPMONIKER pmk);
	STDMETHODIMP_(void) OnSave ();
	STDMETHODIMP_(void) OnClose ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\ids.h ===
//**********************************************************************
// File name: ids.h
//
//      Definition of CDropSource
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDS_H_ )
#define _IDS_H_

#include <assert.h>

class CSimpleDoc;

interface CDropSource : public IDropSource
{
	int m_nCount;
	CSimpleDoc FAR * m_pDoc;

	CDropSource(CSimpleDoc FAR * pDoc) {
		TestDebugOut("In IDS's constructor\r\n");
		m_pDoc = pDoc;
		m_nCount = 0;
		};

	~CDropSource() {
		TestDebugOut("In IDS's destructor\r\n");
		} ;

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	   // *** IDropSource methods ***
	STDMETHODIMP QueryContinueDrag (BOOL fEscapePressed, DWORD grfKeyState);
	STDMETHODIMP GiveFeedback (DWORD dwEffect);

private:

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\ids.cpp ===
//**********************************************************************
// File name: IDS.CPP
//
//      Implementation file for CDropSource
//
// Functions:
//
//      See IDS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "doc.h"
#include "site.h"
#include "dxferobj.h"


//**********************************************************************
//
// CSimpleDoc::QueryDrag
//
// Purpose:
//
//      Check to see if Drag operation should be initiated based on the
//      current position of the mouse.
//
// Parameters:
//
//      POINT pt                - position of mouse
//
// Return Value:
//
//      BOOL                    - TRUE if drag should take place,
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::GetObjRect     SITE.CPP
//      PtInRect                    Windows API
//
// Comments:
//
//********************************************************************

BOOL CSimpleDoc::QueryDrag(POINT pt)
{
	// if pt is within rect of object, then start drag
	if (m_lpSite)
		{
		RECT rect;
		m_lpSite->GetObjRect(&rect);
		return ( PtInRect(&rect, pt) ? TRUE : FALSE );
		}
	else
		return FALSE;
}


//**********************************************************************
//
// CSimpleDoc::DoDragDrop
//
// Purpose:
//
//      Actually perform a drag/drop operation with the current
//      selection in the source document.
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      DWORD                    - returns the result effect of the
//                                 drag/drop operation:
//                                      DROPEFFECT_NONE,
//                                      DROPEFFECT_COPY,
//                                      DROPEFFECT_MOVE, or
//                                      DROPEFFECT_LINK
//
// Function Calls:
//      Function                    Location
//
//      CDataXferObj::Create        DXFEROBJ.CPP
//      CDataXferObj::QueryInterface DXFEROBJ.CPP
//      CDataXferObj::Release       DXFEROBJ.CPP
//      DoDragDrop                  OLE API
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

DWORD CSimpleDoc::DoDragDrop (void)
{
	DWORD       dwEffect     = 0;
	LPDATAOBJECT lpDataObj;

	TestDebugOut("In CSimpleDoc::DoDragDrop\r\n");

	// Create a data transfer object by cloning the existing OLE object
	CDataXferObj FAR* pDataXferObj = CDataXferObj::Create(m_lpSite,NULL);

	if (! pDataXferObj) {
		MessageBox(NULL,"Out-of-memory","SimpDnD",MB_SYSTEMMODAL|MB_ICONHAND);
		return DROPEFFECT_NONE;
	}

	// initially obj is created with 0 refcnt. this QI will make it go to 1.
	pDataXferObj->QueryInterface(IID_IDataObject, (LPVOID FAR*)&lpDataObj);
	assert(lpDataObj);

	m_fLocalDrop     = FALSE;
	m_fLocalDrag     = TRUE;

	::DoDragDrop ( lpDataObj,
				 &m_DropSource,
				 DROPEFFECT_COPY,   // we only allow copy
				 &dwEffect
	);

	m_fLocalDrag     = FALSE;

	/* if after the Drag/Drop modal (mouse capture) loop is finished
	**    and a drag MOVE operation was performed, then we must delete
	**    the selection that was dragged.
	*/
	if ( (dwEffect & DROPEFFECT_MOVE) != 0 ) {
		// ... delete source object here (we do NOT support MOVE)
	}

	pDataXferObj->Release();    // this should destroy the DataXferObj
	return dwEffect;
}



//**********************************************************************
//
// CDropSource::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::QueryInterface  DOC.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropSource::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In IDS::QueryInterface\r\n");

	// delegate to the document
	return m_pDoc->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CDropSource::AddRef
//
// Purpose:
//
//      Increments the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleObj::AddReff         OBJ.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function adds one to the ref count of the interface,
//      and calls then calls CSimpleDoc to increment its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
	TestDebugOut("In IDS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the document Object
	return m_pDoc->AddRef();
}

//**********************************************************************
//
// CDropSource::Release
//
// Purpose:
//
//      Decrements the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleObj::Release         OBJ.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function subtracts one from the ref count of the interface,
//      and calls then calls CSimpleDoc to decrement its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropSource::Release()
{
	TestDebugOut("In IDS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	--m_nCount;

	// delegate to the document object
	return m_pDoc->Release();
}

//**********************************************************************
//
// CDropSource::QueryContinueDrag
//
// Purpose:
//
//      Called to determine if a drop should take place or be canceled.
//
// Parameters:
//
//      BOOL fEscapePressed - TRUE if ESCAPE key has been pressed
//      DWORD grfKeyState   - key state
//
// Return Value:
//
//      DRAGDROP_S_CANCEL   - drag operation should be canceled
//      DRAGDROP_S_DROP     - drop operation should be performed
//      S_OK                - dragging should continue
//
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropSource::QueryContinueDrag (
		BOOL    fEscapePressed,
		DWORD   grfKeyState
)
{
	if (fEscapePressed)
		return ResultFromScode(DRAGDROP_S_CANCEL);
	else if (!(grfKeyState & MK_LBUTTON))
		return ResultFromScode(DRAGDROP_S_DROP);
	else
		return NOERROR;
}


//**********************************************************************
//
// CDropSource::GiveFeedback
//
// Purpose:
//
//      Called to set cursor feedback
//
// Parameters:
//
//      DWORD dwEffect      - drop operation to give feedback for
//
// Return Value:
//
//      DRAGDROP_S_USEDEFAULTCURSORS  - tells OLE to use standard cursors
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropSource::GiveFeedback (DWORD dwEffect)
{
	return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\idt.h ===
//**********************************************************************
// File name: idt.h
//
//      Definition of CDropTarget
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDT_H_ )
#define _IDT_H_

#include <assert.h>

class CSimpleDoc;

/* Flags to control direction for drag scrolling */
typedef enum tagSCROLLDIR {
	SCROLLDIR_NULL          = 0,
	SCROLLDIR_UP            = 1,
	SCROLLDIR_DOWN          = 2,
	SCROLLDIR_RIGHT         = 3,
	SCROLLDIR_LEFT          = 4
} SCROLLDIR;

interface CDropTarget : public IDropTarget
{
	int   m_nCount;                 // reference count
	CSimpleDoc FAR * m_pDoc;
	BOOL  m_fCanDropCopy;
	BOOL  m_fCanDropLink;
	DWORD m_dwSrcAspect;
	RECT  m_rcDragRect;
	POINT m_ptLast;
	BOOL  m_fDragFeedbackDrawn;
	DWORD m_dwTimeEnterScrollArea;  // time of entering scroll border region
	DWORD m_dwLastScrollDir;        // current dir for drag scroll
	DWORD m_dwNextScrollTime;       // time for next scroll

	CDropTarget(CSimpleDoc FAR * pDoc) {
		TestDebugOut("In IDT's constructor\r\n");
		m_pDoc = pDoc;
		m_nCount = 0;
		m_fCanDropCopy = FALSE;
		m_fCanDropLink = FALSE;
		m_fDragFeedbackDrawn = FALSE;
		m_dwTimeEnterScrollArea = 0L;
		m_dwNextScrollTime = 0L;
		m_dwLastScrollDir = SCROLLDIR_NULL;
		};

	~CDropTarget() {
		TestDebugOut("In IDT's destructor\r\n");
		assert(m_nCount == 0);
		} ;

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	   // *** IDropTarget methods ***
	STDMETHODIMP DragEnter (LPDATAOBJECT pDataObj, DWORD grfKeyState,
			POINTL pt, LPDWORD pdwEffect);
	STDMETHODIMP DragOver  (DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect);
	STDMETHODIMP DragLeave ();
	STDMETHODIMP Drop (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt,
			LPDWORD pdwEffect);

private:
	// Drag/Drop support methods
	BOOL QueryDrop (DWORD grfKeyState, POINTL pointl, BOOL fDragScroll,
			LPDWORD lpdwEffect);
	BOOL DoDragScroll( POINTL pointl );
	void InitDragFeedback(LPDATAOBJECT pDataObj, POINTL pointl);
	void DrawDragFeedback( POINTL pointl );
	void UndrawDragFeedback( void );
};

#endif  // _IDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\ias.cpp ===
//**********************************************************************
// File name: IAS.CPP
//
//      Implementation file of CAdviseSink
//
//
// Functions:
//
//      See IAS.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CAdviseSink::QueryInterface
//
// Purpose:
//
//      Returns a pointer to a requested interface.
//
// Parameters:
//
//      REFIID riid         - The requested interface
//
//      LPVOID FAR* ppvObj  - Place to return the interface
//
// Return Value:
//
//      HRESULT from CSimpleSite::QueryInterface
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::QueryInterface SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function simply delegates to the Object class, which is
//      aware of the supported interfaces.
//
//********************************************************************

STDMETHODIMP CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In IAS::QueryInterface\r\n");

	// delegate to the document Object
	return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CAdviseSink::AddRef
//
// Purpose:
//
//      Increments the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::AddReff        SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function adds one to the ref count of the interface,
//      and calls then calls CSimpleSite to increment its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::AddRef()
{
	TestDebugOut("In IAS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the container Site
	return m_pSite->AddRef();
}

//**********************************************************************
//
// CAdviseSink::Release
//
// Purpose:
//
//      Decrements the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function subtracts one from the ref count of the interface,
//      and calls then calls CSimpleSite to decrement its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::Release()
{
	TestDebugOut("In IAS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	m_nCount--;

	// delegate to the container Site
	return m_pSite->Release();
}

//**********************************************************************
//
// CAdviseSink::OnDataChange
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnDataChange (FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed)
{
	TestDebugOut("In IAS::OnDataChange\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnViewChange
//
// Purpose:
//
//      Notifies us that the view has changed and needs to be updated.
//
// Parameters:
//
//      DWORD dwAspect  - Aspect that has changed
//
//      LONG lindex     - Index that has changed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      IViewObject2::GetExtent     Object
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnViewChange (DWORD dwAspect, LONG lindex)
{
	LPVIEWOBJECT2 lpViewObject2;
	TestDebugOut("In IAS::OnViewChange\r\n");

	// get a pointer to IViewObject2
	HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
			IID_IViewObject2,(LPVOID FAR *)&lpViewObject2);

	if (hErr == NOERROR) {
		// get extent of the object
		// NOTE: this method will never be remoted; it can be called w/i this async method
		lpViewObject2->GetExtent(DVASPECT_CONTENT, -1 , NULL, &m_pSite->m_sizel);
		lpViewObject2->Release();
	}

	InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);
}

//**********************************************************************
//
// CAdviseSink::OnRename
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnRename (LPMONIKER pmk)
{
	TestDebugOut("In IAS::OnRename\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnSave
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnSave ()
{
	TestDebugOut("In IAS::OnSave\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnClose
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnClose()
{
	TestDebugOut("In IAS::OnClose\r\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\iocs.cpp ===
//**********************************************************************
// File name: IOCS.CPP
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at this interface
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In IOCS::QueryInterface\r\n");

	// delegate to the container Site
	return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
	TestDebugOut("In IOCS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the container Site
	return m_pSite->AddRef();
}


//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::Release()
{
	TestDebugOut("In IOCS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	--m_nCount;

	// delegate to the container Site
	return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleObject::QueryInterface          Object
//      IPersistStorage::SaveCompleted      Object
//      IPersistStorage::Release            Object
//      OleSave                             OLE API
//      ResultFromScode                     OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::SaveObject()
{
	LPPERSISTSTORAGE lpPS;
	SCODE sc = E_FAIL;

	TestDebugOut("In IOCS::SaveObject\r\n");

	// get a pointer to IPersistStorage
	HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(IID_IPersistStorage, (LPVOID FAR *)&lpPS);

	// save the object
	if (hErr == NOERROR)
		{
		sc = GetScode( OleSave(lpPS, m_pSite->m_lpObjStorage, TRUE) );
		lpPS->SaveCompleted(NULL);
		lpPS->Release();
		}

	return ResultFromScode(sc);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
	TestDebugOut("In IOCS::GetMoniker\r\n");

	// need to null the out pointer
	*ppmk = NULL;

	return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
	TestDebugOut("In IOCS::GetContainer\r\n");

	// NULL the out pointer
	*ppContainer = NULL;

	return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
	TestDebugOut("In IOCS::ShowObject\r\n");
	return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
	TestDebugOut("In IOCS::OnShowWindow\r\n");
	m_pSite->m_fObjectOpen = fShow;
	InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);

	// if object window is closing, then bring container window to top
	if (! fShow) {
		BringWindowToTop(m_pSite->m_lpDoc->m_hDocWnd);
		SetFocus(m_pSite->m_lpDoc->m_hDocWnd);
	}
	return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
	TestDebugOut("In IOCS::RequestNewObjectLayout\r\n");
	return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpdnd.h"
#include "resource.h"
#include <ole2ver.h>

extern "C" void TestDebugOut(LPSTR psz);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\idt.cpp ===
//**********************************************************************
// File name: IDT.CPP
//
//      Implementation file for CDropTarget
//
// Functions:
//
//      See IDT.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "idt.h"

extern CLIPFORMAT g_cfObjectDescriptor;


//**********************************************************************
//
// CDropTarget::QueryDrop
//
// Purpose:
//
//      Check if the desired drop operation (identified by the given key
//      state) is possible at the current mouse position (pointl).
//
// Parameters:
//
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      BOOL fDragScroll        - TRUE if drag scrolling cursor should
//                                be shown.
//      LPDWORD pdwEffect       - (OUT) drag effect that should occur
//
// Return Value:
//
//      BOOL                    - TRUE if drop could take place,
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      OleStdGetDropEffect         OLE2UI API
//
// Comments:
//
//********************************************************************

BOOL CDropTarget::QueryDrop (
	DWORD           grfKeyState,
	POINTL          pointl,
	BOOL            fDragScroll,
	LPDWORD         pdwEffect
)
{
	DWORD      dwScrollEffect = 0L;
	DWORD      dwOKEffects = *pdwEffect;

	/* check if the cursor is in the active scroll area, if so need the
	**    special scroll cursor.
	*/
	if (fDragScroll)
		dwScrollEffect = DROPEFFECT_SCROLL;

	/* if we have already determined that the source does NOT have any
	**    acceptable data for us, the return NO-DROP
	*/
	if (! m_fCanDropCopy && ! m_fCanDropLink)
		goto dropeffect_none;

	/* OLE2NOTE: determine what type of drop should be performed given
	**    the current modifier key state. we rely on the standard
	**    interpretation of the modifier keys:
	**          no modifier -- DROPEFFECT_MOVE or whatever is allowed by src
	**          SHIFT       -- DROPEFFECT_MOVE
	**          CTRL        -- DROPEFFECT_COPY
	**          CTRL-SHIFT  -- DROPEFFECT_LINK
	*/

	*pdwEffect = OleStdGetDropEffect(grfKeyState);
	if (*pdwEffect == 0) {
		// No modifier keys given. Try in order MOVE, COPY, LINK.
		if ((DROPEFFECT_MOVE & dwOKEffects) && m_fCanDropCopy)
			*pdwEffect = DROPEFFECT_MOVE;
		else if ((DROPEFFECT_COPY & dwOKEffects) && m_fCanDropCopy)
			*pdwEffect = DROPEFFECT_COPY;
		else if ((DROPEFFECT_LINK & dwOKEffects) && m_fCanDropLink)
			*pdwEffect = DROPEFFECT_LINK;
		else
			goto dropeffect_none;
	} else {
		/* OLE2NOTE: we should check if the drag source application allows
		**    the desired drop effect.
		*/
		if (!(*pdwEffect & dwOKEffects))
			goto dropeffect_none;

		if ((*pdwEffect == DROPEFFECT_COPY || *pdwEffect == DROPEFFECT_MOVE)
				&& ! m_fCanDropCopy)
			goto dropeffect_none;

		if (*pdwEffect == DROPEFFECT_LINK && ! m_fCanDropLink)
			goto dropeffect_none;
	}

	*pdwEffect |= dwScrollEffect;
	return TRUE;

dropeffect_none:

	*pdwEffect = DROPEFFECT_NONE;
	return FALSE;
}


//**********************************************************************
//
// CDropTarget::QueryDrop
//
// Purpose:
//
//     Check to see if Drag scroll operation should be initiated.
//
// Parameters:
//
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      BOOL                    - TRUE if scroll cursor should be given
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      ScreenToClient              WINDOWS API
//      GetClientRect               WINDOWS API
//
// Comments:
//     A Drag scroll operation should be initiated when the mouse has
//     remained in the active scroll area (11 pixels frame around border
//     of window) for a specified amount of time (50ms).
//
//********************************************************************

BOOL CDropTarget::DoDragScroll (POINTL pointl)
{
	DWORD dwScrollDir = SCROLLDIR_NULL;
	DWORD dwTime = GetCurrentTime();
	int nScrollInset = m_pDoc->m_lpApp->m_nScrollInset;
	int nScrollDelay = m_pDoc->m_lpApp->m_nScrollDelay;
	int nScrollInterval = m_pDoc->m_lpApp->m_nScrollInterval;
	POINT point;
	RECT rect;

	point.x = (int)pointl.x;
	point.y = (int)pointl.y;

	ScreenToClient( m_pDoc->m_hDocWnd, &point);
	GetClientRect ( m_pDoc->m_hDocWnd, (LPRECT) &rect );

	if (rect.top <= point.y && point.y<=(rect.top+nScrollInset))
		dwScrollDir = SCROLLDIR_UP;
	else if ((rect.bottom-nScrollInset) <= point.y && point.y <= rect.bottom)
		dwScrollDir = SCROLLDIR_DOWN;
	else if (rect.left <= point.x && point.x <= (rect.left+nScrollInset))
		dwScrollDir = SCROLLDIR_LEFT;
	else if ((rect.right-nScrollInset) <= point.x && point.x <= rect.right)
		dwScrollDir = SCROLLDIR_RIGHT;

	if (m_dwTimeEnterScrollArea) {

		/* cursor was already in Scroll Area */

		if (! dwScrollDir) {
			/* cusor moved OUT of scroll area.
			**      clear "EnterScrollArea" time.
			*/
			m_dwTimeEnterScrollArea = 0L;
			m_dwNextScrollTime = 0L;
			m_dwLastScrollDir = SCROLLDIR_NULL;

		} else if (dwScrollDir != m_dwLastScrollDir) {
			/* cusor moved into a different direction scroll area.
			**      reset "EnterScrollArea" time to start a new 50ms delay.
			*/
			m_dwTimeEnterScrollArea = dwTime;
			m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
			m_dwLastScrollDir = dwScrollDir;

		} else if (dwTime && dwTime >= m_dwNextScrollTime) {
			m_pDoc->Scroll ( dwScrollDir );    // Scroll document now
			m_dwNextScrollTime = dwTime + (DWORD)nScrollInterval;
		}
	} else {
		if (dwScrollDir) {
			/* cusor moved INTO a scroll area.
			**      reset "EnterScrollArea" time to start a new 50ms delay.
			*/
			m_dwTimeEnterScrollArea = dwTime;
			m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
			m_dwLastScrollDir = dwScrollDir;
		}
	}

	return (dwScrollDir ? TRUE : FALSE);
}


// Support functions/macros
#define SetTopLeft(rc, pt)      \
	((rc)->top = (pt)->y,(rc)->left = (pt)->x)
#define SetBottomRight(rc, pt)      \
	((rc)->bottom = (pt)->y,(rc)->right = (pt)->x)
#define OffsetPoint(pt, dx, dy)     \
	((pt)->x += dx, (pt)->y += dy)


/* HighlightRect
** -------------
**    Invert rectangle on screen. used for drop target feedback.
*/

static int HighlightRect(HWND hwnd, HDC hdc, LPRECT rc)
{
	POINT pt1, pt2;
	int old = SetROP2(hdc, R2_NOT);
	HPEN hpen;
	HGDIOBJ hold;

	pt1.x = rc->left;
	pt1.y = rc->top;
	pt2.x = rc->right;
	pt2.y = rc->bottom;

	ScreenToClient(hwnd, &pt1);
	ScreenToClient(hwnd, &pt2);

	hold = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
	hpen = SelectObject(hdc, CreatePen(PS_SOLID, 2,
						  GetSysColor(COLOR_ACTIVEBORDER)));

	Rectangle(hdc, pt1.x, pt1.y, pt2.x, pt2.y);

	SetROP2(hdc, old);

	hold = SelectObject(hdc, hold);
	hpen = SelectObject(hdc, hpen);

	DeleteObject(hpen);

  return 0;
}


//**********************************************************************
//
// CDropTarget::InitDragFeedback
//
// Purpose:
//
//      Initialize data used to draw drop target feedback.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      IDataObject::GetData        Object
//      XformSizeInHimetricToPixels OLE2UI Library
//      GlobalLock                  WINDOWS API
//      GlobalUnlock                WINDOWS API
//      ReleaseStgMedium            OLE2 API
//      OffsetPoint                 IDT.CPP
//      SetTopLeft                  IDT.CPP
//      SetBottomRight              IDT.CPP
//
// Comments:
//      In order to known the size of the object before the object
//      is actually dropped, we render CF_OBJECTDESCRIPTOR format.
//      this data format tells us both the size of the object as
//      well as which aspect is the object is displayed as in the
//      source. if the object is currently displayed as DVASPECT_ICON
//      then we want to create the object also as DVASPECT_ICON.
//
//********************************************************************

void CDropTarget::InitDragFeedback(LPDATAOBJECT pDataObj, POINTL pointl)
{
	FORMATETC fmtetc;
	STGMEDIUM stgmed;
	POINT pt;
	int height, width;
	HRESULT hrErr;

	height = width = 100; // some default values
	pt.x = (int)pointl.x;
	pt.y = (int)pointl.y;

	// do a GetData for CF_OBJECTDESCRIPTOR format to get the size of the
	// object as displayed in the source. using this size, initialize the
	// size for the drag feedback rectangle.
	fmtetc.cfFormat = g_cfObjectDescriptor;
	fmtetc.ptd = NULL;
	fmtetc.lindex = -1;
	fmtetc.dwAspect = DVASPECT_CONTENT;
	fmtetc.tymed = TYMED_HGLOBAL;

	hrErr = pDataObj->GetData(&fmtetc, &stgmed);
	if (hrErr == NOERROR) {
		LPOBJECTDESCRIPTOR pOD=(LPOBJECTDESCRIPTOR)GlobalLock(stgmed.hGlobal);
		if (pOD != NULL) {
			XformSizeInHimetricToPixels(NULL, &pOD->sizel, &pOD->sizel);

			width = (int)pOD->sizel.cx;
			height = (int)pOD->sizel.cy;
			m_dwSrcAspect = pOD->dwDrawAspect;
		}

		GlobalUnlock(stgmed.hGlobal);
		ReleaseStgMedium(&stgmed);
	}

	m_ptLast = pt;
	m_fDragFeedbackDrawn = FALSE;

	OffsetPoint(&pt, -(width/2), -(height/2));
	SetTopLeft(&m_rcDragRect, &pt);

	OffsetPoint(&pt, width, height);
	SetBottomRight(&m_rcDragRect, &pt);
}


//**********************************************************************
//
// CDropTarget::UndrawDragFeedback
//
// Purpose:
//
//      Erase any drop target feedback.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      GetDC                       WINDOWS API
//      ReleaseDC                   WINDOWS API
//      GlobalUnlock                WINDOWS API
//      HighlightRect               IDT.CPP
//
// Comments:
//      In order to known the size of the object before the object
//      is actually dropped, we render CF_OBJECTDESCRIPTOR format.
//      this data format tells us both the size of the object as
//      well as which aspect is the object is displayed as in the
//      source. if the object is currently displayed as DVASPECT_ICON
//      then we want to create the object also as DVASPECT_ICON.
//
//********************************************************************

void CDropTarget::UndrawDragFeedback( void )
{
	if (m_fDragFeedbackDrawn) {
		m_fDragFeedbackDrawn = FALSE;
		HDC hDC = GetDC(m_pDoc->m_hDocWnd);
		HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
		ReleaseDC(m_pDoc->m_hDocWnd, hDC);
	}
}


//**********************************************************************
//
// CDropTarget::DrawDragFeedback
//
// Purpose:
//
//      Compute new position of drop target feedback rectangle and
//      erase old rectangle and draw new rectangle.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      OffsetPoint                 IDT.CPP
//      HighlightRect               IDT.CPP
//      GetDC                       WINDOWS API
//      ReleaseDC                   WINDOWS API
//
// Comments:
//
//********************************************************************

void CDropTarget::DrawDragFeedback( POINTL pointl )
{
	POINT ptDiff;

	ptDiff.x = (int)pointl.x - m_ptLast.x;
	ptDiff.y = (int)pointl.y - m_ptLast.y;

	if (m_fDragFeedbackDrawn && (ptDiff.x == 0 && ptDiff.y == 0))
		return;     // mouse did not move; leave rectangle as drawn

	HDC hDC = GetDC(m_pDoc->m_hDocWnd);
	if (m_fDragFeedbackDrawn) {
		m_fDragFeedbackDrawn = FALSE;
		HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
	}

	OffsetRect(&m_rcDragRect, ptDiff.x, ptDiff.y);
	HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
	m_fDragFeedbackDrawn = TRUE;
	m_ptLast.x = (int)pointl.x;
	m_ptLast.y = (int)pointl.y;
	ReleaseDC(m_pDoc->m_hDocWnd, hDC);
}


//**********************************************************************
//
// CDropTarget::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::QueryInterface  DOC.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropTarget::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In IDT::QueryInterface\r\n");

	// delegate to the document
	return m_pDoc->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CDropTarget::AddRef
//
// Purpose:
//
//      Increments the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::AddReff         DOC.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function adds one to the ref count of the interface,
//      and calls then calls CSimpleObj to increment its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropTarget::AddRef()
{
	TestDebugOut("In IDT::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the document Object
	return m_pDoc->AddRef();
}

//**********************************************************************
//
// CDropTarget::Release
//
// Purpose:
//
//      Decrements the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::Release         DOC.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function subtracts one from the ref count of the interface,
//      and calls then calls CSimpleDoc to decrement its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropTarget::Release()
{
	TestDebugOut("In IDT::Release\r\n");

	// decrement the interface reference count (for debugging only)
	--m_nCount;

	// delegate to the document object
	return m_pDoc->Release();
}


//**********************************************************************
//
// CDropTarget::DragEnter
//
// Purpose:
//
//      Called when the mouse first enters our DropTarget window
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleQueryCreateFromData      OLE2 API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      InitDragFeedback            IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE.
//
//********************************************************************

STDMETHODIMP CDropTarget::DragEnter (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect)
{
	TestDebugOut("In IDT::DragEnter\r\n");

	/* Determine if the drag source data object offers a data format
	**  that we understand. we accept only creating embedded objects.
	*/
	m_fCanDropCopy = ((OleQueryCreateFromData(pDataObj) == NOERROR) ?
			TRUE : FALSE);
	m_fCanDropLink = FALSE; // linking NOT supported in this simple sample

	if (m_fCanDropCopy || m_fCanDropLink)
		InitDragFeedback(pDataObj, pointl);

	BOOL fDragScroll = DoDragScroll ( pointl );

	if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect))
		DrawDragFeedback( pointl );

	return NOERROR;
}


//**********************************************************************
//
// CDropTarget::DragOver
//
// Purpose:
//
//      Called when the mouse moves, key state changes, or a time
//      interval passes while the mouse is still within our DropTarget
//      window.
//
// Parameters:
//
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE. OLE pulses the DragOver
//      calls in order that the DropTarget can implement drag scrolling
//
//********************************************************************

STDMETHODIMP CDropTarget::DragOver  (DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect)
{
	TestDebugOut("In IDT::DragOver\r\n");

	BOOL fDragScroll = DoDragScroll ( pointl );

	if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect))
		DrawDragFeedback( pointl );
	else
		UndrawDragFeedback();

	return NOERROR;
}


//**********************************************************************
//
// CDropTarget::DragLeave
//
// Purpose:
//
//      Called when the mouse leaves our DropTarget window
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      UndrawDragFeedback          IDT.CPP
//      ResultFromScode             OLE2 API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropTarget::DragLeave ()
{
	TestDebugOut("In IDT::DragLeave\r\n");

	UndrawDragFeedback();

	return ResultFromScode(S_OK);
}


//**********************************************************************
//
// CDropTarget::Drop
//
// Purpose:
//
//      Called when a Drop operation should take place.
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Create         SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      OleCreateFromData           OLE2 API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      InitDragFeedback            IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//      GetScode                    OLE2 API
//      ResultFromScode             OLE2 API
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE.
//
//********************************************************************

STDMETHODIMP CDropTarget::Drop (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect)
{
	FORMATETC fmtetc;
	SCODE sc = S_OK;

	TestDebugOut("In IDT::Drop\r\n");

	UndrawDragFeedback();

	if (pDataObj && QueryDrop(grfKeyState,pointl,FALSE,pdwEffect))
		{
		m_pDoc->m_lpSite = CSimpleSite::Create(m_pDoc);
		// keep same aspect as drop source
		m_pDoc->m_lpSite->m_dwDrawAspect = m_dwSrcAspect;

		// in order to specify a particular drawing Aspect we must
		// pass a FORMATETC* to OleCreateFromData
		fmtetc.cfFormat = NULL;             // use whatever for drawing
		fmtetc.ptd = NULL;
		fmtetc.lindex = -1;
		fmtetc.dwAspect = m_dwSrcAspect;    // desired drawing aspect
		fmtetc.tymed = TYMED_NULL;

		HRESULT hrErr = OleCreateFromData (
							pDataObj,
							IID_IOleObject,
							OLERENDER_DRAW,
							&fmtetc,
							&m_pDoc->m_lpSite->m_OleClientSite,
							m_pDoc->m_lpSite->m_lpObjStorage,
							(LPVOID FAR *)&m_pDoc->m_lpSite->m_lpOleObject);

		if (hrErr == NOERROR)
			{
			m_pDoc->m_lpSite->InitObject(FALSE /* fCreateNew */);
			m_pDoc->DisableInsertObject();
			}
		else
			sc = GetScode(hrErr);
		}

	return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\iocs.h ===
//**********************************************************************
// File name: IOCS.H
//
//      Definition of COleClientSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOCS_H_ )
#define _IOCS_H_

#include <assert.h>

class CSimpleSite;

interface COleClientSite : public IOleClientSite
{
	int m_nCount;
	CSimpleSite FAR * m_pSite;

	COleClientSite(CSimpleSite FAR * pSite) {
		TestDebugOut("In IOCS's constructor\r\n");
		m_pSite = pSite;
		m_nCount = 0;
		}

	~COleClientSite() {
		TestDebugOut("In IOCS's destructor\r\n");
		assert(m_nCount == 0);
		}

	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// *** IOleClientSite methods ***
	STDMETHODIMP SaveObject();
	STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk);
	STDMETHODIMP GetContainer(LPOLECONTAINER FAR* ppContainer);
	STDMETHODIMP ShowObject();
	STDMETHODIMP OnShowWindow(BOOL fShow);
	STDMETHODIMP RequestNewObjectLayout();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPDND.RC
//
#define IDM_OPEN                        102
#define IDC_DRAGPENDING                 102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\tests.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	tests.h
//
//  Contents: 	Declarations for the unit test functions
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef __TESTS_H
#define __TESTS_H

void StartTest1(CSimpleApp *);
void StartTest2(CSimpleApp *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\simpdnd.h ===
//**********************************************************************
// File name: simpdnd.h
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000

int PASCAL WinMain(HANDLE hInstance,HANDLE hPrevInstance,LPSTR lpCmdLine,int nCmdShow);
BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);
long FAR PASCAL _export MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
long FAR PASCAL _export DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FAR PASCAL _export About(HWND hDlg, unsigned message, WORD wParam, LONG lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\simpdnd.cpp ===
//**********************************************************************
// File name: Simple.cpp
//
//      Main source file for the Simple OLE 2.0 object container
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>
#include <stdlib.h>
#include "tests.h"

// This line is needed for the debug utilities in OLE2UI
extern "C" {
        OLEDBGDATA_MAIN("SIMPDND")
}

CSimpleApp FAR * lpCSimpleApp;
BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugString(psz);
    }
}

//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::CSimpleApp          APP.CPP
//      CSimpleApp::fInitApplication    APP.CPP
//      CSimpleApp::fInitInstance       APP.CPP
//      CSimpleApp::HandleAccelerators  APP.CPP
//      CSimpleApp::~CSimpleApp         APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
// Comments:
//
//********************************************************************

int PASCAL WinMain(HANDLE hInstance,HANDLE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)

{
        LPSTR       pszTemp;
        MSG msg;
	fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

	if(fBeVerbose == 0)
	{
	    fBeVerbose = GetProfileInt("OLEUTEST","spdnd16",0);
	}

        // needed for LRPC to work properly...
        SetMessageQueue(96);

        lpCSimpleApp = new CSimpleApp;

        // we will add one ref count on our App. later when we want to destroy
        // the App object we will release this  ref count. when the App's ref
        // count goes to 0, it will be deleted.
        lpCSimpleApp->AddRef();

        // process the command line

        if( (pszTemp = strstr(lpCmdLine, "-driver")) )
        {
            //we were launched by the test driver
            lpCSimpleApp->m_hDriverWnd = (HWND)strtoul(pszTemp+8, NULL, 10);
        }



        // app initialization
        if (!hPrevInstance)
                if (!lpCSimpleApp->fInitApplication(hInstance))
                        return (FALSE);

        // instance initialization
        if (!lpCSimpleApp->fInitInstance(hInstance, nCmdShow))
                return (FALSE);

        /* Initialization required for OLE 2 UI library.  This call is
        **    needed ONLY if we are using the static link version of the UI
        **    library. If we are using the DLL version, we should NOT call
        **    this function in our application.
        */
        if (!OleUIInitialize(hInstance, hPrevInstance))
                {
                OleDbgOut("Could not initialize OLEUI library\n");
                return FALSE;
                }

        // message loop
        while (GetMessage(&msg, NULL, NULL, NULL))
                if (!lpCSimpleApp->HandleAccelerators(&msg))
                        {
                        TranslateMessage(&msg);    /* Translates virtual key codes */
                        DispatchMessage(&msg);     /* Dispatches message to window */
                        }

        // De-initialization for UI libraries.  Just like OleUIInitialize, this
        // funciton is needed ONLY if we are using the static link version of the
        // OLE UI library.
        OleUIUninitialize();

        // Release the ref count added on the App above. this will make
        // the App's ref count go to 0, and the App object will be deleted.
        lpCSimpleApp->Release();

        return (msg.wParam);          /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::lCommandHandler     APP.CPP
//      CSimpleApp::DestroyDocs         APP.CPP
//      CSimpleApp::lCreateDoc          APP.CPP
//      CSimpleApp::lSizeHandler        APP.CPP
//      CSimpleDoc::lAddVerbs           DOC.CPP
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//
// Comments:
//
//********************************************************************

long FAR PASCAL _export MainWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)

{

        switch (message)
                {
                    case WM_TEST2:
                    StartTest2(lpCSimpleApp);
                    break;
                case WM_TEST1:
                    StartTest1(lpCSimpleApp);
                    break;
                case WM_CLOSE:
                    DestroyWindow(lpCSimpleApp->m_hAppWnd);
                    break;


                case WM_COMMAND:           // message: command from application menu
                        return lpCSimpleApp->lCommandHandler(hWnd, message, wParam, lParam);
                        break;

                case WM_CREATE:
                        return lpCSimpleApp->lCreateDoc(hWnd, message, wParam, lParam);
                        break;

                case WM_DESTROY:                  // message: window being destroyed
                        lpCSimpleApp->DestroyDocs();  // need to destroy the doc...
                        PostQuitMessage(0);
                        break;

                case WM_INITMENUPOPUP:
                        // is this the edit menu?
                        if ( LOWORD(lParam) == 1)
                                return lpCSimpleApp->m_lpDoc->lAddVerbs();

                        break;

                case WM_SIZE:
                        return lpCSimpleApp->lSizeHandler(hWnd, message, wParam, lParam);

                default:                          // Passes it on if unproccessed
                        return (DefWindowProc(hWnd, message, wParam, lParam));
                }
                return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
// Comments:
//
//********************************************************************

BOOL FAR PASCAL _export About(HWND hDlg,unsigned message,WORD wParam,LONG lParam)

{
        switch (message) {
        case WM_INITDIALOG:                /* message: initialize dialog box */
                return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
                if (wParam == IDOK                /* "OK" box selected?          */
                || wParam == IDCANCEL) {      /* System menu close command? */
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
                }
                break;
        }
        return (FALSE);                           /* Didn't process a message    */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                            Location
//
//      CSimpleApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      IOleObject::QueryInterface          Object
//      IOleObject::DoVerb                  Object
//      CSimpleSite::GetObjRect             SITE.CPP
//      CSimpleDoc::QueryDrag               DOC.CPP
//      CSimpleDoc::DoDragDrop              DOC.CPP
//      SetTimer                            Windows API
//      KillTimer                           Windows API
//      SetCapture                          Windows API
//      ReleaseCapture                      Windows API
//
// Comments:
//
//********************************************************************

long FAR PASCAL _export DocWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
        HDC hDC;
        PAINTSTRUCT ps;

        switch (message) {
                case WM_PAINT:

                        hDC = BeginPaint(hWnd, &ps);

                        if (lpCSimpleApp)
                                lpCSimpleApp->PaintApp (hDC);

                        EndPaint(hWnd, &ps);
                        break;

                case WM_LBUTTONDBLCLK:
                        {
                        POINT pt;

                        pt.x = (int)(short)LOWORD (lParam );
                        pt.y = (int)(short)HIWORD (lParam );

                        if (lpCSimpleApp->m_lpDoc->m_lpSite &&
                                lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject)
                                {
                                RECT rect;

                                lpCSimpleApp->m_lpDoc->m_lpSite->GetObjRect(&rect);

                                if ( PtInRect(&rect, pt) )
                                        {
                                        // Execute object's default verb
                                        lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                                                        OLEIVERB_PRIMARY, (LPMSG)&message,
                                                        &lpCSimpleApp->m_lpDoc->m_lpSite->m_OleClientSite,
                                                        -1, hWnd, &rect);
                                        }
                                }
                        }
                        break;

                case WM_LBUTTONDOWN:
                        {
                        POINT pt;

                        pt.x = (int)(short)LOWORD (lParam );
                        pt.y = (int)(short)HIWORD (lParam );

                        /* OLE2NOTE: check if this is a button down on the region
                        **    that is a handle to start a drag operation. for us,
                        **    this this is any where in the window. we
                        **    do NOT want to start a drag immediately; we want to
                        **    wait until the mouse moves a certain threshold. or a
                        **    certain amount of time has elapsed. if
                        **    LButtonUp comes before the drag is started, then
                        **    the fPendingDrag state is cleared. we must capture
                        **    the mouse to ensure the modal state is handled
                        **    properly.
                        */
                        if (lpCSimpleApp->m_lpDoc->QueryDrag(pt) )
                                {
                                lpCSimpleApp->m_lpDoc->m_fPendingDrag = TRUE;
                                lpCSimpleApp->m_lpDoc->m_ptButDown = pt;
                                SetTimer(hWnd, 1, lpCSimpleApp->m_nDragDelay, NULL);
                                SetCapture(hWnd);
                                }
                        break;
                        }

                case WM_LBUTTONUP:

                        if (lpCSimpleApp->m_lpDoc->m_fPendingDrag)
                                {
                                /* ButtonUP came BEFORE distance/time threshholds were
                                **    exceeded. clear fPendingDrag state.
                                */
                                ReleaseCapture();
                                KillTimer(hWnd, 1);
                                lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;
                                }
                        break;

                case WM_MOUSEMOVE:
                        {
                        if (lpCSimpleApp->m_lpDoc->m_fPendingDrag)
                                {
                                int  x = (int)(short)LOWORD (lParam );
                                int  y = (int)(short)HIWORD (lParam );
                                POINT pt = lpCSimpleApp->m_lpDoc->m_ptButDown;
                                int nDragMinDist = lpCSimpleApp->m_nDragMinDist;

                                if (! ( ((pt.x - nDragMinDist) <= x)
                                                && (x <= (pt.x + nDragMinDist))
                                                && ((pt.y - nDragMinDist) <= y)
                                                && (y <= (pt.y + nDragMinDist)) ) )
                                        {
                                        // mouse moved beyond threshhold to start drag
                                        ReleaseCapture();
                                        KillTimer(hWnd, 1);
                                        lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;

                                        // perform the modal drag/drop operation.
                                        lpCSimpleApp->m_lpDoc->DoDragDrop( );
                                        }
                                }
                        break;
                        }

                case WM_TIMER:
                        {
                        // drag time delay threshhold exceeded -- start drag
                        ReleaseCapture();
                        KillTimer(hWnd, 1);
                        lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;

                        // perform the modal drag/drop operation.
                        lpCSimpleApp->m_lpDoc->DoDragDrop( );
                        break;
                        }

                default:                          /* Passes it on if unproccessed */
                        return (DefWindowProc(hWnd, message, wParam, lParam));
        }
        return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\site.cpp ===
//**********************************************************************
// File name: SITE.CPP
//
//      Implementation file for CSimpleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CSimpleSite::Create
//
// Purpose:
//
//      Creation routine for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      IStorage::CreateStorage     OLE API
//      assert                      C Runtime
//
// Comments:
//
//********************************************************************

CSimpleSite FAR * CSimpleSite::Create(CSimpleDoc FAR *lpDoc)
{
        CSimpleSite FAR * lpTemp = new CSimpleSite(lpDoc);

        if (!lpTemp)
                return NULL;

        // create a sub-storage for the object
        HRESULT hErr = lpDoc->m_lpStorage->CreateStorage( "Object",
                                STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
                                0,
                                0,
                                &lpTemp->m_lpObjStorage);

        assert(hErr == NOERROR);

        if (hErr != NOERROR)
                {
                delete lpTemp;
                return NULL;
                }

        // we will add one ref count on our Site. later when we want to destroy
        // the Site object we will release this  ref count. when the Site's ref
        // count goes to 0, it will be deleted.
        lpTemp->AddRef();

        return lpTemp;
}

//**********************************************************************
//
// CSimpleSite::CSimpleSite
//
// Purpose:
//
//      Constructor for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                                                // tells us that we are passing this in
                                                                // an initializer, before "this" is through
                                                                // initializing.  This is ok, because
                                                                // we just store the ptr in the other
                                                                // constructors

CSimpleSite::CSimpleSite (CSimpleDoc FAR *lpDoc) : m_OleClientSite(this),
                                                                                                 m_AdviseSink(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
        // remember the pointer to the doc
        m_lpDoc = lpDoc;

        // clear the reference count
        m_nCount = 0;

        m_dwDrawAspect = DVASPECT_CONTENT;
        m_lpOleObject = NULL;
        m_fObjectOpen = FALSE;
}

//**********************************************************************
//
// CSimpleSite::~CSimpleSite
//
// Purpose:
//
//      Destructor for CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

CSimpleSite::~CSimpleSite ()
{
        TestDebugOut ("In CSimpleSite's Destructor \r\n");

        if (m_lpOleObject)
           m_lpOleObject->Release();

        if (m_lpObjStorage)
           m_lpObjStorage->Release();
}


//**********************************************************************
//
// CSimpleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Close                       Object
//
// Comments:
//
//********************************************************************

void CSimpleSite::CloseOleObject (void)
{
        LPVIEWOBJECT lpViewObject = NULL;

        TestDebugOut ("In CSimpleSite::CloseOleObject \r\n");

        if (m_lpOleObject)
           {
           m_lpOleObject->Close(OLECLOSE_NOSAVE);
           }
}


//**********************************************************************
//
// CSimpleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpleSite::CloseOleObject             SITE.CPP
//      IOleObject::QueryInterface              Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::UnloadOleObject (void)
{
        TestDebugOut ("In CSimpleSite::UnloadOleObject \r\n");

        if (m_lpOleObject)
           {
           LPVIEWOBJECT lpViewObject;
           CloseOleObject();    // ensure object is closed; NOP if already closed

           m_lpOleObject->QueryInterface(IID_IViewObject, (LPVOID FAR *)&lpViewObject);

           if (lpViewObject)
                   {
                   // Remove the view advise
                   lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
                   lpViewObject->Release();
                   }

           m_lpOleObject->Release();
           m_lpOleObject = NULL;
           }
}


//**********************************************************************
//
// CSimpleSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CSimpleSite::AddRef          OBJ.CPP
//      COleClientSite::AddRef      IOCS.CPP
//      CAdviseSink::AddRef         IAS.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CSimpleSite::QueryInterface\r\n");

        *ppvObj = NULL;     // must set out pointer parameters to NULL

        if ( riid == IID_IUnknown)
                {
                AddRef();
                *ppvObj = this;
                return ResultFromScode(S_OK);
                }

        if ( riid == IID_IOleClientSite)
                {
                m_OleClientSite.AddRef();
                *ppvObj = &m_OleClientSite;
                return ResultFromScode(S_OK);
                }

        if ( riid == IID_IAdviseSink)
                {
                m_AdviseSink.AddRef();
                *ppvObj = &m_AdviseSink;
                return ResultFromScode(S_OK);
                }

        // Not a supported interface
        return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::AddRef()
{
        TestDebugOut("In CSimpleSite::AddRef\r\n");

        return ++m_nCount;
}

//**********************************************************************
//
// CSimpleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::Release()
{
        TestDebugOut("In CSimpleSite::Release\r\n");

        if (--m_nCount == 0) {
                delete this;
                return 0;
        }
        return m_nCount;
}

//**********************************************************************
//
// CSimpleSite::InitObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
//      BOOL fCreateNew -   TRUE if insert NEW object
//                          FALSE if create object FROM FILE
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject::SetAdvise          Object
//      IViewObject::Release            Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
// Comments:
//
//********************************************************************

HRESULT CSimpleSite::InitObject(BOOL fCreateNew)
{
    LPVIEWOBJECT2 lpViewObject2;
    RECT rect;
    HRESULT hRes;

    // Set a View Advise
    hRes = m_lpOleObject->QueryInterface(IID_IViewObject2,
                                  (LPVOID FAR *)&lpViewObject2);
    if (hRes == ResultFromScode(S_OK))
    {
       hRes = lpViewObject2->SetAdvise(m_dwDrawAspect, ADVF_PRIMEFIRST,
                                &m_AdviseSink);

       if( FAILED(hRes))
       {
                goto errRtn;
       }
       // get the initial size of the object

       hRes = lpViewObject2->GetExtent(m_dwDrawAspect, -1 /*lindex*/, NULL /*ptd*/,
                                &m_sizel);

       //
       // Is OK if the object is actually blank
       //
       if( FAILED(hRes) && (GetScode(hRes) !=  OLE_E_BLANK) )
       {
                goto errRtn;
       }

       lpViewObject2->Release();
    }
    GetObjRect(&rect);  // get the rectangle of the object in pixels

    // give the object the name of the container app/document
    hRes  = m_lpOleObject->SetHostNames("Simple Application",
                                "Simple OLE 2.0 Drag/Drop Container");

    if( FAILED(hRes) )
    {
       goto errRtn;
    }

    // inform object handler/DLL object that it is used in the embedding
    // container's context
    if (OleSetContainedObject(m_lpOleObject, TRUE) != ResultFromScode(S_OK))
    {
       TestDebugOut("Fail in OleSetContainedObject\n");
    }

    if (fCreateNew)
    {
       // force new object to save to guarantee valid object in our storage.
       // OLE 1.0 objects may close w/o saving. this is NOT necessary if the
       // object is created FROM FILE; its data in storage is already valid.
       m_OleClientSite.SaveObject();

       // we only want to DoVerb(SHOW) if this is an InsertNew object.
       // we should NOT DoVerb(SHOW) if the object is created FromFile.
       hRes = m_lpOleObject->DoVerb(
               OLEIVERB_SHOW,
               NULL,
               &m_OleClientSite,
               -1,
               m_lpDoc->m_hDocWnd,
               &rect);
    }

errRtn:
    return hRes;

}

//**********************************************************************
//
// CSimpleSite::PaintObj
//
// Purpose:
//
//      Paints the object
//
// Parameters:
//
//      HDC hDC     - Device context of the document window
//
// Return Value:
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::QueryInterface      Object
//      IViewObject::GetColorSet        Object
//      IViewObject::Release            Object
//      SetMapMode                      Windows API
//      LPtoDP                          Windows API
//      CreateHatchBrush                Windows API
//      SelectObject                    Windows API
//      DeleteObject                    Windows API
//      CreatePalette                   Windows API
//      SelectPalette                   Windows API
//      RealizePalette                  Windows API
//      OleStdFree                      OUTLUI Function
//      OleDraw                         OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::PaintObj(HDC hDC)
{
RECT rect;

        // need to check to make sure there is a valid object
        // available.  This is needed if there is a paint msg
        // between the time that CSimpleSite is instantiated
        // and OleUIInsertObject returns.
        if (!m_lpOleObject)
                return;

        // convert it to pixels
        GetObjRect(&rect);

        LPLOGPALETTE pColorSet = NULL;
        LPVIEWOBJECT lpView = NULL;

        // get a pointer to IViewObject
        m_lpOleObject->QueryInterface(IID_IViewObject,(LPVOID FAR *) &lpView);

        // if the QI succeeds, get the LOGPALETTE for the object
        if (lpView)
                lpView->GetColorSet(m_dwDrawAspect, -1, NULL, NULL, NULL, &pColorSet);

        HPALETTE hPal=NULL;
        HPALETTE hOldPal=NULL;

        // if a LOGPALETTE was returned (not guarateed), create the palette and
        // realize it.  NOTE: A smarter application would want to get the LOGPALETTE
        // for each of its visible objects, and try to create a palette that
        // satisfies all of the visible objects.  ALSO: OleStdFree() is use to
        // free the returned LOGPALETTE.
        if ((pColorSet))
                {
                hPal = CreatePalette((const LPLOGPALETTE) pColorSet);
                hOldPal = SelectPalette(hDC, hPal, FALSE);
                RealizePalette(hDC);
                OleStdFree(pColorSet);
                }

        // draw the object
        OleDraw(m_lpOleObject, m_dwDrawAspect, hDC, &rect);

        // if the object is open, draw a hatch rect.
        if (m_fObjectOpen)
                {
                HBRUSH hBrush = CreateHatchBrush ( HS_BDIAGONAL, RGB(0,0,0) );
                HBRUSH hOldBrush = SelectObject (hDC, hBrush);
                SetROP2(hDC, R2_MASKPEN);
                Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom);
                SelectObject(hDC, hOldBrush);
                DeleteObject(hBrush);
                }

        // if we created a palette, restore the old one, and destroy
        // the object.
        if (hPal)
                {
                SelectPalette(hDC,hOldPal,FALSE);
                DeleteObject(hPal);
                }

        // if a view pointer was successfully returned, it needs to be released.
        if (lpView)
                lpView->Release();
}

//**********************************************************************
//
// CSimpleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
// Return Value:
//
// Function Calls:
//      Function                        Location
//
//      XformWidthInHimetricToPixels    OUTLUI Function
//      XformHeightInHimetricToPixels   OUTLUI Function
//
// Comments:
//
//********************************************************************

void CSimpleSite::GetObjRect(LPRECT lpRect)
{
        // convert it to pixels
        lpRect->left = lpRect->top = 0;
        lpRect->right = XformWidthInHimetricToPixels(NULL,(int)m_sizel.cx);
        lpRect->bottom = XformHeightInHimetricToPixels(NULL,(int)m_sizel.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\site.h ===
//**********************************************************************
// File name: SITE.H
//
//      Definition of CSimpleSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _SITE_H_ )
#define _SITE_H_

#include <ole2.h>
#include "ias.h"
#include "iocs.h"

class CSimpleDoc;

class CSimpleSite : public IUnknown
{
public:
        int m_nCount;
        LPOLEOBJECT m_lpOleObject;
        DWORD m_dwDrawAspect;
        SIZEL m_sizel;
        BOOL m_fObjectOpen;
        LPSTORAGE m_lpObjStorage;

        CAdviseSink m_AdviseSink;
        COleClientSite m_OleClientSite;

        CSimpleDoc FAR * m_lpDoc;

        // IUnknown Interfaces
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        HRESULT InitObject(BOOL fCreateNew);
        static CSimpleSite FAR * Create(CSimpleDoc FAR *lpDoc);
        CSimpleSite(CSimpleDoc FAR *lpDoc);
        ~CSimpleSite();
        void PaintObj(HDC hDC);
        void GetObjRect(LPRECT lpRect);
        void CloseOleObject(void);
        void UnloadOleObject(void);
};

#endif  // _SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpSvrApp
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

class CSimpSvrDoc;
interface CClassFactory;

class CSimpSvrApp : public IUnknown
{
private:

	int m_nCount;               // reference count
	HWND m_hAppWnd;             // main window handle
	HINSTANCE m_hInst;          // application instance
	BOOL m_fStartByOle;         // TRUE if app started by OLE
	DWORD m_dwRegisterClass;    // returned by RegisterClassFactory

	HMENU m_hMainMenu;
	HMENU m_hColorMenu;
	HMENU m_hHelpMenu;


	LPOLEOBJECT m_OleObject;    // pointer to "dummy" object


	CSimpSvrDoc FAR * m_lpDoc;   // pointer to document object
	BOOL m_fInitialized;         // OLE initialization flag

	RECT nullRect;               // used in inplace negotiation

public:
	// IUnknown Interfaces
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Initialization methods

	CSimpSvrApp();           // Constructor
	~CSimpSvrApp();          // Destructor


	BOOL fInitApplication (HANDLE hInstance);
	BOOL fInitInstance (HANDLE hInstance, int nCmdShow, CClassFactory FAR * lpClassFactory);

	// Message handling methods

	long lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	void PaintApp(HDC hDC);

	//  Utility functions
	void ParseCmdLine(LPSTR lpCmdLine);
	void SetStatusText();
	BOOL IsInPlaceActive();
	void ShowAppWnd(int nCmdShow=SW_SHOWNORMAL);
	void HideAppWnd();


	// member variable access
	inline HWND GethAppWnd() { return m_hAppWnd; };
	inline HINSTANCE GethInst() { return m_hInst; };
	inline BOOL IsStartedByOle() { return m_fStartByOle; };
	inline BOOL IsInitialized() { return m_fInitialized; };
	inline DWORD GetRegisterClass() { return m_dwRegisterClass; };
	inline CSimpSvrDoc FAR * GetDoc() { return m_lpDoc; };
	inline void ClearDoc() { m_lpDoc = NULL; };
	inline LPOLEOBJECT GetOleObject() { return m_OleObject; };
		inline HMENU GetMainMenu() { return m_hMainMenu; };
	inline HMENU GetColorMenu() { return m_hColorMenu; };
	inline HMENU GetHelpMenu() { return m_hHelpMenu; } ;


	friend interface CClassFactory;  // make the contained class a friend
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpdnd\tests.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       tests.cpp
//
//  Contents:   Implementations of the Upper Layer unit tests
//
//  Classes:
//
//  Functions:  StartTest1
//
//  History:    dd-mmm-yy Author    Comment
//              07-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>

#ifdef WIN32
const CLSID CLSID_SimpleServer = {0xbcf6d4a0, 0xbe8c, 0x1068, { 0xb6, 0xd4,
        0x00, 0xdd, 0x01, 0x0c, 0x05, 0x09 }};
#else
const CLSID CLSID_SimpleServer = {0x9fb878d0, 0x6f88, 0x101b, { 0xbc, 0x65,
        0x00, 0x00, 0x0b, 0x65, 0xc7, 0xa6 }};
#endif



const CLSID CLSID_Paintbrush = {0x0003000a, 0, 0, { 0xc0, 0,0,0,0,0,0,0x46 }};

//+-------------------------------------------------------------------------
//
//  Function:   StartTest1
//
//  Synopsis:   Starts unit test1, inserting a simple server object into
//              this (simpdnd) container.
//
//  Effects:
//
//  Arguments:  pApp    -- a pointer to the CSimpleApp that we're a part of
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              07-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartTest1( CSimpleApp *pApp )
{
        HRESULT hresult;
        static FORMATETC formatetc;

        //insert the simple server object

        formatetc.dwAspect = DVASPECT_CONTENT;
        formatetc.cfFormat = NULL;
        formatetc.lindex = -1;

        //need to create the client site

        pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

        hresult = OleCreate(CLSID_SimpleServer, IID_IOleObject,
                OLERENDER_DRAW, &formatetc,
                &pApp->m_lpDoc->m_lpSite->m_OleClientSite,
                pApp->m_lpDoc->m_lpSite->m_lpObjStorage,
                (void **)&(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

        if( hresult != NOERROR )
        {
                goto errRtn;
        }

        //initialize the object

        hresult = pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

        if( hresult == NOERROR )
        {
                //tell it to paint itself, then we'll quit
                PostMessage(pApp->m_lpDoc->m_hDocWnd, WM_PAINT, 0L, 0L);
                PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_SUCCESS,
                (LPARAM)hresult);
                PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                return;
        }

errRtn:
        PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_FAILURE,
                (LPARAM)hresult);
        PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
        return;
}


//+-------------------------------------------------------------------------
//
//  Function:   StartTest2
//
//  Synopsis:   Starts unit Test2, inserting a paintbrush object into
//              this (simpdnd) container.
//
//  Effects:
//
//  Arguments:  pApp    -- a pointer to the CSimpleApp that we're a part of
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kevinro & alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartTest2( CSimpleApp *pApp )
{
        HRESULT hresult;
        static FORMATETC formatetc;

        //insert the simple server object

        formatetc.dwAspect = DVASPECT_CONTENT;
        formatetc.cfFormat = NULL;
        formatetc.lindex = -1;

        //need to create the client site

        pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

        hresult = OleCreate(CLSID_Paintbrush, IID_IOleObject,
                OLERENDER_DRAW, &formatetc,
                &pApp->m_lpDoc->m_lpSite->m_OleClientSite,
                pApp->m_lpDoc->m_lpSite->m_lpObjStorage,
                (void **)&(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

        if( hresult != NOERROR )
        {
                goto errRtn;
        }

        //initialize the object

        hresult = pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

        //
        // The DDE layer is going to ignore all of the parameters except
        // the verb index. The parameters here are mostly dummies.
        //
        if (hresult == NOERROR)
        {
                hresult = pApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(0,
                                NULL,
                                &(pApp->m_lpDoc->m_lpSite->m_OleClientSite),
                                -1,
                                NULL,
                                NULL);
        }

        if( hresult == NOERROR )
        {
                //tell it to paint itself, then we'll quit
                PostMessage(pApp->m_lpDoc->m_hDocWnd, WM_PAINT, 0L, 0L);
                PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_SUCCESS,
                (LPARAM)hresult);
                PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                return;
        }

errRtn:
        PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_FAILURE,
                (LPARAM)hresult);
        PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"
#include "icf.h"

#include "initguid.h"

#ifdef WIN32
DEFINE_GUID(GUID_SIMPLE, 0xBCF6D4A0, 0xBE8C, 0x1068, 0xB6, 0xD4, 0x00, 0xDD, 0x01, 0x0C, 0x05, 0x09);
#else
DEFINE_GUID(GUID_SIMPLE, 0x9fb878d0, 0x6f88, 0x101b, 0xbc, 0x65, 0x00, 0x00, 0x0b, 0x65, 0xc7, 0xa6);
#endif



//**********************************************************************
//
// CSimpSvrApp::CSimpSvrApp()
//
// Purpose:
//
//      Constructor for CSimpSvrApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//
//********************************************************************

CSimpSvrApp::CSimpSvrApp()
{
        TestDebugOut("In CSimpSvrApp's Constructor \r\n");

        // Set Ref Count
        m_nCount = 0;

        // clear members
        m_hAppWnd = NULL;
        m_hInst = NULL;
        m_lpDoc = NULL;

        // clear flags
        m_fInitialized = FALSE;

        // used for inplace
        SetRectEmpty(&nullRect);
}

//**********************************************************************
//
// CSimpSvrApp::~CSimpSvrApp()
//
// Purpose:
//
//      Destructor for CSimpSvrApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DestroyWindow               Windows API
//      CSimpSvrApp::IsInitialized  APP.H
//      OleUninitialize             OLE API
//
// Comments:
//
//********************************************************************

CSimpSvrApp::~CSimpSvrApp()
{
        TestDebugOut("In CSimpSvrApp's Destructor\r\n");

        // need to uninit the library...
        if (IsInitialized())
                OleUninitialize();

        DestroyWindow(m_hAppWnd);
}


//**********************************************************************
//
// CSimpSvrApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Application level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK          -   The interface is supported.
//      E_NOINTERFACE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IUnknown::AddRef            APP.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CSimpSvrApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CSimpSvrApp::QueryInterface\r\n");

        SCODE sc = S_OK;

        if (riid == IID_IUnknown)
                *ppvObj = this;
        else
                {
                *ppvObj = NULL;
                sc = E_NOINTERFACE;
                }

        if (*ppvObj)
                ((LPUNKNOWN)*ppvObj)->AddRef();

        // asking for something we don't understand at this level.
        return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrApp::AddRef()
{
        TestDebugOut("In CSimpSvrApp::AddRef\r\n");
        return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrApp::Release()
{
        TestDebugOut("In CSimpSvrApp::Release\r\n");

        if (--m_nCount == 0) {
                delete this;
        return 0;
    }

        return m_nCount;
}

//**********************************************************************
//
// CSimpSvrApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//      RegisterHatchWindowClass    OUTLUI.DLL
//
// Comments:
//
//********************************************************************

BOOL CSimpSvrApp::fInitApplication(HANDLE hInstance)
{
        WNDCLASS  wc;

        // Fill in window class structure with parameters that describe the
        // main window.

        wc.style = NULL;                    // Class style(s).
        wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                                                                // windows of this class.
        wc.cbClsExtra = 0;                  // No per-class extra data.
        wc.cbWndExtra = 0;                  // No per-window extra data.
        wc.hInstance = hInstance;           // Application that owns the class.
        wc.hIcon = LoadIcon(hInstance, "SimpSvr");
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  "SimpSvrMENU";    // Name of menu resource in .RC file.
        wc.lpszClassName = "SimpSvrWClass";  // Name used in call to CreateWindow.

        if (!RegisterClass(&wc))
                return FALSE;

        wc.style = CS_VREDRAW | CS_HREDRAW;                    // Class style(s).
        wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                                                                // windows of this class.
        wc.cbClsExtra = 0;                  // No per-class extra data.
        wc.cbWndExtra = 0;                  // No per-window extra data.
        wc.hInstance = hInstance;           // Application that owns the class.
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  NULL;
        wc.lpszClassName = "DocWClass";     // Name used in call to CreateWindow.

        // Register the window class and return success/failure code.

        if (!RegisterClass(&wc))
                return FALSE;

        return (RegisterHatchWindowClass(hInstance));
}

//**********************************************************************
//
// CSimpSvrApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      InvalidateRect              Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      CoRegisterClassObject       OLE API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//      CSimpSvrDoc::CreateObject   DOC.CPP
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpSvrApp::fInitInstance (HANDLE hInstance, int nCmdShow, CClassFactory FAR * lpClassFactory)
{
        m_hInst = hInstance;

                DWORD dwVer = OleBuildVersion();

        // check to see if we are compatible with this version of the libraries
        if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup)
                TestDebugOut("*** WARNING:  Not compatible with current libs ***\r\n");

        // initialize the libraries
        if (OleInitialize(NULL) == NOERROR)
                m_fInitialized = TRUE;


        // Create the "application" windows
        m_hAppWnd = CreateWindow ("SimpSvrWClass",
                                                          "Simple OLE 2.0 Server",
                                                          WS_OVERLAPPEDWINDOW,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          NULL,
                                                          NULL,
                                                          hInstance,
                                                          NULL);

        if (!m_hAppWnd)
                return FALSE;

        // if not started by OLE, then show the Window, and create a "fake" object, else
        // Register a pointer to IClassFactory so that OLE can instruct us to make an
        // object at the appropriate time.
        if (!m_fStartByOle)
                {
                ShowAppWnd(nCmdShow);
                m_lpDoc->CreateObject(IID_IOleObject, (LPVOID FAR *)&m_OleObject);
                InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                }
        else
                {
                lpClassFactory = new CClassFactory(this);

                // shouldn't pass an API an object with a zero ref count
                lpClassFactory->AddRef();

                CoRegisterClassObject(GUID_SIMPLE,(IUnknown FAR *)lpClassFactory, CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE, &m_dwRegisterClass);

                // remove artificial Ref. count
                lpClassFactory->Release();
                }

        m_hMainMenu = GetMenu(m_hAppWnd);
        m_hColorMenu = GetSubMenu(m_hMainMenu, 1);
        m_hHelpMenu = GetSubMenu(m_hMainMenu, 2);


        return m_fInitialized;
}

//**********************************************************************
//
// CSimpSvrApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      InvalidateRect                              Windows API
//      CSimpSvrDoc::InsertObject                   DOC.CPP
//      CSimpSvrObj::SetColor                       OBJ.CPP
//      CSimpSvrObj::RotateColor                    OBJ.CPP
//
// Comments:
//
//********************************************************************

long CSimpSvrApp::lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        switch (wParam) {
                // bring up the About box
                case IDM_ABOUT:
                        {
                        FARPROC lpProcAbout = MakeProcInstance((FARPROC)About, m_hInst);

                        DialogBox(m_hInst,               // current instance
                                        "AboutBox",                  // resource to use
                                        m_hAppWnd,                   // parent handle
                                        lpProcAbout);                // About() instance address

                        FreeProcInstance(lpProcAbout);
                        break;
                        }

                // exit the application
                case IDM_EXIT:
                        SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                        break;

                case IDM_RED:
                        m_lpDoc->GetObj()->SetColor (128, 0, 0);
                        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                        break;

                case IDM_GREEN:
                        m_lpDoc->GetObj()->SetColor (0,128, 0);
                        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                        break;

                case IDM_BLUE:
                        m_lpDoc->GetObj()->SetColor (0, 0, 128);
                        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                        break;

                case IDM_ROTATE:
                        m_lpDoc->GetObj()->RotateColor();
                        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                        break;

                default:
                        return (DefWindowProc(hWnd, message, wParam, lParam));
                   }   // end of switch
        return NULL;
}

//**********************************************************************
//
// CSimpSvrApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpSvrDoc::lResizeDoc      DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpSvrApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        GetClientRect(m_hAppWnd, &rect);
        return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpSvrApp::lCreateDoc
//                                                         d
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpSvrDoc::Create         DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpSvrApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        GetClientRect(hWnd, &rect);

        m_lpDoc = CSimpSvrDoc::Create(this, &rect, hWnd);

        return NULL;
}



//**********************************************************************
//
// CSimpSvrApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::PaintDoc        DOC.CPP
//
// Comments:
//
//
//********************************************************************

void CSimpSvrApp::PaintApp (HDC hDC)
{

        // if we supported multiple documents, we would enumerate
        // through each of the open documents and call paint.

        if (m_lpDoc)
                m_lpDoc->PaintDoc(hDC);

}

//**********************************************************************
//
// CSimpSvrApp::ParseCmdLine
//
// Purpose:
//
//      Determines if the app was started by OLE
//
//
// Parameters:
//
//      LPSTR lpCmdLine -   Pointer to the command line
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      lstrlen                     Windows API
//      lstrcmp                     Windows API
//
//
// Comments:
//
//      Parses the command line looking for the -Embedding or /Embedding
//      flag.
//
//********************************************************************

void CSimpSvrApp::ParseCmdLine(LPSTR lpCmdLine)
{
        char szTemp[255];

        m_fStartByOle = TRUE;

        ::ParseCmdLine (lpCmdLine, &m_fStartByOle, szTemp);
}

//**********************************************************************
//
// CSimpSvrApp::SetStatusText
//
// Purpose:
//
//      Blanks out the text in the status bar
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::SetStatusText  DOC.CPP
//
//
// Comments:
//
//
//********************************************************************

void CSimpSvrApp::SetStatusText()
{
        m_lpDoc->SetStatusText();
}


//**********************************************************************
//
// CSimpSvrApp::IsInPlaceActive
//
// Purpose:
//
//      Safely determines from the app level if currently inplace active.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      TRUE    - Inplace active
//      FALSE   - Not Inplace active
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::GetObject      OBJ.H
//      CSimpSvrObj:IsInPlaceActive OBJ.H
//
//
// Comments:
//
//
//********************************************************************

BOOL CSimpSvrApp::IsInPlaceActive()
{
        BOOL retval = FALSE;

        if (m_lpDoc)
                if (m_lpDoc->GetObj())
                        retval = m_lpDoc->GetObj()->IsInPlaceActive();

        return retval;
}

//**********************************************************************
//
// CSimpSvrApp::ShowAppWnd
//
// Purpose:
//
//      Shows the Application Window
//
// Parameters:
//
//      int nCmdShow    - Window State
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//      CoLockObjectExternal            OLE API
//
// Comments:
//
//********************************************************************

void CSimpSvrApp::ShowAppWnd(int nCmdShow)
{
        CoLockObjectExternal(this, TRUE, FALSE);
        ShowWindow (m_hAppWnd, nCmdShow);
        UpdateWindow (m_hAppWnd);
}

//**********************************************************************
//
// CSimpSvrApp::ShowAppWnd
//
// Purpose:
//
//      Hides the Application Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      CoLockObjectExternal            OLE API
//
// Comments:
//
//********************************************************************

void CSimpSvrApp::HideAppWnd()
{
        CoLockObjectExternal(this, FALSE, TRUE);
        ShowWindow (m_hAppWnd, SW_HIDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpSvrDoc
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

class CSimpSvrApp;
class CSimpSvrObj;

class CSimpSvrDoc : IUnknown
{
private:
	int m_nCount;

	CSimpSvrApp FAR * m_lpApp;
	CSimpSvrObj FAR * m_lpObj;

	HWND m_hDocWnd;
	HWND m_hHatchWnd;
	BOOL m_fClosing;

public:
	static CSimpSvrDoc FAR * Create(CSimpSvrApp FAR *lpApp, LPRECT lpRect,HWND hWnd);

	CSimpSvrDoc();
	CSimpSvrDoc(CSimpSvrApp FAR *lpApp, HWND hWnd);
	~CSimpSvrDoc();

// IUnknown Interfaces
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	long lResizeDoc(LPRECT lpRect);
	long lAddVerbs();

	BOOL Load(LPSTR lpszFileName);
	void PaintDoc(HDC hDC);
	void lButtonDown(WPARAM wParam,LPARAM lParam);

	HRESULT CreateObject(REFIID riid, LPVOID FAR *ppvObject);

	void Close();
	void SetStatusText();
	void ShowDocWnd();
	void ShowHatchWnd();
	void CSimpSvrDoc::HideDocWnd();
	void CSimpSvrDoc::HideHatchWnd();

// member access
	inline HWND GethDocWnd() { return m_hDocWnd; };
	inline HWND GethHatchWnd() { return m_hHatchWnd; };
	inline HWND GethAppWnd() { return m_lpApp->GethAppWnd(); };
	inline CSimpSvrApp FAR * GetApp() { return m_lpApp; };
	inline CSimpSvrObj FAR * GetObj() { return m_lpObj; };
	inline void ClearObj() { m_lpObj = NULL; };

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\icf.h ===
//**********************************************************************
// File name: icf.h
//
//      Definition of CClassFactory
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _ICF_H_)
#define _ICF_H_

class CSimpSvrApp;

interface CClassFactory :  IClassFactory
{
private:
	int m_nCount;               // reference count
	CSimpSvrApp FAR * m_lpApp;

public:
	CClassFactory::CClassFactory(CSimpSvrApp FAR * lpApp)
		{
		TestDebugOut("In CClassFactory's Constructor\r\n");
		m_lpApp = lpApp;
		m_nCount = 0;
		};
	CClassFactory::~CClassFactory()
	   {
	   TestDebugOut("In CClassFactory's Destructor\r\n");
	   };

	// IUnknown Methods

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP CreateInstance (LPUNKNOWN pUnkOuter,
							  REFIID riid,
							  LPVOID FAR* ppvObject);
	STDMETHODIMP LockServer ( BOOL fLock);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\icf.cpp ===
//**********************************************************************
// File name: ICF.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See icf.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "app.h"
#include "doc.h"
#include "icf.h"

//**********************************************************************
//
// CClassFactory::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrApp::QueryInterface APP.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CClassFactory::QueryInterface  ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CClassFactory::QueryInterface\r\n");

	SCODE sc = S_OK;

	if ( (riid == IID_IUnknown) ||
		 (riid == IID_IClassFactory) )
		*ppvObj = this;
	else
		{
		*ppvObj = NULL;
		sc = E_NOINTERFACE;
		}

	if (*ppvObj)
		((LPUNKNOWN)*ppvObj)->AddRef();

	// pass it on to the Application object
	return ResultFromScode(sc);
};

//**********************************************************************
//
// CClassFactory::AddRef
//
// Purpose:
//
//      Increments the reference count on CClassFactory and the application
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on CClassFactory
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP_(ULONG) CClassFactory::AddRef ()
{
	TestDebugOut("In CClassFactory::AddRef\r\n");

	return ++m_nCount;
};

//**********************************************************************
//
// CClassFactory::Release
//
// Purpose:
//
//      Decrements the reference count of CClassFactory and the
//      application object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP_(ULONG) CClassFactory::Release ()
{
	TestDebugOut("In CClassFactory::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
        return 0;
    }

	return m_nCount;
};


//**********************************************************************
//
// CClassFactory::CreateInstance
//
// Purpose:
//
//      Instantiates a new OLE object
//
// Parameters:
//
//      LPUNKNOWN pUnkOuter     - Pointer to the controlling unknown
//
//      REFIID riid             - The interface type to fill in ppvObject
//
//      LPVOID FAR* ppvObject   - Out pointer for the object
//
// Return Value:
//
//      S_OK                    - Creation was successful
//      CLASS_E_NOAGGREGATION   - Tried to be created as part of an aggregate
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::CreateObject   DOC.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CClassFactory::CreateInstance ( LPUNKNOWN pUnkOuter,
							  REFIID riid,
							  LPVOID FAR* ppvObject)
{
	HRESULT hErr;

	TestDebugOut("In CClassFactory::CreateInstance\r\n");

	// need to NULL the out parameter
	*ppvObject = NULL;

	// we don't support aggregation...
	if (pUnkOuter)
		{
		hErr = ResultFromScode(CLASS_E_NOAGGREGATION);
		goto error;
		}

	hErr = m_lpApp->m_lpDoc->CreateObject(riid, ppvObject);

error:
	return hErr;
};

//**********************************************************************
//
// CClassFactory::LockServer
//
// Purpose:
//
//
// Parameters:
//
//      BOOL fLock      - TRUE to lock the server, FALSE to unlock it
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CoLockObjectExternal        OLE API
//      ResultFromScode             OLE API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CClassFactory::LockServer ( BOOL fLock)
{
	TestDebugOut("In CClassFactory::LockServer\r\n");
	CoLockObjectExternal(m_lpApp, fLock, TRUE);

	return ResultFromScode( S_OK);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpSvrDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CSimpSvrDoc::Create
//
// Purpose:
//
//      Creation for the CSimpSvrDoc Class
//
// Parameters:
//
//      CSimpSvrApp FAR * lpApp  -   Pointer to the CSimpSvrApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      CSimpSvrDoc::CSimpSvrDoc    DOC.CPP
//      CreateHatchWindow           OLE2UI
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpSvrDoc FAR * CSimpSvrDoc::Create(CSimpSvrApp FAR *lpApp, LPRECT lpRect,HWND hWnd)
{
	CSimpSvrDoc FAR * lpTemp = new CSimpSvrDoc(lpApp, hWnd);

	if (!lpTemp)
		return NULL;

	// create the document Window
	lpTemp->m_hDocWnd = CreateWindow(
			"DocWClass",
			NULL,
			WS_CHILD | WS_CLIPSIBLINGS,
			lpRect->left,
			lpRect->top,
			lpRect->right,
			lpRect->bottom,
			hWnd,
			NULL,
			lpApp->GethInst(),
			NULL);

	if (!lpTemp->m_hDocWnd)
		goto error;

	lpTemp->ShowDocWnd();

	lpTemp->m_hHatchWnd = CreateHatchWindow( lpTemp->m_hDocWnd, lpApp->GethInst());

	lpTemp->HideHatchWnd();

	return (lpTemp);

error:
	delete (lpTemp);
	return NULL;

}

//**********************************************************************
//
// CSimpSvrDoc::CSimpSvrDoc
//
// Purpose:
//
//      Constructor for the CSimpSvrDoc Class
//
// Parameters:
//
//      CSimpSvrApp FAR * lpApp  -   Pointer to the CSimpSvrApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
// Comments:
//
//********************************************************************

CSimpSvrDoc::CSimpSvrDoc(CSimpSvrApp FAR * lpApp,HWND hWnd)
{
	TestDebugOut("In CSimpSvrDoc's Constructor\r\n");
	m_lpApp = lpApp;
	m_nCount = 0;
	m_lpObj = NULL;
	m_fClosing = FALSE;

	// set up menu handles


}

//**********************************************************************
//
// CSimpSvrDoc::~CSimpSvrDoc
//
// Purpose:
//
//      Destructor for CSimpSvrDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DestroyWindow               Windows API
//      CSimpSvrApp::ClearDoc       APP.CPP
//
// Comments:
//
//********************************************************************

CSimpSvrDoc::~CSimpSvrDoc()
{
	TestDebugOut("In CSimpSvrDoc's Destructor\r\n");
	m_lpApp->ClearDoc();
	DestroyWindow(m_hHatchWnd);
}


//**********************************************************************
//
// CSimpSvrDoc::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      E_NOINTERFACE -   Always
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::QueryInterface APP.CPP
//
// Comments:
//
//      Since the document could contain multiple objects, all
//      interfaces except those associated with the document should
//      be returned.  In this implementation, there are no doc level
//      interfaces.
//
//********************************************************************

STDMETHODIMP CSimpSvrDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CSimpSvrDoc::QueryInterface\r\n");

	SCODE sc = E_NOINTERFACE;

	if ( (riid == IID_IUnknown) )
	   {
	   AddRef();
	   *ppvObj = this;
	   sc = S_OK;
	   }

	return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrDoc::AddRef
//
// Purpose:
//
//      Increments the document level reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::AddRef         APP.CPP
//
// Comments:
//
//      The reference count at this level reflects the total ref.
//      count of all interfaces on all objects contained within
//      this document.  Note that it also "trickles up" the
//      ref count to the app level.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrDoc::AddRef()
{
	TestDebugOut("In CSimpSvrDoc::AddRef\r\n");
	// AddRef the app, but return the doc count
	m_lpApp->AddRef();

	return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrDoc::Release
//
// Purpose:
//
//      Decrements the document level reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::Release         APP.CPP
//
// Comments:
//
//      The reference count at this level reflects the total ref.
//      count of all interfaces on all objects contained within
//      this document.  Note that it also "trickles up" the
//      ref count to the app level.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrDoc::Release()
{
	TestDebugOut("In CSimpSvrDoc::Release\r\n");
	// Release the app, but return the app count
	m_lpApp->Release();

	if (--m_nCount == 0) {
		delete this;
        return 0;
    }

	return m_nCount;
}

//**********************************************************************
//
// CSimpSvrDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      MoveWindow                              Windows API
//
// Comments:
//
//********************************************************************

long CSimpSvrDoc::lResizeDoc(LPRECT lpRect)
{
	MoveWindow(m_hDocWnd, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, TRUE);
	return NULL;
}


//**********************************************************************
//
// CSimpSvrDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::Draw                   OBJ.CPP
//      CSimpSvrObj::GetDataAdviseHolder    OBJ.H
//      CSimpSvrObj::GetDataObject          OBJ.H
//      CSimpAppObj::IsStartedByOle         APP.CPP
//      IDataAdviseHolder::SendOnDataChange OLE API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::PaintDoc (HDC hDC)
{

	// if the object hasn't been created yet, then don't draw
	if (m_lpObj)
		m_lpObj->Draw(hDC,FALSE);
	else
		return;

	// Sending a data change every time we paint, but only if we
	// were started by OLE
	if (m_lpApp->IsStartedByOle())
			m_lpObj->SendOnDataChange( );
}



//**********************************************************************
//
// CSimpSvrDoc::CreateObject
//
// Purpose:
//
//
// Parameters:
//
//
// Return Value:
//
//      NOERROR if the function succeeds, otherwise E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::CSimpSvrObj    OBJ.CPP
//      CSimpSvrOjb::QueryInterface OBJ.CPP
//
// Comments:
//
//********************************************************************

HRESULT CSimpSvrDoc::CreateObject(REFIID riid, LPVOID FAR *ppvObject)
{
	SCODE sc = E_FAIL;

	m_lpObj = new CSimpSvrObj(this);

	if (m_lpObj)
		{
		m_lpObj->QueryInterface(riid, ppvObject);
		sc = S_OK;
		}

	return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrDoc::Close
//
// Purpose:
//
//      Closes the object
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpSvrObj::AddRef                     OBJ.CPP
//      CSimpSvrObj::Release                    OBJ.CPP
//      CSimpSvrObj::IsInPlaceActive            OBJ.H
//      CSimpSvrObj::GetOleInPlaceObject        OBJ.H
//      CSimpSvrObj::ClearOleClientSite         OBJ.H
//      CSimpSvrObj::GetDataAdviseHolder        OBJ.H
//      CSimpSvrObj::GetOleClientSite           OBJ.H
//      CSimpSvrObj::ClearDataAdviseHolder      OBJ.H
//      CSimpSvrObj::GetOleAdviseHolder         OBJ.H
//      CSimpSvrObj::ClearOleAdviseHolder       OBJ.H
//      IOleInPlaceObject::InPlaceDeactivate    Container
//      IOleClientSite::SaveObject              Container
//      IOleClientSite::OnShowWindow            Container
//      IOleClientSite::Release                 Container
//      IDataAdviseHolder::SendOnDataChange     OLE
//      IDataAdviseHolder::Release              OLE
//      IOleAdviseHolder::SendOnClose           OLE
//      IOleAdviseHolder::Release               OLE
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::Close()
{
	TestDebugOut("In CSimpSvrDoc::Close() \r\n");

	m_lpObj->AddRef(); // hold object alive

	if (m_fClosing)
		return;

	m_fClosing = TRUE;

	// if the object is currently inplace active, then deactivate
	if (m_lpObj->IsInPlaceActive())
		m_lpObj->GetOleInPlaceObject()->InPlaceDeactivate();

	// unregister from the ROT...
	if (m_lpObj->GetRotRegister())
		{
		LPRUNNINGOBJECTTABLE lpRot;

		if (GetRunningObjectTable (0, &lpRot) == NOERROR )
			{
			lpRot->Revoke(m_lpObj->GetRotRegister());
			lpRot->Release();
			}
		}

	// if we have a clientsite, instruct it to save the object
	if (m_lpObj->GetOleClientSite())
		{
		m_lpObj->GetOleClientSite()->SaveObject();
		m_lpObj->GetOleClientSite()->OnShowWindow(FALSE);
		}

	// Do a final SendOnDataChange for those containers that have specified the
	// ADF_DATAONSTOP flag.
	if (m_lpObj->GetDataAdviseHolder())
		{
		m_lpObj->GetDataAdviseHolder()->SendOnDataChange( m_lpObj->GetDataObject(), 0, ADVF_DATAONSTOP);
		m_lpObj->GetDataAdviseHolder()->Release();
		m_lpObj->ClearDataAdviseHolder();
		}


	// Tell the container that we are shutting down.
	if (m_lpObj->GetOleAdviseHolder())
		{
		m_lpObj->GetOleAdviseHolder()->SendOnClose();
		m_lpObj->GetOleAdviseHolder()->Release();
		m_lpObj->ClearOleAdviseHolder();
		}

	if (m_lpObj->GetOleClientSite())
		{
		m_lpObj->GetOleClientSite()->Release();
		m_lpObj->ClearOleClientSite();
		}

	// release our streams and storage
	m_lpObj->GetPersistStorage()->ReleaseStreamsAndStorage();

	// Disconnect the object.  NOTE: This call should not do anything
	// unless the container has cause a GP Fault or some other problem
	// has occured...
	TestDebugOut("*** Before CoDisconnectObject *** \r\n");
	CoDisconnectObject((LPUNKNOWN)m_lpObj, 0);
	TestDebugOut("*** After CoDisconnectObject *** \r\n");

	m_lpObj->Release(); // let object close

}


//**********************************************************************
//
// CSimpSvrDoc::SetStatusText
//
// Purpose:
//
//      Sets the Container's status bar text
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrObj::IsInPlaceActive    OBJ.CPP
//      IOleInPlaceFrame::SetStatusText Container
//
// Comments:
//
//      Even though there is no status line in this sample, this
//      method must be called on WM_MENUSELECT to clear the last
//      message in the status line.
//
//********************************************************************

void CSimpSvrDoc::SetStatusText()
{
	if (m_lpObj->IsInPlaceActive())
		m_lpObj->GetInPlaceFrame()->SetStatusText("\0");
}

//**********************************************************************
//
// CSimpSvrDoc::ShowDocWnd
//
// Purpose:
//
//      Shows the Document Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::ShowDocWnd()
{
	ShowWindow(m_hDocWnd, SW_SHOWNORMAL);  // Show the window
	UpdateWindow(m_hDocWnd);               // Sends WM_PAINT message
}

//**********************************************************************
//
// CSimpSvrDoc::ShowHatchWnd
//
// Purpose:
//
//      Shows the hatch Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::ShowHatchWnd()
{
	ShowWindow(m_hHatchWnd, SW_SHOW);
}

//**********************************************************************
//
// CSimpSvrDoc::HideDocWnd
//
// Purpose:
//
//      Hides the DocumentWindow
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::HideDocWnd()
{
	ShowWindow(m_hDocWnd, SW_HIDE);
}

//**********************************************************************
//
// CSimpSvrDoc::HideHatchWnd
//
// Purpose:
//
//      Hides the Hatch Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::HideHatchWnd()
{
	ShowWindow(m_hHatchWnd, SW_HIDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ido.cpp ===
//**********************************************************************
// File name: IDO.CPP
//
//    Implementation file for the CDataObject Class
//
// Functions:
//
//    See ido.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ido.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CDataObject::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CDataObject::QueryInterface\r\n");

	return m_lpObj->QueryInterface(riid, ppvObj);
};

//**********************************************************************
//
// CDataObject::AddRef
//
// Purpose:
//
//      Increments the reference count on CClassFactory and the application
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on CDataObject
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataObject::AddRef ()
{
	TestDebugOut("In CDataObject::AddRef\r\n");
	++m_nCount;
	return m_lpObj->AddRef();
};

//**********************************************************************
//
// CDataObject::Release
//
// Purpose:
//
//      Decrements the reference count of CDataObject
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP_(ULONG) CDataObject::Release ()
{
	TestDebugOut("In CDataObject::Release\r\n");
	--m_nCount;
	return m_lpObj->Release();
};

//**********************************************************************
//
// CDataObject::QueryGetData
//
// Purpose:
//
//      Called to determine if our object supports a particular
//      FORMATETC.
//
// Parameters:
//
//      LPFORMATETC pformatetc  - Pointer to the FORMATETC being queried for.
//
// Return Value:
//
//      DATA_E_FORMATETC    - The FORMATETC is not supported
//      S_OK                - The FORMATETC is supported.
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::QueryGetData  ( LPFORMATETC pformatetc )
{
	SCODE sc = DATA_E_FORMATETC;

	TestDebugOut("In CDataObject::QueryGetData\r\n");

	// check the validity of the formatetc.
	if ( (pformatetc->cfFormat == CF_METAFILEPICT)  &&
		 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
		 (pformatetc->tymed == TYMED_MFPICT) )
		sc = S_OK;

	return ResultFromScode(sc);
};

//**********************************************************************
//
// CDataObject::DAdvise
//
// Purpose:
//
//      Called by the container when it would like to be notified of
//      changes in the object data.
//
// Parameters:
//
//      FORMATETC FAR* pFormatetc   - The format the container is interested in.
//
//      DWORD advf                  - The type of advise to be set up.
//
//      LPADVISESINK pAdvSink       - Pointer to the containers IAdviseSink
//
//      DWORD FAR* pdwConnection    - Out parameter to return a unique connection id.
//
// Return Value:
//
//      passed on from IDataAdviseHolder
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateDataAdviseHolder      OLE API
//      IDataAdviseHolder::Advise   OLE API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
									 LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
	TestDebugOut("In CDataObject::DAdvise\r\n");

	// if no DataAdviseHolder has been created, then create one.
	if (!m_lpObj->m_lpDataAdviseHolder)
		CreateDataAdviseHolder(&m_lpObj->m_lpDataAdviseHolder);

	// pass on to the DataAdviseHolder
	return m_lpObj->m_lpDataAdviseHolder->Advise( this, pFormatetc, advf,
												  pAdvSink, pdwConnection);
}

//**********************************************************************
//
// CDataObject::GetData
//
// Purpose:
//
//      Returns the data in the format specified in pformatetcIn.
//
// Parameters:
//
//      LPFORMATETC pformatetcIn    -   The format requested by the caller
//
//      LPSTGMEDIUM pmedium         -   The medium requested by the caller
//
// Return Value:
//
//      DATA_E_FORMATETC    - Format not supported
//      S_OK                - Success
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CSimpSvrObj::GetMetaFilePict()  OBJ.CPP
//      ResultFromScode                 OLE API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::GetData  ( LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{
	SCODE sc = DATA_E_FORMATETC;

	TestDebugOut("In CDataObject::GetData\r\n");

	// Check to the FORMATETC and fill pmedium if valid.
	if ( (pformatetcIn->cfFormat == CF_METAFILEPICT)  &&
		 (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
		 (pformatetcIn->tymed & TYMED_MFPICT) )
		{
		HANDLE hmfPict = m_lpObj->GetMetaFilePict();
		pmedium->tymed = TYMED_MFPICT;
		pmedium->hGlobal = hmfPict;
		pmedium->pUnkForRelease = NULL;
		sc = S_OK;
		}

	return ResultFromScode( sc );
};

//**********************************************************************
//
// CDataObject::DUnadvise
//
// Purpose:
//
//      Breaks down an Advise connection.
//
// Parameters:
//
//      DWORD dwConnection  - Advise connection ID.
//
// Return Value:
//
//      Returned from the DataAdviseHolder.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IDataAdviseHolder::Unadvise OLE
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::DUnadvise  ( DWORD dwConnection)
{
	TestDebugOut("In CDataObject::DUnadvise\r\n");

	if (m_lpObj != NULL && m_lpObj->m_lpDataAdviseHolder != NULL)
	{
	    return m_lpObj->m_lpDataAdviseHolder->Unadvise(dwConnection);
	}
	
	return ResultFromScode( E_UNEXPECTED);


};

//**********************************************************************
//
// CDataObject::GetDataHere
//
// Purpose:
//
//      Called to get a data format in a caller supplied location
//
// Parameters:
//
//      LPFORMATETC pformatetc  - FORMATETC requested
//
//      LPSTGMEDIUM pmedium     - Medium to return the data
//
// Return Value:
//
//      DATA_E_FORMATETC    - We don't support the requested format
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      In this simple implementation, we don't really support this
//      method, we just always return DATA_E_FORMATETC.
//
//********************************************************************


STDMETHODIMP CDataObject::GetDataHere  ( LPFORMATETC pformatetc,
										 LPSTGMEDIUM pmedium )
{
	TestDebugOut("In CDataObject::GetDataHere\r\n");
	return ResultFromScode( DATA_E_FORMATETC);
};

//**********************************************************************
//
// CDataObject::GetCanonicalFormatEtc
//
// Purpose:
//
//      Returns a FORMATETC that is equivalent to the one passed in.
//
// Parameters:
//
//      LPFORMATETC pformatetc      - FORMATETC to be tested.
//
//      LPFORMATETC pformatetcOut   - Out ptr for returned FORMATETC.
//
// Return Value:
//
//      DATA_S_SAMEFORMATETC    - Use the same formatetc as was passed.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CoGetMalloc                 OLE API
//      IMalloc::Alloc              OLE
//      IMalloc::Release            OLE
//      _fmemcpy                    C run-time
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
												   LPFORMATETC pformatetcOut)
{
	HRESULT hresult;
	TestDebugOut("In CDataObject::GetCanonicalFormatEtc\r\n");

	if (!pformatetcOut)
		return ResultFromScode(E_INVALIDARG);

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	pformatetcOut->ptd = NULL;

	if (!pformatetc)
		return ResultFromScode(E_INVALIDARG);

	// OLE2NOTE: we must validate that the format requested is supported
	if ((hresult = QueryGetData(pformatetc)) != NOERROR)
		return hresult;

	/* OLE2NOTE: an app that is insensitive to target device (as
	**    SimpSvr is) should fill in the lpformatOut parameter
	**    but NULL out the "ptd" field; it should return NOERROR if the
	**    input formatetc->ptd what non-NULL. this tells the caller
	**    that it is NOT necessary to maintain a separate screen
	**    rendering and printer rendering. if should return
	**    DATA_S_SAMEFORMATETC if the input and output formatetc's are
	**    identical.
	*/

	*pformatetcOut = *pformatetc;
	if (pformatetc->ptd == NULL)
		return ResultFromScode(DATA_S_SAMEFORMATETC);
	else
		{
		pformatetcOut->ptd = NULL;
		return NOERROR;
		}
};

//**********************************************************************
//
// CDataObject::SetData
//
// Purpose:
//
//      Called to set the data for the object.
//
// Parameters:
//
//      LPFORMATETC pformatetc      - the format of the data being passed
//
//      STGMEDIUM FAR * pmedium     - the location of the data.
//
//      BOOL fRelease               - Defines the ownership of the medium
//
// Return Value:
//
//      DATA_E_FORMATETC    - Not a valid FORMATETC for this object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This simple object does not support having its data set, so an
//      error value is always returned.
//
//********************************************************************


STDMETHODIMP CDataObject::SetData  ( LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
									 BOOL fRelease)
{
	TestDebugOut("In CDataObject::SetData\r\n");
	return ResultFromScode( DATA_E_FORMATETC );
};

//**********************************************************************
//
// CDataObject::EnumFormatEtc
//
// Purpose:
//
//      Enumerates the formats supported by this object.
//
// Parameters:
//
//      DWORD dwDirection                       - Order of enumeration.
//
//      LPENUMFORMATETC FAR* ppenumFormatEtc    - Place to return a pointer
//                                                to the enumerator.
//
// Return Value:
//
//      OLE_S_USEREG    - Indicates that OLE should consult the REG DB
//                        to enumerate the formats.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::EnumFormatEtc  ( DWORD dwDirection,
										   LPENUMFORMATETC FAR* ppenumFormatEtc)
{
	TestDebugOut("In CDataObject::EnumFormatEtc\r\n");
	// need to NULL the out parameter
	*ppenumFormatEtc = NULL;
	return ResultFromScode( OLE_S_USEREG );
};

//**********************************************************************
//
// CDataObject::EnumDAdvise
//
// Purpose:
//
//      Returns an enumerator that enumerates all of the advises
//      set up on this data object.
//
// Parameters:
//
//      LPENUMSTATDATA FAR* ppenumAdvise    - An out ptr in which to
//                                            return the enumerator.
//
// Return Value:
//
//      Passed back from IDataAdviseHolder::EnumAdvise
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      IDAtaAdviseHolder::EnumAdvise   OLE
//
// Comments:
//
//      This just delegates to the DataAdviseHolder.
//
//********************************************************************


STDMETHODIMP CDataObject::EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
{
	TestDebugOut("In CDataObject::EnumDAdvise\r\n");
	// need to NULL the out parameter
	*ppenumAdvise = NULL;

	return m_lpObj->m_lpDataAdviseHolder->EnumAdvise(ppenumAdvise);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ido.h ===
//**********************************************************************
// File name: ido.h
//
//      Definition of CDataObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDO_H_)
#define _IDO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CDataObject : public IDataObject
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;

public:
	CDataObject::CDataObject(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		};

	CDataObject::~CDataObject() {};

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
					LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
	STDMETHODIMP DUnadvise  ( DWORD dwConnection);
	STDMETHODIMP EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise);
	STDMETHODIMP EnumFormatEtc  ( DWORD dwDirection,
								  LPENUMFORMATETC FAR* ppenumFormatEtc);
	STDMETHODIMP GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
										  LPFORMATETC pformatetcOut);
	STDMETHODIMP GetData  ( LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium );
	STDMETHODIMP GetDataHere  ( LPFORMATETC pformatetc, LPSTGMEDIUM pmedium );
	STDMETHODIMP QueryGetData  ( LPFORMATETC pformatetc );
	STDMETHODIMP SetData  ( LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
							BOOL fRelease);


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\iec.h ===
//**********************************************************************
// File name: iec.h
//
//      Definition of CExternalConnection
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IEC_H_)
#define _IEC_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CExternalConnection : public IExternalConnection
{
private:
	CSimpSvrObj FAR * m_lpObj;  // Ptr to object
	int m_nCount;               // Ref count
	DWORD m_dwStrong;           // Connection Count

public:
	CExternalConnection::CExternalConnection(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		m_dwStrong = 0;
		};

	CExternalConnection::~CExternalConnection() {};

	// *** IUnknown methods ***
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	// *** IExternalConnection methods ***
	STDMETHODIMP_(DWORD) AddConnection (DWORD extconn, DWORD reserved);
	STDMETHODIMP_(DWORD) ReleaseConnection (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\iec.cpp ===
//**********************************************************************
// File name: IEC.CPP
//
//    Implementation file for the CExternalConnection Class
//
// Functions:
//
//    See iec.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "iec.h"
#include "app.h"
#include "doc.h"


//**********************************************************************
//
// CExternalConnection::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CExternalConnection::QueryInterface (REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CExternalConnection::QueryInterface\r\n");

	return m_lpObj->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CExternalConnection::AddRef
//
// Purpose:
//
//      Increments the reference count on CExternalConnection and the "object"
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the Object.
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CExternalConnection::AddRef ()
{
	TestDebugOut("In CExternalConnection::AddRef\r\n");
	++m_nCount;
	return m_lpObj->AddRef();
};

//**********************************************************************
//
// CExternalConnection::Release
//
// Purpose:
//
//      Decrements the reference count of COleObject and the
//      "object" object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP_(ULONG) CExternalConnection::Release ()
{
	TestDebugOut("In CExternalConnection::Release\r\n");
	--m_nCount;
	return m_lpObj->Release();
};



//**********************************************************************
//
// CExternalConnection::AddConnection
//
// Purpose:
//
//      Called when another connection is made to the object.
//
// Parameters:
//
//      DWORD extconn   -   Type of connection
//
//      DWORD reserved  -   Reserved
//
// Return Value:
//
//      Strong connection count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(DWORD) CExternalConnection::AddConnection (DWORD extconn, DWORD reserved)
{
	TestDebugOut("In CExternalConnection::AddConnection\r\n");

	if (extconn & EXTCONN_STRONG)
		return ++m_dwStrong;

	return 0;
}

//**********************************************************************
//
// CExternalConnection::ReleaseConnection
//
// Purpose:
//
//      Called when a connection to the object is released.
//
// Parameters:
//
//      DWORD extconn               - Type of Connection
//
//      DWORD reserved              - Reserved
//
//      BOOL fLastReleaseCloses     - Close flag
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      COleObject::Close           IOO.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(DWORD) CExternalConnection::ReleaseConnection (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses)
{
	TestDebugOut("In CExternalConnection::ReleaseConnection\r\n");

	if (extconn & EXTCONN_STRONG)
		{
		DWORD dwSave = --m_dwStrong;

		if (!m_dwStrong && fLastReleaseCloses)
			m_lpObj->m_OleObject.Close(OLECLOSE_SAVEIFDIRTY);

		return dwSave;
		}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ioipao.cpp ===
//**********************************************************************
// File name: IOIPAO.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See ioipao.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioipao.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// COleInPlaceActiveObject::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In COleInPlaceActiveObject::QueryInterface\r\n");
	// need to NULL the out parameter
	return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceActiveObject::AddRef
//
// Purpose:
//
//      Increments the reference count on COleInPlaceActiveObject and the
//      "object" object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the "object" object.
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceActiveObject::AddRef ()
{
	TestDebugOut("In COleInPlaceActiveObject::AddRef\r\n");

	++m_nCount;

	return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleInPlaceActiveObject::Release
//
// Purpose:
//
//      Decrements the reference count of COleInPlaceActiveObject.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceActiveObject::Release ()
{
	TestDebugOut("In COleInPlaceActiveObject::Release\r\n");

	--m_nCount;

	return m_lpObj->Release();
}

//**********************************************************************
//
// COleInPlaceActiveObject::OnDocWindowActivate
//
// Purpose:
//
//      Called when the doc window (in an MDI App) is (de)activated.
//
// Parameters:
//
//      BOOL fActivate  - TRUE if activating, FALSE if deactivating
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceFrame::SetActiveObject   Container
//      CSimpSvrObject::AddFrameLevelUI     OBJ.CPP
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::OnDocWindowActivate  ( BOOL fActivate )
{
	TestDebugOut("In COleInPlaceActiveObject::OnDocWindowActivate\r\n");

	// Activating?
	if (fActivate)
		m_lpObj->AddFrameLevelUI();

	// No frame level tools to remove...

	return ResultFromScode(S_OK);
};

//**********************************************************************
//
// COleInPlaceActiveObject::OnFrameWindowActivate
//
// Purpose:
//
//      Called when the Frame window is (de)activating
//
// Parameters:
//
//      BOOL fActivate  - TRUE if activating, FALSE if Deactivating
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetFocus                    Windows API
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::OnFrameWindowActivate  ( BOOL fActivate)
{
	TestDebugOut("In COleInPlaceActiveObject::OnFrameWindowActivate\r\n");

	// set the focus to the object window if we are activating.
/*    if (fActivate)
		SetFocus(m_lpObj->m_lpDoc->GethDocWnd()); */

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceActiveObject::GetWindow
//
// Purpose:
//
//      Gets the objects Window Handle.
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::GethDocWnd     DOC.H
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::GetWindow  ( HWND FAR* lphwnd)
{
	TestDebugOut("In COleInPlaceActiveObject::GetWindow\r\n");
	// need to NULL the out parameter
	*lphwnd = m_lpObj->m_lpDoc->GethDocWnd();
	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceActiveObject::ContextSensitiveHelp
//
// Purpose:
//
//      Used to implement Context Sensitive help
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      See TECHNOTES.WRI include with the OLE SDK for proper
//      implementation of this function.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::ContextSensitiveHelp  ( BOOL fEnterMode )
{
	TestDebugOut("In COleInPlaceActiveObject::ContextSensitiveHelp\r\n");
	return ResultFromScode( E_NOTIMPL);
};

//**********************************************************************
//
// COleInPlaceActiveObject::TranslateAccelerator
//
// Purpose:
//
//      Used for translating accelerators in .DLL objects.
//
// Parameters:
//
//      LPMSG lpmsg - Pointer to a message
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      This method should never be called since we are implemented
//      in an executable.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::TranslateAccelerator  ( LPMSG lpmsg)
{
	TestDebugOut("In COleInPlaceActiveObject::TranslateAccelerator\r\n");
	// no accelerator table, return FALSE
	return ResultFromScode( S_FALSE );
};

//**********************************************************************
//
// COleInPlaceActiveObject::ResizeBorder
//
// Purpose:
//
//      Called when the border changes size.
//
// Parameters:
//
//      LPCRECT lprectBorder                - New Border
//
//      LPOLEINPLACEUIWINDOW lpUIWindow     - Pointer to UIWindow
//
//      BOOL fFrameWindow                   - True if lpUIWindow is the
//                                            frame window.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      Need to call SetBorderSpace again...
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::ResizeBorder  ( LPCRECT lprectBorder,
													  LPOLEINPLACEUIWINDOW lpUIWindow,
													  BOOL fFrameWindow)
{
	TestDebugOut("In COleInPlaceActiveObject::ResizeBorder\r\n");

	// should always have an inplace frame...
	m_lpObj->GetInPlaceFrame()->SetBorderSpace(NULL);

	// There will only be a UIWindow if in an MDI container
	if (m_lpObj->GetUIWindow())
		m_lpObj->GetUIWindow()->SetBorderSpace(NULL);

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceActiveObject::EnableModeless
//
// Purpose:
//
//      Called to enable/disable modeless dialogs.
//
// Parameters:
//
//      BOOL fEnable    - TRUE to enable, FALSE to disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      Called by the container when a model dialog box is added/removed
//      from the screen.  The appropriate action for a server application
//      is to disable/enable any modeless dialogs currently being displayed.
//      Since this application doesn't display any modeless dialogs,
//      this method is essentially ignored.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::EnableModeless  ( BOOL fEnable)
{
	TestDebugOut("In COleInPlaceActiveObject::EnableModeless\r\n");
	return ResultFromScode( S_OK );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ioipao.h ===
//**********************************************************************
// File name: IOIPAO.H
//
//      Definition of COleInPlaceActiveObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IOIPAO_H_)
#define _IOIPAO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleInPlaceActiveObject : public IOleInPlaceActiveObject
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;

public:
	COleInPlaceActiveObject::COleInPlaceActiveObject(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;     // set up the back ptr
		m_nCount = 0;            // clear the ref count.
		};
	COleInPlaceActiveObject::~COleInPlaceActiveObject() {};   // destructor

// IUnknown Methods

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP OnDocWindowActivate  ( BOOL fActivate) ;
	STDMETHODIMP OnFrameWindowActivate  ( BOOL fActivate) ;
	STDMETHODIMP GetWindow  ( HWND FAR* lphwnd);
	STDMETHODIMP ContextSensitiveHelp  ( BOOL fEnterMode);
	STDMETHODIMP TranslateAccelerator  ( LPMSG lpmsg);
	STDMETHODIMP ResizeBorder  ( LPCRECT lprectBorder,
								 LPOLEINPLACEUIWINDOW lpUIWindow,
								 BOOL fFrameWindow);
	STDMETHODIMP EnableModeless  ( BOOL fEnable);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ioipo.h ===
//**********************************************************************
// File name: ioipo.h
//
//      Definition of COleInPlaceObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IOIPO_H_)
#define _IOIPO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleInPlaceObject : public IOleInPlaceObject
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;

public:
	COleInPlaceObject::COleInPlaceObject(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		};
	COleInPlaceObject::~COleInPlaceObject() {};

//  IUnknown Methods
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP InPlaceDeactivate  ();
	STDMETHODIMP UIDeactivate  () ;
	STDMETHODIMP SetObjectRects  ( LPCRECT lprcPosRect, LPCRECT lprcClipRect);
	STDMETHODIMP GetWindow  ( HWND FAR* lphwnd) ;
	STDMETHODIMP ContextSensitiveHelp  ( BOOL fEnterMode);
	STDMETHODIMP ReactivateAndUndo  ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ioo.h ===
//**********************************************************************
// File name: ioo.h
//
//      Definition of COleObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOO_H_)
#define _IOO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleObject : public IOleObject
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;
	BOOL m_fOpen;

public:
	COleObject::COleObject(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		m_fOpen = FALSE;
		};
	COleObject::~COleObject()
		{
		};
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP SetClientSite (LPOLECLIENTSITE pClientSite);
	STDMETHODIMP Advise (LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
	STDMETHODIMP SetHostNames  ( LPCSTR szContainerApp, LPCSTR szContainerObj);
	STDMETHODIMP DoVerb  (  LONG iVerb,
							LPMSG lpmsg,
							LPOLECLIENTSITE pActiveSite,
							LONG lindex,
							HWND hwndParent,
							LPCRECT lprcPosRect);
	STDMETHODIMP GetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel);
	STDMETHODIMP Update  () ;
	STDMETHODIMP Close  ( DWORD dwSaveOption) ;
	STDMETHODIMP Unadvise ( DWORD dwConnection);
	STDMETHODIMP EnumVerbs  ( LPENUMOLEVERB FAR* ppenumOleVerb) ;
	STDMETHODIMP GetClientSite  ( LPOLECLIENTSITE FAR* ppClientSite);
	STDMETHODIMP SetMoniker  ( DWORD dwWhichMoniker, LPMONIKER pmk);
	STDMETHODIMP GetMoniker  ( DWORD dwAssign, DWORD dwWhichMoniker,
							   LPMONIKER FAR* ppmk);
	STDMETHODIMP InitFromData  ( LPDATAOBJECT pDataObject,
								 BOOL fCreation,
								 DWORD dwReserved);
	STDMETHODIMP GetClipboardData  ( DWORD dwReserved,
									 LPDATAOBJECT FAR* ppDataObject);
	STDMETHODIMP IsUpToDate  ();
	STDMETHODIMP GetUserClassID  ( CLSID FAR* pClsid);
	STDMETHODIMP GetUserType  ( DWORD dwFormOfType, LPSTR FAR* pszUserType);
	STDMETHODIMP SetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel);
	STDMETHODIMP EnumAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise);
	STDMETHODIMP GetMiscStatus  ( DWORD dwAspect, DWORD FAR* pdwStatus);
	STDMETHODIMP SetColorScheme  ( LPLOGPALETTE lpLogpal);

	void OpenEdit(LPOLECLIENTSITE pActiveSite);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ioo.cpp ===
//**********************************************************************
// File name: IOO.CPP
//
//    Implementation file for the COleObject Class
//
// Functions:
//
//    See ioo.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioo.h"
#include "app.h"
#include "doc.h"

#define VERB_OPEN 1

//**********************************************************************
//
// COleObject::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In COleObject::QueryInterface\r\n");
	return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleObject::AddRef
//
// Purpose:
//
//      Increments the reference count on COleObject and the "object"
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the Object.
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleObject::AddRef ()
{
	TestDebugOut("In COleObject::AddRef\r\n");
	++m_nCount;
	return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleObject::Release
//
// Purpose:
//
//      Decrements the reference count of COleObject and the
//      "object" object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleObject::Release ()
{
	TestDebugOut("In COleObject::Release\r\n");
	--m_nCount;
	return m_lpObj->Release();
}

//**********************************************************************
//
// COleObject::SetClientSite
//
// Purpose:
//
//      Called to notify the object of it's client site.
//
// Parameters:
//
//      LPOLECLIENTSITE pClientSite     - ptr to new client site
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IOleClientSite::Release     Container
//      IOleClientSite::AddRef      Container
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::SetClientSite  ( LPOLECLIENTSITE pClientSite)
{
	TestDebugOut("In COleObject::SetClientSite\r\n");

	// if we already have a client site, release it.
	if (m_lpObj->m_lpOleClientSite)
		{
		m_lpObj->m_lpOleClientSite->Release();
		m_lpObj->m_lpOleClientSite = NULL;
		}

	// store copy of the client site.
	m_lpObj->m_lpOleClientSite = pClientSite;

	// AddRef it so it doesn't go away.
	if (m_lpObj->m_lpOleClientSite)
		m_lpObj->m_lpOleClientSite->AddRef();

	return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleObject::Advise
//
// Purpose:
//
//      Called to set up an advise on the OLE object.
//
// Parameters:
//
//      LPADVISESINK pAdvSink       - ptr to the Advise Sink for notification
//
//      DWORD FAR* pdwConnection    - place to return the connection ID.
//
// Return Value:
//
//      Passed back from IOleAdviseHolder::Advise.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateOleAdviseHolder       OLE API
//      IOleAdviseHolder::Advise    OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::Advise ( LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
	TestDebugOut("In COleObject::Advise\r\n");

	// if we haven't made an OleAdviseHolder yet, make one.
	if (!m_lpObj->m_lpOleAdviseHolder)
		CreateOleAdviseHolder(&m_lpObj->m_lpOleAdviseHolder);

	// pass this call onto the OleAdviseHolder.
	return m_lpObj->m_lpOleAdviseHolder->Advise(pAdvSink, pdwConnection);
}

//**********************************************************************
//
// COleObject::SetHostNames
//
// Purpose:
//
//      Called to pass strings for Window titles.
//
// Parameters:
//
//      LPCSTR szContainerApp   -   ptr to string describing Container App
//
//      LPCSTR szContainerObj   -   ptr to string describing Object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This routine is called so that the server application can
//      set the window title appropriately.
//
//********************************************************************

STDMETHODIMP COleObject::SetHostNames  ( LPCSTR szContainerApp, LPCSTR szContainerObj)
{
	TestDebugOut("In COleObject::SetHostNames\r\n");

	return ResultFromScode( S_OK);
};

//**********************************************************************
//
// COleObject::DoVerb
//
// Purpose:
//
//      Called by the container application to invoke a verb.
//
// Parameters:
//
//      LONG iVerb                  - The value of the verb to be
//                                    invoked.
//
//      LPMSG lpmsg                 - The message that caused the
//                                    verb to be invoked.
//
//      LPOLECLIENTSITE pActiveSite - Ptr to the active client site.
//
//      LONG lindex                 - Used in extended layout
//
//      HWND hwndParent             - This should be the window handle of
//                                    the window in which we are contained.
//                                    This value could be used to "fake"
//                                    inplace activation in a manner similar
//                                    to Video for Windows in OLE 1.0.
//
//      LPCRECT lprcPosRect         - The rectangle that contains the object
//                                    within hwndParent.  Also used to
//                                    "fake" inplace activation.
//
// Return Value:
//
//      OLE_E_NOTINPLACEACTIVE      - Returned if attempted to undo while not
//                                    inplace active.
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      ShowWindow                          Windows API
//      CSimpSvrObj::DoInPlaceActivate      OBJ.CPP
//      CSimpSvrObj::DoInPlaceHide          OBJ.CPP
//      COleObject::OpenEdit                IOO.CPP
//      CSimpSvrDoc::GethDocWnd             DOC.H
//      COleInPlaceObj::InPlaceDeactivate   IOIPO.CPP
//
// Comments:
//
//      Be sure to look at TECHNOTES.WRI included with the OLE
//      SDK for a description of handling the inplace verbs
//      properly.
//
//********************************************************************

STDMETHODIMP COleObject::DoVerb  (  LONG iVerb,
									LPMSG lpmsg,
									LPOLECLIENTSITE pActiveSite,
									LONG lindex,
									HWND hwndParent,
									LPCRECT lprcPosRect)
{
	TestDebugOut("In COleObject::DoVerb\r\n");

	switch (iVerb)
		{
		case OLEIVERB_SHOW:
		case OLEIVERB_PRIMARY:
			if (m_fOpen)
				SetFocus(m_lpObj->m_lpDoc->GethAppWnd());
			else if (m_lpObj->DoInPlaceActivate(iVerb) == FALSE)
				OpenEdit(pActiveSite);
			break;

		case OLEIVERB_UIACTIVATE:
			if (m_fOpen)
				return ResultFromScode (E_FAIL);

			// inplace activate
			if (!m_lpObj->DoInPlaceActivate(iVerb))
				return ResultFromScode (E_FAIL);
			break;

		case OLEIVERB_DISCARDUNDOSTATE:
			// don't have to worry about this situation as we don't
			// support an undo state.
			if (!m_lpObj->m_fInPlaceActive)
				return ResultFromScode(OLE_E_NOT_INPLACEACTIVE);
			break;

		case OLEIVERB_HIDE:
			// if inplace active, do an "inplace" hide, otherwise
			// just hide the app window.
			if (m_lpObj->m_fInPlaceActive)
				{
				m_lpObj->DeactivateUI();
				m_lpObj->DoInPlaceHide();
				}
			else
				m_lpObj->m_lpDoc->GetApp()->HideAppWnd();
			break;

		case OLEIVERB_OPEN:
		case VERB_OPEN:
			// if inplace active, deactivate
			if (m_lpObj->m_fInPlaceActive)
				m_lpObj->m_OleInPlaceObject.InPlaceDeactivate();

			// open into another window.
			OpenEdit(pActiveSite);
			break;

		default:
			if (iVerb < 0)
				return ResultFromScode(E_FAIL);
		}

	return ResultFromScode( S_OK);
};

//**********************************************************************
//
// COleObject::GetExtent
//
// Purpose:
//
//      Returns the extent of the object.
//
// Parameters:
//
//      DWORD dwDrawAspect  - The aspect in which to get the size.
//
//      LPSIZEL lpsizel     - Out ptr to return the size.
//
// Return Value:
//
//
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      XformWidthInPixelsToHimetric    OLE2UI
//      XformHeightInPixelsToHimetric   OLE2UI
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	TestDebugOut("In COleObject::GetExtent\r\n");

	SCODE sc = E_FAIL;

	// Only DVASPECT_CONTENT is supported....
	if (dwDrawAspect == DVASPECT_CONTENT)
		{
		sc = S_OK;

		// return the correct size in HIMETRIC...
		lpsizel->cx = XformWidthInPixelsToHimetric(NULL, m_lpObj->m_size.x);
		lpsizel->cy = XformHeightInPixelsToHimetric(NULL, m_lpObj->m_size.y);
		}

	return ResultFromScode( sc );
};

//**********************************************************************
//
// COleObject::Update
//
// Purpose:
//
//      Called to get the most up to date data
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IDataAdviseHolder::SendOnDataChange OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::Update()
{
	TestDebugOut("In COleObject::Update\r\n");

	// force an update
	m_lpObj->SendOnDataChange();

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::Close
//
// Purpose:
//
//      Called when the OLE object needs to be closed
//
// Parameters:
//
//      DWORD dwSaveOption  - Flags to instruct the server how to prompt
//                            the user.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::Close          DOC.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::Close  ( DWORD dwSaveOption)
{
	TestDebugOut("In COleObject::Close\r\n");

	// delegate to the document object.
	m_lpObj->m_lpDoc->Close();

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::Unadvise
//
// Purpose:
//
//      Breaks down an OLE advise that has been set up on this object.
//
// Parameters:
//
//      DWORD dwConnection  - Connection that needs to be broken down
//
// Return Value:
//
//      Passed back from IOleAdviseHolder::Unadvise
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IOleAdviseHolder::Unadvise  OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::Unadvise ( DWORD dwConnection)
{
	TestDebugOut("In COleObject::Unadvise\r\n");

	// pass on to OleAdviseHolder.
	return m_lpObj->m_lpOleAdviseHolder->Unadvise(dwConnection);
};

//**********************************************************************
//
// COleObject::EnumVerbs
//
// Purpose:
//
//      Enumerates the verbs associated with this object.
//
// Parameters:
//
//      LPENUMOLEVERB FAR* ppenumOleVerb    - Out ptr in which to return
//                                            the enumerator
//
// Return Value:
//
//      OLE_S_USEREG    - Instructs OLE to use the verbs found in the
//                        REG DB for this server.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      In a .DLL, an application cannot return OLE_S_USEREG.  This is
//      due to the fact that the default object handler is not being
//      used, and the container is really making direct function calls
//      into the server .DLL.
//
//********************************************************************

STDMETHODIMP COleObject::EnumVerbs  ( LPENUMOLEVERB FAR* ppenumOleVerb)
{
	TestDebugOut("In COleObject::EnumVerbs\r\n");

	return ResultFromScode( OLE_S_USEREG );
};

//**********************************************************************
//
// COleObject::GetClientSite
//
// Purpose:
//
//      Called to get the current client site of the object.
//
// Parameters:
//
//      LPOLECLIENTSITE FAR* ppClientSite   - Out ptr in which to return the
//                                            client site.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetClientSite  ( LPOLECLIENTSITE FAR* ppClientSite)
{
	TestDebugOut("In COleObject::GetClientSite\r\n");
	*ppClientSite = m_lpObj->m_lpOleClientSite;
	return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::SetMoniker
//
// Purpose:
//
//      Used to set the objects moniker
//
// Parameters:
//
//      DWORD dwWhichMoniker    - Type of moniker being set
//
//      LPMONIKER pmk           - Pointer to the moniker
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::SetMoniker  ( DWORD dwWhichMoniker, LPMONIKER pmk)
{
	TestDebugOut("In COleObject::SetMoniker\r\n");

	LPMONIKER lpmk;

	if (! m_lpObj->GetOleClientSite())
		return ResultFromScode (E_FAIL);

	if (m_lpObj->GetOleClientSite()->GetMoniker (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, &lpmk) != NOERROR)
		return ResultFromScode (E_FAIL);


	if (m_lpObj->GetOleAdviseHolder())
		m_lpObj->GetOleAdviseHolder()->SendOnRename(lpmk);

	LPRUNNINGOBJECTTABLE lpRot;

	if (GetRunningObjectTable(0, &lpRot) == NOERROR)
		{
		if (m_lpObj->m_dwRegister)
			lpRot->Revoke(m_lpObj->m_dwRegister);

		lpRot->Register(0, m_lpObj, lpmk, &m_lpObj->m_dwRegister);

		lpRot->Release();
		}


	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::GetMoniker
//
// Purpose:
//
////
// Parameters:
//
//      DWORD dwAssign          - Assignment for the moniker
//
//      DWORD dwWhichMoniker    - Which moniker to return
//
//      LPMONIKER FAR* ppmk     - An out ptr to return the moniker
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetMoniker  (  DWORD dwAssign, DWORD dwWhichMoniker,
										LPMONIKER FAR* ppmk)
{
	TestDebugOut("In COleObject::GetMoniker\r\n");
	// need to NULL the out parameter
	*ppmk = NULL;

	return m_lpObj->GetOleClientSite()->GetMoniker (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, ppmk);
};

//**********************************************************************
//
// COleObject::InitFromData
//
// Purpose:
//
//      Initialize the object from the passed pDataObject.
//
// Parameters:
//
//      LPDATAOBJECT pDataObject    - Pointer to data transfer object
//                                    to be used in the initialization
//
//      BOOL fCreation              - TRUE if the object is currently being
//                                    created.
//
//      DWORD dwReserved            - Reserved
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      We don't support this functionality, so we will always return
//      error.
//
//********************************************************************

STDMETHODIMP COleObject::InitFromData  ( LPDATAOBJECT pDataObject,
										 BOOL fCreation,
										 DWORD dwReserved)
{
	TestDebugOut("In COleObject::InitFromData\r\n");

	return ResultFromScode( S_FALSE );
};

//**********************************************************************
//
// COleObject::GetClipboardData
//
// Purpose:
//
//      Returns an IDataObject that is the same as doing an OleSetClipboard
//
// Parameters:
//
//      DWORD dwReserved                - Reserved
//
//      LPDATAOBJECT FAR* ppDataObject  - Out ptr for the Data Object.
//
// Return Value:
//
//      OLE_E_NOTSUPPORTED
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Support of this method is optional.
//
//********************************************************************

STDMETHODIMP COleObject::GetClipboardData  ( DWORD dwReserved,
											 LPDATAOBJECT FAR* ppDataObject)
{
	TestDebugOut("In COleObject::GetClipboardData\r\n");
	// NULL the out ptr
	*ppDataObject = NULL;
	return ResultFromScode( E_NOTIMPL );
};

//**********************************************************************
//
// COleObject::IsUpToDate
//
// Purpose:
//
//      Determines if an object is up to date
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Our embedded object is always up to date.  This function is
//      particularly useful in linking situations.
//
//********************************************************************

STDMETHODIMP COleObject::IsUpToDate()
{
	TestDebugOut("In COleObject::IsUpToDate\r\n");
	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::GetUserClassID
//
// Purpose:
//
//      Returns the applications CLSID
//
// Parameters:
//
//      CLSID FAR* pClsid   - Out ptr to return the CLSID
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CPersistStorage::GetClassID IPS.CPP
//
// Comments:
//
//      This function is just delegated to IPS::GetClassID.
//
//********************************************************************

STDMETHODIMP COleObject::GetUserClassID  ( CLSID FAR* pClsid)
{
	TestDebugOut("In COleObject::GetUserClassID\r\n");

	m_lpObj->m_PersistStorage.GetClassID(pClsid);
	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::GetUserType
//
// Purpose:
//
//      Used to get a user presentable id for this object
//
// Parameters:
//
//      DWORD dwFormOfType      - The ID requested
//
//      LPSTR FAR* pszUserType  - Out ptr to return the string
//
// Return Value:
//
//      OLE_S_USEREG    - Use the reg db to get these entries.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetUserType  ( DWORD dwFormOfType, LPSTR FAR* pszUserType)
{
	TestDebugOut("In COleObject::GetUserType\r\n");

	return ResultFromScode( OLE_S_USEREG );
};

//**********************************************************************
//
// COleObject::SetExtent
//
// Purpose:
//
//      Called to set the extent of the object.
//
// Parameters:
//
//      DWORD dwDrawAspect  - Aspect to have its size set
//
//      LPSIZEL lpsizel     - New size of the object.
//
// Return Value:
//
//      E_NOTIMPL   - This function is not curently implemented.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::SetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	TestDebugOut("In COleObject::SetExtent\r\n");
	return ResultFromScode( E_NOTIMPL);
};

//**********************************************************************
//
// COleObject::EnumAdvise
//
// Purpose:
//
//      Returns an enumerate which enumerates the outstanding advises
//      associated with this OLE object.
//
// Parameters:
//
//      LPENUMSTATDATA FAR* ppenumAdvise - Out ptr in which to return
//                                         the enumerator.
//
// Return Value:
//
//      Passed on from IOleAdviseHolder::EnumAdvise.
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      IOleAdviseHolder::EnumAdvise    OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::EnumAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
{
	TestDebugOut("In COleObject::EnumAdvise\r\n");
	// need to NULL the out parameter
	*ppenumAdvise = NULL;

	// pass on to the OLE Advise holder.
	return m_lpObj->m_lpOleAdviseHolder->EnumAdvise(ppenumAdvise);
};

//**********************************************************************
//
// COleObject::GetMiscStatus
//
// Purpose:
//
//      Return status information about the object
//
// Parameters:
//
//      DWORD dwAspect          - Aspect interested in.
//
//      DWORD FAR* pdwStatus    - Out ptr in which to return the bits.
//
// Return Value:
//
//      CO_E_READREGDB  - Tell the library to use the reg DB.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetMiscStatus  ( DWORD dwAspect, DWORD FAR* pdwStatus)
{
	TestDebugOut("In COleObject::GetMiscStatus\r\n");
	// need to NULL the out parameter
	*pdwStatus = NULL;
	return ResultFromScode( OLE_S_USEREG );
};

//**********************************************************************
//
// COleObject::SetColorScheme
//
// Purpose:
//
//      Used to set the palette for the object to use.
//
// Parameters:
//
//      LPLOGPALETTE lpLogpal   - Pointer to the LOGPALETTE to be used.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This server ignores this method.
//
//********************************************************************

STDMETHODIMP COleObject::SetColorScheme  ( LPLOGPALETTE lpLogpal)
{
	TestDebugOut("In COleObject::SetColorScheme\r\n");
	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::OpenEdit
//
// Purpose:
//
//      Used to Open the object into a seperate window.
//
// Parameters:
//
//      LPOLECLIENTSITE pActiveSite - Pointer to the Active clientsite.
//
// Return Value:
//
//      None.
//
// Function Calls:
//      Function                        Location
//
//      IOleClientSite::OnShowWindow    Container
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//      TestDebugOut               Windows API
//      CSimpSvrDoc::GethAppWnd         DOC.H
//      CSimpSvrDoc::GethHatchWnd       DOC.H
//
// Comments:
//
//
//********************************************************************

void COleObject::OpenEdit(LPOLECLIENTSITE pActiveSite)
{
   if (m_lpObj->GetOleClientSite())
	   m_lpObj->GetOleClientSite()->ShowObject();


	m_fOpen = TRUE;

	// tell the site we are opening so the object can be hatched out.
	if (m_lpObj->GetOleClientSite())
		m_lpObj->GetOleClientSite()->OnShowWindow(TRUE);


	m_lpObj->m_lpDoc->ShowDocWnd();

	m_lpObj->m_lpDoc->HideHatchWnd();

	// Show app window.
	m_lpObj->m_lpDoc->GetApp()->ShowAppWnd();

	SetFocus(m_lpObj->m_lpDoc->GethAppWnd());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ips.cpp ===
//**********************************************************************
// File name: ips.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See ips.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ips.h"
#include "app.h"
#include "doc.h"

#include <storage.h>

#ifdef WIN32
DEFINE_GUID(GUID_SIMPLE, 0xBCF6D4A0, 0xBE8C, 0x1068, 0xB6, 0xD4, 0x00, 0xDD, 0x01, 0x0C, 0x05, 0x09);
#else
DEFINE_GUID(GUID_SIMPLE, 0x9fb878d0, 0x6f88, 0x101b, 0xbc, 0x65, 0x00, 0x00, 0x0b, 0x65, 0xc7, 0xa6);
#endif

//**********************************************************************
//
// CPersistStorage::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CPersistStorage::QueryInterface\r\n");
        // need to NULL the out parameter
        return m_lpObj->QueryInterface(riid, ppvObj);
};

//**********************************************************************
//
// CPersistStorage::AddRef
//
// Purpose:
//
//      Increments the reference count on CPersistStorage and the "object"
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the Object.
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CPersistStorage::AddRef ()
{
        TestDebugOut("In CPersistStorage::AddRef\r\n");
        ++m_nCount;
        return m_lpObj->AddRef();
};

//**********************************************************************
//
// CPersistStorage::Release
//
// Purpose:
//
//      Decrements the reference count of CPersistStorage and the
//      "object" object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CPersistStorage::Release ()
{
        TestDebugOut("In CPersistStorage::Release\r\n");
        --m_nCount;
        return m_lpObj->Release();
};

//**********************************************************************
//
// CPersistStorage::InitNew
//
// Purpose:
//
//      Used to give a new OLE object a ptr to its storage.
//
// Parameters:
//
//      LPSTORAGE pStg  - Pointer to the storage
//
// Return Value:
//
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//      IStorage::AddRef            OLE
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::InitNew (LPSTORAGE pStg)
{
        TestDebugOut("In CPersistStorage::InitNew\r\n");

        // release any streams and storages that may be open
        ReleaseStreamsAndStorage();

        m_lpObj->m_lpStorage = pStg;

        // AddRef the new Storage
        if (m_lpObj->m_lpStorage)
                m_lpObj->m_lpStorage->AddRef();

        CreateStreams(m_lpObj->m_lpStorage);

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// CPersistStorage::GetClassID
//
// Purpose:
//
//      Returns the CLSID of this object.
//
// Parameters:
//
//      LPCLSID lpClassID   - Out ptr in which to return the CLSID
//
// Return Value:
//
//       S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::GetClassID  ( LPCLSID lpClassID)
{
        TestDebugOut("In CPersistStorage::GetClassID\r\n");

        *lpClassID = GUID_SIMPLE;

        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::Save
//
// Purpose:
//
//      Instructs the object to save itself into the storage.
//
// Parameters:
//
//      LPSTORAGE pStgSave  - Storage in which the object should be saved
//
//      BOOL fSameAsLoad    - TRUE if pStgSave is the same as the storage
//                            that the object was originally created with.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CPersistStorage::InitNew    IPS.CPP
//      CSimpSvrObj::SaveToStorage  OBJ.CPP
//
//
// Comments:
//
//      A real app will want better error checking in this method.
//
//********************************************************************

STDMETHODIMP CPersistStorage::Save  ( LPSTORAGE pStgSave, BOOL fSameAsLoad)
{
        TestDebugOut("In CPersistStorage::Save\r\n");

        // save the data
        m_lpObj->SaveToStorage (pStgSave, fSameAsLoad);

        m_lpObj->m_fSaveWithSameAsLoad = fSameAsLoad;
        m_lpObj->m_fNoScribbleMode = TRUE;

        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::SaveCompleted
//
// Purpose:
//
//      Called when the container is finished saving the object
//
// Parameters:
//
//      LPSTORAGE pStgNew   - ptr to the new storage
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::SaveCompleted  ( LPSTORAGE pStgNew)
{
        TestDebugOut("In CPersistStorage::SaveCompleted\r\n");

        if (pStgNew)
                {
                ReleaseStreamsAndStorage();
                m_lpObj->m_lpStorage = pStgNew;
                m_lpObj->m_lpStorage->AddRef();
                OpenStreams(pStgNew);
                }


        /* OLE2NOTE: it is only legal to perform a Save or SaveAs operation
        **    on an embedded object. if the document is a file-based document
        **    then we can not be changed to a IStorage-base object.
        **
        **      fSameAsLoad   lpStgNew     Type of Save     Send OnSave
        **    ---------------------------------------------------------
        **         TRUE        NULL        SAVE             YES
        **         TRUE        ! NULL      SAVE *           YES
        **         FALSE       ! NULL      SAVE AS          YES
        **         FALSE       NULL        SAVE COPY AS     NO
        **
        **    * this is a strange case that is possible. it is inefficient
        **    for the caller; it would be better to pass lpStgNew==NULL for
        **    the Save operation.
        */

        if ( pStgNew || m_lpObj->m_fSaveWithSameAsLoad)
                {
                if (m_lpObj->m_fNoScribbleMode)
                        m_lpObj->GetOleAdviseHolder()->SendOnSave();  // normally would clear a
                                                                                                                  // dirty bit
                m_lpObj->m_fSaveWithSameAsLoad = FALSE;
                }

        m_lpObj->m_fNoScribbleMode = FALSE;

        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::Load
//
// Purpose:
//
//      Instructs the object to be loaded from storage.
//
// Parameters:
//
//      LPSTORAGE pStg  - Ptr to the storage in which to be loaded
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CSimpSvrObj::LoadFromStorage    OBJ.CPP
//
//
// Comments:
//
//      A real app will want better error checking in this method.
//
//********************************************************************

STDMETHODIMP CPersistStorage::Load  ( LPSTORAGE pStg)
{
        TestDebugOut("In CPersistStorage::Load\r\n");

        // remember the storage
        if (m_lpObj->m_lpStorage)
                {
                m_lpObj->m_lpStorage->Release();
                m_lpObj->m_lpStorage = NULL;
                }

        m_lpObj->m_lpStorage = pStg;

        m_lpObj->m_lpStorage->AddRef();

        OpenStreams(m_lpObj->m_lpStorage);

        m_lpObj->LoadFromStorage();


        return ResultFromScode( S_OK );
};


//**********************************************************************
//
// CPersistStorage::IsDirty
//
// Purpose:
//
//      Returns whether or not the object is dirty w/respect to its
//      Storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      This sample does not implement this function, although a
//      real application should.
//
//********************************************************************

STDMETHODIMP CPersistStorage::IsDirty()
{
        TestDebugOut("In CPersistStorage::IsDirty\r\n");
        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::HandsOffStorage
//
// Purpose:
//
//      Forces the object to release its handle to its storage.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::HandsOffStorage  ()
{
        TestDebugOut("In CPersistStorage::HandsOffStorage\r\n");

        ReleaseStreamsAndStorage();

        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::CreateStreams
//
// Purpose:
//
//      Creates the streams that are held open for the object's lifetime.
//
// Parameters:
//
//      LPSTORAGE lpStg -   Storage in which to create the streams
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//      IStream::Release            OLE
//      IStorage::CreateStream      OLE
//
// Comments:
//
//
//********************************************************************

void CPersistStorage::CreateStreams(LPSTORAGE lpStg)
{
        if (m_lpObj->m_lpColorStm)
                m_lpObj->m_lpColorStm->Release();

        if (m_lpObj->m_lpSizeStm)
                m_lpObj->m_lpSizeStm->Release();

                // create a stream to save the colors
        lpStg->CreateStream ( "RGB",
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                                   0,
                                                   0,
                                                   &m_lpObj->m_lpColorStm);

        // create a stream to save the size
        lpStg->CreateStream ( "size",
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                                   0,
                                                   0,
                                                   &m_lpObj->m_lpSizeStm);
}

//**********************************************************************
//
// CPersistStorage::OpenStreams
//
// Purpose:
//
//      Opens the streams in a storage.
//
// Parameters:
//
//      LPSTORAGE lpStg -   Storage in which to open the streams.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
// Comments:
//
//
//********************************************************************

void CPersistStorage::OpenStreams(LPSTORAGE lpStg)
{
        if (m_lpObj->m_lpColorStm)
                m_lpObj->m_lpColorStm->Release();

        if (m_lpObj->m_lpSizeStm)
                m_lpObj->m_lpSizeStm->Release();

                // open the color stream
        lpStg->OpenStream ( "RGB",
                                                   0,
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                                   0,
                                                   &m_lpObj->m_lpColorStm);

        // open the color stream
        lpStg->OpenStream ( "size",
                                                   0,
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                                   0,
                                                   &m_lpObj->m_lpSizeStm);
}

//**********************************************************************
//
// CPersistStorage::ReleaseStreamsAndStorage
//
// Purpose:
//
//      Releases the stream and storage ptrs
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
// Comments:
//
//
//********************************************************************

void CPersistStorage::ReleaseStreamsAndStorage()
{
        if (m_lpObj->m_lpColorStm)
                {
                m_lpObj->m_lpColorStm->Release();
                m_lpObj->m_lpColorStm = NULL;
                }

        if (m_lpObj->m_lpSizeStm)
                {
                m_lpObj->m_lpSizeStm->Release();
                m_lpObj->m_lpSizeStm = NULL;
                }

        if (m_lpObj->m_lpStorage)
                {
                m_lpObj->m_lpStorage->Release();
                m_lpObj->m_lpStorage = NULL;
                }
}

//**********************************************************************
//
// CPersistStorage::CreateStreams
//
// Purpose:
//
//      Creates temporary streams in a storage.
//
// Parameters:
//
//      LPSTORAGE lpStg                 - Pointer to the storage
//
//      LPSTREAM FAR* lplpTempColor     - Color Stream
//
//      LPSTREAM FAR* lplpTempSize      - Size Stream
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
// Comments:
//
//
//********************************************************************

void CPersistStorage::CreateStreams(LPSTORAGE lpStg, LPSTREAM FAR* lplpTempColor,LPSTREAM FAR* lplpTempSize)
{
                // create a stream to save the colors
         lpStg->CreateStream ( "RGB",
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                                   0,
                                                   0,
                                                   lplpTempColor);

        // create a stream to save the size
        lpStg->CreateStream ( "size",
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                                   0,
                                                   0,
                                                   lplpTempSize);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ioipo.cpp ===
//**********************************************************************
// File name: IOIPO.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See ioipo.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioipo.h"
#include "app.h"
#include "doc.h"
#include "math.h"

//**********************************************************************
//
// COleInPlaceObject::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In COleInPlaceObject::QueryInterface\r\n");
	// need to NULL the out parameter
	*ppvObj = NULL;
	return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceObject::AddRef
//
// Purpose:
//
//      Increments the reference count on COleInPlaceObject and the "object"
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the Object
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceObject::AddRef ()
{
	TestDebugOut("In COleInPlaceObject::AddRef\r\n");
	++m_nCount;
	return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleInPlaceObject::Release
//
// Purpose:
//
//      Decrements the reference count of COleInPlaceObject and the
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceObject::Release ()
{
	TestDebugOut("In COleInPlaceObject::Release\r\n");
	--m_nCount;
	return m_lpObj->Release();
}

//**********************************************************************
//
// COleInPlaceObject::InPlaceDeactivate
//
// Purpose:
//
//      Called to deactivat the object
//
// Parameters:
//
//      None
//
// Return Value:
//
//
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleClientSite::QueryInterface          Container
//      IOleInPlaceSite::OnInPlaceDeactivate    Container
//      IOleInPlaceSite::Release                Container
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP COleInPlaceObject::InPlaceDeactivate()
{
	 TestDebugOut("In COleInPlaceObject::InPlaceDeactivate\r\n");

	 // if not inplace active, return NOERROR
	 if (!m_lpObj->m_fInPlaceActive)
		 return NOERROR;

	 // clear inplace flag
	 m_lpObj->m_fInPlaceActive = FALSE;

	 // deactivate the UI
	 m_lpObj->DeactivateUI();
	 m_lpObj->DoInPlaceHide();

	 // tell the container that we are deactivating.
	 if (m_lpObj->m_lpIPSite)
		 {
		 m_lpObj->m_lpIPSite->OnInPlaceDeactivate();
		 m_lpObj->m_lpIPSite->Release();
		 m_lpObj->m_lpIPSite =NULL;
		 }

	return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceObject::UIDeactivate
//
// Purpose:
//
//      Instructs us to remove our UI.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleClientSite::QueryInterface          Container
//      IOleInPlaceSite::OnUIDeactivate         Container
//      IOleInPlaceSite::Release                Container
//      CSimpSvrObj::DoInPlaceHide              OBJ.H
//      IDataAdviseHolder::SendOnDataChange     OLE
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::UIDeactivate()
{
	TestDebugOut("In COleInPlaceObject::UIDeactivate\r\n");

	m_lpObj->DeactivateUI();

	return ResultFromScode (S_OK);
}

//**********************************************************************
//
// COleInPlaceObject::SetObjectRects
//
// Purpose:
//
//      Called when the container clipping region or the object position
//      changes.
//
// Parameters:
//
//      LPCRECT lprcPosRect     - New Position Rect.
//
//      LPCRECT lprcClipRect    - New Clipping Rect.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IntersectRect               Windows API
//      OffsetRect                  Windows API
//      CopyRect                    Windows API
//      MoveWindow                  Windows API
//      CSimpSvrDoc::GethHatchWnd   DOC.H
//      CSimpSvrDoc::gethDocWnd     DOC.h
//      SetHatchWindowSize          OLE2UI
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::SetObjectRects  ( LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
	TestDebugOut("In COleInPlaceObject::SetObjectRects\r\n");

	RECT resRect;
	POINT pt;

	// Get the intersection of the clipping rect and the position rect.
	IntersectRect(&resRect, lprcPosRect, lprcClipRect);

	m_lpObj->m_xOffset = abs (resRect.left - lprcPosRect->left);
	m_lpObj->m_yOffset = abs (resRect.top - lprcPosRect->top);

	m_lpObj->m_scale = (float)(lprcPosRect->right - lprcPosRect->left)/m_lpObj->m_size.x;

	if (m_lpObj->m_scale == 0)
		m_lpObj->m_scale = 1;

	char szBuffer[255];
	wsprintf(szBuffer,"New Scale %3d\r\n",m_lpObj->m_scale);
	TestDebugOut(szBuffer);

	// Adjust the size of the Hatch Window.
	SetHatchWindowSize(m_lpObj->m_lpDoc->GethHatchWnd(),(LPRECT) lprcPosRect, (LPRECT) lprcClipRect, &pt);

	// offset the rect
	OffsetRect(&resRect, pt.x, pt.y);

	CopyRect(&m_lpObj->m_posRect, lprcPosRect);

	// Move the actual object window
	MoveWindow(m_lpObj->m_lpDoc->GethDocWnd(),
				   resRect.left,
				   resRect.top,
				   resRect.right - resRect.left,
				   resRect.bottom - resRect.top,
				   TRUE);


	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceObject::GetWindow
//
// Purpose:
//
//      Returns the Window handle of the inplace object
//
// Parameters:
//
//      HWND FAR* lphwnd    - Out pointer in which to return the window
//                            Handle.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::GethDocWnd      DOC.H
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::GetWindow  ( HWND FAR* lphwnd)
{
	TestDebugOut("In COleInPlaceObject::GetWindow\r\n");
	*lphwnd = m_lpObj->m_lpDoc->GethDocWnd();

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceObject::ContextSensitiveHelp
//
// Purpose:
//
//      Used in performing Context Sensitive Help
//
// Parameters:
//
//      BOOL fEnterMode     - Flag to determine if enter or exiting
//                            Context Sensitive Help.
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented due to the fact that it is
//      beyond the scope of a simple object.  All *real* applications
//      are going to want to implement this function, otherwise any
//      container that supports context sensitive help will not work
//      properly while the object is in place.
//
//      See TECHNOTES.WRI include with the OLE SDK for details on
//      Implementing this method.
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::ContextSensitiveHelp  ( BOOL fEnterMode)
{
	TestDebugOut("In COleInPlaceObject::ContextSensitiveHelp\r\n");
	return ResultFromScode( E_NOTIMPL);
};

//**********************************************************************
//
// COleInPlaceObject::ReactivateAndUndo
//
// Purpose:
//
//      Called when the container wants to undo the last edit made in
//      the object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      INPLACE_E_NOTUNDOABLE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Since this server does not support undo, the value
//      INPLACE_E_NOTUNDOABLE is always returned.
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::ReactivateAndUndo  ()
{
	TestDebugOut("In COleInPlaceObject::ReactivateAndUndo\r\n");
	return ResultFromScode( INPLACE_E_NOTUNDOABLE );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpsvr.h"
#include "resource.h"
#include <ole2ver.h>
extern "C" void TestDebugOut(LPSTR psz);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\ips.h ===
//**********************************************************************
// File name: ips.h
//
//      Definition of CPersistStorage
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IPS_H_)
#define _IPS_H_


#include <ole2.h>
#include <storage.h>
#include "obj.h"

class CSimpSvrObj;

interface CPersistStorage : IPersistStorage
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;
	BOOL m_fSameAsLoad;

public:
	CPersistStorage::CPersistStorage(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		};
	CPersistStorage::~CPersistStorage() {};

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP InitNew (LPSTORAGE pStg);
	STDMETHODIMP GetClassID  ( LPCLSID lpClassID) ;
	STDMETHODIMP Save  ( LPSTORAGE pStgSave, BOOL fSameAsLoad) ;
	STDMETHODIMP SaveCompleted  ( LPSTORAGE pStgNew);
	STDMETHODIMP Load  ( LPSTORAGE pStg);
	STDMETHODIMP IsDirty  ();
	STDMETHODIMP HandsOffStorage  ();

	void ReleaseStreamsAndStorage();
	void OpenStreams(LPSTORAGE lpStg);
	void CreateStreams(LPSTORAGE lpStg);
	void CreateStreams(LPSTORAGE lpStg, LPSTREAM FAR *lpTempColor, LPSTREAM FAR *lpTempSize);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\obj.h ===
//**********************************************************************
// File name: obj.h
//
//      Definition of CSimpSvrObj
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _OBJ_H_)
#define _OBJ_H_

#include "ioipao.h"
#include "ioipo.h"
#include "ioo.h"
#include "ips.h"
#include "ido.h"
#include "iec.h"

class CSimpSvrDoc;
interface COleObject;
interface CPersistStorage;
interface CDataObject;
interface COleInPlaceActiveObject;
interface COleInPlaceObject;
interface CExternalConnection;

class CSimpSvrObj : public IUnknown
{
private:
	CSimpSvrDoc FAR * m_lpDoc;      // Back pointer
	int m_nCount;                   // reference count
	BOOL m_fInPlaceActive;          // Used during InPlace Negotiation
	BOOL m_fInPlaceVisible;         // "  "  "  "   "   "   "   "   "
	BOOL m_fUIActive;               // "  "  "  "   "   "   "   "   "
	HMENU m_hmenuShared;            // "  "  "  "   "   "   "   "   "
	HOLEMENU m_hOleMenu;            // "  "  "  "   "   "   "   "   "
	RECT m_posRect;                 // "  "  "  "   "   "   "   "   "
	OLEINPLACEFRAMEINFO m_FrameInfo;
	BOOL m_fSaveWithSameAsLoad;
	BOOL m_fNoScribbleMode;

	DWORD m_dwRegister;             // Registered in ROT

	int m_red, m_green, m_blue;     // current color
	POINT m_size;                   // current size
	int m_xOffset;
	int m_yOffset;
	float m_scale;

	HWND m_hWndParent;              // parent window handle

	// interfaces used
	LPSTORAGE m_lpStorage;
	LPSTREAM m_lpColorStm, m_lpSizeStm;
	LPOLECLIENTSITE m_lpOleClientSite;          // IOleClientSite
	LPOLEADVISEHOLDER m_lpOleAdviseHolder;      // IOleAdviseHolder
	LPDATAADVISEHOLDER m_lpDataAdviseHolder;    // IDataAdviseHolder
	LPOLEINPLACEFRAME m_lpFrame;                // IOleInPlaceFrame
	LPOLEINPLACEUIWINDOW m_lpCntrDoc;           // IOleInPlaceUIWindow
	LPOLEINPLACESITE m_lpIPSite;                // IOleInPlaceSite

	// interface implemented
	COleObject m_OleObject;                             // IOleObject
	CPersistStorage m_PersistStorage;                   // IPersistStorage
	CDataObject m_DataObject;                           // IDataObject
	COleInPlaceActiveObject m_OleInPlaceActiveObject;   // IOleInPlaceActiveObject
	COleInPlaceObject m_OleInPlaceObject;               // IOleInPlaceObject
	CExternalConnection m_ExternalConnection;

public:
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

// construction/destruction
	CSimpSvrObj(CSimpSvrDoc FAR * lpSimpSvrDoc);
	~CSimpSvrObj();

// utility functions
	void Draw(HDC hDC, BOOL fMetaDC = TRUE);
	void PaintObj(HDC hDC);
	void lButtonDown(WPARAM wParam,LPARAM lParam);
	HANDLE GetMetaFilePict();
	void SaveToStorage (LPSTORAGE lpStg, BOOL fSameAsLoad);
	void LoadFromStorage ();

// visual editing helper functions
	BOOL DoInPlaceActivate (LONG lVerb);
	void AssembleMenus();
	void AddFrameLevelUI();
	void DoInPlaceHide();
	void DisassembleMenus();
	void SendOnDataChange();
	void DeactivateUI();

// member variable access
	inline BOOL IsInPlaceActive() { return m_fInPlaceActive; };
	inline BOOL IsInPlaceVisible() { return m_fInPlaceVisible; };
	inline BOOL IsUIActive() { return m_fUIActive; };
	inline HWND GetParent() { return m_hWndParent; };
	inline LPSTORAGE GetStorage() { return m_lpStorage; };
	inline LPOLECLIENTSITE GetOleClientSite() { return m_lpOleClientSite; };
	inline LPDATAADVISEHOLDER GetDataAdviseHolder() { return m_lpDataAdviseHolder; };
	inline LPOLEADVISEHOLDER GetOleAdviseHolder() { return m_lpOleAdviseHolder; };
	inline LPOLEINPLACEFRAME GetInPlaceFrame() { return m_lpFrame; };
	inline LPOLEINPLACEUIWINDOW GetUIWindow() { return m_lpCntrDoc; };
	inline LPOLEINPLACESITE GetInPlaceSite() { return m_lpIPSite; };
	inline COleObject FAR * GetOleObject() { return &m_OleObject; };
	inline CPersistStorage FAR * GetPersistStorage() { return &m_PersistStorage; };
	inline CDataObject FAR * GetDataObject() { return &m_DataObject; };
	inline COleInPlaceActiveObject FAR * GetOleInPlaceActiveObject() { return &m_OleInPlaceActiveObject; };
	inline COleInPlaceObject FAR * GetOleInPlaceObject() { return &m_OleInPlaceObject; };
	inline void ClearOleClientSite() { m_lpOleClientSite = NULL; };
	inline void ClearDataAdviseHolder() { m_lpDataAdviseHolder = NULL; };
	inline void ClearOleAdviseHolder() { m_lpOleAdviseHolder = NULL; };
	inline LPRECT GetPosRect() { return &m_posRect; };
	inline LPPOINT GetSize() { return &m_size; };
	inline LPOLEINPLACEFRAMEINFO GetFrameInfo() {return &m_FrameInfo;};
	inline DWORD GetRotRegister() { return m_dwRegister; };



	// member manipulation
	inline void SetColor (int nRed, int nGreen, int nBlue)
		{ m_red = nRed; m_green = nGreen; m_blue = nBlue; };

	inline void RotateColor()
		{ m_red+=10; m_green+=10; m_blue+=10;};


// all of the interface implementations should be friends of this
// class
friend interface COleObject;
friend interface CPersistStorage;
friend interface CDataObject;
friend interface COleInPlaceActiveObject;
friend interface COleInPlaceObject;
friend interface CExternalConnection;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\simpsvr.h ===
//**********************************************************************
// File name: simpsvr.h
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000


int PASCAL WinMain(HANDLE hInstance,HANDLE hPrevInstance,LPSTR lpCmdLine,int nCmdShow);
BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);
long FAR PASCAL _export MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
long FAR PASCAL _export DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FAR PASCAL _export About(HWND hDlg, unsigned message, WORD wParam, LONG lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\obj.cpp ===
//**********************************************************************
// File name: obj.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See obj.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioo.h"
#include "ido.h"
#include "ips.h"
#include "icf.h"
#include "ioipao.h"
#include "ioipo.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CSimpSvrObj::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the "Object" level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK          -   The interface is supported.
//      E_NOINTERFACE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IUnknown::AddRef            OBJ.CPP, IOO.CPP, IDO.CPP, IPS.CPP
//                                  IOIPO.CPP, IOIPAO.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CSimpSvrObj::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CSimpSvrObj::QueryInterface\r\n");

	SCODE sc = S_OK;

	if (riid == IID_IUnknown)
		*ppvObj = this;
	else if (riid == IID_IOleObject)
		*ppvObj = &m_OleObject;
	else if (riid == IID_IDataObject)
		*ppvObj = &m_DataObject;
	else if ( (riid == IID_IPersistStorage) || (riid == IID_IPersist) )
		*ppvObj = &m_PersistStorage;
	else if (riid == IID_IOleInPlaceObject)
		*ppvObj = &m_OleInPlaceObject;
	else if (riid == IID_IOleInPlaceActiveObject)
		*ppvObj = &m_OleInPlaceActiveObject;
	else if (riid == IID_IExternalConnection)
		 *ppvObj = &m_ExternalConnection;
	else
		{
		*ppvObj = NULL;
		sc = E_NOINTERFACE;
		}

	if (*ppvObj)
		((LPUNKNOWN)*ppvObj)->AddRef();

	return ResultFromScode( sc );
};

//**********************************************************************
//
// CSimpSvrObj::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Object level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrObj::AddRef ()
{
	TestDebugOut("In CSimpSvrObj::AddRef\r\n");

	m_lpDoc->AddRef();

	return ++m_nCount;
};

//**********************************************************************
//
// CSimpSvrObj::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrObj::Release ()
{
	TestDebugOut("In CSimpSvrObj::Release\r\n");

	m_lpDoc->Release();

	if (--m_nCount == 0) {
		delete this;
        return 0;
    }

	return m_nCount;
};

//**********************************************************************
//
// CSimpSvrObj::CSimpSvrObj
//
// Purpose:
//
//      Constructor for CSimpSvrObj
//
// Parameters:
//
//      CSimpSvrDoc FAR * lpSimpSvrDoc - ptr to the doc object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//
//********************************************************************
#pragma warning (disable : 4355) // "this" used in base initializer list warning.  This
								 // can be disabled because we are not using "this" in
								 // the constructor for these objects, rather we are
								 // just storing it for future use...
CSimpSvrObj::CSimpSvrObj(CSimpSvrDoc FAR * lpSimpSvrDoc) : m_OleObject(this),
														   m_DataObject(this),
														   m_PersistStorage(this),
														   m_OleInPlaceActiveObject(this),
														   m_OleInPlaceObject(this),
														   m_ExternalConnection(this)
#pragma warning (default : 4355) // Turn the warning back on

{
	m_lpDoc = lpSimpSvrDoc;
	m_nCount = 0;
	m_fInPlaceActive = FALSE;
	m_fInPlaceVisible = FALSE;
	m_fUIActive = FALSE;
	m_hmenuShared = NULL;
	m_hOleMenu = NULL;

	m_dwRegister = 0;

	m_lpFrame = NULL;
	m_lpCntrDoc = NULL;

	m_lpStorage = NULL;
	m_lpColorStm = NULL;
	m_lpSizeStm = NULL;
	m_lpOleClientSite = NULL;
	m_lpOleAdviseHolder = NULL;
	m_lpDataAdviseHolder = NULL;
	m_lpIPSite = NULL;

	m_red = 128;
	m_green = 0;
	m_blue = 0;

	m_size.x = 100;
	m_size.y = 100;

	m_xOffset = 0;
	m_yOffset = 0;

	m_scale = 1;

	m_fSaveWithSameAsLoad = FALSE;
	m_fNoScribbleMode = FALSE;

}

//**********************************************************************
//
// CSimpSvrObj::~CSimpSvrObj
//
// Purpose:
//
//      Destructor for CSimpSvrObj
//
// Parameters:
//
//      None
//
// Return Value:
//
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      PostMessage                 Windows API
//      CSimpSvrDoc::GetApp         DOC.H
//      CSimpSvrDoc::GethAppWnd     DOC.H
//      CSimpSvrDoc::ClearObj       DOC.H
//      CSimpSvrApp::IsStartedByOle APP.CPP
//
// Comments:
//
//
//********************************************************************

CSimpSvrObj::~CSimpSvrObj()
{
	TestDebugOut("In CSimpSvrObj's Destructor \r\n");

	// if we were started by ole, post ourselves a close message
	if (m_lpDoc->GetApp()->IsStartedByOle())
		PostMessage(m_lpDoc->GethAppWnd(), WM_SYSCOMMAND, SC_CLOSE, 0L);

	// clear the OBJ ptr in the doc class
	m_lpDoc->ClearObj();

}

//**********************************************************************
//
// CSimpSvrObj::Draw
//
// Purpose:
//
//      Draws the object into an arbitrary DC
//
// Parameters:
//
//      HDC hDC - DC to draw into
//
// Return Value:
//
//      NONE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateBrushIndirect         Windows API
//      SelectObject                Windows API
//      Rectangle                   Windows API
//      DeleteObject                Windows API
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::Draw (HDC hDC, BOOL m_fMeta)
{
	LOGBRUSH lb;

	TestDebugOut("In CSimpSvrObj::Draw\r\n");

	char szBuffer[255];
	wsprintf(szBuffer,"Drawing Scale %3d\r\n",m_scale);
	TestDebugOut(szBuffer);

	if (!m_fMeta)
		{
		SetMapMode(hDC, MM_ANISOTROPIC);
		SetWindowOrg(hDC, (int)(m_xOffset/m_scale), (int)(m_yOffset/m_scale));
		SetWindowExt(hDC, m_size.x, m_size.y);
		SetViewportExt(hDC, (int)(m_size.x*m_scale), (int)(m_size.y*m_scale));
		}

	// fill out a LOGBRUSH
	lb.lbStyle = BS_SOLID;
	lb.lbColor = RGB(m_red, m_green, m_blue);
	lb.lbHatch = 0;

	// create the brush
	HBRUSH hBrush = CreateBrushIndirect(&lb);

	// select the brush
	HBRUSH hOldBrush = SelectObject(hDC, hBrush);
	HPEN hPen = CreatePen(PS_INSIDEFRAME, 6, RGB(0, 0, 0));

	HPEN hOldPen = SelectObject(hDC, hPen);

	// draw the rectangle
	Rectangle (hDC, 0, 0, m_size.x, m_size.y);

	// restore the pen
	hPen = SelectObject(hDC, hOldPen);

	// free the pen
	DeleteObject(hPen);

	// restore the old brush
	hBrush = SelectObject(hDC, hOldBrush);

	// free the brush
	DeleteObject(hBrush);
}

//**********************************************************************
//
// CSimpSvrObj::GetMetaFilePict
//
// Purpose:
//
//      Returns a handle to a metafile representation of the object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      Handle to the metafile.
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      GlobalAlloc                     Windows API
//      GlobalLock                      Windows API
//      SetWindowOrg                    Windows API
//      SetWindowExt                    Windows API
//      CreateMetaFile                  Windows API
//      CloseMetaFile                   Windows API
//      GlobalUnlock                    Windows API
//      XformWidthInPixelsToHimetric    OLE2UI
//      XformHeightInPixelsToHimetric   OLE2UI
//      CSimpSvrObj::Draw               OBJ.CPP
//
// Comments:
//
//
//********************************************************************

HANDLE CSimpSvrObj::GetMetaFilePict()
{
	HANDLE hMFP;
	METAFILEPICT FAR * lpMFP;
	POINT pt;

	TestDebugOut("In CSimpSvrObj::GetMetaFilePict\r\n");

	// allocate the memory for the METAFILEPICT structure
	hMFP = GlobalAlloc (GMEM_SHARE | GHND, sizeof (METAFILEPICT) );
	lpMFP = (METAFILEPICT FAR*) GlobalLock(hMFP);

	// get the size of the object in HIMETRIC
	pt.x = XformWidthInPixelsToHimetric(NULL, m_size.x);
	pt.y = XformHeightInPixelsToHimetric(NULL, m_size.y);

	// fill out the METAFILEPICT structure
	lpMFP->mm = MM_ANISOTROPIC;
	lpMFP->xExt = pt.x;
	lpMFP->yExt = pt.y;

	// Create the metafile
	HDC hDC = CreateMetaFile(NULL);

	SetWindowOrg (hDC, 0, 0);
	SetWindowExt (hDC, m_size.x,
					   m_size.y);

	Draw(hDC);

	lpMFP->hMF = CloseMetaFile(hDC);

	// unlock the metafilepict
	GlobalUnlock(hMFP);

	return hMFP;
}


//**********************************************************************
//
// CSimpSvrObj::SaveToStorage
//
// Purpose:
//
//      Saves the object to the passed storage
//
// Parameters:
//
//      LPSTORAGE lpStg - Storage in which to save the object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::CreateStream      OLE
//      IStream::Write              OLE
//      IStream::Release            OLE
//
// Comments:
//
//      A real app will want to do better error checking / returning
//
//********************************************************************

void CSimpSvrObj::SaveToStorage (LPSTORAGE lpStg, BOOL fSameAsLoad)
{
	TestDebugOut("In CSimpSvrObj::SaveToStorage\r\n");

	LPSTREAM lpTempColor, lpTempSize;

	if (!fSameAsLoad)
		m_PersistStorage.CreateStreams( lpStg, &lpTempColor, &lpTempSize);
	else
		{
		lpTempColor = m_lpColorStm;
		lpTempColor->AddRef();
		lpTempSize = m_lpSizeStm;
		lpTempSize->AddRef();
		}

	ULARGE_INTEGER uli;

	uli.LowPart = 0;
	uli.HighPart = 0;

	lpTempColor->SetSize(uli);
	lpTempSize->SetSize(uli);

	LARGE_INTEGER li;

	li.LowPart = 0;
	li.HighPart = 0;

	lpTempColor->Seek(li, STREAM_SEEK_SET, NULL);
	lpTempSize->Seek(li, STREAM_SEEK_SET, NULL);

	// write the colors to the stream
	lpTempColor->Write(&m_red, sizeof(m_red), NULL);
	lpTempColor->Write(&m_green, sizeof(m_green), NULL);
	lpTempColor->Write(&m_blue, sizeof(m_blue), NULL);

	// write the size to the stream
	lpTempSize->Write(&m_size, sizeof(m_size), NULL);

	lpTempColor->Release();
	lpTempSize->Release();
}

//**********************************************************************
//
// CSimpSvrObj::LoadFromStorage
//
// Purpose:
//
//      Loads the object from the passed storage
//
// Parameters:
//
//      LPSTORAGE lpStg     - Storage in which to load the object from
//
// Return Value:
//
//      None.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::OpenStream        OLE
//      IStream::Read               OLE
//      IStream::Release            OLE
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::LoadFromStorage ()
{
	TestDebugOut("In CSimpSvrObj::LoadFromStorage\r\n");

	// Read the colors
	m_lpColorStm->Read(&m_red, sizeof(m_red), NULL);
	m_lpColorStm->Read(&m_green, sizeof(m_green), NULL);
	m_lpColorStm->Read(&m_blue, sizeof(m_blue), NULL);

	// read the size
	m_lpSizeStm->Read(&m_size, sizeof(m_size), NULL);

}

//**********************************************************************
//
// CSimpSvrObj::DoInPlaceActivate
//
// Purpose:
//
//      Does the inplace activation for the object
//
// Parameters:
//
//      LONG lVerb  - Verb that caused this function to be called
//
// Return Value:
//
//      TRUE/FALSE depending on success or failure.
//
// Function Calls:
//      Function                                Location
//
//      IOleClientSite::QueryInterface          Container
//      IOleClientSite::ShowObject              Container
//      IOleInPlaceSite::CanInPlaceActivate     Container
//      IOleInPlaceSite::Release                Container
//      IOleInPlaceSite::OnInPlaceActivate      Container
//      IOleInPlaceSite::GetWindow              Container
//      IOleInPlaceSite::GetWindowContext       Container
//      IOleInPlaceSite::OnUIActivate           Container
//      IOleInPlaceSite::Release                Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      TestDebugOut                       Windows API
//      ShowWindow                              Windows API
//      SetParent                               Windows API
//      IntersectRect                           Windows API
//      OffsetRect                              Windows API
//      MoveWindow                              Windows API
//      CopyRect                                Windows API
//      SetFocus                                Windows API
//      SetHatchWindowSize                      OLE2UI
//      CSimpSvrObj::AssembleMenus              OBJ.CPP
//      CSimpSvrObj::AddFrameLevelUI            OBJ.CPP
//
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

BOOL CSimpSvrObj::DoInPlaceActivate (LONG lVerb)
{
	BOOL retval = FALSE;
	RECT posRect, clipRect;


	TestDebugOut("In CSimpSvrObj::DoInPlaceActivate\r\n");

	// if not currently in place active
	if (!m_fInPlaceActive)
		{
		// get the inplace site
		if (m_lpOleClientSite->QueryInterface(IID_IOleInPlaceSite,
											  (LPVOID FAR *)&m_lpIPSite) != NOERROR)
			goto error;


		// if the inplace site could not be obtained, or refuses to inplace
		// activate then goto error.
		if (m_lpIPSite == NULL || m_lpIPSite->CanInPlaceActivate() != NOERROR)
			{
			if (m_lpIPSite)
				m_lpIPSite->Release();
			m_lpIPSite = NULL;
			goto error;
			}

		// tell the site that we are activating.
		m_lpIPSite->OnInPlaceActivate();
		m_fInPlaceActive = TRUE;
		}

	// if not currently inplace visibl
	if (!m_fInPlaceVisible)
		{
		m_fInPlaceVisible = TRUE;

		// get the window handle of the site
		m_lpIPSite->GetWindow(&m_hWndParent);

		// get window context from the container
		m_lpIPSite->GetWindowContext ( &m_lpFrame,
									 &m_lpCntrDoc,
									 &posRect,
									 &clipRect,
									 &m_FrameInfo);

		// show the hatch window
		m_lpDoc->ShowHatchWnd();

		// Set the parenting
		SetParent (m_lpDoc->GethHatchWnd(), m_hWndParent);
		SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethHatchWnd());

		// tell the client site to show the object
		m_lpOleClientSite->ShowObject();

		RECT resRect;

		// figure out the "real" size of the object
		IntersectRect(&resRect, &posRect, &clipRect);
		CopyRect(&m_posRect, &posRect);

		POINT pt;

		// adjust our hatch window size
		SetHatchWindowSize ( m_lpDoc->GethHatchWnd(),
							 &resRect,
							 &posRect,
							 &pt);

		// calculate the actual object rect inside the hatchwnd.
		OffsetRect (&resRect, pt.x, pt.y);

		// move the object window
		MoveWindow(m_lpDoc->GethDocWnd(),
				   resRect.left,
				   resRect.top,
				   resRect.right - resRect.left,
				   resRect.bottom - resRect.top,
				   FALSE);

		// create the combined window
		AssembleMenus();
		}

	// if not UIActive
	if (!m_fUIActive)
		{
		m_fUIActive = TRUE;

		// tell the inplace site that we are activating
		m_lpIPSite->OnUIActivate();

		// set the focus to our object window
		SetFocus(m_lpDoc->GethDocWnd());

		// set the active object on the frame
		m_lpFrame->SetActiveObject(&m_OleInPlaceActiveObject, "Simple OLE 2.0 Server");

		// set the active object on the Doc, if available.
		if (m_lpCntrDoc)
			m_lpCntrDoc->SetActiveObject(&m_OleInPlaceActiveObject, "Simple OLE 2.0 Server");

		// add the frame level UI.
		AddFrameLevelUI();
		}

	retval = TRUE;
error:
	return retval;
}

//**********************************************************************
//
// CSimpSvrObj::AssembleMenus
//
// Purpose:
//
//      Creates the combined menus used during inplace activation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CreateMenu                      Windows API
//      IOleInPlaceFrame::InsertMenus   Container
//      InsertMenu                      Windows API
//      DestroyMenu                     Windows API
//      OleCreateMenuDescriptor         OLE API
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::AssembleMenus()
{
	TestDebugOut("In CSimpSvrObj::AssembleMenus\r\n");
	OLEMENUGROUPWIDTHS menugroupwidths;

	m_hmenuShared = NULL;

	//  Create the menu resource
	m_hmenuShared = CreateMenu();

	// have the contaner insert its menus
	if (m_lpFrame->InsertMenus (m_hmenuShared, &menugroupwidths) == NOERROR)
		{
		int nFirstGroup = (int) menugroupwidths.width[0];

		// insert the server menus
		InsertMenu( m_hmenuShared, nFirstGroup, MF_BYPOSITION | MF_POPUP, m_lpDoc->GetApp()->GetColorMenu(), "&Color");
		menugroupwidths.width[1] = 1;
		menugroupwidths.width[3] = 0;
		menugroupwidths.width[5] = 0;
		}
	else
		{
		// Destroy the menu resource
		DestroyMenu(m_hmenuShared);
		m_hmenuShared = NULL;
		}

	// tell OLE to create the menu descriptor
	m_hOleMenu = OleCreateMenuDescriptor(m_hmenuShared, &menugroupwidths);
}

//**********************************************************************
//
// CSimpSvrObj::AddFrameLevelUI
//
// Purpose:
//
//      Adds the Frame level user interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceFrame::SetMenu           Container
//      IOleInPlaceFrame::SetBorderSpace    Container
//      IOleInPlaceUIWindow::SetBorderSpace Container
//      CSimpSvrDoc::GethDocWnd             DOC.H
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::AddFrameLevelUI()
{
	TestDebugOut("In CSimpSvrObj::AddFrameLevelUI\r\n");

	// add the combined menu
	m_lpFrame->SetMenu(m_hmenuShared, m_hOleMenu, m_lpDoc->GethDocWnd());

	// do hatched border
	SetParent (m_lpDoc->GethHatchWnd(), m_hWndParent);
	SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethHatchWnd());

	// set the border space.  Normally we would negotiate for toolbar
	// space at this point.  Since this server doesn't have a toolbar,
	// this isn't needed...
	if (m_lpFrame)
		m_lpFrame->SetBorderSpace(NULL);

	if (m_lpCntrDoc)
		m_lpCntrDoc->SetBorderSpace(NULL);
}

//**********************************************************************
//
// CSimpSvrObj::DoInPlaceHide
//
// Purpose:
//
//      Hides the object while inplace actvie
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      SetParent                       Windows API
//      CSimpSvrDoc::GethDocWnd         DOC.H
//      CSimpSvrDoc::GethAppWnd         DOC.H
//      CSimpSvrDoc::GethHatchWnd       DOC.H
//      CSimpSvrObj::DisassembleMenus   OBJ.CPP
//      IOleInPlaceFrame::Release       Container
//      IOleInPlaceUIWindow::Release    Container
//
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

void CSimpSvrObj::DoInPlaceHide()
{
	TestDebugOut("In CSimpSvrObj::DoInPlaceHide\r\n");

	// if we aren't inplace visible, then this routine is a NOP,
	if (!m_fInPlaceVisible)
		return;

	m_fInPlaceVisible = FALSE;

	// change the parenting
	SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethAppWnd());
	SetParent (m_lpDoc->GethHatchWnd(),m_lpDoc->GethDocWnd());

	// rip down the combined menus
	DisassembleMenus();

	// release the inplace frame
	m_lpFrame->Release();

	m_lpFrame = NULL;  // only holding one ref. to frame.

	// release the UIWindow if it is there.
	if (m_lpCntrDoc)
		m_lpCntrDoc->Release();

	m_lpCntrDoc = NULL;

}

//**********************************************************************
//
// CSimpSvrObj::DisassembleMenus
//
// Purpose:
//
//      Disassembles the combined menus used in inplace activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut               Windows API
//      OleDestroyMenuDescriptor        OLE API
//      RemoveMenu                      Windows API
//      IOleInPlaceFrame::RemoveMenus   Container
//      DestroyMenu                     Windows API
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

void CSimpSvrObj::DisassembleMenus()
{
	// destroy the menu descriptor
	OleDestroyMenuDescriptor(m_hOleMenu);

	if (m_hmenuShared)
		{
		// remove the menus that we added
		RemoveMenu( m_hmenuShared, 1, MF_BYPOSITION);

		// have the container remove its menus
		m_lpFrame->RemoveMenus(m_hmenuShared);

		// Destroy the menu resource
		DestroyMenu(m_hmenuShared);

		m_hmenuShared = NULL;
		}
}

//**********************************************************************
//
// CSimpSvrObj::SendOnDataChange
//
// Purpose:
//
//      Uses the data advise holder to send a data change, then updates
//      the ROT to note the time of change.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      IDataAdviseHolder::SendOnDataChange     OLE API
//      GetRunningObjectTable                   OLE API
//      CoFileTimeNow                           OLE API
//      IRunningObjectTable::NoteChangeTime     OLE API
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::SendOnDataChange()
{
	if (m_lpDataAdviseHolder)
		m_lpDataAdviseHolder->SendOnDataChange( (LPDATAOBJECT)&m_DataObject, 0, 0);

	LPRUNNINGOBJECTTABLE lpRot;

	GetRunningObjectTable(0, &lpRot);

	if ( lpRot && m_dwRegister)
		{
		FILETIME ft;
		CoFileTimeNow(&ft);

		lpRot->NoteChangeTime(m_dwRegister, &ft);
		lpRot->Release();
		}
}

//**********************************************************************
//
// CSimpSvrObj::DeactivateUI
//
// Purpose:
//
//      Breaks down the inplace ui
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      SetParent                               Windows API
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleInPlaceSite::UIDeactivate           Container
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::DeactivateUI()
{
	// if not UI active, or no pointer to IOleInPlaceFrame, then
	// return NOERROR
	if (!(m_fUIActive || m_lpFrame))
		return;
	else
		{
		m_fUIActive = FALSE;

		// remove hatching
		SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethAppWnd());
		SetParent (m_lpDoc->GethHatchWnd(),m_lpDoc->GethDocWnd());

		// if in an MDI container, call SetActiveObject on the DOC.
		if (m_lpCntrDoc)
			m_lpCntrDoc->SetActiveObject(NULL, NULL);

		m_lpFrame->SetActiveObject(NULL, NULL);

		// tell the container that our UI is going away.
		if (m_lpIPSite)
			m_lpIPSite->OnUIDeactivate(FALSE);
		}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPSVR.RC
//
#define IDM_OPEN                        102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112
#define IDM_RED                         113
#define IDM_GREEN                       114
#define IDM_BLUE                        115
#define IDM_ROTATE                      116

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         117
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\utests16\simpsvr\simpsvr.cpp ===
//**********************************************************************
// File name: simpsvr.cpp
//
//      Main source file for the simple OLE 2.0 server
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"
#include "icf.h"

// This line is needed for the debug utilities in OLE2UI
extern "C" {
	OLEDBGDATA_MAIN("SIMPSVR")
}

CSimpSvrApp FAR * lpCSimpSvrApp;
CClassFactory FAR * lpClassFactory;
BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugString(psz);
    }
}

//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrApp::CSimpSvrApp          APP.CPP
//      CSimpSvrApp::fInitApplication    APP.CPP
//      CSimpSvrApp::fInitInstance       APP.CPP
//      CSimpSvrApp::HandleAccelerators  APP.CPP
//      CSimpSvrApp::~CSimpSvrApp         APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
// Comments:
//
//********************************************************************

int PASCAL WinMain(HANDLE hInstance,HANDLE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)

{
	MSG msg;
	fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

	if(fBeVerbose == 0)
	{
	    fBeVerbose = GetProfileInt("OLEUTEST","spsvr16",0);
	}

	// recommended size for OLE apps
	SetMessageQueue(96);

	lpCSimpSvrApp = new CSimpSvrApp;

	lpCSimpSvrApp->AddRef();      // need the app ref. count at 1 to hold the
								  // app alive.

	lpCSimpSvrApp->ParseCmdLine(lpCmdLine);

	// app initialization
	if (!hPrevInstance)
		if (!lpCSimpSvrApp->fInitApplication(hInstance))
			return (FALSE);

	// instance initialization
	if (!lpCSimpSvrApp->fInitInstance(hInstance, nCmdShow, lpClassFactory))
		return (FALSE);

	/* Initialization required for OLE 2 UI library.  This call is
	**    needed ONLY if we are using the static link version of the UI
	**    library. If we are using the DLL version, we should NOT call
	**    this function in our application.
	*/
	if (!OleUIInitialize(hInstance, hPrevInstance))
		{
		OleDbgOut("Could not initialize OLEUI library\n");
		return FALSE;
		}

	// message loop
	while (GetMessage(&msg, NULL, NULL, NULL))
		{
		if (lpCSimpSvrApp->IsInPlaceActive())

			// Only key messages need to be sent to OleTranslateAccelerator.  Any other message
			// would result in an extra FAR call to occur for that message processing...

			if ( (msg.message >= WM_KEYFIRST) && (msg.message <= WM_KEYLAST) )

				// OleTranslateAccelerator MUST be called, even though this application does
				// not have an accelerator table.  This has to be done in order for the
				// mneumonics for the top level menu items to work properly.

				if ( OleTranslateAccelerator ( lpCSimpSvrApp->GetDoc()->GetObj()->GetInPlaceFrame(),
											   lpCSimpSvrApp->GetDoc()->GetObj()->GetFrameInfo(),
											   &msg) == NOERROR)
					continue;

		TranslateMessage(&msg);    /* Translates virtual key codes           */
		DispatchMessage(&msg);     /* Dispatches message to window           */
		}

	// De-initialization for UI libraries.  Just like OleUIInitialize, this
	// funciton is needed ONLY if we are using the static link version of the
	// OLE UI library.
	OleUIUninitialize();

	return (msg.wParam);           /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrApp::lCommandHandler     APP.CPP
//      CSimpSvrApp::DestroyDocs         APP.CPP
//      CSimpSvrApp::lCreateDoc          APP.CPP
//      CSimpSvrApp::lSizeHandler        APP.CPP
//      CGameDoc::lAddVerbs           DOC.CPP
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//
// Comments:
//
//********************************************************************

long FAR PASCAL _export MainWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)

{

	switch (message)
		{
		case WM_CLOSE:
			TestDebugOut("*** In WM_CLOSE *** \r\n");

			// if there is still a document
			if (lpCSimpSvrApp->GetDoc())

				// if there is still an object within a document
				if (lpCSimpSvrApp->GetDoc()->GetObj())   // this case occurs if there is still
														 // an outstanding Ref count on the object
														 // when the app is trying to go away.
														 // typically this case will occur in
														 // the "open" editing mode.
					//  Close the document
					lpCSimpSvrApp->GetDoc()->Close();

			// hide the app window
			lpCSimpSvrApp->HideAppWnd();

			// if we were started by ole, unregister the class factory, otherwise
			// remove the ref count on our dummy OLE object
			if (lpCSimpSvrApp->IsStartedByOle())
				CoRevokeClassObject(lpCSimpSvrApp->GetRegisterClass());
			else
				lpCSimpSvrApp->GetOleObject()->Release();

			lpCSimpSvrApp->Release();  // This should close the app.

			break;

		case WM_COMMAND:           // message: command from application menu
			return lpCSimpSvrApp->lCommandHandler(hWnd, message, wParam, lParam);
			break;

		case WM_CREATE:
			return lpCSimpSvrApp->lCreateDoc(hWnd, message, wParam, lParam);
			break;

		case WM_DESTROY:                  // message: window being destroyed
			PostQuitMessage(0);
			break;

		case WM_SIZE:
			return lpCSimpSvrApp->lSizeHandler(hWnd, message, wParam, lParam);

		default:                          // Passes it on if unproccessed
			return (DefWindowProc(hWnd, message, wParam, lParam));
		}
		return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
// Comments:
//
//********************************************************************

BOOL FAR PASCAL _export About(HWND hDlg,unsigned message,WORD wParam,LONG lParam)

{
	switch (message) {
	case WM_INITDIALOG:                /* message: initialize dialog box */
		return (TRUE);

	case WM_COMMAND:                      /* message: received a command */
		if (wParam == IDOK                /* "OK" box selected?          */
		|| wParam == IDCANCEL) {      /* System menu close command? */
		EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
		return (TRUE);
		}
		break;
	}
	return (FALSE);                           /* Didn't process a message    */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                            Location
//
//      CSimpSvrApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      IOleObject::QueryInterface          Object
//      IOleInPlaceObject::UIDeactivate     Object
//      IOleObject::DoVerb                  Object
//      IOleInPlaceObject::Release          Object
//
// Comments:
//
//********************************************************************

long FAR PASCAL _export DocWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	HDC hDC;
	PAINTSTRUCT ps;

	switch (message) {
		case WM_COMMAND:           // message: command from application menu
			return lpCSimpSvrApp->lCommandHandler(hWnd, message, wParam, lParam);
			break;

		case WM_PAINT:
			hDC = BeginPaint(hWnd, &ps);

			// tell the app class to paint itself
			if (lpCSimpSvrApp)
				lpCSimpSvrApp->PaintApp (hDC);

			EndPaint(hWnd, &ps);
			break;

		case WM_MENUSELECT:
			lpCSimpSvrApp->SetStatusText();
			break;

	default:                          /* Passes it on if unproccessed    */
		return (DefWindowProc(hWnd, message, wParam, lParam));
	}
	return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\comclass.h ===
//+-------------------------------------------------------------------
//
//  File:       comclass.h
//
//  Contents:   Define class id for use by com class
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#ifndef _COMCLASS_H_
#define _COMCLASS_H_

extern CLSID clsidServer;

void InitDll(void);

#endif // _COMCLASS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\bt\makefile.inc ===
obj\i386\olebt.def: olebt.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\at\oleat.cpp ===
//+-------------------------------------------------------------------
//
//  File:       oleat.cpp
//
//  Contents:   Unique parts of apt model DLL server
//
//  Classes:
//
//  Functions:
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include    <windows.h>
#include    <ole2.h>
#include    <comclass.h>
#include    <uthread.h>

CLSID clsidServer;

void InitDll(void)
{
    clsidServer = clsidAptThreadedDll;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\at\makefile.inc ===
obj\i386\oleat.def: oleat.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\uthread.h ===
//+-------------------------------------------------------------------
//
//  File:       uthread.h
//
//  Contents:   Common constants for thread unit test
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#ifndef _UTHREAD_H_
#define _UTHREAD_H_
#undef UNICODE
#undef _UNICODE

extern const CLSID clsidSingleThreadedDll;
extern const char *pszSingleThreadedDll;

extern const CLSID clsidAptThreadedDll;
extern const char *pszAptThreadedDll;

extern const CLSID clsidBothThreadedDll;
extern const char *pszBothThreadedDll;

#endif // _UTHREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\common\classdef.cpp ===
//+-------------------------------------------------------------------
//
//  File:       classdef.cpp
//
//  Contents:   Common constants for thread unit test
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include <windows.h>
#include <uthread.h>

const CLSID clsidSingleThreadedDll =
    {0xe22e88c0, 0xf72a, 0x11cd, {0xa1,0xaa,0x00,0x00,0x69,0x01,0x29,0x3f}};
const char *pszSingleThreadedDll = "olest.dll";

const CLSID clsidAptThreadedDll =
    {0xe82c0ae0, 0xf72a, 0x11cd, {0xa1,0xaa,0x00,0x00,0x69,0x01,0x29,0x3f}};
const char *pszAptThreadedDll = "oleat.dll";

const CLSID clsidBothThreadedDll =
    {0xe97d4300, 0xf72a, 0x11cd, {0xa1,0xaa,0x00,0x00,0x69,0x01,0x29,0x3f}};
const char *pszBothThreadedDll = "olebt.dll";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\bt\olebt.cpp ===
//+-------------------------------------------------------------------
//
//  File:       olebt.cpp
//
//  Contents:   Test DLL class code that be used multithreaded.
//
//  Classes:
//
//  Functions:
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include    <windows.h>
#include    <ole2.h>
#include    <uthread.h>


// Global count of
ULONG g_UseCount = 0;

void PrintDebugMsg(char *pszMsg, DWORD dwData)
{
    char wszBuf[256];
    wsprintf(wszBuf, "olebt.dll: %s %d\n", pszMsg, dwData);
    OutputDebugString(wszBuf);
}



//+-------------------------------------------------------------------
//
//  Class:    CBasicBndCF
//
//  Synopsis: Class Factory for CBasicBnd
//
//  Methods:  IUnknown      - QueryInterface, AddRef, Release
//            IClassFactory - CreateInstance
//
//  History:  03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class FAR CBasicBndCF: public IClassFactory
{
public:

                        // Constructor/Destructor
                        CBasicBndCF(void);
                        ~CBasicBndCF();

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


                        // IClassFactory
    STDMETHODIMP        CreateInstance(
                            IUnknown FAR* pUnkOuter,
	                    REFIID iidInterface,
			    void FAR* FAR* ppv);

    STDMETHODIMP        LockServer(BOOL fLock);

private:

    ULONG		_cRefs;

    IUnknown *          _punkFm;
};



//+-------------------------------------------------------------------
//
//  Class:    CBasicBnd
//
//  Synopsis: Test class CBasicBnd
//
//  Methods:
//
//  History:  03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class FAR CBasicBnd: public IPersist
{
public:
                        // Constructor/Destructor
                        CBasicBnd(void);
                        ~CBasicBnd();

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

                        // IPersist - only thing we implement because it
                        // gives us a nice way to figure who we are talking to.
    STDMETHODIMP        GetClassID(LPCLSID lpClassID);

private:

    ULONG               _cRefs;

    IUnknown *          _punkFm;
};


extern "C" BOOL WINAPI DllMain(
    HANDLE,
    DWORD,
    LPVOID)
{
    return TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Called by client (from within BindToObject et al)
//              interface requested  should be IUnknown or IClassFactory -
//              Creates ClassFactory object and returns pointer to it
//
//  Arguments:  REFCLSID clsid    - class id
//              REFIID iid        - interface id
//              void FAR* FAR* ppv- pointer to class factory interface
//
//  Returns:    TRUE
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (!IsEqualGUID(iid, IID_IUnknown)
        && !IsEqualGUID(iid, IID_IClassFactory)
        && !IsEqualGUID(iid, IID_IMarshal))
    {
	return E_NOINTERFACE;
    }

    if (IsEqualGUID(clsid, clsidBothThreadedDll))
    {
	IUnknown *punk = new CBasicBndCF();

        HRESULT hr = punk->QueryInterface(iid, ppv);

        punk->Release();

	return hr;
    }

    return E_FAIL;
}


STDAPI DllCanUnloadNow(void)
{
    return (g_UseCount == 0)
	? S_OK
	: S_FALSE;
}




//+-------------------------------------------------------------------
//
//  Member:     CBasicBndCF::CBasicBndCF()
//
//  Synopsis:   The constructor for CBAsicBnd.
//
//  Arguments:  None
//
//  History:    21-Nov-92  Ricksa  Created
//
//--------------------------------------------------------------------
CBasicBndCF::CBasicBndCF(void)
    : _cRefs(1), _punkFm(NULL)
{
    PrintDebugMsg("Creating Class Factory", (DWORD) this);
    g_UseCount++;
}



//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndCF()
//
//  Synopsis:   The destructor for CBasicCF.
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
CBasicBndCF::~CBasicBndCF()
{
    PrintDebugMsg("Deleting Class Factory", (DWORD) this);
    g_UseCount--;

    if (_punkFm != NULL)
    {
        _punkFm->Release();
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IsEqualGUID(iid, IID_IUnknown) || IsEqualGUID(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        hr = S_OK;
    }
    else if (IsEqualGUID(iid, IID_IMarshal))
    {
        if (NULL == _punkFm)
        {
            hr = CoCreateFreeThreadedMarshaler(this, &_punkFm);
        }

        if (_punkFm != NULL)
        {
            return _punkFm->QueryInterface(iid, ppv);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::AddRef
//
//  Synopsis:   Increment reference count
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBndCF::AddRef(void)
{
    return ++_cRefs;
}

//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::Release
//
//  Synopsis:   Decrement reference count
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBndCF::Release(void)
{
    ULONG cRefs = --_cRefs;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}



//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    HRESULT hresult = S_OK;

    if (pUnkOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CBasicBnd *pbb = new FAR CBasicBnd();

    if (pbb == NULL)
    {
	return E_OUTOFMEMORY;
    }

    hresult = pbb->QueryInterface(iidInterface, ppv);

    pbb->Release();

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Method:	CBasicBndCF::LockServer
//
//  Synopsis:   Inc/Dec stay alive count
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBndCF::LockServer(BOOL fLock)
{
    if (fLock)
    {
        g_UseCount++;
    }
    else
    {
        g_UseCount--;
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::CBasicBnd()
//
//  Synopsis:   The constructor for CBAsicBnd. I
//
//  Arguments:  None
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------

CBasicBnd::CBasicBnd(void)
    : _cRefs(1), _punkFm(NULL)
{
    PrintDebugMsg("Creating App Object", (DWORD) this);
    g_UseCount++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------

CBasicBnd::~CBasicBnd(void)
{
    PrintDebugMsg("Deleting App Object", (DWORD) this);
    g_UseCount--;
    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualGUID(iid, IID_IUnknown) || IsEqualGUID(iid, IID_IPersist))
    {
        *ppv = this;
	AddRef();
        return S_OK;
    }
    else if (IsEqualGUID(iid, IID_IMarshal))
    {
        HRESULT hr;

        if (NULL == _punkFm)
        {
            hr = CoCreateFreeThreadedMarshaler(this, &_punkFm);
        }

        if (_punkFm != NULL)
        {
            hr = _punkFm->QueryInterface(iid, ppv);
        }

        return hr;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::AddRef
//
//  Synopsis:   Standard stuff
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBnd::AddRef(void)
{
    return _cRefs++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Release
//
//  Synopsis:   Standard stuff
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBnd::Release(void)
{
    ULONG cRefs;

    if ((cRefs = --_cRefs) == 0)
    {
        delete this;
    }

    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::GetClassID
//
//  Synopsis:   Return the class id
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::GetClassID(LPCLSID classid)
{
    *classid = clsidBothThreadedDll;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\common\sources.inc ===
SYNCHRONIZE_BLOCK=1
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\dload\compch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\st\makefile.inc ===
obj\i386\olest.def: olest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\dload\mobsync.c ===
#include "compch.h"
#pragma hdrstop

#include <syncrasp.h>

static
LRESULT
CALLBACK
SyncMgrRasProc (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    return -1;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mobsync)
{
    DLPENTRY(SyncMgrRasProc)
};

DEFINE_PROCNAME_MAP(mobsync)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\st\olest.cpp ===
//+-------------------------------------------------------------------
//
//  File:       olest.cpp
//
//  Contents:   Unique parts of apt model DLL server
//
//  Classes:
//
//  Functions:
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include    <windows.h>
#include    <ole2.h>
#include    <comclass.h>
#include    <uthread.h>

CLSID clsidServer;

void InitDll(void)
{
    clsidServer = clsidSingleThreadedDll;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\uthread\common\comclass.cpp ===
//+-------------------------------------------------------------------
//
//  File:       comclass.cpp
//
//  Contents:   Test DLL class code that can be used for both apt
//              model and single threaded application
//
//  Classes:
//
//  Functions:
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include    <windows.h>
#include    <ole2.h>
#include    <comclass.h>


// Global count of
ULONG g_UseCount = 0;




//+-------------------------------------------------------------------
//
//  Class:    CBasicBndCF
//
//  Synopsis: Class Factory for CBasicBnd
//
//  Methods:  IUnknown      - QueryInterface, AddRef, Release
//            IClassFactory - CreateInstance
//
//  History:  03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class FAR CBasicBndCF: public IClassFactory
{
public:

                        // Constructor/Destructor
                        CBasicBndCF(REFCLSID rclsid);
                        ~CBasicBndCF();

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


                        // IClassFactory
    STDMETHODIMP        CreateInstance(
                            IUnknown FAR* pUnkOuter,
	                    REFIID iidInterface,
			    void FAR* FAR* ppv);

    STDMETHODIMP        LockServer(BOOL fLock);

private:

    ULONG		_cRefs;

    REFCLSID            _rclsid;

    DWORD               _dwThreadId;
};



//+-------------------------------------------------------------------
//
//  Class:    CBasicBnd
//
//  Synopsis: Test class CBasicBnd
//
//  Methods:
//
//  History:  03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class FAR CBasicBnd: public IPersist
{
public:
                        // Constructor/Destructor
                        CBasicBnd(REFCLSID rclsd, DWORD dwThreadId);
                        ~CBasicBnd();

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

                        // IPersist - only thing we implement because it
                        // gives us a nice way to figure who we are talking to.
    STDMETHODIMP        GetClassID(LPCLSID lpClassID);

private:

    ULONG               _cRefs;

    REFCLSID            _rclsid;

    DWORD               _dwThreadId;
};


extern "C" BOOL WINAPI DllMain(
    HANDLE,
    DWORD,
    LPVOID)
{
    static BOOL fFirst = TRUE;

    if (fFirst)
    {
        InitDll();
        fFirst = FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Called by client (from within BindToObject et al)
//              interface requested  should be IUnknown or IClassFactory -
//              Creates ClassFactory object and returns pointer to it
//
//  Arguments:  REFCLSID clsid    - class id
//              REFIID iid        - interface id
//              void FAR* FAR* ppv- pointer to class factory interface
//
//  Returns:    TRUE
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    if (!IsEqualGUID(iid, IID_IUnknown)
        && !IsEqualGUID(iid, IID_IClassFactory))
    {
	return E_NOINTERFACE;
    }

    if (IsEqualGUID(clsid, clsidServer))
    {
	*ppv = new CBasicBndCF(clsidServer);

	return (*ppv != NULL) ? S_OK : E_OUTOFMEMORY;
    }

    return E_FAIL;
}


STDAPI DllCanUnloadNow(void)
{
    return (g_UseCount == 0)
	? S_OK
	: S_FALSE;
}




//+-------------------------------------------------------------------
//
//  Member:     CBasicBndCF::CBasicBndCF()
//
//  Synopsis:   The constructor for CBAsicBnd.
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
CBasicBndCF::CBasicBndCF(REFCLSID rclsid)
    : _cRefs(1), _rclsid(rclsid), _dwThreadId(GetCurrentThreadId())
{
    g_UseCount++;
}



//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndCF()
//
//  Synopsis:   The destructor for CBasicCF.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
CBasicBndCF::~CBasicBndCF()
{
    g_UseCount--;
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualGUID(iid, IID_IUnknown) || IsEqualGUID(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBasicBndCF::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CBasicBndCF::Release(void)
{
    ULONG cRefs = --_cRefs;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}



//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    if (GetCurrentThreadId() != _dwThreadId)
    {
        return E_UNEXPECTED;
    }

    HRESULT hresult = S_OK;

    if (pUnkOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CBasicBnd *pbb = new FAR CBasicBnd(_rclsid, _dwThreadId);

    if (pbb == NULL)
    {
	return E_OUTOFMEMORY;
    }

    hresult = pbb->QueryInterface(iidInterface, ppv);

    pbb->Release();

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Method:	CBasicBndCF::LockServer
//
//  Synopsis:	Who knows what this is for?
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBndCF::LockServer(BOOL fLock)
{
    if (GetCurrentThreadId() != _dwThreadId)
    {
        return E_UNEXPECTED;
    }

    if (fLock)
    {
        g_UseCount++;
    }
    else
    {
        g_UseCount--;
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::CBasicBnd()
//
//  Synopsis:   The constructor for CBAsicBnd. I
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::CBasicBnd(REFCLSID rclsid, DWORD dwThreadId)
    : _cRefs(1), _rclsid(rclsid), _dwThreadId(dwThreadId)
{
    g_UseCount++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::~CBasicBnd()
{
    g_UseCount--;
    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::QueryInterface(REFIID iid, void **ppv)
{
    if (GetCurrentThreadId() != _dwThreadId)
    {
        return E_UNEXPECTED;
    }

    if (IsEqualGUID(iid, IID_IUnknown) || IsEqualGUID(iid, IID_IPersist))
    {
        *ppv = this;
	AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::AddRef
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBnd::AddRef(void)
{
    return _cRefs++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Release
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBasicBnd::Release(void)
{
    ULONG cRefs;

    if ((cRefs = --_cRefs) == 0)
    {
        delete this;
    }

    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Interface:  IPersist
//
//  Synopsis:   IPersist interface methods
//              Need to return a valid class id here
//
//  History:    21-Nov-92  SarahJ  Created
//

STDMETHODIMP CBasicBnd::GetClassID(LPCLSID classid)
{
    if (GetCurrentThreadId() != _dwThreadId)
    {
        return E_UNEXPECTED;
    }

    *classid = _rclsid;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\dload\rpcrt4.c ===
#include "compch.h"
#pragma hdrstop

#include "rpcdce.h"

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPC_STATUS
RPC_ENTRY
UuidCreate (
    OUT UUID* Uuid
    )
{
    ZeroMemory(Uuid, sizeof(*Uuid));
    return RPC_E_UNEXPECTED;
}

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringA (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    )
{
    return RPC_E_UNEXPECTED;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(rpcrt4)
{
    DLPENTRY(RpcStringFreeA)
    DLPENTRY(UuidCreate)
    DLPENTRY(UuidToStringA)
};

DEFINE_PROCNAME_MAP(rpcrt4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\dload\ole32.c ===
#include "compch.h"
#pragma hdrstop

#define _OLE32_
#include <objidl.h>

#undef WINOLEAPI
#define WINOLEAPI           HRESULT STDAPICALLTYPE
#undef  WINOLEAPI_
#define WINOLEAPI_(_x)      _x STDAPICALLTYPE


static
WINOLEAPI
CLSIDFromProgID(
    IN LPCOLESTR lpszProgID,
    OUT LPCLSID lpclsid
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CLSIDFromString(
    IN LPOLESTR lpsz,
    OUT LPCLSID pclsid
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoCancelCall(
    IN DWORD dwThreadId,
    IN ULONG ulTimeout
    )
{
    return E_FAIL;
}
 

static
WINOLEAPI
CoCreateGuid(
    OUT GUID * pGuid
    )
{
    return RPC_S_OUT_OF_MEMORY;
}
 

static
WINOLEAPI
CoCreateInstance(
    IN REFCLSID rclsid,
    IN LPUNKNOWN pUnkOuter,
    IN DWORD dwClsContext,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )
{
    *ppv = NULL;
    return E_FAIL;
}

static
WINOLEAPI
CoDisableCallCancellation(
    IN LPVOID pReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoDisconnectObject(
    IN LPUNKNOWN pUnk,
    IN DWORD dwReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoEnableCallCancellation(
    IN LPVOID pReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoInitialize(
    IN LPVOID pvReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoInitializeEx(
    IN LPVOID pvReserved,
    IN DWORD  dwCoInit
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoInitializeSecurity(
    IN PSECURITY_DESCRIPTOR         pSecDesc,
    IN LONG                         cAuthSvc,
    IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
    IN void                        *pReserved1,
    IN DWORD                        dwAuthnLevel,
    IN DWORD                        dwImpLevel,
    IN void                        *pAuthList,
    IN DWORD                        dwCapabilities,
    IN void                        *pReserved3
    )
{
    return E_FAIL;
}

static
WINOLEAPI CoImpersonateClient()
{
    return E_FAIL;
}

static
WINOLEAPI
CoRevertToSelf()
{
    return E_FAIL;
}

static
WINOLEAPI 
CoSwitchCallContext( 
    IN IUnknown *pNewObject, 
    OUT IUnknown **ppOldObject )
{
    return E_FAIL;
}

static
WINOLEAPI
CoMarshalInterface(
    IN LPSTREAM pStm,
    IN REFIID riid,
    IN LPUNKNOWN pUnk,
    IN DWORD dwDestContext,
    IN LPVOID pvDestContext,
    IN DWORD mshlflags
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoRegisterClassObject(
    IN REFCLSID rclsid,
    IN LPUNKNOWN pUnk,
    IN DWORD dwClsContext,
    IN DWORD flags,
    OUT LPDWORD lpdwRegister
    )
{
    return E_FAIL;
}


static
WINOLEAPI
CoReleaseMarshalData(
    IN LPSTREAM pStm
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoResumeClassObjects(
    void
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoRevokeClassObject(
    IN DWORD dwRegister
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoSetProxyBlanket(
    IN IUnknown                 *pProxy,
    IN DWORD                     dwAuthnSvc,
    IN DWORD                     dwAuthzSvc,
    IN OLECHAR                  *pServerPrincName,
    IN DWORD                     dwAuthnLevel,
    IN DWORD                     dwImpLevel,
    IN RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    IN DWORD                     dwCapabilities
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoSuspendClassObjects(
    void
    )
{
    return E_FAIL;
}

static
WINOLEAPI_(LPVOID)
CoTaskMemAlloc(
    IN SIZE_T cb
    )
{
    return NULL;
}

static
WINOLEAPI_(LPVOID)
CoTaskMemRealloc(
    IN LPVOID pv,
    IN SIZE_T cb
    )
{
    return NULL;
}

static
WINOLEAPI_(void)
CoTaskMemFree(
    IN LPVOID pv
    )
{
    NOTHING;
}


static
WINOLEAPI_(void) 
CoUninitialize(
    void
    )
{
    NOTHING;
}

static
WINOLEAPI
CoUnmarshalInterface(
    IN LPSTREAM pStm,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateClassMoniker(
    IN REFCLSID rclsid,
    OUT LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;
    return E_FAIL;
}

static
WINOLEAPI
CreateItemMoniker(
    IN LPCOLESTR lpszDelim,
    IN LPCOLESTR lpszItem,
    OUT LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;
    return E_FAIL;
}

static
WINOLEAPI
CreateStreamOnHGlobal(
    IN HGLOBAL hGlobal,
    IN BOOL fDeleteOnRelease,
    OUT LPSTREAM FAR* ppstm
    )
{
    return E_FAIL;
}

static
WINOLEAPI
GetRunningObjectTable(
    IN DWORD reserved,
    OUT LPRUNNINGOBJECTTABLE FAR* pprot
    )
{
    *pprot = NULL;
    return E_FAIL;
}

static
WINOLEAPI
MkParseDisplayName(
  LPBC pbc,
  LPCOLESTR szUserName,
  ULONG FAR *pchEaten,
  LPMONIKER FAR *ppmk
)
{
    *ppmk = NULL;
    return E_FAIL;
}

static
WINOLEAPI
OleInitialize(
    IN LPVOID pvReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleLoadFromStream(
    IN LPSTREAM pStm,
    IN REFIID iidInterface,
    OUT LPVOID FAR* ppvObj
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleSaveToStream(
    IN LPPERSISTSTREAM pPStm,
    IN LPSTREAM pStm
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleLockRunning(
    IN LPUNKNOWN pUnknown,
    IN BOOL fLock,
    IN BOOL fLastUnlockCloses
    )
{
    return E_FAIL;
}

static
WINOLEAPI_(void)
OleUninitialize(
    void
    )
{
    NOTHING;
}

static
WINOLEAPI
ProgIDFromCLSID(
    IN REFCLSID clsid,
    OUT LPOLESTR FAR* lplpszProgID
    )
{
    return E_FAIL;
}


static
WINOLEAPI
StringFromCLSID(
    IN REFCLSID rclsid,
    OUT LPOLESTR FAR* lplpsz
    )
{
    return E_FAIL;
}

static
WINOLEAPI
WriteClassStm(
    IN LPSTREAM pStm,
    IN REFCLSID rclsid
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateDataAdviseHolder(
    OUT LPDATAADVISEHOLDER FAR* ppDAHolder
    )
{
    return E_FAIL;
}

static
WINOLEAPI
StgCreateDocfile(
    IN const OLECHAR FAR* pwcsName,
    IN DWORD grfMode,
    IN DWORD reserved,
    OUT IStorage FAR * FAR *ppstgOpen
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateILockBytesOnHGlobal(
    IN HGLOBAL hGlobal,
    IN BOOL fDeleteOnRelease,
    OUT LPLOCKBYTES FAR* pplkbyt
    )
{
    return E_FAIL;
}

static
WINOLEAPI
StgCreateDocfileOnILockBytes(
    IN ILockBytes FAR *plkbyt,
    IN DWORD grfMode,
    IN DWORD reserved,
    OUT IStorage FAR * FAR *ppstgOpen
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleQueryCreateFromData(
    IN LPDATAOBJECT pSrcDataObject
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleQueryLinkFromData(
    IN LPDATAOBJECT pSrcDataObject
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateFileMoniker(
    IN LPCOLESTR lpszPathName, 
    OUT LPMONIKER FAR* ppmk
    )
{
    return E_FAIL;
}

static
WINOLEAPI
GetClassFile(
    IN LPCOLESTR szFilename, 
    OUT CLSID FAR* pclsid
    )
{
    return E_FAIL;
}

static
WINOLEAPI
StgOpenStorage(
    IN const OLECHAR FAR* pwcsName,
    IN  IStorage FAR *pstgPriority,
    IN  DWORD grfMode,
    IN  SNB snbExclude,
    IN  DWORD reserved,
    OUT IStorage FAR * FAR *ppstgOpen
    )
{
    return E_FAIL;
}

static
WINOLEAPI_(int)
StringFromGUID2(
    IN REFGUID rguid,
    OUT LPOLESTR lpsz, 
    IN int cchMax
    )
{
    return 0;
}

static
WINOLEAPI
CoMarshalInterThreadInterfaceInStream(
    IN REFIID riid,
    IN LPUNKNOWN pUnk,
    OUT LPSTREAM *ppStm
    )
{
    return E_FAIL;
}

static 
WINOLEAPI
CoGetInterfaceAndReleaseStream(
    IN LPSTREAM pStm, 
    IN REFIID iid,
    OUT LPVOID FAR* ppv)
{
    return E_FAIL;
}

static 
WINOLEAPI
DoDragDrop(
    IN LPDATAOBJECT pDataObj,
    IN LPDROPSOURCE pDropSource,
    IN DWORD dwOKEffects,
    OUT LPDWORD pdwEffect
    )
{
    return E_FAIL;
}

static 
WINOLEAPI
OleGetClipboard(
    OUT LPDATAOBJECT FAR* ppDataObj
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleSetClipboard(
    IN LPDATAOBJECT pDataObj
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleRegEnumVerbs(
    IN REFCLSID clsid,
    OUT LPENUMOLEVERB FAR* ppenum
    )
{
    return E_FAIL;
}

static
WINOLEAPI
PropVariantClear(
    PROPVARIANT * pvar
    )
{
    return E_FAIL;
}

static
WINOLEAPI_(void)
ReleaseStgMedium(
    IN LPSTGMEDIUM pmedium
    )
{
    NOTHING;
}

static
WINOLEAPI_(void)
CoFreeUnusedLibraries(void)
{
    NOTHING;
}

static
WINOLEAPI
RevokeDragDrop(
    IN HWND hwnd
    )
{
    return E_FAIL;
}

static
WINOLEAPI
RegisterDragDrop(
    IN HWND hwnd,
    IN LPDROPTARGET pDropTarget
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleFlushClipboard(void)
{
    return E_FAIL;
}

static
WINOLEAPI
CoGetMalloc(
    IN DWORD dwMemContext,
    OUT LPMALLOC FAR* ppMalloc
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleRegGetMiscStatus(
    IN REFCLSID clsid,
    IN DWORD dwAspect,
    OUT DWORD FAR* pdwStatus
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleRegGetUserType(
    IN REFCLSID clsid,
    IN DWORD dwFormOfType,
    OUT LPOLESTR FAR* pszUserType
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateOleAdviseHolder(
    OUT LPOLEADVISEHOLDER FAR* ppOAHolder
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleRun(
    IN LPUNKNOWN pUnknown
    )
{
    return E_FAIL;
}

static
WINOLEAPI
FreePropVariantArray(
    ULONG cVariants,
    PROPVARIANT * rgvars
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateBindCtx(
    IN DWORD reserved,
    OUT LPBC FAR* ppbc
    )
{
    return E_FAIL;
}

static
WINOLEAPI
StgOpenStorageEx(
    IN const WCHAR* pwcsName,
    IN  DWORD grfMode,
    IN  DWORD stgfmt,              // enum
    IN  DWORD grfAttrs,             // reserved
    IN  STGOPTIONS * pStgOptions,
    IN  void * reserved,
    IN  REFIID riid,
    OUT void ** ppObjectOpen
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoGetClassObject(
    IN REFCLSID rclsid,
    IN DWORD dwClsContext,
    IN LPVOID pvReserved,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )
{
    *ppv = NULL;
    return E_FAIL;
}  

static
WINOLEAPI
OleDraw(
    IN LPUNKNOWN pUnknown,
    IN DWORD dwAspect,
    IN HDC hdcDraw,
    IN LPCRECT lprcBounds
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAPI
OleCreateFromData(
    IN LPDATAOBJECT pSrcDataObj,
    IN REFIID riid,
    IN DWORD renderopt,
    IN LPFORMATETC pFormatEtc,
    IN LPOLECLIENTSITE pClientSite,
    IN LPSTORAGE pStg,
    OUT LPVOID FAR* ppvObj
    )
{
    *ppvObj = NULL;
    return E_FAIL;
}

static
WINOLEAPI
OleSetMenuDescriptor(
    IN HOLEMENU holemenu,
    IN HWND hwndFrame,
    IN HWND hwndActiveObject,
    IN LPOLEINPLACEFRAME lpFrame,
    IN LPOLEINPLACEACTIVEOBJECT lpActiveObj
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleSave(
    IN LPPERSISTSTORAGE pPS,
    IN LPSTORAGE pStg,
    IN BOOL fSameAsLoad
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoFileTimeNow(
    OUT FILETIME FAR* lpFileTime
    )
{
    lpFileTime->dwHighDateTime = 0;
    lpFileTime->dwLowDateTime = GetTickCount();
    return S_OK;
}
    
static
WINOLEAPI
CoRegisterMessageFilter(
    IN LPMESSAGEFILTER lpMessageFilter,
    OUT LPMESSAGEFILTER FAR* lplpMessageFilter
    )
{
    return E_FAIL;
}

static
WINOLEAPI
GetHGlobalFromStream(
    IN LPSTREAM pstm,
    OUT HGLOBAL FAR* phglobal
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAPI
PropVariantCopy(
    PROPVARIANT * pvarDest,
    const PROPVARIANT * pvarSrc
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoAllowSetForegroundWindow(
    IN IUnknown *pUnk,
    IN LPVOID lpvReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoCreateFreeThreadedMarshaler(
    IN LPUNKNOWN  punkOuter,
    OUT LPUNKNOWN *ppunkMarshal
    )
{
    *ppunkMarshal = NULL;
    return E_FAIL;
}

static
WINOLEAPI
CoWaitForMultipleHandles(
    IN DWORD dwFlags,
    IN DWORD dwTimeout,
    IN ULONG cHandles,
    IN LPHANDLE pHandles,
    OUT LPDWORD  lpdwindex)
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ole32)
{
    DLPENTRY(CLSIDFromProgID)
    DLPENTRY(CLSIDFromString)
    DLPENTRY(CoAllowSetForegroundWindow)
    DLPENTRY(CoCancelCall)
    DLPENTRY(CoCreateFreeThreadedMarshaler)
    DLPENTRY(CoCreateGuid)
    DLPENTRY(CoCreateInstance)
    DLPENTRY(CoDisableCallCancellation)
    DLPENTRY(CoDisconnectObject)
    DLPENTRY(CoEnableCallCancellation)
    DLPENTRY(CoFileTimeNow)
    DLPENTRY(CoFreeUnusedLibraries)
    DLPENTRY(CoGetClassObject)
    DLPENTRY(CoGetInterfaceAndReleaseStream)
    DLPENTRY(CoGetMalloc)
    DLPENTRY(CoImpersonateClient)
    DLPENTRY(CoInitialize)
    DLPENTRY(CoInitializeEx)
    DLPENTRY(CoInitializeSecurity)
    DLPENTRY(CoMarshalInterThreadInterfaceInStream)
    DLPENTRY(CoMarshalInterface)
    DLPENTRY(CoRegisterClassObject)
    DLPENTRY(CoRegisterMessageFilter)
    DLPENTRY(CoReleaseMarshalData)
    DLPENTRY(CoResumeClassObjects)
    DLPENTRY(CoRevertToSelf)
    DLPENTRY(CoRevokeClassObject)
    DLPENTRY(CoSetProxyBlanket)
    DLPENTRY(CoSuspendClassObjects)
    DLPENTRY(CoSwitchCallContext)
    DLPENTRY(CoTaskMemAlloc)
    DLPENTRY(CoTaskMemFree)
    DLPENTRY(CoTaskMemRealloc)
    DLPENTRY(CoUninitialize)
    DLPENTRY(CoUnmarshalInterface)
    DLPENTRY(CoWaitForMultipleHandles)
    DLPENTRY(CreateBindCtx)
    DLPENTRY(CreateClassMoniker)
    DLPENTRY(CreateDataAdviseHolder)
    DLPENTRY(CreateFileMoniker)
    DLPENTRY(CreateILockBytesOnHGlobal)
    DLPENTRY(CreateItemMoniker)
    DLPENTRY(CreateOleAdviseHolder)
    DLPENTRY(CreateStreamOnHGlobal)
    DLPENTRY(DoDragDrop)
    DLPENTRY(FreePropVariantArray)
    DLPENTRY(GetClassFile)
    DLPENTRY(GetHGlobalFromStream)
    DLPENTRY(GetRunningObjectTable)
    DLPENTRY(MkParseDisplayName)
    DLPENTRY(OleCreateFromData)
    DLPENTRY(OleDraw)
    DLPENTRY(OleFlushClipboard)
    DLPENTRY(OleGetClipboard)
    DLPENTRY(OleInitialize)
    DLPENTRY(OleLoadFromStream)
    DLPENTRY(OleLockRunning)
    DLPENTRY(OleQueryCreateFromData)
    DLPENTRY(OleQueryLinkFromData)
    DLPENTRY(OleRegEnumVerbs)
    DLPENTRY(OleRegGetMiscStatus)
    DLPENTRY(OleRegGetUserType)
    DLPENTRY(OleRun)
    DLPENTRY(OleSave)
    DLPENTRY(OleSaveToStream)
    DLPENTRY(OleSetClipboard)
    DLPENTRY(OleSetMenuDescriptor)
    DLPENTRY(OleUninitialize)
    DLPENTRY(ProgIDFromCLSID)
    DLPENTRY(PropVariantClear)
    DLPENTRY(PropVariantCopy)
    DLPENTRY(RegisterDragDrop)
    DLPENTRY(ReleaseStgMedium)
    DLPENTRY(RevokeDragDrop)
    DLPENTRY(StgCreateDocfile)
    DLPENTRY(StgCreateDocfileOnILockBytes)
    DLPENTRY(StgOpenStorage)
    DLPENTRY(StgOpenStorageEx)
    DLPENTRY(StringFromCLSID)
    DLPENTRY(StringFromGUID2)
    DLPENTRY(WriteClassStm)         
};

DEFINE_PROCNAME_MAP(ole32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\idlole\comcat\makefile.inc ===
#
# Special hack for comcat.  Turn off 4090 until midl is fixed to generate the remote thunks
# correctly.
#

$(O)\comcat_p.obj : $(O)\comcat_p.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    type << > $(O)\comcat_warning.h
#pragma warning(4:4090)
#pragma warning(4:4047)
#undef _MIDL_USE_GUIDDEF_
#undef __RPCNDR_H__ 	
#undef __RPC_H__ 	
#undef RPC_NO_WINDOWS_H
#undef COM_NO_WINDOWS_H
#undef GUID_DEFS_ONLY
#define REGISTER_PROXY_DLL
<<
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$O/" $(USE_FC) $(USECXX_FLAG) $?
$(EX_C_COMPILER_FLAGS)
-FI$(O)\comcat_warning.h
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\dload\oleaut32.c ===
#include "compch.h"
#pragma hdrstop

#define _OLEAUT32_
#include <oleauto.h>
#include <olectl.h>

#undef WINOLEAUTAPI
#define WINOLEAUTAPI    HRESULT STDAPICALLTYPE
#undef WINOLECTLAPI
#define WINOLECTLAPI    HRESULT STDAPICALLTYPE
#undef WINOLEAUTAPI_
#define WINOLEAUTAPI_(type) type STDAPICALLTYPE
    

static
STDMETHODIMP_(BSTR)
SysAllocString(
    const OLECHAR * string
    )
{
    return NULL;
}

static
STDMETHODIMP_(void)
SysFreeString(
    BSTR bstrString
    )
{
    return;
}

static
STDMETHODIMP_(void)
VariantInit(
    VARIANTARG * pvarg
    )
{
    pvarg->vt = VT_EMPTY;

    return;
}

static
STDMETHODIMP
VariantClear(
    VARIANTARG * pvarg
    )
{
    pvarg->vt = VT_EMPTY;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(BSTR)
SysAllocStringByteLen(
    LPCSTR psz,
    UINT len
    )
{
    return NULL;
}

static
STDMETHODIMP_(UINT)
SafeArrayGetDim(
    SAFEARRAY * psa
    )
{
    return 0;
}

static
STDMETHODIMP_(UINT)
SysStringByteLen(
    BSTR bstr
    )
{
    return 0;
}

static
STDMETHODIMP_(SAFEARRAY *)
SafeArrayCreateVector(
    VARTYPE vt,
    LONG lLbound,
    ULONG cElements
    )
{
    return NULL;
}

static
STDMETHODIMP_(SAFEARRAY *)
SafeArrayCreate(
    VARTYPE vt,
    UINT cDims,
    SAFEARRAYBOUND * rgsabound
    )
{
    return NULL;
}

static
STDMETHODIMP
SafeArrayCopy(
    SAFEARRAY * psa,
    SAFEARRAY ** ppsaOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayPutElement(
    SAFEARRAY * psa,
    LONG * rgIndices,
    void * pv
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayDestroy(
    SAFEARRAY * psa
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayAccessData(
    SAFEARRAY * psa,
    void HUGEP** ppvData
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayUnaccessData(
    SAFEARRAY * psa
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(INT)
VariantTimeToSystemTime(
    DOUBLE vtime,
    LPSYSTEMTIME lpSystemTime
    )
{
    return FALSE;
}

static
STDMETHODIMP
OleCreatePropertyFrame(
    HWND hwndOwner,
    UINT x,
    UINT y,
    LPCOLESTR lpszCaption,
    ULONG cObjects,
    LPUNKNOWN FAR* ppUnk,
    ULONG cPages,
    LPCLSID pPageClsID,
    LCID lcid,
    DWORD dwReserved,
    LPVOID pvReserved)
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(UINT)
SysStringLen(
    BSTR bstr
    )
{
    return 0;
}

static
STDMETHODIMP
LoadRegTypeLib(
    REFGUID rguid,
    WORD wVerMajor,
    WORD wVerMinor,
    LCID lcid,
    ITypeLib ** pptlib
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SetErrorInfo(
    ULONG dwReserved,
    IErrorInfo * perrinfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(INT)
SystemTimeToVariantTime(
    LPSYSTEMTIME lpSystemTime,
    DOUBLE *pvtime
    )
{
    return 0;
}

static
STDMETHODIMP
VariantCopy(
    VARIANTARG * pvargDest,
    VARIANTARG * pvargSrc
    )
{
    return E_OUTOFMEMORY;
}

static
STDMETHODIMP_(INT)
DosDateTimeToVariantTime(
    USHORT wDosDate,
    USHORT wDosTime,
    DOUBLE * pvtime
    )
{
    return 0;
}

static
STDMETHODIMP_(INT)
VariantTimeToDosDateTime(
    DOUBLE vtime,
    USHORT * pwDosDate,
    USHORT * pwDosTime
    )
{
    return 0;
}

static
STDMETHODIMP
SafeArrayGetUBound(
    SAFEARRAY * psa,
    UINT nDim,
    LONG * plUbound
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarDiv(
    LPVARIANT pvarLeft,
    LPVARIANT pvarRight,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarNeg(
    LPVARIANT pvarIn,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarRound(
    LPVARIANT pvarIn,
    int cDecimals,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarCmp(
    LPVARIANT pvarLeft,
    LPVARIANT pvarRight,
    LCID lcid,
    ULONG dwFlags
    )
{
    return VARCMP_NULL;
}

static
STDMETHODIMP
VarMul(
    LPVARIANT pvarLeft,
    LPVARIANT pvarRight,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarPow(
    LPVARIANT pvarLeft,
    LPVARIANT pvarRight,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
RegisterTypeLib(
    ITypeLib * ptlib,
    OLECHAR  *szFullPath,
    OLECHAR  *szHelpDir
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
LoadTypeLib(
    const OLECHAR *szFile,
    ITypeLib ** pptlib
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(BSTR)
SysAllocStringLen(
    const OLECHAR * strIn,
    UINT cch
    )
{
    return NULL;
}

static
STDMETHODIMP
VariantChangeType(
    VARIANTARG * pvargDest,
    VARIANTARG * pvarSrc,
    USHORT wFlags,
    VARTYPE vt
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayGetLBound(
    SAFEARRAY * psa,
    UINT nDim,
    LONG * plLbound
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
DispInvoke(
    void * _this,
    ITypeInfo * ptinfo,
    DISPID dispidMember,
    WORD wFlags,
    DISPPARAMS * pparams,
    VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo,
    UINT * puArgErr
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAUTAPI
DispGetIDsOfNames(
    ITypeInfo * ptinfo,
    OLECHAR ** rgszNames,
    UINT cNames,
    DISPID * rgdispid
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAUTAPI
SafeArrayGetElement(
    SAFEARRAY* psa,
    LONG* rgIndices,
    void* pv
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLECTLAPI
OleCreatePropertyFrameIndirect(
    LPOCPFIPARAMS lpParams
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VariantCopyInd(
    VARIANT* pvarDest,
    VARIANTARG* pvargSrc
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAUTAPI_(UINT)
SafeArrayGetElemsize(
    SAFEARRAY * psa
    )
{
    return 0;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(oleaut32)
{
    DLOENTRY(  2, SysAllocString)
    DLOENTRY(  4, SysAllocStringLen)
    DLOENTRY(  6, SysFreeString)
    DLOENTRY(  7, SysStringLen)
    DLOENTRY(  8, VariantInit)
    DLOENTRY(  9, VariantClear)
    DLOENTRY( 10, VariantCopy)
    DLOENTRY( 11, VariantCopyInd)
    DLOENTRY( 12, VariantChangeType)
    DLOENTRY( 13, VariantTimeToDosDateTime)
    DLOENTRY( 14, DosDateTimeToVariantTime)
    DLOENTRY( 15, SafeArrayCreate)
    DLOENTRY( 16, SafeArrayDestroy)
    DLOENTRY( 17, SafeArrayGetDim)
    DLOENTRY( 18, SafeArrayGetElemsize)
    DLOENTRY( 19, SafeArrayGetUBound)
    DLOENTRY( 20, SafeArrayGetLBound)
    DLOENTRY( 23, SafeArrayAccessData)
    DLOENTRY( 24, SafeArrayUnaccessData)
    DLOENTRY( 25, SafeArrayGetElement)
    DLOENTRY( 26, SafeArrayPutElement)
    DLOENTRY( 27, SafeArrayCopy)
    DLOENTRY( 29, DispGetIDsOfNames)
    DLOENTRY( 30, DispInvoke)
    DLOENTRY(143, VarDiv)
    DLOENTRY(149, SysStringByteLen)
    DLOENTRY(150, SysAllocStringByteLen)
    DLOENTRY(156, VarMul)
    DLOENTRY(158, VarPow)
    DLOENTRY(161, LoadTypeLib)
    DLOENTRY(162, LoadRegTypeLib)
    DLOENTRY(163, RegisterTypeLib)
    DLOENTRY(173, VarNeg)
    DLOENTRY(175, VarRound)
    DLOENTRY(176, VarCmp)
    DLOENTRY(184, SystemTimeToVariantTime)
    DLOENTRY(185, VariantTimeToSystemTime)
    DLOENTRY(201, SetErrorInfo)
    DLOENTRY(411, SafeArrayCreateVector)
    DLOENTRY(416, OleCreatePropertyFrameIndirect)
    DLOENTRY(417, OleCreatePropertyFrame)
};

DEFINE_ORDINAL_MAP(oleaut32);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\idlole\genxie\comcat.c ===
#include "comcat_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\idlole\idl\makefile.inc ===
callobj.idl : ..\public\callobj.idl
ocidl.idl   : ..\public\ocidl.idl
wtypes.idl  : ..\public\wtypes.idl
unknwn.idl  : ..\public\unknwn.idl
objidl.idl  : ..\public\objidl.idl
propidl.idl : ..\public\propidl.idl
pbagex.idl  : ..\public\pbagex.idl
oleidl.idl  : ..\public\oleidl.idl
oaidl.idl   : ..\public\oaidl.idl
storext.idl : ..\public\storext.idl
iaccess.idl : ..\public\iaccess.idl
immact.idl  : ..\public\immact.idl
obase.idl   : ..\public\obase.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\idlole\h\idlmulti.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       idlmulti.h
//
//  Contents:   preprocessor trickery to make our .idl/.tdl files compile
//              with MIDL or APBU Mktyplib.
//
//  History:    27-May-94   DonCl     Created
//              20-Jul-94   ErikGav   Remove SDKTOOLS support
//
//----------------------------------------------------------------------------

#ifndef __IDLMULTI_H__
#define __IDLMULTI_H__

#define ENDCOCLASS  };


#ifndef __MKTYPLIB__
#define TYPEDEF(guid)   \
typedef

#define LOCAL_INTERFACE(guid)       \
[                                   \
    local,                          \
    object,                         \
    uuid(guid),                     \
    pointer_default(unique)         \
]


#define REMOTED_INTERFACE(guid)     \
[                                   \
    object,                         \
    uuid(guid),                     \
    pointer_default(unique)         \
]


#define BEGINEVENTSET(es)   \
eventset es  \
{            \

#define ENDEVENTSET  };


#define COCLASS(name, dispint, events)  \
cotype name                                                 \
{                                                           \
    dispinterface dispint;                                  \
    eventset events;



#else // __MKTYPLIB__

#define TYPEDEF(guid) typedef [uuid(guid)]

#define cpp_quote(string)

#define const

#define LOCAL_INTERFACE(guid)    \
[                           \
    uuid(guid),             \
    odl                     \
]

#define REMOTED_INTERFACE(guid)   \
[                           \
    uuid(guid),             \
    odl                     \
]

#define BEGINEVENTSET(es)  \
dispinterface es           \
{                          \
properties:                \
                           \
methods:                   \

#define ENDEVENTSET  };


#define COCLASS(name, dispint, events)          \
coclass name                                    \
{                                               \
    [default] dispinterface dispint;            \
    [source, default] dispinterface events;     \



#endif  /// MKTYPLIB

#endif  // __IDLMULTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\idlole\public\makefile.inc ===
#
# Inference Rules
#
.SUFFIXES:.acf

.idl{$(SDK_INC_PATH)}.idl:
    copy $? $@

.acf{$(SDK_INC_PATH)}.acf:
    copy $? $@

$(SDK_INC_PATH)\ocidl.idl:$(@F)
$(SDK_INC_PATH)\ocidl.acf:$(@F)
$(SDK_INC_PATH)\wtypes.idl:$(@F)
$(SDK_INC_PATH)\unknwn.idl:$(@F)
$(SDK_INC_PATH)\objidl.idl:$(@F)
$(SDK_INC_PATH)\propidl.idl:$(@F)
$(SDK_INC_PATH)\pbagex.idl:$(@F)
$(SDK_INC_PATH)\oleidl.idl:$(@F)
$(SDK_INC_PATH)\oaidl.idl:$(@F)
$(SDK_INC_PATH)\oaidl.acf:$(@F)
$(SDK_INC_PATH)\storext.idl:$(@F)
$(SDK_INC_PATH)\iaccess.idl:$(@F)
$(SDK_INC_PATH)\iaccess.acf:$(@F)
    copy $** $@
$(SDK_INC_PATH)\callobj.idl:$(@F)

clean:
    -del /F /Q $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\mc\makefile.inc ===
$(O)\allerror.mc:    smctlerr.mc smgmterr.mc oledberr.mc reconcil.mc a_first.x z_last.x
    copy a_first.x + smctlerr.mc + smgmterr.mc + oledberr.mc + z_last.x $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\inc\sens.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sens.h

Abstract:

    This file is the master header file for Event System events published
    and subscribed by the System Event Notification service (SENS).

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          12/8/1997         Start.

--*/


#ifndef __SENS_H__
#define __SENS_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// Constants
//

#define CONNECTION_LAN   0x00000001
#define CONNECTION_WAN   0x00000002
#define CONNECTION_AOL   0x00000004




//
// SENS Guids related to Event System
//


DEFINE_GUID(
    SENSGUID_PUBLISHER,             /* 5fee1bd6-5b9b-11d1-8dd2-00aa004abd5e */
    0x5fee1bd6,
    0x5b9b,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_SUBSCRIBER_LCE,        /* d3938ab0-5b9d-11d1-8dd2-00aa004abd5e */
    0xd3938ab0,
    0x5b9d,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_SUBSCRIBER_WININET,    /* d3938ab5-5b9d-11d1-8dd2-00aa004abd5e */
    0xd3938ab5,
    0x5b9d,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);





//
// Classes of Events published by SENS
//

DEFINE_GUID(
    SENSGUID_EVENTCLASS_NETWORK,        /* d5978620-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978620,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_EVENTCLASS_LOGON,          /* d5978630-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978630,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_EVENTCLASS_ONNOW,          /* d5978640-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978640,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_EVENTCLASS_LOGON2,         /* d5978650-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978650,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);


#endif // __SENS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\inc\sensapip.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sensapip.h

Abstract:

    This header file is used by components external to System Event
    Notification Service (SENS). These components will call SENS to
    notify it of events related to themselves.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/4/1997         Start.

--*/


#ifndef __SENSAPIP_H__
#define __SENSAPIP_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// Includes
//


#if !defined(__midl)
#include <netcon.h>
#else
import "netcon.idl";
#endif // __midl

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

#define SENS_NOTIFY_RAS_STARTED                 0x00000001
#define SENS_NOTIFY_RAS_STOPPED                 0x00000002
#define SENS_NOTIFY_RAS_CONNECT                 0x00000004
#define SENS_NOTIFY_RAS_DISCONNECT              0x00000008
#define SENS_NOTIFY_RAS_DISCONNECT_PENDING      0x00000010
#define SENS_NOTIFY_LAN_CONNECT                 0x00000020
#define SENS_NOTIFY_LAN_DISCONNECT              0x00000040

#define SENS_NOTIFY_WINLOGON_LOGON              0x00001000
#define SENS_NOTIFY_WINLOGON_LOGOFF             0x00002000
#define SENS_NOTIFY_WINLOGON_STARTUP            0x00004000
#define SENS_NOTIFY_WINLOGON_STARTSHELL         0x00008000
#define SENS_NOTIFY_WINLOGON_SHUTDOWN           0x00010000
#define SENS_NOTIFY_WINLOGON_LOCK               0x00020000
#define SENS_NOTIFY_WINLOGON_UNLOCK             0x00040000
#define SENS_NOTIFY_WINLOGON_STARTSCREENSAVER   0x00080000
#define SENS_NOTIFY_WINLOGON_STOPSCREENSAVER    0x00100000
#define SENS_NOTIFY_WINLOGON_POSTSHELL          0x00200000
#define SENS_NOTIFY_WINLOGON_SESSION_DISCONNECT 0x00400000
#define SENS_NOTIFY_WINLOGON_SESSION_RECONNECT  0x00800000

//
// Typedefs
//

typedef DWORD SENS_HRASCONN;

typedef struct _WINLOGON_INFO
{
    ULONG Size;
    ULONG Flags;
    LPWSTR UserName;
    LPWSTR Domain;
    LPWSTR WindowStation;
    DWORD hToken;   // Originally HANDLE
    DWORD hDesktop; // Originally HDESK
    DWORD dwSessionId;
} WINLOGON_INFO, *PWINLOGON_INFO;

typedef struct _SENS_NOTIFY_WINLOGON
{
    DWORD eType;
    WINLOGON_INFO Info;
} SENS_NOTIFY_WINLOGON, *PSENS_NOTIFY_WINLOGON;

typedef struct _SENS_NOTIFY_RAS
{
    DWORD eType;
    SENS_HRASCONN hConnection;
} SENS_NOTIFY_RAS, *PSENS_NOTIFY_RAS;

typedef struct _SENS_NOTIFY_NETCON
{
    DWORD eType;
    INetConnection *pINetConnection;
} SENS_NOTIFY_NETCON, *PSENS_NOTIFY_NETCON;

typedef struct _SENS_NOTIFY_NETCON_P // _P stands for Private
{
    DWORD eType;
#ifdef MIDL_PASS
    [string]
#endif // MIDL_PASS
    LPWSTR Name;
    NETCON_STATUS Status;
    NETCON_MEDIATYPE Type;
} SENS_NOTIFY_NETCON_P, *PSENS_NOTIFY_NETCON_P;

//
// Function prototypes
//

#if !defined(__midl)

DWORD APIENTRY
SensNotifyWinlogonEvent(
    PSENS_NOTIFY_WINLOGON pEvent
    );

DWORD APIENTRY
SensNotifyRasEvent(
    PSENS_NOTIFY_RAS pEvent
    );

DWORD APIENTRY
SensNotifyNetconEvent(
    PSENS_NOTIFY_NETCON pEvent
    );

#endif // !defined(__midl)


#ifdef __cplusplus
}
#endif

#endif // __SENSAPIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\inc\sensapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sensapi.h

Abstract:

    Public header file for the SENS Connectivity APIs.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/12/1997         Start.

--*/


#ifndef __SENSAPI_H__
#define __SENSAPI_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


#define NETWORK_ALIVE_LAN   0x00000001
#define NETWORK_ALIVE_WAN   0x00000002
#define NETWORK_ALIVE_AOL   0x00000004


typedef struct tagQOCINFO
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwInSpeed;
    DWORD dwOutSpeed;
} QOCINFO, *LPQOCINFO;



#ifdef UNICODE
#define  IsDestinationReachable  IsDestinationReachableW
#else
#define  IsDestinationReachable  IsDestinationReachableA
#endif // UNICODE


#if !defined(__midl)

BOOL APIENTRY
IsDestinationReachableA(
    LPCSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    );

BOOL APIENTRY
IsDestinationReachableW(
    LPCWSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    );

BOOL APIENTRY
IsNetworkAlive(
    LPDWORD lpdwFlags
    );

#endif // !defined(__midl)


#ifdef __cplusplus
}
#endif

#endif // __SENSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\inc\mtxadmin_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Nov 14 05:07:21 1997
 */
/* Compiler settings for mtxadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICatalog = {0x6eb22870,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};

// These IID's are included by linking to uuid.lib
//const IID IID_ICatalogObject = {0x6eb22871,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};

// These IID's are included by linking to uuid.lib
//const IID IID_ICatalogCollection = {0x6eb22872,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};

const IID IID_IComponentUtil = {0x6eb22873,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IPackageUtil = {0x6eb22874,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRemoteComponentUtil = {0x6eb22875,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRoleAssociationUtil = {0x6eb22876,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID LIBID_MTSAdmin = {0x6eb22880,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_Catalog = {0x6eb22881,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogObject = {0x6eb22882,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogCollection = {0x6eb22883,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_ComponentUtil = {0x6eb22884,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_PackageUtil = {0x6eb22885,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RemoteComponentUtil = {0x6eb22886,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RoleAssociationUtil = {0x6eb22887,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\inc\mtsadmin_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */
// Copyright (c) Microsoft Corporation. All rights reserved.
/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Thu Mar 11 18:35:18 1999
 */
/* Compiler settings for mtsadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICatalog = {0x6eb22870,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IComponentUtil = {0x6eb22873,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IPackageUtil = {0x6eb22874,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRemoteComponentUtil = {0x6eb22875,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRoleAssociationUtil = {0x6eb22876,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID LIBID_MTSAdmin = {0x6eb22880,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_Catalog = {0x6eb22881,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogObject = {0x6eb22882,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogCollection = {0x6eb22883,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_ComponentUtil = {0x6eb22884,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_PackageUtil = {0x6eb22885,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RemoteComponentUtil = {0x6eb22886,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RoleAssociationUtil = {0x6eb22887,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\uuid\cguid_i.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       cguid_i.c
//
//  Contents:   Defines guids for interfaces not supported by MIDL.
//              This file is named so the this file will be include into UUID.LIB
//              As these interfaces are converted to IDL, the corresponding DEFINE_OLEGUID
//              macro calls for  the interfaces should be removed.
//
//  History:    8-06-93   terryru   Created
//
//----------------------------------------------------------------------------




#define INITGUID

#include <guiddef.h>


DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

/* Marshaler Component Category ID (same as IID_IMarshal) */
/* If you change this IID, change the string in IsMarshalerCLSID */

DEFINE_OLEGUID(CATID_MARSHALER,                 0x00000003, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,                 0x00000004, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,                    0x00000005, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,                0x00000006, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,                   0x00000007, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,               0x00000008, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,                  0x00000009, 0, 0);


/* moniker related interfaces */

DEFINE_OLEGUID(IID_IInternalMoniker,            0x00000011, 0, 0);

DEFINE_OLEGUID(IID_IDfReserved1,                0x00000013, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,                0x00000014, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,                0x00000015, 0, 0);


/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,                0x00000017, 0, 0);

DEFINE_OLEGUID(IID_IStub,                       0x00000026, 0, 0);
DEFINE_OLEGUID(IID_IProxy,                      0x00000027, 0, 0);

/* NOTE: LSB 0x2E through 0xff are reserved for future use */


//--------------------------------------------------------------------------
//
//  master definition of all public GUIDs specific to OLE2
//
//--------------------------------------------------------------------------


DEFINE_OLEGUID(IID_IEnumGeneric,                0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,                 0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,               0x00000108, 0, 0);





DEFINE_OLEGUID(IID_IOleManager,                 0x0000011f, 0, 0);
DEFINE_OLEGUID(IID_IOlePresObj,                 0x00000120, 0, 0);


DEFINE_OLEGUID(IID_IDebug,                      0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,                0x00000124, 0, 0);


// clsids for proxy/stub objects
DEFINE_OLEGUID(CLSID_PSGenObject,               0x0000030c, 0, 0);
DEFINE_OLEGUID(CLSID_PSClientSite,              0x0000030d, 0, 0);
DEFINE_OLEGUID(CLSID_PSClassObject,             0x0000030e, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceActive,           0x0000030f, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceFrame,            0x00000310, 0, 0);
DEFINE_OLEGUID(CLSID_PSDragDrop,                0x00000311, 0, 0);
DEFINE_OLEGUID(CLSID_PSBindCtx,                 0x00000312, 0, 0);
DEFINE_OLEGUID(CLSID_PSEnumerators,             0x00000313, 0, 0);

DEFINE_OLEGUID(CLSID_StaticMetafile,            0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_StaticDib,                 0x00000316, 0, 0);


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_Picture_Metafile,          0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_EnhMetafile,       0x00000319, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_Dib,               0x00000316, 0, 0);
DEFINE_OLEGUID(CLSID_DCOMAccessControl,         0x0000031D, 0, 0);
DEFINE_OLEGUID(CLSID_StdGlobalInterfaceTable,   0x00000323, 0, 0);


// Class ids for various implementations of ISynchronize
DEFINE_OLEGUID(CLSID_ManualResetEvent,             0x0000032c, 0, 0);
DEFINE_OLEGUID(CLSID_StdEvent,                     0x0000032b, 0, 0);
DEFINE_OLEGUID(CLSID_SynchronizeContainer,         0x0000032d, 0, 0);


// OBJREF Moniker                                  0x00000327
// Class id for string binding wrapper object
DEFINE_OLEGUID(CLSID_ComBinding,                0x00000328, 0, 0);
// Class id for obtaining an implementation of IAsyncManager
DEFINE_OLEGUID(CLSID_StdAsyncActManager,           0x00000329L, 0, 0);

/* clsid for free threaded marshaler */
DEFINE_OLEGUID(CLSID_InProcFreeMarshaler,       0x00000033a, 0, 0);
DEFINE_OLEGUID(CLSID_RemoteUnknownPSFactory,       0x00000340, 0, 0);


//
//  Define Richedit GUIDs
//
DEFINE_OLEGUID(IID_IRichEditOle,                0x00020D00, 0, 0);
DEFINE_OLEGUID(IID_IRichEditOleCallback,        0x00020D03, 0, 0);

//
//  Define Class Repository CLSIDs
//

DEFINE_OLEGUID(CLSID_AllClasses,                0x00000330, 0, 0);
DEFINE_OLEGUID(CLSID_LocalMachineClasses,       0x00000331, 0, 0);
DEFINE_OLEGUID(CLSID_CurrentUserClasses,        0x00000332, 0, 0);


// for address control object
DEFINE_OLEGUID(CLSID_AddrControl,                 0x00000348, 0, 0);

//
// define ole controls clsids
//
//

DEFINE_GUID(IID_IPropertyFrame,
        0xB196B28A,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);

//  Class IDs for property sheet implementations
//

DEFINE_GUID(CLSID_CFontPropPage,
        0x0be35200,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);
DEFINE_GUID(CLSID_CColorPropPage,
        0x0be35201,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);
DEFINE_GUID(CLSID_CPicturePropPage,
        0x0be35202,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);

//
// class IDs for msprop32's property pages.
//

#include <msstkppg.h>

//
//  Class IDs for persistent property set formats
//

DEFINE_GUID(CLSID_PersistPropset,
        0xfb8f0821,0x0164,0x101b,0x84,0xed,0x08,0x00,0x2b,0x2e,0xc7,0x13);
DEFINE_GUID(CLSID_ConvertVBX,
        0xfb8f0822,0x0164,0x101b,0x84,0xed,0x08,0x00,0x2b,0x2e,0xc7,0x13);

//
//  Class ID for standard implementations of IFont and IPicture

DEFINE_GUID(CLSID_StdFont,
        0x0be35203,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);
DEFINE_GUID(CLSID_StdPicture,
        0x0be35204,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);


//
//  GUIDs for standard types
//

DEFINE_GUID(GUID_HIMETRIC,
        0x66504300,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_COLOR,
        0x66504301,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XPOSPIXEL,
        0x66504302,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YPOSPIXEL,
        0x66504303,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XSIZEPIXEL,
        0x66504304,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YSIZEPIXEL,
        0x66504305,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XPOS,
        0x66504306,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YPOS,
        0x66504307,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XSIZE,
        0x66504308,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YSIZE,
        0x66504309,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_TRISTATE,
        0x6650430A,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_OPTIONVALUEEXCLUSIVE,
        0x6650430B,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_CHECKVALUEEXCLUSIVE,
        0x6650430C,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTNAME,
        0x6650430D,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTSIZE,
        0x6650430E,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTBOLD,
        0x6650430F,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTITALIC,
        0x66504310,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTUNDERSCORE,
        0x66504311,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTSTRIKETHROUGH,
        0x66504312,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_HANDLE,
        0x66504313,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);

//
//  GUIDs for OLE Automation
//
DEFINE_OLEGUID(IID_StdOle,  0x00020430L, 0, 0);

// Ole Control Data Binding guids

DEFINE_GUID(IID_ICursor,
    0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorMove,
    0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorScroll,
    0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorUpdateARow,
    0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_INotifyDBEvents,
    0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorFind,
    0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_IEntryID,
    0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(_GUID_NAMEONLY,
    0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(_DBBMKGUID,
    0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(_DBCIDGUID,
    0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

// OLE Data binding

DEFINE_GUID(IID_IBoundObject,
    0x9BFBBC00, 0xEFF1, 0x101A, 0x84, 0xED, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07);

DEFINE_GUID(IID_IBoundObjectSite,
    0x9BFBBC01, 0xEFF1, 0x101A, 0x84, 0xED, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07);

// Global Comcat clsid (with Class Store)
DEFINE_OLEGUID(CLSID_GblComponentCategoriesMgr, 0x0002E006, 0, 0);


//
// A GUID for the thumbnail generator
//
DEFINE_GUID(CLSID_ThumbnailFCNHandler,
    0xcefc65d8, 0x66d8, 0x11d1, 0x8d, 0x8c, 0x00, 0x00, 0xf8, 0x04, 0xb0, 0x57);

DEFINE_GUID(CLSID_ThumbnailUpdater,
    0xa3c63918, 0x889d, 0x11d1, 0x83, 0xe9, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0xd4);

#include <devguid.h>

#define _WINIOCTL_
#include <winioctl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\uuid\qosguid.c ===
#define INITGUID
#include <guiddef.h>

#include <tcguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\uuid\trkadm_i.c ===
#define INITGUID
#include <guiddef.h>

DEFINE_GUID(IID_ITrkForceOwnership, 0xA2531F44,0xC67D,0x11D0,0x8C,0xB1,0x00,0xC0,0x4F,0xD9,0x0F,0x85);
DEFINE_GUID(IID_ITrkRestoreNotify,  0xD0056F6B,0xE2A0,0x11D0,0xB1,0xC2,0x00,0xC0,0x4F,0xB9,0x38,0x6D);
DEFINE_GUID(IID_ITrkRestoreParser,  0x755939E3,0xE381,0x11D0,0xB1,0xC5,0x00,0xC0,0x4F,0xB9,0x38,0x6D);
DEFINE_GUID(LIBID_ITRKADMNLib,      0xA2531F35,0xC67D,0x11D0,0x8C,0xB1,0x00,0xC0,0x4F,0xD9,0x0F,0x85);
DEFINE_GUID(CLSID_TrkForceOwnership,0xA2531F45,0xC67D,0x11D0,0x8C,0xB1,0x00,0xC0,0x4F,0xD9,0x0F,0x85);
DEFINE_GUID(CLSID_TrkRestoreNotify, 0xD0056F6C,0xE2A0,0x11D0,0xB1,0xC2,0x00,0xC0,0x4F,0xB9,0x38,0x6D);
DEFINE_GUID(CLSID_TrkRestoreParser, 0x755939E4,0xE381,0x11D0,0xB1,0xC5,0x00,0xC0,0x4F,0xB9,0x38,0x6D);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\uuid\wdmguids.c ===
#define INITGUID
#include <guiddef.h>

#include <wdmguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\uuid\makefile.inc ===
$(O)\callobj_i.c : ..\idlole\idl\$(O)\callobj_i.c
    copy $** $@

$(O)\ctxtcall_i.c : ..\idlole\idl\$(O)\ctxtcall_i.c
    copy $** $@

$(O)\iaccess_i.c : ..\idlole\idl\$(O)\iaccess_i.c
    copy $** $@

$(O)\immact_i.c : ..\idlole\idl\$(O)\immact_i.c
    copy $** $@

$(O)\oaidl_i.c : ..\idlole\idl\$(O)\oaidl_i.c
    copy $** $@

$(O)\objidl_i.c : ..\idlole\idl\$(O)\objidl_i.c
    copy $** $@

$(O)\ocidl_i.c : ..\idlole\idl\$(O)\ocidl_i.c
    copy $** $@

$(O)\oleext_i.c : ..\idlole\oleext\$(O)\oleext_i.c
    copy $** $@

$(O)\oleidl_i.c : ..\idlole\idl\$(O)\oleidl_i.c
    copy $** $@

$(O)\pbagex_i.c : ..\idlole\idl\$(O)\pbagex_i.c
    copy $** $@

$(O)\propidl_i.c : ..\idlole\idl\$(O)\propidl_i.c
    copy $** $@

$(O)\storext_i.c : ..\idlole\idl\$(O)\storext_i.c
    copy $** $@

$(O)\sysmgmt_i.c : ..\idlole\sysmgmt\$(O)\sysmgmt_i.c
    copy $** $@

$(O)\transact_i.c : ..\idlole\complus\$(O)\transact_i.c
    copy $** $@

$(O)\unknwn_i.c : ..\idlole\idl\$(O)\unknwn_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\uuid\trkcom_i.c ===
#define INITGUID
#include <guiddef.h>
DEFINE_GUID(CLSID_TrackFile, 0x8790c947,0xa30b,0x11d0,0x8c,0xab,0x00,0xc0,0x4f,0xd9,0x0f,0x85);
DEFINE_GUID(IID_ITrackFile,  0x8790c948,0xa30b,0x11d0,0x8c,0xab,0x00,0xc0,0x4f,0xd9,0x0f,0x85);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\uuid\sifmt_i.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       sifmt_i.c
//
//  Contents:   Defines Format IDs for the SummaryInformation and DocumentSummaryInformation
//              property sets.
//              This file is named so the this file will be include into UUID.LIB
//
//  History:    1/25/96   MikeHill   Created
//
//----------------------------------------------------------------------------




#define INITGUID

#include <guiddef.h>


// The FMTID of the "SummaryInformation" property set.

DEFINE_GUID( FMTID_SummaryInformation,
             0xf29f85e0, 0x4ff9, 0x1068,
             0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 );

// The FMTID of the first Section of the "DocumentSummaryInformation" property set.

DEFINE_GUID( FMTID_DocSummaryInformation,
             0xd5cdd502, 0x2e9c, 0x101b,
             0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae );

// The FMTID of the section Section of the "DocumentSummaryInformation" property set.

DEFINE_GUID( FMTID_UserDefinedProperties,
             0xd5cdd505, 0x2e9c, 0x101b,
             0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae );


DEFINE_GUID( FMTID_PropertyBag,
             0x20001801, 0x5DE6, 0x11D1,
             0x8E, 0x38, 0x00, 0xC0, 0x4F, 0xB9, 0x38, 0x6D );

// The FMTID of the "DiscardableInformation" property set

DEFINE_GUID( FMTID_DiscardableInformation,
             0xd725ebb0, 0xc9b8, 0x11d1,
             0x89, 0xbc, 0x00, 0x00, 0xf8, 0x04, 0xb0, 0x57 );


// ImageSummaryInfo propset
DEFINE_GUID( FMTID_ImageSummaryInformation,
             0x6444048f, 0x4c8b, 0x11d1,
             0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3 ) ;

// AudioSummaryInfo propset
DEFINE_GUID( FMTID_AudioSummaryInformation,
             0x64440490, 0x4c8b, 0x11d1,
             0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3 ) ;

// VideoSummaryInfo propset
DEFINE_GUID( FMTID_VideoSummaryInformation,
	     0x64440491, 0x4c8b, 0x11d1,
             0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3 ) ;

// MediaFileSummaryInfo propset - common properties for multimedia files
DEFINE_GUID( FMTID_MediaFileSummaryInformation,
             0x64440492, 0x4c8b, 0x11d1,
             0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3 ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\uuid\vcguids.c ===
#define INITGUID
#include <guiddef.h>


typedef enum tagDBCOLKIND
{
    DBCOLKIND_GUID_NAME = 0,
    DBCOLKIND_GUID_NUMBER = 1,
    DBCOLKIND_NAME = 2
} DBCOLKIND;

typedef struct tagDBCOLUMNID
{
    GUID guid;
    DBCOLKIND dwKind;
    union
    {
        long lNumber;
        wchar_t* lpdbsz;
    };
} DBCOLUMNID;

#define DBCIDGUID {0xfe284700L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#define DBBMKGUID {0xf6304bb0L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}

#define DECLARE_COLUMNID    EXTERN_C const DBCOLUMNID DECLSPEC_SELECTANY

DECLARE_COLUMNID COLUMNID_INVALID         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, -1};
DECLARE_COLUMNID COLUMN_AUTOINCREMENT     = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 0};
DECLARE_COLUMNID COLUMN_BASECOLUMNNAME    = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 1};
DECLARE_COLUMNID COLUMN_BASENAME          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 2};
DECLARE_COLUMNID COLUMN_BINARYCOMPARABLE  = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 3};
DECLARE_COLUMNID COLUMN_BINDTYPE          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 4};
DECLARE_COLUMNID COLUMN_CASESENSITIVE     = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 5};
DECLARE_COLUMNID COLUMN_COLLATINGORDER    = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 6};
DECLARE_COLUMNID COLUMN_COLUMNID          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 7};
DECLARE_COLUMNID COLUMN_CURSORCOLUMN      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 8};
DECLARE_COLUMNID COLUMN_DATACOLUMN        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 9};
DECLARE_COLUMNID COLUMN_DEFAULTVALUE      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 10};
DECLARE_COLUMNID COLUMN_ENTRYIDMAXLENGTH  = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 11};
DECLARE_COLUMNID COLUMN_FIXED             = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 12};
DECLARE_COLUMNID COLUMN_HASDEFAULT        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 13};
DECLARE_COLUMNID COLUMN_MAXLENGTH         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 14};
DECLARE_COLUMNID COLUMN_MULTIVALUED       = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 15};
DECLARE_COLUMNID COLUMN_NAME              = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 16};
DECLARE_COLUMNID COLUMN_NULLABLE          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 17};
DECLARE_COLUMNID COLUMN_PHYSICALSORT      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 18};
DECLARE_COLUMNID COLUMN_NUMBER            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 19};
DECLARE_COLUMNID COLUMN_ROWENTRYID        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 20};
DECLARE_COLUMNID COLUMN_SCALE             = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 21};
DECLARE_COLUMNID COLUMN_SEARCHABLE        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 22};
DECLARE_COLUMNID COLUMN_TYPE              = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 23};
DECLARE_COLUMNID COLUMN_UNIQUE            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 24};
DECLARE_COLUMNID COLUMN_UPDATABLE         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 25};
DECLARE_COLUMNID COLUMN_VERSION           = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 26};
DECLARE_COLUMNID COLUMN_STATUS            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 27};

DECLARE_COLUMNID COLUMN_BMKTEMPORARY      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 0};
DECLARE_COLUMNID COLUMN_BMKTEMPORARYREL   = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 1};
DECLARE_COLUMNID COLUMN_BMKCURSOR         = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 2};
DECLARE_COLUMNID COLUMN_BMKCURSORREL      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 3};
DECLARE_COLUMNID COLUMN_BMKSESSION        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 4};
DECLARE_COLUMNID COLUMN_BMKSESSIONREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 5};
DECLARE_COLUMNID COLUMN_BMKPERSIST        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 6};
DECLARE_COLUMNID COLUMN_BMKPERSISTREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 7};


#define DECLARE_BYTE    EXTERN_C const unsigned char DECLSPEC_SELECTANY

DECLARE_BYTE DBBMK_INVALID   = 0x0;
DECLARE_BYTE DBBMK_CURRENT   = 0x1;
DECLARE_BYTE DBBMK_BEGINNING = 0x2;
DECLARE_BYTE DBBMK_END       = 0x3;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\published\uuid\xenroll_i.c ===
#define INITGUID
#include <guiddef.h>
DEFINE_GUID(IID_ICEnroll,    0x43F8F288,0x7A20,0x11D0,0x8F,0x06,0x00,0xC0,0x4F,0xC2,0x95,0xE1);
DEFINE_GUID(IID_ICEnroll2,   0x704ca730,0xc90b,0x11d1,0x9b,0xec,0x00,0xc0,0x4f,0xc2,0x95,0xe1);
DEFINE_GUID(IID_ICEnroll3,   0xc28c2d95,0xb7de,0x11d2,0xa4,0x21,0x00,0xc0,0x4f,0x79,0xfe,0x8e);
DEFINE_GUID(IID_ICEnroll4,   0xc1f1188a,0x2eb5,0x4a80,0x84,0x1b,0x7e,0x72,0x9a,0x35,0x6d,0x90);
DEFINE_GUID(IID_IEnroll,     0xacaa7838,0x4585,0x11d1,0xab,0x57,0x00,0xc0,0x4f,0xc2,0x95,0xe1);
DEFINE_GUID(IID_IEnroll2,    0xc080e199,0xb7df,0x11d2,0xa4,0x21,0x00,0xc0,0x4f,0x79,0xfe,0x8e);
DEFINE_GUID(IID_IEnroll4,    0xf8053fe5,0x78f4,0x448f,0xa0,0xdb,0x41,0xd6,0x1b,0x73,0x44,0x6b);
DEFINE_GUID(LIBID_XENROLLLib,0x43F8F27B,0x7A20,0x11D0,0x8F,0x06,0x00,0xC0,0x4F,0xC2,0x95,0xE1);
DEFINE_GUID(CLSID_CEnroll,   0x43F8F289,0x7A20,0x11D0,0x8F,0x06,0x00,0xC0,0x4F,0xC2,0x95,0xE1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\autohand.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    autohand.cxx

Abstract:

    This module implements the autohandle functions call by the compiler
    generated stubs.

Author:

    Steven Zeck (stevez) 03/10/92
    Kamen Moutafov (KamenM) Feb 2000 - add support for multiple transfer syntaxes

--*/

#include <rpc.h>
#include <rpcdcep.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <rpcnsi.h>
#include <rpcnsip.h>

#ifdef __cplusplus
}
#endif

typedef RPC_STATUS
(RPC_ENTRY *RPC_BIND)
        (
        IN PRPC_MESSAGE Message
        );

RPC_STATUS
RpcpNsGetBuffer(
    IN PRPC_MESSAGE Message,
    RPC_BIND BindFn
    );

// Interface can be only RPC_CLIENT_INTERFACE
inline BOOL DoesInterfaceSupportMultipleTransferSyntaxes(void *Interface)
{
    // the client and server interface have the same layout - we can just
    // use one of them
    RPC_CLIENT_INTERFACE *ClientInterface = (RPC_CLIENT_INTERFACE *)Interface;

    if (ClientInterface->Length == NT351_INTERFACE_SIZE)
        return FALSE;

    return (ClientInterface->Flags & RPCFLG_HAS_MULTI_SYNTAXES);
}

RPC_STATUS RPC_ENTRY
I_RpcNsGetBuffer(
    IN PRPC_MESSAGE Message
    )

/*++

Routine Description:

    Auto bind to a given interface.

Arguments:

    Message - describes the interface that we want to auto bind to.

Returns:

    RPC_S_OK, RPC_S_CALL_FAILED_DNE, I_RpcGetBuffer()

--*/

{
    if (!DoesInterfaceSupportMultipleTransferSyntaxes(Message->RpcInterfaceInformation))
        Message->ImportContext = 0;

    return RpcpNsGetBuffer(Message, I_RpcGetBuffer);
}

extern "C"
{

RPC_STATUS RPC_ENTRY
I_RpcNsNegotiateTransferSyntax(
    IN PRPC_MESSAGE Message
    );

};   // extern "C"

RPC_STATUS RPC_ENTRY
I_RpcNsNegotiateTransferSyntax(
    IN PRPC_MESSAGE Message
    )

/*++

Routine Description:

    Auto bind to a given interface.

Arguments:

    Message - describes the interface that we want to auto bind to.

Returns:

    RPC_S_OK, RPC_S_CALL_FAILED_DNE, I_RpcGetBuffer()

--*/

{
    Message->ImportContext = 0;
    return RpcpNsGetBuffer(Message, I_RpcNegotiateTransferSyntax);
}


RPC_STATUS
RpcpNsGetBuffer(
    IN PRPC_MESSAGE Message,
    RPC_BIND BindFn
    )

/*++

Routine Description:

    Auto bind to a given interface.

Arguments:

    Message - describes the interface that we want to auto bind to.

Returns:

    RPC_S_OK or error

--*/

{
    RPC_STATUS status;
    PRPC_IMPORT_CONTEXT_P Import;
    int fSetAge = 0;

    // If there already is a handle, use it directly.

    if (Message->Handle)
        return(BindFn(Message));

    Message->ImportContext = 0;

    for (int cTry = 0; cTry < 2; cTry++)
        {
        status = RpcNsBindingImportBegin(RPC_C_NS_SYNTAX_DEFAULT, 0,
            Message->RpcInterfaceInformation, 0, &Message->ImportContext);

        Import = (PRPC_IMPORT_CONTEXT_P) Message->ImportContext;

        if (status)
            break;

        // This will cause some Zecky Magic
        // Also note that naively one might move this ExpAge to
        // after the first lookup failed time- that is a bobo
        if (fSetAge)
            status = RpcNsMgmtHandleSetExpAge (Message->ImportContext, 0);

        // If we found no bindings last time, tell the locator
        // to look on the net.


        // For each handle returned by import, try using it with I_RpcGetBuffer
        // function until success or no more import handles.

        while(RpcNsBindingImportNext(Import, &Import->ProposedHandle)
                                                               == RPC_S_OK)
            {
            Message->Handle = Import->ProposedHandle;

            if (BindFn(Message) == RPC_S_OK)
                return(RPC_S_OK);

            RpcBindingFree(&Import->ProposedHandle);
            }

        fSetAge = 1;


        RpcNsBindingImportDone(&Message->ImportContext);
        }


    if (status == RPC_S_NAME_SERVICE_UNAVAILABLE ||
        status == RPC_S_OUT_OF_MEMORY ||
        status == RPC_S_OUT_OF_RESOURCES)

        return(status);

    return(RPC_S_CALL_FAILED_DNE);
}



RPC_STATUS RPC_ENTRY
I_RpcNsSendReceive(
    IN PRPC_MESSAGE Message,
    OUT RPC_BINDING_HANDLE * Handle
    )

/*++

Routine Description:

    Make a call on a RPC server.  If the call fails continue looking for
    servers to bind to.  This is only needed for protocols
    which don't allocate the connection at I_RpcGetBuffer time.


Arguments:

    Message - describes the interface that we want to Call.  The
        ImportContext field contains the active lookup handle, if any.

    Handle - returns the binding handle used on the successfull call.

Returns:


    RPC_S_CALL_FAILED_DNE, I_RpcSendReceive()

--*/

{
    RPC_STATUS status;
    PRPC_IMPORT_CONTEXT_P Import;

    Import = (PRPC_IMPORT_CONTEXT_P) Message->ImportContext;

    while ((status = I_RpcSendReceive(Message)) != RPC_S_OK && Import)
       {
       RpcBindingFree(&Import->ProposedHandle);

       // The call failed, try the next binding handle

       while(RpcNsBindingImportNext(Import, &Import->ProposedHandle)
           == RPC_S_OK)
           {
           Message->Handle = Import->ProposedHandle;

           I_RpcReBindBuffer(Message);
           continue;
           }

       I_RpcFreeBuffer(Message);

       status = RPC_S_CALL_FAILED_DNE;
       }

    if (Import)
       {
       *Handle = Import->ProposedHandle;
       RpcNsBindingImportDone(&Message->ImportContext);
       }

    if (status)
        *Handle = 0;

    return(status);
}



void RPC_ENTRY
I_RpcNsRaiseException(
    IN PRPC_MESSAGE Message,
    IN RPC_STATUS Status
    )

/*++

Routine Description:

    Raise an Exception for an autobind interface.  We simply cleanup any
    open import context and raise the exception.

Arguments:

    Message - continas the import context, if any.

--*/

{
    RpcNsBindingImportDone(&Message->ImportContext);

    RpcRaiseException(Status);
}


// BUG BUG implement this is the runtime.

RPC_STATUS RPC_ENTRY
I_RpcReBindBuffer(
    IN PRPC_MESSAGE Message
    )
{
    (void __RPC_FAR *) Message;

    RpcRaiseException(RPC_S_INTERNAL_ERROR);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\mem.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mem.c
//
//--------------------------------------------------------------------------

/*++

Module Name:

    mem.c

Abstract:

    Implements midl_user_allocate and midl_user_free.

Author:

    Jeff Roberts (jroberts)  15-May-1996

Revision History:

     15-May-1996     jroberts

        Created this module.

--*/

#include <rpc.h>


void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    unsigned cb
    )
/*++

Routine Description:

    Call the C memory allocation for MIDL.

--*/
{
    return I_RpcAllocate(cb);
}

void __RPC_API
MIDL_user_free(
    void __RPC_FAR * p
    )
{
    I_RpcFree(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\cbind.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    cbind.cxx

Abstract:

    This is the client side NSI service support layer.  These functions
    provide for binding to the locator or other name server.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#include <nsi.h>

#ifndef NTENV

#include <netcons.h>
#include <neterr.h>
#include <server.h>
#include <access.h>
#include <regapi.h>
#include <mailslot.h>
#include <wksta.h>

#ifndef USHORT
#define USHORT unsigned short
#endif

#else

#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <stdlib.h>
#include "startsvc.h"
#endif

#include <string.h>

#ifndef NTENV
#include "locquery.h"
#endif

extern "C"
{
unsigned long RPC_ENTRY
I_GetDefaultEntrySyntax(
    );
}

void RpcNsLmDiscard(void);

#ifndef NTENV
unsigned short BroadcastAQuery(unsigned long Query,
                               char __RPC_FAR * Buffer,
                               unsigned short Count);

#define MAXLOCATORSTOTRY 8
#endif

#ifdef NTENV
#define LOCALLOCATOR "\\\\."
#endif

#if defined(DOS) && !defined(WIN)

extern int _NsAllocatorInitialized;
extern __RPC_API NsAllocatorSetup();

#define INIT_DOS_ALLOCATOR_IF_NECESSARY \
    { if (!_NsAllocatorInitialized) NsAllocatorSetup(); }

#else  // DOS only
#define INIT_DOS_ALLOCATOR_IF_NECESSARY
#endif // DOS only

unsigned char * NsiStringBinding;

enum {
    BindingReadRegistry = 0,
    BindingNotYetTried,
    BindingContinueRegistry,
    BindingFound,
#ifndef NTENV
    BindingBackupFirst,
    BindingBackup,
    BindToBackupViaBC,
    BindToAnyViaBC
#endif
};

#define NilOffset (-1)

typedef struct
{
    unsigned char *ProtoSeq;
    unsigned char *NetworkAddress;
    unsigned char *Endpoint;

    HKEY RegHandle;
    unsigned int NumberServers;
    int AddressOffset;
    void *Buffer;
    char *ServerList;
    int State;
    int NextState;

} RPC_LOCATOR_BIND_CONTEXT, *PRPC_LOCATOR_BIND_CONTEXT;

DWORD GblBindId = 0;

#define MAX_SERVER_NAME 20

static RPC_LOCATOR_BIND_CONTEXT near BindSearch;

WIDE_STRING *DefaultName;
long DefaultSyntax = RPC_C_NS_SYNTAX_DCE;
int  fSyntaxDefaultsLoaded;

#ifndef NTENV

char __RPC_FAR * MailslotName = "\\\\*\\mailslot\\Resp_s";
char __RPC_FAR * LocalMS      = "\\mailslot\\Resp_c";

#define RESPONSETIME  4096L
#endif



unsigned char *
RegGetString(
    IN void * RegHandle,
    IN char * KeyName
    )

/*++

Routine Description:

    Get a string from the registery.

Arguments:

    KeyName - name of key to lookup.

Returns:

    pointer to the allocated string, or Nil if not found

--*/
{
    char Buffer[300];
    DWORD BufferLength = sizeof(Buffer);
    DWORD Type;

#ifdef NTENV

    if (RegQueryValueExA((HKEY)RegHandle, KeyName, 0, &Type,
            (unsigned char far*)Buffer, &BufferLength))
#else

    if (RegQueryValueA((HKEY)RegHandle, KeyName,
                (char far*)Buffer, &BufferLength))

#endif
        return(0);

    return(CopyString(Buffer));
}


static RPC_STATUS
Bind(RPC_BINDING_HANDLE *NsiClntBinding
    )

/*++

Routine Description:

    Bind to the locator server

Returns:

    RpcBindingFromStringBinding()

--*/
{
    RPC_STATUS status;
    unsigned char AddressBuffer[100];

    status = RpcStringFreeA(&NsiStringBinding);
    ASSERT(!status);

    // Get the next path componet from the NetworkAddress field.
    // Conponets are ; delimited fields.

    ASSERT(BindSearch.AddressOffset >= 0);

    for (int i = 0; i < sizeof(AddressBuffer); BindSearch.AddressOffset++, i++)
         {

         AddressBuffer[i] =
             BindSearch.NetworkAddress[BindSearch.AddressOffset];

         if (BindSearch.NetworkAddress[BindSearch.AddressOffset] == ';')
            {

            BindSearch.AddressOffset++;

            // If there are two ;; in a row, then pass through the ;
            // as a literal instead of a path seperator.

            if (BindSearch.NetworkAddress[BindSearch.AddressOffset] == ';')
                continue;

            AddressBuffer[i] = 0;
            break;
            }

         if (BindSearch.NetworkAddress[BindSearch.AddressOffset] == 0)
            {
            BindSearch.AddressOffset = NilOffset;
            break;
            }
        }
 

    status = RpcStringBindingComposeA(0, BindSearch.ProtoSeq,
         AddressBuffer, BindSearch.Endpoint,
         0, &NsiStringBinding);

    if (status)
        return(status);

    return (RpcBindingFromStringBindingA(NsiStringBinding, NsiClntBinding));
}


RPC_STATUS RPC_ENTRY
I_NsClientBindSearch(RPC_BINDING_HANDLE *NsiClntBinding, DWORD *BindId
                     )
/*++
    
Routine Description:
  
    The function binds to the locator, first it tries to bind to a
    local machine, then it attempts to bind to the domain controller.
                         
Arguments:
                           
  BindingSearchContext - context of search for the locator.

Returns:
                               
  RPC_S_OK, RPC_S_NO_BINDINGS, RPC_S_CANNOT_BIND, RPC_S_OUT_OF_RESOURCES
                                 
  rewritten to make it multi-thread capable. ushaji, Mar 98

--*/
                                   
{
    long status;
    
#ifndef NTENV
    unsigned short cbSI;
#define SERVER_INFO struct server_info_0
#define ServerName(p) ((struct server_info_0 *)p)->sv0_name
    unsigned short Count = 1;
    QUERYLOCATORREPLY Reply, __RPC_FAR * QueryReply;
#else
#define SERVER_INFO SERVER_INFO_100
#define ServerName(p) ((SERVER_INFO_100 *)p)->sv100_name
#endif
    
    INIT_DOS_ALLOCATOR_IF_NECESSARY;
    
    RequestGlobalMutex();
    
    switch (BindSearch.State)
    {
    case BindingReadRegistry:
        
        if (BindSearch.RegHandle)
        {
            status = RegCloseKey(BindSearch.RegHandle);
            ASSERT(!status);
            BindSearch.RegHandle = 0;
            
            delete BindSearch.NetworkAddress;
            delete BindSearch.ProtoSeq;
            delete BindSearch.Endpoint;
        }
        memset(&BindSearch, 0, sizeof(RPC_LOCATOR_BIND_CONTEXT));
        
        // We store the binding information on the name service in
        // the registry.  Get the information into BindingHandle.
        
#ifdef NTENV
        status = RegOpenKeyExA(RPC_REG_ROOT, REG_NSI, 0L, KEY_READ,
            &BindSearch.RegHandle);
#else
        status = RegOpenKeyA(RPC_REG_ROOT, REG_NSI, &BindSearch.RegHandle);
#endif
        
        
        if (status) {
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
        BindSearch.ProtoSeq = RegGetString((void *) BindSearch.RegHandle, "Protocol");
        BindSearch.NetworkAddress = RegGetString((void *) BindSearch.RegHandle,
            "NetworkAddress");
        BindSearch.Endpoint = RegGetString((void *) BindSearch.RegHandle, "Endpoint");
        
        GetDefaultEntrys((void *) BindSearch.RegHandle);
        
        if (!BindSearch.ProtoSeq || !BindSearch.Endpoint) {
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
#ifdef NTENV
        if (
            (BindSearch.NetworkAddress == NULL)
            || (BindSearch.NetworkAddress[0] == '\0')
            || (!strncmp((char *) BindSearch.NetworkAddress, LOCALLOCATOR,
            strlen(LOCALLOCATOR)))
            )
        {
            StartServiceIfNecessary();
        }
#endif
        
        status = Bind(NsiClntBinding);
        if (status == RPC_S_OK) {
            BindSearch.State = BindingNotYetTried;
            GblBindId++;
            BindSearch.NextState = BindingContinueRegistry;
        }
        
        break;
        
        
    case BindingNotYetTried:
    case BindingFound:
        status = RpcBindingFromStringBindingA(NsiStringBinding, NsiClntBinding);
        break;
        
    case BindingContinueRegistry:
        
        if (BindSearch.AddressOffset != NilOffset) {
            status = Bind(NsiClntBinding);
            
            if (status == RPC_S_OK) {
                BindSearch.State = BindingNotYetTried;
                GblBindId++;
            }
            break;
        }
        
#ifdef NTENV
        status = RPC_S_NAME_SERVICE_UNAVAILABLE;
        break;
#else
        
        if (BindSearch.NetworkAddress)
            delete BindSearch.NetworkAddress;
        
        // Don't search the Net if we aren't looking for the locator.
        if (strcmp((char *)BindSearch.Endpoint, "\\pipe\\locator"))
        {
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
        BindSearch.NetworkAddress = new unsigned char [MAX_SERVER_NAME];
        
        // second, try the domain controller
        
        
        if (NetGetDCName(0, 0, (char far *) BindSearch.NetworkAddress,
            MAX_SERVER_NAME))
        {
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
        BindSearch.AddressOffset = 0;
        
        status = Bind(NsiClntBinding);
        if (status == RPC_S_OK) 
        {
            GblBindId++;
            BindSearch.State = BindingNotYetTried;
            BindSearch.NextState = BindingBackupFirst;
            break;
        }
        break;
        
    case BindingBackupFirst:
        BindSearch.NumberServers = 0;
        
        // third, try all the member servers. First get the # of bytes
        // needed to hold all the names, then retrive them.
        
        NetServerEnum2(0, 0, 0, 0,
            (USHORT *) &BindSearch.NumberServers,
            (USHORT *) &BindSearch.NumberServers,
            SV_TYPE_DOMAIN_BAKCTRL, 0);
        
        cbSI = (BindSearch.NumberServers+2) * sizeof(SERVER_INFO);
        BindSearch.Buffer = new char [cbSI];
        BindSearch.ServerList = (char *) BindSearch.Buffer;
        
        if (!BindSearch.ServerList)
        {
            status = RPC_S_OUT_OF_RESOURCES;
            break;
        }
        
        if (NetServerEnum2(0, 0, (char far *)BindSearch.ServerList, cbSI,
            (USHORT *) &BindSearch.NumberServers,
            (USHORT *) &BindSearch.NumberServers,
            SV_TYPE_DOMAIN_BAKCTRL, 0))
            
        {
            delete BindSearch.Buffer;
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
    case BindingBackup:
        
        if (BindSearch.NumberServers == 0)
        {
            delete BindSearch.Buffer;
            BindSearch.Buffer = new char [sizeof(QUERYLOCATORREPLY) *
                MAXLOCATORSTOTRY];
            if (BindSearch.Buffer == NULL)
            {
                status = RPC_S_NAME_SERVICE_UNAVAILABLE;
                break;
            }
            
            BindSearch.ServerList = (char *)BindSearch.Buffer;
            BindSearch.NumberServers = BroadcastAQuery(
                QUERY_DC_LOCATOR,
                (char __RPC_FAR *)BindSearch.Buffer,
                MAXLOCATORSTOTRY
                );
            
        }
        else
        {
            BindSearch.NumberServers--;
            BindSearch.NetworkAddress[0] = '\\';
            BindSearch.NetworkAddress[1] = '\\';
            
            strcpy((char far *)BindSearch.NetworkAddress+2,
                ServerName(BindSearch.ServerList));
            
            BindSearch.ServerList += sizeof(SERVER_INFO);
            
            BindSearch.AddressOffset = 0;
            status = Bind(NsiClntBinding);
            if (status == RPC_S_OK) {
                GblBindId++;
                BindSearch.NextState = BindSearch.State;
                BindSearch.State = BindingNotYetTried;
            }
            
            break;
        }
        
        
    case BindToBackupViaBC:
        
        if (BindSearch.NumberServers == 0)
        {
            //The buffer is already setup, use it for next phase
            BindSearch.NumberServers =  BroadcastAQuery(
                QUERY_ANY_LOCATOR,
                (char __RPC_FAR *)BindSearch.Buffer,
                MAXLOCATORSTOTRY
                );
            BindSearch.State = BindToAnyViaBC;
            BindSearch.ServerList = (char *) BindSearch.Buffer;
        }
        else
        {
            BindSearch.NumberServers--;
            QueryReply = (QUERYLOCATORREPLY __RPC_FAR *)
                BindSearch.ServerList;
            UnicodeToAscii(QueryReply->SenderName);
            strcpy((char __RPC_FAR *) BindSearch.NetworkAddress,
                (char __RPC_FAR *)QueryReply->SenderName);
            BindSearch.ServerList = (char __RPC_FAR *)(QueryReply+1);
            BindSearch.AddressOffset = 0;
            status = Bind(NsiClntBinding);

            if (status == RPC_S_OK) {
                GblBindId++;
                BindSearch.NextState = BindSearch.State;
                BindSearch.State = BindingNotYetTried;
            }
            break;
        }
        
        //In the If case - we intentionally fall through to the
        //BindAny state.
        
    case BindToAnyViaBC:
        if (BindSearch.NumberServers == 0)
        {
            delete BindSearch.Buffer;
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
        }
        else
        {
            BindSearch.NumberServers--;
            QueryReply = (QUERYLOCATORREPLY __RPC_FAR *)
                BindSearch.ServerList;
            UnicodeToAscii(QueryReply->SenderName);
            strcpy((char __RPC_FAR *) BindSearch.NetworkAddress,
                (char __RPC_FAR *)QueryReply->SenderName);
            BindSearch.ServerList = (char __RPC_FAR *)(QueryReply+1);
            BindSearch.AddressOffset = 0;
            status = Bind(NsiClntBinding);

            if (status == RPC_S_OK) {
                GblBindId++;
                BindSearch.NextState = BindSearch.State;
                BindSearch.State = BindingNotYetTried;
            }
        }
        
        break;
#endif
        
    default:
        ASSERT(!"Bad Search State");
        BindSearch.State = BindingReadRegistry;
        status = RPC_S_NAME_SERVICE_UNAVAILABLE;
        break;
    }
    
    *BindId = GblBindId;
    ClearGlobalMutex();
    return(status);
}

RPC_STATUS RPC_ENTRY
I_NsBindingFoundBogus(RPC_BINDING_HANDLE *NsiClntBinding, DWORD BindId
        )
{
    long status;

    if (*NsiClntBinding)
    {
        status = RpcBindingFree(NsiClntBinding);
        ASSERT(!status);
    }
    *NsiClntBinding = NULL;

    RequestGlobalMutex();

    switch (BindSearch.State)
    {
    case BindingNotYetTried:
        if (BindId == GblBindId)
            BindSearch.State = BindSearch.NextState;
        break;
    case BindingFound:
        if (BindId == GblBindId)
            BindSearch.State = BindingReadRegistry;
        break;
    default:
        break;
    }

    ClearGlobalMutex();
    return(RPC_S_OK);
}

void RPC_ENTRY
I_NsClientBindDone(RPC_BINDING_HANDLE *NsiClntBinding, DWORD BindId
    )
/*++

Routine Description:

    The function cleans up after binding to the locator.

Returns:

--*/

{
    long status;
    RPC_STATUS RpcStatus;

    RequestGlobalMutex();

    switch (BindSearch.State)
      {
      case BindingFound:
        break;

      case BindingReadRegistry:
        break;

      case BindingNotYetTried:
          if (BindId == GblBindId) {
              BindSearch.State = BindingFound;

              if (BindSearch.RegHandle)
              {
                  status = RegCloseKey(BindSearch.RegHandle);
                  ASSERT(!status);
                  BindSearch.RegHandle = 0;
                  
                  delete BindSearch.NetworkAddress;
                  delete BindSearch.ProtoSeq;
                  delete BindSearch.Endpoint;
              }
          }
         break;

      case BindingContinueRegistry:
          if (BindId == GblBindId) {
             BindSearch.State = BindingReadRegistry;
             if (BindSearch.RegHandle)
             {
                  status = RegCloseKey(BindSearch.RegHandle);
                  ASSERT(!status);
                  BindSearch.RegHandle = 0;
                  
                  delete BindSearch.NetworkAddress;
                  delete BindSearch.ProtoSeq;
                  delete BindSearch.Endpoint;
             }
         }
         break;

#ifndef NTENV
      case BindToAnyViaBC:
      case BindToBackupViaBC:
      case BindingBackup:
        delete BindSearch.Buffer;

      case BindingBackupFirst:

         status = RegSetValue(BindSearch.RegHandle, "NetworkAddress",
            REG_SZ, (LPSTR) BindSearch.NetworkAddress,
            strlen((CONST_CHAR *)BindSearch.NetworkAddress) + 1);

         BindSearch.State = BindingFound;
         ASSERT(!status);
         break;
#endif

      default:
         ASSERT(!"Bad State - \n");
      }

#if defined(DOS) && !defined(WIN)

    // Unloaded the big fat lanman stuff now that we are done searching.

    RpcNsLmDiscard();

#endif

    RpcStatus = RpcBindingFree(NsiClntBinding);

    ClearGlobalMutex();
    
//    ASSERT(!RpcStatus);
}



unsigned long RPC_ENTRY
I_GetDefaultEntrySyntax(
    )
/*++

Routine Description:

    Called by the runtime DLL when it needs to know the default syntax.
    Currently this is used only by RpcBindingInqEntry().

Arguments:

    none

Return Value:

    the entry syntax

Exceptions:

    none

--*/
{
    return (unsigned long) DefaultSyntax;
}


#ifndef NTENV

unsigned short BroadcastAQuery(
               unsigned long Type,
               char __RPC_FAR * Buffer,
               unsigned short  Count
                 )
{

  unsigned short Err;
  unsigned MSHandle;
  unsigned short Returned, NextSize, NextPri, Avail;
  unsigned short RetCount = 0;
  QUERYLOCATOR   Query;
  unsigned long TimeRemaining = RESPONSETIME;
  wksta_info_10  __RPC_FAR * Wkio10;
  char __RPC_FAR * pBuf;
  unsigned short __RPC_FAR * pUZ;
  //First try and get the computer name

  Err = NetWkstaGetInfo(
                  0L,
                  10,
                  (char __RPC_FAR *) 0L,
                  0,
                  &Avail);

  ASSERT(Err == NERR_BufTooSmall);

  Wkio10 = (wksta_info_10 __RPC_FAR *) new char [Avail];

  if (Wkio10 == 0L)
    {
      return 0;
    }

  Err = NetWkstaGetInfo(
                  0L,
                  10,
                  (char __RPC_FAR *) Wkio10,
                  Avail,
                  &Avail
                  );

  //Format the Query!
  Query.MessageType = Type;
  Query.SenderOsType= OS_WIN31DOS;

  for (pBuf = &Wkio10->wki10_computername[0],pUZ = &Query.RequesterName[0];
       *pBuf !=0;
       pBuf++, pUZ++)
    *pUZ = *pBuf;

  *pUZ = 0;


  Err = DosMakeMailslot(
               LocalMS,
               sizeof(QUERYLOCATORREPLY),
               0,
               &MSHandle
               );

  if (Err != NERR_Success)
      {
        return 0;
      }

  Err = DosWriteMailslot(
                 MailslotName,
                 (char __RPC_FAR *) &Query,
                 sizeof(Query),
                 0,                //Priority
                 2,                //Class
                 0                 //Timeout
                 );

  if (Err != NERR_Success)
      goto CleanupAndExit;

  //Now sit in a loop and wait
  //for WAITRESPONSE secs

  while ((TimeRemaining) && (RetCount < Count))
  {

    Err = DosReadMailslot(
                   MSHandle,
                   Buffer,
                   &Returned,
                   &NextSize,
                   &NextPri,
                   TimeRemaining
                   );

    if (Err == NERR_Success)
       {
         ASSERT (Returned == sizeof(QUERYLOCATORREPLY));
         Buffer += sizeof(QUERYLOCATORREPLY);
         RetCount ++;
         TimeRemaining >> 1;
         continue;
       }

    break;

   } //end of while ReadMS


CleanupAndExit:
   DosDeleteMailslot(MSHandle);
   return (RetCount);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\nsi.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    nsi.h

Abstract:

    This module contains utility functions used by the NSI client wrappers.

Author:

    Steven Zeck (stevez) 03/27/92

--*/

#ifndef __NSI_H
#define __NSI_H

#ifdef __cplusplus
extern "C" {
#endif

#define RPC_REG_ROOT HKEY_LOCAL_MACHINE
#define REG_NSI "Software\\Microsoft\\Rpc\\NameService"

#if !defined(NSI_ASCII)
#define UNICODE
typedef unsigned short RT_CHAR;
#define CONST_CHAR const char
#else
typedef unsigned char RT_CHAR;
#define CONST_CHAR  char
#endif

#if defined(NTENV) 
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <rpc.h>
#include <rpcnsi.h>
#include <nsisvr.h>
#include <nsiclt.h>
#include <nsimgm.h>

#ifdef __cplusplus
} // extern "C"
#endif

#ifdef __cplusplus
#include <nsiutil.hxx>
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\nsimgmt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    nsimgmt.cxx

Abstract:

    This is the module implements the client side support for management
    APIs.

Author:

    Steven Zeck (stevez) 04/23/92

--*/

#include <nsi.h>
#include <string.h>

RPC_STATUS RPC_ENTRY
I_NsBindingFoundBogus(RPC_BINDING_HANDLE *BindingHandle, DWORD BindId);
RPC_STATUS RPC_ENTRY
I_NsClientBindSearch(RPC_BINDING_HANDLE *NsiClntBinding, DWORD *BindId);
void RPC_ENTRY
I_NsClientBindDone(RPC_BINDING_HANDLE *NsiClntBinding, DWORD BindId);

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteW(
    IN unsigned long GroupNameSyntax,
    IN unsigned short __RPC_FAR * GroupName
    )
/*++

Routine Description:

    Remove a group entry and all its member items.

Arguments:

    GroupNameSyntax - This value describes the type/format of the GroupName.

    GroupName -  Name that will be deleted.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_group_delete()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! GroupNameSyntax)
        GroupNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_group_delete(NsiClntBinding, GroupNameSyntax, GroupName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddW(
    IN unsigned long GroupNameSyntax,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName
    )
/*++

Routine Description:

    Add a new member to a group entry.  Create the group entry on demand.

Arguments:

    GroupNameSyntax - This value describes the type/format of the GroupName.

    GroupName -  Name of the group that the member will be added to.

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  Name of member in the group that will be added.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_group_mbr_add()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! GroupNameSyntax)
        GroupNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_group_mbr_add(NsiClntBinding, GroupNameSyntax, GroupName,
                              MemberNameSyntax, MemberName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);
    
    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveW(
    IN unsigned long GroupNameSyntax,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName
    )
/*++

Routine Description:


Arguments:

    GroupNameSyntax - This value describes the type/format of the GroupName.

    GroupName -  Name of the group that the member will be deleted from.

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  Name of member in the group that will be deleted

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_group_mbr_remove()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! GroupNameSyntax)
        GroupNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {

        RpcTryExcept
        {
            nsi_group_mbr_remove(NsiClntBinding, GroupNameSyntax, GroupName,
                MemberNameSyntax, MemberName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);

        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return status;
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginW(
    IN unsigned long GroupNameSyntax,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Begin a inquiry to enumerate all the members in a group entry.

Arguments:

    GroupNameSyntax - This value describes the type/format of the GroupName.

    GroupName -  Name of the group that the member will be deleted from.

    MemberNameSyntax - This controls what format the name is returned in.

    InquiryContext - context handle for RpcNsGroupMbrInqNextW

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_group_mbr_inq_begin()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    *InquiryContext = 0;

    if (! GroupNameSyntax)
        GroupNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_group_mbr_inq_begin(NsiClntBinding, GroupNameSyntax, GroupName,
                MemberNameSyntax, InquiryContext, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);
        
    return status;
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextW(
    OUT RPC_NS_HANDLE InquiryContext,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName
    )
/*++

Routine Description:

    Get the next member in a group entry.

Arguments:

    InquiryContext - context handle from RpcNsGroupMbrInqBeginW

    MemberName - pointer to return results.

Returns:

    nsi_group_mbr_inq_next()

--*/

{
    UNSIGNED16 NsiStatus;

    *MemberName = 0;

    RpcTryExcept
        {
        nsi_group_mbr_inq_next(InquiryContext, MemberName, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept


    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqDone(
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Finish enumerating the members of a group.

Arguments:

    InquiryContext - context handle from RpcNsGroupMbrInqBeginW

Returns:

    nsi_group_mbr_inq_done()

--*/

{
    UNSIGNED16 NsiStatus;

    RpcTryExcept
        {
        nsi_group_mbr_inq_done(InquiryContext, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Begin a inquiry to enumerate all the UUID objects in a server entry.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name of the server entry to inquiry.

    InquiryContext - context handle for RpcNsGroupMbrInqNextW

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_entry_object_inq_begin()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    *InquiryContext = 0;
        
    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;
        
    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_entry_object_inq_begin(NsiClntBinding, EntryNameSyntax, EntryName,
                InquiryContext, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;
        
        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return status;
}


RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqNext(
    IN RPC_NS_HANDLE InquiryContext,
    OUT UUID __RPC_FAR * ObjUuid
    )
/*++

Routine Description:

    Gets the next object UUID in the server entry.

Arguments:

    InquiryContext - context handle from RpcNsEntryObjectInqBeginW

    ObjUuid - pointer to memory to return results

Returns:

    nsi_entry_object_inq_next()

--*/

{
    UNSIGNED16 NsiStatus;

    RpcTryExcept
        {
        nsi_entry_object_inq_next(InquiryContext, (NSI_UUID_T *) ObjUuid, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqDone(
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Finish enumerating the objects of a server entry.

Arguments:

    InquiryContext - context handle from RpcNsEntryObjectInqBeginW

Returns:

    nsi_entry_object_inq_done()

--*/

{
    UNSIGNED16 NsiStatus;

    RpcTryExcept
        {
        nsi_entry_object_inq_done(InquiryContext, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtInqExpAge(
    OUT unsigned long *ExpirationAge
    )
/*++

Routine Description:

    Get the global time that a cached entry remains valide.

Arguments:

    ExpirationAge - place to expiration age in seconds

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_inq_exp_age()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_mgmt_inq_exp_age(NsiClntBinding, ExpirationAge, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
    
        status = NsiMapStatus(NsiStatus);

        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return status;
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtSetExpAge(
    IN unsigned long ExpirationAge
    )
/*++

Routine Description:

    set the global time that a cached entry remains valide.

Arguments:

    ExpirationAge - new expiration age in seconds

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_set_exp_age()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        
        RpcTryExcept
        {
            nsi_mgmt_inq_set_age(NsiClntBinding, ExpirationAge, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return status;
}


RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ExpandedName
    )
/*++

Routine Description:


Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that will be expanded.

    ExpandedName - fully quailified global name.

Returns:


--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_entry_expand_name(NsiClntBinding, EntryNameSyntax, EntryName, ExpandedName,
                &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
             
        status = NsiMapStatus(NsiStatus);

        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName,
    IN RPC_IF_ID * IfId, OPTIONAL
    IN unsigned long VersOption, OPTIONAL
    IN UUID_VECTOR * ObjectUuidVec OPTIONAL
    )
/*++

Routine Description:

    Remove interfaces and or objects from an server entry.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  The server name that will be unexported.

    IfId - The interface to unexport, NIL means objects only.

    VersOption -  constrains which interfaces to remove

    ObjectUuidVec - list of objects to remove in combination with interface.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_binding_unexport()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_mgmt_binding_unexport(NsiClntBinding, EntryNameSyntax, EntryName,
                (NSI_IF_ID_P_T) IfId, VersOption,
                (NSI_UUID_VECTOR_T *)ObjectUuidVec, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName
    )
/*++

Routine Description:

    Create an entry name that is empty.  It has no type and becomes a
    type according to the first add API aplied (profile, groupd, server).

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name of the new entry.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_entry_Create()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_mgmt_entry_create(NsiClntBinding, EntryNameSyntax, EntryName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;
        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName
    )
/*++

Routine Description:

    Remove an entry name (server, group or profile).

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_entry_delete()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        
        RpcTryExcept
        {
            nsi_mgmt_entry_delete(NsiClntBinding, EntryNameSyntax, EntryName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;
        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName,
    OUT RPC_IF_ID_VECTOR ** IfIdVec
    )
/*++

Routine Description:

    Get all the interface identifiers in a server entry.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    IfIdVec - pointer to return results in

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_entry_inq_ifids()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;


    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        *IfIdVec = 0;
        
        RpcTryExcept
        {
            nsi_mgmt_entry_inq_if_ids(NsiClntBinding, EntryNameSyntax, EntryName,
                (NSI_IF_ID_VECTOR_T **)  IfIdVec, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);

    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteW(
    IN unsigned long ProfileNameSyntax,
    IN unsigned short __RPC_FAR * ProfileName
    )

/*++

Routine Description:

    Remove a profile entry and all its member items.

Arguments:

    profileNameSyntax - This value describes the type/format of the profile ame.

    profileName -  Name that will be deleted.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_profile_delete()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! ProfileNameSyntax)
        ProfileNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_profile_delete(NsiClntBinding, ProfileNameSyntax, ProfileName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddW(
    IN unsigned long ProfileNameSyntax,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID * IfId,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned short __RPC_FAR * Annotation
    )
/*++

Routine Description:

    Add elements to the profile entry

Arguments:

    ProfileNameSyntax - This value describes the type/format of the ProfileName.

    ProfileName -  The server name that will be unexported.

    IfId - The interface to unexport, NIL means objects only.

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  The server name that will be unexported.

    Priority - Place to insert member in profile

    Annotation - comment for member

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_profile_elt_add()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! ProfileNameSyntax)
        ProfileNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_profile_elt_add(NsiClntBinding, ProfileNameSyntax, ProfileName,
                (NSI_IF_ID_P_T) IfId,
                MemberNameSyntax, MemberName, Priority, Annotation, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;       

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveW(
    IN unsigned long ProfileNameSyntax,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID * IfId,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName
    )

/*++

Routine Description:

    Remove an element from a profile entry.

Arguments:

    ProfileNameSyntax - This value describes the type/format of the ProfileName.

    ProfileName -  The server name that will be unexported.

    IfId - The interface to unexport, NIL means objects only.

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  The server name that will be unexported.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_binding_unexport()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! ProfileNameSyntax)
        ProfileNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_profile_elt_remove(NsiClntBinding, ProfileNameSyntax, ProfileName,
                    (NSI_IF_ID_P_T) IfId, MemberNameSyntax, MemberName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginW(
    IN unsigned long ProfileNameSyntax,
    IN unsigned short __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID * IfId,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName,
    OUT RPC_NS_HANDLE *InquiryContext
    )

/*++

Routine Description:

    Remove an element from a profile entry.

Arguments:

    ProfileNameSyntax - This value describes the type/format of the ProfileName.

    ProfileName -  The server name that will be unexported.

    InquiryType - Type of inquiry, one of RpcCProfile* constants

    IfId - The interface to unexport, NIL means objects only.

    VersOption - Version options, one of RpcCVers* constants

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  The server name that will be unexported.

    InquiryContext - context handle for use wiht RpcNsProfileEltInqNextW

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_profile_elt_inq_begin()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (InquiryContext)
        *InquiryContext = NULL;

    if (! ProfileNameSyntax)
        ProfileNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_profile_elt_inq_begin(NsiClntBinding, ProfileNameSyntax, ProfileName, InquiryType,
                (NSI_IF_ID_P_T) IfId, VersOption,
                MemberNameSyntax, MemberName, InquiryContext, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextW(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID * IfId,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation
    )
/*++

Routine Description:

    Gets the next element in the profile entry.

Arguments:

    InquiryContext - context handle from RpcNsEntryObjectInqBeginW

    MemberName - place to put profile element name

    IfId - place to return interface

    Priority - place to put profile element priority

    Annotation - place to put profile element comment

Returns:

    nsi_profile_elt_inq_next()

--*/
{
    unsigned short *  pAnnotation;
    unsigned short *  pMemberName;
    unsigned short ** ppAnnotation;
    unsigned short ** ppMemberName;
    
    UNSIGNED16 NsiStatus;

    if (Annotation)
        ppAnnotation = Annotation;
    else
        ppAnnotation = &pAnnotation;

    *ppAnnotation = NULL;

    if (MemberName)
        ppMemberName = MemberName;
    else
        ppMemberName = &pMemberName;

    *ppMemberName = NULL;
    
    RpcTryExcept
        {
        nsi_profile_elt_inq_next(InquiryContext, (NSI_IF_ID_P_T) IfId,
            ppMemberName, Priority, ppAnnotation, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    if (!Annotation)
        RpcStringFreeW(ppAnnotation);

    if (!MemberName)
        RpcStringFreeW(ppMemberName);

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqDone(
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Finish enumerating the objects of a profile entry.

Arguments:

    InquiryContext - context handle from RpcNsProfileEltInqBeginW

Returns:

    nsi_profile_elt_inq_done()

--*/

{
    UNSIGNED16 NsiStatus;

    RpcTryExcept
        {
        nsi_profile_elt_inq_done(InquiryContext, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}



// The following are ASCII wrappers to the UNICODE API's

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteA(
    IN unsigned long GroupNameSyntax,
    IN unsigned char __RPC_FAR * GroupName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING GroupNameW(GroupName);

    if (GroupNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsGroupDeleteW(GroupNameSyntax, &GroupNameW));
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddA(
    IN unsigned long GroupNameSyntax,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING GroupNameW(GroupName);
    WIDE_STRING MemberNameW(MemberName);

    if (GroupNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsGroupMbrAddW(GroupNameSyntax, &GroupNameW,
   	MemberNameSyntax, &MemberNameW));
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveA(
    IN unsigned long GroupNameSyntax,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING GroupNameW(GroupName);
    WIDE_STRING MemberNameW(MemberName);

    if (GroupNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsGroupMbrRemoveW(GroupNameSyntax, &GroupNameW,
   	MemberNameSyntax, &MemberNameW));
}



RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginA(
    IN unsigned long GroupNameSyntax,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING GroupNameW(GroupName);

    if (GroupNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsGroupMbrInqBeginW(GroupNameSyntax, &GroupNameW,
	MemberNameSyntax, InquiryContext));
}

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextA(
    OUT RPC_NS_HANDLE InquiryContext,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    RPC_STATUS Status;

    Status = RpcNsGroupMbrInqNextW(InquiryContext,
        (unsigned short __RPC_FAR * __RPC_FAR *) MemberName);

    if (Status)
        return(Status);

    return(UnicodeToAscii((unsigned short *) *MemberName));
}


RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsEntryObjectInqBeginW(EntryNameSyntax, &EntryNameW,
        InquiryContext));
}

RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ExpandedName
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    RPC_STATUS Status;
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    Status = RpcNsEntryExpandNameW(EntryNameSyntax, &EntryNameW,
        (unsigned short __RPC_FAR * __RPC_FAR *) ExpandedName);

    if (Status)
        return(Status);

    return(UnicodeToAscii((unsigned short *) *ExpandedName));
}


RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    IN RPC_IF_ID * IfId,
    IN unsigned long VersOption,
    IN UUID_VECTOR * ObjectUuidVec OPTIONAL
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsMgmtBindingUnexportW(EntryNameSyntax, &EntryNameW,
        IfId, VersOption, ObjectUuidVec));
}

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsMgmtEntryCreateW(EntryNameSyntax, &EntryNameW));
}

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsMgmtEntryDeleteW(EntryNameSyntax, &EntryNameW));
}

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    OUT RPC_IF_ID_VECTOR ** IfIdVec
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsMgmtEntryInqIfIdsW(EntryNameSyntax, &EntryNameW,
	IfIdVec));
}


RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteA(
    IN unsigned long ProfileNameSyntax,
    IN unsigned char __RPC_FAR * ProfileName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING ProfileNameW(ProfileName);

    if (ProfileNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsProfileDeleteW(ProfileNameSyntax, &ProfileNameW));
}

RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddA(
    IN unsigned long ProfileNameSyntax,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID * IfId,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned char __RPC_FAR * Annotation
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING ProfileNameW(ProfileName);
    WIDE_STRING MemberNameW(MemberName);
    WIDE_STRING AnnotationW(Annotation);

    if (ProfileNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (AnnotationW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsProfileEltAddW(ProfileNameSyntax, &ProfileNameW,
	IfId, MemberNameSyntax, &MemberNameW, Priority, &AnnotationW));
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveA(
    IN unsigned long ProfileNameSyntax,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID * IfId,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING ProfileNameW(ProfileName);
    WIDE_STRING MemberNameW(MemberName);

    if (ProfileNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsProfileEltRemoveW(ProfileNameSyntax, &ProfileNameW,
	IfId, MemberNameSyntax, &MemberNameW));
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginA(
    IN unsigned long ProfileNameSyntax,
    IN unsigned char __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID * IfId,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName,
    OUT RPC_NS_HANDLE *InquiryContext
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING ProfileNameW(ProfileName);
    WIDE_STRING MemberNameW(MemberName);

    if (ProfileNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsProfileEltInqBeginW(ProfileNameSyntax, &ProfileNameW,
	InquiryType, IfId, VersOption, MemberNameSyntax, &MemberNameW,
	InquiryContext));
}

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextA(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID * IfId,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    RPC_STATUS Status;

    Status = RpcNsProfileEltInqNextW(InquiryContext, IfId,
        (unsigned short __RPC_FAR * __RPC_FAR *) MemberName, Priority,
        (unsigned short __RPC_FAR * __RPC_FAR *) Annotation);

    if (Status)
        return(Status);

    if (Status = UnicodeToAscii((unsigned short *) *MemberName))
        return(Status);

    if (Annotation)
        return(UnicodeToAscii((unsigned short *) *Annotation));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\startsvc.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    startsvc.h

Abstract:

    This file contains the interface for insuring that the rpcss service
    has been started.

Author:

    Michael Montague (mikemon) (02-Oct-1992)

Revision History:

--*/

#ifndef __STARTSVC_H__
#define __STARTSVC_H__

#ifdef __cplusplus
extern "C" {
#endif

RPC_STATUS
StartServiceIfNecessary (
    void
    );

#ifdef __cplusplus
}
#endif


#endif // __STARTSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\nsisvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    nsisvr.cxx

Abstract:

    This is the server side NSI service support layer.  These are wrappers
    which call the name service provider.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#include <nsi.h>

#include <memory.h>
#include <string.h>
#include <stdio.h>

RPC_STATUS RPC_ENTRY
RpcNsBindingExportW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle, OPTIONAL
    IN RPC_BINDING_VECTOR * BindingVector, OPTIONAL
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )

/*++

Routine Description:

    Place a server interface and objects in the name service data base.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    RpcIfHandle - The interface that is being exported.

    BindingVector - A list of StringBindings to export that are associated
        with this interface.

    ObjectVector -  A list of objects that are associated with this
       interface and Entry Name

Returns:

    Bind(), RpcBindingToStringBinding(), nsi_binding_export()


--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    NSI_SERVER_BINDING_VECTOR_T *NsiVector = 0;
    WIDE_STRING *StringBindingW;
    RT_CHAR * StringBinding = 0;
    RT_CHAR * DynamicEndpoint = 0;
    unsigned int Index;
    unsigned int VectorSize = 0;
    NSI_INTERFACE_ID_T NilIfOnWire, __RPC_FAR *IfPtr;

    if (RpcIfHandle == NULL)
      {
         IfPtr = &NilIfOnWire;
         memset(IfPtr, 0, sizeof(NSI_INTERFACE_ID_T));
      }
    else
      {
         IfPtr = (NSI_INTERFACE_ID_T __RPC_FAR *)
                    &((PRPC_CLIENT_INTERFACE)RpcIfHandle)->InterfaceId;
      }


    if (status = I_NsServerBindSearch())
        return(status);

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    if (BindingVector && BindingVector->Count && RpcIfHandle)
        {
        VectorSize = (unsigned int) BindingVector->Count;

        NsiVector = (NSI_SERVER_BINDING_VECTOR_T *) I_RpcAllocate((unsigned int) (
            sizeof(NSI_SERVER_BINDING_VECTOR_T) +
            sizeof(unsigned short *) * VectorSize));

        if (!NsiVector)
            return(RPC_S_OUT_OF_MEMORY);

        NsiVector->count = 0;
        }

    // Copy the vector of binding handles into a vector of string bindinds
    // that are wide character.

    for (Index = 0; Index < VectorSize; Index++)
        {

        if (!BindingVector->BindingH[Index])
            continue;

        // Turn the private runtime data structure into a StringBinding.
#ifdef NTENV
        status = I_RpcBindingToStaticStringBindingW(BindingVector->BindingH[Index],
                &StringBinding);

        // call to remove the dynamic part from the binding
        // and give the string binding.
#else
        status = RpcBindingToStringBinding(BindingVector->BindingH[Index],
                &StringBinding);
#endif

        if (status)
            goto ErrorExit;

        StringBindingW = new WIDE_STRING (StringBinding);

        if (!StringBindingW || StringBindingW->OutOfMemory())
            {
            status = RPC_S_OUT_OF_MEMORY;
            goto ErrorExit;
            }

        NsiVector->string[NsiVector->count++] = &(*StringBindingW);

        I_RpcFree(StringBindingW);      // Free memory without destuctor

#ifndef NTENV
        I_RpcFree(StringBinding);       // Free the non unicode string
#endif
        }

    RpcTryExcept
        {
        nsi_binding_export(
                           NsiSvrBinding,
                           EntryNameSyntax,
                           EntryName,
                           IfPtr,
                           NsiVector,
                           (NSI_UUID_VECTOR_P_T) ObjectVector,
                           &NsiStatus
                          );

        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    status = NsiMapStatus(NsiStatus);

ErrorExit:
    // Return memory allocated for nsi vector.

    if (NsiVector)
        for (Index = 0; Index < NsiVector->count; Index++)
            I_RpcFree(NsiVector->string[Index]);

    if (NsiVector)
        I_RpcFree(NsiVector);

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle OPTIONAL,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )

/*++

Routine Description:

    Remove a server interface and objects in the name service data base.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    RpcIfHandle - The interface that is being unexported.

    ObjectVector -  A list of objects that are associated with this
       interface and Entry Name

Returns:

    Bind(), nsi_binding_unexport()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    NSI_INTERFACE_ID_T NilIfOnWire, __RPC_FAR *IfPtr;

    if (RpcIfHandle == NULL)
      {
         IfPtr = &NilIfOnWire;
         memset(IfPtr, 0, sizeof(NSI_INTERFACE_ID_T));
      }
    else
      {
         IfPtr = (NSI_INTERFACE_ID_T __RPC_FAR *)
                    &((PRPC_CLIENT_INTERFACE)RpcIfHandle)->InterfaceId;
      }


    if (status = I_NsServerBindSearch())
        return(status);

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    RpcTryExcept
        {
         nsi_binding_unexport(NsiSvrBinding, EntryNameSyntax, EntryName,
             IfPtr, (NSI_UUID_VECTOR_P_T) ObjectVector,
             &NsiStatus); 
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingExportA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle,
    IN RPC_BINDING_VECTOR * BindingVector, OPTIONAL
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingExportW(EntryNameSyntax, &EntryNameW,
        RpcIfHandle, BindingVector, ObjectVector));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingUnexportW(EntryNameSyntax, &EntryNameW,
        RpcIfHandle, ObjectVector));
}

#ifdef NTENV

/*
Function:
        The Binding Vector corresponding to this Server is discovered
using InqBindings, And is cached along with the EntryName and RpcIfHandle 
in the same Process.

When a PnP event occurs resulting in addition/deletion of the bindings
Corresponding changes are made to the Name Service database. (added or deleted)

Notice that this can not be called from a process that is not a server. The
Exports have to be done from the server itself if it has to be PnP aware

*/

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle, OPTIONAL
     IN UUID_VECTOR * ObjectVector OPTIONAL
    )

{
    RPC_STATUS status = RPC_S_OK;
    RPC_BINDING_VECTOR *BindingVec = NULL;

    status = RpcServerInqBindings(&BindingVec);
    // InqBindings to get the binding vector

    if (status != RPC_S_OK)
        return status;


    status = RpcNsBindingExportW(EntryNameSyntax, EntryName,
                                     RpcIfHandle, BindingVec, 
                                     ObjectVector
                                     );
    if (status != RPC_S_OK)
        return status;

    // only if this is valid, other invalid cases will all be caught before

    if (RpcIfHandle)
        status = I_RpcNsInterfaceExported(EntryNameSyntax, EntryName,
                                      (RPC_SERVER_INTERFACE *)RpcIfHandle);

    return status;

// going to cache for bindings exported to the locator 
// (only if the prev. export succeeded)
}

/*
        Removes all the bindings corresponding to this particular server
from the Name Service database. It also removes it from the cache that
is maintained for the EntryName/InterfaceId combination.

Notice that this can not be called from a process that is not a server. The
Unexports have to be done from the server itself if it has to be PnP aware

*/

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle OPTIONAL,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )
{
    RPC_STATUS status = RPC_S_OK;
    status = RpcNsBindingUnexportW(EntryNameSyntax, EntryName,
                                   RpcIfHandle, ObjectVector);

    if (status != RPC_S_OK)
        return status;

    if (RpcIfHandle)
        status = I_RpcNsInterfaceUnexported(EntryNameSyntax, EntryName,
                                      (RPC_SERVER_INTERFACE *)RpcIfHandle);
    // once it has got removed, remove it from the cache as well.

    return status;
}

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle, OPTIONAL
     IN UUID_VECTOR * ObjectVector OPTIONAL
    )

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingExportPnPW(EntryNameSyntax, &EntryNameW,
        RpcIfHandle, ObjectVector));

}

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle OPTIONAL,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )
{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingUnexportPnPW(EntryNameSyntax, &EntryNameW,
        RpcIfHandle, ObjectVector));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\nsiclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    nsiclnt.cxx

Abstract:

    This is the client side NSI service support layer.  These are wrappers
    which call the name service provider.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#include <nsi.h>

#include <string.h>
#include <time.h>


// This structure is used in binding handle select processing.

typedef struct
{
    unsigned long Count;
    int IndexMatch[1];

} MATCH_VECTOR;

RPC_STATUS RPC_ENTRY 
I_NsBindingFoundBogus(RPC_BINDING_HANDLE *BindingHandle, DWORD BindId);
RPC_STATUS RPC_ENTRY
I_NsClientBindSearch(RPC_BINDING_HANDLE *NsiClntBinding, DWORD *BindId);
void RPC_ENTRY
I_NsClientBindDone(RPC_BINDING_HANDLE *NsiClntBinding, DWORD BindId);



RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle,
    IN UUID __RPC_FAR * Object OPTIONAL,
    IN unsigned long BindingMaxCount,
    OUT RPC_NS_HANDLE *LookupContext
    )

/*++

Routine Description:

    Query the named server for the requested binding handles.  This will
    request a query from name server to be performed and store the results
    to be retrieved with RpcNsBindingLookupNext().

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    RpcIfHandle - The interface that is being exported.

    Object - the object UUID that you are looking for (or in combination
        with RpcIfHandle).

    BindingMaxCount - The maxium size of the binding vector to be returned
        to the RpcNsBindingLookupNext function.

    LookupContext - handle to be used to pass to RpcNsBindingImportNext,
        This is really allocated by RpcNsLookupBinding

    SearchOptions - used by the auto handle binding routines and Micosoft
        name server.

Returns:

    RPC_S_OK, RPC_S_NO_MORE_BINDINGS

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    NSI_INTERFACE_ID_T NilIfOnWire, __RPC_FAR *IfPtr;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (RpcIfHandle == NULL)
      {
         IfPtr = &NilIfOnWire;
         memset(IfPtr, 0, sizeof(NSI_INTERFACE_ID_T));
      }
    else
      {
         IfPtr = (NSI_INTERFACE_ID_T __RPC_FAR *)
                    &((PRPC_CLIENT_INTERFACE)RpcIfHandle)->InterfaceId;
      }

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK)
    {
        
        // Provide the default entry name if there is none.
        
        if ((! EntryName || *EntryName == 0) && DefaultName)
        {
            EntryName = &(*DefaultName);
            EntryNameSyntax = DefaultSyntax;
        }
        else if (! EntryNameSyntax)
            EntryNameSyntax = DefaultSyntax;
        
        RpcTryExcept
        {
            nsi_binding_lookup_begin(NsiClntBinding, EntryNameSyntax, EntryName,
                IfPtr,
                (NSI_UUID_P_T) Object, BindingMaxCount, 0,
                LookupContext, &NsiStatus);
            
        }
        RpcExcept(1)
        {
            *LookupContext = 0;
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;
        
        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsBindingLookupNext(
    IN  RPC_NS_HANDLE LookupContext,
    OUT RPC_BINDING_VECTOR **BindingVector
    )

/*++

Routine Description:

    Retrieve the next group of bindings queryed from RpcNsBindingLookupBegin().
Arguments:

    LookupContext - handle to allocated by RpcNsBindingLookupBegin()

    BindingVector - returns a pointer to a  binding vector.

Returns:

    RPC_S_OK, RPC_S_NO_MORE_BINDINGS, RPC_S_OUT_OF_MEMORY,
    nsi_binding_lookup_next()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    NSI_BINDING_VECTOR_T * NsiBindingVector;
    RPC_BINDING_HANDLE Handle;
    unsigned int HandleValide, Index;

     NsiBindingVector = 0;
    *BindingVector = 0;

    RpcTryExcept
        {
        nsi_binding_lookup_next((NSI_NS_HANDLE_T *) LookupContext,
            &NsiBindingVector, &NsiStatus);

        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    if (NsiStatus)
        return(NsiMapStatus(NsiStatus));

    // Convert the string bindings to binding handles.  This done by
    // replacing the StringBinding with RPC_BINDING_HANDLE to a
    // RPC_BINDING_VECTOR allocated by the runtime.

    *BindingVector = (RPC_BINDING_VECTOR *) I_RpcAllocate((unsigned int) (
        sizeof(RPC_BINDING_VECTOR) - sizeof(RPC_BINDING_HANDLE) +
        sizeof(RPC_BINDING_HANDLE) * NsiBindingVector->count));

    if (! *BindingVector)
        return(RPC_S_OUT_OF_MEMORY);

    for (Index = 0, HandleValide = 0;
        Index < NsiBindingVector->count; Index++)
        {
        Handle = 0;

        if (!UnicodeToRtString(NsiBindingVector->binding[Index].string))
            status = RpcBindingFromStringBinding(
                    (RT_CHAR *)NsiBindingVector->binding[Index].string, &Handle);


        if (!status && NsiBindingVector->binding[Index].entry_name)
            {
            if (!UnicodeToRtString( NsiBindingVector->binding[Index].entry_name))
            {
#ifdef NTENV
                status = I_RpcNsBindingSetEntryNameW(Handle,
#else
                status = I_RpcNsBindingSetEntryName(Handle,
#endif
                    NsiBindingVector->binding[Index].entry_name_syntax,
                    (RT_CHAR *)NsiBindingVector->binding[Index].entry_name);
                }
            }

        if (NsiBindingVector->binding[Index].entry_name)
             I_RpcFree(NsiBindingVector->binding[Index].entry_name);

        I_RpcFree(NsiBindingVector->binding[Index].string);

        // only copy the handle to the output if the Binding was OK.

        if (! status)
            (*BindingVector)->BindingH[HandleValide++] = Handle;
        }

    (*BindingVector)->Count = HandleValide;

    I_RpcFree(NsiBindingVector);

    return((HandleValide > 0)? RPC_S_OK: RPC_S_NO_MORE_BINDINGS);
}



RPC_STATUS RPC_ENTRY
RpcNsBindingLookupDone(
    OUT RPC_NS_HANDLE *LookupContext
    )

/*++

Routine Description:

    Close the context opened with RpcNsBindingLookupBegin();

Arguments:

    LookupContext - context handle to close

Returns:

    nsi_binding_lookup_done()

--*/

{
    UNSIGNED16 NsiStatus = NSI_S_OK;

    RpcTryExcept
        {
        nsi_binding_lookup_done((NSI_NS_HANDLE_T *) LookupContext, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

//    RpcBindingFree(&NsiClntBinding);
    *LookupContext = 0;

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle,
    IN UUID __RPC_FAR * Object OPTIONAL,
    OUT RPC_NS_HANDLE *ImportContextOut
    )

/*++

Routine Description:

    Query the named server for the requested binding handles.  This function
    is implemented in terms of RpcNsLookupBinding.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    RpcIfHandle - The interface that is being exported.

    Object - the object UUID that you are looking for (or in combination
        with RpcIfHandle).

    ImportContext - handle to be used to pass to RpcNsBindingImportNext,
        This is really allocated by RpcNsLookupBinding

    SearchOptions - used by the auto handle binding routines and Micosoft
        name server.

Returns:


    RpcNsBindingLookupBegin(), RPC_S_OUT_OF_MEMORY, RPS_S_OK
--*/

{
    RPC_STATUS status;
    RPC_NS_HANDLE LookupContext;
    PRPC_IMPORT_CONTEXT_P ImportContext;
    const int BindingVectorSize = 10;

    *ImportContextOut = 0;

    status = RpcNsBindingLookupBeginW(EntryNameSyntax, EntryName,
        RpcIfHandle, Object, BindingVectorSize, &LookupContext);

    if (status)
        return(status);

    // Allocate an import context which contains a lookup context,
    // a StringBinding vector and an index to the current StringBinding
    // in the vector.

    if (!(ImportContext = (PRPC_IMPORT_CONTEXT_P)
            I_RpcAllocate(sizeof(RPC_IMPORT_CONTEXT_P))) )

        return(RPC_S_OUT_OF_MEMORY);

    ImportContext->LookupContext = LookupContext;
    ImportContext->Bindings = 0;

    *ImportContextOut = ImportContext;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcNsBindingImportNext(
    IN RPC_NS_HANDLE ImportContextIn,
    OUT RPC_BINDING_HANDLE __RPC_FAR * RpcBinding
    )

/*++

Routine Description:

    Get the next StringBinding in the Import StringBinding vector.  If
    the vector is empty, call RpcNsBindingLookupBegin() to get a new
    vector.

Arguments:

    ImportContext - handle to be used get a new string binding vector from
        RpcNsBindingLookupNext()

    RpcBinding - place to return a binding.  This Binding Handle ownership
        passes to caller.

Returns:

    RPC_S_OK, RpcNsBindingLookupNext()

--*/

{
    RPC_STATUS status;
    PRPC_IMPORT_CONTEXT_P ImportContext;

    ImportContext = (PRPC_IMPORT_CONTEXT_P) ImportContextIn;

    if (!ImportContext)
        return(RPC_S_NO_CONTEXT_AVAILABLE);

    if (ImportContext->Bindings)
        {
        status = RpcNsBindingSelect(ImportContext->Bindings, RpcBinding);

        if (status == RPC_S_OK)
            return(RPC_S_OK);

        if (status != RPC_S_NO_MORE_BINDINGS)
            return(status);
        }

    // The vector was empty or there were no more entris.  Get another vector.

    if (ImportContext->Bindings)
        RpcBindingVectorFree(&ImportContext->Bindings);

    status = RpcNsBindingLookupNext(ImportContext->LookupContext,
        &ImportContext->Bindings);

    if (status)
        return(status);

    return(RpcNsBindingSelect(ImportContext->Bindings, RpcBinding));

}



RPC_STATUS RPC_ENTRY
RpcNsBindingImportDone(
    IN RPC_NS_HANDLE *ImportContextIn
    )

/*++

Routine Description:

    Close an Import Context handle when done.  Free up the current
    Bindings vector, LookupContext and ImportContext structure.

Arguments:

    ImportContext - handle to close.

Returns:

    RPC_S_OK, RpcNsBindingLookupDone()

--*/

{
    RPC_STATUS status;
    PRPC_IMPORT_CONTEXT_P ImportContext;

    ImportContext = (PRPC_IMPORT_CONTEXT_P) *ImportContextIn;

    if (! ImportContext)
        return(RPC_S_OK);

    if (ImportContext->Bindings)
        RpcBindingVectorFree(&ImportContext->Bindings);

    status = RpcNsBindingLookupDone(&ImportContext->LookupContext);

    I_RpcFree (ImportContext);
    *ImportContextIn = 0;

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsMgmtHandleSetExpAge(
    IN RPC_NS_HANDLE NsHandle,
    IN unsigned long ExpirationAge
    )
/*++

Routine Description:

    Set the maxium age that a cached entry will be returned in reponse
    to a name service inquirary transaction.

Arguments:

    NsHandle - context handle created with one of the RpcNs*Begin APIs

Returns:

    nsi_mgmt_handle_set_exp_age()

--*/

{
    UNSIGNED16 NsiStatus;
    RPC_NS_HANDLE LookupContext =
                  ((PRPC_IMPORT_CONTEXT_P)NsHandle)->LookupContext;


    RpcTryExcept
        {
        nsi_mgmt_handle_set_exp_age(LookupContext, ExpirationAge, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}


#define isLocalName(NetWorkAddress) (1) //BUGBUG


static RPC_STATUS
GetMatchingProtocols(
    IN RPC_BINDING_VECTOR *BindingVector,
    OUT MATCH_VECTOR *MatchVector,
    IN char * SearchProtocol, OPTIONAL
    IN int fLocalOnly
    )

/*++

Routine Description:

    Construct a match binding vector with protocols that we are interested in.
    PERF: When we know how to parse NetWorkAddress to know when it is
    a local name, we should select those first

Arguments:

    BindingVector - vector of binding handles to select from.

    MatchVector - place to put the results.

    SearchProtocol - Protocol we are looking for.  A Nil matches everything.

Returns:

    The number of protocols that we matched in the match vector.

    RPC_S_OK, RpcBindingToStringBinding(), RpcStringBindingParse()

--*/

{
    RPC_STATUS Status;
    unsigned int Index;
    RT_CHAR * StringBinding, *ProtocolSeq, *NetAddress;
    int fProtocolsMatched;

    MatchVector->Count = 0;

    for (Index = 0; Index < BindingVector->Count; Index++)
        {
        if (!BindingVector->BindingH[Index])
            continue;

        // Convert the binding handle to a string and then extract
        // the fields we are interested in.

        if (Status = RpcBindingToStringBinding(
            BindingVector->BindingH[Index], &StringBinding))

             return (Status);

        if (Status = RpcStringBindingParse(StringBinding, 0,
            &ProtocolSeq, &NetAddress, 0, 0))

             return (Status);

        fProtocolsMatched = 1;

        if (SearchProtocol)
            {
            char * STmp = SearchProtocol;

            for (RT_CHAR *pT = ProtocolSeq; *pT &&
                (char) *pT++ == *STmp++; ) ;

            if (*STmp)
                fProtocolsMatched = 0;
            }

        // If we are looking for a local name only and the matched
        // protocol isn't local, throw this one out.

        if (fLocalOnly && !isLocalName(NetAddress))
            fProtocolsMatched = 0;


        // Return all the strings to the RPC runtime.

        if (Status = RpcStringFree(&ProtocolSeq))
            return(Status);

        if (Status = RpcStringFree(&NetAddress))
            return(Status);

        if (Status = RpcStringFree(&StringBinding))
            return(Status);

        if (! fProtocolsMatched)
           continue;


        // A match is recorded as an index into the original vector.

        MatchVector->IndexMatch[MatchVector->Count++] = Index;
        }

    return(RPC_S_OK);
}


int
RandomNumber(
    )
/*++

Routine Description:

    Yet another pseudo-random number generator.

Returns:

    New random number, in the range 0..32767.

--*/
{
     static long holdrand;
     static int fInitialized = 0;

    // Start with a different seed everytime.

    if (!fInitialized)
        {
        fInitialized = 1;
//      holdrand = clock();
        }

    return( (int) (holdrand = (long) ( (holdrand * 214013L + 2531011L)
                >> 16  & 0x7fff ) ));
}



RPC_STATUS RPC_ENTRY
RpcNsBindingSelect(
    IN OUT RPC_BINDING_VECTOR *BindingVector,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * RpcBinding
    )

/*++

Routine Description:

    This function will select a Binding handle from a vector of binding
    handles.  Since we know a little bit about our binding handles, we
    will chose the more effiecent types of handles first.  We select
    groups of bindings unordered via a random number generator.

Arguments:

    BindingVector - vector of binding handles to select from

    RpcBinding - place to return the binding handle.  The ownership of
       the handle passes to the caller.

Returns:

    RPC_S_OK, RPC_S_OUT_OF_MEMORY, RPC_S_NO_MORE_BINDINGS, GetMatchingProtocols()

--*/

{
    static char * PreferredProtocol[] =
    {
        "ncalrpc",
        "ncacn_np",
        0
    };
    int CountPreferredProtocol = sizeof(PreferredProtocol) / sizeof(void *);

    RPC_STATUS Status;
    MATCH_VECTOR *MatchVector;
    int IndexSelected;
    int ProtocolIndex;
    int fLocalOnly;

    *RpcBinding = 0;

    MatchVector = (MATCH_VECTOR *) I_RpcAllocate((unsigned int)
        (sizeof(MATCH_VECTOR) + sizeof(int) * BindingVector->Count));

    if (!MatchVector)
        return(RPC_S_OUT_OF_MEMORY);

    // For all the protocols returned, first try the local ones, then
    // the remote.

    for (fLocalOnly = 1; fLocalOnly >= 0; fLocalOnly--)
        {
        for (ProtocolIndex = 0; ProtocolIndex < CountPreferredProtocol;
             ProtocolIndex++)
            {

            // First, get the perferred protocols into a match vector.
            // The match vector has a range from 0..number of matching protocols.
            // We need this so we know what range to generate a random number.

            if (Status = GetMatchingProtocols(BindingVector, MatchVector,
                PreferredProtocol[ProtocolIndex], fLocalOnly))

                return(Status);

            // If we found any, select one and return it.

            if (MatchVector->Count)
                {
                IndexSelected = MatchVector->
                    IndexMatch[RandomNumber() % MatchVector->Count];

                *RpcBinding = BindingVector->BindingH[IndexSelected];

                // Remove selected one from binding vector.

                BindingVector->BindingH[IndexSelected] = 0;
                I_RpcFree (MatchVector);

                return(RPC_S_OK);
                }
            }
        }

    I_RpcFree (MatchVector);

    return(RPC_S_NO_MORE_BINDINGS);
}


RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE RpcIfSpec,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount,
    OUT RPC_NS_HANDLE *LookupContext
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingLookupBeginW(EntryNameSyntax, &EntryNameW,
        RpcIfSpec, ObjUuid, BindingMaxCount, LookupContext));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE RpcIfSpec,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE *ImportContext
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingImportBeginW(EntryNameSyntax, &EntryNameW,
        RpcIfSpec, ObjUuid, ImportContext));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\startsvc.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    startsvc.c

Abstract:

    This routine implements on-demand starting of the RpcSs service.

Author:

    Bharat Shah (barats) 4-5-92

Revision History:

--*/

#include <windows.h>
#include <rpc.h>
#include <winsvc.h>
#include <startsvc.h>

#define SUCCESS         0
#define RPCLOCATOR      "RPCLOCATOR"



RPC_STATUS 
StartServiceIfNecessary(
    void
    )
/*++

Routine Description:

    If the locator service has not yet been started, then we attempt to
    start it.

Returns:

    RPC_S_OK - The locator service is running.

    Service controller errors.


--*/
{

    SC_HANDLE           hServiceController = NULL;
    SC_HANDLE           hService = NULL;
    SERVICE_STATUS      ServiceStatus;
    DWORD               status;
    DWORD               Counter = 0L;
    BOOL                FirstTime = TRUE;
    unsigned long       ArgC = 0;
    char     __RPC_FAR *     ArgV[1] = { NULL };

    //
    // Get a handle to the service controller.
    //
    hServiceController = OpenSCManager(
                            NULL,
                            NULL,
                            GENERIC_READ);

    if (hServiceController == NULL)
       {
        status = GetLastError();
        return(status);
       }

    //
    // Get a handle to the service
    //
    hService = OpenService(
                hServiceController,
                RPCLOCATOR,
                GENERIC_READ|SERVICE_START);

    if (hService == NULL)
       {
        status = GetLastError();
        goto CleanExit;
       }

    //
    // Call StartService
    //
    /*
    if (!StartService(hService,ArgC,ArgV))
       {
          status = GetLastError();
          if (status == ERROR_SERVICE_ALREADY_RUNNING)
             status = RPC_S_OK;
          goto CleanExit;
       }
    */

    do
      {

        if (!QueryServiceStatus(hService,&ServiceStatus))
            {
              status = GetLastError();
              goto CleanExit;
            }

        switch(ServiceStatus.dwCurrentState)
        {

          case SERVICE_RUNNING:
                status = SUCCESS;
                goto CleanExit;
                break;

          case SERVICE_STOP_PENDING:
          case SERVICE_START_PENDING:
                if (!FirstTime && (Counter == ServiceStatus.dwCheckPoint))
                   {
                    status = ERROR_SERVICE_REQUEST_TIMEOUT;
                    goto CleanExit;
                   }
                else
                   {
                    FirstTime = FALSE;
                    Counter = ServiceStatus.dwCheckPoint;
                    Sleep(ServiceStatus.dwWaitHint);
                   }
                 break;
 
          case SERVICE_STOPPED:
                if (!StartService(hService,ArgC,ArgV))
                   {
                   status = GetLastError();
                   if (status == ERROR_SERVICE_ALREADY_RUNNING)
                               status = RPC_S_OK;
                   goto CleanExit;
                   }
                 Sleep(500);
                 break;

          default:
                 status = GetLastError();
                 goto CleanExit;
                 break;
       }
    }
   while (TRUE);

CleanExit:

    if(hServiceController != NULL) {
        (VOID) CloseServiceHandle(hServiceController);
    }
    if(hService != NULL) {
        (VOID) CloseServiceHandle(hService);
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\ntutil.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    ntutil.c

Abstract:

    This is provides basic utilities for the NT DLL.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#include <nsi.h>
#include <string.h>

void
AsciiToUnicodeNT(
    OUT unsigned short *String,
    IN unsigned char *AsciiString
    )
/*++

Routine Description:

    Convert a ASCII string to unicode via the NT librarys

Arguments:

    String - place to put result

    AsciiString - string to convert

--*/
{
    while(*String++ = RtlAnsiCharToUnicodeChar ((PUCHAR *) &AsciiString)) ;
}

int
UnicodeToAscii(
    unsigned short *WideCharString
    )
/*++

Routine Description:

    Make a  ASCII string from an UNICODE string.  This is done in
    place so the string becomes ASCII.

Arguments:

    UnicodeString - unicode string to convert

Returns:

    RPC_S_OK, RPC_S_OUT_OF_MEMORY

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    RtlInitUnicodeString(&UnicodeString, WideCharString);
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);

    if (!NT_SUCCESS(NtStatus))
        return(RPC_S_OUT_OF_MEMORY);

    strcpy((char *)WideCharString, AnsiString.Buffer);
    RtlFreeAnsiString(&AnsiString);

    return(RPC_S_OK);
}


static RTL_CRITICAL_SECTION GlobalMutex;

extern "C" {
int
InitializeDLL (
    IN void * DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*++

Routine Description:

    NT DLL initialization function. Allocate/free the global MUTEX.

Arguments:

    DllHandle - my module handle

    Reason - why this funciton is being called

    Context - the context pointer.

Returns:

    0 if there were no error during initialization, non 0 otherwise.

--*/
{
    NTSTATUS Status;

    UNUSED(Context);

    if (Reason == DLL_PROCESS_ATTACH)
        {
#ifndef RPC_NT31
        // API added for NT 3.11, don't call when building for NT 3.1

        DisableThreadLibraryCalls((HMODULE)DllHandle);
#endif

        Status = RtlInitializeCriticalSection(&GlobalMutex);

        if (! NT_SUCCESS(Status) )
            return(FALSE);

        }

    if (Reason == DLL_PROCESS_DETACH)
        {
        Status = RtlDeleteCriticalSection(&GlobalMutex);
        }

    return(TRUE);
}

}


void
GlobalMutexRequest (
    void
    )
/*++

Routine Description:

    Request the global mutex.

--*/
{
    NTSTATUS Status;

    Status = RtlEnterCriticalSection(&GlobalMutex);
}


void
GlobalMutexClear (
    void
    )
/*++

Routine Description:

    Clear the global mutex.

--*/
{
    NTSTATUS Status;

    Status = RtlLeaveCriticalSection(&GlobalMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\sbind.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    sbind.cxx

Abstract:

    This is the server side NSI service support layer.  These functions
    provide for binding to the locator.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#define NSI_ASCII
#define RegistryIsWorking

#include <nsi.h>

#ifdef NTENV
#include <windows.h>
#endif

#include <winreg.h>

#include <string.h>

#ifdef NTENV

#include <startsvc.h>

#endif

RPC_BINDING_HANDLE NsiSvrBinding;	 // global binding handle to locator


// *** The following functions are used to RPC to the locator *** ///

RPC_STATUS RPC_ENTRY
I_NsServerBindSearch (
    )
/*++

Routine Description:

   Servers keep their RPC binding open until they terminate.

Returns:

    RPC_S_OK, RPC_S_CALL_FAILED_DNE, RpcStringBindingCompose(),
    RpcBindingFromStringBinding()

--*/
{
    RPC_STATUS status;
    long statusTmp;
    static RPC_BINDING_HANDLE NsiSvrBindingExport;
    unsigned char * StringBinding;
    HKEY RegHandle;
    unsigned char *ProtoSeq;
    unsigned char *NetworkAddress;
    unsigned char *Endpoint;

    RequestGlobalMutex();

    if (NsiSvrBinding = NsiSvrBindingExport)
        {
        ClearGlobalMutex();
	return(RPC_S_OK);
        }

#ifndef RegistryIsWorking
        ProtoSeq = (unsigned char *)"ncacn_np";
        NetworkAddress = 0;
        Endpoint = (unsigned char *)"\\pipe\\locator";
        DefaultSyntax = 1;

    status = RpcStringBindingCompose(0, ProtoSeq,
        NetworkAddress, Endpoint, 0, &StringBinding);
#else


    // We store the binding information on the name service in
    // the registry.  Get the information into BindingHandle.

#ifdef NTENV
    statusTmp = RegOpenKeyEx(RPC_REG_ROOT, REG_NSI, 0L, KEY_READ,
                             (PHKEY) &RegHandle);
#else
    statusTmp = RegOpenKey(RPC_REG_ROOT, REG_NSI, (PHKEY) &RegHandle);
#endif

    if (statusTmp)
        {
        ClearGlobalMutex();
        return(RPC_S_CALL_FAILED_DNE);
        }

    GetDefaultEntrys((void *) RegHandle);

    ProtoSeq = RegGetString((void *) RegHandle, "Protocol");
    NetworkAddress = RegGetString((void *) RegHandle, "ServerNetWorkAddress");
    Endpoint = RegGetString((void *) RegHandle, "Endpoint");

    status = RpcStringBindingCompose(0, ProtoSeq,
        NetworkAddress, Endpoint, 0, &StringBinding);

#ifdef NTENV

    if (  (NetworkAddress == NULL)
        || (NetworkAddress[0] == '\0')
        || (strcmp ((char *)NetworkAddress, "\\\\.") == 0)
       )
       {
          //We are binding to the local locator..
          //lets start the local locator if not already started

          StartServiceIfNecessary();
       }
#endif

    delete ProtoSeq;
    delete NetworkAddress;
    delete Endpoint;

    statusTmp = RegCloseKey(RegHandle);
    ASSERT(!statusTmp);
#endif

    if (status)
        {
        ClearGlobalMutex();
        return(status);
        }


    status = RpcBindingFromStringBinding(StringBinding, &NsiSvrBinding);

    if (status == RPC_S_OK)
        NsiSvrBindingExport = NsiSvrBinding;

    statusTmp = RpcStringFree(&StringBinding);
    ASSERT(!statusTmp);

    ClearGlobalMutex();

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\client\util.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    util.cxx

Abstract:

    This module contains utility functions used by the NSI client wrappers.

Author:

    Steven Zeck (stevez) 03/27/92

--*/


#include <nsi.h>

#include <memory.h>
#include <string.h>
#include <stdio.h>

#ifndef WIN32

extern "C"
{
int atoi(char *);

void far pascal OutputDebugString(void far *);


void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    size_t cb
    );

void __RPC_API
MIDL_user_free(
    void __RPC_FAR * p
    );
}

#else
#include <stdlib.h>

#endif

RPC_STATUS NsiToRpcStatus[] =
{
    RPC_S_OK,                      // NSI_S_OK
    RPC_S_NO_MORE_BINDINGS,        // NSI_S_NO_MORE_BINDINGS
    RPC_S_INTERFACE_NOT_FOUND,     // NSI_S_INTERFACE_NOT_FOUND
    RPC_S_ENTRY_NOT_FOUND,         // NSI_S_ENTRY_NOT_FOUND
    RPC_S_NAME_SERVICE_UNAVAILABLE,// NSI_S_NAME_SERVICE_UNAVAILABLE
    RPC_S_ACCESS_DENIED,           // NSI_S_NO_NS_PRIVILEGE
    RPC_S_UNSUPPORTED_NAME_SYNTAX, // NSI_S_UNSUPPORTED_NAME_SYNTAX
    RPC_S_NOT_ALL_OBJS_UNEXPORTED, // NSI_S_NOTHING_TO_UNEXPORT
    RPC_S_INVALID_NAME_SYNTAX,     // NSI_S_INVALID_NAME_SYNTAX
    RPC_S_NO_CONTEXT_AVAILABLE,    // NSI_S_INVALID_NS_HANDLE
    RPC_S_OUT_OF_RESOURCES,        // NSI_S_INVALID_OBJECT
    RPC_S_NOT_ALL_OBJS_UNEXPORTED, // NSI_S_NOT_ALL_OBJS_UNEXPORTED
    RPC_S_INVALID_STRING_BINDING,  // NSI_S_INVALID_STRING_BINDING
    RPC_S_INTERNAL_ERROR,          // NSI_S_SOME_OTHER_ERROR
    RPC_S_NOTHING_TO_EXPORT,       // NSI_S_NOTHING_TO_EXPORT
    RPC_S_CANNOT_SUPPORT,          // NSI_S_UNIMPLEMENTED_API
    RPC_S_NOTHING_TO_EXPORT,       // NSI_S_NO_INTERFACES_EXPORTED
    RPC_S_INCOMPLETE_NAME,         // NSI_S_INCOMPLETE_NAME
    RPC_S_INVALID_VERS_OPTION,     // NSI_S_INVALID_VERS_OPTION
    RPC_S_NO_MORE_MEMBERS,         // NSI_S_NO_MORE_MEMBERS
    RPC_S_ENTRY_ALREADY_EXISTS,    // NSI_S_ENTRY_ALREADY_EXISTS
    RPC_S_OUT_OF_MEMORY,           // NSI_S_OUT_OF_MEMORY
    RPC_S_GROUP_MEMBER_NOT_FOUND,  // NSI_S_GROUP_MEMBER_NOT_FOUND
    RPC_S_SERVER_UNAVAILABLE,      // NSI_S_NO_MASTER_LOCATOR
    RPC_S_ENTRY_TYPE_MISMATCH,	   // NSI_S_ENTRY_TYPE_MISMATCH
    RPC_S_NOT_ALL_OBJS_EXPORTED,   // NSI_S_NOT_ALL_OBJS_EXPORTED
    RPC_S_INTERFACE_NOT_EXPORTED,  // NSI_S_INTERFACE_NOT_EXPORTED
    RPC_S_PROFILE_NOT_ADDED,       // NSI_S_PROFILE_NOT_ADDED
    RPC_S_PRF_ELT_NOT_ADDED,       // NSI_S_PRF_ELT_NOT_ADDED
    RPC_S_PRF_ELT_NOT_REMOVED,	   // NSI_S_PRF_ELT_NOT_REMOVED
    RPC_S_GRP_ELT_NOT_ADDED,	   // NSI_S_GRP_ELT_NOT_ADDED
    RPC_S_GRP_ELT_NOT_REMOVED      // NSI_S_GRP_ELT_NOT_REMOVED
};



UNSIGNED16
MapException(
    IN RPC_STATUS Exception
    )
/*++

Routine Description:

    Map a RPC exception to a NSI status code.

Arguments:

    Exception - Stub generated exception code.

Returns:

    NSI status code
--*/
{

#ifdef NTENV

    // If an NT access fault was raised, re-raise it.

    if (Exception == 0xc0000005)
        RpcRaiseException(Exception);
#endif

    switch(Exception)
    {
      case RPC_X_SS_CONTEXT_MISMATCH:
      case RPC_X_SS_IN_NULL_CONTEXT:
      case RPC_S_INVALID_BINDING:
        return(NSI_S_INVALID_NS_HANDLE);

      case RPC_S_OUT_OF_MEMORY:
        return(NSI_S_OUT_OF_MEMORY);

      case RPC_X_ENUM_VALUE_OUT_OF_RANGE:
        return (NSI_S_UNIMPLEMENTED_API);
    }

    return(NSI_S_NAME_SERVICE_UNAVAILABLE);
}


WIDE_STRING::WIDE_STRING(
    IN unsigned char * AsciiString OPTIONAL
    )

/*++

Routine Description:

    Make a UNICODE string from an ASCII string.

Arguments:

    AsciiString - 8 bit string to widen to 16 bits.

Returns:

    String is set to new value.  If there was an allocation error, then
    the value is set to AllocError.

--*/
{
    if (!AsciiString)
        {
        String = 0;
        AllocMode = AllocReference;
        return;
        }

    int Size = (strlen((CONST_CHAR *) AsciiString) + 1) * sizeof(unsigned short);

    if (! (String = (unsigned short *)I_RpcAllocate(Size)))
        {
        AllocMode = AllocError;
        return;
        }

    AllocMode = AllocMemory;

#ifdef NTENV
    AsciiToUnicodeNT(String, AsciiString);
#else
    for (unsigned short *pT = String; *pT++ = *AsciiString++;) ;
#endif

}

#ifndef NTENV

int
UnicodeToAscii(
    unsigned short *UnicodeString
    )
/*++

Routine Description:

    Make a  ASCII string from an UNICODE string.  This is done in
    place so the string becomes ASCII.

Arguments:

    UnicodeString - unicode string to convert

Returns:

    1 if conversion was OK, 0 if there was an error.

--*/
{
    unsigned char * AsciiString;

    for (AsciiString = (unsigned char *) UnicodeString;
         *UnicodeString <= 0xff && *UnicodeString; )

         *AsciiString++ = *UnicodeString++;

    *AsciiString = 0;
    return((*UnicodeString == 0)? RPC_S_OK: RPC_S_OK);
}

#endif


void *
#if defined(WIN32)
__cdecl
#endif
operator new(
        size_t size
        )
{

    return(I_RpcAllocate(size));
}

void
#if defined(WIN32)
__cdecl
#endif
operator delete(
           void * p
           )
{

    I_RpcFree(p);
}


void CallExportInit() {}


unsigned char *
CopyString(
    IN char * String
    )

/*++

Routine Description:

    Copy a string.

Arguments:

    String - to copy

Returns:

    pointer to a copy, Nil if out of memory.

--*/
{
    unsigned char * pReturn;

    if (!String || !( pReturn = new unsigned char [strlen(String)+1]))
        return(0);

    return ((unsigned char *) strcpy((char *) pReturn, (CONST_CHAR *) String));
}


void
GetDefaultEntrys(
    IN void * Key
    )

/*++

Routine Description:

    Get the default Entry name and syntax type form the registry.

Arguments:

    Key - open registry handle

--*/
{
    // While we have the registry open, get the default syntax entrys.

    if (! fSyntaxDefaultsLoaded)
        {
        unsigned char *SyntaxValue;

        if (SyntaxValue = RegGetString(Key, "DefaultSyntax"))
            {
            DefaultSyntax = atoi((char *)SyntaxValue);
            delete SyntaxValue;
            }

        if (SyntaxValue = RegGetString(Key, "DefaultEntry"))
            {
            DefaultName = new WIDE_STRING(SyntaxValue);
            delete SyntaxValue;
            }

        fSyntaxDefaultsLoaded = 1;
        }
}


#if !defined(NTENV) && DBG


void
RtlAssert(
    void * FailedAssertion,
    void * FileName,
    unsigned long LineNumber,
    char * Message
    )
{
    UNUSED(Message);

#if defined(OS212)

    printf("Assert failed %s in %s line %ld\n",
        FailedAssertion, FileName, LineNumber);

#elif defined(WIN)


    char Buffer[300];
    sprintf(Buffer, "Assert failed %s in %s line %ld\n",
        FailedAssertion, FileName, LineNumber);

    OutputDebugString(Buffer);

#endif

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\c\drtc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drtc.cxx
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "drt.h"    // header file generated by MIDL compiler

void __cdecl main(int argc, char **argv)
{
    unsigned char * pszString     = (unsigned char *)"drt";
    WCHAR * pszEntryName            = L"/.:/drtsrv_01";
    WCHAR * pszGrpEntryName1        = L"/.:/drtgrp_01";
    WCHAR * pszPrfEntryName1        = L"/.:/drtprf_01";
    WCHAR * pszStrBinding           = NULL;
    RPC_NS_HANDLE hdrt;
    RPC_BINDING_HANDLE bhdrt;
    RPC_IF_ID          ifid;
    unsigned long fNameSyntaxType = RPC_C_NS_SYNTAX_DEFAULT;
    RPC_STATUS status;
    unsigned long ulCode;
    short fSuccess = 0;
    short fContinue = 1;
    short i;
    WCHAR *pMemberName;
    WCHAR *pAnnotation;
    ULONG dwPriority = 0;

    RpcTryExcept {
        status = RpcNsBindingImportBegin(fNameSyntaxType,
                                         pszEntryName,
                                         drtsrv_01_v1_0_c_ifspec,
                                         NULL,
                                         &hdrt);
        printf("RpcNsBindingImportBegin returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    if ( status != RPC_S_OK )
        fContinue = 0;

    /* The loop is present because the name service may contain "stale" */
    /* and unusable binding handlers.  This is part of the DCE design.  */
    while( fContinue )
    {
        status = RpcNsBindingImportNext(hdrt,
                                        &bhdrt);
        printf("RpcNsBindingImportNext returned 0x%x\n", status);

        if ( (status == RPC_S_NO_MORE_BINDINGS) ||
             (status == RPC_S_NAME_SERVICE_UNAVAILABLE ) )
            break;

        if (status != RPC_S_OK)
            continue;

        RpcBindingToStringBinding( bhdrt, &pszStrBinding );
        printf("StringBinding: %s\n", pszStrBinding );
        RpcStringFree(&pszStrBinding);

        RpcTryExcept {
            printf("Calling remote procedure HelloProc with string %s\n",
                   pszString);
            HelloProc(bhdrt, pszString);
            fContinue = 0;
            fSuccess = 1;
        }
        RpcExcept(1) {
            ulCode = RpcExceptionCode();
            printf("RPC Runtime raised exception 0x%x\n", ulCode);
            status = RpcBindingFree(&bhdrt);
            printf("RpcBindingFree returned 0x%x\n", status);
            fContinue = 1;
        }
        RpcEndExcept

    }

    RpcTryExcept {
        status = RpcNsBindingImportDone(&hdrt);
        printf("RpcNsBindingImportDone returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    if ( fSuccess )
    {
        RpcTryExcept {
            Shutdown(bhdrt);  // Shutdown is a remote procedure
        }
        RpcExcept(1) {
            ulCode = RpcExceptionCode();
            printf("RPC runtime raised exception 0x%x\n", ulCode);
        }
        RpcEndExcept

        status = RpcBindingFree(&bhdrt);
        printf("RpcBindingFree returned 0x%x\n", status);
    }

    exit(0);

}  // end main()


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file drtc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\c\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\dynamic\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\clean\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\c\drtc.orig.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drtc.orig.cxx
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "drt.h"    // header file generated by MIDL compiler

void __cdecl main(int argc, char **argv)
{
    unsigned char * pszString     = (unsigned char *)"drt";
    WCHAR * pszEntryName            = L"/.:/drtsrv_01";
    WCHAR * pszGrpEntryName1        = L"/.:/drtgrp_01";
    WCHAR * pszPrfEntryName1        = L"/.:/drtprf_01";
    WCHAR * pszStrBinding           = NULL;
    RPC_NS_HANDLE hdrt;
    RPC_BINDING_HANDLE bhdrt;
    RPC_IF_ID          ifid;
    unsigned long fNameSyntaxType = RPC_C_NS_SYNTAX_DEFAULT;
    RPC_STATUS status;
    unsigned long ulCode;
    short fSuccess = 0;
    short fContinue = 1;
    short i;
    WCHAR *pMemberName;
    WCHAR *pAnnotation;
    ULONG dwPriority = 0;

    RpcTryExcept {
    status = RpcNsProfileEltInqBegin(
                          fNameSyntaxType,
                          pszPrfEntryName1,
                          RPC_C_PROFILE_ALL_ELT,
                          NULL,
                          0,
                          fNameSyntaxType,
                          NULL,
                          &hdrt
    );
    printf(" RpcNsProfileEltInqBegin returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    RpcTryExcept {
        status = RpcNsProfileEltInqNext(
                          hdrt,
                          &ifid,
                          &pMemberName,
                          &dwPriority,
                          &pAnnotation
        );
        printf("RpcNsProfileEltInqNext returned 0x%x\n", status);
        if (!status)
        {
            wprintf(L"Annotation: %s\n", pAnnotation);
            wprintf(L"MemberName: %s, Priority %d\n", pMemberName, dwPriority);
        }
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    RpcTryExcept {
        status = RpcNsProfileEltInqNext(
                          hdrt,
                          &ifid,
                          &pMemberName,
                          &dwPriority,
                          &pAnnotation
        );
        printf("RpcNsProfileEltInqNext returned 0x%x\n", status);
        if (!status)
        {
            wprintf(L"Annotation: %s\n", pAnnotation);
            wprintf(L"MemberName: %s, Priority %d\n", pMemberName, dwPriority);
        }
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    RpcTryExcept {
        status = RpcNsProfileEltInqDone(
                         &hdrt
        );
        printf("RpcNsProfileEltInqDone returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept


    RpcTryExcept {
    status = RpcNsGroupMbrInqBegin(
                          fNameSyntaxType,
                          pszGrpEntryName1,
                          fNameSyntaxType,
                          &hdrt
            );
    printf(" RpcNsGroupMbrInqBegin returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    *pMemberName = '\0';
    RpcTryExcept {
        status = RpcNsGroupMbrInqNext(
                          hdrt,
                          &pMemberName
        );
        printf("RpcNsGroupMbrInqNext returned 0x%x\n", status);
        if (!status)
        {
            wprintf(L"MemberName: %s\n", pMemberName);
        }
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    RpcTryExcept {
        status = RpcNsGroupMbrInqDone(
                         &hdrt
        );
        printf("RpcNsGroupMbrInqDone returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept



    RpcTryExcept {
        status = RpcNsBindingImportBegin(fNameSyntaxType,
                                         pszGrpEntryName1,
                                         drtsrv_01_v1_0_c_ifspec,
                                         NULL,
                                         &hdrt);
        printf("RpcNsBindingImportBegin returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    if ( status != RPC_S_OK )
        fContinue = 0;

    /* The loop is present because the name service may contain "stale" */
    /* and unusable binding handlers.  This is part of the DCE design.  */
    while( fContinue )
    {
        status = RpcNsBindingImportNext(hdrt,
                                        &bhdrt);
        printf("RpcNsBindingImportNext returned 0x%x\n", status);

        if ( (status == RPC_S_NO_MORE_BINDINGS) ||
             (status == RPC_S_NAME_SERVICE_UNAVAILABLE ) )
            break;

        if (status != RPC_S_OK)
            continue;

        RpcBindingToStringBinding( bhdrt, &pszStrBinding );
        printf("StringBinding: %s\n", pszStrBinding );
        RpcStringFree(&pszStrBinding);

        RpcTryExcept {
            printf("Calling remote procedure HelloProc with string %s\n",
                   pszString);
            HelloProc(bhdrt, pszString);
            fContinue = 0;
            fSuccess = 1;
        }
        RpcExcept(1) {
            ulCode = RpcExceptionCode();
            printf("RPC Runtime raised exception 0x%x\n", ulCode);
            status = RpcBindingFree(&bhdrt);
            printf("RpcBindingFree returned 0x%x\n", status);
            fContinue = 1;
        }
        RpcEndExcept

    }

    RpcTryExcept {
        status = RpcNsBindingImportDone(&hdrt);
        printf("RpcNsBindingImportDone returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    if ( fSuccess )
    {
        RpcTryExcept {
            Shutdown(bhdrt);  // Shutdown is a remote procedure
        }
        RpcExcept(1) {
            ulCode = RpcExceptionCode();
            printf("RPC runtime raised exception 0x%x\n", ulCode);
        }
        RpcEndExcept

        status = RpcBindingFree(&bhdrt);
        printf("RpcBindingFree returned 0x%x\n", status);
    }

    exit(0);

}  // end main()


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file drtc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\idl\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\clean\main.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       main.cxx
//
//--------------------------------------------------------------------------

// test routine for create/delete
#include "rpc.h"                                                               
#include "rpcndr.h"                                                            
#include <stdio.h>

// copied from Catalin's test-------------------
RPC_DISPATCH_TABLE nstest01_v1_0_DispatchTable =
    {
    2,
    nstest01_table
    };

extern RPC_DISPATCH_TABLE nstest01_v1_0_DispatchTable;

static const RPC_SERVER_INTERFACE nstest01___RpcServerInterface =                                                      
    {                                                                                                                  
    sizeof(RPC_SERVER_INTERFACE),                                                                                      
    {{0xdeadbeef,0x6b56,0x11d0,{0xbb,0xd7,0x00,0xc0,0x4f,0xd7,0xcf,0xc9}},{1,0}},                                      
    {{0xdeadbeef,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},                                      
    &nstest01_v1_0_DispatchTable,                                                                                      
    0,                                                                                                                 
    0,                                                                                                                 
    0,                                                                                                                 
    0,                                                                                                                 
    0                                                                                                                  
    };                                                                                                                 

RPC_IF_HANDLE nstest01_v1_0_s_ifspec = (RPC_IF_HANDLE)& nstest01___RpcServerInterface;                                 
//------------------------------------

void __cdecl main(int argc, char *argv[])
{
    RPC_STATUS status;
/*    RPC_IF_HANDLE  intf;
    RPC_BINDING_VECTOR bv;
    UUID_VECTOR ov;
        
			hIfSpec = nstest01_v1_0_s_ifspec;

			status = RpcServerRegisterIf(	nstest01_v1_0_s_ifspec, 
											NULL,   
											NULL);  
			printf("RpcServerRegisterIf returned 0x%x\n", status);
    
			if (MSG_OK != status){
				dwExitCode = (DWORD)status;
				break;
			}
			else
				fRegistered = 1;
		}
		else 
			hIfSpec = NULL;
    
    
		// BindingVec
		if( TEST_OPT_VALID_BIND == pTestOpt->m_nBindingVec ) {
			printf("CallingRpcServerUseProtseq...\n");
			status = RpcServerUseProtseq(   pszProtSeq[pTestOpt->m_nProtSeq], 
											cMaxCalls,    // max concurrent calls
											pszSecurity); // Security descriptor
			printf("RpcServerUseProtseq returned 0x%x\n", status);
			if (MSG_OK != status){
				dwExitCode = ERROR_MSG_USE_PROTSEQ;
				break;
			}
    
			status = RpcServerInqBindings(&pBindingVector);
			printf("RpcServerInqBindings returned 0x%x\n", status);
			if (MSG_OK != status){
				dwExitCode = (DWORD)status;
				break;
			}

			status = RpcServerInqBindings(&pbkBindingVector);
			printf("RpcServerInqBindings returned 0x%x\n", status);
			if (MSG_OK != status){
				dwExitCode = (DWORD)status;
				break;
			}


			if( hIfSpec ){
				status = RpcEpRegister(hIfSpec,
									   pBindingVector,
									   pUuidVect,
									   "");
				printf("RpcEpRegister returned 0x%x\n", status);
				if (MSG_OK != status){
					dwExitCode = (DWORD)status;
					break;
				}
				else
					fEndpoint = 1;
			}
		}
		else
			pBindingVector = NULL;

			
		if( NULL != pBindingVector ){
			status = RpcBindingReset( pBindingVector->BindingH[0] );
			printf("RpcBindingReset returned 0x%x\n", status);
		}


    status = RpcServerRegisterIf(nstest01_v1_0_s_ifspec, NULL, NULL); 

  // too many hoops
  */
    // create an entry
    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Create returned Status = 0x%x\n", status);

    // delete an entry
    status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Delete returned Status = 0x%x\n", status);

    // create an entry
    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Create returned Status = 0x%x\n", status);

    // export to it

    status = RpcNsBindingExport(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08",
                        intf, bv, ov);
    printf("Export returned Status = 0x%x\n", status);

    // delete it
    status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Delete returned Status = 0x%x\n", status);


    // create an entry
    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Create returned Status = 0x%x\n", status);

    // export to the group entry

    // delete the entry
    status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Delete returned Status = 0x%x\n", status);


    // create an entry
    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Create returned Status = 0x%x\n", status);

    // export it as profile entry

    // delete the entry
    status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Delete returned Status = 0x%x\n", status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\clean\testclean.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       testclean.cpp
//
//--------------------------------------------------------------------------

// code to delete the contents of a container
//
//


#ifdef UNICODE
#define _UNICODE 1
#endif

//#include <sys/types.h>
//#include <sys/stat.h>

//
// CRunTime Includes
//

//#include <limits.h>
//#include <io.h>

#include <stdio.h>
#include <objbase.h>
#include <activeds.h>

#include <rpc.h>
#include <ole2.h>

#include "oledb.h"
#include "oledberr.h"
#include "msdadc.h"

#define RETURN_ON_FAILURE(hr)   \
        if (FAILED(hr)) {     \
                return hr;   \
        }

#define _MAX_LENGTH					500
#define MAX_ADS_ENUM				10
#define CLASSNAME                   L"objectClass" 

HRESULT
GetNextEnum(
    IEnumVARIANT * pEnum,
    IADs       **ppADs
    )
{

    HRESULT hr;
    VARIANT VariantArray[MAX_ADS_ENUM];
    IDispatch *pDispatch = NULL;


    hr = ADsEnumerateNext(
                    pEnum,
                    1,
                    VariantArray,
                    NULL
                    );

    if (hr == S_FALSE)
        return hr;

    RETURN_ON_FAILURE(hr);

    pDispatch = VariantArray[0].pdispVal;
    memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);
    hr = pDispatch->QueryInterface(IID_IADs, (void **) ppADs) ;
    pDispatch->Release();
    return(S_OK);
}

HRESULT GetPropertyListAlloc(IADs *pADs, LPOLESTR pszPropName, 
								DWORD *pCount, LPOLESTR **ppList)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;
    VARIANT var;

    *pCount = 0;
    VariantInit(&var);

    hr = pADs->Get(pszPropName, &var);
    
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        return S_OK;
    }

    RETURN_ON_FAILURE(hr);

    if(!((V_VT(&var) &  VT_VARIANT)))
    {
        return(E_FAIL);
    }

    //
    // The following is a work around for the package detail field
    //
    if (!V_ISARRAY(&var))
    {
        (*ppList) = (LPOLESTR *) CoTaskMemAlloc(sizeof(LPOLESTR));
        *pCount = 1;
        *(*ppList) = (LPOLESTR) CoTaskMemAlloc (sizeof(WCHAR) * (wcslen(var.bstrVal)+1));
        wcscpy (*(*ppList), var.bstrVal);
        VariantClear(&var);
        return S_OK;
    }
    
    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) 
    {
        return E_FAIL;
    }
    //
    // Check that there is atleast one element in this array
    //
    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
    {
        return S_OK; // was E_FAIL;
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    RETURN_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    RETURN_ON_FAILURE(hr);

    (*ppList) = (LPOLESTR *) CoTaskMemAlloc(sizeof(LPOLESTR)*(dwSUBound-dwSLBound+1));

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        if (i <= dwSUBound) 
        {
            (*ppList)[*pCount] = (LPOLESTR) CoTaskMemAlloc 
                 (sizeof (WCHAR) * (wcslen(v.bstrVal) + 1));
            wcscpy ((*ppList)[*pCount], v.bstrVal);
            VariantClear(&v);
            (*pCount)++;
        }
    }

    VariantClear(&var);
    return(S_OK);
}

void EnumerateAndDelete(WCHAR *szContainerName)
{
	HRESULT			 hr=S_OK;
	IADsContainer	*pADsContainer=NULL, *pADssubContainer=NULL;
    IEnumVARIANT	*pEnum=NULL;
	IADs			*pADs=NULL;
	WCHAR			*szFullName=NULL, *szName=NULL;
    WCHAR			**ppswClassNameList=NULL;
	ULONG			 sz=0;

	hr = ADsGetObject(szContainerName, IID_IADsContainer, (void **)&pADsContainer);

	if (SUCCEEDED(hr))
		hr = ADsBuildEnumerator(pADsContainer, &pEnum);

	if (SUCCEEDED(hr))
	{
		for (;;)
		{
		    hr = GetNextEnum(pEnum, &pADs);
			if (hr != S_OK)
				break;

			hr = pADs->get_ADsPath(&szFullName);
			if (FAILED(hr))
				continue;

			wprintf(L"Deleting %s \n", szFullName);
			hr = pADs->QueryInterface(IID_IADsContainer, (void **)&pADssubContainer);

			if (SUCCEEDED(hr))
			{
				pADssubContainer->Release();
				EnumerateAndDelete(szFullName);
			}
			
	        hr = GetPropertyListAlloc(pADs, CLASSNAME, &sz, &ppswClassNameList);
			if (FAILED(hr))
				continue;
			
			SysFreeString(szFullName);

			hr = pADs->get_Name(&szName);
			if (FAILED(hr))
				continue;

			pADsContainer->Delete(ppswClassNameList[sz-1], szName);
			
			SysFreeString(szName);
		}
	}
	if (pADsContainer)
		pADsContainer->Release();
	return;
}

void __cdecl main(int argc, char *argv[])
{
	WCHAR szContainer [_MAX_LENGTH+1];

	if (argc != 2)
	{
		printf("Usage: %s <Full ContainerName that has to be emptied>", argv[0]);
		printf("\tThe container itself will remain\n");
		return;
	}

	CoInitialize(NULL);
	MultiByteToWideChar(CP_ACP, 0, argv[1], strlen(argv[1]) + 1, 
                szContainer, _MAX_LENGTH);

	EnumerateAndDelete(szContainer);
	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\s\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\dynamic\exp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       exp.cxx
//
//--------------------------------------------------------------------------

// drt that mainly puts things into the locator
//
//

#include "drt.hxx"

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS             status;
    RPC_BINDING_VECTOR   * pBindingVector = NULL;
    RPC_IF_HANDLE          IfSpec;
    UUID_VECTOR          * objuuid;
    int                    fFailed = 0;

    // form a dynamic endpoint.
    unsigned int    cMinCalls       = 1;
    unsigned int    cMaxCalls       = 20;
    unsigned char * pszSecurity     = NULL;

    status = RpcServerUseAllProtseqs(cMaxCalls, pszSecurity);
    printf("RpcServerUseProtseqs returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcServerInqBindings(&pBindingVector);
    printf("RpcServerInqBindings returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    FormIfHandle(ifid[1], &IfSpec);
    status = RpcNsBindingExport(RPC_C_NS_SYNTAX_DEFAULT,
                                szDynSrvEntryName,
                                IfSpec,
                                pBindingVector,
                                NULL);
    printf("RpcNsBindingExport returned 0x%x\n", status);
    if (status)
        fFailed = 1;

    if (fFailed)
       printf("Export Test FAILED\n");
    else
       printf("Export Test PASSED\n");


    RpcServerListen(10, 20, 0);


}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\export\exp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       exp.cxx
//
//--------------------------------------------------------------------------

// drt that mainly puts things into the locator
//
//

#include "drt.hxx"

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS             status;
    RPC_BINDING_VECTOR   * pBindingVector = NULL;
    RPC_IF_HANDLE          IfSpec;
    UUID_VECTOR          * objuuid;
    RPC_IF_ID              intfid;
    int                    fFailed = 0;

    intfid.Uuid = ifid[0];
    intfid.VersMajor = 42;
    intfid.VersMinor = 42;

    FormBindingVector(Bindings, 1, &pBindingVector);

    FormObjUuid(objid, 2, &objuuid);

    // form a dynamic endpoint.
    unsigned int    cMinCalls       = 1;
    unsigned int    cMaxCalls       = 20;
    unsigned char * pszSecurity     = NULL;

    status = RpcServerUseProtseq(L"ncacn_ip_tcp", cMaxCalls, pszSecurity);
    printf("RpcServerUseProtseqs returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcServerInqBindings(&pBindingVector);
    printf("RpcServerInqBindings returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    FormIfHandle(ifid[1], &IfSpec);

    status = RpcNsBindingExport(RPC_C_NS_SYNTAX_DEFAULT,
                                szDynSrvEntryName,
                                IfSpec,
                                pBindingVector,
                                NULL);
     printf("RpcNsBindingExport returned 0x%x\n", status);
     if (status)
        fFailed = 1;

    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT,
			     szGrpEntryName[0]);
    if (status)
       fFailed = 1;

    printf("RpcNsMgmtEntryCreate returned 0x%x\n", status);

    FormIfHandle(ifid[0], &IfSpec);

    status = RpcNsBindingExport(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szSrvEntryName[0],        // nsi entry name
                                IfSpec,
                                pBindingVector,
                                objuuid);                 // UUID vector

    if (status)
       fFailed = 1;

    printf("RpcNsBindingExport returned 0x%x\n", status);

    status = RpcNsGroupMbrAdd(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[0],
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szSrvEntryName[0]);

    printf("RpcNsGroupMbrAdd 1 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsGroupMbrAdd(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[0],
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szSrvEntryName[1]);

    printf("RpcNsGroupMbrAdd 2 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltAdd(
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szPrfEntryName[0],
                              &intfid,
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[0],
                              1,
                              L"Group Entry 1 Trying to test the length of the string possible");
    printf("RpcNsProfileEltAdd 1 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltAdd(
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szPrfEntryName[0],
                              &intfid,
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[1],
                              2,
                              L"Group Entry 2");
    printf("RpcNsProfileEltAdd 2 returned 0x%x\n", status);
    if (status)
       fFailed = 1;



    if (fFailed)
       printf("Export Test FAILED\n");
    else
       printf("Export Test PASSED\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\inc\drtcom.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drtcom.cxx
//
//--------------------------------------------------------------------------

// the common functions req'd by more than 1 exe in this drts

#include "rpc.h"
#include "rpcnsi.h"
#include "stdio.h"
#include "stdlib.h"

WCHAR *ep[] =       { L"1025",
		      L"1026"
		    };

void FormIfHandle(GUID ifid, RPC_IF_HANDLE *IfSpec)
{
     RPC_SERVER_INTERFACE  *intf = new RPC_SERVER_INTERFACE;
     RPC_DISPATCH_TABLE    *pdispatch = new RPC_DISPATCH_TABLE;
     RPC_DISPATCH_FUNCTION *pfn = new RPC_DISPATCH_FUNCTION;

     intf->Length = sizeof(RPC_SERVER_INTERFACE);

     (intf->InterfaceId).SyntaxGUID = ifid;
     (intf->InterfaceId).SyntaxVersion.MajorVersion = 1;
     (intf->InterfaceId).SyntaxVersion.MinorVersion = 0;

     (intf->TransferSyntax).SyntaxGUID = ifid;
     (intf->TransferSyntax).SyntaxVersion.MajorVersion = 1;
     (intf->TransferSyntax).SyntaxVersion.MinorVersion = 0;

     intf->RpcProtseqEndpointCount = 0;
     intf->RpcProtseqEndpoint = NULL;
     intf->InterpreterInfo = NULL;
     intf->Flags = 0;

     pfn[0] = NULL;

     pdispatch->DispatchTableCount = 1;
     pdispatch->DispatchTable = pfn;
     pdispatch->Reserved = 0;

     intf->DispatchTable = pdispatch; // &m_DispatchTable;

     *IfSpec = (RPC_IF_HANDLE)intf;
}

void FormBindingVector(WCHAR **Binding, ULONG num, RPC_BINDING_VECTOR **BindVec)
{
    ULONG i;
    RPC_BINDING_HANDLE *pBindHandle;
    RPC_STATUS		status = 0;

//    RpcStringBindingCompose(NULL, L"", L"0.0.0.0",
    for (i = 0; i < num; i++) {
       status = RpcServerUseProtseqEp(Binding[i], 20, ep[i], NULL);
    }

    status = RpcServerInqBindings(BindVec);
}

void FormObjUuid(GUID *pguid, ULONG num, UUID_VECTOR **objuuid)
{
    ULONG i;
    *objuuid = (UUID_VECTOR *)malloc(sizeof(ULONG)+sizeof(UUID *)*num);
    (*objuuid)->Count = num;

    for (i = 0; i < num; i++) {
       (*objuuid)->Uuid[i] = pguid+i;
    }
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\s\drts.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drts.cxx
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "drt.h"   // header file generated by MIDL compiler

void __cdecl main(int argc, char * argv[])
{
    RPC_STATUS status;
    RPC_BINDING_VECTOR * pBindingVector = NULL;
    WCHAR * pszEntryName            = L"/.:/drtsrv_01";
    WCHAR * pszGrpEntryName1        = L"/.:/drtgrp_01";
    WCHAR * pszPrfEntryName1        = L"/.:/drtprf_01";
    unsigned char * pszSecurity     = NULL;
    unsigned int    cMinCalls       = 1;
    unsigned int    cMaxCalls       = 20;
    unsigned int    fDontWait       = 0;
    unsigned int    fNameSyntaxType = RPC_C_NS_SYNTAX_DEFAULT;
    unsigned int    fRegistered     = 0;
    unsigned int    fEndpoint       = 0;
    unsigned int    fExported       = 0;
      // abcdefab-abcd-abcd-abcd-abcdefabcdef
    RPC_IF_ID       ifid            = {{ 0xabcdefab, 0xabcd, 0xabcd, { 0xab, 0xcd, 0xab, 0xcd, 0xef, 0xab, 0xcd, 0xef } },
                                      1, 0};
    int             i;

    printf("CallingRpcServerUseAllProtseqs...\n");

    status = RpcServerUseAllProtseqs(cMaxCalls,     // max concurrent calls
                                     pszSecurity);  // Security descriptor
    printf("RpcServerUseAllProtseqs returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }

    status = RpcServerRegisterIf(drtsrv_01_v1_0_s_ifspec, // interface to register
                                 NULL,                    // MgrTypeUuid
                                 NULL);                   // MgrEpv; null means use default
    printf("RpcServerRegisterIf returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }
    else
        fRegistered = 1;

    status = RpcServerInqBindings(&pBindingVector);
    printf("RpcServerInqBindings returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }

    status = RpcEpRegister(drtsrv_01_v1_0_s_ifspec,
                           pBindingVector,
                           NULL,
                           L"");
    printf("RpcEpRegister returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }
    else
        fEndpoint = 1;

     status = RpcNsBindingExport(fNameSyntaxType,  // name syntax type
				 pszEntryName,     // nsi entry name
				 drtsrv_01_v1_0_s_ifspec,
				 pBindingVector,   // set in previous call
				 NULL);            // UUID vector
     printf("RpcNsBindingExport returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }
    else
        fExported = 1;


    printf("Calling RpcServerListen: Case 1:\n");
    status = RpcServerListen(cMinCalls,
                             cMaxCalls,
                             fDontWait);  // wait flag
    printf("RpcServerListen returned: 0x%x\n", status);
    if (status) {
        goto cleanup;
    }

    if (fDontWait) {
        printf("Calling RpcMgmtWaitServerListen\n");
        status = RpcMgmtWaitServerListen();  //  wait operation
        printf("RpcMgmtWaitServerListen returned: 0x%x\n", status);
    }

  cleanup:

    if ( fExported )
    {
        status = RpcNsBindingUnexport(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                       pszEntryName,            // nsi entry name
                                       drtsrv_01_v1_0_s_ifspec,
                                       NULL);                   // UUID vector
        printf( "RpcNsBindingUnexport returned 0x%x\n", status);
    }


    if ( fEndpoint )
    {
        status = RpcEpUnregister(drtsrv_01_v1_0_s_ifspec,
                                  pBindingVector,
                                  NULL);
        printf( "RpcEpUnregister returned 0x%x\n", status);
    }

    if ( pBindingVector )
    {
        status = RpcBindingVectorFree(&pBindingVector);
        printf( "RpcBindingVectorFree returned 0x%x\n", status);
    }

    if ( fRegistered )
    {
        status = RpcServerUnregisterIf(drtsrv_01_v1_0_s_ifspec, // interface to register
                                       NULL,   // MgrTypeUuid
                                       1);     // wait for outstanding calls
        printf( "RpcServerUnregisterIf returned 0x%x\n", status);
    }


}  // end main()



/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file drts.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\s\drtp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drtp.cxx
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "drt.h"    // header file generated by MIDL compiler

void HelloProc(handle_t hHello, unsigned char *pszString)
{
    printf("%s\n", pszString);
    return;
}

void Shutdown(handle_t hHello)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtIsServerListening\n");
    status = RpcMgmtIsServerListening(NULL);
    printf("RpcMgmtIsServerListening returned: 0x%x\n", status);

    if ( status == RPC_S_OK )
    {
        printf("Calling RpcMgmtStopServerListening\n");
        status = RpcMgmtStopServerListening(NULL);
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
    }

}

/* end file drtp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\lookup\lkp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lkp.cxx
//
//--------------------------------------------------------------------------

// drt that tries to lookup the various things.

#include "drt.hxx"

RPC_STATUS LookupCountAndPrint(RPC_NS_HANDLE NsHandle, int exp)
{
    int 		   i=0;
    RPC_STATUS 		   status = 0;
    RPC_BINDING_VECTOR   * pBindingVec;
    WCHAR		 * szBinding;

    for (;!status;) {
       status = RpcNsBindingLookupNext(
				  NsHandle,
				  &pBindingVec
				  );
       printf("RpcNsBindingLookupNext returned 0x%x\n", status);

       if (!status) {
	  status = RpcBindingToStringBinding(pBindingVec->BindingH[0], &szBinding);
	  i++;
	  printf("%d. Binding = \"%S\"\n", i, szBinding);
       }
    }
    if (i != exp)
       return 1;
    return 0;
}

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS             status;
    RPC_NS_HANDLE          NsHandle;
    WCHAR                * Annotation, *MemberName;
    UUID_VECTOR		 * objuuid = NULL;
    RPC_IF_HANDLE          IfSpec;
    RPC_IF_ID		   ifidgot;
    DWORD		   Priority;
    int			   fFailed = 0;
    UUID		   uuidfound;

    FormObjUuid(objid, 1, &objuuid);

    FormIfHandle(ifid[0], &IfSpec);

    status = RpcNsMgmtSetExpAge(1);

    printf("RpcNsMgmtSetExpAge returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    // no interface, no objuuid
    printf("**Test: Entry Name, No intf, No objuuid\n");
    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szSrvEntryName[0],        // nsi entry name
                                NULL,
                                NULL,
                                1,
                				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 2);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    // 1 obj uuid
    printf("**Test: Entry Name, No intf, 1 objuuid\n");
    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szSrvEntryName[0],        // nsi entry name
                                NULL,
                                objid,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 1);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    printf("**Test: No Entry Name, 1 intf, No objuuid\n");
    // Null entry name, 1 intf, no obj uuid
    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                NULL,        // nsi entry name
                                IfSpec,
                                NULL,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 2);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    printf("**Test: Enumerating Profiles\n");
    status = RpcNsProfileEltInqBegin(
				    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				    szPrfEntryName[0],
				    RPC_C_PROFILE_ALL_ELTS,
				    NULL,
				    RPC_C_VERS_ALL,
				    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				    NULL,
				    &NsHandle);
    printf("RpcNsProfileEltInqBegin returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltInqNext(
				    NsHandle,
				    &ifidgot,
				    &MemberName,
				    &Priority,
				    &Annotation);
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    printf("MemberName = \"%S\", Priority = %d, Annotation = \"%S\"\n", MemberName, Priority,
				       Annotation);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltInqNext(
				    NsHandle,
				    &ifidgot,
				    &MemberName,
				    &Priority,
				    &Annotation);
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    printf("MemberName = \"%S\", Priority = %d, Annotation = \"%S\"\n", MemberName, Priority,
				       Annotation);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltInqNext(
				    NsHandle,
				    &ifidgot,
				    &MemberName,
				    &Priority,
				    &Annotation);
    printf("RpcNsProfileEltInqNext returned 0x%x\n", status);
    if (!status)
       fFailed = 1;

    status = RpcNsProfileEltInqDone(&NsHandle);
    printf("RpcNsProfileEltInqDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    printf("**Test: Enumerating Groups\n");

    status = RpcNsGroupMbrInqBegin(
				    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				    szGrpEntryName[0],
				    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				    &NsHandle);
    printf("RpcNsProfileEltInqBegin returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsGroupMbrInqNext(
			     	 NsHandle,
    				 &MemberName
	    			 );
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    printf("MemberName = \"%S\"\n", MemberName);
    if (status)
       fFailed = 1;

    status = RpcNsGroupMbrInqNext(
			     	 NsHandle,
				 &MemberName
				 );
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    printf("MemberName = \"%S\"\n", MemberName);

    if (status)
       fFailed = 1;

    status = RpcNsGroupMbrInqNext(
			     	 NsHandle,
				 &MemberName
				 );
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    if (!status)
       fFailed = 1;

    status = RpcNsGroupMbrInqDone(&NsHandle);
    printf("RpcNsProfileEltInqDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    printf("**Test: Lookup using Groups\n");
    printf("**Test: Entry Name, No intf, No objuuid\n");

    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szGrpEntryName[0],        // nsi entry name
                                NULL,
                                NULL,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 2);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;


    printf("**Test: Lookup using Profiles\n");
    printf("**Test: Entry Name, No intf, No objuuid\n");
    status = RpcNsBindingLookupBegin(
			        RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				szPrfEntryName[0],        // nsi entry name
                                NULL,
                                NULL,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 2);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;


    printf("**Test: Object Inquiry\n");
    printf("**Test: Entry Name\n");
    status = RpcNsEntryObjectInqBegin(
				RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				szSrvEntryName[0],        // nsi entry name
				&NsHandle);

    printf("RpcNsEntryObjectInqBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsEntryObjectInqNext(NsHandle, &uuidfound);
    printf("RpcNsEntryObjectInqNext returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsEntryObjectInqNext(NsHandle, &uuidfound);
    printf("RpcNsEntryObjectInqNext returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsEntryObjectInqNext(NsHandle, &uuidfound);
    printf("RpcNsEntryObjectInqNext returned 0x%x\n", status);
    if (!status)
       fFailed = 1;

    status = RpcNsEntryObjectInqDone(&NsHandle);
    printf("RpcNsEntryObjectInqDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    // getting the dynamic endpoint
    printf("**Test: Dyn Entry Name, No intf, No objuuid\n");
    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szDynSrvEntryName,        // nsi entry name
                                NULL,
                                NULL,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 1);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    if (fFailed)
       printf("Lookup tests FAILED!!\n");
    else
       printf("Lookup tests PASSED!!\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\drt\unexport\unexp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       unexp.cxx
//
//--------------------------------------------------------------------------

// drt that cleans up the entries
//
//

#include "drt.hxx"

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS             status;
    RPC_IF_HANDLE          IfSpec;
    UUID_VECTOR         *  objuuid = NULL;
    RPC_IF_ID              intfid;
    int			   fFailed = 0;

    intfid.Uuid = ifid[0];
    intfid.VersMajor = 42;
    intfid.VersMinor = 42;

    FormIfHandle(ifid[0], &IfSpec);

    FormObjUuid(objid, 2, &objuuid);

    status = RpcNsBindingUnexport(
				RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szSrvEntryName[0],        // nsi entry name
                                IfSpec,
                                objuuid);                 // UUID vector
    printf("RpcNsBindingUnexport returned 0x%x\n", status);
    if (status)
       fFailed = 1;

//    status = RpcNsGroupMbrRemove(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
//                              szGrpEntryName[0],
//                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
//                              szSrvEntryName[0]);

//    printf("RpcNsGroupMbrRemove 1 returned 0x%x\n", status);
//    if (status)
//       fFailed = 1;

    status = RpcNsGroupMbrRemove(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[0],
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szSrvEntryName[1]);

    printf("RpcNsGroupMbrRemove 2 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

//    status = RpcNsProfileEltRemove(
//                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
//                              szPrfEntryName[0],
//                              &intfid,
//                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
//                              szGrpEntryName[0]);
//    printf("RpcNsProfileEltRemove 1 returned 0x%x\n", status);
//    if (status)
//       fFailed = 1;

    status = RpcNsProfileEltRemove(
    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szPrfEntryName[0],
                              &intfid,
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[1]);
    printf("RpcNsProfileEltRemove 2 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsMgmtEntryDelete(
			      RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
			      szSrvEntryName[0]);
    printf("RpcNsMgmtEntryDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsMgmtEntryDelete(
			      RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
			      szPrfEntryName[0]);
    printf("RpcNsMgmtEntryDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsMgmtEntryDelete(
			      RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
			      szGrpEntryName[0]);
    printf("RpcNsMgmtEntryDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;

/*
    status = RpcNsProfileDelete(
				 RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				 szPrfEntryName[0]);
    printf("RpcNsProfileDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsGroupDelete(
				 RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				 szGrpEntryName[0]);
    printf("RpcNsGroupDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;
*/

    status = RpcNsMgmtEntryDelete(
			      RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
			      szDynSrvEntryName);
    printf("RpcNsMgmtEntryDelete Dyn entryname returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    if (fFailed)
       printf("Export Test FAILED\n");
    else
       printf("Export Test PASSED\n");

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\brodcast.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    brodcast.cxx

Abstract:

   This file contains the code for all mailslot activity relating to
   binding handle queries-- both outgoing and incoming ones.

Things to improve in future revisions:

  1.  CBindingVector::msriList

  2.  formQueryPacket

Author:

    Satish Thatte (SatishT) 08/15/95  Created all the code below except where
                                      otherwise indicated.

--*/


/* NOTE: Compatibility Issue: see below for meaning of END_FLAG_SIZE */

#include <locator.hxx>

const int END_FLAG_SIZE = 4;


/****************  Utilities for Broadcast **********************/


/* a little macro exclusively for use in UnmarshallBroadcastReplyItem */

#define unBufferIt(source)                                            \
    lBufferSize -= advance;                                           \
    if (lBufferSize < 0) {                                            \
                StatusCode = NSI_S_UNMARSHALL_UNSUCCESSFUL;           \
                return;                                               \
    }                                                                 \
    if (source) memcpy((char*) source, pcBuffer, advance);            \
    pcBuffer += advance;


// keeping track of history of broadcast requests.

BOOL
Locator::broadcastCleared(
    QueryPacket& NetRequest,
    ULONG ulCacheTolerance
    )
/*++
Member Description:

    Given a query packet and a tolerance for staleness, decide if a broadcast
    should be made based on recent history of broadcasts.

Arguments:

    NetRequest - the request packet

    ulCacheTolerance - tolerance for staleness in seconds

Returns:

    TRUE - if broadcast should be made

    FALSE - if broadcast is unnecessary

--*/
{
    SimpleCriticalSection me(PCSBroadcastHistory);

    TSLLBroadcastQPIter histIter(*psllBroadcastHistory);

    for (CBroadcastQueryPacket *pbqp = histIter.next(); pbqp; pbqp = histIter.next())
    {
        // if the history is too stale for the global cache retirement age, remove it.

        if (!pbqp->isCurrent(ulMaxCacheAge)) {
            psllBroadcastHistory->remove(pbqp);
            delete pbqp;
        }

        // otherwise, in the subsumes check, use the requested cache retirement age

        else if (pbqp->subsumes(NetRequest,ulCacheTolerance)) {
            return FALSE;
        }
    }

    return TRUE;
}

CRemoteLookupHandle *
Locator::NetLookup(
        UNSIGNED32           EntryNameSyntax,
        STRING_T             EntryName,
        CGUIDVersion    *    pGVinterface,
        CGUIDVersion    *    pGVsyntax,
        CGUID           *    pIDobject,
        unsigned long        ulVectorSize,
        unsigned long        ulCacheAge
        )
/*++
Member Description:

    Use the given lookup parameters to perform a lookup from the
    network -- either via a master locator or via broadcast depending
    on the status of the current locator and the status of the master locator(s).

    Since net lookup is now "lazy" (net is accessed only if needed), we need
    a lazy handle which initializes itself according to the old pattern of
    "use master if you can, broadcast if you must".

Arguments:

    EntryNameSyntax        - Name syntax, optional

    EntryName              - (raw) Name of the entry to look up, optional

    pGVinterface           - (wrapped) Interface to look up, optional

    pGVsyntax              - (wrapped) Transfer syntax, optional

    pIDobject              - (wrapped) Object UUID, optional

    ulVectorSize           - Max size of vectors of binding handles, 0 for default

    ulCacheAge             - acceptable max age of cached information from a master

Returns:

    A lookup handle based on the info retrieved.

--*/
{

    return new CNetLookupHandle(
                    EntryNameSyntax,
                    EntryName,
                    pGVinterface,
                    pGVsyntax,
                    pIDobject,
                    ulVectorSize,
                    ulCacheAge
                    );

}


CObjectInqHandle *
Locator::NetObjectInquiry(
        UNSIGNED32 EntryNameSyntax,
        STRING_T EntryName
        )
/*++
Member Description:

    Perform an inquiry on the network for object UUIDs registered in the
    given entry.   The network is searched either via a master locator or via
    broadcast depending on the status of the current locator and the status
    of the master locator(s).

Arguments:

    EntryNameSyntax        - Name syntax, optional

    EntryName              - (raw) Name of the entry to look up, optional

Returns:

    A handle based on the info retrieved.

--*/
{
    return new CNetObjectInqHandle(
                            EntryName,
                            ulMaxCacheAge
                            );

}

void
Locator::UpdateCache(
            STRING_T                 entry_name,
            UNSIGNED32               entry_name_syntax,
            RPC_SYNTAX_IDENTIFIER    rsiInterface,
            RPC_SYNTAX_IDENTIFIER    rsiTransferSyntax,
            STRING_T                 string,
            NSI_UUID_VECTOR_P_T      pUuidVector,
            TSSLEntryList        *   psslTempNetCache
            )
/*++
Member Description:

    Update the locator's cache with information retrieved from the net
    (either from a master locator or from a broadcast).  Also update the
    temporary cache (last parameter) which holds only new information
    for use in the remote handle based on the current NetLookup.
    The use of this temporary cache avoids duplication in the information
    returned to the client.

Arguments:

    entry_name          - (raw) name of the entry being updated

    entry_name_syntax   - name syntax

    rsiInterface        - (raw) interface

    rsiTransferSyntax   - (raw) transfer syntax

    string              - (raw) string binding handle

    pUuidVector         - vector of object UUIDs to add to entry

    psslTempNetCache    - a temporary cache of entries for use in a remote handle

--*/
{
    NSI_SERVER_BINDING_VECTOR_T BindingVector;
    BindingVector.count = 1;
    BindingVector.string[0] = string;

    NSI_INTERFACE_ID_T Interface;
    Interface.Interface = rsiInterface;
    Interface.TransferSyntax = rsiTransferSyntax;

    /* first we update the locator's cache */

    DBGOUT(BROADCAST, "\tUpdating the cache entry for Entry " << entry_name << "\n");
    DBGOUT(BROADCAST, "\t\tWith Interface: " << &rsiInterface.SyntaxGUID << "\n");
    DBGOUT(BROADCAST, "\t\tWith Binding Vector: " << &BindingVector << "\n");
    DBGOUT(BROADCAST, "\t\tAnd Object Vector: " << pUuidVector << "\n\n");

    if ((    nsi_binding_export(
                        entry_name_syntax,
                        entry_name,
                        &Interface,
                        &BindingVector,
                        pUuidVector,
                        NonLocal
                        )
        ) || (IsNilIfId(&(Interface.Interface))))
    {

    /* if there was something new, we update the temporary cache for the net handle.
       The constructor for CEntryName used below makes the name local if possible. */

        CStringW * pswName = new CStringW(CEntryName(entry_name));

        CServerEntry * pTempCacheEntry = (CServerEntry*)
                                         psslTempNetCache->find(pswName);

        delete pswName;

        if (!pTempCacheEntry) {

            pTempCacheEntry = new CServerEntry(entry_name);
            psslTempNetCache->insert(pTempCacheEntry);
        }

        pTempCacheEntry->add_to_entry(
                        &Interface,
                        &BindingVector,
                        pUuidVector,
                        pCacheInterfaceIndex,
                        TRUE
                        );

        CEntry *pEntry = GetEntryFromCache(
                                entry_name_syntax,
                                entry_name
                                );

        if ((pEntry) && (pEntry->getType() == FullServerEntryType))
        {
            CServerEntry *pLocal = ((CFullServerEntry *)pEntry)->getLocal();
            CServerEntry *pNonLocal = ((CFullServerEntry *)pEntry)->getNonLocal();

            // this is required b'cos the locator that contacted the
            // PDC itself responds to broadcast request and hence there
            // is a necessity to remove this info from the results got
            // back.

            if (pNonLocal->purgeCommonEntries(pLocal))
                        // all the bindings has been purged.
                ((CNonLocalServerEntry *)pNonLocal)->fHasNonLocalInfo = FALSE;
            if (pTempCacheEntry->purgeCommonEntries(pLocal))
            {
                psslTempNetCache->remove(pTempCacheEntry);
                delete pTempCacheEntry;
            }
        }
    }
}


void
UnmarshallBroadcastReplyItem(
            TSSLEntryList *psslCache,
            STRING_T szEntryDomain,
            char * &pcBuffer,
            long& lBufferSize,
            ULONG& StatusCode
            )
/*++

Routine Description:

    Unmarshall an item from the broadcast reply buffer.  If a well-formed item
    is found, the locator's cache and the temporary given cache (first argument)
    is updated and the buffer size is decreased accordingly.  A reply packet
    contains the name of the replying locator's domain, which is used as the
    domain of the entry unless otherwise specified in the name itself.

    If the unmarshalling is unsuccessful, this is indicated in the status code returned.

Arguments:

    psslCache        - temporary cache for remote handle

    szEntryDomain    - domain of replying locator

    pcBuffer         - reply buffer

    lBufferSize      - reduced buffer size returned here

    StatusCode       - status of unmarshalling attempt returned here

Returned Status:

    NSI_S_OK, NSI_OUT_OF_MEMORY, NSI_S_UNMARSHALL_UNSUCCESSFUL,
    NSI_S_UNSUPPORTED_BUFFER_TYPE

Remarks:

   The following function has "return"s inside a __try block.  Since this whole code
   is slated for removal after a couple of updates, I have left them in.  They could
   be easily replaced with "goto"s if necessary.

--*/
{
    StatusCode = NSI_S_OK;
    long advance;
    RPC_SYNTAX_IDENTIFIER Interface;
    RPC_SYNTAX_IDENTIFIER XferSyntax;
    STRING_T binding;
    STRING_T entryName = NULL;

    if (pcBuffer) {
        DBGOUT(BROADCAST, "Received:: " << pcBuffer << "\n");
    }
    else {
    	DBGOUT(BROADCAST, "\tThrowing the reply element because it is empty" << "\n");        
        return;
    }

    advance = sizeof(fixed_part_of_reply);
    fixed_part_of_reply fpr;
    unBufferIt(&fpr);

    if (fpr.type != MailslotServerEntryType) {
        StatusCode = NSI_S_UNSUPPORTED_BUFFER_TYPE;
    	DBGOUT(BROADCAST, "\tThrowing the reply element" << "\n");        
        return;
    }

    Interface = fpr.Interface;
    XferSyntax = fpr.XferSyntax;

    advance = fpr.EntryNameLength * sizeof(WCHAR);

    entryName = (WCHAR*) pcBuffer;

    unBufferIt(NULL);

    if (entryName[fpr.EntryNameLength-1] != L'\0') {
        StatusCode = NSI_S_UNMARSHALL_UNSUCCESSFUL;
	DBGOUT(BROADCAST, "\tThrowing the reply element b'cos the entry name sizes don't match" << "\n");
	DBGOUT(BROADCAST, "\tEntry Name " << entryName << "length = " << fpr.EntryNameLength << "\n");      
        return;
    }

    advance = sizeof(UNSIGNED32);
    UNSIGNED32 objVectorSize;
    unBufferIt(&objVectorSize);

    if (objVectorSize > NET_REPLY_BUFFER_SIZE) { // fix for bug #180095
        StatusCode = NSI_S_UNMARSHALL_UNSUCCESSFUL;
	DBGOUT(BROADCAST, "\tThrowing the reply element b'cos number of objuuids are too much" << "\n");      
	DBGOUT(BROADCAST, "\tObj Vector Size " << objVectorSize << "\n");      
        return; 
    }        
    
    GUID * guidVector = NULL;
    NSI_UUID_VECTOR_T * pUuidVector = NULL;
                
    CStringW *pswEntry = NULL, *pswDomain = NULL;
    CEntryName * penTempName = NULL;
        
    __try {
        guidVector = new GUID[objVectorSize];

        pUuidVector = (NSI_UUID_VECTOR_T *)
            new char [
            sizeof(UNSIGNED32) +
            sizeof(NSI_UUID_P_T) * objVectorSize
            ];

        pUuidVector->count = objVectorSize;
        
        advance = sizeof(DWORD);    // this is a useless pointer part
        lBufferSize -= advance;     // therefore we don't unmarshall it
        pcBuffer += advance;        // we just account for its size

        advance = sizeof(GUID);

        for (ULONG i = 0; i < objVectorSize; i++) {
            pUuidVector->uuid[i] = &(guidVector[i]);
            unBufferIt(&(guidVector[i]));
        }

        advance = fpr.BindingLength * sizeof(WCHAR);
        binding = (WCHAR*) pcBuffer;
        if (binding[fpr.BindingLength-1] != L'\0') {
            StatusCode = NSI_S_UNMARSHALL_UNSUCCESSFUL;
  	    DBGOUT(BROADCAST, "\tThrowing the reply element b'cos bindings do not match the size" << "\n");      
	    DBGOUT(BROADCAST, "\tBinding " << binding << "length = " << fpr.BindingLength << "\n");      
            return;
        }
        unBufferIt(NULL);

        parseEntryName(entryName,pswDomain,pswEntry);

        if (!pswDomain && szEntryDomain)    // if name has no domain then use the
                                            // domain of origin in forming name

            penTempName = new CEntryName(szEntryDomain,*pswEntry);

        else  penTempName = new CEntryName(entryName);

        myRpcLocator->UpdateCache(
                              *penTempName,
                              RPC_C_NS_SYNTAX_DCE,
                              Interface,
                              XferSyntax,
                              binding,
                              pUuidVector,
                              psslCache
                              );
              /* first update the central cache and, if there is anything new,
                 also update the temporary cache in psslCache
              */

    }
    __finally {
        delete [] pUuidVector;
        delete [] guidVector;
        delete pswDomain;
        delete pswEntry;
        delete penTempName;
    }
}


BOOL
CBroadcastQueryPacket::subsumes(QueryPacket& NewQuery, ULONG tolerance) {

    // too stale?

    if (!isCurrent(tolerance)) return FALSE;

    CStringW OtherEntry(NewQuery.EntryName);

    // incompatible entry name involved?

    if (!(swEntryName == OtherEntry) && (swEntryName.length() > 0))
        return FALSE;

    CGUID OtherObject(NewQuery.Object);

    // incompatible object involved?

    if (!(OtherObject == Object) && !Object.IsNil()) return FALSE;

    CGUIDVersion OtherInterface(NewQuery.Interface);
    CGUID myGUID(Interface.myIdAndVersion().SyntaxGUID);

    // incompatible interface involved?

    if (
        !OtherInterface.isMatching(Interface,RPC_C_VERS_COMPATIBLE) &&
        !myGUID.IsNil()
       )
       return FALSE;

    // we ran the gauntlet successfully -- stop the broadcast!

    return TRUE;

}


void
formQueryPacket(
            CEntryName        *    penEntryName,
            CGUIDVersion      *    pGVInterface,
            CGUID             *    pIDobject,
            QueryPacket       &    NetRequest
            )
/*++

Routine Description:

    Forms a query packet given the items in it.

Arguments:

    penEntryName    - (wrapped) entry name

    pGVInterface    - (wrapped) interface UUID and version

    pIDobject       - (wrapped) object UUID

    NetRequest      - The request packet is returned here

Remarks:

  BUGBUG:

       We used to perform some shenanigans with interface and object settings
       in the QueryPacket to allow us to correctly report NSI_S_ENTRY_NOT_FOUND
       when appropriate.  Specifically, using wildcards for interface and object
       if the entry name was non null so as to gather all information about the
       specific entry from the net.

       In order to interoperate with the old locator, these shenanigans have
       been suspended, and we will currently return NSI_S_ENTRY_NOT_FOUND
       spuriously when no information is received from the net in response to
       a specific rather than a wildcard query, just like the old locator
       (so that the old tests pass when they expect NSI_S_ENTRY_NOT_FOUND !!).

       The problem with the old locator is that it carefully avoids sending
       duplicate binding handles, so if a null interface is given in
       the broadcast query, it naturally assumes that we don't care about the
       interface, and may omit info about some interfaces unless they have
       distinct binding handles associated with them.

--*/
{

    memset(&(NetRequest.Object),0,sizeof(NetRequest.Object));
    memset(&(NetRequest.Interface),0,sizeof(NetRequest.Interface));

     if (penEntryName) // specific entry - we used to leave wildcards for interface and object
        wcscpy(NetRequest.EntryName,*penEntryName);

    else             // otherwise, use real interface and object if given
        memset(&(NetRequest.EntryName),0,sizeof(WCHAR)*MAX_ENTRY_NAME_LENGTH);

    // NOTE:  compatibility removal: the following two lines were conditional
    //  on the else before the "shenanigans" were eliminated

    if (pIDobject) NetRequest.Object = pIDobject->myGUID();
    if (pGVInterface) NetRequest.Interface = *pGVInterface;
}


TSSLEntryList *
getBroadcastResults(
            ULONG                 cacheTolerance,
            CEntryName       *    penEntryName,
            CGUIDVersion     *    pGVInterface,
            CGUID            *    pIDobject,
            ULONG            &    StatusCode
            )
/*++

Routine Description:

    Broadcasts for the requested binding handles.

Arguments:

    cacheTolerance  - the staleness tolerance associated with this request,
                      used in deciding whether to broadcast at all

    penEntryName    - (wrapped) entry name

    pGVInterface    - (wrapped) interface UUID and version

    pIDobject       - (wrapped) object UUID

    StatusCode      - The status of the broadcast attempt is returned here

Returns:

    A temporary cache of entries containing the new information.

Remarks:

       A broadcast is made only if a subsuming broadcast has not been made within
       the staleness limit specified by the parameter cacheTolerance.  Only one
       broadcast is allowed at a time, since there is only one mailslot for replies.

--*/
{
    char * pcBuffer;
    ULONG waitCur = INITIAL_MAILSLOT_READ_WAIT; // current wait time for replies
    STRING_T szEntryDomain;

    READ_MAIL_SLOT *hMailslotForReplies = myRpcLocator->hMailslotForReplies;
    long cbRead;

    QueryReply NetReply;

    if (!hMailslotForReplies) {
        StatusCode = NSI_S_ENTRY_NOT_FOUND;
        return NULL;
    }

    QueryPacket NetRequest;

    wcscpy(NetRequest.WkstaName, TEXT("\\\\"));
    wcscpy(NetRequest.WkstaName + 2, *myRpcLocator->getComputerName());

    formQueryPacket(penEntryName,pGVInterface,pIDobject,NetRequest);

    // now get this broadcast cleared -- make sure it is not redundant

    if (!myRpcLocator->broadcastCleared(NetRequest,cacheTolerance))
    {
        if (penEntryName)
        {
            DBGOUT(BROADCAST, "\nBroadcast request denied for " << *penEntryName << "\n"
                << "Interface = " << &NetRequest.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetRequest.Object << "\n\n");
        }
        else
        {
            DBGOUT(BROADCAST, "\nBroadcast request denied for NULL entry\n"
                << "Interface = " << &NetRequest.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetRequest.Object << "\n\n");
        }
        return NULL;
    }
    else
    {
        if (penEntryName)
        {
            DBGOUT(BROADCAST, "\nI am broadcasting for " << *penEntryName << "\n"
                << "Interface = " << &NetRequest.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetRequest.Object << "\n\n");
        }
        else
        {
            DBGOUT(BROADCAST, "\nI am broadcasting for NULL entry\n"
                << "Interface = " << &NetRequest.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetRequest.Object << "\n\n");
        }
        myRpcLocator->markBroadcast(NetRequest);
    }


    // szDomain should be either NULL or a plain Domain name

    STRING_T szDomainParam;

    CStringW *pswDomain = penEntryName ? penEntryName->getDomainName() : NULL;

    if (pswDomain)
        szDomainParam = catenate(TEXT("\\\\"),*pswDomain);
    else szDomainParam = TEXT("\\\\*");

    TSSLEntryList *psslCache = new TSSLEntryList;

    StatusCode = NSI_S_OK;

    __try {

        csBindingBroadcastGuard.Enter();    // only one broadcast at a time

        while (cbRead = hMailslotForReplies->Read((char *) &NetReply, 
							sizeof(NetReply), 
							0)); // flush

        WRITE_MAIL_SLOT MSquery(szDomainParam, PMAILNAME_S);

        MSquery.Write((char *) &NetRequest, sizeof(NetRequest));

        // now loop waiting for responses from other RPC servers

        DBGOUT(BROADCAST, "**Broadcast sent. Wait timeout:: " << waitCur << "\n\n");

        while (cbRead = hMailslotForReplies->Read((char *) &NetReply,
                                                sizeof(NetReply),
                                                waitCur
                                            )
                )
        {
            DBGOUT(BROADCAST, "**Received a reply\n");
            pcBuffer = NetReply.Buffer;
            szEntryDomain = (_wcsicmp(
                                    *myRpcLocator->getDomainName(),
                                    NetReply.Domain
                                    )
                                == 0
                             )? NULL: NetReply.Domain;

            while (!StatusCode) {

                UnmarshallBroadcastReplyItem(
                                            psslCache,
                                            szEntryDomain,
                                            pcBuffer,
                                            cbRead,
                                            StatusCode
                                            );
            }

            StatusCode = NSI_S_OK;

            // halve the wait period everytime you get a response from the net

            waitCur >>= 1;

            DBGOUT(BROADCAST, "Wait time out:: " << waitCur);
        }
        DBGOUT(BROADCAST, "\nFinished waiting\n\n");
        csBindingBroadcastGuard.Leave();
    }

    __except(EXCEPTION_EXECUTE_HANDLER) {
        csBindingBroadcastGuard.Leave();
        StatusCode = GetExceptionCode();
        psslCache->wipeOut();
        delete psslCache;
        psslCache = NULL;
        if (pswDomain) 
            delete [] szDomainParam;
        return NULL;
    }

    if (pswDomain) delete [] szDomainParam;

    if (psslCache->size() == 0) {
        delete psslCache;
        psslCache = NULL;
    }

    return psslCache;
}


/****************  Methods related to MailSlotReplyItem ********************/

/* a little macro exclusively for use in CMailSlotReplyItem::Marshall */

#define bufferIt(source)                                          \
    lBufferSize -= advance;                                       \
    if (lBufferSize < 0) return 0;                                \
    memcpy(pcBuffer, (char*) source, advance);                    \
    pcBuffer += advance;


DWORD
CMailSlotReplyItem::Marshall(
                        char * pcBuffer,
                        long lBufferSize
                        )

/*++
Method Description:

--*/

{
    DWORD dwOriginalBufferSize = lBufferSize;

    fixed_part_of_reply fpr;

    fpr.type = MailslotServerEntryType;

    fpr.Interface = Interface;
    fpr.XferSyntax = XferSyntax;

    fpr.BindingLength = wcslen(binding)+ 1;
    fpr.EntryNameLength = wcslen(entryName) + 1;

    long advance;

    advance = sizeof(fixed_part_of_reply);
    bufferIt(&fpr);

    advance = fpr.EntryNameLength * sizeof(WCHAR);
    bufferIt(entryName);

    DBGOUT(BROADCAST, "Marshalling entry " << entryName);

    advance = sizeof(long);
    long objListSize = pObjectList->size();
    bufferIt(&objListSize);

    advance = sizeof(DWORD);    // this is a useless pointer part
    lBufferSize -= advance;     // therefore we don't marshall it
    pcBuffer += advance;        // we just account for its size

    TCSafeSkipListIterator<CGUID> objIter(*pObjectList);
    advance = sizeof(GUID);

    for (CGUID *obj =objIter.next(); obj; obj =objIter.next()) {
        GUID rep = obj->myGUID();
        bufferIt(&rep);
    }

    advance = fpr.BindingLength * sizeof(WCHAR);
    bufferIt(binding);

    return dwOriginalBufferSize - lBufferSize;
}


TMSRILinkList *
CBindingVector::msriList(
                CInterface *pIf,
                TCSafeSkipList<CGUID>* psslObjList
                )

/*++
Method Description:

    We combine every relevant object in the server entry with every basic
    binding string although that seems ridiculous.  This is the way the old
    locator expects us to behave as far as I can tell.

--*/

{
    CMailSlotReplyItem *pmsrl;
    TMSRILinkList *pmsrill = new TMSRILinkList;

    TCSafeSkipListIterator<CStringW> bindingIter(*this);

    for (CStringW * psw = bindingIter.next(); psw; psw = bindingIter.next())
    {
            pmsrl = new CMailSlotReplyItem;

            pmsrl->binding = *psw;
            pmsrl->pObjectList = psslObjList;
            pmsrl->Interface = pIf->myIdAndVersion();
            pmsrl->XferSyntax = pIf->xferSyntaxIdAndVersion();
            pmsrl->entryName = pMyEntry->getCurrentName();

            pmsrill->insert(pmsrl);
    }

    return pmsrill;
}


/**********  CBroadcastLookupHandle Methods ****************/

CBroadcastLookupHandle::CBroadcastLookupHandle(
                            UNSIGNED32            EntryNameSyntax,
                            STRING_T              EntryName,
                            CGUIDVersion     *    pGVInterface,
                            CGUIDVersion     *    pGVTransferSyntax,
                            CGUID            *    pIDobject,
                            unsigned long         ulVectorSize,
                            unsigned long         ulCacheAge
                            ) :
                            CRemoteLookupHandle(
                                    EntryNameSyntax,
                                    EntryName,
                                    pGVInterface,
                                    pGVTransferSyntax,
                                    pIDobject,
                                    ulVectorSize,
                                    ulCacheAge
                                    )
{
}



void
CBroadcastLookupHandle::initialize()
{
    StatusCode = NSI_S_OK;

    DBGOUT(BROADCAST, "Broadcasting for the entry received\n");

    psslNewCache = getBroadcastResults(
                                    ulCacheMax,
                                    penEntryName,
                                    pgvInterface,
                                    pidObject,
                                    StatusCode
                                    );

    if (!psslNewCache) plhFetched = NULL;

    else {

        TSSLEntryListIterator *pCacheIter = new TSSLEntryListIterator(*psslNewCache);

        plhFetched = new CGroupLookupHandle(
                                        pCacheIter,
                                        pgvInterface,
                                        pgvTransferSyntax,
                                        pidObject,
                                        ulVS,
                                        ulCacheMax
                                        );
    }

    if (penEntryName && !plhFetched) {                  // we looked for a specific entry
        DBGOUT(BROADCAST, "Broadcast not Made????\n");  // by name but found nothing new,
        StatusCode = NSI_S_ENTRY_NO_NEW_INFO;           // possibly because the broadcast
    }                                                   // was redundant and was not made

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}


/****************** CBroadcastObjectInqHandle Methods *******************/

CBroadcastObjectInqHandle::CBroadcastObjectInqHandle(
                                        STRING_T szEntryName,
                                        ULONG ulCacheAge
                                        )
                                : CRemoteObjectInqHandle(szEntryName,ulCacheAge)
{
}


void
CBroadcastObjectInqHandle::initialize()
{
    StatusCode = NSI_S_OK;

    TSSLEntryList *psslNewCache = getBroadcastResults(
                                                ulCacheMax,
                                                penEntryName,
                                                NULL,
                                                NULL,
                                                StatusCode
                                                );

    if (!psslNewCache || (psslNewCache->size() == 0)) {
        pUuidVector = NULL;
        return;
    }

    CEntry *pEntry = psslNewCache->pop();

    psslNewCache->wipeOut();
    delete psslNewCache;

    pUuidVector = getVector(pEntry->objectInquiry(ulCacheMax));
    delete pEntry;

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}


/************  Methods for CServerMailSlotReplyHandle *************/


CServerMailSlotReplyHandle::CServerMailSlotReplyHandle(
        TMSRILinkList    *    pmsrill
    )
{
    pmsriIterator = new TMSRILinkListIterator(*pmsrill);
           // see CServerLookupHandle::CServerLookupHandle
    delete pmsrill;
}


CServerMailSlotReplyHandle::~CServerMailSlotReplyHandle()
{
    for (    // run down the remaining items in the handle
            CMailSlotReplyItem* pmsri = pmsriIterator->next();
            pmsri;
            pmsri = pmsriIterator->next()
        )
    {
        delete pmsri;
    }

    delete pmsriIterator;
}



/************  Methods for CIndexMailSlotReplyHandle *************/


void
CIndexMailSlotReplyHandle::advanceCurrentHandle()
{
    delete pCurrentHandle;
    pCurrentHandle = NULL;

    CEntry *pCurEntry;

    while (!pEIterator->finished()) {

        pCurEntry = pEIterator->next();
        if (pCurEntry->isNonLocalType()) continue;

        pCurrentHandle = pCurEntry->MailSlotLookup(
                                        pGVInterface,
                                        pIDobject
                                        );

        if (pCurrentHandle && !pCurrentHandle->finished()) break;
    }
}


CIndexMailSlotReplyHandle::CIndexMailSlotReplyHandle(
            CGUIDVersion    *    pGVInf,
            CGUID           *    pIDobj,
            TEntryIterator  *    pEI
        )
{
    pEIterator = pEI;
    pGVInterface = pGVInf;
    pIDobject = pIDobj;
    pCurrentHandle = NULL;

    advanceCurrentHandle();
}


CMailSlotReplyItem *
CIndexMailSlotReplyHandle::next()
{
    if (pCurrentHandle && pCurrentHandle->finished())
                advanceCurrentHandle();

    if (!pCurrentHandle) return NULL;    // no more entries
    else return pCurrentHandle->next();
}

int
CIndexMailSlotReplyHandle::finished()
{
    if (pCurrentHandle && pCurrentHandle->finished())
                advanceCurrentHandle();

    if (!pCurrentHandle) return TRUE;    // no more entries
    else return FALSE;
}



/************  MailSlotLookup Methods *************/


CMailSlotReplyHandle *
CServerEntry::MailSlotLookup(
                    CGUIDVersion    *    pGVInterface,
                    CGUID           *    pIDobject
                    )
/*++
Method Description:

--*/
{
    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);

    TMSRILinkList *pmsrill = new TMSRILinkList;

    for (CInterface *pIf = IfIter.next(); pIf != NULL; pIf = IfIter.next())
            if (pIf->isCompatibleWith(pGVInterface,NULL)
               )
    {
        TMSRILinkList *pmsrillTemp
            = pIf->pBVhandles->msriList(pIf,&ObjectList);

        pmsrill->catenate(*pmsrillTemp);
        delete pmsrillTemp;
    }

    return new CServerMailSlotReplyHandle(
                                pmsrill
                                );
}


CMailSlotReplyHandle *
CFullServerEntry::MailSlotLookup(
            CGUIDVersion    *    pGVInterface,
            CGUID           *    pIDobject
            )
{
    if (pLocalEntry) return pLocalEntry->MailSlotLookup(
                                                    pGVInterface,
                                                    pIDobject
                                                    );
    else return NULL;
}


/**************  Thread definition for replying to broadcasts ***************/


#define cleanup()            \
    delete plhQuery;         \
    delete pGVinterface;     \
    delete pIDobject;        \
    delete pEntryName;

void
QueryProcess(void*)
/*++

  Routine Description:
  
    This thread creates a mailslot which listens for requests for
    RPC servers of a given interface GID.  It then uses LookUp to
    build a response list.  It then replies via a mailslot to the
    requesting machine.
    
      --*/
{
    QueryReply NetReply;
    QueryPacket NetQuery;
    
    DWORD dwMailSize, dwBufferUsed;
    
    // create both a server (s) side mailslot
    
    READ_MAIL_SLOT *hMailslotForQueries;
    
    __try{
        hMailslotForQueries = new READ_MAIL_SLOT(PMAILNAME_S, sizeof(QueryPacket));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        ExitThread(NSI_S_MAILSLOT_ERROR);
    }
    
    wcscpy(NetReply.Domain, *myRpcLocator->getDomainName());
    
    while (1) {
        
        CMailSlotReplyHandle * plhQuery = NULL;
        CGUIDVersion * pGVinterface = NULL;
        CGUID * pIDobject = NULL;
        CEntry * pEntry = NULL;
        
        RPC_STATUS status = NSI_S_OK;
        
        dwMailSize = hMailslotForQueries->Read(
            (char *) &NetQuery,
            sizeof(QueryPacket),
            MAILSLOT_WAIT_FOREVER
            );
        
        CriticalReader LocReader(rwLocatorGuard);
        // after mailslot receives a message take the lock.

        if (dwMailSize != sizeof(QueryPacket))
            continue;        // strange query, ignore it

        if (IsBadStringPtr(NetQuery.WkstaName, MAX_DOMAIN_NAME_LENGTH))
            continue;

        if (IsBadStringPtr(NetQuery.EntryName, MAX_ENTRY_NAME_LENGTH))
            continue;
        
        // ignore messages to self, sending a request on a mailslot
        // by a NetLookUp request will be delivered to the local slot too.
        // The pointer arithmetic skips over the initial "\\" in the name
        
        if (myRpcLocator->IsSelf(NetQuery.WkstaName+2)) continue;
        
        DBGOUT(BROADCAST, "\nReceived broadcast request from " << NetQuery.WkstaName << "\n\n");
        
        if (NetQuery.EntryName[0] != 0)
        {
            DBGOUT(BROADCAST, "\nBroadcast Looking for " << NetQuery.EntryName << "\n"
                << "Interface = " << &NetQuery.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetQuery.Object << "\n\n");
        }
        else
        {
            DBGOUT(BROADCAST, "\nBroadcast Looking for NULL entry\n"
                << "Interface = " << &NetQuery.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetQuery.Object << "\n\n");
        }
        
        // OK looks like a genuine query -- if we are in a workgroup, rememeber
        // the broadcaster as a potential master
        
        if (myRpcLocator->IsInWorkgroup()) myRpcLocator->addMaster((NetQuery.WkstaName)+2);
        
        pGVinterface = UuidIsNil(&NetQuery.Interface.SyntaxGUID,&status) ? NULL :
        new CGUIDVersion(NetQuery.Interface);
        
        pIDobject = UuidIsNil(&NetQuery.Object,&status) ? NULL :
        new CGUID(NetQuery.Object);
        
        // Variable used to make sure the entry name is well formed and local
        
        CEntryName *pEntryName = NULL;
        
        // This global reader block is needed because a lot of the info in the
        // MSRIs is "borrowed" from regular entries, i.e., not copied.  Thus, an
        // unexport in a separate thread can have unfortunate consequences.
        
        CriticalReader me(rwEntryGuard);
        
        if (NetQuery.EntryName[0] == 0) {    // use default entry
            
            plhQuery = new CIndexMailSlotReplyHandle(
                pGVinterface,
                pIDobject,
                myRpcLocator->IndexLookup(pGVinterface)
                );
            
            if (!plhQuery) {
                cleanup();                            // ignore the query
                continue;                            // if nothing to report
            }
        }
        
        else {
            
            __try {
                pEntryName = new CEntryName(NetQuery.EntryName);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                cleanup();                            // ignore the query
                continue;                            // if there is any problem
            }
            
            
            if (!pEntryName->isLocal()) {
                cleanup();                            // ignore the query
                continue;                            // if entry not in our domain
            }
            
            pEntry = myRpcLocator->findEntry(pEntryName);
            
            if (!pEntry) {
                cleanup();                            // ignore the query
                continue;                            // if entry not found
            }
            
            else plhQuery = pEntry->MailSlotLookup(
                pGVinterface,
                pIDobject
                );
            
            if (!plhQuery) {
                cleanup();                            // ignore the query
                continue;                            // if nothing to report
            }
            
        }
        
        __try {
            WRITE_MAIL_SLOT MSReply(NetQuery.WkstaName, PMAILNAME_C);
            
            char *pcBuffer = NetReply.Buffer;
            
            /* we must take care of the possibility that an item is fetched but
            cannot be marshalled because the buffer is full -- we have to
            retry marshalling it in the next cycle
            */
            
            CMailSlotReplyItem * pmsriNext = NULL;
            
            pmsriNext = plhQuery->next();
            
            while (pmsriNext) {
                
                int BufferNotFull = TRUE;
                dwBufferUsed = 0;
                
                while (BufferNotFull && pmsriNext) {
                    
                /*  NOTE: Compatibility Issue:  The +END_FLAG_SIZE below reserves space for
                the 4-byte 0 flag required by the old locator at the end of the buffer.
                    */
                    
                    DWORD dwBytesWritten =
                        pmsriNext->Marshall(
                        pcBuffer+dwBufferUsed,
                        NET_REPLY_MAILSLOT_BUFFER_SIZE-(dwBufferUsed+END_FLAG_SIZE)
                        );
                    
                    if (dwBytesWritten) {
                        dwBufferUsed += dwBytesWritten;
                        delete pmsriNext;
                        pmsriNext = plhQuery->next(); // only if marshalling was successful
                    }
                    
                    else BufferNotFull = FALSE;
                    
                }
                
                /* NOTE: Compatibility Issue:
                
                  The old locator does not use the count of bytes read to decide when
                  to stop unmarshalling a mailslot reply -- instead it uses the 0 flag
                  after the last marshalled entry for that purpose, so for compatibility
                  reasons we must do the needful.
                */
                
                memset(pcBuffer+dwBufferUsed,0,END_FLAG_SIZE);
                
                MSReply.Write(
                    (char*) &NetReply,
                    dwBufferUsed + MAX_DOMAIN_NAME_LENGTH * sizeof(WCHAR) + END_FLAG_SIZE
                    );
                DBGOUT(BROADCAST, "Reply sent\n\n");
            }
        }
        __finally {
            cleanup();                           // ignore the query
                                                 // if there is any problem
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\debug.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    debug.cxx

Abstract:

   This file contains the implementations for non inline member functions
   used for debugging output via the CDebugStream class, as well as debug
   and retail versions of midl_user_{allocate,free}.

Author:

    Satish Thatte (SatishT) 08/15/95  Created all the code below except where
									  otherwise indicated.

--*/


#include <locator.hxx>

#if DBG


CDebugStream&
CDebugStream::operator<<(
				NSI_SERVER_BINDING_VECTOR_T * pbvt
				)
{
	if (!pbvt) return *this;
	OutputDebugString(WNL);

	for (ULONG i = 0; i < pbvt->count; i++) {
		OutputDebugString(pbvt->string[i]);
		OutputDebugString(WNL);
	}

	OutputDebugString(WNL);
	return *this;
}

	
CDebugStream&
CDebugStream::operator<<(
				NSI_UUID_T * puuid
				)
{
	if (!puuid) return *this;
	*this << " ";

	WCHAR * pBuffer;

	UuidToString(puuid, &pBuffer);
	*this << pBuffer;
	RpcStringFree(&pBuffer);
	*this << " ";

	return *this;
}


CDebugStream&
CDebugStream::operator<<(
				NSI_UUID_VECTOR_T * puvt
				)
{
	if (!puvt) return *this;
	OutputDebugString(WNL);

	for (ULONG i = 0; i < puvt->count; i++) {
		*this << puvt->uuid[i];
		OutputDebugString(WNL);
	}

	OutputDebugString(WNL);
	return *this;
}

CDebugStream&
CDebugStream::operator<<(NSI_SYNTAX_ID_T * pIF_ID)
{
	if (!pIF_ID) return *this;

    *this << &pIF_ID->SyntaxGUID << " Version "
          << pIF_ID->SyntaxVersion.MajorVersion << "."
          << pIF_ID->SyntaxVersion.MinorVersion;

	return *this;
}


#endif

extern "C" {

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{

//#if DBG
//    void* pResult = CoTaskMemAlloc(len);
	// void* pResult = malloc(len);
//#else
	void* pResult = malloc(len);
//#endif

	if (pResult) return pResult;
	else Raise(NSI_S_OUT_OF_MEMORY);

	// the following just keeps the compiler happy

	return NULL;
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
//#if DBG
//    CoTaskMemFree(ptr);
	// free(ptr);
//#else
	free(ptr);
//#endif
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\dsqry.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:  dsqry.cxx
//
//  Contents:  Null queries on NTDS
//
//
//  History:   09-24-96     DebiM
//
//------------------------------------------------------------------------------
#include "locator.hxx"

CDSHandle::CDSHandle(STRING_T szDomainNameDns, STRING_T szRpcContainer)
{
    STRING_T szFullDN = NULL;
    
    hDSObject = NULL;
    if (myRpcLocator->fDSEnabled)
    {
        szFullDN = new WCHAR [LDAPPrefixLength+DSDomainBeginLength+wcslen(szDomainNameDns)+
                              DSDomainEndLength+wcslen(szRpcContainer)+1];

        wsprintf(szFullDN, L"%s%s%s%s%s", LDAPPrefix, DSDomainBegin, szDomainNameDns, DSDomainEndStr, szRpcContainer);

        DBGOUT(DIRSVC, "CDSHandle::CDSHandle Opening " << szFullDN << "in the DS\n");
        ADSIOpenDSObject(szFullDN, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, &hDSObject);
        delete szFullDN;
    }
}

CDSHandle::~CDSHandle()
{
    if (hDSObject)
        ADSICloseDSObject(hDSObject);
}

// returns the attribute corresp. to a given property.
DWORD GetPropertyFromAttr(ADS_ATTR_INFO *pattr, DWORD cNum, WCHAR *szProperty)
{
    DWORD   i;
    for (i = 0; i < cNum; i++)
        if (wcscmp(pattr[i].pszAttrName, szProperty) == 0)
            break;
        return i;
}


HRESULT GetRpcContainerForDomain(WCHAR *szDomain, WCHAR **pszRpcContainerDN, WCHAR **szDomainNameDns)
{
   WCHAR	          *szPath=NULL, *szDN = NULL;
   HANDLE              hDSObject = NULL;
   LPWSTR    	       AttrName = DEFAULTNAMINGCONTEXT;
   ADS_ATTR_INFO     * pAttr=NULL;
   DWORD               cgot=0, len = 0, dwResult = 0;
   HRESULT	           hr = S_OK;
   PDOMAIN_CONTROLLER_INFO pDCI;
    
   len = RPCCONTAINERPREFIXLEN+1+wcslen(ROOTCONTAINER);
   *szDomainNameDns = NULL;

   dwResult = DsGetDcName(NULL, szDomain, NULL, NULL,
                                      DS_IP_REQUIRED |
                                      DS_IS_FLAT_NAME |
                                      DS_DIRECTORY_SERVICE_PREFERRED |
                                      DS_RETURN_DNS_NAME,
                                      &pDCI);

   if ((dwResult == ERROR_SUCCESS) && (pDCI->DomainName)) {
        *szDomainNameDns = new WCHAR[wcslen(pDCI->DomainName)+1];
        if (!(*szDomainNameDns)) {
           NetApiBufferFree(pDCI);        
           return E_OUTOFMEMORY;
        }
            
        wcscpy(*szDomainNameDns, (pDCI->DomainName));
        NetApiBufferFree(pDCI);        
   }
   else {
    	DBGOUT(DIRSVC, "DsGetDc failed with error " << dwResult);
    	if (szDomain) {
            *szDomainNameDns = new WCHAR[wcslen(szDomain)+1];
            if (!(*szDomainNameDns)) {
               return E_OUTOFMEMORY;
            }
        
            wcscpy(*szDomainNameDns, (szDomain));
        }
   }

   // allocate memory
   if ((*szDomainNameDns) && (**szDomainNameDns))
        len += wcslen(*szDomainNameDns)+1;
        
   szPath = new WCHAR[len];
   if (!szPath)
       return E_OUTOFMEMORY;

   wsprintf(szPath, L"%s", RPCCONTAINERPREFIX);
   if ((*szDomainNameDns) && (**szDomainNameDns))
      wsprintf(szPath+wcslen(szPath), L"%s/", szDomainNameDns);
   wcscat(szPath, ROOTCONTAINER);

   DBGOUT(DIRSVC, "GetRpcContainerForDomain Opening " << szPath << "in the DS\n");
   hr = ADSIOpenDSObject(szPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, &hDSObject);

   if (SUCCEEDED(hr))
      hr = ADSIGetObjectAttributes(hDSObject, &AttrName, 1, &pAttr, &cgot);

   if (SUCCEEDED(hr))
      szDN = UnpackStrFrom(pAttr[0]);

   if (SUCCEEDED(hr)) {
       *pszRpcContainerDN = new WCHAR[wcslen(RPCSUBCONTAINER)+wcslen(szDN)+1];
       if (!*pszRpcContainerDN) 
           hr = E_OUTOFMEMORY;
   }

   if (SUCCEEDED(hr)) {
       wsprintf(*pszRpcContainerDN, L"%s%s", RPCSUBCONTAINER, szDN);
   }

   if (hDSObject)
      ADSICloseDSObject(hDSObject);

   if (pAttr)
      FreeADsMem(pAttr);

   delete szPath;

   return hr;
}


// Goes in as local system. Gets the machine domain name.
// for the time being.

HRESULT GetDefaultRpcContainer(DSROLE_PRIMARY_DOMAIN_INFO_BASIC dsrole, WCHAR **pszRpcContainerDN)
{
    WCHAR              *bgn = NULL, *end = NULL;
    NTSTATUS            Status;
    unsigned int        i, j;

    SetSvcStatus();

    // allocating a large spc to have enough space for replacing ',' with "DC="

    if (dsrole.DomainNameDns) 
        *pszRpcContainerDN = new WCHAR[wcslen(dsrole.DomainNameDns)*3+wcslen(RPCSUBCONTAINER)+1];
    else 
        *pszRpcContainerDN = new WCHAR[wcslen(RPCSUBCONTAINER)+1];

    if (!pszRpcContainerDN)
        return E_OUTOFMEMORY;

    if (dsrole.DomainNameDns) {
    	DBGOUT(DIRSVC, "DnsDomainName <" << dsrole.DomainNameDns << "> returned\n");

        wsprintf(*pszRpcContainerDN, L"%s", RPCSUBCONTAINER);
        j= wcslen(RPCSUBCONTAINER);
        
        for (bgn = dsrole.DomainNameDns;;) {
            end = wcschr(bgn, L'.');
            // find the next '.'
            if (end)
                *end = L'\0';
            
            if (bgn != dsrole.DomainNameDns)
                wcscat(*pszRpcContainerDN, L",");
            // if it is not first part, add a seperator.
            
            wcscat(*pszRpcContainerDN, L"DC=");
            wcscat(*pszRpcContainerDN, bgn);
            
            if ((!end) || (!(*(end+1))))
                break;
            // quit either if there are no more '.' or 
            // if we have reached the end.
            bgn = end+1;
		}
    }
    else
    {
        wcscpy(*pszRpcContainerDN, L"");
    }

    SetSvcStatus();

    return S_OK;
}

// BUGBUG:: This has to change. for the time being it
// doesn't distinguish multiple cases like workgroup, DC coming up
// etc..

void Locator::SetConfigInfoFromDS(DSROLE_PRIMARY_DOMAIN_INFO_BASIC dsrole)
{
    HRESULT             hr=S_OK;
    WCHAR              *szFullName=NULL, *szRpcContainerDN= NULL;
    HANDLE              hDSObject = NULL;
    LPWSTR              AttrName = NT4COMPATIBILITY_FLAG;
    ADS_ATTR_INFO     * attr=NULL;
    DWORD               cgot=0;
    NTSTATUS            Status;

    //    csDSSettingsGuard.Enter();
    //    if (fTriedConnectingToDS)
    //    {
    //        csDSSettingsGuard.Leave();
    //        return;
    //    }
    //
    //    fTriedConnectingToDS = 1;

    //
    // LDAP has its own notions of when to pass the securitydescriptor to the DS. When running as 
    // as local system if we want to verify anything we have to pass the Dns Domain Name. Rest of the
    // the time flat name seems to be sufficient. In an effort to localize the changes we are passing
    // DomainNameDns only when a call is being made as system service. rest of the stuff still passes
    // flat name.
    //

    fNT4Compat = 1;
    fDSEnabled = 1;

    if (dsrole.DomainNameDns) {
        pDomainNameDns = new CStringW(dsrole.DomainNameDns);
        DBGOUT(DIRSVC, "DomainName <" << dsrole.DomainNameDns << "> returned\n");
    }
    else {
        DBGOUT(DIRSVC, "DnsDomainName is NULL\n");   
        pDomainNameDns = NULL;
    }

    if (dsrole.DomainNameFlat) {
        pDomainName = new CStringW(dsrole.DomainNameFlat);
        if (!pDomainNameDns)
            pDomainNameDns = new CStringW(dsrole.DomainNameFlat);

        DBGOUT(DIRSVC, "DomainName <" << dsrole.DomainNameFlat << "> returned\n");
    }
    else {
        DBGOUT(DIRSVC, "DomainName is NULL\n");                
        pDomainName = new CStringW(L"");
        pDomainNameDns = new CStringW(L"");
    }

    // get the domain name and its DN
    hr = GetDefaultRpcContainer(dsrole, &szRpcContainerDN);

    if (SUCCEEDED(hr))
        pRpcContainerDN = new CStringW(szRpcContainerDN);
    else
        pRpcContainerDN = new CStringW(L"");


    DBGOUT(DIRSVC, "Machine Domain " << *pDomainName << "\n");
    DBGOUT(DIRSVC, "szDefaultDNRpcContainer " << *pRpcContainerDN << "\n");

    if ((!szRpcContainerDN) || (!szRpcContainerDN[0])) {
        fDSEnabled = 0;
        DBGOUT(DIRSVC, "No DNS Information available. Running in NT4 Mode\n");
//		hr = GetRpcContainerForDomain(NULL, szRpcContainerDN);
//		DBGOUT(DIRSVC, "Contacting the DC we get" << szRpcContainerDN << "\n");
        return;
    }

    SetSvcStatus();

    // Get the compatibility flag value.

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen((STRING_T)(*pDomainNameDns))+1+wcslen(szRpcContainerDN)+1];
    if (!szFullName)
        hr = E_OUTOFMEMORY;
    else {
        wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, (STRING_T)(*pDomainNameDns), szRpcContainerDN);
        DBGOUT(DIRSVC, "SetConfigInfoFromDS Attempting to contact the DC at " << szFullName << "...\n");
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION, &hDSObject);
        
        SetSvcStatus();
        delete szFullName;
    }

    delete szRpcContainerDN;


    if (FAILED(hr)) {
/*
        // adding it to the event log.
        WCHAR ErrorCode[20];
        HANDLE LogHandle = NULL;
        LPCTSTR Strings[1];

        String[0] = ErrorCode;

        wsprintf(ErrorCode, L"Errorcode = 0x%x", hr);
        LogHandle = RegisterEventSource(NULL, LOCATOR_EVENT_SOURCE);

        if (!LogHandle) {
            DBGOUT(DIRSVC, "Couldn't open event log\n");
            return;
        }

        ReportEvent(LogHandle,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EVENT_RPCLOCATOR_BIND_TO_DS_ERROR,
                                  // create this event
                    1,
                    0,
                    (LPCTSTR *)Strings,
                    NULL
                    );
*/

        WCHAR errbuf[20];
        wsprintf(errbuf, L"HRESULT = 0x%x", hr);

        fDSEnabled = 0;
        DBGOUT(DIRSVC, "Couldn't contact the DC. Running in pure NT4 Mode" << errbuf << "\n");
        return;
    }
    else
        DBGOUT(DIRSVC, "contacted DC\n");

    hr = ADSIGetObjectAttributes(hDSObject, &AttrName, 1, &attr, &cgot);
    DBGOUT(DIRSVC, "Got the NT4Compat flag\n");

    if ((SUCCEEDED(hr)) && (cgot))
        fNT4Compat = UnpackIntFrom(attr[0]);

    SetSvcStatus();

    if (hDSObject)
        ADSICloseDSObject(hDSObject);

    DBGOUT(DIRSVC, "Clsoing the LDAP handle\n");
    if (attr)
        FreeADsMem(attr);

    //    csDSSettingsGuard.Leave();
}


CLookupHandle *
Locator::DSLookup(
                  UNSIGNED32           EntryNameSyntax,
                  STRING_T             EntryName,
                  CGUIDVersion    *    pGVinterface,
                  CGUIDVersion    *    pGVsyntax,
                  CGUID           *    pIDobject,
                  unsigned long        ulVectorSize,
                  unsigned long        ulCacheAge
                  )
/*++
Member Description:

  Use the given lookup parameters to perform a lookup from the
  DS.

  If an entry name is given then get all the data immediately available
  If an entry is server entry then get all the data immediately
  If an entry is group entry get all the data but do not chase the
        links immediately. Links will be chased lazily in case of nexts
        and not in creating the handle
  If an entry is profile entry it behaves the same way as the group
  entry above.

  if the entryname is not given it again behaves like a group entry.

Arguments:

  EntryNameSyntax        - Name syntax, optional

  EntryName              - (raw) Name of the entry to look up, optional

  pGVinterface           - (wrapped) Interface to look up, optional

  pGVsyntax              - (wrapped) Transfer syntax, optional

  pIDobject              - (wrapped) Object UUID, optional

  ulVectorSize           - Max size of vectors of binding handles, 0 for default

  ulCacheAge             - acceptable max age of cached information from a master
                           presently unused.

Returns:

  A lookup handle based on the info retrieved.

--*/
{
   ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and abt. to start lookup in DS");
   return new CDSLookupHandle(
            EntryNameSyntax,
            EntryName,
            pGVinterface,
            pGVsyntax,
            pIDobject,
            ulVectorSize,
            ulCacheAge
            );

}

//////////////////////////////////////////////////////////////////////////
//  GetEntryFromDS::
//          Given the entry name, this function creates an object of server,
//  profile or group entry type based on the schema name of the DS object.
// It then gets various fields/properties. After that Satish's code for in memory
// search takes over.
//////////////////////////////////////////////////////////////////////////

// all the functions below that use attr returned from GetObjectAttributes
// should free them at the place where GetObjectAttributes is called.

// all the functions that use columns should free them immediate after
// using GetColumn is called.

CEntry *
GetEntryFromDS(UNSIGNED32 EntryNameSyntax,
               STRING_T pszEntryName)
{
    ULONG                i, sz=0;
    HRESULT              hr = S_OK;
    CEntry             * pEntry = NULL;
    WCHAR              * pszFullEntryName=NULL;
    ADS_ATTR_INFO      * pAttr=NULL;
    DWORD                cAttrgot = 0, propnum=0;
    WCHAR             ** pszClasses, *szFullName=NULL;
    HANDLE               hDSObject=NULL;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and abt. to start lookup in DS");

    if (EntryNameSyntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!pszEntryName) Raise(NSI_S_INCOMPLETE_NAME);

    CEntryName * EntryName = new CEntryName(pszEntryName);

    pszFullEntryName = EntryName->getFullDNAlloc();

    DBGOUT(DIRSVC, "Looking for Entry " << pszFullEntryName << "in the DS\n");

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen((STRING_T)(*(EntryName->getDomainNameDns())))+1+
                           wcslen(pszFullEntryName)+1];

    if (!szFullName)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr)) {
        wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, (STRING_T)(*(EntryName->getDomainNameDns())),
	         pszFullEntryName);

        DBGOUT(DIRSVC, "GetEntryFromDS Opening " << szFullName << "in the DS\n");
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
		    	  &hDSObject);
    }

    // get all the attributes. we do not want to go on n/w again.
    if (SUCCEEDED(hr))
        hr = ADSIGetObjectAttributes(hDSObject, NULL, -1, &pAttr, &cAttrgot);

    if (SUCCEEDED(hr))
    {
        propnum = GetPropertyFromAttr(pAttr, cAttrgot, CLASSNAME);
        if (propnum == cAttrgot)
            hr = E_FAIL; // class didn't come back from the getobject.
    }

    if (SUCCEEDED(hr))
    {
        UnpackStrArrFrom(pAttr[propnum], &pszClasses, &sz);

        if ((!pszClasses) || (!sz))
            hr = E_FAIL;

        // create a new entry based on the value.
        if ((SUCCEEDED(hr)) && (wcsstr(pszClasses[sz-1], RPCSERVERCONTAINERCLASS) != NULL))
        {
            // if it is a created entry return NULL.
            propnum = GetPropertyFromAttr(pAttr, cAttrgot, DESCRIPTION);
            if (propnum < cAttrgot)
            {
                WCHAR *pszDesc = UnpackStrFrom(pAttr[propnum]);
                if ((pszDesc) && (wcscmp(pszDesc, CREATED_DESCRIPTION) != 0))
                {
                    DBGOUT(DIRSVC, "Found a Server Entry of the name in the DS\n");
                    CServerEntry *pServerEntry = new CServerEntry(pszEntryName, pAttr, cAttrgot,
                        hDSObject, &hr);
                    if (FAILED(hr))
                        delete pServerEntry;
                    else
                        pEntry = pServerEntry;
                }
            }
        }
        else if ((SUCCEEDED(hr)) && (wcsstr(pszClasses[sz-1], RPCPROFILECONTAINERCLASS) != NULL))
        {
            DBGOUT(DIRSVC, "Found a Profile Entry of the name in the DS\n");
            CProfileEntry *pProfileEntry = new CProfileEntry(pszEntryName, pAttr, cAttrgot,
                hDSObject, &hr);
            if (FAILED(hr))
                delete pProfileEntry;
            else
                pEntry = pProfileEntry;
        }
        else if ((SUCCEEDED(hr)) && (wcsstr(pszClasses[sz-1], RPCGROUPCLASS) != NULL))
        {
            DBGOUT(DIRSVC, "Found a Group Entry of the name in the DS\n");
            CGroupEntry *pGroupEntry = new CGroupEntry(pszEntryName, pAttr, cAttrgot,
                hDSObject, &hr);
            if (FAILED(hr))
                delete pGroupEntry;
            else
                pEntry = pGroupEntry;
        }
        else
            hr = E_FAIL;

        if (pszClasses)
            delete pszClasses;

        // Class type is not recognized.
    }

    if (hDSObject)
        ADSICloseDSObject(hDSObject);

    if (pszFullEntryName)
        delete pszFullEntryName;

    if (EntryName)
        delete EntryName;

    delete szFullName;

    DBGOUT(DIRSVC, "\n");

    if (pAttr)
        FreeADsMem(pAttr);

    return pEntry;
}

//------------------------------------------------------------
// these 2 macros repeat in profile and server entry searches.
#define MACSetSearchOneLevel                                    \
    SearchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;     \
    SearchPrefs.vValue.dwType = ADSTYPE_INTEGER;                \
    SearchPrefs.vValue.Integer = ADS_SCOPE_ONELEVEL;            \
*phr = ADSISetSearchPreference(hDSObject, &SearchPrefs, 1);

#define MACExecuteSearch                                        \
*phr = ADSIExecuteSearch(hDSObject, filter, pChildAttrNames, nAttrs, &hSearchHandle);

#define MACEnumChildrenLOOP                                     \
    for (*phr = ADSIGetFirstRow(hDSObject, hSearchHandle);      \
    ((SUCCEEDED(*phr)) && ((*phr) != S_ADS_NOMORE_ROWS));       \
*phr = ADSIGetNextRow(hDSObject, hSearchHandle))


#define MACSetChildList                                         \
    MACSetSearchOneLevel                                        \
                                                                \
    if (SUCCEEDED(*phr))                                        \
        MACExecuteSearch                                        \
                                                                \
    if (SUCCEEDED(*phr))                                        \
        MACEnumChildrenLOOP
//----------------------------------------------------------

// fill in all the object uuid
void GetObjectList(TCSafeSkipList<CGUID> *pObjectList, WCHAR **pProperty, ULONG sz)
{
    GUID                 objectGuid;
    CGUID              * tmpguid=NULL;
    DWORD                 i;

    pObjectList->wipeOut();
    for (i = 0; i < sz; i++) {
        UuidFromString(pProperty[i], &objectGuid);
        tmpguid = new CGUID(objectGuid);
        pObjectList->insert(tmpguid);
    }
}

// fill the interface structure
void GetInterfaceList(CServerEntry *me, TCSafeSkipList<CInterface> *pInterfaceList,
                      HANDLE hDSObject, HRESULT *phr)
{
    ADS_SEARCH_HANDLE        hSearchHandle = NULL;
    CInterface             * pInterface = NULL;
    ADS_SEARCHPREF_INFO      SearchPrefs;
    LPWSTR                   pChildAttrNames[] = {BINDINGS, TRANSFERSYNTAX, INTERFACEID};
    DWORD                    nAttrs = 3;
    WCHAR                    filter[_MAX_PATH];   

    pInterfaceList->wipeOut();

    wsprintf(filter, L"(%s=%s)", CLASSNAME, RPCSERVERELEMENTCLASS);

    MACSetChildList {
        pInterface = new CInterface(me, hDSObject, hSearchHandle, phr);
        if (FAILED(*phr))
            delete pInterface;
        else
            pInterfaceList->insert(pInterface);
    }
    if (hSearchHandle)
        ADSICloseSearchHandle(hDSObject, hSearchHandle);
}

// create a new server entry
CServerEntry::CServerEntry(CONST_STRING_T pszStr, ADS_ATTR_INFO *pAttr,
                           DWORD cAttr, HANDLE hDSObject, HRESULT *phr)
                           : CEntry(pszStr, ServerEntryType)
{
    ULONG                   sz = 0;
    WCHAR                ** pProperty = NULL;
    DWORD                   propnum = 0;

    *phr = S_OK;
    propnum = GetPropertyFromAttr(pAttr, cAttr, OBJECTID);
    if (propnum < cAttr)
        UnpackStrArrFrom(pAttr[propnum], &pProperty, &sz);

    GetObjectList(&ObjectList, pProperty, sz);
    GetInterfaceList(this, &InterfaceList, hDSObject, phr);

    if (pProperty)
        delete pProperty;
}

CServerEntry::CServerEntry(CONST_STRING_T pszStr, CONST_STRING_T pszDomainNameDns, CONST_STRING_T pszEntryName, 
                          HANDLE hDSObject, ADS_SEARCH_HANDLE hSearchHandle, HRESULT *phr)
                           : CEntry(pszStr, pszDomainNameDns, 1, pszEntryName, ServerEntryType)
{
    ULONG                   sz = 0;
    WCHAR                ** pProperty = NULL, *szFullName=NULL, *pszFullEntryName = NULL;
    ADS_SEARCH_COLUMN       column;
    HANDLE                  hDSSrvObject = NULL;

    pszFullEntryName = getFullDNAlloc();

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen(pszDomainNameDns)+1+wcslen(pszFullEntryName)+1];

    if (!szFullName) {
        *phr = E_OUTOFMEMORY;
    }
    else {
        wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, pszDomainNameDns, pszFullEntryName);

        *phr = ADSIGetColumn(hDSObject, hSearchHandle, OBJECTID, &column);
    }

    if (SUCCEEDED(*phr)) {
        UnpackStrArrFrom(column, &pProperty, &sz);
        GetObjectList(&ObjectList, pProperty, sz);
        ADSIFreeColumn(hDSObject, &column);

        if (pProperty)
            delete pProperty;
    }

    DBGOUT(DIRSVC, "CServerEntry::CServerEntry Opening " << szFullName << "in the DS\n");
    *phr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                            &hDSSrvObject);
    if (SUCCEEDED(*phr))
        GetInterfaceList(this, &InterfaceList, hDSSrvObject, phr);

    if (hDSSrvObject)
        ADSICloseDSObject(hDSSrvObject);
    delete szFullName;

    *phr = S_OK;
}


//////////////////////////////////////////////////////////////////////////
//      It gets the property fields filled. Then it enumerates among its
//  children and gets the values for each of the profile elements.
//////////////////////////////////////////////////////////////////////////
CProfileEntry::CProfileEntry(const STRING_T pszStr, ADS_ATTR_INFO *pAttr, DWORD cAttr,
                             HANDLE hDSObject, HRESULT *phr)
                             : CEntry(pszStr, ProfileEntryType),
                             pDefaultElt(NULL)
{
    ADS_SEARCHPREF_INFO     SearchPrefs;
    ADS_SEARCH_HANDLE       hSearchHandle;
    LPWSTR                  pChildAttrNames[] = {PROFILE, PRIORITY, ANNOTATION, INTERFACEID}; 
    WCHAR                   filter[_MAX_PATH];
    DWORD                   i, nAttrs = 4;
    CProfileElement       * pProfileElement = NULL;

    *phr = S_OK;
    wsprintf(filter, L"(%s=%s)", CLASSNAME, RPCPROFILEELEMENTCLASS);

    MACSetChildList {
        pProfileElement = new CProfileElement(this, hDSObject, hSearchHandle, phr);
        if (FAILED(*phr))
            delete pProfileElement;
        else {
            if (pProfileElement->fIsDefault)
                pDefaultElt = pProfileElement;
            else {
                EltList.insert(pProfileElement);
                CProfileSet *pSet = ProfileList.find(&CUnsigned32(pProfileElement->dwPriority));

                if (pSet == NULL) {
                    // New priority level
                    pSet = new CProfileSet(pProfileElement);
                    ProfileList.insert(pSet);
                }
                else
                    pSet->insert(pProfileElement);
            }
        }
    }

    if (hSearchHandle)
        ADSICloseSearchHandle(hDSObject, hSearchHandle);
}

//////////////////////////////////////////////////////////////////////////
//      gets the property filled immediately.
//////////////////////////////////////////////////////////////////////////
CGroupEntry::CGroupEntry(const STRING_T pszStr, ADS_ATTR_INFO *pAttr, DWORD cAttr,
                         HANDLE hDSObject, HRESULT *phr)
                         : CEntry(pszStr, GroupEntryType)
{
    WCHAR        ** pszGroupList=NULL;
    DWORD           propnum, i, sz=0;
    WCHAR         * szRpcContainerDN = NULL, 
                  * szDomainNameDns = NULL, * szEntryName = NULL;

    *phr = S_OK;
    propnum = GetPropertyFromAttr(pAttr, cAttr, GROUP);
    if (propnum < cAttr) {
        UnpackStrArrFrom(pAttr[propnum], &pszGroupList, &sz);
        for (i = 0; i < sz; i++) {
            StripDomainFromDN(pszGroupList[i], &szDomainNameDns, &szEntryName, 
                              &szRpcContainerDN);
            CEntryName *pEntryName = new CEntryName(szRpcContainerDN, szDomainNameDns, 1, szEntryName);
            GroupList.insert(pEntryName);
        }

        if (pszGroupList)
            delete pszGroupList;
    }
}


CInterface::CInterface(CServerEntry *pMyEntry, HANDLE hDSObject, ADS_SEARCH_HANDLE hSearchHandle,
                       HRESULT *phr): m_pMyEntry(pMyEntry)
{
    ULONG                         i, sz = 0;
    RPC_SYNTAX_IDENTIFIER         in;
    WCHAR                      ** pszProperty=NULL;
    WCHAR                       * endptr=NULL;
    WCHAR                       * szProperty=NULL;
    ADS_SEARCH_COLUMN             column;

    *phr = S_OK;

    DBGOUT(DIRSVC, "Found a Interface, under the server Entry in the DS\n");

    pBVhandles = new CBindingVector(pMyEntry);

    if (SUCCEEDED(*phr))
        *phr = ADSIGetColumn(hDSObject, hSearchHandle, BINDINGS, &column);

    if (SUCCEEDED(*phr)) {
        UnpackStrArrFrom(column, &pszProperty, &sz);
        for (i = 0; i < sz; i++)
            pBVhandles->insertBindingHandle(pszProperty[i]);
        ADSIFreeColumn(hDSObject, &column);

        *phr = ADSIGetColumn(hDSObject, hSearchHandle, TRANSFERSYNTAX, &column);

        if (pszProperty)
            delete pszProperty;
    }

    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if ((szProperty) && (SyntaxIdFromString(in, szProperty)))
            transferSyntax = CGUIDVersion(in);
        else
            *phr = E_FAIL;

        ADSIFreeColumn(hDSObject, &column);
    }

    if (SUCCEEDED(*phr))   
        *phr = ADSIGetColumn(hDSObject, hSearchHandle, INTERFACEID, &column);

    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if (!((szProperty) && (SyntaxIdFromString(idAndVersion, szProperty))))
            *phr = E_FAIL;

        ADSIFreeColumn(hDSObject, &column);
    }
}


CProfileElement::CProfileElement(
                                 CProfileEntry            *  pMyEntry,
                                 HANDLE                      hDSObject,
                                 ADS_SEARCH_HANDLE           hSearchHandle,
                                 HRESULT                  *  phr
                                 ):m_pMyEntry(pMyEntry)
{
    RPC_SYNTAX_IDENTIFIER    in;
    WCHAR                  * szProperty = NULL;
    WCHAR                  * endptr=NULL;
    ADS_SEARCH_COLUMN        column;
    WCHAR                  * szRpcContainerDN = NULL, 
                           * szDomainNameDns = NULL, * szEntryName = NULL;

    DBGOUT(DIRSVC, "Found a Profile Element, under the Profile Entry in the DS\n");

    *phr = ADSIGetColumn(hDSObject, hSearchHandle, PROFILE, &column);
    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if (!szProperty)
            *phr = E_FAIL;
        else {
            StripDomainFromDN(szProperty, &szDomainNameDns, &szEntryName, 
                              &szRpcContainerDN);
            EntryName = CEntryName(szRpcContainerDN, szDomainNameDns, 1, szEntryName);
        }
        ADSIFreeColumn(hDSObject, &column);

        *phr = ADSIGetColumn(hDSObject, hSearchHandle, PRIORITY, &column);
    }

    if (SUCCEEDED(*phr)) {
        dwPriority = (DWORD)UnpackIntFrom(column);
        ADSIFreeColumn(hDSObject, &column);

        *phr = ADSIGetColumn(hDSObject, hSearchHandle, ANNOTATION, &column);
    }

    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if (szProperty)
            pszAnnotation = CStringW(szProperty);
        else
            pszAnnotation = CStringW(L"");
        ADSIFreeColumn(hDSObject, &column);
    }
    else {
        pszAnnotation = CStringW(L"");
        *phr = S_OK;
    }

    if (SUCCEEDED(*phr))
        *phr = ADSIGetColumn(hDSObject, hSearchHandle, INTERFACEID, &column);

    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if (!((szProperty) && (SyntaxIdFromString(in, szProperty))))
            *phr = E_FAIL;
        else {
            Interface = CGUIDVersion(in);

            if (IsNilIfId(&in))
                fIsDefault = TRUE;
            else
                fIsDefault = FALSE;
        }
        ADSIFreeColumn(hDSObject, &column);
    }
}


CServerEntry *CDSQry::next()
{
    HRESULT                hr = S_OK;
    ADS_SEARCH_COLUMN      column;
    WCHAR                * szProperty = NULL;
    CServerEntry         * pServer = NULL;

    hr = ADSIGetNextRow(hDSObject, hSearchHandle);
    if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
        return NULL;

    hr = ADSIGetColumn(hDSObject, hSearchHandle, DISTINGUISHEDNAME, &column);
    if (FAILED(hr))
        return NULL;

    // this has to be there as part of all entries.
    // may be DS is down

    szProperty = UnpackStrFrom(column);
    if (szProperty)
    {
        WCHAR	*szDN = NULL, *szDomainNameDns = NULL, *szEntryName = NULL, *szRpcContainerDN = NULL;
   
        szDN = new WCHAR[DSDomainBeginLength+wcslen(*(myRpcLocator->getDomainNameDns()))+
    	    	        DSDomainEndLength+wcslen(szProperty)+1];

        wsprintf(szDN, L"%s%s%c%s", DSDomainBegin, (STRING_T)*(myRpcLocator->getDomainNameDns()), DSDomainEnd, 
                                     szProperty);

        StripDomainFromDN(szDN, &szDomainNameDns, &szEntryName, 
                              &szRpcContainerDN);

        pServer = new CServerEntry(szRpcContainerDN, szDomainNameDns, szEntryName, hDSObject, hSearchHandle, &hr);

        delete szDN;
    }
    else
        hr = E_FAIL;


    if (FAILED(hr)) {
        delete pServer;
        pServer = NULL;
    }
    ADSIFreeColumn(hDSObject, &column);
    return pServer;

}

CDSQry::CDSQry(WCHAR *filter, HRESULT *phr)
{
    WCHAR                   *szFullName=NULL;
    ADS_SEARCHPREF_INFO      SearchPrefs;
    ULONG                    nAttrs = 2;
    LPWSTR                   pChildAttrNames[] = {DISTINGUISHEDNAME, OBJECTID};

    // get all the relevant properties.
    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen((STRING_T)*(myRpcLocator->getDomainNameDns()))+1+
                           wcslen((STRING_T)*(myRpcLocator->pRpcContainerDN))+1];

    wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, (STRING_T)*(myRpcLocator->getDomainNameDns()),
                                    (STRING_T)*(myRpcLocator->pRpcContainerDN));

    if (!szFullName) {
        *phr = E_OUTOFMEMORY;
    } else {
        DBGOUT(DIRSVC, "CDSQry::CDSQry Opening " << szFullName << "in the DS\n");
        *phr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
            &hDSObject);
    }

    if (SUCCEEDED(*phr))
        MACSetSearchOneLevel;

    if (SUCCEEDED(*phr))
        MACExecuteSearch;

    delete szFullName;
}

CDSQry::~CDSQry()
{
    if (hSearchHandle)
        ADSICloseSearchHandle(hDSObject, hSearchHandle);
    if (hDSObject)
        ADSICloseDSObject(hDSObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\api.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    api.cxx

Abstract:

   This file contains

   1.  implementations of most noninline member functions in the Locator class.

   2.  implementations of the remoted API functions called by the name service client DLL.

   3.  implementations of the locator-to-locator API functions.

Author:

    Satish Thatte (SatishT) 08/15/95  Created all the code below except where
                                      otherwise indicated.

--*/


#include <locator.hxx>
extern BOOL fLocatorInitialized;


/*************                                         *************
 *************     The top level API routines follow   *************
 *************                                         *************/

extern "C" {

void
nsi_binding_export(
    IN UNSIGNED32           EntryNameSyntax,
    IN STRING_T             EntryName,
    IN NSI_INTERFACE_ID_T * Interface,
    IN NSI_SERVER_BINDING_VECTOR_T *BindingVector,
    IN NSI_UUID_VECTOR_P_T  ObjectVector, OPT
    IN UNSIGNED16         * status
    )
/*++
Routine Description:

    Export interfaces and objects to a server entry.

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       - Name string of the entry to export

    Interface       - Interface unexport

    BindingVector   - Vector of string bindings to export.

    ObjectVector    - Objects to add to the entry

    status          - Status is returned here

Returned Status:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_S_OUT_OF_MEMORY, NSI_S_INVALID_OBJECT, NSI_S_NOTHING_TO_EXPORT,
    NSI_S_ENTRY_TYPE_MISMATCH

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    DBGOUT(API, "\nExport for Entry " << EntryName << "\n\n");
    DBGOUT(API, "With Binding Vector:\n" << BindingVector);
    DBGOUT(API, "\n\nAnd Object Vector:\n" << ObjectVector << "\n\n");


    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try {
        myRpcLocator->nsi_binding_export(
                    EntryNameSyntax,
                    pEntryName,
                    Interface,
                    BindingVector,
                    ObjectVector,
                    Local
                    );
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_INVALID_OBJECT:
            case NSI_S_NOTHING_TO_EXPORT:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_INTERFACE_NOT_EXPORTED:
            case NSI_S_NOT_ALL_OBJS_EXPORTED:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}



void
nsi_mgmt_binding_unexport(
    UNSIGNED32          EntryNameSyntax,
    STRING_T            EntryName,
    NSI_IF_ID_P_T       Interface,
    UNSIGNED32          VersOption,
    NSI_UUID_VECTOR_P_T ObjectVector,
    UNSIGNED16 *        status
    )
/*++

Routine Description:

    unExport a information from a server entry finer control then nsi_binding
    counter part.

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       - Name string of the entry to unexport

    Interface       - Interface to unexport

    VersOption      - controls in fine detail which interfaces to remove.

    ObjectVector    - Objects to remove from the entry

    status          - Status is returned here

Returned Status:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_S_INVALID_VERS_OPTION, NSI_S_ENTRY_NOT_FOUND.
    NSI_S_NOTHING_TO_UNEXPORT, NSI_S_NOT_ALL_OBJS_UNEXPORTED,
    NSI_S_INTERFACE_NOT_FOUND

--*/
{
    RPC_STATUS raw_status;

    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    *status = NSI_S_OK;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;


    __try {
        myRpcLocator->nsi_mgmt_binding_unexport(
                            EntryNameSyntax,
                            pEntryName,
                            Interface,
                            VersOption,
                            ObjectVector
                            );

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_NOTHING_TO_UNEXPORT:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_NOT_ALL_OBJS_UNEXPORTED:
            case NSI_S_INTERFACE_NOT_FOUND:
            case NSI_S_INVALID_VERS_OPTION:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }

    raw_status = RpcRevertToSelf();
}



void
nsi_binding_unexport(
    IN UNSIGNED32           EntryNameSyntax,
    IN STRING_T             EntryName,
    IN NSI_INTERFACE_ID_T * Interface,
    IN NSI_UUID_VECTOR_P_T  ObjectVector, OPT
    IN UNSIGNED16         * status
    )
/*++

Routine Description:

    unExport a information from a server entry..

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       - Name string of the entry to unexport

    Interface       - Interface to unexport

    ObjectVector    - Objects to remove from the entry

    status          - Status is returned here

Returned Status:

    See: nsi_mgmt_binding_unexport()

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    // critical section taken in mgmt_unexport

    if (Interface && IsNilIfId(&(Interface->Interface))) Interface = NULL;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;


    nsi_mgmt_binding_unexport(EntryNameSyntax, pEntryName,
        (Interface)? &Interface->Interface: NULL,
        RPC_C_VERS_EXACT, ObjectVector, status);
}



void
nsi_binding_lookup_begin(
    IN  UNSIGNED32           EntryNameSyntax,
    IN  STRING_T             EntryName,
    IN  NSI_INTERFACE_ID_T * Interface, OPT
    IN  NSI_UUID_P_T         Object, OPT
    IN  UNSIGNED32           VectorSize,
    IN  UNSIGNED32           MaxCacheAge,
    OUT NSI_NS_HANDLE_T    * InqContext,
    IN  UNSIGNED16         * status
    )
/*++

Routine Description:

    Start a lookup operation.  Just save all the input params in the
    newly created lookup context.  Perform the initial query.

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       -  Name string to lookup on.

    Interface       - Interface to search for

    Object          - Object to search for

    VectorSize      - Size of return vector

    MaxCacheAge     - take seriously if nonzero    -- always zero for old locator

    InqContext      - Context to continue with for use with "Next"

    status          - Status is returned here

Returned Status:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_ENTRY_NOT_FOUND,
    NSI_OUT_OF_MEMORY

--*/
{

    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    DBGOUT(API, "\nLookup Begin for Entry " << EntryName << "\n\n");

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;

    __try {
        *InqContext =
            myRpcLocator->nsi_binding_lookup_begin(
                            EntryNameSyntax,
                            pEntryName,
                            Interface, OPT
                            Object, OPT
                            VectorSize,
                            MaxCacheAge,
                            LocalLookup
                            );

    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_INVALID_OBJECT:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_TYPE_MISMATCH:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            case NSI_S_NO_MORE_BINDINGS:

                *status = NSI_S_ENTRY_NOT_FOUND;

        /* N.B. This is all we really know, but the old locator did the above
            *status = NSI_S_OK;
        */
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }

        *InqContext = NULL;
    }

    raw_status = RpcRevertToSelf();

    DBGOUT(API, "\nExiting Lookup Begin with Status " << *status << "\n\n");
}


void
nsi_binding_lookup_next(
    OUT NSI_NS_HANDLE_T         InqContext,
    OUT NSI_BINDING_VECTOR_T ** BindingVectorOut,
    IN  UNSIGNED16            * status
    )
/*++

Routine Description:

    Continue a lookup operation.

Arguments:

    InqContext       - Context to continue with.

    BindingVectorOut - Pointer to return new vector of bindings

    status           - Status is returned here

Returned Status:

    NSI_S_OK, NSI_OUT_OF_MEMORY, NSI_S_NO_MORE_BINDINGS,
    NSI_S_INVALID_NS_HANDLE

--*/
{
    RPC_STATUS raw_status;

    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try {
        if (((CContextHandle *)InqContext)->myLocatorCount != LocatorCount)
            *BindingVectorOut = NULL;
        else {
            CLookupHandle *pHandle = (CLookupHandle *) InqContext;
            *BindingVectorOut = pHandle->next();
        }
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }

    if (!*BindingVectorOut)
       *status = NSI_S_NO_MORE_BINDINGS;
    else
       *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}


void
nsi_binding_lookup_done(
    IN OUT NSI_NS_HANDLE_T    * pInqContext,
    IN  UNSIGNED16            * pStatus
    )

/*++
Routine Description:

    Finish up a lookup operation.

Arguments:

    InqContext - Context to close

    status     - Status is returned here

Returned Status:

    NSI_S_OK

--*/

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *pStatus = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    NSI_NS_HANDLE_T_done(pInqContext,pStatus);

    raw_status = RpcRevertToSelf();
}


void nsi_mgmt_handle_set_exp_age(
    /* [in] */ NSI_NS_HANDLE_T inq_context,
    /* [in] */ UNSIGNED32 expiration_age,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)
/*++
Routine Description:

    Set cache tolerance (expiration) age for a specific NS handle.

Arguments:

    InqContext        - Context to set age for

    expiration_age    - expiration age in seconds

    status            - Status is returned here

Returned Status:

    NSI_S_OK

--*/

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    CContextHandle *pHandle = (CContextHandle *) inq_context;

    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    if (pHandle)

        __try {

        if (((CContextHandle *)inq_context)->myLocatorCount != LocatorCount)
            ;
        else
            pHandle->setExpiryAge(expiration_age);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            *status = (UNSIGNED16) GetExceptionCode();
        }

    raw_status = RpcRevertToSelf();
}


void nsi_mgmt_inq_exp_age(
    /* [out] */ UNSIGNED32 __RPC_FAR *expiration_age,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++
Routine Description:

    Check the global cache tolerance (expiration) age.

Arguments:

    expiration_age    - expiration age in seconds returned here

    status            - Status is returned here

Returned Status:

    NSI_S_OK

--*/
{
    RPC_STATUS raw_status;

    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    if (myRpcLocator->fNT4Compat)
        *expiration_age = myRpcLocator->ulMaxCacheAge;
    else
        *expiration_age = 0;

    *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}


void nsi_mgmt_inq_set_age(
    /* [in] */ UNSIGNED32 expiration_age,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)
/*++
Routine Description:

    Set the global cache tolerance (expiration) age.

Arguments:

    expiration_age    - new global expiration age in seconds

    status            - Status is returned here

Returned Status:

    NSI_S_OK

--*/
{
    /* No need for locks since the new value does not depend on the old
       and race conditions need not be dealt with -- the old value is
       as legitimate as the new
    */

    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    myRpcLocator->ulMaxCacheAge = expiration_age;

    QueryPacket NetRequest;
    if (myRpcLocator->fNT4Compat)
        myRpcLocator->broadcastCleared(NetRequest,myRpcLocator->ulMaxCacheAge);

    /* we also purge the broadcast history, if any, to reflect the new
       ulMaxCacheAge setting, with a phoney "clear broacast" request.
    */

    *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}

void nsi_entry_object_inq_begin(
    /* [in] */ UNSIGNED32 EntryNameSyntax,
    /* [in] */ STRING_T EntryName,
    /* [out] */ NSI_NS_HANDLE_T __RPC_FAR *InqContext,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    Perform an object inquiry, including all available information
    (owned, cached and from the network). Return a context handle for
    actual information.

Arguments:

    EntryNameSyntax   - Name syntax

    EntryName         - Name string to lookup on

    InqContext        - The NS context handle is returned here

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    DBGOUT(API, "\nLookup Begin for Entry " << EntryName << "\n\n");

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;


    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try {
        *InqContext =
            myRpcLocator->nsi_entry_object_inq_begin(
                            EntryNameSyntax,
                            pEntryName,
                            LocalLookup
                            );

    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_TYPE_MISMATCH:


                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }

        *InqContext = NULL;
    }

    raw_status = RpcRevertToSelf();

    DBGOUT(API, "\nExiting ObjectInq Begin with Status " << *status << "\n\n");
}

void nsi_entry_object_inq_next(
    /* [in] */ NSI_NS_HANDLE_T InqContext,
    /* [out][in] */ NSI_UUID_P_T uuid,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    Get the next object UUID from the given context handle.

Arguments:

    InqContext    - The NS context handle

    uuid          - a pointer to the UUID is returned here

Returned Status:

    NSI_S_OK, NSI_S_NO_MORE_MEMBERS

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    GUID * pgNextResult;
    __try {

        if (((CContextHandle *)InqContext)->myLocatorCount != LocatorCount)
            pgNextResult = NULL;
        else
            pgNextResult = ((CObjectInqHandle *) InqContext)->next();
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }
    if (!pgNextResult)
            *status = NSI_S_NO_MORE_MEMBERS;
    else {
        *status = NSI_S_OK;
        *uuid = *pgNextResult;
    }

    raw_status = RpcRevertToSelf();
}

void nsi_entry_object_inq_done(
    /* [out][in] */ NSI_NS_HANDLE_T __RPC_FAR *inq_context,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    NSI_NS_HANDLE_T_done(inq_context,status);

    raw_status = RpcRevertToSelf();
}



/*********  Locator-to-Locator Server-side API implementations *********/
// Locator-to-Locator interfaces do not impersonate because they are mainly
// calls to the normal interfaces and thus do not need them.


void
I_nsi_lookup_begin(
    handle_t hrpcPrimaryLocatorHndl,
    UNSIGNED32 EntryNameSyntax,
    STRING_T EntryName,
    RPC_SYNTAX_IDENTIFIER * Interface,
    RPC_SYNTAX_IDENTIFIER * XferSyntax,
    NSI_UUID_P_T Object,
    UNSIGNED32 VectorSize,
    UNSIGNED32 maxCacheAge,       // if nonzero, take it seriously
    NSI_NS_HANDLE_T *InqContext,
    UNSIGNED16 *status)
/*++
Routine Description:


Arguments:


Returns:

Comments:
    Some of the code is the same as nsi_lookup_begin
    but on the PDC we didn't want it to look in the DS.
    It only returns the results from the broadcast.
--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    NSI_INTERFACE_ID_T * InterfaceAndXfer = new NSI_INTERFACE_ID_T;


    CriticalReader  me(rwLocatorGuard);
    DBGOUT(BROADCAST, "Broadcast Lookup::Broadcast lookup request has arrived\n");

    if (Interface) InterfaceAndXfer->Interface = *Interface;
    else memset(&InterfaceAndXfer->Interface,0,sizeof(InterfaceAndXfer->Interface));

    if (XferSyntax) InterfaceAndXfer->TransferSyntax = *XferSyntax;
    else memset(&InterfaceAndXfer->TransferSyntax,0,sizeof(InterfaceAndXfer->TransferSyntax));

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;


    DBGOUT(TRACE, "Broadcast Lookup::Calling the normal lookup\n");

    DBGOUT(API, "\nLookup Begin Broadcast for Entry " << EntryName << "\n\n");

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    __try {
        *InqContext =
            myRpcLocator->nsi_binding_lookup_begin(
                            EntryNameSyntax,
                            pEntryName,
                            InterfaceAndXfer, OPT
                            Object, OPT
                            VectorSize,
                            maxCacheAge,
                            BroadcastLookup
                            );
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_INVALID_OBJECT:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_TYPE_MISMATCH:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

           case NSI_S_NO_MORE_BINDINGS:

                *status = NSI_S_ENTRY_NOT_FOUND;

        /* N.B. This is all we really know, but the old locator did the above
            *status = NSI_S_OK;
        */
                break;

           default:
                *status = NSI_S_INTERNAL_ERROR;
        }

        *InqContext = NULL;
    }

    if (*InqContext) {
        CLocToLocCompleteHandle *pltlHandle = new CLocToLocCompleteHandle(
                        (CCompleteHandle<NSI_BINDING_VECTOR_T> *)(*InqContext));
        // BUGBUG:: Will this wrapping affect the serialization that satish is talking abt.
        *InqContext = pltlHandle;

        /* here we are using a formerly unused parameter to avoid sending outdated info
           from the master.  this is only a partial solution but better than nothing */

        if ((*status == NSI_S_OK) && (maxCacheAge != 0))
            nsi_mgmt_handle_set_exp_age(
                pltlHandle->pcompleteHandle,
                maxCacheAge,
                status
                );

    }
    else
        *InqContext = NULL;

    delete InterfaceAndXfer;

    DBGOUT(API, "\nExiting Lookup Begin with Status " << *status << "\n\n");
}



void
I_nsi_lookup_done(
    handle_t hrpcPrimaryLocatorHndl,
    NSI_NS_HANDLE_T *InqContext,
    UNSIGNED16 *status)
/*++

Routine Description:


Arguments:


Returns:


--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    if (!(*InqContext))
        return;

    DBGOUT(BROADCAST, "Lookup Done called on LocToLoc Handle\n");

    CLocToLocCompleteHandle *pltlHandle =
             (CLocToLocCompleteHandle *)(*InqContext);

    DBGOUT(BROADCAST, "Local handle done called for LocToLoc Handle\n");
    nsi_binding_lookup_done((NSI_NS_HANDLE_T *)&(pltlHandle->pcompleteHandle), status);
    pltlHandle->pcompleteHandle = NULL;

    DBGOUT(BROADCAST, "Deleting LocToLoc Handle\n");
    delete pltlHandle;


    *InqContext = NULL;
}



void
I_nsi_lookup_next(
    handle_t hrpcPrimaryLocatorHndl,
    NSI_NS_HANDLE_T InqContext,
    NSI_BINDING_VECTOR_P_T *BindingVectorOut,
    UNSIGNED16 *status)
/*++

Routine Description:

Arguments:

Returns:

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    if (!InqContext)
        return;

    CLocToLocCompleteHandle *pltlHandle = (CLocToLocCompleteHandle *)InqContext;

    DBGOUT(TRACE, "Broadcast Lookup:: Next Called\n");

    do {
        nsi_binding_lookup_next(
            pltlHandle->pcompleteHandle,
            BindingVectorOut,
            status);

        if (!(*BindingVectorOut))
            return;
        else
            pltlHandle->StripObjectsFromAndCompress(BindingVectorOut);
    } while (!(*BindingVectorOut)->count);
}



void
I_nsi_entry_object_inq_next(
    IN  handle_t            hrpcPrimaryLocatorHndl,
    IN  NSI_NS_HANDLE_T     InqContext,
    OUT NSI_UUID_VECTOR_P_T *uuid_vector,
    OUT UNSIGNED16          *status
    )
/*++

Routine Description:

    Continue an inquiry for objects in an entry.

Arguments:

    InqContext    - Context to continue with

    uuid          - pointer to return object in.

    status        - Status is returned here

Returns:

    NSI_S_OK, NSI_S_NO_MORE_MEMBERS

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    __try {

        if (((CContextHandle *)InqContext)->myLocatorCount != LocatorCount)
            *uuid_vector = NULL;
        else
            *uuid_vector = getVector((CObjectInqHandle *) InqContext);
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }

    *status = NSI_S_OK;
}

void
I_nsi_ping_locator(
       handle_t h,
       error_status_t * Status
       )
{
    if (!fLocatorInitialized)
        InitializeLocator();

    *Status = 0;
}



void
I_nsi_entry_object_inq_begin(
    handle_t             hrpcPrimaryHandle,
    IN  UNSIGNED32       EntryNameSyntax,
    IN  STRING_T         EntryName,
    OUT NSI_NS_HANDLE_T *InqContext,
    OUT UNSIGNED16      *status
    )
/*++

Routine Description:

    Start a inquiry for objects in an entry.

Arguments:

    EntryNameSyntax    - Name syntax

    EntryName          - Name of the entry to find objects in

    InqContext         - Context to continue with for use with "Next"

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    DBGOUT(API, "\nLookup Begin for Entry " << EntryName << "\n\n");

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;

    __try {
        *InqContext =
            myRpcLocator->nsi_entry_object_inq_begin(
                            EntryNameSyntax,
                            pEntryName,
                            BroadcastLookup
                            );

    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_TYPE_MISMATCH:


                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }

        *InqContext = NULL; // new CContextHandle;  // i.e., a NULL handle
    }

    DBGOUT(API, "\nExiting ObjectInq Begin with Status " << *status << "\n\n");
}


void
I_nsi_entry_object_inq_done(
    IN OUT NSI_NS_HANDLE_T *pInqContext,
    OUT    UNSIGNED16      *pStatus
    )
/*++

Routine Description:

    Finish an inquiry on a object.

Arguments:

    InqContext - Context to close

    status - Status is returned here

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    NSI_NS_HANDLE_T_done(pInqContext,pStatus);
}

void nsi_group_mbr_add(
    /* [in] */ UNSIGNED32 group_name_syntax,
    /* [in] */ STRING_T group_name,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [in] */ STRING_T member_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    Add a member to the group. if the group doesn't exist create it.

Arguments:

    group_name_syntax  - Name syntax

    group_name         - Name of the group to add the member to

    member_name_syntax - Name syntax

    member_name        - Name of the member that has to be added

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try
    {
        myRpcLocator->nsi_group_mbr_add(
                group_name_syntax,
                group_name,
                member_name_syntax,
                member_name
                );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
        {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_ENTRY_ALREADY_EXISTS:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_GRP_ELT_NOT_ADDED:

        // the following converts ULONG to UNSIGNED16
        // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }

    raw_status = RpcRevertToSelf();
}

void nsi_group_mbr_remove(
    /* [in] */ UNSIGNED32       group_name_syntax,
    /* [in] */ STRING_T         group_name,
    /* [in] */ UNSIGNED32       member_name_syntax,
    /* [in] */ STRING_T         member_name,
    /* [out] */ UNSIGNED16 __RPC_FAR   *status)
/*++

Routine Description:

    Remove a member from the group.

Arguments:

    group_name_syntax  - Name syntax

    group_name         - Name of the group to remove the member from

    member_name_syntax - Name syntax

    member_name        - Name of the member that has to be removed

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/

{
    if (!fLocatorInitialized)
        InitializeLocator();

    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try
    {
            myRpcLocator->nsi_group_mbr_remove(
                        group_name_syntax,
                        group_name,
                        member_name_syntax,
                        member_name
                        );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
            {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_GRP_ELT_NOT_REMOVED:

            // the following converts ULONG to UNSIGNED16
            // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}

void nsi_group_mbr_inq_begin(
    /* [in] */ UNSIGNED32 group_name_syntax,
    /* [in] */ STRING_T group_name,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [out] */ NSI_NS_HANDLE_T __RPC_FAR *inq_context,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    enumerate members from the group.

Arguments:

    group_name_syntax  - Name syntax

    group_name         - Name of the group to enumerate

    member_name_syntax - Name syntax

    inq_context        - name service handle for next.

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try
    {
        *inq_context = myRpcLocator->nsi_group_mbr_inq_begin(
                            group_name_syntax,
                            group_name,
                            member_name_syntax
                            );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
        {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_ENTRY_NOT_FOUND:

            // the following converts ULONG to UNSIGNED16
            // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
        *inq_context = NULL;
    }
    raw_status = RpcRevertToSelf();
}

void nsi_group_mbr_inq_next(
    /* [in] */ NSI_NS_HANDLE_T InqContext,
    /* [out] */ STRING_T __RPC_FAR *member_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    enumerate members from the group.

Arguments:

    inq_context        - name service handle got from begin.

    member_name        - Name of the group to enumerate

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try {

        CGroupInqHandle *pHandle = (CGroupInqHandle *) InqContext;
        *member_name = pHandle->next();
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }

    if (!*member_name)
         *status = NSI_S_NO_MORE_MEMBERS;
    else *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}


void nsi_group_mbr_inq_done(
    /* [out][in] */ NSI_NS_HANDLE_T __RPC_FAR *pInqContext,
    /* [out] */ UNSIGNED16 __RPC_FAR *pStatus)

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *pStatus = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    NSI_NS_HANDLE_T_done(pInqContext,pStatus);

    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_add(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name,
    /* [in] */ NSI_IF_ID_P_T if_id,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [in] */ STRING_T member_name,
    /* [in] */ UNSIGNED32 priority,
    /* [in] */ STRING_T annotation,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    add elements from the profile.

Arguments:

    profile_name_syntax  - Name syntax of the profile

    profile_name         - Name of the profile.

    if_id        - interface id for the profile element.

    member_name_syntax   - Name syntax of the member.

    member_name      - Name of the member.

    priority         - Priority for the element.

    annotation       - Annotation for the element.

    status               - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try
    {
        myRpcLocator->nsi_profile_elt_add(
                                    profile_name_syntax,
                                    profile_name,
                                    if_id,
                                    member_name_syntax,
                                    member_name,
                                    priority,
                                    annotation
                                    );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
        {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_ENTRY_ALREADY_EXISTS:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_PROFILE_NOT_ADDED:
            case NSI_S_PRF_ELT_NOT_ADDED:

            // the following converts ULONG to UNSIGNED16
            // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_remove(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name,
    /* [in] */ NSI_IF_ID_P_T if_id,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [in] */ STRING_T member_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    remove element from the profile.

Arguments:

    profile_name_syntax  - Name syntax of the profile

    profile_name         - Name of the profile.

    if_id        - interface id for the profile element.

    member_name_syntax   - Name syntax of the member.

    member_name      - Name of the member.

    status               - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try
    {
            myRpcLocator->nsi_profile_elt_remove(
                                        profile_name_syntax,
                                        profile_name,
                                        if_id,
                                        member_name_syntax,
                                        member_name
                                        );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        switch (raw_status = GetExceptionCode())
            {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_PRF_ELT_NOT_REMOVED:
                // the following converts ULONG to UNSIGNED16
                    // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_inq_begin(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name,
    /* [in] */ UNSIGNED32 inquiry_type,
    /* [in] */ NSI_IF_ID_P_T if_id,
    /* [in] */ UNSIGNED32 vers_option,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [in] */ STRING_T member_name,
    /* [out] */ NSI_NS_HANDLE_T __RPC_FAR *inq_context,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    enumerate members elements from the profile depending on some criteria.

Arguments:

    profile_name_syntax  - Name syntax of the profile

    profile_name         - Name of the profile.

    inquiry_type     - type of inquiry. look in DCE spec.

    if_id        - interface id for the profile element.

    vers_option      - look in DCE spec.

    member_name_syntax   - Name syntax of the member.

    member_name      - Name of the member.

    priority         - Priority for the element.

    inq_context          - name service handle for next.

    status               - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try
    {
            *inq_context = myRpcLocator->nsi_profile_elt_inq_begin(
                                                            profile_name_syntax,
                                                            profile_name,
                                                            inquiry_type,
                                                            if_id,
                                                            vers_option,
                                                            member_name_syntax,
                                                            member_name
                                                            );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
        {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_ENTRY_NOT_FOUND:

                 // the following converts ULONG to UNSIGNED16
                 // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
        *inq_context = NULL;
    }
    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_inq_next(
    /* [in]  */ NSI_NS_HANDLE_T inq_context,
    /* [out] */ NSI_IF_ID_P_T if_id,
    /* [out] */ STRING_T __RPC_FAR *member_name,
    /* [out] */ UNSIGNED32 __RPC_FAR *priority,
    /* [out] */ STRING_T __RPC_FAR *annotation,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    enumerate members elements from the profile depending on some criteria.

Arguments:

    inq_context          - name service handle for next.

    if_id        - interface id for the profile element.

    member_name      - Name of the member.

    priority         - Priority for the element.

    annotation       - Annotation for the element.

    status               - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/

{
    if (!fLocatorInitialized)
        InitializeLocator();

    RPC_STATUS raw_status;

    CriticalReader  me(rwLocatorGuard);
    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try {

           CProfileInqHandle *pHandle = (CProfileInqHandle *) inq_context;
           CProfileElement *pElt = pHandle->next();

           if (pElt == NULL) Raise(NSI_S_NO_MORE_MEMBERS);

           *member_name = pElt->EntryName.copyAsMIDLstring();
           *priority = pElt->dwPriority;
           *annotation = CStringW::copyMIDLstring(pElt->pszAnnotation);
           *if_id = pElt->Interface.myIdAndVersion();
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }
    *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_inq_done(
    /* [out][in] */ NSI_NS_HANDLE_T __RPC_FAR *pInqContext,
    /* [out] */ UNSIGNED16 __RPC_FAR *pStatus)

/*++

Routine Description:

    close the handle

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    RPC_STATUS raw_status;

    CriticalReader  me(rwLocatorGuard);
    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *pStatus = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    NSI_NS_HANDLE_T_done(pInqContext,pStatus);

    raw_status = RpcRevertToSelf();
}



void nsi_mgmt_entry_delete(
    /* [in] */ UNSIGNED32 entry_name_syntax,
    /* [in] */ STRING_T entry_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    deletes an entry.

Arguments:
    entry_name_syntax   - syntax of the entry name

    entry_name      - entry name

    status      - status is returned here.


Comments:
    whether the entry was created by create or
    during export it deletes it recursively.
--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    RPC_STATUS raw_status;
    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try {
        myRpcLocator->nsi_mgmt_entry_delete(
                            entry_name_syntax,
                            entry_name,
                            AnyEntryType);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}


void nsi_mgmt_entry_create(
    /* [in] */ UNSIGNED32 entry_name_syntax,
    /* [in] */ STRING_T entry_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    Creates an entry in the DS.

Arguments:
    entry_name_syntax   - syntax of the entry name

    entry_name      - entry name

    status      - status is returned here.


Comments:
   Marks it to distinguish it from entries in which some activity has been done
   The mark is removed as soon as something is done in the locator.
   The marked entry can be deleted and another entry can be created in its
   place which is group/profile.

Reason:
   Present schema has seperate group, profile and server entry type.
   which is different from DCE spec.

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try {
        myRpcLocator->nsi_mgmt_entry_create(
                            entry_name_syntax,
                            entry_name);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_ENTRY_ALREADY_EXISTS:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}


void nsi_entry_expand_name(
    /* [in] */ UNSIGNED32 entry_name_syntax,
    /* [in] */ STRING_T entry_name,
    /* [out] */ STRING_T __RPC_FAR *expanded_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
   *status = NSI_S_UNIMPLEMENTED_API;
}

void nsi_group_delete(
    /* [in] */ UNSIGNED32 group_name_syntax,
    /* [in] */ STRING_T group_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
   *status = NSI_S_UNIMPLEMENTED_API;
}

void nsi_profile_delete(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
   *status = NSI_S_UNIMPLEMENTED_API;
}

void nsi_mgmt_entry_inq_if_ids(
    /* [in] */ UNSIGNED32 entry_name_syntax,
    /* [in] */ STRING_T entry_name,
    /* [out] */ NSI_IF_ID_VECTOR_T __RPC_FAR *__RPC_FAR *if_id_vec,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
    *status = NSI_S_UNIMPLEMENTED_API;
}


} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\linklist.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    linklist.cxx

Abstract:

	This module contains definitions of non inline member functions for the
	basic implementation class CLinkList.
	
Author:

    Satish Thatte (SatishT) 08/16/95  Created all the code below except where
									  otherwise indicated.

--*/

#include <locator.hxx>


extern char * LLname = "CLinkList";

extern char * Lname = "Link";

	
CLinkList::Link::Link(IDataItem* a, Link* n) {
	data = a; 
	next = n;
	fDeleteData = FALSE;
}

CLinkList::Link::~Link() {		// called when ref count goes to zero
	if (next) next->release(); 
	if (fDeleteData) delete data;  // should this be release?
}

	
void CLinkList::enque(IDataItem* x) 
{	// no hold() calls needed because the constructor does an implicit hold
	if (pLnkLast) pLnkLast = pLnkLast->next = new Link(x, NULL);
	else pLnkFirst = pLnkLast = new Link(x,NULL);

	ulCount++;
}

void 
CLinkList::push(IDataItem* x) 
{	// see comment above
	pLnkFirst = new Link(x, pLnkFirst);
	if (!pLnkLast) pLnkLast = pLnkFirst;

	ulCount++;
}



void
CLinkList::releaseAll(Link *pCurr) 

/*  The reason why this method doesn't just release pCurr is
    because we must avoid stack overflow caused by a runaway recursive
	release effect.  So we do this iteratively.  We must, however,
	make sure to stop if we hit a link that would not be deleted if 
	released because we are releasing the next one only to simulate
    the release that would happen due to deletion of the current link.
*/

{
	Link *pPrev = NULL;

	/* The invariant for the loop below is that pCurr->ulRefCount 
	   is 1 higher than it should be, if pCurr != NULL.
	*/

	while (pCurr && pCurr->willBeDeletedIfReleased()) {
		pPrev = pCurr;
		pCurr = pCurr->next;
		if (pCurr) pCurr->hold();
		pPrev->release();
	}

	if (pCurr) pCurr->release();

//	printStats();
}


IDataItem* 
CLinkList::pop() 

/*++
Routine Description:

	Delete first item in the CLinkList and return it
	
--*/

{
	if (!pLnkFirst) return NULL;
		
	IDataItem* result = pLnkFirst->data;
	Link* oldFirst = pLnkFirst;
	pLnkFirst = pLnkFirst->next;
	if (!pLnkFirst) pLnkLast = NULL;  // nothing left
	else pLnkFirst->hold();
	oldFirst->release();

	ulCount--;
	return result;
}
		
int
CLinkList::remove(IDataItem* pDI)  

/*++
Routine Description:

	Remove the specified item and return it -- using pointer equality. 

    The return value primarily acts as a flag notifying success/failure
	
--*/

{
	if (!pLnkFirst) return FALSE;			// empty list

	if (pLnkFirst->data == pDI) { 			// remove first item
		pop();
		return TRUE;
	}

	Link * pLnkPrev = pLnkFirst, * pLnkCurr = pLnkFirst->next;

	while (pLnkCurr && (pLnkCurr->data != pDI)) {
		pLnkPrev = pLnkCurr; pLnkCurr = pLnkCurr->next;
	}

	if (!pLnkCurr) return FALSE;			// not found

	/* pLnkCurr contains the item to be removed and it is not the only 
	   item in the list since it is not the first item */

	pLnkPrev->next = pLnkCurr->next;
	if (pLnkPrev->next) 
            pLnkPrev->next->hold();
        else
            pLnkLast = pLnkPrev;               // this is the new last element.

	pLnkCurr->release();

	ulCount--;
	return TRUE;
}

IDataItem* 
CLinkList::nth(long lOrdinal)

/*++
Routine Description:

	Simply return the Nth data item -- starting the count at 0.
	
--*/

{
	if (!pLnkFirst) return NULL;			// empty list

	Link * pLnkCurr = pLnkFirst;
	long lCount = 0;

	while (pLnkCurr && (lCount++ < lOrdinal))
		pLnkCurr = pLnkCurr->next;

	if (!pLnkCurr) return NULL;			// not found
	else return pLnkCurr->data;
}

void 
CLinkList::rotate(long lDegree)

/*++
Routine Description:

	This routine imagines that the list is in fact circular and 
	rotates it by lDegree -- using pop and enque for modularity.  
	We could actually move links around, but this operation is
	not frequent enough (once for every NS lookup). Here we pay the
	price of not having a true circular list (we moved away from
	the true circular list for ref counting).
	
--*/

{
	if (!pLnkFirst) return;	// nothing to rotate;

	IDataItem *pCurr;

	for (long i = 0; i < (lDegree % ulCount); i++) {
		pCurr = pop();
		enque(pCurr);
	}
}


	
IDataItem* 
CLinkList::find(IDataItem* pDI,			// item to find
				TcompFun comp			// (pointer to) comparison function
			   )

/*++
Routine Description:

	Unlike remove, this method is designed to use a client-supplied
	comparison function instead of pointer equality.  The comparison
	function is expected to behave like strcmp (returning <0 is less,
	0 if equal and >0 if greater).
	
--*/

{
	if (!pLnkFirst) return NULL;			// empty list

	Link * pLnkCurr = pLnkFirst;

	while (pLnkCurr && comp(pLnkCurr->data,pDI))
		pLnkCurr = pLnkCurr->next;

	if (!pLnkCurr) return NULL;			// not found
	else return pLnkCurr->data;
}


void CLinkList::catenate(CLinkList& ll)

/*++
Routine Description:

	append the argument list to the current one -- as is, not a copy
	
--*/

{
	if (!ll.pLnkFirst) return;	// nothing to catenate

	if (!pLnkFirst) pLnkFirst = ll.pLnkFirst;
	else pLnkLast->next = ll.pLnkFirst;

	pLnkLast = ll.pLnkLast;

	ulCount += ll.ulCount;

	/* we only need to hold the first link, because *it* holds the others */

	ll.pLnkFirst->hold();
}

void CLinkList::wipeOut() 

/*++
Routine Description:

	release all links and all data and reinitialize to empty list
	
--*/

{
	if (pLnkFirst) {

		Link *pCurr = pLnkFirst;

		do {
			pCurr->fDeleteData = TRUE;	// delete data when Link dies
			pCurr = pCurr->next;
		} while (pCurr);

		releaseAll(pLnkFirst);	// release as many links as you can, and do it
								// iteratively for robustness

		pLnkFirst = pLnkLast = NULL;
		ulCount = 0;
	}
}



CLinkListIterator::CLinkListIterator(CLinkList& source) {
	ptr = first = source.pLnkFirst;
	if (ptr) ptr->hold();
}




IDataItem* 
CLinkListIterator::next() {	// advance the iterator and return next IDataItem

		if (!ptr) return NULL;

		CLinkList::Link* tl = ptr;
		IDataItem* result = ptr->data;
		ptr = ptr->next;
		if (ptr) ptr->hold();
		tl->release();
		return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\dsedit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsedit.cxx
//
//--------------------------------------------------------------------------

/***************************************************************************
* dsedit.cxx
*      Author:         UShaji
*
* Contains:
*      The member functions that add/delete from DS.
*      Uses mainly functions defined in dsutils for setting
*      the various properties.
*  Issues:
*          Domain name for many of the DN has to be set up properly.
*
*
***************************************************************************/

#include <locator.hxx>

//+-------------------------------------------------------------------------
//
//  Function:  RemapErrorCode
// remaps error code to nsi
//--------------------------------------------------------------------------

DWORD RemapErrorCode(HRESULT ErrorCode)
{
    HRESULT RetCode;

    if (SUCCEEDED(ErrorCode))
        return S_OK;

    switch (ErrorCode) 
    {
        //            
        //  All kinds of failures due to ObjectNotFound
        //  due to non-existence of object OR 
        //         non-existent container OR
        //         invalid path specification
        //  Other than Access Denails
        //
        case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
        case HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED):    // understand what causes this
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_FOUND):   //  -do-
            
            RetCode = NSI_S_ENTRY_NOT_FOUND;                       // which object - specific error
            break;

        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS):
        case E_ADS_OBJECT_EXISTS:
            RetCode = NSI_S_ENTRY_ALREADY_EXISTS;
            break;

        //            
        //  The following errors should not be expected normally.
        //  Class Store schema mismatched should be handled correctly.
        //  Errors below may ONLY occur for corrupted data OR out-of-band changes
        //  to a Class Store content.

        case E_ADS_CANT_CONVERT_DATATYPE:
        case E_ADS_SCHEMA_VIOLATION:
        case HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE):
        case HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION):
            RetCode = NSI_S_UNSUPPORTED_NAME_SYNTAX;
            break;

        //            
        //  Any kinds of Access or Auth Denial
        //      return ACCESS_DENIED
        //

        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED):
        case HRESULT_FROM_WIN32(ERROR_DS_STRONG_AUTH_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_DS_CONFIDENTIALITY_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN):

            RetCode = NSI_S_NO_NS_PRIVILEGE;
            break;

        case E_ADS_BAD_PATHNAME:
        case HRESULT_FROM_WIN32(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX):  // this is wrong
            RetCode = NSI_S_INCOMPLETE_NAME;
            break;
        
        //            
        //  Out of Memory
        //

        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY):
            
            RetCode = NSI_S_OUT_OF_MEMORY;
            break;

        //            
        //  Any DNS, DS or Network failures
        //

        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_RESOLVING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_UNIQUE):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NO_MAPPING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_DOMAIN_ONLY):
        case HRESULT_FROM_WIN32(ERROR_DS_TIMELIMIT_EXCEEDED):
        case HRESULT_FROM_WIN32(ERROR_DS_BUSY):
        case HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE):
        case HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM):
        case HRESULT_FROM_WIN32(ERROR_TIMEOUT):
        case HRESULT_FROM_WIN32(ERROR_CONNECTION_REFUSED):
        case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
        case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
            RetCode = NSI_S_INTERNAL_ERROR;
            break;

        case HRESULT_FROM_WIN32(ERROR_DS_ADMIN_LIMIT_EXCEEDED):
             RetCode = NSI_S_NO_NS_PRIVILEGE;
             break;


        case E_INVALIDARG:
        case ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS:
            RetCode = NSI_S_ENTRY_ALREADY_EXISTS;
            break;

        default:
            RetCode = NSI_S_INTERNAL_ERROR;
    }

    DBGOUT(DIRSVC, "Error Code 0x%x remapped to 0x%x\n" << ErrorCode << RetCode);
    return RetCode;
}


//+-------------------------------------------------------------------------
//
//  Function:  UuidToStringEx
// no memory allocation.
//--------------------------------------------------------------------------

int UuidToStringEx(UUID *Uuid, WCHAR *StringUuid)
{
    swprintf(StringUuid, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        Uuid->Data1, Uuid->Data2, Uuid->Data3,
        Uuid->Data4[0], Uuid->Data4[1],
        Uuid->Data4[2], Uuid->Data4[3],
        Uuid->Data4[4], Uuid->Data4[5],
        Uuid->Data4[6], Uuid->Data4[7]);
    return 36;
}

BOOL SyntaxIdToString(RPC_SYNTAX_IDENTIFIER &SynId, WCHAR *StringSynId)
{
    UuidToStringEx(&SynId.SyntaxGUID, StringSynId);
    wsprintf(StringSynId+wcslen(StringSynId), L".%04d.%04d",
        SynId.SyntaxVersion.MajorVersion%10000,
        SynId.SyntaxVersion.MinorVersion%10000
        );
    return TRUE;
}

BOOL SyntaxIdFromString(RPC_SYNTAX_IDENTIFIER &SynId, WCHAR *StringSynId)
{
    WCHAR    *endptr = NULL;

    if (wcslen(StringSynId) < STRINGGUIDVERSIONLEN)
        return FALSE;

    StringSynId[STRINGGUIDLEN] = L'\0';
    StringSynId[STRINGMAJVERSIONLEN] = L'\0';

    UuidFromString(StringSynId, &SynId.SyntaxGUID);
    SynId.SyntaxVersion.MajorVersion = (unsigned short)wcstoul(StringSynId+STRINGGUIDLEN+1,
        &endptr, 10);
    SynId.SyntaxVersion.MinorVersion = (unsigned short)wcstoul(StringSynId+STRINGMAJVERSIONLEN+1,
        &endptr, 10);
    return TRUE;
}

void FreeAttr(ADS_ATTR_INFO attr)
{
    delete attr.pADsValues;
}

// Note: None of these APIs copies anything into their own buffers.
// It allocates a buffer for adsvalues though.

// packing a property's value into a attribute structure
// for sending in with a create/modify.
void PackStrArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty,
                      WCHAR **pszAttr, DWORD num)
{
    DWORD    i;

    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;

    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_DN_STRING;
    attr->pADsValues = new ADSVALUE[num];

    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_DN_STRING;
        attr->pADsValues[i].DNString = pszAttr[i];
    }
}

void PackIntArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, int *pAttr, DWORD num)
{
    DWORD    i;

    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;

    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;

    attr->dwADsType = ADSTYPE_INTEGER;
    attr->pADsValues = new ADSVALUE[num];

    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_INTEGER;
        attr->pADsValues[i].Integer = pAttr[i];
    }
}

void PackStrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, WCHAR *szAttr)
{
    if (szAttr)
        PackStrArrToAttr(attr, szProperty, &szAttr, 1);
    else
        PackStrArrToAttr(attr, szProperty, &szAttr, 0);
}

void PackIntToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, int Attr)
{
    PackIntArrToAttr(attr, szProperty, &Attr, 1);
}


HRESULT Delete(STRING_T DN, STRING_T RDN, STRING_T szDomain)
{
    HANDLE   hDSObject = NULL;
    WCHAR   *szFullName=NULL;
    HRESULT  hr = S_OK;

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen(szDomain)+1+wcslen(DN)+1];
    if (!szFullName)
        return E_OUTOFMEMORY;

    wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, szDomain, DN);

    DBGOUT(DIRSVC, "Delete:: Opening " << szFullName << "in the DS\n");
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hDSObject);

    if (SUCCEEDED(hr))
        hr = ADSIDeleteDSObject(hDSObject, RDN);

    if (hDSObject)
        ADSICloseDSObject(hDSObject);

    delete szFullName;

    return hr;
}

// if the entry exists it tries to modify other wise create.
// This function has so many parameters because the adsldpc.dll
// does not take attributes that have zero values.
//
// setting an attribute of an already existing entry, we can not
// set objectclass and in creation we can not set/clear zero valued
// attributes.
// DN       - Domain Name of the container.
// RDN      - The name of the entry to be created.
// pAttr    - attributes to be set. first one has to be objectclass.
// cAttr    - Number of attributes.
// cCreateAttr  - Number of attributes to be set if it is being created.
//        empty attributes should not be set.
// ChkEntry - A boolean flag to see if the entry was created by
//        create in which case it should delete it.
//        (Has to be set to true in case of entries.

HRESULT UpdateOrCreateEx(WCHAR *DN, WCHAR *RDN, WCHAR *szDomain, ADS_ATTR_INFO *pAttr,
		         DWORD cAttr, DWORD cCreateAttr, BOOL ChkEntry)
{
    WCHAR              * szFullName=NULL, * szParentFullName=NULL, *pszDesc = L"";
    LPWSTR               szAttrName = DESCRIPTION;
    HANDLE               hDSObject;
    DWORD                modified;
    HRESULT              hr = S_OK;
    ADS_ATTR_INFO      * pAttrGot = NULL;
    DWORD                cgot;

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen(szDomain)+1+wcslen(RDN)+1+wcslen(DN)+1];
    if (!szFullName)
        return E_OUTOFMEMORY;
    wsprintf(szFullName, L"%s%s/%s,%s", RPCCONTAINERPREFIX, szDomain, RDN, DN);

    szParentFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen(szDomain)+1+wcslen(DN)+1];
    if (!szParentFullName) {
        delete szFullName;
        return E_OUTOFMEMORY;
    }
    wsprintf(szParentFullName, L"%s%s/%s", RPCCONTAINERPREFIX, szDomain, DN);

    DBGOUT(DIRSVC, "UpdateOrCreateEx Opening " << szFullName << "in the DS\n");

    // see whether it already exists.
    hr =  ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION, &hDSObject);

    // BUGBUG:: Bind doesn't return file not found.
    if (SUCCEEDED(hr))
    {
        if (ChkEntry)
        {
            // if it was created, delete. This value will exist for all valid entries.
            hr = ADSIGetObjectAttributes(hDSObject, &szAttrName, 1, &pAttrGot, &cgot);
            if ((SUCCEEDED(hr)) && (cgot))
            {
                pszDesc = UnpackStrFrom(pAttrGot[0]);
                if ((!pszDesc) || (wcscmp(pszDesc, CREATED_DESCRIPTION) == 0))
                {
                    ADSICloseDSObject(hDSObject);
                    hr = Delete(DN, RDN, szDomain);
                    if (SUCCEEDED(hr))
                        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                    // if we deleted we would like to recreate it.
                }
                else
                {
                    if (cAttr)
                        hr = ADSISetObjectAttributes(hDSObject, pAttr+1, cAttr, &modified);
                    ADSICloseDSObject(hDSObject);
                }
            }
        }
        else
        {
            if (cAttr)
                hr = ADSISetObjectAttributes(hDSObject, pAttr+1, cAttr, &modified);
            ADSICloseDSObject(hDSObject);
        }
    }

    if (SUCCEEDED(hr)) {
        delete szFullName;
        delete szParentFullName;
        return hr;
    }

    if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        DBGOUT(DIRSVC, "Returned hr = " << hr << "in open\n");

    if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR))
    {
        WCHAR errbuf[256], namebuf[256];
        DWORD err;

        ADsGetLastError(&err, errbuf, 256, namebuf, 256);
        DBGOUT(DIRSVC, "Error," << err << "errbuf = " << errbuf << "namebuf = " << namebuf << "\n");

        delete szFullName;
        delete szParentFullName;
        return hr;
    }

    DBGOUT(DIRSVC, "UpdateOrCreateEx Opening " << szParentFullName << "in the DS\n");
    hr = ADSIOpenDSObject(szParentFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hDSObject);
    if (SUCCEEDED(hr))
    {
        hr = ADSICreateDSObject(hDSObject, RDN, pAttr, cCreateAttr);
        ADSICloseDSObject(hDSObject); // opened abv.
    }

    if (FAILED(hr))
        DBGOUT(DIRSVC, "Returned hr = " << hr << "in create\n");

    if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR))
    {
        WCHAR errbuf[256], namebuf[256];
        DWORD err;

        ADsGetLastError(&err, errbuf, 256, namebuf, 256);
        DBGOUT(DIRSVC, "Error," << err << "errbuf = " << errbuf << "namebuf = " << namebuf << "\n");

        delete szFullName;
        delete szParentFullName;
        return hr;
    }

    delete szFullName;
    delete szParentFullName;
    return hr;
}

HRESULT UpdateOrCreate(WCHAR *DN, WCHAR *RDN, WCHAR *szDomain, ADS_ATTR_INFO *pAttr,
		       DWORD cAttr, DWORD cCreateAttr)
{
    return UpdateOrCreateEx(DN, RDN, szDomain, pAttr, cAttr, cCreateAttr, FALSE);
}
// for entries 1 more criteria is that the entry type might have to be modified
// if it was created by create and a group or profile tries to export to
// that.

HRESULT UpdateOrCreateEntry(WCHAR *DN, WCHAR *RDN, WCHAR *szDomain, ADS_ATTR_INFO *pAttr, DWORD cAttr, DWORD cCreateAttr)
{
    return UpdateOrCreateEx(DN, RDN, szDomain, pAttr, cAttr, cCreateAttr, TRUE);
}

// This function can be called without actually calling the addtods function
// for the corresp. server entry. Hence the call to bind to the server is in
// code. adsldp keeps the security data corresp. to the user and doesn't go
// again on the network only if there is some handle that is not yet closed.
//
// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, TRANSFERSYNTAX, INTERFACEID, BINDINGS
//

HRESULT CInterface::AddToDS()
{
    ULONG                   sz = 0;
    HRESULT                 hr = S_OK;
    RPC_SYNTAX_IDENTIFIER   in;
    STRINGGUID              szGUID;
    STRINGGUIDVERSION       szIdVersion, szXferSyntax;
    WCHAR                ** pszBindings;
    WCHAR                 * szRDN=NULL;
    WCHAR                 * DNParentName = NULL;
    ADS_ATTR_INFO           pAttr[4];
    DWORD                   i, cAttr = 3, cCreateAttr = 4, cTotalAttr = 4;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    SyntaxIdToString(myIdAndVersion(), szIdVersion);
    // interface id and version

    szRDN= new WCHAR[3+wcslen(szIdVersion)+1];

    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", szIdVersion);

    PackStrToAttr(pAttr+0, CLASSNAME, RPCSERVERELEMENTCLASS);
    // class
    PackStrToAttr(pAttr+1, INTERFACEID, szIdVersion);
    // Name

    SyntaxIdToString(xferSyntaxIdAndVersion(), szXferSyntax);
    PackStrToAttr(pAttr+2, TRANSFERSYNTAX, szXferSyntax);
    // transfer syntax of the interface.

    pszBindings = new LPWSTR[sz = pBVhandles->size()];
    if (!pszBindings)
        hr = E_OUTOFMEMORY;

    // storing all the bindings.
    if (SUCCEEDED(hr))
    {
        TCSafeSkipListIterator<CStringW> BVIter(*pBVhandles);

        for (i = 0; i < sz; i++)
            pszBindings[i] = *(BVIter.next());

        if (!sz)
            cCreateAttr--;
        PackStrArrToAttr(pAttr+3, BINDINGS, pszBindings, sz);

        DBGOUT(DIRSVC, "Trying to Store Interface " << szRDN << "in the DS\n");

        DNParentName = m_pMyEntry->getFullDNAlloc();
        hr = UpdateOrCreate(DNParentName, szRDN, *(m_pMyEntry->getDomainNameDns()), pAttr,
			   cAttr, cCreateAttr);

	delete DNParentName;
    }

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Interface " << szRDN << "in the DS\n\n");

    delete pszBindings;
    delete szRDN;

    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);
    return hr;
}


HRESULT CInterface::DeleteFromDS()
{
    HRESULT                 hr=S_OK;
    WCHAR                  *szRDN=NULL;
    STRINGGUIDVERSION       szIdVersion;
    RPC_SYNTAX_IDENTIFIER   in;
    WCHAR                  *DNParentName = NULL;


    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    SyntaxIdToString(myIdAndVersion(), szIdVersion);

    szRDN= new WCHAR[3+wcslen(szIdVersion)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", szIdVersion);

    DNParentName = m_pMyEntry->getFullDNAlloc();

    DBGOUT(DIRSVC, "Trying to Delete Interface " << szRDN << "from the DS\n");

    hr = Delete(DNParentName, szRDN, *(m_pMyEntry->getDomainNameDns()));

    delete DNParentName;

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Interface " << szRDN << "from the DS \n\n");

    delete szRDN;

    return hr;
}

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, PROFILE, PROFILE1, PRIORITY, INTERFACEID, ANNOTATION

HRESULT CProfileElement::AddToDS()
{
    HRESULT                 hr = S_OK;
    RPC_SYNTAX_IDENTIFIER   in;
    STRINGGUID              szGUID;
    STRINGGUIDVERSION       szIdVersion;
    WCHAR                 * szRDN=NULL;
    WCHAR                 * DNParentName = NULL, *szEntryName = NULL;
    ADS_ATTR_INFO           pAttr[5];
    DWORD                   i, cAttr = 4, cCreateAttr = 5, cTotalAttr = 5;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN = new WCHAR[3+wcslen((STRING_T)*EntryName.getEntryName())+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    PackStrToAttr(pAttr+0, CLASSNAME, RPCPROFILEELEMENTCLASS);
    // class

    PackStrToAttr(pAttr+1, PROFILE, szEntryName = EntryName.getFullDNWithDomainAlloc());
    // link to the real entry.

    PackIntToAttr(pAttr+2, PRIORITY, dwPriority);
    // priority

    SyntaxIdToString(Interface.myIdAndVersion(), szIdVersion);
    PackStrToAttr(pAttr+3, INTERFACEID, szIdVersion);
    // interface id

    if ((!pszAnnotation) || (!wcslen(pszAnnotation))) {
        cCreateAttr--;
        PackStrToAttr(pAttr+4, ANNOTATION, NULL);
    }
    else
        PackStrToAttr(pAttr+4, ANNOTATION, pszAnnotation);
    // annotation

    DNParentName = m_pMyEntry->getFullDNAlloc();

    wsprintf(szRDN, L"CN=%s", (STRING_T)*EntryName.getEntryName());

    DBGOUT(DIRSVC, "Trying to Store Profile Element " << szRDN << "in the DS\n");

    hr = UpdateOrCreate(DNParentName, szRDN, *(m_pMyEntry->getDomainNameDns()),
			pAttr, cAttr, cCreateAttr);

    delete DNParentName;

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Profile ELement " << szRDN << "in the DS\n\n");

    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);

    delete szEntryName;
    delete szRDN;

    return hr;
}


HRESULT CProfileElement::DeleteFromDS()
{
    HRESULT                 hr=S_OK;
    WCHAR                  *szRDN=NULL;
    WCHAR                  *DNParentName = NULL;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to delete from DS");

    szRDN = new WCHAR[3+wcslen((STRING_T)*EntryName.getEntryName())+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    DNParentName = m_pMyEntry->getFullDNAlloc();

    wsprintf(szRDN, L"CN=%s", (STRING_T)(*(EntryName.getEntryName())));

    DBGOUT(DIRSVC, "Trying to delete Profile Element " << szRDN << "from the DS\n");

    hr = Delete(DNParentName, szRDN, *(m_pMyEntry->getDomainNameDns()));

    delete DNParentName;

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Profile Element " << szRDN << "from the DS \n\n");

    delete szRDN;
    return hr;
}

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, GROUP, GROUP1, DESCRIPTION, GROUP
HRESULT CGroupEntry::AddToDS()
{
    HRESULT                 hr = S_OK;
    ULONG                   i, sz;
    CEntryName             *EntryName = NULL;
    WCHAR                 **pszGroupList = NULL;
    WCHAR                  *szRDN=NULL;
    ADS_ATTR_INFO           pAttr[3];
    DWORD                   cAttr = 2, cTotalAttr = 3, cCreateAttr = 3;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    PackStrToAttr(pAttr+0, CLASSNAME, RPCGROUPCLASS);
    // class

    PackStrToAttr(pAttr+1, DESCRIPTION, L"RPC Group Entry");
    // description

    // BUGBUG:: Object IDs.??

    pszGroupList = new LPWSTR[sz = GroupList.size()];
    if (!pszGroupList)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        TCSafeSkipListIterator<CEntryName> GroupIter(GroupList);

        for (i = 0; i < sz; i++) {
            EntryName = GroupIter.next();
            pszGroupList[i] = (EntryName->getFullDNWithDomainAlloc());
        }

        if (!sz)
            cCreateAttr--;
        PackStrArrToAttr(pAttr+2, GROUP, pszGroupList, sz);
        // links to group entries
    }
    // BUGBUG:: Hack waiting for schema changes.
    DBGOUT(DIRSVC, "Storing the Group Entry " << szRDN << "in the DS\n\n");


    if (SUCCEEDED(hr))
        hr = UpdateOrCreateEntry(*getRpcContainer(), szRDN, *getDomainNameDns(), pAttr, cAttr, cCreateAttr);

    if (pszGroupList)
       for (i = 0; i < GroupList.size(); i++)
	  delete pszGroupList[i];
    delete pszGroupList;

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Group Entry " << szRDN << "in the DS\n\n");

    delete szRDN;
    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);
    return hr;
}


HRESULT CGroupEntry::DeleteFromDS()
{
    HRESULT                 hr=S_OK;
    WCHAR                  *szRDN=NULL;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    DBGOUT(DIRSVC, "Trying to Delete Group Entry " << szRDN << "from the DS\n");

    hr = Delete(*getRpcContainer(), szRDN, *getDomainNameDns());

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Group Entry " << szRDN << "from the DS \n\n");

    delete szRDN;

    return hr;
}

// Created entry is of type server entry and hence would not
// require to check whether the entry was created by create etc.

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, DESCRIPTION, OBJECTID

HRESULT CServerEntry::AddToDS()
{
    HRESULT                  hr = S_OK;
    ULONG                    i, sz;
    CGUID                   *Object;
    GUID                     ObjectGuid;
    WCHAR                   *szRDN=NULL;
    WCHAR                  **pszGuid=NULL;
    ADS_ATTR_INFO            pAttr[3];
    DWORD                    cAttr = 2, cCreateAttr = 3, cTotalAttr = 3;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    DBGOUT(DIRSVC, "Trying to Store Server Entry " << szRDN << "in the DS\n");

    PackStrToAttr(pAttr+0, CLASSNAME, RPCSERVERCONTAINERCLASS);
    // class

    PackStrToAttr(pAttr+1, DESCRIPTION, L"RPC Server Container");
    // description

    if (SUCCEEDED(hr)) {
        sz = ObjectList.size();
        pszGuid = new LPWSTR[sz];
        if (!pszGuid)
            hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr)) {
        TCSafeSkipListIterator<CGUID> ObjectIterator(ObjectList);

        for (i = 0; i < sz; i++) {
            Object = ObjectIterator.next();
            ObjectGuid = Object->myGUID();
            UuidToString(&ObjectGuid, &pszGuid[i]);
        }
        if (!sz)
            cCreateAttr--;
        PackStrArrToAttr(pAttr+2, OBJECTID, pszGuid, sz);
    }
    // convert and store object uuids.

    if (SUCCEEDED(hr))
        hr = UpdateOrCreate(*getRpcContainer(), szRDN, *getDomainNameDns(), pAttr, cAttr, cCreateAttr);

    for (i = 0; i < sz; i++)
        RpcStringFree(&pszGuid[i]);
    delete pszGuid;

    //BUGBUG::Codeset??

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Server Entry " << szRDN << "in the DS\n\n");

    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);
    delete szRDN;
    return hr;
}

HRESULT CServerEntry::DeleteFromDS()
{
    HRESULT                 hr=S_OK;
    WCHAR                  *szRDN=NULL;
    int                     i, sz;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;
    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    DBGOUT(DIRSVC, "Trying to Delete Server Entry " << szRDN << "in the DS\n");

    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);
    CInterface *pintf = NULL;

    sz = InterfaceList.size();
    for (i = 0; i < sz; i++) {
        pintf = IfIter.next();
        pintf->DeleteFromDS();
    }
    // Deleting all the interfaces listed under it from the DS.

    hr = Delete(*getRpcContainer(), szRDN, *getDomainNameDns());

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Server Entry " << szRDN << "in the DS\n\n");

    delete szRDN;
    return hr;
}

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, DESCRIPTION

HRESULT CProfileEntry::AddToDS()
{
    HRESULT                 hr = S_OK;
    WCHAR                  *szRDN=NULL;
    ADS_ATTR_INFO           pAttr[2];
    DWORD                   i, cAttr = 1, cCreateAttr = 2, cTotalAttr = 2;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;
    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);
    DBGOUT(DIRSVC, "Trying to Store Profile Entry " << szRDN << "in the DS\n");

    PackStrToAttr(pAttr+0, CLASSNAME, RPCPROFILECONTAINERCLASS);
    PackStrToAttr(pAttr+1, DESCRIPTION, L"RPC Profile Container");

    hr = UpdateOrCreateEntry(*getRpcContainer(), szRDN, *getDomainNameDns(), pAttr, cAttr, cCreateAttr);

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Profile Entry " << szRDN << "in the DS\n\n");

    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);

    delete szRDN;
    return hr;
}


HRESULT CProfileEntry::DeleteFromDS()
{
    HRESULT                 hr = S_OK;
    WCHAR                  *szRDN=NULL;
    DWORD                   i, sz;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    DBGOUT(DIRSVC, "Trying to Delete Profile Entry " << szRDN << "from the DS\n");

    if (pDefaultElt)
        pDefaultElt->DeleteFromDS();

    TCSafeSkipListIterator<CProfileElement> PEIter(EltList);
    CProfileElement *pProfileElement;
    sz = EltList.size();

    for (i = 0; i < sz; i++) {
        pProfileElement = PEIter.next();
        pProfileElement->DeleteFromDS();
    }
    // deleting all the profile elements under it.

    hr = Delete(*getRpcContainer(), szRDN, *getDomainNameDns());

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Profile Entry " << szRDN << "from the DS \n\n");

    delete szRDN;
    return hr;
}

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, DESCRIPTION

HRESULT
Locator::CreateEntryInDS(CEntryName *pEntryName)
{
    HRESULT                 hr = S_OK;
    WCHAR                  *szFullName=NULL, *szRDN=NULL;
    CStringW              * pLocalName;
    ADS_ATTR_INFO           pAttr[2];
    HANDLE                  hDSObject;
    DWORD                   i, cAttr = 0;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    pLocalName = pEntryName->getEntryName();
    szRDN = new WCHAR[3+wcslen((STRING_T)*pLocalName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen((STRING_T)(*(pEntryName->getDomainNameDns())))+1+
                           wcslen((STRING_T)(*(pEntryName->getRpcContainer())))+1];

    if (!szFullName) {
        delete szRDN;
        return E_OUTOFMEMORY;
    }

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pLocalName);
    wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, (STRING_T)(*(pEntryName->getDomainNameDns())),
                                     (STRING_T)(*(pEntryName->getRpcContainer())));

    DBGOUT(DIRSVC, "Trying to Create Entry " << szRDN << "in the DS\n");

    // Try to create the entry.

    DBGOUT(DIRSVC, "CreateEntryInDS Opening " << szFullName << "in the DS\n");
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hDSObject);
    if (SUCCEEDED(hr)) {
        PackStrToAttr(pAttr+cAttr, CLASSNAME, RPCSERVERCONTAINERCLASS); cAttr++;
        PackStrToAttr(pAttr+cAttr, DESCRIPTION, CREATED_DESCRIPTION); cAttr++;
        hr = ADSICreateDSObject(hDSObject, szRDN, pAttr, cAttr);
        ADSICloseDSObject(hDSObject);
    }

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Created Entry " << szRDN << "in the DS\n\n");

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);

    delete szRDN;
    delete szFullName;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\locator.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    stubs.cxx

Abstract:

    This module contains stubs for unimplemented API functions.

Author:

    Satish Thatte (SatishT) 08/16/95  Created all the code below except where
                                      otherwise indicated.

--*/

#include <locator.hxx>

/***********                                                            **********/
/***********   constructor and utility operations in the Locator class  **********/
/***********                                                            **********/

// int fTriedConnectingToDS;


Locator::Locator()
/*++
Member Description:

    Constructor.  Initializes the state of the locator, including discovering whether
    it is running in a domain or workgroup, and the names of DCs, if any.  In a domain,
    if the PDC machine (not just the PDC locator) is down, the environment is initialized
    to workgroup instead of domain.

    It contacts the DS and gets the DNS name of the domain, gets the compatibilty
    flag for the domain before going any further.

--*/
{

    //    fTriedConnectingToDS = 0;
    NTSTATUS          Status;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pdsrole;

    // This contains various flags whether we are in workgroup, DNS name of the domain
    // etc.

    DBGOUT(DIRSVC, "Calling DsRoleGetPrimaryDomainInformation\n");

    Status = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *)&pdsrole);
    if (!NT_SUCCESS(Status) || (!pdsrole))
        Raise(NSI_S_INTERNAL_ERROR);

    DBGOUT(DIRSVC, "DsRoleGetPrimaryDomainInformation returned Status\n");

    // gets info abt. the DNS name of the m/c and
    // the compatibility flag

    SetConfigInfoFromDS(*pdsrole);

    srand( (unsigned)time( NULL ) );

    // all the info related with whether it is running in a domain,
    // the PDC name etc. is required only if we have to support
    // NT4 clients. In a pure NT5 Domain we do not need this.

    if (fNT4Compat)
        SetCompatConfigInfo(*pdsrole);

    DsRoleFreeMemory(pdsrole);
    SetSvcStatus();
}


Locator::~Locator()
/*++
Member Description:

    Destructor.

--*/
{
    delete pDomainName;
    delete pDomainNameDns;
    delete pRpcContainerDN;

    if (fNT4Compat) {
        delete pComputerName;
        delete pPrimaryDCName;
        SetSvcStatus();
        pInternalCache->wipeOut();
        delete pInternalCache;

        PCSBroadcastHistory.Enter();
        SetSvcStatus();
        psllBroadcastHistory->wipeOut();
        delete psllBroadcastHistory;

        SetSvcStatus();
        pAllMasters->wipeOut();
        delete pAllMasters;

        SetSvcStatus();
        delete pCacheInterfaceIndex;
        delete hMailslotForReplies;
        delete hMasterFinderSlot;
    }
    DBGOUT(BROADCAST, "Destroying locator structure\n");
}


CFullServerEntry *
Locator::GetEntryFromCache(
    IN UNSIGNED32    EntryNameSyntax,
    IN STRING_T      EntryName
    )
/*++
Member Description:

    Get the given entry locally.
    Raise exceptions if anything is wrong.

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       - Name string of the entry to export

    Interface       - Interface to standardize

Returns:

    The entry found -- NULL if none.

--*/
{

    if (EntryNameSyntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!EntryName) Raise(NSI_S_INCOMPLETE_NAME);

    /* The constructor for CEntryName used below makes the name local if possible */

    CStringW * pswName = new CStringW(CEntryName(EntryName));
    CFullServerEntry * pFSEntry = NULL;

    __try {
        pFSEntry = pInternalCache->find(pswName);
    }

    __finally {
        delete pswName;
    }

    return pFSEntry;
}


/***********                                               **********/
/***********   primary API operations in the Locator class **********/
/***********                                               **********/

BOOL Locator::nsi_binding_export(
    IN UNSIGNED32                         EntryNameSyntax,
    IN STRING_T                           EntryName,
    IN NSI_INTERFACE_ID_T            *    Interface,
    IN NSI_SERVER_BINDING_VECTOR_T   *    BindingVector,
    IN NSI_UUID_VECTOR_P_T                ObjectVector,
    IN ExportType                         type
    )
/*++
Member Description:

    This is basically the API function for binding export.  The member version
    here does raise exception (often inside a try block) but they are all error
    situations and therefore acceptable for performance.  This member is also used
    for updating the locator's cache.

Arguments:

    EntryNameSyntax - Name syntax, optional

    EntryName       - (raw) Name of the entry to look up, optional

    Interface       - (raw) Interface+TransferSyntax to export

    BindingVector   - (raw) Vector of string bindings to export.

    ObjectVector    - (raw) Vector of object UUIDs to add to the entry

    type            - local or nonlocal (owned or imported information)

 Returns:

    true if there were changes to the entry, false o/w.

 Exceptions:

    NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY, NSI_S_INVALID_OBJECT, NSI_S_NOTHING_TO_EXPORT,
    NSI_S_ENTRY_TYPE_MISMATCH

Comments:
   Called when the export happens from a client
   or when we want to store a broadcast reply
   in the cache.

   If the export is happening directly
      1. add it to the DS.
      2. add it to the cache as an owned entry (only if NT4Compat flag is on)

   if the export is happening to store broadcast replies
      1. add it to the cache as non owned member
--*/
{
    int                fChanges = FALSE, fNewEntry = FALSE, fDSNewEntry = FALSE;
    CServerEntry     * pRealEntry = NULL;
    HRESULT            hr = S_OK;
    CFullServerEntry * pFSEntry = NULL;
    CEntry           * pDSEntry = NULL;

    // entries get into the DS, through this entry.
    // DS might have come up later and the old entry found
    // in the cache should still go to DS. Hence a seperate
    // fDSNewEntry flag.

    // validate
    if (Interface && IsNilIfId(&(Interface->Interface))) Interface = NULL;

    if (!ObjectVector && (!Interface || !BindingVector))
        Raise(NSI_S_NOTHING_TO_EXPORT);

    if (type == Local) {
        // get entry from the DS, whatever Compat flag is if export is Local.
        if (fDSEnabled)
            pDSEntry = GetEntryFromDS(EntryNameSyntax, EntryName);        

        if ((pDSEntry) && (pDSEntry->getType() != ServerEntryType))
        {
            // if there is an entry in the DS with a different type raise an exception.
            DBGOUT(TRACE, "Entry found and is not of the type FSEntryType\n");
            delete pDSEntry;
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
        }

        // if not found.
        if ((!pDSEntry) && (fDSEnabled)) {
            pDSEntry = new CServerEntry(EntryName);
            fDSNewEntry = TRUE;
        }
    }

    if (fNT4Compat) {
        // Look whether the entry exists in the local machine.

        pFSEntry = GetEntryFromCache(
            EntryNameSyntax,
            EntryName
            );

        ASSERT(!((pFSEntry) && (pFSEntry->getType() != FullServerEntryType)),
            "Wrong Entry type found in cache\n");

        if (!pFSEntry) {
            fNewEntry = fChanges = TRUE;

            // if entry doesn't exist, create a new Full Server entry.
            // NOTE: SECURITY: need extra check here

            pFSEntry = new CFullServerEntry(EntryName);

            if (!pFSEntry) 
                Raise (NSI_S_OUT_OF_MEMORY);

            pInternalCache->insert(pFSEntry);
        }

        switch (type) {
        case Local:
            pRealEntry = pFSEntry->getLocal();
            break;
        case NonLocal:
            pRealEntry = pFSEntry->getNonLocal();
        }
    }

    __try
    {
        DBGOUT(DIRSVC, "exporting now to the server entry\n");

        if (fNT4Compat) {
            // put it in the cache, local or NonLocal (depending on type)
            fChanges = pRealEntry->add_to_entry(
                Interface,
                BindingVector,
                ObjectVector,
                pCacheInterfaceIndex,
                FALSE
                )
                || fChanges;
            DBGOUT(DIRSVC, "exported to the local server entry\n");
        }

        if (pDSEntry) {
            ((CServerEntry *)pDSEntry)->add_changes_to_DS(
                Interface,
                BindingVector,
                ObjectVector,
                fDSNewEntry,
        		fNT4Compat
                );
            // return value not used.
        }

//        if ((pDSEntry) ** (!(pDSEntry->pswDomainName))) {
//        BUGBUG:: log an Event here.        
//        }
    }

    __except (
        (GetExceptionCode() == NSI_S_NOTHING_TO_EXPORT) && (fNewEntry || fDSNewEntry) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        {
        /* BUGBUG:  This guard should really be here but it conflicts with
           the reader guard in isEmpty -- leave out for now.

           CriticalWriter me(rwEntryGuard);
         */
            DBGOUT(DIRSVC, "got an exception\n");

            if ((fNT4Compat) && (pFSEntry->isEmpty())) {
                pInternalCache->remove(pFSEntry);
                delete pFSEntry;
            }
        }

        Raise(NSI_S_NOTHING_TO_EXPORT);
    }

    delete pDSEntry;

    return fChanges;
}    // nsi_binding_export

void
Locator::nsi_mgmt_binding_unexport(
    UNSIGNED32          EntryNameSyntax,
    STRING_T            EntryName,
    NSI_IF_ID_P_T       Interface,
    UNSIGNED32          VersOption,
    NSI_UUID_VECTOR_P_T ObjectVector
    )
/*++

Member Description:

    unexport information from a server entry -- finer control than nsi_binding
    counterpart.

Arguments:

    EntryNameSyntax - name syntax

    EntryName       - (raw) Name string of the entry to unexport

    Interface       - (raw) Interface+TransferSyntax to unexport

    VersOption      - flag which controls in fine detail which interfaces to remove

    ObjectVector    - objects to remove from the entry

Exceptions:

    NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_S_INVALID_VERS_OPTION, NSI_S_ENTRY_NOT_FOUND.
    NSI_S_NOTHING_TO_UNEXPORT, NSI_S_NOT_ALL_OBJS_UNEXPORTED,
    NSI_S_INTERFACE_NOT_FOUND, NSI_S_ENTRY_TYPE_MISMATCH
--*/
{
    int                fChanges = FALSE;
    CFullServerEntry * pFSEntry = NULL;
    CEntry           * pDSEntry = NULL;

    // validate
    if (Interface && IsNilIfId(Interface)) Interface = NULL;

    if (!ObjectVector && !Interface)
        Raise(NSI_S_NOTHING_TO_UNEXPORT);

    if (fNT4Compat) {
        pFSEntry = GetEntryFromCache(
            EntryNameSyntax,
            EntryName
            );
        // BUGBUG:: if compat flag is on, should it or not.
        if (!pFSEntry)
            Raise(NSI_S_ENTRY_NOT_FOUND);
    }

    // try getting the entry from the local cache.

    if (fDSEnabled)
       pDSEntry = GetEntryFromDS(
           EntryNameSyntax,
	   EntryName
	   );

    if ((!pDSEntry) && (!fNT4Compat))
        Raise(NSI_S_ENTRY_NOT_FOUND);

    if (fNT4Compat) {
        // if it has got it from the local cache then the type
        // must necessarily be FullServerEntryType.

        CServerEntry * pSEntry;

        if (pFSEntry->getType() != FullServerEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);

        // getting the local part.
        pSEntry = ((CFullServerEntry *) pFSEntry)->getLocal();

        fChanges = pSEntry->remove_from_entry(Interface, VersOption, ObjectVector, pCacheInterfaceIndex);
    }

    if ((pDSEntry) && (pDSEntry->getType() != ServerEntryType))
        // changes made after tests were started on all apns1
        Raise(NSI_S_ENTRY_TYPE_MISMATCH);

    if (pDSEntry)
        ((CServerEntry *)pDSEntry)->remove_changes_from_DS(Interface, VersOption, ObjectVector, fNT4Compat);

    delete pDSEntry;

} // nsi_mgmt_binding_unexport


CLookupHandle *
Locator::nsi_binding_lookup_begin_null(
            CGUIDVersion        * pGVinterface,
            CGUIDVersion        * pGVsyntax,
            CGUID               * pIDobject,
            UNSIGNED32            ulVectorSize,
            UNSIGNED32            MaxCacheAge,
            int                 * fTentativeStatus
            )
/*++

Member Description:

    lookup with a null entry name when the compatibility flag is
    on it first looks in the local cache, and then over the
    network when it is off it makes a lookup by querying in
    the DS. parameters are described in detail in tha actual
    api below.

Returns:
    the lookup handle.
--*/
{
    CLookupHandle       * pDSHandle = NULL;
    CLookupHandle       * pFinalHandle = NULL;

    *fTentativeStatus = NSI_S_OK;

    if (fNT4Compat) {
    /*
       it is important to do the index lookup before the net lookup so as
       to avoid duplication in the results returned.  If the net lookup uses
       a broadcast handle, the initialization will create both a private and a
       public cache (the former to avoid duplication), and the latter will be
       picked up by index lookup if it is done later.
     */

        CLookupHandle *pGLHindex = new CIndexLookupHandle(
            pGVinterface,
            pGVsyntax,
            pIDobject,
            ulVectorSize,
            MaxCacheAge? MaxCacheAge: ulMaxCacheAge
            );
        // lookup based on the interface id and object id in the local
        // data structure.

        CRemoteLookupHandle *prlhNetLookup =  NetLookup(
            RPC_C_NS_SYNTAX_DCE,
            NULL,
            pGVinterface,
            pGVsyntax,
            pIDobject,
            ulVectorSize,
            MaxCacheAge? MaxCacheAge: ulMaxCacheAge
            );

        // looking in other locators by contacting the PDC and broadcast.

        DBGOUT(MEM1,"Creating Complete Broadcast Handle for NULL Entry\n\n");

        pFinalHandle = new CCompleteHandle<NSI_BINDING_VECTOR_T>(
            pGLHindex,
            NULL,
            prlhNetLookup,
            MaxCacheAge? MaxCacheAge: ulMaxCacheAge
            );
    }
    else {
        // DS will necessarily be enabled if the compat flag has to be off.
	// no need to check.

        // searching in the DS. cache parameter is unused currently.
        // there is no cache maintained here.
        pFinalHandle =  new CDSNullLookupHandle(
            pGVinterface,
            pGVsyntax,
            pIDobject,
            ulVectorSize,
            MaxCacheAge? MaxCacheAge: ulMaxCacheAge
            // this is an unused parameter
            );

        DBGOUT(DIRSVC,"Creating Complete Lookup going only to DS Handle for NULL Entry\n\n");
    }
    return pFinalHandle;
}

CLookupHandle *
Locator::nsi_binding_lookup_begin_name(
                UNSIGNED32           EntryNameSyntax,
                STRING_T             EntryName,
                CGUIDVersion       * pGVinterface,
                CGUIDVersion       * pGVsyntax,
                CGUID              * pIDobject,
                UNSIGNED32           ulVectorSize,
                UNSIGNED32           MaxCacheAge,
                LookupType           type,
                int                * fTentativeStatus
               )
/*++
Member Description:

Lookup when the entry name is given.
DS takes precendence in this case even
when the compatibility flag is on.
--*/
{
    CFullServerEntry    * pFSEntry = NULL;
    CLookupHandle       * pDSHandle = NULL;
    CLookupHandle       * pFinalHandle = NULL;

    // if the lookup is made directly to this locator and not through
    // broadcast interface, look in the DS. Do no reply to broadcasts
    // with entries in the DS.
    *fTentativeStatus = NSI_S_OK;

    if ((type == LocalLookup) && (fDSEnabled))
        pDSHandle = DSLookup(
                EntryNameSyntax,
                EntryName,
                pGVinterface,
                pGVsyntax,
                pIDobject,
                ulVectorSize,
                MaxCacheAge? MaxCacheAge: ulMaxCacheAge
                );
    else
        pDSHandle = NULL;

    // if the entry exists in the DS it overides cache and the
    // network lookup

    if (pDSHandle && (((CDSLookupHandle *)pDSHandle)->FoundInDS()))
    {
        // if there was a DS and entry was found in the DS.
        pFinalHandle = pDSHandle;
        *fTentativeStatus = NSI_S_OK;
    }
    else
    {
        delete pDSHandle;

        if (fNT4Compat) {
            // try to see whether the entry exists locally.
            if (EntryName)
                pFSEntry = GetEntryFromCache(
                                        EntryNameSyntax,
                                        EntryName
                                        );

            // if it doesn't, assume that it is a server entry,
            // and do a lookup on that which will in turn do a
            // Broadcast for the entry name.

            if (!pFSEntry) {
                pFSEntry = new CFullServerEntry(EntryName);

                if (!pFSEntry)
                    Raise(NSI_S_OUT_OF_MEMORY);

                pInternalCache->insert(pFSEntry);

                *fTentativeStatus = NSI_S_ENTRY_NOT_FOUND;
                // lookup reply goes into the cache at this point.
                // for the time being put an empty entry into the cache.
            }

            DBGOUT(MEM1,"Creating Complete Handle for " << *pFSEntry << "\n\n");

            pFinalHandle = pFSEntry->lookup(
                                        pGVinterface,
                                        pGVsyntax,
                                        pIDobject,
                                        ulVectorSize,
                                        MaxCacheAge? MaxCacheAge: ulMaxCacheAge
                                        );

            if (*fTentativeStatus == NSI_S_ENTRY_NOT_FOUND) {
                *fTentativeStatus =
                    ((CCompleteHandle<NSI_BINDING_VECTOR_T>*) pFinalHandle)->netStatus();

                if ((*fTentativeStatus == NSI_S_ENTRY_NO_NEW_INFO) && pFSEntry->isEmpty())
                    *fTentativeStatus = NSI_S_ENTRY_NOT_FOUND;
                // Nothing was gained in the broadcast.

                /* BUGBUG:  This guard should really be here but it causes
                    deadlock -- leave out for now.
                    CriticalWriter me(rwEntryGuard);
                */

                if (*fTentativeStatus == NSI_S_ENTRY_NOT_FOUND) {
                    pInternalCache->remove(pFSEntry);
                    delete pFSEntry;
                }
            }
        }
        else
        {
            // do not attempt any broadcasts etc
            *fTentativeStatus = NSI_S_ENTRY_NOT_FOUND;
            pFinalHandle = NULL;
        }
    }
    return pFinalHandle;
}

NSI_NS_HANDLE_T
Locator::nsi_binding_lookup_begin(
    IN  UNSIGNED32           EntryNameSyntax,
    IN  STRING_T             EntryName,
    IN  NSI_INTERFACE_ID_T * Interface, OPT
    IN  NSI_UUID_P_T         Object, OPT
    IN  UNSIGNED32           VectorSize,
    IN  UNSIGNED32           MaxCacheAge,
    IN  LookupType           type
    )
/*++

Member Description:

    Perform a lookup operation, including all available information
    (owned, NonLocal and from the network).

Arguments:

    EntryNameSyntax - Name syntax

    EntryName        - Name string to lookup on.

    Interface        - Interface to search for

    Object           - Object UUID to search for

    VectorSize       - Size of return vector

Returns:

    A context handle for NS lookup.

Exceptions:

    NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_ENTRY_NOT_FOUND,
    NSI_S_OUT_OF_MEMORY, NSI_S_INVALID_OBJECT

    The broadcast lookup also calls the same handle.
    with the type set to broadcast

--*/
{
    int                   fTentativeStatus = NSI_S_OK;
    CGUIDVersion        * pGVinterface = NULL;
    CGUIDVersion        * pGVsyntax = NULL;
    CGUID               * pIDobject = NULL;
    int                   fDefaultEntry = FALSE;
    CLookupHandle       * pFinalHandle = NULL;

    if (!EntryName)
        fDefaultEntry = TRUE;
    // see whether the entry name is NULL.
    // if the entry name is null then the lookup has to be made based on other attributes.
    // like the interface id, object uuid etc.

    if (Interface && IsNilIfId(&(Interface->Interface))) Interface = NULL;

    __try {

        unsigned long ulVectorSize = (VectorSize) ? VectorSize : RPC_C_BINDING_MAX_COUNT;

        pGVinterface = (Interface)? new CGUIDVersion(Interface->Interface) : NULL;

        pGVsyntax = (Interface)? new CGUIDVersion(Interface->TransferSyntax) : NULL;

        RPC_STATUS dummyStatus;

        pIDobject = (!Object || UuidIsNil(Object,&dummyStatus)) ?
                            NULL : new CGUID(*Object) ;

        if (fDefaultEntry) {
            pFinalHandle = nsi_binding_lookup_begin_null(
                            pGVinterface,
                            pGVsyntax,
                            pIDobject,
                            ulVectorSize,
                            MaxCacheAge,
                            &fTentativeStatus
                            );

        }
        else {
            pFinalHandle = nsi_binding_lookup_begin_name(
                            EntryNameSyntax,
                            EntryName,
                            pGVinterface,
                            pGVsyntax,
                            pIDobject,
                            ulVectorSize,
                            MaxCacheAge,
                            type,
                            &fTentativeStatus
                            );

        }
    }

    __finally {

        delete pGVinterface;
        delete pGVsyntax;
        delete pIDobject;

    }

    if (fTentativeStatus != NSI_S_OK) {
        delete pFinalHandle;
        Raise(fTentativeStatus);
    }

    return (NSI_NS_HANDLE_T) pFinalHandle;
}



/* Note that there is no such thing as an object inquiry in the default entry */

NSI_NS_HANDLE_T
Locator::nsi_entry_object_inq_begin(
        UNSIGNED32          EntryNameSyntax,
        STRING_T            EntryName,
        LookupType          type
    )
/*++

Member Description:

    Perform an object inquiry, including all available information
    (owned, NonLocal and from the network).

Arguments:

    EntryNameSyntax  - Name syntax

    EntryName        - Name string to lookup on.

Returns:

    A context handle.

Exceptions:

    NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME, NSI_S_OUT_OF_MEMORY
--*/
{
    int                fFromDS = FALSE;
    CEntry           * pEntry = NULL;

    if (type == LocalLookup)
    {
        if (fDSEnabled)
	   pEntry = GetEntryFromDS(
                        EntryNameSyntax,
                        EntryName
                        );

        if (pEntry)
            fFromDS = TRUE;

        if ((pEntry) && (pEntry->getType() != ServerEntryType))
        {
            delete pEntry;
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
        }
    }

    if ((fNT4Compat) && (!pEntry)) {
        pEntry = GetEntryFromCache(
                        EntryNameSyntax,
                        EntryName
                        );

        if (!pEntry) {
            // if nothing was found in the DS for whatever reasons,
            // prepare for a broadcast.
            pEntry = new CFullServerEntry(EntryName);

            if (!pEntry)
                Raise(NSI_S_OUT_OF_MEMORY);

            pInternalCache->insert((CFullServerEntry *)pEntry);
            /* BUGBUG: in the following statement, we are assuming a server entry whereas
               the real entry may be a group or profile entry.  However, direct caching as
               a server entry is adequate for now.
             */
        }
    }

    if (!pEntry)
        Raise(NSI_S_ENTRY_NOT_FOUND);

    CObjectInqHandle * InqContext = pEntry->objectInquiry(ulMaxCacheAge);

    if (fFromDS)
        delete pEntry;

    return (NSI_NS_HANDLE_T) InqContext;
}

void
Locator::nsi_group_mbr_add(
        IN UNSIGNED32       group_name_syntax,
        IN STRING_T         group_name,
        IN UNSIGNED32       member_name_syntax,
        IN STRING_T         member_name
    )
{

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!member_name)
        Raise(NSI_S_INCOMPLETE_NAME);

    if (!fDSEnabled)
        Raise(NSI_S_GRP_ELT_NOT_ADDED);


    DBGOUT(API, "\nAdd to: " << group_name);
    DBGOUT(API, " Group Member:" << member_name);

    CEntry *pEntry = GetEntryFromDS(
        group_name_syntax,
        group_name
        );

    // getting the entry from the DS and making sure
    // that it is a group entry.
    if (pEntry)
    {
        if (pEntry->getType() != GroupEntryType)
        {
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
        }
    }
    else
    {
        // if not found creat a new entry.
        pEntry = new CGroupEntry(group_name);
        CGroupEntry *pGroup = (CGroupEntry*) pEntry;
    }

    CGroupEntry *pGroup = (CGroupEntry*) pEntry;
    // add the changes to the DS.
    pGroup->AddMember(member_name);
    delete pEntry;
}

void
Locator::nsi_group_mbr_remove(
        IN UNSIGNED32       group_name_syntax,
        IN STRING_T         group_name,
        IN UNSIGNED32       member_name_syntax,
        IN STRING_T         member_name
        )
{

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!member_name)
        Raise(NSI_S_INCOMPLETE_NAME);

    if (!fDSEnabled)
       Raise(NSI_S_GRP_ELT_NOT_REMOVED);

    DBGOUT(API, "\nRemove from: " << group_name);
    DBGOUT(API, " Group Member:" << member_name);

    // getting the entry from the DS and making sure
    // that it is a group entry.
    CEntry *pEntry = GetEntryFromDS(
        group_name_syntax,
        group_name
        );

    if (pEntry)
    {
        // if not found create a new entry.
        if (pEntry->getType() != GroupEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
        Raise(NSI_S_ENTRY_NOT_FOUND);

    CGroupEntry *pGroup = (CGroupEntry*) pEntry;
    // remove the changes from the DS.
    pGroup->RemoveMember(member_name);
    delete pEntry;
}


NSI_NS_HANDLE_T
Locator::nsi_group_mbr_inq_begin(
        IN UNSIGNED32       group_name_syntax,
        IN STRING_T         group_name,
        IN UNSIGNED32       member_name_syntax
        )
{
    CEntry            *pEntry = NULL;

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    DBGOUT(API, "\nnsi_group_mbr_inq_begin: " << group_name);

    if (fDSEnabled)
       pEntry = GetEntryFromDS(
                            group_name_syntax,
                            group_name
                            );

    if (pEntry) {
        if (pEntry->getType() != GroupEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
        Raise(NSI_S_ENTRY_NOT_FOUND);

    CGroupEntry *pGroupEntry = (CGroupEntry*) pEntry;
    CGroupInqHandle * InqContext = pGroupEntry->GroupMbrInquiry();

    // deleted by the handle
    return (NSI_NS_HANDLE_T) InqContext;
}


void
Locator::nsi_profile_elt_add(
        IN UNSIGNED32       profile_name_syntax,
        IN STRING_T         profile_name,
        IN NSI_IF_ID_P_T    if_id,
        IN UNSIGNED32       member_name_syntax,
        IN STRING_T         member_name,
        IN UNSIGNED32       priority,
        IN STRING_T         annotation
    )

{
    HRESULT            hr = S_OK;

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!member_name)
        Raise(NSI_S_INCOMPLETE_NAME);

    if (!fDSEnabled)
        Raise(NSI_S_PRF_ELT_NOT_ADDED);

    if (annotation == NULL)
        annotation = L"";

    DBGOUT(API, "\nAdd to: " << profile_name);
    DBGOUT(API, " Profile Member:" << member_name);
    if (if_id) DBGOUT(API, " Interface:" << if_id << "\n");
    DBGOUT(API, "Priority:" << priority);
    DBGOUT(API, " Annotation:" << annotation << "\n\n");

    CEntry *pEntry = GetEntryFromDS(
        profile_name_syntax,
        profile_name
        );

    if (pEntry)
    {
        if (pEntry->getType() != ProfileEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
    {
        pEntry = new CProfileEntry(profile_name);
        CProfileEntry *pProfile = (CProfileEntry*) pEntry;
        hr = pProfile->AddToDS();
        if (FAILED(hr)) {
           DWORD dwErr = RemapErrorCode(hr);
           if (dwErr == NSI_S_INTERNAL_ERROR)
               Raise(NSI_S_PROFILE_NOT_ADDED);
           else
               Raise(dwErr);
        }

        // creating a new profile entry in the DS.
    }

    CProfileEntry *pProfile = (CProfileEntry*) pEntry;

    pProfile->AddElement(
        if_id,
        member_name,
        priority,
        annotation
        );
    // reflecting the changes in the element in the DS.
    delete pEntry;
}


void
Locator::nsi_profile_elt_remove(
            IN UNSIGNED32       profile_name_syntax,
            IN STRING_T         profile_name,
            IN NSI_IF_ID_P_T    if_id,
            IN UNSIGNED32       member_name_syntax,
            IN STRING_T         member_name
            )
{

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!member_name)
        Raise(NSI_S_INCOMPLETE_NAME);

    if (!fDSEnabled)
       Raise(NSI_S_PRF_ELT_NOT_REMOVED);

    DBGOUT(API, "\nRemove From: " << profile_name);
    DBGOUT(API, " Profile Member:" << member_name);
    DBGOUT(API, " Interface:" << if_id << "\n");

    CEntry *pEntry = GetEntryFromDS(
        profile_name_syntax,
        profile_name
        );
    if (pEntry)
    {
        if (pEntry->getType() != ProfileEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
        Raise(NSI_S_ENTRY_NOT_FOUND);

    CProfileEntry *pProfile = (CProfileEntry*) pEntry;
    pProfile->RemoveElement(if_id,member_name);
    // removing the element from the DS.
    delete pEntry;
}



NSI_NS_HANDLE_T
Locator::nsi_profile_elt_inq_begin(
            IN UNSIGNED32       profile_name_syntax,
            IN STRING_T         profile_name,
            IN UNSIGNED32       inquiry_type,
            IN NSI_IF_ID_P_T    if_id,
            IN UNSIGNED32       vers_option,
            IN UNSIGNED32       member_name_syntax,
            IN STRING_T         member_name
            )
{
    CEntry            *pEntry = NULL;

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
       Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (if_id && IsNilIfId(if_id)) if_id = NULL;

    DBGOUT(API, "\nInquire From: " << profile_name);
    DBGOUT(API, " Member Name:" << member_name);
    DBGOUT(API, " Interface:" << if_id << "\n");


    if (fDSEnabled)
       pEntry = GetEntryFromDS(
                        profile_name_syntax,
                        profile_name
                        );

    if (pEntry)
    {
       if (pEntry->getType() != ProfileEntryType)
      Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
       Raise(NSI_S_ENTRY_NOT_FOUND);

    CProfileEntry *pProfile = (CProfileEntry*) pEntry;

    return pProfile->ProfileEltInquiry(
                                inquiry_type,
                                if_id,
                                vers_option,
                                member_name
                                );
    // deleted by the handle
}


void
Locator::nsi_mgmt_entry_delete(
         UNSIGNED32     entry_name_syntax,
         STRING_T       entry_name,
         EntryType      entry_type
         )
{
    HRESULT      hr = S_OK;
    CEntry     * pEntry = NULL;

    if (fNT4Compat)
        pEntry = GetEntryFromCache(
        entry_name_syntax,
        entry_name
        );

    if (pEntry) {
        ASSERT(pEntry->getType() == FullServerEntryType,
            "Cache Entry is not full server entry\n");
        pInternalCache->remove((CFullServerEntry *)pEntry);
        // have to remove the interfaces from the interface index list
        // IfIndex->remove(pEntry, *);
        pCacheInterfaceIndex->removeServerEntry(((CFullServerEntry *)pEntry)->getLocal());
        pCacheInterfaceIndex->removeServerEntry(((CFullServerEntry *)pEntry)->getNonLocal());
    }

    // if it exists in the local copy, delete it.

    delete pEntry;

    pEntry = NULL;

    if (fDSEnabled)
       pEntry = GetEntryFromDS(
            RPC_C_NS_SYNTAX_DCE,
            entry_name
            );

    if (!pEntry)
        Raise(NSI_S_ENTRY_NOT_FOUND);

    hr = pEntry->DeleteFromDS();
    // This will raise not an rpc entry
    delete pEntry;

    // mapping error codes.
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            Raise(NSI_S_ENTRY_NOT_FOUND);

        if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            Raise(NSI_S_NO_NS_PRIVILEGE);

        Raise(NSI_S_NAME_SERVICE_UNAVAILABLE);
    }
}


void
Locator::nsi_mgmt_entry_create(
         UNSIGNED32     entry_name_syntax,
         STRING_T       entry_name
         )
{
    HRESULT     hr = S_OK;

    if (entry_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!fDSEnabled)
       Raise(NSI_S_NAME_SERVICE_UNAVAILABLE);

    CEntryName *pEntryName = new CEntryName(entry_name);

    hr = CreateEntryInDS(pEntryName);

    delete pEntryName;

    // mapping error codes.
    if (FAILED(hr))
    {
        if ((hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) ||
               (hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)))
            Raise(NSI_S_ENTRY_ALREADY_EXISTS);

        if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            Raise(NSI_S_NO_NS_PRIVILEGE);

        Raise(NSI_S_NAME_SERVICE_UNAVAILABLE);
    }
    return;
}

void
Locator::nsi_group_delete(
    /* [in] */ UNSIGNED32 group_name_syntax,
    /* [in] */ STRING_T group_name
    )
{
/*   nsi_mgmt_entry_delete(
          group_name_syntax,
          group_name,
          GroupEntryType);
          */

}

void
Locator::nsi_profile_delete(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name
    )
{
/*   nsi_mgmt_entry_delete(
          profile_name_syntax,
          profile_name,
          ProfileEntryType);
          */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\mutex.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    mutex.cxx

Abstract:

    This file contains the implementations for non inline member functions of
	CReadWriteSection and CPrivateSemaphore, which implement a readers/writers
	mutex and a multi-owner mutex, respectively.

Author:

    Satish Thatte (SatishT) 09/01/95  Created all the code below except where
									  otherwise indicated.

--*/

#define NULL 0

#include <locator.hxx>


int
CReadWriteSection::readerEnter()

/*++

Routine Description:

	Reader may enter if no writer is in the section or waiting to enter it.
	Readers keep count of themselves and when the count drops to zero
	they release PSemWriterBlock so writers may enter.

Results:

    Count of current readers.

--*/

{
	/* wait for writer if one is in or waiting, otherwise
	   bump up reader count and block writer if first reader */

	DBGOUT(SEM, "Entering readerEnter\n");

	SimpleCriticalSection me1(PCSReaderBlock);

	SimpleCriticalSection me2(PCSCountBlock);

	DBGOUT(SEM, "ulReaderCount = " << ulReaderCount << "\n"); 

	if (ulReaderCount++);			// other readers already in
	else PSemWriterBlock.Enter();		// otherwise, block writer's entry

	DBGOUT(SEM, "Leaving readerEnter\n");
	DBGOUT(SEM, "ulReaderCount = " << ulReaderCount << "\n"); 

	return ulReaderCount;
}


int
CReadWriteSection::readerLeave()

/*++

Routine Description:

	A reader leaves, decrementing the ulReaderCount and releasing PSemWriterBlock
	if appropriate.

Results:

    Count of current readers as seen during count update.

--*/

{
	DBGOUT(SEM, "Entering readerLeave\n");
	DBGOUT(SEM, "ulReaderCount = " << ulReaderCount << "\n"); 

	SimpleCriticalSection me(PCSCountBlock);

	if (--ulReaderCount);			// other readers still in
	else PSemWriterBlock.Leave();		// otherwise, release writer's entry

	return ulReaderCount;
}
 


CPrivateSemaphore::CPrivateSemaphore(
							long lMaxCount
							) 
/*++

Routine Description:

    create a semaphore and initialize the handle member pNTSem.

--*/
{
	// DBGOUT(SEM, "Creating Semaphore with counts =" << lMaxCount << "\n");
	
	pNTSem = CreateSemaphore(
							NULL,		// pointer to security attributes 
							lMaxCount,	// initial count 
							lMaxCount,	// maximum count 
							NULL	 	// pointer to semaphore-object name  
							);
}



CPrivateSemaphore::~CPrivateSemaphore() 
/*++

Routine Description:

    close the semaphore handle.

--*/
{
	CloseHandle(pNTSem);
}


void
CPrivateSemaphore::Enter() 
/*++

Routine Description:

    Wait for the semaphore count to become nonzero.

--*/
{
	WaitForSingleObject(pNTSem,INFINITE);
}


void
CPrivateSemaphore::Leave(long lIncrement) 
/*++

Routine Description:

    Increment the semaphore count by lIncrement to release lIncrement "slots".

--*/
{
	DBGOUT(SEM1, "Releasing Semaphore with Increment =" << lIncrement << "\n");

	ReleaseSemaphore(pNTSem,lIncrement,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\nt4confg.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    nt4confg.c


Abstract:

     this file provides the routine GetSystemType
     that returns an identifier for the system type
     i.e. NT on wrkgrp, domain or lMnt BDC, PDC.

Author:

    Michael Montague (mikemon) 18-Dec-1991
    Rearranged and modified the Lsa part. ushaji 3 Dec 97

Revision History:

--*/

#undef ASSERT

#include <locator.hxx>
#include <lmcons.h>     // LAN Manager basic definitions
#include <lmserver.h>   // NetServerEnum etc
#include <lmwksta.h>    // NetWkstaGetInfo etc
#include <lmaccess.h>   // NetGetDCName etc

void
Locator::InitializeDomainBasedLocator()
/*++
Member Description:

    Initialize the domain locator.  The list of masters is initialized to
    hold names of all BDCs.  The name of the PDC has already been initialized.

--*/
{
    if ((Role == Master) || (Role == Backup))

        pAllMasters = new TGSLString;    // DC locators don't use BDCs as masters

    else pAllMasters = EnumDCs(pDomainName,SV_TYPE_DOMAIN_BAKCTRL,100);
}


void
Locator::InitializeWorkgroupBasedLocator()
/*++
Member Description:

    Initialize the workgroup locator.  No masters are known to start with.

--*/
{
    pAllMasters = new TGSLString;   // initialize with empty list, and add
                                    // potential masters in QueryProcess

    Role = Backup;                  // always ready to serve, if called upon to do so
}




TGSLString *
Locator::EnumDCs(
             CStringW * pDomainName,
             DWORD ServerType,
             long lNumWanted
             )
/*++
Member Description:

    This is a static private helper operation for enumerating servers of
    a given type in a given domain.

Arguments:

    pDomainName - the Unicode string name of the domain

    ServerType - the mask bits defining server types of interest

    lNumWanted - the number of servers to ask for; it seems a good
                 idea to ask for a lot (say 100) to make sure you get all
                 because NetServerEnum can be stingy with names

Returns:

    A Guarded Skiplist of string names.

--*/
{
    char errmsg[1000];

    DWORD EntriesRead, TotalEntries, ResumeHandle;

    SERVER_INFO_100 * buffer;

    SetSvcStatus();

    NET_API_STATUS NetStatus = NetServerEnum (
                    NULL,    // local
                    100,     // info level
                    (LPBYTE *) &buffer,
                    lNumWanted*sizeof(SERVER_INFO_100),
                    &EntriesRead,
                    &TotalEntries,
                    ServerType,
                    *pDomainName,    // auto conversion to STRING_T
                    &ResumeHandle
                    );

    TGSLString *pResult = new TGSLString;

    if ((NetStatus == NO_ERROR) || (NetStatus == ERROR_MORE_DATA)) {

        for (DWORD i = 0; i < EntriesRead; i++) {
            pResult->insert(new CStringW(buffer->sv100_name));
            buffer++;
        }
    }
    else
    {
        sprintf(errmsg, "NetServerEnum Failed, DomainName %S, lNumWanted %l\n", STRING_T(pDomainName),
                                            lNumWanted);
        StopLocator(
                errmsg,
                NSI_S_INTERNAL_ERROR
                );
    }
    return pResult;
}

BOOL
Locator::SetRoleAndSystemType(DSROLE_PRIMARY_DOMAIN_INFO_BASIC dsrole)

/*

   Determine if we [locator] are being run on a Workgroup machine
   or a member machine or a PDC or a BDC
*/

{
  Role = Client;
  BOOL fSuccess = TRUE;

  switch (dsrole.MachineRole)
  {
       case DsRole_RoleStandaloneWorkstation:
       case DsRole_RoleStandaloneServer:
           System = Workgroup;
           Role = Backup;
           break;

       case DsRole_RoleMemberWorkstation:
           System = Domain;
           Role = Client;
           break;

       case DsRole_RoleMemberServer:
           System = Domain;
           Role = Backup;
           break;
           
       case DsRole_RoleBackupDomainController:
           System = Domain;
           Role = Backup;
           break;

       case DsRole_RolePrimaryDomainController:
           System = Domain;
           Role = Master;
           break;
       default:
           System = Workgroup;
           Role = Backup;   // this is the most adaptive configuration.
           fSuccess = FALSE;
  }
  return fSuccess;
}

void Locator::SetCompatConfigInfo(DSROLE_PRIMARY_DOMAIN_INFO_BASIC dsrole)
{
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD sz = MAX_COMPUTERNAME_LENGTH + 1;

    SetSvcStatus();

    pCacheInterfaceIndex = new CInterfaceIndex(this);
    pInternalCache = new TGSLEntryList;
    psllBroadcastHistory = new TSLLBroadcastQP;
    ulMaxCacheAge = MAX_CACHE_AGE;
    fDCsAreDown = FALSE;

    SetSvcStatus();

    hMailslotForReplies = new READ_MAIL_SLOT(PMAILNAME_C, sizeof(QueryReply));

    SetSvcStatus();

    hMasterFinderSlot = new READ_MAIL_SLOT(RESPONDERMSLOT_C, sizeof(QueryReply));

    if (!GetComputerName(szComputerName, &sz))
        Raise(NSI_S_INTERNAL_ERROR);

    pComputerName = new CStringW(szComputerName);

    if (!SetRoleAndSystemType(dsrole))
        StopLocator(
            "Failed to determine system type",
            NSI_S_INTERNAL_ERROR
            );

    switch (System) {

    case Domain:
        LPBYTE DCnameBuffer;
        NET_API_STATUS NetStatus;

        SetSvcStatus();

        NetStatus = NetGetDCName(NULL,NULL,&DCnameBuffer);

        if ((NetStatus == NO_ERROR) || (NetStatus == ERROR_MORE_DATA)) {
            pPrimaryDCName = new CStringW(((STRING_T) DCnameBuffer) + 2);  // skip over "\\"
            InitializeDomainBasedLocator();
        }
        else {    // in the absence of a PDC, we pretend to be in a workgroup
            pPrimaryDCName = NULL;
            System = Workgroup;
            InitializeWorkgroupBasedLocator();
        }
        break;

    case Workgroup:
        pPrimaryDCName = NULL;
        InitializeWorkgroupBasedLocator();
        break;

    default:
        StopLocator(
            "Unknown system type",
            NSI_S_INTERNAL_ERROR
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\mailslot.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    mailslot.cxx

Abstract:

    This file contains the implementations for non inline member functions
    of WRITE_MAIL_SLOT and READ_MAIL_SLOT, which are classes used for
    wrapping NT mailslot functionality.

Author:

    Satish Thatte (SatishT) 10/1/95  Created all the code below except where
                                      otherwise indicated.

--*/

#define NULL 0

#include <locator.hxx>


WRITE_MAIL_SLOT::WRITE_MAIL_SLOT(
    IN STRING_T Target,
    IN STRING_T MailSlot
    )
/*++

Routine Description:

    open an existing NT MailSlot for writing.

Arguments:

    MailSlot - name of the WRITE_MAIL_SLOT

    Target - the workstation/domain to write to
--*/
{
    STRING_T SlotName;

    hWriteHandle = NULL;

    // STRING_T TargetPart;

    if (!Target)     // this should only happen for broadcasts
        SlotName = catenate(TEXT("\\\\*"),MailSlot);

    else SlotName = catenate(Target,MailSlot);

    hWriteHandle = CreateFile(
                        SlotName,
                        GENERIC_WRITE, // | SYNCHRONIZE,  don't know if this is needed
                        FILE_SHARE_WRITE,
                        NULL,                // BUGBUG: punting on security
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (INVALID_HANDLE_VALUE == hWriteHandle) {
        hWriteHandle = NULL;
        DBGOUT(BROADCAST, "CreateFile for Mailslot" << SlotName <<  "returned" << GetLastError() << "\n");
        delete [] SlotName;
//        Raise(NSI_S_MAILSLOT_ERROR);  // no point in raisin an exception in a released prod.
    }

    else delete [] SlotName;

}


WRITE_MAIL_SLOT::~WRITE_MAIL_SLOT(
    )
/*++

Routine Description:

    Deallocate a WRITE_MAIL_SLOT.

--*/
{
    if (hWriteHandle) CloseHandle(hWriteHandle);
}


DWORD
WRITE_MAIL_SLOT::Write(
    IN char * lpBuffer,
    IN DWORD nNumberOfBytesToWrite
    )
/*++

Routine Description:

    Write data to a mailslot.   
    
    The following may not be true at the moment:

    The mailslot is created with sync attributes,
    so there is no need to wait for the operation.

Arguments:

    lpBuffer - buffer to write.

    nNumberOfBytesToWrite - size of buffer to write.

Returns:

    Number of bytes written if write went OK. FALSE, otherwise.

--*/
{

    DWORD NumberOfBytesWritten;

    if (!hWriteHandle)
        return FALSE;

    BOOL result = WriteFile(
                    hWriteHandle,            // handle of file to write to 
                    (LPCVOID) lpBuffer,        // address of data to write to file 
                    nNumberOfBytesToWrite,    // number of bytes to write 
                    &NumberOfBytesWritten,    // address of number of bytes written 
                    NULL
                    );

    if (result) return NumberOfBytesWritten;
    else return FALSE;
}



READ_MAIL_SLOT::READ_MAIL_SLOT(
    IN STRING_T MailSlot,
    IN DWORD nMaxMessageSize
    )
/*++

Routine Description:

    Create an NT mailslot.

Arguments:

    MailSlot - name of the READ_MAIL_SLOT

    nMaxMessageSize - the size of buffer to allocate for reads.

--*/
{
    STRING_T SlotName;

    Size = nMaxMessageSize;   // max buffer size for reads
    hReadHandle = NULL;

    // Form the name of the READ_MAIL_SLOT.

    SlotName = catenate(TEXT("\\\\."), MailSlot);

    hReadHandle = 
        CreateMailslot(
                SlotName,
                nMaxMessageSize,    // maximum message size
                NET_REPLY_INITIAL_TIMEOUT,    // milliseconds before read time-out
                NULL     // address of security structure
                );

    if (INVALID_HANDLE_VALUE == hReadHandle) {
        hReadHandle = NULL;
        DBGOUT(BROADCAST, "CreateFile for Mailslot" << SlotName <<  "returned " << GetLastError() << "\n");
        delete [] SlotName;
//        Raise(NSI_S_MAILSLOT_ERROR);  // no point in raisin an exception in a released prod.
    }

    else delete [] SlotName;
}


READ_MAIL_SLOT::~READ_MAIL_SLOT(
    )
/*++

Routine Description:

    Deallocate a READ_MAIL_SLOT.

--*/
{
    if (hReadHandle) CloseHandle(hReadHandle);
}



DWORD
READ_MAIL_SLOT::Read(
    IN OUT char * lpBuffer,    // info is filled in hence also OUT
    IN DWORD dwBufferSize,
    IN DWORD dwReadTimeout
    )
/*++

Routine Description:

    Read data from a mailslot.  The mailslot is created with async
    atrributes so that the read can be timed out.

Arguments:

    lpBuffer - buffer to read data into

    dwBufferSize - the size of the buffer

    dwReadTimeout - time to wait for a response.

Returns:

    Number of bytes actually read.

--*/
{
    if (!hReadHandle)
        return FALSE;

    DBGOUT(BROADCAST, "Before Entering critical section of Read\n");
    SerializeReaders.Enter();

    BOOL success = SetMailslotInfo(
                            hReadHandle,
                            dwReadTimeout
                            );    

    if (!success) {
        SerializeReaders.Leave();
        return FALSE;
    }

    DWORD NumberOfBytesRead;

    DBGOUT(BROADCAST, "Entered Critical section\n");

    BOOL result = ReadFile(
                    hReadHandle,    // handle of file to write to 
                    lpBuffer,        // address of data buffer for reading
                    dwBufferSize,    // number of bytes to read 
                    &NumberOfBytesRead,    // address of number of bytes read 
                    NULL            // no overlapping
                    );
    DBGOUT(BROADCAST, "Read Data\n");

    SerializeReaders.Leave();

    if (result) return NumberOfBytesRead;
    else return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\objects.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    objects.cxx

Abstract:

    This file contains the implementations for non inline member functions
    of all basic classes used the server, excluding the data structure classes
    and classes used for network interactions.

Author:

    Satish Thatte (SatishT) 08/21/95  Created all the code below except where
                                      otherwise indicated.

--*/

#include <locator.hxx>


/***********  CGUID Methods **********/

CStringW*
CGUID::ConvertToString() {
    STRING_T pszResult;

    RPC_STATUS Status = UuidToString(
                                &rep,
                                &pszResult
                                );

    if (Status == RPC_S_OK) {
        CStringW * pswResult = new CStringW(pszResult);
        RpcStringFree(&pszResult);
        return pswResult;
    }
    else Raise(NSI_S_OUT_OF_MEMORY);

    /* NOTE: the following is a dummy statement to get past the compiler. */

    return NULL;
}

/***********  CGUIDVersion Methods **********/

int
CGUIDVersion::isMatching(const CGUIDVersion& o, UNSIGNED32 vers_option) {

        /*  vers_option decides how we match -- this is useful in,
            for instance, RpcNsMgmtBindingUnexport */

        CidAndVersion self(idAndVersion);
        CidAndVersion other(o.idAndVersion);

        if (self.id != other.id) return FALSE;    // id must match

        switch (vers_option) {
            case RPC_C_VERS_ALL:
                return TRUE;

            case RPC_C_VERS_COMPATIBLE:
                return (self.major == other.major) &&
                       (self.minor >= other.minor);

            case RPC_C_VERS_EXACT:
                return (self.major == other.major) &&
                       (self.minor == other.minor);

            case RPC_C_VERS_MAJOR_ONLY:
                return self.major == other.major;

            case RPC_C_VERS_UPTO:
                return (self.major < other.major) ||
                       ((self.major == other.major) && (self.minor <= other.minor));

            default:
                Raise(NSI_S_INVALID_VERS_OPTION);
        }

        /* the following is a dummy statement to get past the compiler */

        return NULL;
}


/***********  CBVWrapper Methods **********/

void
CBVWrapper::rundown()
{
    if (pBVT)
    {
        for (ULONG i = 0; i < pBVT->count;i++) {
            midl_user_free(pBVT->binding[i].string);
            midl_user_free(pBVT->binding[i].entry_name);
        }

        midl_user_free(pBVT);
        pBVT = NULL;
    }
}


/***********  CBindingVector Methods **********/

CBindingVector::CBindingVector(
            NSI_SERVER_BINDING_VECTOR_T *pbvtInVector,
            CServerEntry *pEntry
            )
            : pMyEntry(pEntry)
{
    merge(pbvtInVector);
}

int
CBindingVector::merge(
                      NSI_SERVER_BINDING_VECTOR_T* pHandles
                     )
/*++
Routine Description:

    Add new binding handles to the vector.

Arguments:

    pHandles - vector of allegedly new handles

Returns:

    TRUE, FALSE

Remarks:

    We first strip any object part present in the handle strings.
    The return value FALSE signifies that there were no new binding handles.

--*/
{
    int fChanges = FALSE;
    CStringW *pTemp;

    for (ULONG i = 0; i < pHandles->count; i++)    {

        NSI_STRING_BINDING_T szNextHandle = pHandles->string[i];
        NSI_STRING_BINDING_T szFinalHandle = NULL;

        /* first strip any object part from binding handle */

        if (szNextHandle) szFinalHandle = makeBindingStringWithObject(szNextHandle,NULL);

        if (szFinalHandle) {
            pTemp = new CStringW(szFinalHandle);
            RpcStringFree(&szFinalHandle);
            if (Duplicate == insert(pTemp)) delete pTemp;
            else fChanges = TRUE;
        }
    }
    return fChanges;
}


TBVSafeLinkList *
CBindingVector::formObjBVT(
        TSLLString * pLLobjectStrings,
        long ulVS    // max BV size
        )
/*++
Routine Description:

       Makes a copy of this CBindingVector in list-of-vector form replacing the
       object IDs in those bindings which contain a different object and
       adding the object ID to those which contain none.

Arguments:

    pLLobjectStrings - the linked list of possible object ID strings

    ulVS - limit on the size of the vector to be returned

Returns:

    binding vector


--*/

{
    long ulBVtotal = size() * max(pLLobjectStrings->size(),1);

    TBVSafeLinkList * pbvsll = new TBVSafeLinkList;

    long ulBVcount;

    NSI_BINDING_VECTOR_T * pbvtCurrentVector;

    // preform a list of all the vectors we will fill later
    // better keep all counts signed for safety in comparison

    for (ulBVcount = min(ulBVtotal,ulVS);
         ulBVcount;
         ulBVtotal -= ulBVcount, ulBVcount = min(ulBVtotal,ulVS)
        )
    {
        pbvtCurrentVector =
            (NSI_BINDING_VECTOR_T *)
            midl_user_allocate(sizeof(UNSIGNED32) + sizeof(NSI_BINDING_T)*ulBVcount);

        pbvtCurrentVector->count = ulBVcount;
        pbvsll->insert(new CBVWrapper(pbvtCurrentVector));
    }

    TBVSafeLinkListIterator BViter(*pbvsll);

    pbvtCurrentVector = BViter.next()->pBVT;
    ulBVcount = pbvtCurrentVector->count;

    TSLLStringIter ObjIter(*pLLobjectStrings);

    long i = 0;

    BOOL fNoneMade = TRUE;    // must make at least one binding string for each
                            // binding even if there are no object strings

    for (CStringW * pswObject = ObjIter.next();
         pswObject || fNoneMade;
         pswObject = ObjIter.next())
    {
        fNoneMade = FALSE;    // made one now

        TCSafeSkipListIterator<CStringW> BindingIter(*this);

        for ( CStringW * pswBinding = BindingIter.next();
              pswBinding;
              pswBinding = BindingIter.next(), i++
            )
        {

            STRING_T szObject;

            if (pswObject) szObject = *pswObject;
            else szObject = NULL;

            STRING_T tempBinding =
                makeBindingStringWithObject(
                            *pswBinding,    // current binding string
                            szObject
                            );

            if (i == ulBVcount) {                    // current vector full
                                                    // start the next one
                pbvtCurrentVector = BViter.next()->pBVT;
                ulBVcount = pbvtCurrentVector->count;
                i = 0;
            }

            pbvtCurrentVector->binding[i].string = CStringW::copyMIDLstring(
                                                                tempBinding
                                                                );
            pbvtCurrentVector->binding[i].entry_name = pMyEntry->copyAsMIDLstring();
            pbvtCurrentVector->binding[i].entry_name_syntax = pMyEntry->ulEntryNameSyntax;

            RpcStringFree(&tempBinding);    // comes from a different pool
        }
    }

    return pbvsll;
}



/***********  CEntryName Methods **********/

CEntryName::CEntryName(
            CONST_STRING_T fullName
            )     // disassembling constructor
            : CStringW(fullName)

// This constructor makes a local name if it can, and is the one that should
// be used whenever possible
{
    // Enforce the correct format of the name.

    WCHAR	*szRpcContainerDN=NULL;
    WCHAR	*szDomainNameDns=NULL;
    HRESULT hr = S_OK;

    parseEntryName(fullName, pswDomainName, pswEntryName);
    pswRpcContainerDN = NULL;
    pswDomainNameDns = NULL;

    if (isLocal()) changeToLocalName();
    else
       if (myRpcLocator->fDSEnabled) {
	        hr = GetRpcContainerForDomain(*pswDomainName, &szRpcContainerDN, &szDomainNameDns);
            if (SUCCEEDED(hr))
	            pswRpcContainerDN = new CStringW(szRpcContainerDN);
            else
	            pswRpcContainerDN = new CStringW(L"");

            if (szRpcContainerDN)
                delete szRpcContainerDN;

            if (szDomainNameDns) 
                pswDomainNameDns = new CStringW(szDomainNameDns);
            else
                pswDomainNameDns = NULL;
                
            if (szDomainNameDns)
                delete szDomainNameDns;
       }
}


CEntryName::CEntryName(               // assembling constructor
        CONST_STRING_T domainName,    // if NULL, assume relative name
        CONST_STRING_T entryName
        )
{
    WCHAR	*szRpcContainerDN=NULL;
    WCHAR	*szDomainNameDns=NULL;    
    HRESULT hr = S_OK;

    pswDomainName = domainName ? new CStringW(domainName) : NULL;
    pswEntryName = new CStringW(entryName);
    pswRpcContainerDN = NULL;
    pswDomainNameDns = NULL;

    pszVal = NULL;

    if (isLocal()) changeToLocalName();
    else pszVal = copyGlobalName();

    if (pswDomainName) {
       if (myRpcLocator->fDSEnabled) {
	        hr = GetRpcContainerForDomain(*pswDomainName, &szRpcContainerDN, &szDomainNameDns);
            if (SUCCEEDED(hr))
    	        pswRpcContainerDN = new CStringW(szRpcContainerDN);
            else
    	        pswRpcContainerDN = new CStringW(L"");

            if (szRpcContainerDN)
                delete szRpcContainerDN;

            if (szDomainNameDns) 
                pswDomainNameDns = new CStringW(szDomainNameDns);
            else
                pswDomainNameDns = NULL;
                
            if (szDomainNameDns)
                delete szDomainNameDns;
       }
    }
}

CEntryName::CEntryName(               // assembling constructor for DS
        CONST_STRING_T RpcContainerDN,
        CONST_STRING_T domainNameDns,    // if NULL, assume relative name
        DWORD          type,
        CONST_STRING_T entryName
        )
{
    pswDomainNameDns = domainNameDns ? new CStringW(domainNameDns) : NULL;
    pswEntryName = new CStringW(entryName);
    pswRpcContainerDN = new CStringW(RpcContainerDN);
    pswDomainName = NULL;
    
    pszVal = NULL;

    if (isLocal()) changeToLocalName();
    else {
    
        WCHAR *szDomainNameFlat=NULL;

        GetDomainFlatName(domainNameDns, &szDomainNameFlat);

        if (szDomainNameFlat) {
            pswDomainName = new CStringW(szDomainNameFlat);
            delete szDomainNameFlat;
        }
        else {
            pswDomainName = new CStringW(domainNameDns);
        }

        pszVal = copyGlobalName();
    }            
}


CEntryName::~CEntryName() {
    delete pswDomainName;
    delete pswEntryName;
    if (pswRpcContainerDN)
        delete pswRpcContainerDN;
    if (pswDomainNameDns) 
        delete pswDomainNameDns;
}


STRING_T
CEntryName::copyGlobalName() {

    CStringW * pswDomain = pswDomainName ? pswDomainName :
          myRpcLocator->getDomainName();

    if (!pswDomain) Raise(NSI_S_INTERNAL_ERROR);

    return makeGlobalName(*pswDomain,*pswEntryName);
}

STRING_T
CEntryName::getFullDNAlloc()
{
    WCHAR	*szDN = NULL;

    szDN = new WCHAR[DNNamePrefixLength+wcslen((*pswEntryName))+
    		 wcslen(*(getRpcContainer())) +1+1];

    wsprintf(szDN, L"%s%s,%s", DNNamePrefix, (STRING_T)(*pswEntryName),
    		(STRING_T)(*(getRpcContainer())));

    return szDN;
}

STRING_T
CEntryName::getFullDNWithDomainAlloc()
{
    WCHAR	*szDN = NULL;
   
    szDN = new WCHAR[DSDomainBeginLength+wcslen(*(getDomainNameDns()))+
    		 DSDomainEndLength+DNNamePrefixLength+wcslen((*pswEntryName))+1+
    		 wcslen(*(getRpcContainer()))+1];

    wsprintf(szDN, L"%s%s%c%s%s,%s", DSDomainBegin, (STRING_T)(*getDomainNameDns()), DSDomainEnd, 
                                     DNNamePrefix, (STRING_T)(*pswEntryName), 
                                     (STRING_T)(*(getRpcContainer())));

    return szDN;
}

CStringW*
CEntryName::getDomainName()
{
    return pswDomainName?pswDomainName:myRpcLocator->getDomainName();
}

CStringW*
CEntryName::getDomainNameDns()
{
    if (pswDomainNameDns)
        return pswDomainNameDns;
    else if (pswDomainName) // couldn't find DNS domain Name
        return pswDomainName;
    else 
        return myRpcLocator->getDomainNameDns();
}

CStringW*
CEntryName::getRpcContainer()
{
    return (pswRpcContainerDN?pswRpcContainerDN:
    	(myRpcLocator->pRpcContainerDN));
}

int
CEntryName::isLocal() {
    if ((!pswDomainName) && (!pswDomainNameDns))
        return TRUE;

    if ((pswDomainName) && (*pswDomainName == *myRpcLocator->getDomainName()))
        return TRUE;

    if ((pswDomainNameDns) && (*pswDomainNameDns == *myRpcLocator->getDomainNameDns()))
        return TRUE;

    return FALSE;
}

/***********  CInterface Methods **********/

CInterface::CInterface(
            NSI_INTERFACE_ID_T * lpInf,
            NSI_SERVER_BINDING_VECTOR_T *BindingVector,
            CServerEntry *pMyEntry
            )
            :    CGUIDVersion(lpInf->Interface),
                transferSyntax(lpInf->TransferSyntax),
                m_pMyEntry(pMyEntry)
{
    pBVhandles = new CBindingVector(BindingVector,pMyEntry);
}



/***********  CServerEntry Methods **********/

void
CServerEntry::flush() {

    CriticalWriter me(rwEntryGuard);

    DBGOUT(OBJECT, ObjectList.size() << " Objects Flushed\n");
    DBGOUT(OBJECT, InterfaceList.size() << " Interfaces Flushed\n\n");

    ObjectList.wipeOut();
    InterfaceList.wipeOut();

}



int CServerEntry::addObjects(
            NSI_UUID_VECTOR_P_T objectVector
            )
{
    CGUID *lpObject;
    int fChanges = FALSE;

    CriticalWriter me(rwEntryGuard);

    for (unsigned long i = 0; i < objectVector->count; i++) {

        if (!objectVector->uuid[i])
            continue;

        lpObject = new CGUID(*(objectVector->uuid[i]));

        if (Duplicate == ObjectList.insert(lpObject)) delete lpObject;
        else fChanges = TRUE;
    }
    return fChanges;
}

int CServerEntry::removeObjects(
                NSI_UUID_VECTOR_P_T objectVector,
                int& fRemovedAll
                )
{
    int fChanges = FALSE;
    fRemovedAll = TRUE;

    CGUID *pRemovedObject;

    CriticalWriter me(rwEntryGuard);

    for (unsigned long i = 0; i < objectVector->count; i++) {

        if (!objectVector->uuid[i])
            continue;

        CGUID Object(*objectVector->uuid[i]);

        if (pRemovedObject = ObjectList.remove(&Object)) {
            fChanges = TRUE;
            delete pRemovedObject;
        }
        else fRemovedAll = FALSE;
    }

    return fChanges;
}

int CServerEntry::addToInterface(
        NSI_INTERFACE_ID_T *lpInf,
        NSI_SERVER_BINDING_VECTOR_T *lpBindingVector,
        CInterfaceIndex* IfIndex
        )
/*++
Routine Description:

    Add new binding handles to the given interface and
    insert as a new interface if necessary.

Arguments:

    lpInf - Interface

    lpBindingVector - Vector of string bindings to add

    IfIndex - the interface index to insert a new interface into (besides self)

Returns:

    TRUE or FALSE

Remarks:

    The return value signifies whether the binding handles were new
    or the interface was new, i.e., whether the entry was actually updated.
    FALSE means no change.

--*/
{
    CInterface     *pTargetInterface = NULL;

    int fChanges = FALSE;

    CriticalWriter me(rwEntryGuard);

    pTargetInterface = InterfaceList.find(&CGUIDVersion(lpInf->Interface));

    if (pTargetInterface)
        fChanges = pTargetInterface->mergeHandles(lpBindingVector);

    else {
        pTargetInterface = new CInterface(lpInf,lpBindingVector,this);
        InterfaceList.insert(pTargetInterface);

        // add this server entry to the global interface list.
        IfIndex->insert(this, pTargetInterface);
        fChanges = TRUE;
    }
    return fChanges;
}

int CServerEntry::addInterfaceToDS(
        NSI_INTERFACE_ID_T *lpInf,
        NSI_SERVER_BINDING_VECTOR_T *lpBindingVector
        )
/*++
Routine Description:

    Add new binding handles to the given interface and
    insert as a new interface if necessary.

Arguments:

    lpInf - Interface

    lpBindingVector - Vector of string bindings to add

Returns:

    TRUE or FALSE

Remarks:

    The return value signifies whether the binding handles were new
    or the interface was new, i.e., whether the entry was actually updated.
    FALSE means no change.

--*/
{
    CInterface     *pTargetInterface;
    HRESULT         hr = S_OK;

    int fChanges = FALSE;

    CriticalWriter me(rwEntryGuard);

    pTargetInterface = InterfaceList.find(&CGUIDVersion(lpInf->Interface));

    if (pTargetInterface)
        fChanges = pTargetInterface->mergeHandles(lpBindingVector);
    else {
        pTargetInterface = new CInterface(lpInf,lpBindingVector, this);
        InterfaceList.insert(pTargetInterface);
        fChanges = TRUE;
    }

    if (fChanges)
    hr = pTargetInterface->AddToDS();

    return (SUCCEEDED(hr));
}



int CServerEntry::removeInterfaces(
                NSI_IF_ID_P_T    lpInf,
                UNSIGNED32   VersOption,
                CInterfaceIndex* IfIndex
                )
/*++
Routine Description:

    Remove all matching interfaces from the entry.

Arguments:

    lpInf - Base Interface Spec

    VersOption - Compatibility spec that decides which interfaces
                 match the base spec, and should be removed

    IfIndex - the interface index to remove interfaces from (besides self)


Returns:

    TRUE, FALSE

Remarks:

    The return value signifies whether any interfaces were removed.

--*/
{
    int fChanges = FALSE;

    CriticalWriter me(rwEntryGuard);

    CGUIDVersion baseIf(*lpInf);

    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);

    for (CInterface *pIf = IfIter.next(); pIf != NULL; pIf = IfIter.next())
        if (pIf->isMatching(baseIf,VersOption)) {
            InterfaceList.remove(pIf);
            IfIndex->remove(this,pIf);
            delete pIf;
            fChanges = TRUE;
        }

    return fChanges;
}

int
CServerEntry::removeInterfacesFromDS(
                NSI_IF_ID_P_T lpInf,
                UNSIGNED32 VersOption
                )
/*++
Routine Description:

    Remove all matching interfaces from the entry.

Arguments:

    lpInf   - Base Interface Spec

    VersOption  - Compatibility spec that decides which interfaces
                  match the base spec, and should be removed

    IfIndex     - the interface index to remove interfaces from (besides self)


Returns:

    TRUE, FALSE

Remarks:

    The return value signifies whether any interfaces were removed.

--*/
{
    int fChanges = FALSE;
    HRESULT     hr = S_OK;

    CriticalWriter me(rwEntryGuard);

    CGUIDVersion baseIf(*lpInf);

    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);

    for (CInterface *pIf = IfIter.next(); pIf != NULL; pIf = IfIter.next())
        if (pIf->isMatching(baseIf,VersOption)) {
            InterfaceList.remove(pIf);
            hr = pIf->DeleteFromDS();
            delete pIf;

            if (SUCCEEDED(hr))
           fChanges = TRUE;
        }

    return fChanges;
}


TSLLString*
CServerEntry::formObjectStrings(
            CGUID            *    pIDobject
            )

/*++

Method Description:

        We form a list of object UUID strings.  The list is empty if there is
        no OID involved (the client specified none and the entry contains none).
        The list contains only the string form of pIDobject if pIDobject is not
        NULL, and contains all UUIDs in the entry in string form otherwise.

        This is a private method, and must be called only within a reader guard.

--*/

{
    TSLLString * pLLobjectStrings = new TSLLString;

    if (pIDobject)
        pLLobjectStrings->insert(pIDobject->ConvertToString());
    else
    {
        TCSafeSkipListIterator<CGUID> ObjIter(ObjectList);
        for (CGUID *pID = ObjIter.next(); pID != NULL; pID = ObjIter.next())
            pLLobjectStrings->insert(pID->ConvertToString());
    }

    return pLLobjectStrings;
}




CLookupHandle *
CServerEntry::lookup(
            CGUIDVersion    *    pGVInterface,
            CGUIDVersion    *    pGVTransferSyntax,
            CGUID           *    pIDobject,
            unsigned long        ulVectorSize,
            unsigned long        ulCacheAge        // ignored in this case
        )
/*++
Method Description: CServerEntry::lookup

    lookup an entry and form a linked list of binding vectors corresponding
    to the interface and object specification given, then wrap it in a
    lookup handle to make it ready for iteration.

Arguments:

            pGVInterface        -    Interface (and version)
            pGVTransferSyntax    -    Transfer syntax (ignored)
            pIDobject            -    object UUID we want
            ulVectorSize        -    max size of BVs to be sent

Returns:

    a lookup handle

Remarks:

--*/
{
    if (pIDobject && !memberObject(pIDobject))         // object not found
            return new CServerLookupHandle(            // return empty handle
                    new TBVSafeLinkList
                    );

    /* better to put this after the memberObject call, which itself uses
       a lock on rwEntryGuard, although also as a reader */

    CriticalReader me(rwEntryGuard);

    // Object OK, now find compatible interfaces

    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);

    TBVSafeLinkList * pBVLLbindings = new TBVSafeLinkList;

    TSLLString * pLLobjectStrings = formObjectStrings(pIDobject);

    for (CInterface *pIf = IfIter.next(); pIf != NULL; pIf = IfIter.next())
        if (!pGVInterface ||
            pIf->isCompatibleWith(pGVInterface,pGVTransferSyntax)
           )
        {

            /* we randomize the BV list by randomly using  either push or enque
               to insert each BV into the list -- this is accomplished by using
               randomized initialization of the pointer-to-member-function "put"

               NOTE:  put should be an intrinsic on Linked Lists -- and
                        used in formObjBVT

                void (TBVSafeLinkList::*put)(NSI_BINDING_VECTOR_T*);

                put = ((rand() % 2) ? TBVSafeLinkList::push : TBVSafeLinkList::enque);
            */

            TBVSafeLinkList * pbvList =
                 pIf->pBVhandles->formObjBVT(
                        pLLobjectStrings,
                        ulVectorSize
                    );

            pBVLLbindings->catenate(*pbvList);

            delete pbvList;
        }

    /* finally, run down the object strings before returning the handle */

    TCSafeLinkListIterator<CStringW> runDownIter(*pLLobjectStrings);

    for (CStringW * psw = runDownIter.next(); psw; psw = runDownIter.next())
        delete psw;

    delete pLLobjectStrings;

    return new CServerLookupHandle(
            pBVLLbindings
            );
}

int
CServerEntry::add_to_entry(
    IN NSI_INTERFACE_ID_T              *    Interface,
    IN NSI_SERVER_BINDING_VECTOR_T     *    BindingVector,
    IN NSI_UUID_VECTOR_P_T                  ObjectVector,
    CInterfaceIndex            *    IfIndex,
    BOOL                            fCache
    )
/*++
Member Description:

    Add interfaces and objects to a server entry.

Arguments:

    Interface        - (raw) Interface+TransferSyntax to export

    BindingVector    - (raw) Vector of string bindings to export.

    ObjectVector     - (raw) Vector of object UUIDs to add to the entry

    IfIndex - the interface index to insert a new interface into (besides self)

Returns:

    TRUE    - if the export results in changes to the entry

    FALSE    - if the entry is unchanged

--*/
{
   int fChanges = FALSE;

   if (ObjectVector) fChanges = addObjects(ObjectVector);

   if ((!fCache) && (IsNilIfId(&(Interface->Interface))))
       return fChanges;

   if (Interface && BindingVector)
       fChanges = addToInterface(Interface,BindingVector,IfIndex) || fChanges;

   return fChanges;

} // add_to_entry

int
CServerEntry::remove_from_entry(
    IN NSI_IF_ID_P_T                        Interface,
    IN UNSIGNED32                   VersOption,
    IN NSI_UUID_VECTOR_P_T                  ObjectVector,
    CInterfaceIndex            *    IfIndex
    )
/*++
Member Description:

    remove interfaces and objects from a server entry.

Arguments:

    Interface        - (raw) Interface+TransferSyntax to unexport

    VersOption       - flag which controls in fine detail which interfaces to remove

    ObjectVector     - (raw) Vector of object UUIDs to remove from the entry

    IfIndex          - the interface index to remove a new interface into (besides self)

Returns:

    TRUE    - if the export results in changes to the entry

    FALSE   - if the entry is unchanged

--*/
{
   int fChanges = FALSE, fIntfChanges = TRUE; // safe
   int fRemovedAll = TRUE;

   if (ObjectVector) fChanges = removeObjects(ObjectVector, fRemovedAll);

   if (!fRemovedAll)
       Raise(NSI_S_NOT_ALL_OBJS_UNEXPORTED);

   if (Interface)
       fIntfChanges = removeInterfaces(Interface, VersOption, IfIndex);

   if (!fIntfChanges)
       Raise(NSI_S_INTERFACE_NOT_FOUND);

   return fChanges || fIntfChanges;

} // add_to_entry


int
CServerEntry::add_changes_to_DS(
    IN NSI_INTERFACE_ID_T              *    Interface,
    IN NSI_SERVER_BINDING_VECTOR_T     *    BindingVector,
    IN NSI_UUID_VECTOR_P_T                  ObjectVector,
    int                                     fNewEntry,
    BOOL				    fIgnoreErrors)
{
   int        fChanges = FALSE, fIntfChanges = TRUE;
   HRESULT    hr = S_OK;

   if (ObjectVector) fChanges = addObjects(ObjectVector);

   if (fChanges || fNewEntry)
       hr = AddToDS();

   if ((FAILED(hr)) && (!fIgnoreErrors))
       Raise(NSI_S_NOT_ALL_OBJS_EXPORTED);

   if (Interface && BindingVector)
       fIntfChanges = addInterfaceToDS(Interface,BindingVector);

   if ((!fIntfChanges) && (!fIgnoreErrors))
       Raise(NSI_S_INTERFACE_NOT_EXPORTED);

   return fChanges || fIntfChanges;
}


int
CServerEntry::remove_changes_from_DS(
    IN NSI_IF_ID_P_T                        Interface,
    UNSIGNED32                              VersOption,
    IN NSI_UUID_VECTOR_P_T                  ObjectVector,
    BOOL				    fIgnoreErrors
    )
{
   int fChanges = FALSE, fIntfChanges = TRUE;
   int fRemovedAll = TRUE;
   HRESULT hr = S_OK;

   if (ObjectVector) fChanges = removeObjects(ObjectVector, fRemovedAll);

   if (fChanges)
       hr = AddToDS();

   if (((!fRemovedAll) || (FAILED(hr))) && (!fIgnoreErrors))
       Raise(NSI_S_NOT_ALL_OBJS_UNEXPORTED);

   if (Interface)
       fIntfChanges = removeInterfacesFromDS(Interface, VersOption);

   if ((!fIntfChanges) && (!fIgnoreErrors))
       Raise(NSI_S_INTERFACE_NOT_FOUND);

   return fChanges || fIntfChanges;
}


/* BUGBUG: A CServerObjectInqHandle created by the following seems to be leaked in the
   master (PDC) locator in CT test#511, perhaps only when the test fails, which it does
   when the client locator is new and the server locator is old -- needs investigation */

CObjectInqHandle *
CServerEntry::objectInquiry(
        unsigned long        ulCacheAge
    )
{
    CriticalReader me(rwEntryGuard);

    TCSafeSkipListIterator<CGUID> ssli(ObjectList);

    TCSafeSkipList<CGUID> *pssl = new TCSafeSkipList<CGUID>;

    for (CGUID* pguid = ssli.next(); pguid; pguid = ssli.next())
    {
        CGUID * pGuidCopy = new CGUID(*pguid);
        pssl->insert(pGuidCopy);
    }

    TSSLGuidIterator *pGuidIter = new TSSLGuidIterator(*pssl);

    delete pssl;

    return new CServerObjectInqHandle(
                                    pGuidIter,
                                    ulCacheAge
                                    );
}


/***********  CRemoteLookupHandle Methods **********/


#if DBG
    ULONG CRemoteLookupHandle::ulHandleCount = 0;
    ULONG CRemoteObjectInqHandle::ulHandleCount = 0;
#endif

CRemoteLookupHandle::CRemoteLookupHandle(
        UNSIGNED32            EntryNameSyntax,
        STRING_T              EntryName,
        CGUIDVersion     *    pGVInterface,
        CGUIDVersion     *    pGVTransferSyntax,
        CGUID            *    pIDobject,
        unsigned long         ulVectorSize,
        unsigned long         ulCacheAge
    )
{
   DBGOUT(MEM2, "RemoteLookupHandle#" << (ulHandleNo = ++ulHandleCount)
        << " Created at" << CurrentTime() << "\n\n");

   u32EntryNameSyntax = EntryNameSyntax;
   penEntryName = EntryName ? new CEntryName(EntryName) : NULL;

   pgvInterface = pGVInterface ? new CGUIDVersion(*pGVInterface) : NULL;
   pgvTransferSyntax = pGVTransferSyntax ?
               new CGUIDVersion(*pGVTransferSyntax) :
               NULL;
   pidObject = pIDobject ? new CGUID(*pIDobject) : NULL;

   ulVS = ulVectorSize;
   ulCacheMax = ulCacheAge;

   fNotInitialized = TRUE;
   plhFetched = NULL;
   psslNewCache = NULL;
}


/***********  CNetLookupHandle Methods **********/

#if DBG
    ULONG CNetLookupHandle::ulNetLookupHandleCount = 0;
    ULONG CNetLookupHandle::ulNetLookupHandleNo = 0;
#endif

void
CNetLookupHandle::initialize()
{
    STRING_T szEntryName;

    if (penEntryName) szEntryName = *penEntryName;
    else szEntryName = NULL;

    DBGOUT(TRACE,"CNetLookupHandle::initialize called for Handle#" << ulHandleNo << "\n\n");
    if (!myRpcLocator->IsInMasterRole())
    {
        DBGOUT(TRACE, "Not a master locator, requesting for Broadcast\n");
        pRealHandle = new CMasterLookupHandle(
                                u32EntryNameSyntax,
                                szEntryName,
                                pgvInterface,
                                pgvTransferSyntax,
                                pidObject,
                                ulVS,
                                ulCacheMax
                                );

        // force initialization to make sure connection to master is OK

        pRealHandle->initialize();
    }



    if (myRpcLocator->IsInMasterRole() ||
        (!IsNormalCode(pRealHandle->StatusCode) && myRpcLocator->IsInBackupRole())
       )

    {
        if (myRpcLocator->IsInWorkgroup())    // we are in a workgroup, so become masterful
            myRpcLocator->becomeMasterLocator();

        if (pRealHandle) delete pRealHandle;

        DBGOUT(TRACE, "Finds that it is the master locator and sends broadcast\n");
        pRealHandle = new CBroadcastLookupHandle(
                                u32EntryNameSyntax,
                                szEntryName,
                                pgvInterface,
                                pgvTransferSyntax,
                                pidObject,
                                ulVS,
                                ulCacheMax
                                );
    }

    fNotInitialized = FALSE;
}




/***********  CNetObjectInqHandle Methods **********/

void
CNetObjectInqHandle::initialize()
{
    if (!myRpcLocator->IsInMasterRole())
    {
        pRealHandle = new CMasterObjectInqHandle(
                                *penEntryName,
                                ulCacheMax
                                );

        // force initialization to make sure connection to master is OK

         pRealHandle->initialize();
    }

    if (myRpcLocator->IsInMasterRole() ||
        (!IsNormalCode(pRealHandle->StatusCode) && myRpcLocator->IsInBackupRole())
       )
    {
        if (myRpcLocator->IsInWorkgroup())    // we are in a workgroup, so become masterful

            myRpcLocator->becomeMasterLocator();

        if (pRealHandle) delete pRealHandle;

        pRealHandle = new CBroadcastObjectInqHandle(
                                *penEntryName,
                                ulCacheMax
                                );
    }
}


/***********  CServerLookupHandle Methods **********/


void
CServerLookupHandle::rundown() {
    CBVWrapper *pbvw;

    if (pBVIterator)
    {
        for (pbvw = pBVIterator->next(); pbvw; pbvw = pBVIterator->next()) {
            pbvw->rundown();
            delete pbvw;
        }

        delete pBVIterator;
        pBVIterator = NULL;
    }
}



CServerLookupHandle::CServerLookupHandle(
            TBVSafeLinkList            *    pBVLL
            )
{
    pBVIterator = new TBVSafeLinkListIterator(*pBVLL);
    
    /* it seems bizarre to do the following, but reference counting and
       the fDeleteData flag in Link objects ensure that nothing is
       destroyed prematurely.  This just sets things up so that objects
       are automatically deleted as they are used up.  Note that the BV objects
       themselves are freed automatically by the stub as they are passed back.

       Unused BV objects will be reclaimed by rundown/done using middle_user_free.
    */

    delete pBVLL;
}


/***********  CServerObjectInqHandle Methods **********/

void
CServerObjectInqHandle::rundown()
{
    if (pcgIterSource)
    {
        for (CGUID* pg = pcgIterSource->next(); pg; pg = pcgIterSource->next())
            delete pg;

        delete pcgIterSource;
        pcgIterSource = NULL;
    }
}


GUID *
CServerObjectInqHandle::next() {

    CGUID* pg = pcgIterSource->next();

    GUID * result = NULL;

    if (pg) {
        result = (GUID*) midl_user_allocate(sizeof(GUID));
        *result = pg->myGUID();
        delete pg;
    }

    return result;
}



/***********  CNonLocalServerEntry Methods **********/

BOOL
CNonLocalServerEntry::isCurrent(ULONG ulTolerance) {

    CriticalReader me(rwNonLocalEntryGuard);

    return fHasNonLocalInfo && IsStillCurrent(ulCacheTime,ulTolerance);

}


CLookupHandle *
CNonLocalServerEntry::lookup(
            CGUIDVersion    *    pGVInterface,
            CGUIDVersion    *    pGVTransferSyntax,
            CGUID           *    pIDobject,
            unsigned long        ulVectorSize,
            unsigned long        ulCacheAge
        )
{
    if (!isCurrent(ulCacheAge)) flush();

    CriticalReader me(rwNonLocalEntryGuard);

    DBGOUT(TRACE, "Forming new NonLocal handle for" << getCurrentName() << "\n");

    return new CNonLocalServerLookupHandle(
                        getCurrentName(),
                        pGVInterface,
                        pGVTransferSyntax,
                        pIDobject,
                        ulVectorSize,
                        ulCacheAge
                        );
}


CObjectInqHandle *
CNonLocalServerEntry::objectInquiry(
            unsigned long        ulCacheAge
        )
{
    CriticalReader me(rwNonLocalEntryGuard);

    return new CNonLocalServerObjectInqHandle(
                    getCurrentName(),
                    ulCacheAge
                    );
}




/***********  CFullServerEntry Methods **********/

void
CFullServerEntry::flushCacheIfNecessary(ULONG ulTolerance)
{
    CriticalReader me(rwFullEntryGuard);

    if (!pNonLocalEntry->isCurrent(ulTolerance))
    {
        pNonLocalEntry->flush();

        /*
           Note that the "flushing" may be spurious -- it may happen
           because the NonLocal entry has no cached info.
        */
    }
}


CLookupHandle *
CFullServerEntry::lookup(
            CGUIDVersion    *    pGVInterface,
            CGUIDVersion    *    pGVTransferSyntax,
            CGUID           *    pIDobject,
            unsigned long        ulVectorSize,
            unsigned long        ulCacheAge
            )
{
    CriticalReader me(rwFullEntryGuard);

    CLookupHandle *
    pLocalHandle = pLocalEntry->lookup(
                                    pGVInterface,
                                    pGVTransferSyntax,
                                    pIDobject,
                                    ulVectorSize,
                                    ulCacheAge
                                    );

    flushCacheIfNecessary(ulCacheAge);

    /* it is important to do the cache lookup before the net lookup so as
       to avoid duplication in the results returned.  If the net lookup uses
       a broadcast handle, the initialization will create both a private and a
       public cache (the former to avoid duplication), and the latter will be
       picked up by cache lookup if it is done later.
    */

    CLookupHandle *
    pNonLocalHandle = pNonLocalEntry->lookup(
                                    pGVInterface,
                                    pGVTransferSyntax,
                                    pIDobject,
                                    ulVectorSize,
                                    ulCacheAge
                                    );


    CLookupHandle *
    pNetHandle = myRpcLocator->NetLookup(
                                    RPC_C_NS_SYNTAX_DCE,
                                    getCurrentName(),
                                    pGVInterface,
                                    pGVTransferSyntax,
                                    pIDobject,
                                    ulVectorSize,
                                    ulCacheAge
                                    );

    return new CCompleteHandle<NSI_BINDING_VECTOR_T>(
                                                pLocalHandle,
                                                pNonLocalHandle,
                                                pNetHandle,
                                                ulCacheAge
                                                );
}


CObjectInqHandle *
CFullServerEntry::objectInquiry(
            unsigned long        ulCacheAge
            )
{
    CriticalReader me(rwFullEntryGuard);

    CObjectInqHandle *
    pLocalHandle = pLocalEntry->objectInquiry(
                                        ulCacheAge
                                        );

    CObjectInqHandle *
    pNonLocalHandle = pNonLocalEntry->objectInquiry(
                                        ulCacheAge
                                        );

    CObjectInqHandle *
    pNetHandle = myRpcLocator->NetObjectInquiry(
                                        RPC_C_NS_SYNTAX_DCE,
                                        getCurrentName()
                                        );

    return new CCompleteHandle<GUID>(
                                     pLocalHandle,
                                     pNonLocalHandle,
                                     pNetHandle,
                                     ulCacheAge
                                     );
}




/***********  CNonLocalServerLookupHandle Methods **********/

void
CNonLocalServerLookupHandle::initialize()
{
    CEntry *pE = myRpcLocator->GetEntryFromCache(RPC_C_NS_SYNTAX_DCE,*penEntryName);

    CNonLocalServerEntry *pEntry;

    if ((pE) && (pE->getType() == FullServerEntryType))
        pEntry = ((CFullServerEntry*)pE)->getNonLocal();

    else if ((pE) && (pE->getType() == NonLocalServerEntryType))
        pEntry = (CNonLocalServerEntry*)pE;

    else pEntry = NULL;

    if (pEntry) {
        plhFetched = pEntry->CServerEntry::lookup(
                                                    pgvInterface,
                                                    pgvTransferSyntax,
                                                    pidObject,
                                                    ulVS,
                                                    ulCacheMax
                                                    );
        if (plhFetched)
        {
            DBGOUT(TRACE, "Found a NonLocal entry for" << *penEntryName << "\n");
        }
        else
        {
            DBGOUT(TRACE, "Entry Found, but handle couldn't be formed for"
                << *penEntryName << "\n");
        }
    }
    else  plhFetched = NULL;

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}


CNonLocalServerLookupHandle::CNonLocalServerLookupHandle(
                    STRING_T szEntryName,
                    CGUIDVersion *pGVInterface,
                    CGUIDVersion *pGVTransferSyntax,
                    CGUID *pIDobject,
                    ULONG ulVectorSize,
                    ULONG ulCacheAge
                    )
                : CRemoteLookupHandle(
                    RPC_C_NS_SYNTAX_DCE,
                    szEntryName,
                    pGVInterface,
                    pGVTransferSyntax,
                    pIDobject,
                    ulVectorSize,
                    ulCacheAge
                    )
{
}



/***********  CNonLocalServerObjectInqHandle Methods **********/

void
CNonLocalServerObjectInqHandle::initialize()
{
    ulIndex = 0;

    CNonLocalServerEntry *pEntry;

    // get the NonLocal entry again because it may have expired, been deleted and replaced

    CEntry *pE = myRpcLocator->GetEntryFromCache(RPC_C_NS_SYNTAX_DCE,*penEntryName);

    if ((pE) && (pE->getType() == FullServerEntryType))
        pEntry = ((CFullServerEntry*)pE)->getNonLocal();

    else if ((pE) && (pE->getType() == NonLocalServerEntryType))
        pEntry = (CNonLocalServerEntry*)pE;

    else pEntry = NULL;

    if (pEntry) {
        CObjectInqHandle *pTempHandle = pEntry->CServerEntry::objectInquiry(ulCacheMax);
        pUuidVector = getVector(pTempHandle);
        delete pTempHandle;
    }
    else pUuidVector = NULL;

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}


CNonLocalServerObjectInqHandle::CNonLocalServerObjectInqHandle(
                    STRING_T szEntryName,
                    ULONG ulCacheAge
                    )
        : CRemoteObjectInqHandle(szEntryName,ulCacheAge)
{
}





/***************** CGroupLookupHandle Methods *****************/


CGroupLookupHandle::CGroupLookupHandle(
            TEntryIterator  *    pEI,
            CGUIDVersion    *    pGVInf,
            CGUIDVersion    *    pGVXferSyntax,
            CGUID           *    pIDobj,
            unsigned long        ulVectSize,
            unsigned long        ulCacheAge
        )
{
    ulCacheMax = ulCacheAge;

    pGVInterface = pGVInf ? new CGUIDVersion(*pGVInf) : NULL;
    pGVTransferSyntax = pGVXferSyntax ? new CGUIDVersion(*pGVXferSyntax) : NULL;
    pIDobject = pIDobj ? new CGUID(*pIDobj) : NULL;
    ulVectorSize = ulVectSize;
    pCurrentHandle = NULL;
    fUnusedHandle = TRUE;
    fRootHandle = TRUE; // presumption

    pEIterator = pEI;


    // The new TSSLEntryList set here may be deleted
    // if this handle is belongs to an entry that is part of a
    // larger group or profile lookup -- in that case the larger
    // lookup will send in its own list of visited entries
    pVisitedEntries = new TSSLVisitedList;
}


void
CGroupLookupHandle::advanceCurrentHandle()
{
    delete pCurrentHandle;
    pCurrentHandle = NULL;

    for (CEntry *pCurEntry = pEIterator->next(); pCurEntry; pCurEntry = pEIterator->next())
    {
        CVisitedEntry    *visited = new CVisitedEntry(pCurEntry->getCurrentName(), pCurEntry->getType());

        if (pVisitedEntries->find(visited)) {
            DBGOUT(TRACE, "Already visited this entry, size of VisitedEntries\n" << pVisitedEntries->size());
            DBGOUT(TRACE, "The current entry type (that is abt. to be skipped): " << pCurEntry->getType() << "\n");
            delete visited;
            continue; // been there
        }

        DBGOUT(TRACE, "The type of entry to be inserted CurEntry type: " << pCurEntry->getType() << "\n");

        pVisitedEntries->insert(visited);

        if (pCurEntry->getType() == MemberEntryType)
        {
            DBGOUT(TRACE, "TYpe is MemberEntryType\n");
            CMemberEntry *pMemberEntry = (CMemberEntry*) pCurEntry;
            pMemberEntry->setVisitedEntries(pVisitedEntries);
        }

        DBGOUT(TRACE, "Calling lookup on pCurEntry\n");
        pCurrentHandle = pCurEntry->lookup(     // INVARIANT:  lookup returns non-NULL
                                        pGVInterface,
                                        pGVTransferSyntax,
                                        pIDobject,
                                        ulVectorSize,
                                        ulCacheMax
                                        );

        if (pCurEntry->getType() == MemberEntryType)
        {
            delete pCurEntry;
        }

        ASSERT(pCurrentHandle,"advanceCurrentHandle got NULL handle\n");

        pCurrentHandle->setExpiryAge(ulCacheMax);

        if (!pCurrentHandle->finished()) break;
        else {
            delete pCurrentHandle;
            pCurrentHandle = NULL;
        }
    }
}




NSI_BINDING_VECTOR_T *
CGroupLookupHandle::next()
{
    if (fUnusedHandle)
    {
        fUnusedHandle = FALSE;
        advanceCurrentHandle();
    }
    else if (pCurrentHandle && pCurrentHandle->finished())
    {
        advanceCurrentHandle();
    }

    if (!pCurrentHandle) return NULL;    // no more entries
    else return pCurrentHandle->next();
}

int
CGroupLookupHandle::finished()
{
    if (fUnusedHandle)
    {
        fUnusedHandle = FALSE;
        advanceCurrentHandle();
    }
    else if (pCurrentHandle && pCurrentHandle->finished())
    {
        advanceCurrentHandle();
    }

    if (!pCurrentHandle) return TRUE;    // no more entries
    else return FALSE;
}

/***************** CDSNullLookupHandle Methods *****************/
CDSNullLookupHandle::CDSNullLookupHandle(
            CGUIDVersion    *    pGVInf,
            CGUIDVersion    *    pGVXferSyntax,
            CGUID           *    pIDobj,
            unsigned long        ulVectSize,
            unsigned long        ulCacheAge
        )
{
    pGVInterface = pGVInf ? new CGUIDVersion(*pGVInf) : NULL;
    pGVTransferSyntax = pGVXferSyntax ? new CGUIDVersion(*pGVXferSyntax) : NULL;
    pIDobject = pIDobj ? new CGUID(*pIDobj) : NULL;
    ulVectorSize = ulVectSize;
    pCurrentHandle = NULL;
    fUnusedHandle = TRUE;
    pDSQry = NULL;
    fNotInitialized = TRUE;
}


void
CDSNullLookupHandle::advanceCurrentHandle()
{
    delete pCurrentHandle;
    pCurrentHandle = NULL;

    if (!pDSQry) {
        return;
    }
    for (CEntry *pCurEntry = pDSQry->next(); pCurEntry; pCurEntry = pDSQry->next())
    {
        DBGOUT(TRACE, "Calling lookup on pCurEntry\n");
        pCurrentHandle = pCurEntry->lookup(     // INVARIANT:  lookup returns non-NULL
                                        pGVInterface,
                                        pGVTransferSyntax,
                                        pIDobject,
                                        ulVectorSize,
                                        ulCacheMax
                                        );

        delete pCurEntry;

        ASSERT(pCurrentHandle,"advanceCurrentHandle got NULL handle\n");

        if (!pCurrentHandle->finished()) break;
        else {
            delete pCurrentHandle;
            pCurrentHandle = NULL;
        }
    }
}

void CDSNullLookupHandle::initialize()
{
    WCHAR   szCommandText[MAX_DS_QUERY_LEN];
    WCHAR   szSubCommand[MAX_DS_QUERY_LEN];
    HRESULT     hr = S_OK;

    wsprintf(szCommandText, L"(& (%s=%s) ",
                            CLASSNAME, RPCSERVERCONTAINERCLASS);
    if (pIDobject) {
       GUID         guid;
       STRINGGUID   szGuid;

       guid = pIDobject->myGUID();
       UuidToStringEx(&guid, szGuid);
       wsprintf(szSubCommand, L"(%s=%s)", OBJECTID, szGuid);
       wcscat(szCommandText, szSubCommand);
    }

    wsprintf(szSubCommand, L")");
    wcscat(szCommandText, szSubCommand);

    DBGOUT(DIRSVC, L"Query string for NULL lookup Handle" << szCommandText);

    pDSQry = new CDSQry(szCommandText, &hr);
    if (FAILED(hr))
        delete pDSQry;

    fNotInitialized = FALSE;
}
// same as group entry lookup

NSI_BINDING_VECTOR_T *
CDSNullLookupHandle::next()
{
   if (fNotInitialized)
       initialize();

    if (fUnusedHandle)
    {
        fUnusedHandle = FALSE;
        advanceCurrentHandle();
    }
    else if (pCurrentHandle && pCurrentHandle->finished())
    {
        advanceCurrentHandle();
    }

    if (!pCurrentHandle) return NULL;    // no more entries
    else return pCurrentHandle->next();
}

// same as group entry lookup.
int
CDSNullLookupHandle::finished()
{
    if (!fNotInitialized)
        initialize();

    if (fUnusedHandle)
    {
        fUnusedHandle = FALSE;
        advanceCurrentHandle();
    }
    else if (pCurrentHandle && pCurrentHandle->finished())
    {
        advanceCurrentHandle();
    }

    if (!pCurrentHandle) return TRUE;    // no more entries
    else return FALSE;
}



/***************** CIndexLookupHandle Methods *****************/

void
CIndexLookupHandle::lookupIfNecessary() {    // client unhappy, start all over again
    rundown();
    delete pEIterator;
    pEIterator = myRpcLocator->IndexLookup(pGVInterface);
    advanceCurrentHandle();
}





CIndexLookupHandle::CIndexLookupHandle(
            CGUIDVersion    *    pGVInf,
            CGUIDVersion    *    pGVXferSyntax,
            CGUID           *    pIDobj,
            unsigned long        ulVectSize,
            unsigned long        ulCacheAge
        )
        : CGroupLookupHandle(
                    myRpcLocator->IndexLookup(pGVInf),
                    pGVInf,
                    pGVXferSyntax,
                    pIDobj,
                    ulVectSize,
                    ulCacheAge
                    )
{}
/********/


void CMemberEntry::materialize() // get the real entry now
{
     pRealEntry = GetEntryFromDS(
                  RPC_C_NS_SYNTAX_DCE,
                  getCurrentName()
                  );

}



CLookupHandle *
CMemberEntry::lookup(
            CGUIDVersion    *    pGVInterface,
            CGUIDVersion    *    pGVTransferSyntax,
            CGUID           *    pIDobject,
            unsigned long        ulVectorSize,
            unsigned long        ulCacheAge
            )
{
    materialize();

    if (pRealEntry == NULL) return new CNullLookupHandle;

    CLookupHandle *pHandle = pRealEntry->lookup(
                                            pGVInterface,
                                            pGVTransferSyntax,
                                            pIDobject,
                                            ulVectorSize,
                                            ulCacheAge
                                            );

    EntryType type = pRealEntry->getType();

    if (type == GroupEntryType || type == ProfileEntryType)
    {
        CGroupLookupHandle *pGroupHandle = (CGroupLookupHandle*) pHandle;
        pGroupHandle->setVisitedEntries(pVisitedEntries);
    }

    return pHandle;
}



/****************** CGroupEntry Methods ******************/


CLookupHandle * CGroupEntry::lookup(
        CGUIDVersion    *    pGVInterface,
        CGUIDVersion    *    pGVTransferSyntax,
        CGUID           *    pIDobject,
        unsigned long        ulVectorSize,
        unsigned long        ulCacheAge
        )
{
    TCSafeSkipListIterator<CEntryName> GroupListIter(GroupList);

    TSLLEntryList EntryList;
    CEntryName *pEntryName;

    while (pEntryName = GroupListIter.next())
    {
        CMemberEntry *pEntry =
            new CMemberEntry(pEntryName->getCurrentName());

        EntryList.enque(pEntry);
    }

    DWORD size = EntryList.size();
    if (size > 0) EntryList.rotate(GetTickCount() % size);  // randomize

    TSLLEntryListIterator *pSLLEntryIterator = new TSLLEntryListIterator(EntryList);

    return new CGroupLookupHandle(
                            pSLLEntryIterator,
                            pGVInterface,
                            pGVTransferSyntax,
                            pIDobject,
                            ulVectorSize,
                            ulCacheAge
                            );
}


CGroupInqHandle *
CGroupEntry::GroupMbrInquiry()
{
    return new CGroupInqHandle(
                    new TCSafeSkipListIterator<CEntryName>(GroupList), this
              );
}



/****************** CProfileEntry Methods ******************/



CProfileInqHandle *
CProfileEntry::ProfileEltInquiry(
            DWORD inquiry_type,
            NSI_IF_ID_P_T if_id,
            DWORD vers_option,
            STRING_T member_name
            )
{
    TCSafeSkipListIterator<CProfileElement> EltListIter(EltList);
    TCSafeLinkList<CProfileElement> ResultList;
    CProfileElement *pElt;

    if (inquiry_type == RPC_C_PROFILE_DEFAULT_ELT)
    {
        if (pDefaultElt != NULL)
        {
            ResultList.insert(pDefaultElt);
        }
    }
    else while (pElt = EltListIter.next())
    {
        BOOL fMatchesIf = TRUE, fMatchesName = TRUE;

        if (inquiry_type == RPC_C_PROFILE_MATCH_BY_IF ||
            inquiry_type == RPC_C_PROFILE_MATCH_BY_BOTH)
        {
            if (
                !if_id ||
                !pElt->Interface.isMatching(
                                    CGUIDVersion(*if_id),
                                    vers_option
                                    )
                )
            {
                fMatchesIf = FALSE;
            }
        }

        if (inquiry_type == RPC_C_PROFILE_MATCH_BY_MBR ||
            inquiry_type == RPC_C_PROFILE_MATCH_BY_BOTH)
        {
            if (
                !member_name ||
                pElt->EntryName != CEntryName(member_name)
               )
            {
                fMatchesName = FALSE;
            }
        }

        if (fMatchesIf && fMatchesName)
        {
            ResultList.insert(pElt);
        }
    }

    return new CProfileInqHandle(
            new TCSafeLinkListIterator<CProfileElement>(ResultList), this
            );
}



void CProfileEntry::AddElement(
            RPC_SYNTAX_IDENTIFIER    *  pInterface,
            STRING_T                    pEntryName,
            DWORD                       dwPriority,
            STRING_T                    pszAnnotation
            )
{
    HRESULT          hr=S_OK;
    BOOL         fChanges = FALSE;

    if (pInterface==NULL)
    {
        // replace default element
        if (pDefaultElt)
            delete pDefaultElt;

        pDefaultElt = new CProfileElement(
                                    NULL,
                                    pEntryName,
                                    0,             // fixed for default
                                    pszAnnotation,
                                    this
                                    );

        hr = pDefaultElt->AddToDS();
        if (FAILED(hr)) {
           DWORD dwErr = RemapErrorCode(hr);
           if (dwErr == NSI_S_INTERNAL_ERROR)
               Raise(NSI_S_PRF_ELT_NOT_ADDED);
           else
               Raise(dwErr);
        }
        return;
    }

    CProfileKey *pKey = new CProfileKey(pInterface,pEntryName);
    CProfileElement *pElt = EltList.find(pKey);
    delete pKey;

    if (pElt != 0)
    {
        // update case
    if (pElt->dwPriority != dwPriority) {
       pElt->dwPriority = dwPriority;
       fChanges = TRUE;
    }

    if (wcscmp(pElt->pszAnnotation, pszAnnotation) != 0) {
       pElt->pszAnnotation = pszAnnotation;
       fChanges = TRUE;
    }
    }
    else
    {
        // new profile element case
    fChanges = TRUE;

        pElt = new CProfileElement(
                                pInterface,
                                pEntryName,
                                dwPriority,
                                pszAnnotation,
                                this
                                );
    }


    if (fChanges)
        hr = pElt->AddToDS();

    if (FAILED(hr)) {
        DWORD dwErr = RemapErrorCode(hr);
        if (dwErr == NSI_S_INTERNAL_ERROR)
           Raise(NSI_S_PRF_ELT_NOT_ADDED);
        else
           Raise(dwErr);
    }
}


CLookupHandle * CProfileEntry::lookup(
        CGUIDVersion    *    pGVInterface,
        CGUIDVersion    *    pGVTransferSyntax,
        CGUID           *    pIDobject,
        unsigned long        ulVectorSize,
        unsigned long        ulCacheAge
        )
{
    // Traverse Profile lists in priority order, randomize the individual lists
    // and form a list of entry names from matching profile elements

    TCSafeSkipListIterator<CProfileSet> ProfileListIter(ProfileList);

    TSLLEntryList EntryList;

    if (pDefaultElt != NULL)  // Always add it in
    {
        CMemberEntry *pEntry =
            new CMemberEntry(pDefaultElt->EntryName.getCurrentName());

        EntryList.enque(pEntry);
    }

    CProfileSet *pSet;

    while (pSet = ProfileListIter.next())
    {
        ASSERT(pSet->size() > 0, "Empty priority set in profile\n");

        // randomize before searching
        pSet->rotate(GetTickCount() % pSet->size());

        TCSafeLinkListIterator<CProfileElement> EltListIter(*pSet);

        CProfileElement *pElt;

        while (pElt = EltListIter.next())
        {
            if ((!pGVInterface) || (pElt->Interface.isCompatibleGV(*pGVInterface)))
            {
                CMemberEntry *pEntry =
                    new CMemberEntry(pElt->EntryName.getCurrentName());

                EntryList.enque(pEntry);
            }
        }
    }

    TSLLEntryListIterator *pSLLEntryIterator = new TSLLEntryListIterator(EntryList);

    return new CGroupLookupHandle(
                            pSLLEntryIterator,
                            pGVInterface,
                            pGVTransferSyntax,
                            pIDobject,
                            ulVectorSize,
                            ulCacheAge
                            );
}


/***************** CInterfaceIndex Methods *****************/

void
CInterfaceIndex::insert(
            CServerEntry * pSElocation,
            CInterface * pInf)

/*++
Routine Description:

    Insert an interface into the interface index.  The interface is either new
    or has had some new binding handles inserted in it.  In the latter case,
    we do not need to reinsert it.

Arguments:

            pSElocation        -    The server entry where the interface occurs
            pInf            -    The new or changed interface

Returns:

    nothing

--*/
{
        CGUID InfID(pInf->myGUID());

        CriticalWriter me(rwLock);        // acquires writer lock

        CInterfaceIndexEntry *pCurrentIndex =
            InterfaceEntries.find(&InfID);

        if (!pCurrentIndex) {
            pCurrentIndex = new CInterfaceIndexEntry(InfID);
            InterfaceEntries.insert(pCurrentIndex);
        }

        pCurrentIndex->insert(pSElocation);
        pNullIndex->insert(pSElocation);
}

void
CInterfaceIndex::remove(
            CServerEntry * pSElocation,
            CInterface * pInf)

/*++

Routine Description:

    Remove an interface from the interface index.
Arguments:

            pSElocation        -    The server entry where the interface occurs
            pInf            -    The new or changed interface

Returns:

    nothing

Remarks:

    Currently, this routine does nothing since we don't know when ALL
    interfaces with a given GUID have been removed from an entry.
    This is harmless since it only means that we may search such an entry
    uselessly for this interface -- a performance problem only.

    N.B. It is a problem if we try to delete the entries in the brodcast
    cache and prevent bloating of locator. Presently this is not the case.

--*/
{
}

void
CInterfaceIndex::removeServerEntry(
            CServerEntry * pSElocation
            )
/*++

Routine Description:

    Remove an interface from the interface index.
Arguments:

            pSElocation        -    The server entry where the interface occurs

Returns:

    nothing

Remarks:

   We will delete all the interface entries in this structure that
   points to this server entry. We do not need to explicitly construct
   the interface structure.

   we can make this structure if we maintain a list of all the interfaces that
   points to this structure.

   N.B. Should change this if performance is a problem.
--*/
{
    CriticalWriter me(rwLock);

    TCSafeSkipListIterator<CInterfaceIndexEntry> iter(InterfaceEntries);
    // Make an iterator for the interfaces.

    for (CInterfaceIndexEntry *ifindx = iter.next(); ifindx;
                           ifindx = iter.next())
        ifindx->remove(pSElocation);
    // for each interface remove the server entry.
    pNullIndex->remove(pSElocation);
}


TSLLEntryList *
CInterfaceIndex::lookup(
            CGUIDVersion    *    pGVInterface
        )
{
    TSLLEntryList * pTrialEntries =  new TSLLEntryList;
    CInterfaceIndexEntry *pIndex = NULL;

    CriticalReader me(rwLock);

    if (!pGVInterface) pIndex = pNullIndex;

    else {
        CGUID InfID(pGVInterface->myGUID());
        pIndex = InterfaceEntries.find(&InfID);
    }

    if (pIndex) {
        TCSafeSkipListIterator<CStringW> iter(pIndex->PossibleEntries);

        /* the reason for splitting full entries and separately inserting NonLocal
           and local entries below is to avoid net lookup for these these
           entries.  Since Index lookup is used exclusively for default
           entry lookup, there is a separate net component to it already.
        */

        for (CStringW *pName = iter.next(); pName; pName = iter.next()) {
            CEntry * pEntry = pMyLocator->findEntry(pName);

            /* NOTE: only full server entries are indexed */

            CFullServerEntry *pfse = (CFullServerEntry *) pEntry;

            if (pfse) {

                ASSERT((pfse->getType() == FullServerEntryType),
                       "Wrong entry type in interface index\n"
                      );

                pTrialEntries->insert(pfse->getLocal());
                pTrialEntries->insert(pfse->getNonLocal());
            }
        }
    }

    return pTrialEntries;
}

/***********************LocToLocCompleteHandle methods*****************/

void
CLocToLocCompleteHandle::StripObjectsFromAndCompress(
        NSI_BINDING_VECTOR_P_T * BindingVectorOut)
/*++

Routine Description:

    The vector of binding handles normally returned from a lookup handle
    contains binding strings with objects (if objects are present).
    However, this is not usable in locator-to-locator communication
    because the old (Steve Zeck's) locator expects objectless
    strings and simply attaches objects in front of the strings it gets
    from a master.  We therefore strip the objects from these strings
    when they are meant to be returned to another locator.  This also
    gives us an opportunity to eliminate duplicates, which is important
    because an object inquiry must be done via RPC for every binding
    string returned to the inquiring locator as a result of the weakness
    of the current locator-to-locator interface.

    Duplicates where eliminated before only in the returned vector. Because
    only the string bindings are returned, there can be duplicates across the
    various binding vectors returned. But these duplicates come together. Hence
    the last returned binding is maintained and it is returned only if it
    doesn't match the prev binding.

  // N.B. Order is very important in the BindingVectorOut.

Arguments:

    StatusCode    - the code to test

Returns

    TRUE if normal, FALSE if internal error (such as failure to connect to master locator).

--*/
{
    if (!*BindingVectorOut) return;

    NSI_BINDING_VECTOR_P_T pbvtGivenVector = *BindingVectorOut;

    TCSafeSkipList<CNSBinding> SSLwinnow;

    for (ULONG i = 0; i < pbvtGivenVector->count; i++)
    {
        STRING_T pszOld = pbvtGivenVector->binding[i].string;
        STRING_T pszNew = makeBindingStringWithObject(pszOld,NULL);
        pbvtGivenVector->binding[i].string = CStringW::copyMIDLstring(pszNew);
        midl_user_free(pszOld);
        RpcStringFree(&pszNew);

        CNSBinding *pNSB = new CNSBinding(pbvtGivenVector->binding[i]);
        // checking for bindings that have been sent out before.

        if ((prevBinding) && (pNSB->compare(*prevBinding) == 0))
        {
            delete pNSB;
            continue;
        }

        if (Duplicate == SSLwinnow.insert(pNSB))
            delete pNSB;
        else
        {
            if (prevBinding)
            {
                delete prevBinding;
                prevBinding = NULL;
            }
            prevBinding = new CNSBinding(pbvtGivenVector->binding[i]);
        }
    }

    ULONG ulBVcount = SSLwinnow.size();

    NSI_BINDING_VECTOR_P_T pbvtNewVector =
            (NSI_BINDING_VECTOR_T *)
            midl_user_allocate(sizeof(UNSIGNED32) + sizeof(NSI_BINDING_T)*ulBVcount);

   pbvtNewVector->count = ulBVcount;

   TCSafeSkipListIterator<CNSBinding> nsbIter(SSLwinnow);

   CNSBinding* pNSB = nsbIter.next();

   for (ULONG j=0; j < ulBVcount; j++)
   {
         pNSB->copyBinding(pbvtNewVector->binding[j]);
         pNSB = nsbIter.next();
   }

   CBVWrapper destructor(pbvtGivenVector);    // wrap to release
   destructor.rundown();            // run down the pbvtGivenVector

   SSLwinnow.wipeOut();                // release CNSBinding objects

   *BindingVectorOut = pbvtNewVector;
}



/*********************CDSLookupHandle methods*****************************/
#if DBG
    ULONG CDSLookupHandle::ulDSLookupHandleCount = 0;
    ULONG CDSLookupHandle::ulDSLookupHandleNo = 0;
#endif

void
CDSLookupHandle::initialize()
/*++
Method Description: CServerEntry::lookup
    Looks up in the DS for the entryName. If found it keeps in the cache
    and stores the lookup handle by calling the lookup function corresp.
    to the entryname.
Remarks:

--*/
{
    CEntry    *pEntry=NULL;

    fNotInitialized = FALSE;

    pEntry = GetEntryFromDS(
            RPC_C_NS_SYNTAX_DCE,
            (STRING_T)(*penEntryName)
            );
    if (pEntry)
    {
        pRealHandle = pEntry->lookup(pgvInterface, pgvTransferSyntax, pidObject,
                                ulVS, ulCacheMax);
    }
    else
        pRealHandle = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\respond.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    respond.cxx

Abstract:

	This file contains the code for responding to broadcasts from
	name service clients looking for a locator service.  This includes

    1.  implementations of two member functions of class Locator

    2.  a listener thread

Author:

    Satish Thatte (SatishT) 08/21/95  Created all the code below except where
									  otherwise indicated.

--*/

#include <locator.hxx>



void
Locator::respondToLocatorSeeker(
		IN QUERYLOCATOR		Query
		)
{

	// first see if we should reply at all

    // ignore messages to self. A request on a group mailslot
    // will be delivered to the local slot too.

	STRING_T szRequester;	  // name without whacks

	if (hasWhacksInMachineName(Query.RequesterName))
		szRequester = Query.RequesterName+2;
	else szRequester = Query.RequesterName;


	if (IsSelf(szRequester)) return;

    // closing a possible security hole.
    if (szRequester[0] == L'?') return;

	// OK, now see if the request fits our status

	switch (Query.MessageType) {

	  case QUERY_MASTER_LOCATOR:
		  if (!IsInMasterRole()) return;
		  else break;

	  case QUERY_BOUND_LOCATOR:
	  case QUERY_ANY_LOCATOR:
		  break;

	  case QUERY_DC_LOCATOR:
		  if (!(IsInDomain() && (IsInMasterRole() || IsInBackupRole())))
		     return;
		  else break;

	  default:
		  DBGOUT(BROADCAST, "Bogus Query MsgType=" << Query.MessageType << "\n\n");
		  return;
	};

	// OK, looks like we are going to reply

	QUERYLOCATORREPLY Reply;

   // fill in our name and other items

	wcscpy(Reply.SenderName,TEXT("\\\\"));
	wcscpy(Reply.SenderName+2,*myRpcLocator->getComputerName());

	Reply.Uptime = CurrentTime() - StartTime;

	if (IsInMasterRole())
	   Reply.Hint = REPLY_MASTER_LOCATOR;

	else if (IsInDomain() && IsInBackupRole())
		Reply.Hint = REPLY_DC_LOCATOR;

	else Reply.Hint = REPLY_OTHER_LOCATOR;

    // create the return Mailslot

	STRING_T sz = catenate(TEXT("\\\\"),szRequester);
	WRITE_MAIL_SLOT MSReply(sz, RESPONDERMSLOT_C);
 	delete [] sz;

	// and write the reply

	MSReply.Write((char *) &Reply, sizeof(Reply));

}


void
Locator::TryBroadcastingForMasterLocator(
                        )
{
	QUERYLOCATOR Query;
	QUERYLOCATORREPLY QueryReply;

	if (!hMasterFinderSlot) {
		return;
	}

	Query.SenderOsType = OS_NTWKGRP;
	Query.MessageType  = QUERY_MASTER_LOCATOR;

	STRING_T myName = catenate(TEXT("\\\\"),*myRpcLocator->getComputerName());
	wcscpy(Query.RequesterName,myName);
	delete [] myName;

    csMasterBroadcastGuard.Enter();

	__try {
	
		WRITE_MAIL_SLOT BSResponder(NULL,RESPONDERMSLOT_S);

		BSResponder.Write((char *) &Query, sizeof(Query));

		ULONG waitCur = INITIAL_MAILSLOT_READ_WAIT; // current wait time for replies

		long cbRead = 0;

		while (cbRead = hMasterFinderSlot->Read((char *) &QueryReply,
													  sizeof(QueryReply),
													  waitCur
													 )
			  )
		{
			if (
				(QueryReply.Hint == REPLY_MASTER_LOCATOR) ||
				(QueryReply.Hint == REPLY_DC_LOCATOR)
			   )
			{
				addMaster(QueryReply.SenderName + 2);
			}

				// halve the wait period everytime you get a response from the net

			waitCur >>= 1;
		}
	}

	__finally {
		csMasterBroadcastGuard.Leave();
	}
}


void
ResponderProcess(void*)		
/*++

Routine Description:

    This thread creates a mailslot and listens for requests for locators,
	responding if appropriate.

--*/
{
    QUERYLOCATOR LocatorQuery;

	DWORD dwMailSize;

    // create a server (s) mailslot

    READ_MAIL_SLOT hMailslotForQueries(RESPONDERMSLOT_S, sizeof(QUERYLOCATOR));

    while (1) {

		dwMailSize = hMailslotForQueries.Read(
								(char *) &LocatorQuery,
								sizeof(QUERYLOCATOR),
								MAILSLOT_WAIT_FOREVER
								);

		CriticalReader  me(rwLocatorGuard);
		// after mailslot recv's a message, take a locator
		// lock.
		if (dwMailSize != sizeof(QUERYLOCATOR))
			continue;	   // strange query, ignore it

		DBGOUT(BROADCAST, LocatorQuery.RequesterName  << " sent query for locator"  << "\n\n");

		myRpcLocator->respondToLocatorSeeker(LocatorQuery);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\master.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    master.cxx

Abstract:

    This file contains the implementations for non inline member functions
    of CMasterLookupHandle and CMasterObjectInqHandle, which are classes used for
    interaction with a master locator for looking up binding handles and objects.

Things to improve in future revisions:

 1. The structure of the locator-to-locator RPC interface needs a complete redesign.
    The query to a master locator should be for a complete entry, not piecemeal
    and painfully repetitive as it is now.

 2. There is a suspicion that client locators don't release all the lookup handles
    they get from a master locator (about 1 in 200 in a random test), probably in
    exceptional circumstances.  This needs to be fixed if true.

Author:

    Satish Thatte (SatishT) 10/1/95  Created all the code below except where
                                      otherwise indicated.

--*/

#include <locator.hxx>


#if DBG
    ULONG CMasterLookupHandle::ulMasterLookupHandleCount = 0;
    ULONG CMasterLookupHandle::ulMasterLookupHandleNo = 0;
#endif

NSI_UUID_VECTOR_P_T
getObjectVector(
    IN RPC_BINDING_HANDLE hCurrentMaster,
    IN UNSIGNED32 EntryNameSyntax,
    IN STRING_T EntryName,
    OUT ULONG& StatusCode
    )
/*++

Routine Description:

    Broadcasts for the requested binding handles.

Arguments:

    hCurrentMaster        - the binding handle for the master locator

    EntryNameSyntax        - syntax of entry name

    EntryName            - entry name for object query

    StatusCode            - status of query returned here

Returns:

    A standard UUID vector containing the object UUIDs returned by the
    master locator.

--*/
{
    STATUS Status;

    NSI_UUID_VECTOR_P_T pUuidVector = NULL;

    HANDLE hObjectHandle = NULL;

//    RpcImpersonateClient(0);

    RpcTryExcept {

        CLIENT_I_nsi_entry_object_inq_begin(
              hCurrentMaster,
              EntryNameSyntax,
              EntryName,
              &hObjectHandle,
              &Status
              );
    }
    RpcExcept (EXCEPTION_EXECUTE_HANDLER) {
        RpcBindingFree(&hCurrentMaster);
        hCurrentMaster = NULL;

        StatusCode = RpcExceptionCode();

        if (StatusCode == RPC_S_ACCESS_DENIED)
            StatusCode = NSI_S_NO_NS_PRIVILEGE;

//        RpcRevertToSelf();
        return NULL;
    }
    RpcEndExcept;

    if ((StatusCode = Status) != NSI_S_OK) return NULL;

    CLIENT_I_nsi_entry_object_inq_next(
               hCurrentMaster,
               hObjectHandle,
               &pUuidVector,
               &Status
               );

    StatusCode = Status;

    CLIENT_I_nsi_entry_object_inq_done(
                       &hObjectHandle,
                       &Status
                       );

    StatusCode = Status;

//    RpcRevertToSelf();

    return pUuidVector;
}




void
CMasterLookupHandle::initialize()
/*++

Method Description:

    Establishes contact with the master locator and acquires a context handle
    for the lookup parameters stored as members in this object.

Remarks:

    The reason for separating initialization as a method separate from the
    constructor is that "lookupIfNecessary" may force reinitialization if
    the information is too stale.  This can happen if the user resets the
    expiration age for a specific context handle.

--*/
{
    DBGOUT(TRACE,"CMasterLookupHandle::initialize called for Handle#" << ulHandleNo << "\n\n");

    StatusCode = NSI_S_OK;

    RPC_SYNTAX_IDENTIFIER interfaceID;

    if (pgvInterface) interfaceID =    *pgvInterface;

    RPC_SYNTAX_IDENTIFIER xferSyntaxID;

    if (pgvTransferSyntax) xferSyntaxID = *pgvTransferSyntax;

    NSI_UUID_T objID;

    if (pidObject) objID = pidObject->myGUID();

    UNSIGNED16 status = 0;

    if (RpcMgmtSetCancelTimeout(CONNECTION_TIMEOUT) != RPC_S_OK)
        {
        StatusCode = NSI_S_OUT_OF_MEMORY;
        return;
        }

    DBGOUT(TRACE, "Connecting to Master Locator\n");

    hCurrentMaster = ConnectToMasterLocator(
                            StatusCode
                            );


    if (!hCurrentMaster || StatusCode) {
        StatusCode = NSI_S_NAME_SERVICE_UNAVAILABLE;
        myRpcLocator->SetDCsDown();

        return;
    }
    else myRpcLocator->SetDCsUp();

//    RpcImpersonateClient(0);

    lookupHandle = NULL;

    /* The following is a work around, because the compiler refuses to accept

           penEntryName ? (*penEntryName) : NULL

    */

    STRING_T szEntryName = NULL;
    if (penEntryName) szEntryName = *penEntryName;

    DBGOUT(TRACE, "Lookup begin called for master locator\n");
    RpcTryExcept {
        CLIENT_I_nsi_lookup_begin(
                hCurrentMaster,
                u32EntryNameSyntax,
                szEntryName,
                pgvInterface? &interfaceID : NULL,
                pgvTransferSyntax? &xferSyntaxID : NULL,
                pidObject? &objID : NULL,
                ulVS,
                ulCacheMax? ulCacheMax: ulCacheMax+CACHE_GRACE, // ensures that it is nonzero
                &lookupHandle,    // the above is wierd but necessary because ulCacheAge is frequently -1
                &status
                );
    }
    RpcExcept (EXCEPTION_EXECUTE_HANDLER) {

        RpcBindingFree(&hCurrentMaster);
        hCurrentMaster = NULL;

        StatusCode = RpcExceptionCode();

        if (StatusCode == RPC_S_ACCESS_DENIED)
            StatusCode = NSI_S_NO_NS_PRIVILEGE;

         // this is a copout to take care of NT vs NSI code conflicts

        else if (StatusCode < NSI_S_STATUS_MAX)
            StatusCode = NSI_S_NAME_SERVICE_UNAVAILABLE;

//        RpcRevertToSelf();
        return;
    }
    RpcEndExcept;

//    RpcRevertToSelf();

    StatusCode = status;    // hopefully, RPC_S_OK;

    fFinished = FALSE;

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}



BOOL
CMasterLookupHandle::fetchNext()
/*++

Method Description:

    Fetches the next vector of binding handles from the master locator, along
    with associated object UUIDs.

Remarks:

    The process is inefficient in that each binding handle returned has an
    entry name associated with it and we must make a full fledged object query
    for every binding handle.  This is extremely expensive but the current structure
    of the locator-to-locator interface forces it upon us.

--*/
{
    DBGOUT(TRACE,"CMasterLookupHandle::fetchNext called for Handle#" << ulHandleNo << "\n\n");

    STATUS status;

    /* We only want to run down the info acquired in the last fetchNext.
       A full-scale rundown of the handle would also give up the context
       handle and binding to the master locator, which would ruin us.
       The only thing we have to fix is to reset the fNotInitialzed flag,
       so that we don't call initialize() again on this handle.
    */

    CRemoteLookupHandle::rundown();
    fNotInitialized = FALSE;

    psslNewCache = new TSSLEntryList;

    NSI_BINDING_VECTOR_T * pNextVector = NULL;

//    RpcImpersonateClient(0);

    RpcTryExcept {

        CLIENT_I_nsi_lookup_next(
                            hCurrentMaster,
                            lookupHandle,
                            &pNextVector,
                            &status
                            );
        }
    RpcExcept (EXCEPTION_EXECUTE_HANDLER) {

        RpcBindingFree(&hCurrentMaster);
        hCurrentMaster = NULL;

        StatusCode = RpcExceptionCode();

        if (StatusCode == RPC_S_ACCESS_DENIED)
            StatusCode = NSI_S_NO_NS_PRIVILEGE;

//        RpcRevertToSelf();
        return FALSE;
    }
    RpcEndExcept;

//    RpcRevertToSelf();

    StatusCode = status;

    if (status == NSI_S_NO_MORE_BINDINGS) return FALSE;

    else if (status != NSI_S_OK) Raise(status);

    else {

        NSI_UUID_VECTOR_P_T pUuidVector;

         for (unsigned int i = 0; i < pNextVector->count; i++)
           {

               pUuidVector = getObjectVector(
                                    hCurrentMaster,
                                    pNextVector->binding[i].entry_name_syntax,
                                    pNextVector->binding[i].entry_name,
                                    StatusCode
                                    );

              /* first update the central cache and, if there is anything new,
                 also update the temporary cache in psslNewCache
              */

               CGUIDVersion nullGV;    // standard initialization to null


               myRpcLocator->UpdateCache(
                          pNextVector->binding[i].entry_name,
                          pNextVector->binding[i].entry_name_syntax,
                          pgvInterface ? *pgvInterface : nullGV,
                          pgvTransferSyntax ? *pgvTransferSyntax : nullGV,
                          pNextVector->binding[i].string,
                          pUuidVector,
                          psslNewCache
                          );

               midl_user_free(pNextVector->binding[i].entry_name);
               midl_user_free(pNextVector->binding[i].string);

               if (pUuidVector) {
                   for (unsigned int j = 0; j < pUuidVector->count; j++)
                          midl_user_free(pUuidVector->uuid[j]);

                   midl_user_free(pUuidVector);
               }

               pUuidVector = NULL;
         }

         midl_user_free(pNextVector);
    }

    TEntryIterator *pCacheIter = new TSSLEntryListIterator(*psslNewCache);

    plhFetched = new CGroupLookupHandle(
                                    pCacheIter,
                                    pgvInterface,
                                    pgvTransferSyntax,
                                    pidObject,
                                    ulVS,
                                    ulCacheMax
                                    );

    /* do not delete psslNewCache -- it is done by the constructor above */

    return TRUE;
}


void
CMasterLookupHandle::rundown()
/*++

Method Description:

    Release the binding to the master and the context handle received from the master.

Remarks:

    The reason to separate this from the destructor is similar to the case of
    initialize(), i.e., finalization may happen due to reinitialization rather than
    destruction.

--*/{

    DBGOUT(TRACE,"CMasterLookupHandle::rundown called for Handle#" << ulHandleNo << "\n\n");

    STATUS status;

    // First do the standard rundown for remote handles

    CRemoteLookupHandle::rundown();

    //  Then try closing lookupHandle in master locator

    if (hCurrentMaster) {

//        RpcImpersonateClient(0);

        RpcTryExcept {

            CLIENT_I_nsi_lookup_done(
                                hCurrentMaster,
                                &lookupHandle,
                                &status
                                );

        }
        RpcExcept (EXCEPTION_EXECUTE_HANDLER) {
            DBGOUT(MEM1,"Could not close lookup handle in master\n\n");
        }
        RpcEndExcept;

        RpcBindingFree(&hCurrentMaster);
        hCurrentMaster = NULL;
//         RpcRevertToSelf();
    }

}




CMasterObjectInqHandle::CMasterObjectInqHandle(
        STRING_T szEntryName,
        ULONG ulCacheAge
        )
        : CRemoteObjectInqHandle(szEntryName,ulCacheAge)
{
}

void
CMasterObjectInqHandle::initialize() {

    ulIndex = 0;

    StatusCode = NSI_S_OK;

    if (RpcMgmtSetCancelTimeout(CONNECTION_TIMEOUT) != RPC_S_OK)
        {
        StatusCode = NSI_S_OUT_OF_MEMORY;
        return;
        }

    RPC_BINDING_HANDLE hCurrentMaster =
                        ConnectToMasterLocator(
                                StatusCode
                                );

    if (!hCurrentMaster || StatusCode) {
        myRpcLocator->SetDCsDown();
        return;
    }
    else myRpcLocator->SetDCsUp();

    /* The following is a work around, because the compiler refuses to accept

           penEntryName ? (*penEntryName) : NULL

    */

    STRING_T szEntryName = NULL;
    if (penEntryName) szEntryName = *penEntryName;

    pUuidVector = getObjectVector(
                    hCurrentMaster,
                    RPC_C_NS_SYNTAX_DCE,
                    szEntryName,
                    StatusCode
                    );

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\switch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       switch.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
		   Copyright(c) Microsoft Corp., 1990

	This file contains a class definition for switch processing

		  This is taken practically unchanged from the RPC locator 
            written by Steven Zeck

-------------------------------------------------------------------- */

#include <locator.hxx>

#define RpcStrdup strdup
#define TRUE 1
#define FALSE 0


#define USED(arg) ((void)(arg))

int TailMatch( char * pszPatt, char * pszIn);

char *ProcessArgs(
SwitchList aSLCur,
char **aArgs

  // Process a list of arguments
) //-----------------------------------------------------------------------//
{
   char * pszArgCur, *pszParm;

    for (; *aArgs; aArgs++) {

	for (SWitch *pSW = aSLCur; pSW->name; pSW++) {

	   pszArgCur = *aArgs;
	   pszParm = pSW->name;

	   while (*pszParm) {

		if (*pszParm == '#') {

		    // optional space between flag and argument

		    if (!*pszArgCur) {
			pszArgCur = *(++aArgs);

			if (!pszArgCur)
			    return(aArgs[-1]);
		    }

		    if (TailMatch(pszParm, pszArgCur))
			goto found;
		}

		else if (*pszParm == '*') {

		   // no space allowed between flag and argument

		    if (*pszArgCur && TailMatch(pszParm, pszArgCur))
			goto found;

		    break;

		}
		else {

		     // do a case insensitive compare, pattern is always lower case

		      if (*pszArgCur >= 'A' && *pszArgCur <= 'Z') {
			 if ((*pszArgCur | 0x20) != *pszParm)
			    break;
		      }
		      else if (*pszArgCur != *pszParm)
			   break;

		    pszArgCur++; pszParm++;

		    if (! *pszArgCur && !*pszParm)
		       goto found;
		}
	    }
	}

	return(*aArgs);		// parm in error

found:
	if ((*pSW->pProcess)(pSW, pszArgCur))
	    return(*aArgs);

    }
    return(0);	// sucess all parms matched

}



int TailMatch(		// match substrings from right to left *^
char * pszPatt,		// pattern to match
char * pszIn			// input pszInint to match

 //compare a tail pszPatt (as in *.c) with a pszIning.  if there is no
 //tail, anything matches.  (null pszInings are detected elsewhere)
 //the current implementation only allows one wild card
)//-----------------------------------------------------------------------//
{
    register char * pszPattT = pszPatt;
    register char * pszInT = pszIn;

    if (pszPattT[1] == 0)  /* wild card is the last thing in the pszPatt, it matches */
	return(TRUE);

    while(pszPattT[1]) pszPattT++;    // find char in front of null in pszPatt

    while(pszInT[1]) pszInT++;	    // find char in front of null in pszIning to check

    while(1) {			    // check chars walking towards front

	// do a case insensitive compare, pattern is always lower case

	if (*pszInT >= 'A' && *pszInT <= 'Z') {
	    if ((*pszInT | 0x20) != *pszPattT)
		return (FALSE);
	}
	else if (*pszInT != *pszPattT)
	    return(FALSE);

	pszInT--;
	pszPattT--;

	/* if we're back at the beginning of the pszPatt and
	 * the pszIn is either at the beginning (but not before)
	 * or somewhere inside then we have a match. */

	if (pszPattT == pszPatt)
	    return(pszInT >= pszIn);

    }
    return(FALSE);
}

int ProcessInt(		// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    for (char * psz=pszText; *psz; ++psz)
	if (*psz < '0' || *psz > '9')
	    return(TRUE);

    *(int *)pSW->p = atoi(pszText);
    return(FALSE);
}


int ProcessLong(	// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    for (char * psz=pszText; *psz; ++psz)
	if (*psz < '0' || *psz > '9')
	    return(TRUE);

    *(long *)pSW->p = atol(pszText);
    return(FALSE);
}

int ProcessChar(	// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
//   if (*(char * *)pSW->p)	// can only set char *'s once
//	return(TRUE);

	int size = strlen(pszText) + 1;
	*(char * *)pSW->p = new char[size];
    strcpy(*(char * *)pSW->p,pszText);
    return(FALSE);
}


int ProcessSetFlag(	// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    USED(pszText);

    *(int *)pSW->p = TRUE;
    return(FALSE);
}


int ProcessResetFlag(	// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    USED(pszText);

    *(int *)pSW->p = FALSE;
    return(FALSE);
}


int ProcessYesNo(	// Set a flag numeric value, either Yes or No *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    *(int *)pSW->p = (*pszText | 0x20) == 'y';
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\simplell.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    simpleLL.cxx

Abstract:

	This module contains definitions of non inline member functions for the
	CSimpleLinkList class, which is a linked list without reference counting.
	
Author:

    Satish Thatte (SatishT) 11/20/95  Created all the code below except where
									  otherwise indicated.

--*/

#include <locator.hxx>


void* 
CSimpleLinkList::pop() 

/*++
Routine Description:

	Delete first item in the CSimpleLinkList and return it
	
--*/

{
	if (!pLnkFirst) return NULL;
		
	void* result = pLnkFirst->data;
	Link* oldFirst = pLnkFirst;
	pLnkFirst = pLnkFirst->next;
	if (!pLnkFirst) pLnkLast = NULL;  // nothing left
	delete oldFirst;

	lCount--;
	return result;
}
		

void* 
CSimpleLinkList::nth(long lOrdinal)

/*++
Routine Description:

	Simply return the Nth data item -- starting the count at 0.
	
--*/

{
	if (!pLnkFirst) return NULL;			// empty list

	Link * pLnkCurr = pLnkFirst;
	long lCount = 0;

	while (pLnkCurr && (lCount++ < lOrdinal))
		pLnkCurr = pLnkCurr->next;

	if (!pLnkCurr) return NULL;			// not found
	else return pLnkCurr->data;
}

void 
CSimpleLinkList::rotate(long lDegree)

/*++
Routine Description:

	This routine imagines that the list is in fact circular and 
	rotates it by lDegree -- using pop and enque for modularity.  
	We could actually move links around, but this operation is
	not frequent enough (once for every NS lookup). Here we pay the
	price of not having a true circular list (we moved away from
	the true circular list for ref counting).
	
--*/

{
	if (!pLnkFirst) return;	// nothing to rotate;

	void *pCurr;

	for (long i = 0; i < (lDegree % lCount); i++) {
		pCurr = pop();
		enque(pCurr);
	}
}


	
void CSimpleLinkList::clear() {		// deletes all links but not the data

	Link * pLnkCurr = pLnkFirst; 

	while (pLnkCurr) 
	{
		Link * pLnkDel = pLnkCurr;
		pLnkCurr = pLnkCurr->next;
		delete pLnkDel;
	}

	pLnkFirst = pLnkLast = NULL; 
}



void* 
CSimpleLinkListIterator::next() {	// advance the iterator and return next void

		if (!ptr) return NULL;

		void* result = ptr->data;
		ptr = ptr->next;
		return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc
    
Note:

    Common MIDL sources file.   Put common MIDL options such as 
    compiler switches here.

!ENDIF

386_STDCALL=0
MSC_WARNING_LEVEL=/WX /W4
USE_MSVCRT=1
USE_RTTI=1

# Asserts are enabled on all builds
C_DEFINES= $(C_DEFINES) -DMIDL_ENABLE_ASSERTS

# Setup debug flags
!IF !$(FREEBUILD)
DEBUG_CRTS=1
C_DEFINES= $(C_DEFINES) -DMIDL_INTERNAL
!ENDIF

SUBSYSTEM_VERSION=4.00
UMTYPE=console

# Hacks to make new types work with old 
# format string code.  Remove before shipping
C_DEFINES= $(C_DEFINES) -DNDR64_ON_DCE_HACK



MIDL_DIR=$(_PROJECT_MK_PATH)\$(O)
MIDL_OBJ_DIR=$(_PROJECT_MK_PATH)\$(_OBJ_DIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\service.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    locator.cxx

Abstract:

    This file contains server initialization and other RPC control
    functions.  It also supplies all the necessities for running the
    locator as a system service, including the main service thread
    and service control functionality.

Author:

    Satish R. Thatte -- 9/14/1995     Created all the code below except where
                                      otherwise indicated.

Adding code here to create a seperate thread informing scm that it is alive
to protect it from the vagaries of other processes.


--*/

#include <locator.hxx>

typedef long NTSTATUS;

ULONG StartTime;                        // time the locator started

unsigned long LocatorCount;
 
CReadWriteSection rwLocatorGuard;

SERVICE_STATUS ssServiceStatus;
SERVICE_STATUS_HANDLE sshServiceHandle;


Locator *myRpcLocator;                  // the primary state of the locator
CReadWriteSection rwEntryGuard;         // single shared guard for all local entries
CReadWriteSection rwNonLocalEntryGuard; // single shared guard for all NonLocal entries
CReadWriteSection rwFullEntryGuard;     // single shared guard for all full entries
CPrivateCriticalSection csBindingBroadcastGuard;
CPrivateCriticalSection csMasterBroadcastGuard;

CPrivateCriticalSection csLocatorInitGuard;
BOOL fLocatorInitialized;

void QueryProcess(void*);
void ResponderProcess(void*);
void InformStatus(void*);


HANDLE hHeapHandle;

#if DBG
CDebugStream debugOut;       // this carries no state
#endif

unsigned char ** ppszDomainName; // name of current domain

/* this is used by Steve's switch processing code */

int fService = TRUE;                    // running as a service
long waitOnRead = 3000L;                // time to wait on reading reply back
int fNet = 1;                           // enable network functionality
DWORD maxCacheAge;                      // ignored for now -- look in class Locator
char * pszOtherDomain;                  // ASCII other domain to look.
char * pszDebugName = "locator.log";    // debug log file name
int debug = -1;                         // debug trace level

SwitchList aSwitchs = {

    {"/debug:*",               ProcessInt, &debug,},
    {"/logfile:*",             ProcessChar, &pszDebugName,},
    {"/expirationage:*",       ProcessLong, &maxCacheAge,},
    {"/querytimeout:*",        ProcessLong, &waitOnRead,},
    {"/noservice",             ProcessResetFlag, &fService,},
    {"/nonet",                 ProcessResetFlag, &fNet,},
    {"/otherdomain:*",         ProcessChar, &pszOtherDomain,},
    {0}
};

/* end of items for Steve's switch processing code */

void WaitForDomainChange()
{
	HANDLE hDomainChangeHandle = NULL;

	if (!NetRegisterDomainNameChangeNotification(&hDomainChangeHandle)) {
		// user is not informed of this.
		return;
	}

	while (1) {
		WaitForSingleObject(hDomainChangeHandle, INFINITE);
                DBGOUT(DIRSVC, "Domain Change Occured. Getting New global information\n");
		CriticalWriter  me(rwLocatorGuard);

		delete myRpcLocator;
		myRpcLocator = new Locator;
		LocatorCount++;
	}
}

void InitializeLocator()
/*++

Routine Description:

     non critical initialization code

--*/
{
    HANDLE pThreadHandle;
    unsigned long ThreadID;

    csLocatorInitGuard.Enter();

    if (!fLocatorInitialized)
    {
        // Initialize the global locator object, sets the fNT4Compat flag
        // used in StartServer

        myRpcLocator = new Locator;

        if (myRpcLocator->fNT4Compat) {
            RPC_STATUS result;
            // register the LoctoLoc interface only if NT4Compat
            if (result = RpcServerRegisterIf(LocToLoc_ServerIfHandle, NULL, NULL))
                StopLocator("RpcServerRegisterIf\n", result);
            
            pThreadHandle = CreateThread(0, 0,
                (LPTHREAD_START_ROUTINE) QueryProcess, NULL, 0, &ThreadID);
            
            if (!pThreadHandle)
                StopLocator("CreateThread Failed\n", 0);

            CloseHandle(pThreadHandle);
            
            pThreadHandle = CreateThread(0, 0,
                (LPTHREAD_START_ROUTINE) ResponderProcess, NULL, 0, &ThreadID);
            
            if (!pThreadHandle)
                StopLocator("CreateThread Failed\n", 0);

            CloseHandle(pThreadHandle);
        }
        
        pThreadHandle = CreateThread(0, 0,
            (LPTHREAD_START_ROUTINE) WaitForDomainChange, NULL, 0, &ThreadID);
        
        if (!pThreadHandle)
            StopLocator("CreateThread Failed\n", 0);
        
        CloseHandle(pThreadHandle);

        fLocatorInitialized = TRUE;
    }

    csLocatorInitGuard.Leave();
}

void
StopLocator(
    IN char * szReason,
    IN long code
    )
/*++

Routine Description:

    Die a graceful death

Arguments:

    szReason - Text message for death

    code - option error code

--*/
{
    ssServiceStatus.dwCurrentState = SERVICE_STOPPED;

    if (code) {
        ssServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        ssServiceStatus.dwServiceSpecificExitCode = code;
    }
    else ssServiceStatus.dwWin32ExitCode = GetLastError();

    if (fService && sshServiceHandle)
        SetSvcStatus();

    ExitProcess(code);
}

void
SetSvcStatus(
   )
/*++

Routine Description:

    Set the lanman service status.

--*/
{
    ASSERT(sshServiceHandle,"NT Service Handle Corrupted\n");

    if (! SetServiceStatus( sshServiceHandle, &ssServiceStatus))
        StopLocator("SetServiceStatus Failed\n", 0);
    ssServiceStatus.dwCheckPoint++;
}


void
StartServer(
    )

/*++

Routine Description:

    Call the runtime to create the server for the locator, the runtime
    will create it own threads to use to service calls.

Returns:

    Never returns.

--*/
{
    RPC_STATUS result;


    if (result = RpcServerRegisterIf(NsiS_ServerIfHandle, NULL, NULL))
        StopLocator("RpcServerRegisterIf\n", result);

    if (result = RpcServerRegisterIf(NsiC_ServerIfHandle, NULL, NULL))
        StopLocator("RpcServerRegisterIf\n", result);

    if (result = RpcServerRegisterIf(NsiM_ServerIfHandle, NULL, NULL))
        StopLocator("RpcServerRegisterIf\n", result);

    // setting the permissions to evryone read/write and owner full control, the default 
    // RPC secuiry for named pipes.

    if (result = RpcServerUseProtseqEp(TEXT("ncacn_np"),    // use named pipes for now
                                       RPC_NS_MAX_CALLS,
                                       TEXT("\\pipe\\locator"),
                                       NULL 
                                       ))
    {
        StopLocator("RpcServerUseProtseqEp Pipe\n", result);
    }


    if (result = RpcServerListen(
                1,                  // min call threads
                RPC_NS_MAX_THREADS, // max call threads
                1                   // don't wait yet
                ))
        StopLocator("RpcServerListen Failed\n", result);
    DBGOUT(BROADCAST, "Started up the server\n");
}



void __stdcall
LocatorControl(
    IN DWORD opCode      // function that we are to carry out.
   )
/*++

Routine Description:

    This function responses the service control requests.

Arguments:

    opCode - Function that we are to carry out.

--*/
{
    RPC_STATUS status;

    switch(opCode) {

        case SERVICE_CONTROL_STOP:

            // Announce that the service is shutting down
            DBGOUT(BROADCAST, "Rec'd Stop signal\n");
            ssServiceStatus.dwCheckPoint = 0;
            ssServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ssServiceStatus.dwWaitHint = 90000;
            SetSvcStatus();

            // we need to tell SCM that we are trying to shut down before doing so.
            status = RpcMgmtStopServerListening(0);
            DBGOUT(BROADCAST, "Stopped listening\n");
            return;


        case SERVICE_CONTROL_INTERROGATE:
            // Do nothing; the status gets announced below
            break ;

    }
    SetSvcStatus();
}

#define MAXCOUNTER 120

void
LocatorServiceMain(
    DWORD   argc,
    LPTSTR  *argv
   )
/*++

Routine Description:

    This is main function for the locator service.
    When we are started as a service, the service control creates a new
    thread and calls this function.

Arguments:

    argc - argument count

    argv - vector of argument pointers

--*/
{

    // Set up the service info structure to indicate the status.

    fLocatorInitialized = FALSE;

    ssServiceStatus.dwServiceType        = SERVICE_WIN32;
    ssServiceStatus.dwCurrentState       = SERVICE_START_PENDING;
    ssServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP;
    ssServiceStatus.dwWin32ExitCode      = 0;
    ssServiceStatus.dwCheckPoint         = 0;
    ssServiceStatus.dwWaitHint           = 30000;

    // Set up control handler

    LocatorCount = 0;

    if (! (sshServiceHandle = RegisterServiceCtrlHandler (
           TEXT("rpclocator"), LocatorControl)))
        StopLocator("RegisterServiceCtrlHandler Failed\n", 0);

    SetSvcStatus();
    myRpcLocator = NULL;

    // Start the RPC server
    SetSvcStatus();
    StartServer();

    ssServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetSvcStatus();

    RpcMgmtWaitServerListen();  // OK, wait now

    DBGOUT(BROADCAST, "Deleting myRpcLocator\n\n");
    delete myRpcLocator;

    DBGOUT(MEM2, CRemoteLookupHandle::ulHandleCount << " CRemoteLookupHandles Leaked\n\n");

    DBGOUT(MEM2, CRemoteObjectInqHandle::ulHandleCount << " CRemoteObjectInqHandles Leaked\n\n");

    DBGOUT(MEM1, CCompleteHandle<NSI_BINDING_VECTOR_T>::ulHandleCount
                << " Complete Binding Handles Leaked\n\n");

    DBGOUT(MEM1, CCompleteHandle<GUID>::ulHandleCount
                << " Complete Object Handles Leaked\n\n");


    DBGOUT(BROADCAST, "Calling CoUninitialize\n\n");

    ssServiceStatus.dwCurrentState = SERVICE_STOPPED;
    ssServiceStatus.dwCheckPoint = 0;
    SetSvcStatus();
}

int __cdecl
main (
   IN int cArgs,
   IN char* *pszArgs
   )
/*++

Routine Description:

    Entry point for the locator server, Initialize data
    structures and start the various threads of excution.

Arguments:

    cArgs - number of argument.

    pszArgs - vector of arguments.

--*/
{
    int Status = 0;

    myRpcLocator = NULL;        // initialize the state later in LocatorServiceMain

    hHeapHandle = GetProcessHeap();

    static SERVICE_TABLE_ENTRY ServiceEntry [] = {
       {TEXT("rpclocator"), (LPSERVICE_MAIN_FUNCTION) LocatorServiceMain},  // only entry item
       {NULL,NULL}                                                          // end of table
    };

    StartTime = CurrentTime();

    char * badArg = ProcessArgs(aSwitchs, ++pszArgs);

    // Bail out on bad arguments.

    if (badArg) {
        char Buffer[200];
        fService = FALSE;
        strcpy(Buffer,"Command Line Error: ");
        strcat(Buffer, badArg);
        StopLocator(Buffer, 0);
    }

    if (!fService) {
        // Initialize the global locator object
        DBGOUT(BROADCAST, "Not running as a service\n");
        myRpcLocator = new Locator;
        StartServer();                  // this doesn't wait
        RpcMgmtWaitServerListen();      // OK, wait now
    }

    // else call (give this thread to) the service controller
    else StartServiceCtrlDispatcher(ServiceEntry);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\analysis\arrayana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	arrayana.cxx

 Abstract:

	Implementation of array marshall and unmarshall analysis.

 Notes:


 History:

 	Nov-13-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "allana.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_FIXED_ARRAY::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform marshall analysis for a fixed array.

 Arguments:

	pAna	= The analysis block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	CG_NDR				*	pBasicCGClass	= GetBasicCGClass();
	ID_CG                   ID              = pBasicCGClass->GetCGID();
	BOOL                    fIsArrayOfUnion = FALSE;

	if((ID == ID_CG_UNION) || (ID == ID_CG_ENCAP_STRUCT))
	    fIsArrayOfUnion = TRUE;

	// Temp fix for varying arrays.

	if( IsVarying() || fIsArrayOfUnion )
		{
		return CG_OK;
		}

	pBasicCGClass->MarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_FIXED_ARRAY::FollowerMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Perform Follower (embedded pointer) marshall analysis on the fixed array 

 Arguments:

	pAna	- The analyser block.

 Return Value:

	CG_OK
	
 Notes:

	// For buffer size calculation, we trick the child cg into beleieving it
	// is the only element being marshalled, so that it gives us the real
	// size per element. Then based on the alignment property before and
	// after the analysis, we make the sizing decisions.

----------------------------------------------------------------------------*/
	{
	CG_NDR		*		pBasicCGClass	= GetBasicCGClass();
	pBasicCGClass->FollowerMarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_ARRAY::DimByDimMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	pAna->PushEmbeddingLevel();
	GetBasicCGClass()->MarshallAnalysis( pAna );
	pAna->PopEmbeddingLevel();

        return CG_OK;

	}

CG_STATUS
CG_ARRAY::DimByDimUnMarshallAnalysis(
	ANALYSIS_INFO* )
	{
	return CG_OK;
	}
CG_STATUS
CG_ARRAY::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	if( IsFixedArray() )
		{
		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( "A" );
			node_skl * pType= MakeIDNode( pName, GetType() );
			SetResource( pAna->AddLocalResource( pName, pType ));
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
	}

CG_STATUS
CG_ARRAY::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	ID_CG			MyID			= GetCGID();
	short			NoOfDimensions	= short( GetDimensions() - 1 );
	int				i;

	//
	// Depending upon the id, perform analysis. Basically declare the
	// needed local variables.
	//

	// If it has embedded pointers or if block copy is not possible, declare
	// an index variable for each dimension.

	if( !IsBlockCopyPossible() )
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetIndexResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "I" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetIndexResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
				pAna->AddTransientResource( GetIndexResource()->GetResourceName(),
										GetIndexResource()->GetType()
									  );
			}

		DimByDimMarshallAnalysis( pAna );

		}

	if( IsFixedArray() && !IsArrayOfRefPointers() )
		{
		CG_FIXED_ARRAY * pThis	= (CG_FIXED_ARRAY *)this;
		unsigned long TotalSize	= pThis->GetNumOfElements();

		for( i = 0;
			 i < NoOfDimensions;
			 i++, pThis = (CG_FIXED_ARRAY *)pThis->GetChild() )
			{
			TotalSize = TotalSize * pThis->GetNumOfElements();
			}

		TotalSize = TotalSize * pThis->GetBasicCGClass()->GetWireSize();
		}

	if( (MyID == ID_CG_CONF_ARRAY) || (MyID == ID_CG_CONF_VAR_ARRAY))
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetSizeResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "S" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetSizeResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
				pAna->AddTransientResource(GetSizeResource()->GetResourceName(),
										   GetSizeResource()->GetType()
									  	  );
			}

		}

	//
	// If this has any form of variance, generate locals for variance stuff.
	//

	if( (MyID == ID_CG_VAR_ARRAY ) || (MyID == ID_CG_CONF_VAR_ARRAY ))
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetFirstResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "F" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetFirstResource(pAna->AddTransientResource(pResName, pType));
				}
			else
			   pAna->AddTransientResource(GetFirstResource()->GetResourceName(),
										   GetFirstResource()->GetType()
									  	  );
			}

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetLengthResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "L" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetLengthResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
			  pAna->AddTransientResource(GetLengthResource()->GetResourceName(),
										 GetLengthResource()->GetType()
									    );
			}

		}

	if( pAna->IsPointeeDeferred() && HasPointer() )
		{
		pAna->SetHasAtLeastOneDeferredPointee();
		}

	return CG_OK;
	}

CG_STATUS
CG_ARRAY::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	ID_CG			MyID			= GetCGID();
	short			NoOfDimensions	= short( GetDimensions() - 1 );
	int				i;

	//
	// Depending upon the id, perform analysis. Basically declare the
	// needed local variables.
	//

	// If it has embedded pointers or if block copy is not possible, declare
	// an index variable for each dimension.

	if( HasPointer() || !IsBlockCopyPossible() )
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetIndexResource() )
				{
				node_skl	*	pType;
				PNAME			pResName= pAna->GenTempResourceName( "I" );

				GetBaseTypeNode(&pType,SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetIndexResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
				pAna->AddTransientResource( pThis->GetIndexResource()->GetResourceName(),
										pThis->GetIndexResource()->GetType()
									  );
			}
		}

	if( (MyID == ID_CG_CONF_ARRAY) || (MyID == ID_CG_CONF_VAR_ARRAY))
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetSizeResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "S" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetSizeResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
				pAna->AddTransientResource(pThis->GetSizeResource()->GetResourceName(),
										   pThis->GetSizeResource()->GetType()
									  	  );
			}

		}

	//
	// If this has any form of variance, generate locals for variance stuff.
	//

	if( (MyID == ID_CG_VAR_ARRAY ) || (MyID == ID_CG_CONF_VAR_ARRAY ))
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetFirstResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "F" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetFirstResource(pAna->AddTransientResource(pResName, pType));
				}
			else
			   pAna->AddTransientResource(pThis->GetFirstResource()->GetResourceName(),
										   pThis->GetFirstResource()->GetType()
									  	  );
			}

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetLengthResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "L" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetLengthResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
			  pAna->AddTransientResource(pThis->GetLengthResource()->GetResourceName(),
										 pThis->GetLengthResource()->GetType()
									    );
			}
		}

	if( HasPointer() )
		{
		pAna->SetHasAtLeastOneDeferredPointee();
		}

	return CG_OK;
	}
CG_STATUS
CG_ARRAY::FollowerMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
        pAna;
	return CG_OK;
	}

CG_STATUS
CG_ARRAY::FollowerUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	node_skl	*	pType	= GetBasicCGClass()->GetType();
	PNAME			pName;

	// Declare a local variable for a member by member unmarshall of the
	// array elements.

	pName	= pAna->GenTempResourceName("PE");
	pType = MakePtrIDNode( pName, pType );
	SetPtrResource( pAna->AddTransientResource( pName, pType ) );

	GetBasicCGClass()->FollowerUnMarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_ARRAY::RefCheckAnalysis(
	ANALYSIS_INFO * pAna )
	{
	int	i;
	int NoOfDimensions = GetDimensions();

	if( IsArrayOfRefPointers() )
		{
		// Allocate an index resource per dimension.
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i < NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetIndexResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "I" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetIndexResource( pAna->AddLocalResource( pResName, pType ));
				}
			else
				pAna->AddLocalResource(
								GetIndexResource()->GetResourceName(),
								GetIndexResource()->GetType()
									  );
			}

		}
	return CG_OK;
	}

CG_STATUS
CG_ARRAY::InLocalAnalysis(
	ANALYSIS_INFO * pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform Allocation of local resources on server side stub for an
 	array of ref pointers.

 Arguments:

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	if( IsArrayOfRefPointers() && IsFixedArray() )
		{
		if( !GetInLocalResource() )
			{
			node_skl	*	pType = GetType();
			PNAME			pResName	= pAna->GenTempResourceName( "A" );

			pType	= MakeIDNode( pResName, pType );
			SetInLocalResource(pAna->AddLocalResource(pResName,pType));
			}
		else
			{
			pAna->AddLocalResource(
						GetInLocalResource()->GetResourceName(),
						GetInLocalResource()->GetType()
									  );
			}
		}
	return CG_OK;
	}

/*****************************************************************************
 CG_STRING_ARRAY methods.
 *****************************************************************************/
CG_STATUS
CG_STRING_ARRAY::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform marshall analysis for a fixed string array.

 Arguments:

	pAna	= The analysis block.

 Return Value:

	CG_OK
	
 Notes:

 	For now this will work only for a single dimensional array on which 
 	[string] is applied.

----------------------------------------------------------------------------*/
	{
	CG_NDR				*	pBasicCGClass	= GetBasicCGClass();

	pBasicCGClass->MarshallAnalysis( pAna );

	return CG_OK;
	}

/*****************************************************************************
 CG_VARYING_ARRAY methods.
 *****************************************************************************/
CG_STATUS
CG_VARYING_ARRAY::MarshallAnalysis(
	ANALYSIS_INFO * pAna )
	{
        pAna;
	return CG_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\skiplist.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    skiplist.cxx

Abstract:

	This module contains definitions of non inline member functions for the
	CSkipList class, which implements skiplists with reference counted links.	
	
Author:

    Satish Thatte (SatishT) 08/16/95  Created all the code below except where
									  otherwise indicated.

--*/

#if DBG
char * CSListName = "CSkipList";
char * CSLinkName = "CSkipLink";
#endif

#include <locator.hxx>


// the regular constructor

CSkipList::CSkipLink::CSkipLink(IOrderedItem * d, short l) : data(d) {

			next = new CSkipLink* [levels = l];
			for (short i = 0; i < l; i++ ) next[i] = NULL;
			fDeleteData = FALSE;
}
		
// resizing constructor

CSkipList::CSkipLink::CSkipLink(CSkipLink * old, short newSize) {
	
			next = new CSkipLink* [levels = newSize];
			data = old->data;
			fDeleteData = old->fDeleteData;

			ASSERT((levels > old->levels), "Skip List Levels Incorrect\n");

			for (short i = 0; i < old->levels; i++ )
				next[i] = old->next[i];
			
			// if we are resizing, there had better be a next
			ASSERT(next[0], "Resizing a single-item Skip List\n");	
			next[0]->hold();	// to counteract the release in old

			for ( i = old->levels; i < levels; i++ ) next[i] = NULL;

			old->release();
}
		
CSkipList::CSkipLink::~CSkipLink() {

			if (next[0]) next[0]->release();

			delete [] next;

			if (fDeleteData)
				delete data;
}


	
CSkipList::CSkipList() {
	count = 0;
	maxlevel = 1;  // initial max level
	maxcount = 2;
	pLnkFirst = NULL;
}



void CSkipList::wipeOut()

/*++
Routine Description:

	release all SkipLinks and all data and reinitialize to empty list
	
--*/

{
	if (pLnkFirst) {

		CSkipLink *pLnkCurr = pLnkFirst;

		do {
		  pLnkCurr->fDeleteData = TRUE;
		  pLnkCurr = pLnkCurr->next[0];
		} while (pLnkCurr);

		releaseAll(pLnkFirst);	// release as many links as you can,
								// and do it iteratively for robustness
		pLnkFirst = NULL;
		count = 0;
	}
}



IOrderedItem *CSkipList::find(IOrderedItem * d)

/*++
Routine Description:

	Find a matching item in the CSkipList and return it
	An IOrderedItem given as argument is the key, and the item
	returned may be an object of a class derived from the key type.
	
	This routine uses a goto and uses the raw compare function,
	because the performance of this routine is important, and it is
	especially important to avoid unnecessary comparisons
	
--*/

{
	CSkipLink *temp = NULL, *pLink = pLnkFirst;
	
	if (!pLnkFirst) return NULL;	// empty list

	int comparison = pLnkFirst->data->compare(*d);

	if (comparison > 0) return NULL; // no chance
	if (comparison == 0) return pLnkFirst->data;
		
	for (short cLvl = maxlevel-1 ; cLvl >= 0 ; cLvl-- ) {
		while(temp = pLink->next[cLvl]) {
			int comparison = temp->data->compare(*d);
			if (comparison == 0) return temp->data;
			if (comparison > 0) goto cont;
			else pLink = temp;	// comparison < 0
		}
cont:;
	}
	
	return NULL;
}

IOrderedItem *CSkipList::pop()
/*++

Routine Description:

	Remove and return the first item in the CSkipList
		
	
Returns:  the removed item if any, NULL, otherwise.

--*/

{
	short cLvl;

	if (!pLnkFirst) return NULL;
	
	IOrderedItem *lpRetval = pLnkFirst->data;

	CSkipLink *temp = NULL;

	/* If there is a second item, we copy the second into the first
	   so as to preserve the max size of the first node, as well as
	   its links at higher levels which the second link may lack
	*/
		
	if (temp = pLnkFirst->next[0]) {
			pLnkFirst->data = temp->data;

			ASSERT((pLnkFirst->levels >= temp->levels), "First node in skip list not largest\n");

			/* the next pointers of the second link need to be copied
			   into the first as well, along with the data pointer
			*/
			
			for ( cLvl = temp->levels - 1; cLvl >= 0; cLvl-- ) {
				pLnkFirst->next[cLvl] = temp->next[cLvl];
			}

			if (temp->next[0])

			// this hold counteracts the following release

				temp->next[0]->hold();
			
			temp->release();
	}
	else {	// we are removing the only item in the list
			pLnkFirst->release();
			pLnkFirst = NULL;
	}
	
	count--;

	return lpRetval;
}

IOrderedItem *CSkipList::remove(IOrderedItem * d)

/*++
Routine Description:

	Remove and return a matching item in the CSkipList.
	An IOrderedItem given as argument is the key, and the item
	to be removed may be an object of a class derived from the key type.
	
	This routine uses ordinary relational operators.  It is
	not as efficient as it could be if it used the raw compare
	function, but relational operators make it more readable.
	Since remove operations are infrequent, the small extra
	cost in performance does not matter.
	
	RETURNS:  the removed item if any, NULL, otherwise
--*/

{
	ASSERT(d, "Attempt to remove a null object in skip list\n");

	if (!pLnkFirst || (*(pLnkFirst->data) > *d)) return NULL; // no chance

	ASSERT(pLnkFirst->levels == maxlevel, "Wrong size for first skiplist node\n");	// always holds

	/* Is this a special case: remove the first item? */

	if (*(pLnkFirst->data) == *d) return pop();	

	/* Otherwise our first task is to find the item to be removed.
	   pLink will track the link prior to the one being removed
	*/
	 		
	CSkipLink *temp = NULL, *pLink = pLnkFirst;
	
	short cLvl;

	IOrderedItem *lpRetval = NULL;
	
	for ( cLvl = maxlevel-1 ; cLvl >= 0 ; cLvl-- ) {
		
		while ((temp = pLink->next[cLvl]) && (*(temp->data) < *d))
			pLink = temp;
		
		if (temp && (*(temp->data) == *d)) {
			lpRetval = temp->data;
			break;
		}
	}

	/* Check if we found something, or came to the end of the rope */
			
	if (cLvl < 0) return NULL; // end of the rope, nothing found

	/* now we can allocate the threading array */

	CSkipLink **ppSLthreads = new CSkipLink* [maxlevel];
	ppSLthreads[cLvl] = pLink;

	short findLvl = cLvl;
	CSkipLink * pFindLink = temp;

	/* Now that we found the link to be removed, we need to find its
	   predecessors at every level, so that they can be relinked
	*/
	
	for ( cLvl-- ; cLvl >= 0 ; cLvl-- ) {

		while ((temp = pLink->next[cLvl]) && *(temp->data) < *d)
			pLink = temp;
		
		ppSLthreads[cLvl] = pLink;
	}

	/* relink, release, and be done */

	for ( cLvl = findLvl; cLvl >= 0; cLvl-- ) {
		ppSLthreads[cLvl]->next[cLvl] = pFindLink->next[cLvl];
	}

	if (pFindLink->next[0]) pFindLink->next[0]->hold();

	// the preceding hold counteracts the following release

	pFindLink->release();

	delete [] ppSLthreads;

	count--;

	return lpRetval;
}



SkipStatus CSkipList::insert(IOrderedItem * d)

/*++
Routine Description:

	Insert the IOrderedItem into the CSkipList.  The CSkipList will
	adjust its maxlevels member as necessary.  The algorithm is
	probabilistic -- the size of the new CSkipLink is decided
	by using a random number.
	
	This routine uses ordinary relational operators.  It is
	not as efficient as it could be if it used the raw compare
	function, but relational operators make it more readable.
	Since remove operations are infrequent, the small extra
	cost in performance does not matter.
	
	The routine assumes that srand has been called to initialize
	the random number generator.
	
--*/

{
	if (!pLnkFirst) {
			
	/* if this is the only data item in the list then we must use maxlevel for node
	   size which may be greater than 1 if the list had stuff which got removed */
		
		pLnkFirst = new CSkipLink(d,maxlevel);
	}
	
	else {

		ASSERT(pLnkFirst->levels == maxlevel, "Wrong size for first skiplist node\n");	// must always hold
	
		if (*(pLnkFirst->data) > *d)
			
		/*  new data is smallest -- swap with first
			and pretend we are inserting previous first.
			This is not the most efficient way, but for
			this special case, the extra code isn't worth it
		*/
		
			swapThem(pLnkFirst->data,d);
		
		CSkipLink *pLink = pLnkFirst, *temp = NULL;
	
		/*	The array below is used to hold the nodes that need to be
			threaded with the new CSkipLink	*/
	
		CSkipLink **ppSLthreads = new CSkipLink* [maxlevel];

		short cLvl;

		/*	We now find the threading points by a process very similar to
			the search process in find	*/
		
		for ( cLvl = maxlevel - 1 ; cLvl >= 0 ; cLvl-- ) {
		
			while((temp = pLink->next[cLvl]) && *(temp->data) <= *d)
				pLink = temp;
			
			if (*(pLink->data) == *d) {
				delete [] ppSLthreads;
				return Duplicate;
			}
			else ppSLthreads[cLvl] = pLink;
		}
		
		/* now create the new link */

		short size;
		
		ULONG dwRandState = GetTickCount();
		
		for (size = 1 ; size < maxlevel ; size++ )
			if (RandomBit(&dwRandState)) break;

	/*  We get a CSkipLink of the randomly chosen size -- the probability
		of choosing each larger size is half that of the previous size.
		Maxlevel has the residual probability, equal to that for the next
		smaller size.  This is not quite ideal, but good enough for us.
	*/
		
		CSkipLink *pNewLink = new CSkipLink(d,size);

		/*	now thread the new link in */
		
		for ( cLvl = size-1 ; cLvl >= 0 ; cLvl-- ) {
			temp = ppSLthreads[cLvl]->next[cLvl];
			ppSLthreads[cLvl]->next[cLvl] = pNewLink;
			pNewLink->next[cLvl] = temp;
		}
		
		delete [] ppSLthreads;
	}
	
	/*	bump up count and also maxlevel if necessary	*/
	
	if ( ++count > maxcount) {
		
		maxlevel++;

		maxcount <<= 1;	// double the maxcount

	/*  now we need to resize the first node to max size */
		
		pLnkFirst = new CSkipLink(pLnkFirst,maxlevel);

	}
	
	return OK;

}

// void printStats();

void
CSkipList::releaseAll(CSkipLink * pCurr)

/*  The reason why this method doesn't just release pLnkFirst is
    because we must avoid stack overflow caused by a runaway recursive
	release effect.  So we do this iteratively.  We must, however,
	make sure to stop if we hit a link that would not be deleted if
	released because we are releasing the next one only to simulate
    the release that would happen due to deletion of the current link.
*/

{
	CSkipLink *pPrev = NULL;

	/* The invariant for the loop below is that pCurr->ulRefCount
	   is 1 higher than it should be.
	*/

	while (pCurr && pCurr->willBeDeletedIfReleased()) {
		pPrev = pCurr;
		pCurr = pCurr->next[0];
		if (pCurr) pCurr->hold();
		pPrev->release();
	}

	if (pCurr)
		pCurr->release();

	// printStats();
}


IOrderedItem*
CSkipListIterator::next() {	
	
// advance the iterator and return next IDataItem
// continue to hold the link we expect to return next

		if (!ptr) return NULL;
			
		CSkipList::CSkipLink* tl = ptr;

		IOrderedItem* result = ptr->data;
		ptr = ptr->next[0];
		if (ptr) ptr->hold();
		tl->release();
		return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\locator\nsserver\src\utils.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    utils.cxx

Abstract:

	This module contains definitions of miscellaneous utility functions.	
	
Author:

    Satish Thatte (SatishT) 09/20/95  Created all the code below except where
									  otherwise indicated.

--*/

#include <locator.hxx>


BOOL
hasWhacksInMachineName(
	STRING_T szName
	)
/*++

Routine Description:

    Check if machine name has "\\" at the beginning.

Returns:

    TRUE if "\\" present, FALSE otherwise.

--*/
{
	if ((*szName == L'\\') && (*(szName+1) == L'\\'))	return TRUE;
	else return FALSE;
}



unsigned long
CurrentTime (
    )
/*++

Routine Description:

    Return the current time in seconds.

Returns:

    The time.

--*/
{
    ULONG time;

    // QUERY the current time; and return the time since service start in seconds.

    time = GetCurrentTime();

    return((time-StartTime)/1000);
}


BOOL
IsStillCurrent(
		ULONG ulCacheTime,
		ULONG ulTolerance
		)
/*++

Routine Description:

    Determines if a cache creation time is still "current" based on a tolerance
	level for staleness. All time values are in seconds.

Arguments:

	ulCacheTime	- cache creation time
	ulTolerance	- staleness tolerance

Returns:

    TRUE if current, FALSE otherwise

--*/
{

	ULONG ulCurrent = CurrentTime();

	DBGOUT(UTIL, "IsStillCurrent: ulCacheTime = " << ulCacheTime << WNL);
	DBGOUT(UTIL, "IsStillCurrent: ulTolerance = " << ulTolerance << WNL);
	DBGOUT(UTIL, "IsStillCurrent: ulCurrent = " << ulCurrent << "\n\n");

	/* the next statement is basically a kludge to get around the fact that
	   rpc_c_ns_default_exp_age is -1 which, as a ULONG is 0xffffffff
	   so that ulTolerance + CACHE_GRACE wraps around to CACHE_GRACE - 1
	   for the default tolerance!
	*/
	
	if (ulTolerance + CACHE_GRACE < CACHE_GRACE)	// ulTolerance wrap around
		return TRUE;

	if (
		(ulCurrent - ulCacheTime) > (ulTolerance + CACHE_GRACE)  ||
		((long)ulCurrent - (long)ulCacheTime) < 0				// ulCurrent wrap around
	   )
	
	   return FALSE;

	else {
		DBGOUT(UTIL, "IsStillCurrent: YES!\n\n");
		return TRUE;
	}
}


void
AssertHeap()

/*++

Routine Description:

    Checks the state of the current process heap, or of a single
	block in the heap if a non-null block address is provided.

--*/
{
	BOOL valid = HeapValidate(
					hHeapHandle,
					0,					// default: serialize heap access
					NULL				// default: validate the entire heap
					);

	if (!valid) Raise(NSI_S_HEAP_TRASHED);

}

RPC_BINDING_HANDLE
MakeDClocTolocHandle(
		STRING_T pszDCName
		)
/*++

Routine Description:

    Create an RPC binding handle for a locator on the given server

Arguments:

    pszDCName	- name of the server machine

Returns:

    A binding handle.

--*/
{
	RPC_STATUS Status;

	STRING_T pszTempBinding;

	STRING_T pszNetworkAddr = catenate(TEXT("\\\\"),pszDCName);

	Status = RpcStringBindingCompose(
					NULL,
					TEXT("ncacn_np"),
					pszNetworkAddr,
					TEXT("\\pipe\\locator"),
					NULL,
					&pszTempBinding
					);

	if (Status != RPC_S_OK) Raise(NSI_S_DC_BINDING_FAILURE);

	RPC_BINDING_HANDLE hResult;

	Status = RpcBindingFromStringBinding(
					pszTempBinding,
					&hResult
					);

	if (Status != RPC_S_OK) Raise(NSI_S_DC_BINDING_FAILURE);

	delete pszNetworkAddr;
	RpcStringFree(&pszTempBinding);

	return hResult;
}


		

STRING_T
catenate(
	STRING_T pszPrefix,
	STRING_T pszSuffix
	)
/*++

Routine Description:

    Concatenate the two given strings into a new string

Arguments:

	pszPrefix	- prefix of result
	
	pszSuffix	- suffix of result

Returns:

    A newly allocated string.

--*/
{
	long prefixLen = wcslen(pszPrefix);
	long suffixLen = wcslen(pszSuffix);

	STRING_T pszResult = new WCHAR[(prefixLen+suffixLen+1)*sizeof(WCHAR)];
    if (!pszResult)
        return NULL;

	wcscpy(pszResult,pszPrefix);
	wcscpy(pszResult+prefixLen,pszSuffix);
	return pszResult;
}


NSI_SERVER_BINDING_VECTOR_T *
BVTtoSBVT(
	NSI_BINDING_VECTOR_T * pbvt
	)
/*++

Routine Description:

	This function reformulates a NSI_BINDING_VECTOR_T as a
	NSI_SERVER_BINDING_VECTOR_T but does not make copies of
	the string bindings in the process.

--*/
{
	NSI_SERVER_BINDING_VECTOR_T *
		psbvt = (NSI_SERVER_BINDING_VECTOR_T *)
				new char [ sizeof(UNSIGNED32) +
						   sizeof(NSI_STRING_BINDING_T)*(pbvt->count)
						 ];

	psbvt->count = pbvt->count;
	for (UNSIGNED32 i = 0; i < pbvt->count; i++) {
		psbvt->string[i] = pbvt->binding[i].string;
	}

	return psbvt;
}



STRING_T
makeBindingStringWithObject(
			STRING_T binding,
			STRING_T object
			)
/*++

Routine Description:

	Take an existing binding string and replace the object part
	before returning.  The string returned is allocated by RPC
	and must be freed by calling RpcStringFree unless it is an
	out parameter for an RPC call (or a part of such a returned
	value) in which case it is freed by the RPC runtime.

--*/
{
	RPC_STATUS Status;

	/* variables to receive binding decomposition */

	STRING_T ProtSeq;
	STRING_T EndPoint;
	STRING_T NetworkAddr;
	STRING_T NetworkOptions;

	Status = RpcStringBindingParse(
				binding,
				NULL,			// don't need current Object ID
				&ProtSeq,
				&NetworkAddr,
				&EndPoint,			// Don't need endpoint
				&NetworkOptions);

	if (Status != RPC_S_OK)		// corrupted entry?
			Raise(NSI_S_INVALID_STRING_BINDING);

	// The following allocates and creates a new string

	// N.B.  for now we keep the endpoint to be compatible with
	// the old locator, but the endpoint really should be removed

	STRING_T tempBinding = NULL;
	
	Status = RpcStringBindingCompose(
						object,
						ProtSeq,
						NetworkAddr,
						EndPoint,			
						NetworkOptions,
						&tempBinding
						);

	if (Status != RPC_S_OK)		// must be out of memory
	   Raise(NSI_S_OUT_OF_MEMORY);

	RpcStringFree(&ProtSeq);
	RpcStringFree(&EndPoint);
	RpcStringFree(&NetworkAddr);
	RpcStringFree(&NetworkOptions);

	return tempBinding;

}


void
I_NSI_NS_HANDLE_T_rundown(
    IN NSI_NS_HANDLE_T InqContext
    )
/*++

Routine Description:

    Cleanup after an a lookup operation.  Internal version.

Arguments:

    InqContext - Context to cleanup

--*/
{
    if (!InqContext) {
        DBGOUT(MEM1, "RunDown::InqContext is NULL\n");
        return;
    }

	CContextHandle *pHandle = (CContextHandle *) InqContext;

	__try {
		
		pHandle->rundown();
	}
	__finally {

		delete pHandle;
	}

}


void NSI_NS_HANDLE_T_done(
	/* [out][in] */ NSI_NS_HANDLE_T __RPC_FAR *inq_context,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)
/*++

Routine Description:

    A generalized version of the "done" operation for NS context handles.

Arguments:

	inq_context	- context handle the client is done with
	
	status	- status is returned here

--*/
{
	*status = NSI_S_OK;

	if (*inq_context)

		__try {
			
		   I_NSI_NS_HANDLE_T_rundown(*inq_context);
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			*status = (UNSIGNED16) GetExceptionCode();
		}

	*inq_context = NULL;
}


void __RPC_API
NSI_NS_HANDLE_T_rundown(
    IN NSI_NS_HANDLE_T InqContext
    )
/*++

Routine Description:

    Cleanup after an aborted lookup operation.
	This is the one called directly by RPC runtime when needed.

Arguments:

    InqContext - Context to cleanup

--*/
{
	DBGOUT(MEM1,"RPC Called Rundown\n\n");

	I_NSI_NS_HANDLE_T_rundown(InqContext);
}



RPC_BINDING_HANDLE
ConnectToMasterLocator(
			ULONG& Status
			)
/*++

Routine Description:

    Contains the logic for connecting to a master locator, whether in a
	workgroup or domain.  Tries to use the cached list of masters in the
	locator object, and if there are none then in a workgroup environment
	tries a broadcast for master locators in the workgroup. When a name
	for a machine with a master is found, the locator is pinged to ensure
	that it is actually alive.

Returns:

    A binding handle to a live master locator, if any.  NULL otherwise.

--*/
{
	RPC_BINDING_HANDLE hCurrentMaster = NULL;

	int fHandleWorked = FALSE;

	TGSLString *pMasters = myRpcLocator->getMasters();
	
	DBGOUT(TRACE, "Finding the list of cached master locators\n");

	if ((pMasters->size() == 0) && (myRpcLocator->IsInWorkgroup()))
	{
		myRpcLocator->TryBroadcastingForMasterLocator();
		DBGOUT(TRACE, "Broadcasted for master locators\n");		
		pMasters = myRpcLocator->getMasters();
	}

	TGSLStringIter iterDCs(*pMasters);


	CStringW * pPrimaryDCName = myRpcLocator->getPDC();
    DBGOUT(TRACE, "Perceived Primary DC Name" << (pPrimaryDCName?(STRING_T)(*pPrimaryDCName):L"<NULL>") << "\n");

	for (CStringW * pSWcurrentDC = pPrimaryDCName ? pPrimaryDCName : iterDCs.next();
		 pSWcurrentDC != NULL;
		 pSWcurrentDC = iterDCs.next()
		)
	{

		RpcTryExcept {
			hCurrentMaster = MakeDClocTolocHandle(*pSWcurrentDC);

			DBGOUT(TRACE, "Pinging Locator on machine " << (STRING_T)(*pSWcurrentDC) << "\n");

			CLIENT_I_nsi_ping_locator(
								   hCurrentMaster,
								   &Status
								   );
		}

		RpcExcept (EXCEPTION_EXECUTE_HANDLER) {
					
			Status = RpcExceptionCode();
			if (Status != NSI_S_DC_BINDING_FAILURE)
				RpcBindingFree(&hCurrentMaster);
			hCurrentMaster = NULL;

			if (Status == RPC_S_ACCESS_DENIED)
				Status = NSI_S_NO_NS_PRIVILEGE;

			/*  Unnecessary to set it here

				if (Status == RPC_S_SERVER_TOO_BUSY)
					Status = NSI_S_NAME_SERVICE_UNAVAILABLE;
			*/
		}
		RpcEndExcept;

		if (Status != RPC_S_OK) continue;

		fHandleWorked = TRUE;
		break;
	}

	if (!fHandleWorked) {

		hCurrentMaster = NULL;

		if (Status != NSI_S_NO_NS_PRIVILEGE)
			Status = NSI_S_NAME_SERVICE_UNAVAILABLE;
	}

	return hCurrentMaster;
}



NSI_UUID_VECTOR_T *
getVector(CObjectInqHandle *pInqHandle)
/*++

Routine Description:

    Given a handle for object lookup, extract all the objects in it
	and format them into a standard object vector.  This function
	is always used in creating ObjectInqHandles

Arguments:

	pInqHandle	- a context handle for object inquiry
	
Returns:

    A standard object vector
--*/
{
	// we have no idea how many we will have, so we use a simple
	// linked list to gather the UUIDs before setting up the vector

	int fDone = FALSE;

	CSimpleLinkList GuidList;

	while (!fDone) {

		__try {
			GUID * pGUID = pInqHandle->next();
			if (pGUID) GuidList.insert(pGUID);
			else fDone = TRUE;
		}
		__except(EXCEPTION_EXECUTE_HANDLER) {
			fDone = TRUE;
		}
	}

	ULONG ulSize = GuidList.size();

	NSI_UUID_VECTOR_T *pUuidVector = (NSI_UUID_VECTOR_T *)
						midl_user_allocate(
									sizeof(UNSIGNED32) +
									sizeof(GUID*) * ulSize
									);

	pUuidVector->count = ulSize;

	for (ULONG i = 0; i < ulSize; i++)
		pUuidVector->uuid[i] = (GUID*) GuidList.pop();

	return pUuidVector;
}


void *new_handler(size_t)
/* this is just in case we use the standard "new" operation, which we don't */
{
	Raise(NSI_S_OUT_OF_MEMORY);

	return NULL;	// just to keep the compiler happy, never used
}

void
StripDomainFromDN(WCHAR *FullName, WCHAR **szDomainName, 
                  WCHAR **pszEntryName, WCHAR **pszRpcContainerDN)
{
    WCHAR *psz = NULL;

    *szDomainName = FullName+wcslen(DSDomainBegin);
    psz = wcschr(*szDomainName, DSDomainEnd);
    *psz = L'\0';

    *pszEntryName = psz+1+3;
    psz = wcschr(*pszEntryName, L',');
    *psz = L'\0';

    *pszRpcContainerDN = psz+1;
}

void 
GetDomainFlatName(CONST WCHAR *domainNameDns, WCHAR **szDomainNameFlat)
{
    DWORD dwResult;
    PDOMAIN_CONTROLLER_INFO pDCI;   

    *szDomainNameFlat = NULL;
    dwResult = DsGetDcName(NULL, domainNameDns, NULL, NULL,
                                       DS_IP_REQUIRED |
//                                       DS_IS_DNS_NAME |
                                       DS_RETURN_FLAT_NAME,
                                       &pDCI);

    if (dwResult == ERROR_SUCCESS) {

        if (pDCI->DomainName) {

            *szDomainNameFlat = new WCHAR [wcslen(pDCI->DomainName) + 1];

            if (*szDomainNameFlat) {
                wcscpy ((*szDomainNameFlat), pDCI->DomainName);
            }
        }

        NetApiBufferFree(pDCI);
    }
}

void
parseEntryName(
		CONST_STRING_T fullName,
		CStringW * &pswDomainName,
		CStringW * &pswEntryName
		)
/*++

Routine Description:

    Parses a given entry name into its domain and entry name parts.
	Deals with both global and relative (local) entry name syntax.

Arguments:

	fullName		- the name to parse

	pswDomainName	- the domain name (if the input was a global name) is
					  returned here.  For a local name, NULL is returned.

	pswEntryName	- the relative entry name is returned here.

    call from brodcast.cxx would not need the LDAP names at all.

Remarks:

    The returned values are newly allocated string objects.

--*/
{
	if (memcmp(RelativePrefix, fullName,
			   RelativePrefixLength * sizeof(WCHAR))
		== 0) {

		pswDomainName = NULL;
		pswEntryName = new CStringW(fullName + RelativePrefixLength);
	}

	else if (memcmp(GlobalPrefix, fullName,
			   GlobalPrefixLength * sizeof(WCHAR))
			 == 0) {

		// make a copy starting after the prefix

		STRING_T domainBegin = CStringW::copyString(fullName + GlobalPrefixLength);

		for (STRING_T psz = domainBegin;
			 (*psz != NSnameDelimiter) && (*psz != WStringTerminator);
			 psz++);

		if (*psz == WStringTerminator) {	// no entry name at all
			delete [] domainBegin;
			Raise(NSI_S_INCOMPLETE_NAME);
		}

		else
		{
			*psz = 0;	 // the NULL character
			pswDomainName = new CStringW(domainBegin);
			pswEntryName = new CStringW(psz+1);
			delete [] domainBegin;
		}

	}

	else				// neither relative nor global prefix found
		Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

}

STRING_T
makeGlobalName(
		const STRING_T szDomainName,
		const STRING_T szEntryName
		)
/*++

Routine Description:

    Formats a global entry name from domain and relative name parts.

Arguments:

	szDomainName	- the domain name

	pswEntryName	- the relative entry name

Returns

    A newly allocated global name string

--*/
{
	STRING_T psz1, psz2;

	psz1 = catenate(TEXT("/"),szEntryName);
	psz2 = catenate(szDomainName,psz1);
	delete [] psz1;
	psz1 = catenate(GlobalPrefix,psz2);
	delete [] psz2;
	return psz1;					

}


int
IsNormalCode(
		IN ULONG StatusCode
		)
/*++

Routine Description:

    A test to see if a status code is a normal status to return or signifies
	some error of purely internal interest.

Arguments:

	StatusCode	- the code to test

Returns

    TRUE if normal, FALSE if internal error (such as failure to connect to master locator).

--*/
{
	return
		(StatusCode < NSI_S_STATUS_MAX) &&
		(StatusCode != NSI_S_NAME_SERVICE_UNAVAILABLE) &&
		(StatusCode != NSI_S_NO_NS_PRIVILEGE) &&
		(StatusCode != NSI_S_OUT_OF_MEMORY) &&
		(StatusCode != NSI_S_NO_MASTER_LOCATOR);
}



unsigned
RandomBit(
    unsigned long *pState
    )
/*++

Routine Description:

    Generates a "random" bit.

    Using the MASK32 polynomial this function will have a period of exactly
    2^32-1.

    A more complete description of this algorithm can be found in "Numerical
    Recipes In C: The Art of Scientific Computation"

    Never generates a sequence of the same value longer more then 31.  This
    doesn't affect the odds much since a more general algorithm would generate
    such a sequence only every 2^31*(32/2) sequences.

Arguments:

    pState - Pointer to a dword of State.  This should
            be initalized to a random value (GetTickCount())
            before the first call.  It should be unmodified
            between future calls.  Must not be zero.

Return Value:

    0 or 1

Author:  MarioGo

--*/
{
    #define B1  (1)
    #define B2  (1<<1)
    #define B3  (1<<2)
    #define B4  (1<<3)
    #define B5  (1<<4)
    #define B6  (1<<5)
    #define B7  (1<<6)
    #define B32 (1<<31)

    // Selected polynomial's from table in Numerical Recipes In C.

    #define MASK30 (B1 + B4 + B6)   // for 30,6,4,1,0 polynomial

    #define MASK32 (B1 + B2 + B3 + B5 + B7) // for 32,7,5,3,2,1,0 polynomial

    if (*pState & B32)
        {
        *pState = ((*pState ^ MASK32) << 1) | 1;
        return(1);
        }

    *pState <<= 1;
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\analysis\analysis.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	anainfo.cxx

 Abstract:

	Implementation of the analysis classes.

 Notes:


 Author:


 History:

 	VibhasC		Jul-25-1993		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

short TempResourceCounter = 0;

/****************************************************************************
 *	externs
 ***************************************************************************/
#ifdef MIDL_INTERNAL

void
ANALYSIS_INFO::Dump(
	 ANAPHASE A )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Debug dump.

 Arguments:

	A	- The analysis phase to be dumped.

 Return Value:

 	None.

 Notes:

----------------------------------------------------------------------------*/
{
	FILE	*		hFile	= stdout;
	char	*		pTemp;
	OPTIM_OPTION	Options	= OPTIMIZE_NONE;

static char Buffer[ 100 ];

	pTemp = ( A == ANA_PHASE_CLIENT_MARSHALL ) ? "Client Marshall"	:
			( A == ANA_PHASE_CLIENT_UNMARSHALL ) ? "Client UnMarshall":
			( A == ANA_PHASE_SERVER_UNMARSHALL ) ? "Server UnMarshall":
			"Server Marshal";

	sprintf( Buffer, "\nDump of phase :%s\n", pTemp );
	fprintf( hFile, "%s", Buffer );

	//
	// dump optimisation options.
	//

	fprintf( hFile, "\nOptimize Options: ( " );
	if( Options )
		{
			if( Options & OPTIMIZE_SIZE )
				{
				fprintf( hFile, "Size " );
				Options &= ~OPTIMIZE_SIZE;
				}

			if( Options & OPTIMIZE_INTERPRETER )
				{
				fprintf( hFile, "Interpret " );
				Options &= ~OPTIMIZE_INTERPRETER;
				}

			if( Options & OPTIMIZE_NO_REF_CHECK )
				{
				fprintf( hFile, "NoRef " );
				Options &= ~OPTIMIZE_NO_REF_CHECK;
				}

			if( Options & OPTIMIZE_NO_CTXT_CHECK )
				{
				fprintf( hFile, "NoCtxt " );
				Options &= ~OPTIMIZE_NO_CTXT_CHECK;
				}

			if( Options & OPTIMIZE_NO_GEN_HDL_CHECK )
				{
				fprintf( hFile, "NoGenHdl " );
				Options &= ~OPTIMIZE_NO_GEN_HDL_CHECK;
				}
		}
	else
		fprintf( hFile, "default( speed )" );

	fprintf( hFile, " )" );

	//
	// all done.
	//

	fprintf( hFile, "\n" );
}
#endif // MIDL_INTERNAL


void
ANALYSIS_INFO::Reset()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	The Master clear or reset.

 Arguments:

 	None.

 Return Value:

	NA.

 Notes:

 	Create an alignment state machine instance.

----------------------------------------------------------------------------*/
{

	//
	// Initialize the miscellaneous properties.
	//

	SetMiscProperties( DEFAULT_MISC_PROPERTIES );

	//
	// Set the default optimization options.
	//

	SetOptimOption( DEFAULT_OPTIM_OPTIONS );

	ResetArrayContext();

	SetRpcSSAllocateRecommended( 0 );
}

ANALYSIS_INFO::ANALYSIS_INFO()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:


 	Constructor for analysis information manager block.

 Arguments:


 	None.

 Return Value:


 	NA.

 Notes:

----------------------------------------------------------------------------*/
{

	//
	// Initialize and so on.
	//

	Reset();

	//
	// Set the analysis phase to be client side marshall by default.
	//

	SetCurrentPhase( ANA_PHASE_CLIENT_MARSHALL );

	//
	// Create a resource dictionary data base.
	//

	pResDictDatabase = new RESOURCE_DICT_DATABASE();

	OptimOptions	 = OPTIMIZE_NONE;

	SetLastPlaceholderClass(0);

	fRpcSSSwitchSet	 = 0;

}

RESOURCE *
ANALYSIS_INFO::DoAddResource(
	RESOURCE_DICT	*	pResDict,
	PNAME				pName,
	node_skl 		*	pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Add a resource to a dictionary.

 Arguments:

	pResDict	- A pointer to the resource dictionary.
	pName		- The resource name.
	pType		- The type of the resource.

 Return Value:

 Notes:

 	If the type of the resource does not indicate a param node, assume it
 	is an ID node and create an id node for it.

----------------------------------------------------------------------------*/
{
	RESOURCE	*	pRes;

	if( (pRes = pResDict->Search( pName )) == 0 )
		{
		pRes = pResDict->Insert( pName, pType );
		}

	return pRes;
}

RESOURCE *
ANALYSIS_INFO::AddStandardResource(
	STANDARD_RES_ID	ResID )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Add a standard resource to the appropriate dictionary.

 Arguments:

 	ResID	- The standard resource ID.

 Return Value:

 Notes:

	Depending upon the resource in question, locate the correct dictionary
	to insert into, generate the type and insert in the dictionary.

----------------------------------------------------------------------------*/
{
	RESOURCE_DICT	*	pResDict = 0;
	PNAME				pName = 0;
	RESOURCE		*	pResource;
	node_id			*	pType;
	PNAME				pTName = 0;

static struct
	{
	char * pName;
	char * pTypeName;
	} LocalResIDToResName[] =
	{
	 { RPC_MESSAGE_VAR_NAME, RPC_MESSAGE_TYPE_NAME }
	,{ STUB_MESSAGE_VAR_NAME, STUB_MESSAGE_TYPE_NAME }
	,{ STUB_DESC_STRUCT_VAR_NAME, STUB_DESC_STRUCT_TYPE_NAME }
	,{ BUFFER_POINTER_VAR_NAME, BUFFER_POINTER_TYPE_NAME }
	,{ RPC_STATUS_VAR_NAME, RPC_STATUS_TYPE_NAME }
	,{ LENGTH_VAR_NAME, LENGTH_VAR_TYPE_NAME }
	,{ BH_LOCAL_VAR_NAME, BH_LOCAL_VAR_TYPE_NAME }
	,{ PXMIT_VAR_NAME, PXMIT_VAR_TYPE_NAME }
	};

static struct
	{
	char * pName;
	char * pTypeName;
	}ParamResIDToResName[] =
	{
	 { PRPC_MESSAGE_VAR_NAME, PRPC_MESSAGE_TYPE_NAME }
	};

static struct
	{
	char * pName;
	char * pTypeName;
	} GlobalResIDToResName[] =
	{
	 { AUTO_BH_VAR_NAME, AUTO_BH_TYPE_NAME }
	};

	if( IS_STANDARD_LOCAL_RESOURCE( ResID ) )
		{
		pResDict= pResDictDatabase->GetLocalResourceDict();
		pName	= LocalResIDToResName[ ResID - ST_LOCAL_RESOURCE_START ].pName;
		pTName	= LocalResIDToResName[ ResID - ST_LOCAL_RESOURCE_START ].pTypeName;
		}
	else if( IS_STANDARD_PARAM_RESOURCE( ResID ) )
		{
		pResDict= pResDictDatabase->GetParamResourceDict();
		pName	= ParamResIDToResName[ ResID - ST_PARAM_RESOURCE_START ].pName;
		pTName	= ParamResIDToResName[ ResID - ST_PARAM_RESOURCE_START ].pTypeName;
		}
	else if( IS_STANDARD_GLOBAL_RESOURCE( ResID ) )
		{
		pResDict= pResDictDatabase->GetGlobalResourceDict();
		pName	= GlobalResIDToResName[ ResID - ST_GLOBAL_RESOURCE_START ].pName;
		pTName	= GlobalResIDToResName[ ResID - ST_GLOBAL_RESOURCE_START ].pTypeName;
		}
	else
		{
		MIDL_ASSERT( FALSE );
		}

	if( (pResource = pResDict->Search( pName )) == 0 )
		{
		pType		= new node_id( pName );
		pType->SetBasicType( new node_def( pTName ) );
//gaj		pType->SetEdgeType( EDGE_USE );
		pType->GetModifiers().SetModifier( ATTR_TAGREF );
		pResource = pResDict->Insert( pName, (node_skl *)pType );
		}

	return pResource;
}

PNAME
ANALYSIS_INFO::GenTempResourceName(
	char	*	pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the name for a temporary resource.

 Arguments:

	pPrefix	- A null terminated prefix string. If this is null, nothing is
			  added.

 Return Value:

	A freshly allocated resource name string.

 Notes:

----------------------------------------------------------------------------*/
{
	char	TempBuffer[ 30 ];

	sprintf( TempBuffer,
			 "_%sM%d",
			 pPrefix ? pPrefix : "",
			 GetTempResourceCounter()
		   );

	BumpTempResourceCounter();

	PNAME	pName	= (PNAME) new char [ strlen(TempBuffer) + 1 ];
	strcpy( pName, TempBuffer );
	return pName;
}

PNAME
ANALYSIS_INFO::GenTRNameOffLastParam(
	char	*	pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the name for a temporary resource.

 Arguments:

	pPrefix	- A null terminated prefix string. If this is null, nothing is
			  added.

 Return Value:

	A freshly allocated resource name string.

 Notes:

----------------------------------------------------------------------------*/
{
	char	TempBuffer[ 30 ];

	sprintf( TempBuffer,
			 "_%sM",
			 pPrefix ? pPrefix : ""
		   );

	PNAME	pName	= (PNAME) new char [ strlen(TempBuffer) + 1 ];
	strcpy( pName, TempBuffer );
	return pName;
}

/****************************************************************************
 	Utility functions.
 ****************************************************************************/
//
// This array defines the action taken when memory has been allocated for 
// a type.
//


static U_ACTION S_WhenMemoryAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_NONE,					// No Allocation needed.
	   RA_NONE,					// No reference action.
	   UA_COPY_INTO_TYPE,		// Copy from source to type ( resource )
	   PR_TYPE					// Presented expression is the type / resource
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_NONE,					// No allocation needed.
	   RA_NONE,					// No action for reference.
	   UA_COPY_INTO_TYPE,		// No Unmarshalling action.
	   PR_TYPE					// Presented expression is deref of src.
	 }

	};

//
// This array defines the action taken when a reference has been allocated for
// a type.
//

static U_ACTION S_WhenRefAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_STACK,				// Explicit allocation needed.
	   RA_PATCH_TO_ADDR_OF_TYPE,// Patch ref to address of type.
	   UA_COPY_INTO_TYPE,		// Copy from source to type.
	   PR_NONE					// Presented expression tbd by caller.
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_NONE,					// No allocation needed.
	   RA_PATCH_INTO_BUFFER,	// Patch ref to position in buffer.
	   UA_NONE,					// No Unmarshalling action.
	   PR_NONE					// Presented expression is deref of src.
	 }

	};

static U_ACTION S_WhenMemoryAndRefAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_ERROR,				// Explicit allocation needed.
	   RA_ERROR,				// Patch ref to address of type.
	   UA_ERROR,				// Copy from source to type.
	   PR_ERROR					// Presented expression tbd by caller.
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_ERROR,				// No allocation needed.
	   RA_ERROR,				// Patch ref to position in buffer.
	   UA_ERROR,				// No Unmarshalling action.
	   PR_ERROR					// Presented expression is deref of src.
	 }
	};

static U_ACTION C_WhenMemoryAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_EXISTS,				// No Allocation needed.
	   RA_NONE,					// No reference action.
	   UA_COPY_INTO_DEREF_OF_REF,	// Copy from source to type ( resource )
	   PR_NONE					// Presented expression is the type / resource
	 }
#if 0
	 { AN_NONE,				// No Allocation needed.
	   RA_NONE,					// No reference action.
	   UA_COPY_INTO_TYPE,		// Copy from source to type ( resource )
	   PR_NONE					// Presented expression is the type / resource
	 }
#endif // 0

	 // When Buffer reuse is possible.

	,{
	   AN_ERROR,				// This situation must never happen on client
	   RA_ERROR,
	   UA_ERROR,
	   PR_ERROR	
	 }

	};

//
// This array defines the action taken when a reference has been allocated for
// a type.
//

static U_ACTION C_WhenRefAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_NONE,					// Explicit allocation needed.
	   RA_NONE,					// Patch ref to address of type.
	   UA_COPY_INTO_DEREF_OF_REF,// Copy from source to type.
	   PR_NONE					// Presented expression tbd by caller.
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_ERROR,				// Must never happen on client
	   RA_ERROR,
	   UA_ERROR,
	   PR_ERROR
	 }

	};

static U_ACTION C_WhenMemoryAndRefAllocated[ 2 ] = 
	{

	// Buffer re-use is not possible.

	 { AN_EXISTS,				// No Allocation needed.
	   RA_NONE,					// No reference action.
	   UA_COPY_INTO_DEREF_OF_REF,// Copy from source to type ( resource )
	   PR_NONE					// Presented expression is the type / resource
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_ERROR,				// Must never happen on client
	   RA_ERROR,
	   UA_ERROR,
	   PR_ERROR
	 }

	};

U_ACTION
CG_NDR::RecommendUAction(
	SIDE	Side,
	BOOL	fMemoryAllocated,
	BOOL	fRefAllocated,
	BOOL	fBufferReUsePossible,
	UAFLAGS  )
	{
	BOOL	fMemoryAndRefAllocated = (fMemoryAllocated && fRefAllocated);


	if( Side == C_SIDE )
		{
		if( fMemoryAndRefAllocated )
			return C_WhenMemoryAndRefAllocated[ fBufferReUsePossible ];
		else if( fMemoryAllocated )
			return C_WhenMemoryAllocated[ fBufferReUsePossible ];
		else
			return C_WhenRefAllocated[ fBufferReUsePossible ];
		}
	else
		{
		if( fMemoryAndRefAllocated )
			{
			MIDL_ASSERT( FALSE &&
		   		    !"Server analysis should never have mem and ref allocated");
			return S_WhenRefAllocated[ fBufferReUsePossible ];
			}
		else if( fMemoryAllocated )
			return S_WhenMemoryAllocated[ fBufferReUsePossible ];
		else
			return S_WhenRefAllocated[ fBufferReUsePossible ];
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\analysis\opinfo.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	opinfo.cxx

 Abstract:

	Contains the implementations of the optimisation analysis information
	classes.

 Notes:


 Author:

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/

/****************************************************************************
 *	SU_PROPERTY implementation
 ***************************************************************************/
USE_COUNT
SU_OPTIM_INFO::IncrInUsage()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Increment the [in] directional usage of this type.

 Arguments:

 	None.
	
 Return Value:
	
	The final incremented usage.

 Notes:

 	If the incremented usage is above the threshold, set it to the threshold
 	value itself.

----------------------------------------------------------------------------*/
	{
	if( ++InUsageCount >= USAGE_THRESHOLD )
		InUsageCount = USAGE_THRESHOLD;
	return InUsageCount;
	}

USE_COUNT
SU_OPTIM_INFO::IncrOutUsage()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Increment the [out] directional usage of this type.

 Arguments:

 	None.
	
 Return Value:
	
	The final incremented usage.

 Notes:

 	If the incremented usage is above the threshold, set it to the threshold
 	value itself.

----------------------------------------------------------------------------*/
	{
	if( ++InUsageCount >= USAGE_THRESHOLD )
		InUsageCount = USAGE_THRESHOLD;
	return InUsageCount;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\analysis\btana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	btana.cxx

 Abstract:

	implementation of analysis methods for base types.

 Notes:

 History:

 	Sep-01-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop
/****************************************************************************/
CG_STATUS
CG_BASETYPE::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{
    
        pAna;
	return CG_OK;
}

CG_STATUS
CG_BASETYPE::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{
        pAna;
	return CG_OK;
}

CG_STATUS
CG_BASETYPE::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Perform analysis for out params, allocated as locals on the server side.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
	CG_OK if all is well
	error otherwise.

 Notes:

 	Initialization for a pure base type is not needed.

----------------------------------------------------------------------------*/
{
	if( pAna->IsRefAllocDone() )
		{
		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( 0 );
			SetResource( pAna->AddLocalResource( pName,
									 	 	MakeIDNode( pName, GetType(), new expr_constant(0L) )
								   	   		));
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\analysis\procana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	procana.cxx

 Abstract:

	This file provides analysis routines for a procedure code generation
	class.

 Notes:

 History:


	Aug-31-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop

#pragma warning ( disable :  4701 )

/****************************************************************************
 	Implementation of the proc code generator class.
 ****************************************************************************/

CG_STATUS
CG_PROC::C_BindingAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform the binding analysis for the client side.

 Arguments:
	
 Return Value:
	
 Notes:

	If it is an auto handle procedure, make sure the global auto handle is
	registered as a global resource.
----------------------------------------------------------------------------*/
{
	node_id	*	pID;

	if( IsAutoHandle() )
		{
		pAna->AddStandardResource( ST_RES_AUTO_BH_VARIABLE );
		}
	else
		{
		SetBindingResource( pAna->AddStandardResource( ST_RES_BH_VARIABLE ) );

		// Initialize the binding resource to 0, so it gets printed out.

		pID	= (node_id *)GetBindingResource()->GetType();

		pID->SetExpr( new expr_constant( 0L ) );

		}
	return CG_OK;
}

CG_STATUS
CG_PROC::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	ITERATOR		I;
	CG_PARAM	*	pCG = 0;
	CG_PARAM	*	pS;
	CG_RETURN	*	pRT;
	SIDE			Side	= pAna->GetCurrentSide();
	expr_node	*	pSE		= 0;
	BOOL			fReturnNeedsMarshall = FALSE;

	if( Side == C_SIDE )
		GetInParamList( I );
	else
		GetOutParamList( I );

    pRT = GetReturnType();
	if ( Side == S_SIDE  && pRT != 0 ) 
		fReturnNeedsMarshall = TRUE;

	if( ITERATOR_GETCOUNT( I ) )
		{
		ITERATOR_INIT( I );

		while( ITERATOR_GETNEXT( I, pCG ) )
			{
            // The "invisible" fault or comm status param doesn't marshal.

			pS = (CG_PARAM *)ITERATOR_PEEKTHIS( I );

            if ( pCG->IsExtraStatusParam() )
                continue;

			pCG->MarshallAnalysis( pAna );

            // Add to the sizing expression.

			if( pSE )
				pSE	= new expr_b_arithmetic( OP_PLUS,
											  pSE,
											  pCG->GetSizeExpression()
											);
			else
				pSE	= pCG->GetSizeExpression();
			}
		}

	if(fReturnNeedsMarshall)
		{
                
                pRT->MarshallAnalysis( pAna );
		
                if( pSE )
			pSE	= new expr_b_arithmetic( OP_PLUS,
										  pSE,
										  pRT->GetSizeExpression()
										);
		else
			pSE	= pRT->GetSizeExpression();
		}

	if( pSE )
		SetSizeExpression( pSE );
	else
		SetSizeExpression( new expr_constant( 0L,VALUE_TYPE_NUMERIC_U ));

    if ( HasExtraStatusParam() )
        {
        GetMembers(I);

        while ( ITERATOR_GETNEXT( I, pCG ) )
            if ( pCG->IsExtraStatusParam() )
                break;

        node_skl *pType = pCG->GetType();

        pCG->SetResource( new RESOURCE( pType->GetSymName(), pType ) );
        }

	return CG_OK;
	}

CG_STATUS
CG_PROC::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	ITERATOR		I;
	CG_PARAM	*	pCG = 0;
	CG_PARAM	*	pS;
	CG_RETURN	*	pRT = 0;
	SIDE			Side = pAna->GetCurrentSide();
	BOOL			fReturnNeedsUnMarshall	= FALSE;

	if( Side == C_SIDE )
		GetOutParamList( I );
	else
		GetInParamList( I );
	
	if( (Side == C_SIDE ) && (pRT = GetReturnType() ) != 0 )
		fReturnNeedsUnMarshall = TRUE;

	if( ITERATOR_GETCOUNT(I) )
		{
		while( ITERATOR_GETNEXT( I, pCG ) )
			{
            // The "invisible" fault/comm status param doesn't unmarshal.

			pS = (CG_PARAM *)ITERATOR_PEEKTHIS( I );

            if ( pCG->IsExtraStatusParam() )
                continue;

			pCG->UnMarshallAnalysis( pAna );
			}

		}

	if( fReturnNeedsUnMarshall )
		{
		pRT->UnMarshallAnalysis( pAna );
		}
	

	return CG_OK;
	}


CG_STATUS
CG_PROC::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for all params which may be allocated as locals for
 	the server side stubs.

 Arguments:

 	pAna	- The analysis block.

	
 Return Value:
	
 	CG_OK	if all is well,
 	error	otherwise.

 Notes:

----------------------------------------------------------------------------*/
{

	ITERATOR		I;
	CG_PARAM	*	pParam = 0;

	GetOutParamList( I );

	while( ITERATOR_GETNEXT( I, pParam ) )
		{
		pParam->S_OutLocalAnalysis( pAna );
		}

	return CG_OK;
}


void
CG_PROC::RpcSsPackageAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for the need to invoke RpcSsm package at server.

 Arguments:

 	pAna	- The analysis block.

	
 Return Value:
	
 Notes:

   Note that we perform both sides analysis at once as the format string
   is generated usually at the client pass.

----------------------------------------------------------------------------*/
{
    //
    // In ms_ext mode:
    //    only if  Enable allocate is specified 
    // In osf mode:
    //    if( RpcSS is recommended by analysis || enable allocate specified )
    //
    SetMustInvokeRpcSSAllocate( 0 );

    if ( IsRpcSSSpecified() )
        SetMustInvokeRpcSSAllocate( 1 );

    if ( MustInvokeRpcSSAllocate()  ||  pAna->GetMode() != 0 )
        return;

    // We analyze parameters in osf to boost performance by skipping
    // unnecessary enable and disable operations.
    //
    
    ITERATOR        ParamList;
    CG_PARAM    *    pParam = 0;

    GetMembers( ParamList );

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            pParam->RpcSsPackageAnalysis( pAna );
            }
        }

    CG_RETURN * pReturn = GetReturnType();

    if ( pReturn )
        {
        if ( (pAna->GetOptimOption() & OPTIMIZE_INTERPRETER)  ||
             (pReturn->GetChild()  &&
                   ( ((CG_NDR *)pReturn->GetChild())->IsPointer()  ||
                     ((CG_NDR *)pReturn->GetChild())->HasPointer() ||
                     ((CG_NDR *)pReturn->GetChild())->GetCGID() == ID_CG_ENCAP_STRUCT ) )
           )
            {
            // We could do a better job for Oi2 if we watched its stack.
            // Encapsulated union is there as it was a hassle to make it
            // know about its pointers.

            pAna->SetRpcSSAllocateRecommended( 1 );
            }
        }

    if ( pAna->IsRpcSSAllocateRecommended() )
       SetMustInvokeRpcSSAllocate( 1 );
}


CG_STATUS
CG_PROC::RefCheckAnalysis(
    ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform ref pointer check analysis.

 Arguments:

 	pAna	- The analysis info block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	ITERATOR		I;
	CG_PARAM	*	pCG = 0;
	CG_RETURN	*	pRT = 0;
	SIDE			Side	= pAna->GetCurrentSide();
	BOOL			fReturnNeedsMarshall = FALSE;

    // generate ref check resources for both in and out params.
    GetMembers( I );
	if( (Side == S_SIDE ) && (pRT = GetReturnType() ) != 0 )
		fReturnNeedsMarshall = TRUE;

	if( ITERATOR_GETCOUNT( I ) )
		{
		ITERATOR_INIT( I );

		while( ITERATOR_GETNEXT( I, pCG ) )
			{
			pCG->RefCheckAnalysis( pAna );
			}
		}

	if(fReturnNeedsMarshall)
		{
		pRT->RefCheckAnalysis( pAna );
		}
	return CG_OK;
	}

CG_STATUS
CG_PROC::InLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for [in] params allocated as locals on server.

 Arguments:

 	pAna	- The analysis info block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	ITERATOR		I;
	CG_PARAM	*	pCG = 0;

	GetInParamList( I );

	if( ITERATOR_GETCOUNT( I ) )
		{
		ITERATOR_INIT( I );

		while( ITERATOR_GETNEXT( I, pCG ) )
			{
			pCG->InLocalAnalysis( pAna );
			}
		}
	return CG_OK;
	}

/****************************************************************************
 	Implementation of the parameter code generator class.
 ****************************************************************************/
CG_STATUS
CG_PARAM::MarshallAnalysis(
	 ANALYSIS_INFO * pAna )
{
	CG_STATUS				Status;

	//
	// Initialize the analysis block and the parameter for the current side
	// and analysis phase.
	//

	InitParamMarshallAnalysis( pAna );

	// Send the message to the lower cg nodes.

	Status = ((CG_NDR *)GetChild())->MarshallAnalysis( pAna );

	if( pAna->HasAtLeastOneDeferredPointee() )
		{
		pAna->ResetDeferPointee();
		((CG_NDR *)GetChild())->FollowerMarshallAnalysis( pAna );
		}


	ConsolidateParamMarshallAnalysis( pAna );


	// The analysis block will now have properties which are a combo of the
	// properties before this param and the properties of this param.

	return CG_OK;
}

CG_STATUS
CG_PARAM::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{

	InitParamUnMarshallAnalysis( pAna );

	// Send the message to the child to perform the same analysis for us
	// and then consolidate the results on return.

	((CG_NDR *)GetChild())->UnMarshallAnalysis( pAna );

	if( pAna->HasAtLeastOneDeferredPointee() )
		{
		pAna->ResetDeferPointee();
		((CG_NDR *)GetChild())->FollowerUnMarshallAnalysis( pAna );
		}

	// Consolidate the results of analysis from the lower nodes.

	ConsolidateParamUnMarshallAnalysis( pAna );

	return CG_OK;
}

void
CG_PARAM::InitParamMarshallAnalysis(
	ANALYSIS_INFO * pAna )
{

	node_skl	*	pType	= GetType();
	PNAME			pName	= pType->GetSymName();
	CG_NDR		*	pC		= (CG_NDR *)GetChild();

	// For all cases of generic handles, where the CG_GENERIC_HANDLE will
	// sit below the param, we want to bypass the generic handle class during
	// marshall analysis.

	if( pC->GetCGID() == ID_CG_GENERIC_HDL )
		{
		pC = (CG_NDR *)pC->GetChild();
		}

	//
	// Allocate the resource for this parameter. On the client side, this
	// parameter is a param resource, while on the server, this param is a local
	// resource. One the client side, the param has already been added to the
	// resource dictionary.

	if( pAna->GetCurrentSide() == C_SIDE )
		{
		if( (pC->IsArray()) &&
			(pAna->GetOptimOption() & OPTIMIZE_INTERPRETER )
		  )
		  	{
			pType	= MakePtrIDNode( pName, pType->GetChild() );
		  	}
		SetResource( new RESOURCE( pName, pType) );
		}
	else
		{
		node_skl	*	pActualType	= pType->GetChild();

		if( (pC->GetCGID() == ID_CG_CONTEXT_HDL ) ||
			(pC->GetChild() && (pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL)))
			{
			pActualType	= MakeIDNode( pName, new node_def ("NDR_SCONTEXT" ) );
			}
		else if( pC->IsArray() )
			pActualType	= MakePtrIDNode( pName, pActualType);
		else
			pActualType = MakeIDNode( pName, pActualType );

		SetResource( pAna->AddLocalResource( pName, pActualType ));
		}

	SetSizeResource( 0 );
	SetLengthResource( 0 );
	SetFirstResource( 0 );

	pAna->SetMemoryAllocDone();
	pAna->ResetRefAllocDone();
	pAna->ResetEmbeddingLevel();
	pAna->ResetIndirectionLevel();
	pAna->SetRefChainIntact();
	pAna->ResetDeferPointee();
	pAna->ResetHasAtLeastOneDeferredPointee();
	pAna->SetLastPlaceholderClass( (CG_NDR *)this );
}

void
CG_PARAM::ConsolidateParamMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{
	expr_node		*	pSE		= 0;
	

	// Consolidate the result of the analysis from lower nodes, first into
	// this node, and then into the analysis block.

	pSE	= new expr_constant( (long)0U, VALUE_TYPE_NUMERIC_U );

	SetSizeExpression( pSE );

	if( pAna->GetOptimOption() & OPTIMIZE_SIZE )
		{
		pAna->ClearTransientResourceDict();
		}
}

void
CG_PARAM::InitParamUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{

	node_skl	*	pType	= GetType();
	node_skl	*	pActualType = pType->GetBasicType();
	PNAME			pName	= pType->GetSymName();
	CG_NDR		*	pC		= (CG_NDR *)GetChild();

	// For all cases of generic handles, where the CG_GENERIC_HANDLE will
	// sit below the param, we want to bypass the generic handle class during
	// marshall analysis.

	if( pC->GetCGID() == ID_CG_GENERIC_HDL )
		{
		pC = (CG_NDR *)pC->GetChild();
		}

	//
	// Allocate resources. On the client side, a parameter resource is allocated
	// and on the server, a local resource is allocated.
	//

	SetSubstitutePtrResource( 0 );

	if( pAna->GetCurrentSide() == C_SIDE )
		{
		pAna->SetDontReUseBuffer();
		if( (pC->IsArray()) &&
			(pAna->GetOptimOption() & OPTIMIZE_INTERPRETER )
		  )
		  	{
			pType	= MakePtrIDNode( pName, pType->GetChild() /* GetBasicType() ????????? */ );
		  	}
		SetResource( new RESOURCE( pName, pType) ) ;
		}
	else if ( ! IsOmittedParam() )
		{
		pC->SetAllocatedOnStack( 1 );

		if( (pC->GetCGID() == ID_CG_CONTEXT_HDL ) ||
			(pC->GetChild() && (pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL)))
			{
			pActualType	= MakeIDNode( pName, new node_def ("NDR_SCONTEXT" ) );
			}
		else if( pC->IsArray() )
			{
			pActualType	= MakePtrIDNode( pName, pType->GetChild() );
			}
		else
			pActualType	= MakeIDNode( pName, pType->GetChild() );

		pAna->ResetDontReUseBuffer();
		SetResource( pAna->AddLocalResource( pName, pActualType ) );
		}

	SetSizeResource( 0 );
	SetLengthResource( 0 );
	SetFirstResource( 0 );

	// Reset for analysis.


	pAna->SetMemoryAllocDone();
	pAna->ResetRefAllocDone();
	pAna->ResetEmbeddingLevel();
	pAna->ResetIndirectionLevel();
	pAna->SetRefChainIntact();
	pAna->ResetDeferPointee();
	pAna->ResetHasAtLeastOneDeferredPointee();
	pAna->SetLastPlaceholderClass( (CG_NDR *)this );
}

void
CG_PARAM::ConsolidateParamUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{

	// Consolidate the result of the analysis from lower nodes, first into
	// this node, and then into the analysis block.

	if( pAna->GetOptimOption() & OPTIMIZE_SIZE )
		{
		pAna->ClearTransientResourceDict();
		}
}
CG_STATUS
CG_PARAM::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for all params which may be allocated as locals for
 	server stub

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
 Notes:

	Ignore [in, out], since that would be done by the Unmarshall analysis.
----------------------------------------------------------------------------*/
{
	// If the param is [out] only, determine if there is a need for local
	// variables and if they need to be inited.
	
	if( IsParamOut() && !IsParamIn() )
		{
		InitParamMarshallAnalysis( pAna );

		((CG_NDR *)GetChild())->S_OutLocalAnalysis( pAna );

		}
	return CG_OK;
}


void
CG_PARAM::RpcSsPackageAnalysis(
    ANALYSIS_INFO    *    pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Perform analysis for rpcss package enabling.

 Arguments:
    
    pAna    - A pointer to the analysis block.

 Return Value:
    
 Notes:

    This routine should be called only in the osf mode.

----------------------------------------------------------------------------*/
{
    //
    // Package needs to be enabled (only is OSF mode) when the NDR engine
    // is going to do any allocations whatsoever at the server side.
    //
    // In Os this may happen on
    //    - anything other than simple type or pointer to simple type
    //    - with simple type, if this happens to be enum16
    // In Oi this may happen on
    //    - anything [out]
    //    - [in] like Os
    // In Oi2 this may happen on
    //    - anything [out] when lack of space on -Oi2 stack
    //    - [in] like Os
    //      (simple types and pointers to simple types are usually on
    //      the interpreter stack, if there is space there).
    //      However, this cannot be guaranteed.
    
    if( IsParamOut() &&
        ( pAna->GetOptimOption() & OPTIMIZE_INTERPRETER) )
        {
        // We could do a better job for Oi2 if we watched the its stack.

        pAna->SetRpcSSAllocateRecommended( 1 );
        return;
        }

    // We are here with
    //   [in] or [in,out] for Oi? 
    //   any              for Os
    // See if this is one of the simple cases mentioned above.
    // This is really a check for the buffer reusage.

    CG_NDR * pChild = (CG_NDR *)GetChild();

    if ( pChild->IsSimpleType() &&
         ( pChild->GetCGID() != ID_CG_ENUM  ||
           pChild->GetCGID() == ID_CG_ENUM  &&
                                     ((CG_ENUM*)pChild)->IsEnumLong() )
         &&  pChild->GetCGID() != ID_CG_INT3264 
       )
        {
        // An [in] arg in the buffer.

        return;
        }

    // Note that we don't have to check for allocate(allnodes) etc.
    // as this is not an osf attribute.
    // Also note that we handle top level pointers here.

    if ( pChild->IsPointer()  &&  ((CG_POINTER *)pChild)->IsRef() )
        {
        // In args would stay in the buffer,
        // out args would be on the Os stack.

        CG_NDR * pPointee = (CG_NDR *)pChild->GetChild();

        if ( ( pChild->GetCGID() == ID_CG_PTR  ||
               pChild->GetCGID() == ID_CG_STRING_PTR  || 
               pChild->GetCGID() == ID_CG_SIZE_PTR )
             &&
             pPointee->IsSimpleType()
             &&
             ( pPointee->GetCGID() != ID_CG_ENUM  ||
               pPointee->GetCGID() == ID_CG_ENUM  &&
                                      ((CG_ENUM*)pPointee)->IsEnumLong() )
             &&
             pPointee->GetCGID() != ID_CG_INT3264
           )
            return;
        }

    pAna->SetRpcSSAllocateRecommended( 1 );
}



/****************************************************************************
 	Implementation of the return type node.
 ****************************************************************************/
CG_STATUS
CG_RETURN::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform the size analysis for the return type.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
 Notes:

	For the return type, the size analysis contributes nothing on the
	client side, yet we must declare a local variable for the return.
----------------------------------------------------------------------------*/
{

	node_skl			*	pType				= GetType();
	PNAME	   				pName				= RETURN_VALUE_VAR_NAME;
	CG_STATUS				Status;
	CG_NDR				*	pC	= (CG_NDR *)GetChild();

	//
	// Always allocate a local resource for the return type.
	//

	if( (pC->GetCGID() == ID_CG_CONTEXT_HDL ) ||
		(pC->GetChild() && (pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL)))
		{
		node_skl	*	pActualType = pType->GetBasicType();
		pActualType	= MakeIDNode( pName, new node_def ("NDR_SCONTEXT" ) );
		SetResource( pAna->AddLocalResource( pName, pActualType ));
		}
	else
		{
		pType	= MakeIDNode( pName, pType );
		SetResource( pAna->AddLocalResource( pName,  pType ));
		}


	SetSizeResource( 0 );

	// Reset the analysis block for marshalling.

	pAna->SetMemoryAllocDone();
	pAna->ResetRefAllocDone();
	pAna->ResetEmbeddingLevel();
	pAna->SetRefChainIntact();
	pAna->SetDontReUseBuffer();
	
	pAna->SetReturnContext();
	pAna->SetLastPlaceholderClass( (CG_NDR *)this );

	// Send the analysis message to the child nodes.

	Status	=  ((CG_NDR *)GetChild())->MarshallAnalysis( pAna );


	SetSizeExpression(
         new expr_constant( 0L, VALUE_TYPE_NUMERIC_U ) );
	
	pAna->ResetReturnContext();

	if( pAna->GetOptimOption() & OPTIMIZE_SIZE )
		{
		pAna->ClearTransientResourceDict();
		}

	return Status;
}

CG_STATUS
CG_RETURN::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform the buffer analysis for the return type.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
 Notes:

	For the return type, the size analysis contributes nothing on the
	client side, yet we must declare a local variable for the return.
----------------------------------------------------------------------------*/
{
	node_skl	*	pType	= GetType();
	PNAME			pName	= RETURN_VALUE_VAR_NAME;
	CG_STATUS		Status;

	//
	// Always allocate a local resource for the return type.
	//

	pType	= MakeIDNode( pName, pType );
	SetResource( pAna->AddLocalResource( pName,  pType ));

	pAna->SetMemoryAllocDone();
	pAna->ResetRefAllocDone();
	pAna->ResetEmbeddingLevel();
	pAna->SetRefChainIntact();
	pAna->SetDontReUseBuffer();
	
	pAna->SetReturnContext();
	pAna->SetLastPlaceholderClass( (CG_NDR *)this );

	Status	= ((CG_NDR *)GetChild())->UnMarshallAnalysis( pAna );

	pAna->ResetReturnContext();

	if( pAna->GetOptimOption() & OPTIMIZE_SIZE )
		{
		pAna->ClearTransientResourceDict();
		}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\analysis\ptrana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	ptrana.cxx

 Abstract:

 	Contains implementations of analysis routines for pointer types.

 Notes:


 History:

 	Oct-10-1993		VibhasC		Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_POINTER::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	CG_STATUS	Status;

	// Unmarshall the pointer body first. If the pointer needs to be deferred,
	// then dont perform the pointee unmarshall analysis. Just indicate that
	// there is a pointee that needs to be unmarshalled later.

	Status = PtrUnMarshallAnalysis( pAna );

	if( pAna->IsPointeeDeferred() )
		{
		pAna->SetHasAtLeastOneDeferredPointee();
		}
	else
		Status	= PteUnMarshallAnalysis( pAna );

	return Status;
	}

CG_STATUS
CG_POINTER::PtrUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	// Perform the analysis for the pointer body. For a [ref] pointer, nothing
	// needs to be done.
	
	if( IsRef() && !pAna->IsMemoryAllocDone() )
		{
		SetUAction( RecommendUAction( pAna->GetCurrentSide(),
								 	  pAna->IsMemoryAllocDone(),	
								 	  pAna->IsRefAllocDone(),
								 	  FALSE,		// no buffer re-use for ref.
								 	  UAFLAGS_NONE
							   	 	));

		}

	return CG_OK;
	}

CG_STATUS
CG_POINTER::PteUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	CG_STATUS	Status;
	pAna->PushIndirectionLevel();

	Status = CorePteUnMarshallAnalysis( pAna );

	pAna->PopIndirectionLevel();

	return Status;
	}

CG_STATUS
CG_POINTER::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	CG_STATUS	Status;
	short		EmbedLevel;

	// Marshall the pointer body first. If the pointee needs to be deferred,
	// dont perform marshall analysis on the pointee. Just indicate that a
	// pointee needs to be marshalled later.

	Status = PtrMarshallAnalysis( pAna );

	if( pAna->IsPointeeDeferred() )
		{
		pAna->SetHasAtLeastOneDeferredPointee();
		}
	else
		{
		EmbedLevel = pAna->GetCurrentEmbeddingLevel();
		pAna->ResetEmbeddingLevel();
		Status	= PteMarshallAnalysis( pAna );
		pAna->SetCurrentEmbeddingLevel( EmbedLevel );
		}

	return Status;
	}

CG_STATUS
CG_POINTER::PtrMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
        pAna;
	return CG_OK;
	}

CG_STATUS
CG_POINTER::PteMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	CG_STATUS			Status;

	pAna->PushIndirectionLevel();

	pAna->SetMemoryAllocDone();	// Needed ?
	Status = CorePteMarshallAnalysis( pAna );

	pAna->PopIndirectionLevel();

	return Status;
	}

CG_STATUS
CG_POINTER::FollowerMarshallAnalysis(
	ANALYSIS_INFO * pAna )
	{
	return PteMarshallAnalysis( pAna );
	}

CG_STATUS
CG_POINTER::FollowerUnMarshallAnalysis(
	ANALYSIS_INFO * pAna )
	{
	return PteUnMarshallAnalysis( pAna );
	}

CG_STATUS
CG_POINTER::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for [out] params that need to be allocated as locals
 	on server stub.

 Arguments:

 	pAna	- The analysis block.
	
 Return Value:
	
	CG_OK	if all is well
	error	otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
	CG_STATUS		Status	= CG_OK;
	CG_NDR		*	pC		= (CG_NDR *)GetNonGenericHandleChild();

	if( !pAna->IsMemoryAllocDone() )
		{
		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( 0 );
			SetResource( pAna->AddLocalResource( pName,
									 	 	MakeIDNode( pName, GetType() )
								   	   	));
			}
		SetAllocatedOnStack( 1 );
		}

	// If it is a ref pointer, chase it further.

	if( IsRef() && !IsQualifiedPointer() )
		{
		pAna->ResetMemoryAllocDone();
		pAna->SetRefAllocDone();
		Status = pC->S_OutLocalAnalysis( pAna );

	    // If this is the server side, and the pointee is allocated on stack,
    	// then dont free the pointee, else free it.

	    if( pC->IsAllocatedOnStack() )
		    {
    		SetPointerShouldFree( 0 );
	    	}
		}

	return Status;
}
CG_STATUS
CG_POINTER::InLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	if( IsRef() && GetChild() )
		{
		((CG_NDR *)GetChild())->InLocalAnalysis( pAna );
		}

	return CG_OK;
	}

/****************************************************************************
 *	CG_QUALIFIED_POINTER 
 ***************************************************************************/

CG_STATUS
CG_QUALIFIED_POINTER::CorePteMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform the core pointee marshall analysis for a conformant string

 Arguments:
	
	pAna	- The analysis block pointer.

 Return Value:

 	CG_OK	if all is well, error otherwise.

 Notes:

	The ndr for a conformant string (eg typedef [string] char *p ) is:
		- MaxCount
		- Offset from start of the valid character
		- Actual Count.

	We need to declare a local variable which will hold the length of the
	string, so that the length can be used in the actual marshall for memcopy.
----------------------------------------------------------------------------*/
{
	node_skl			*	pType;
	PNAME					pResName;
	BOOL					fNeedsCount;
	BOOL					fNeedsFirstAndLength;


	if( pAna->IsArrayContext() )
		{
		SetUsedInArray();
		}

	if ( ( fNeedsCount = NeedsMaxCountMarshall() ) == TRUE )
		{
		if( !GetSizeResource() )
			{
			GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
			pResName	= pAna->GenTempResourceName(0);
			pType		= MakeIDNode( pResName, pType );
			SetSizeResource( pAna->AddTransientResource( pResName, pType ) );
			}
		else
			{
			pAna->AddTransientResource( GetSizeResource()->GetResourceName(),
										GetSizeResource()->GetType()
									  );
			}
		}

	if ( ( fNeedsFirstAndLength = NeedsFirstAndLengthMarshall() ) == TRUE )
		{
		if( !GetLengthResource() )
			{
			GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
			pResName = pAna->GenTempResourceName(0);
			pType		= MakeIDNode( pResName, pType );
			SetLengthResource( pAna->AddTransientResource( pResName, pType ) );
			}
		else
			{
			pAna->AddTransientResource( GetLengthResource()->GetResourceName(),
										GetLengthResource()->GetType()
									  );
			}

		if( NeedsExplicitFirst() )
			{
			if( !GetFirstResource() )
				{
				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pResName = pAna->GenTempResourceName(0);
				pType	 = MakeIDNode( pResName, pType );
				SetFirstResource( pAna->AddTransientResource( pResName, pType ) );
				}
			else
				{
			  pAna->AddTransientResource(GetLengthResource()->GetResourceName(),
										 GetLengthResource()->GetType()
									  	);
				}
			}
		}

	return CG_OK;
}

CG_STATUS
CG_QUALIFIED_POINTER::CorePteUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	node_skl		*	pType;
	PNAME				pResName;
	BOOL				fNeedsMaxCount;
	BOOL				fNeedsFirstAndLength;


	// If a resource for the length has not already been allocated, allocate
	// one.

	if ( ( fNeedsMaxCount = NeedsMaxCountMarshall() ) == TRUE )
		{
		if( !GetSizeResource() )
			{
			GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
			pResName	= pAna->GenTempResourceName(0);
			pType		= MakeIDNode( pResName, pType );

			SetSizeResource( pAna->AddTransientResource( pResName, pType ) );
			}
		else
			pAna->AddTransientResource( GetSizeResource()->GetResourceName(),
										GetSizeResource()->GetType()
									  );
		}

	if ( ( fNeedsFirstAndLength = NeedsFirstAndLengthMarshall() ) == TRUE )
		{
		if( !GetLengthResource() )
			{
			GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
			pResName	= pAna->GenTempResourceName(0);
			pType		= MakeIDNode( pResName, pType );

			SetLengthResource( pAna->AddTransientResource( pResName, pType ) );
			}
		else
			pAna->AddTransientResource( GetLengthResource()->GetResourceName(),
										GetLengthResource()->GetType()
									  );

		if( NeedsExplicitFirst() )
			{
			if( !GetFirstResource() )
				{
				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pResName	= pAna->GenTempResourceName(0);
				pType		= MakeIDNode( pResName, pType );

				SetFirstResource( pAna->AddTransientResource( pResName, pType ) );
				}
			else
			  pAna->AddTransientResource(GetFirstResource()->GetResourceName(),
										 GetFirstResource()->GetType()
									  	);
			}
		}

	return CG_OK;
	}

CG_STATUS
CG_INTERFACE_POINTER::S_OutLocalAnalysis(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Perform analysis for out params, allocated as locals on the server side.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
	CG_OK if all is well
	error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    if( pAna->IsRefAllocDone() )
        {
        if( pAna->GetCurrentSide() != C_SIDE )
            {
            PNAME       pName = pAna->GenTempResourceName( 0 );
            node_skl *  pType = GetType();

            node_skl *  pActualType;

            if ( pType->NodeKind() == NODE_DEF )
                pActualType = MakeIDNode( pName, pType );
            else
                pActualType = MakePtrIDNode( pName, pType );

            SetResource( pAna->AddLocalResource( pName,
                                                 pActualType ));
            }

        SetAllocatedOnStack( 1 );
        }
    return CG_OK;
}

CG_STATUS
CG_INTERFACE_POINTER::MarshallAnalysis(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Perform marshall analysis for interface ptr.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
{
    pAna;
    return CG_OK;
}

CG_STATUS
CG_IIDIS_INTERFACE_POINTER::S_OutLocalAnalysis(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Perform analysis for out params, allocated as locals on the server side.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
	CG_OK if all is well
	error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    if( pAna->IsRefAllocDone() )
        {
        if( pAna->GetCurrentSide() != C_SIDE )
            {
            PNAME       pName = pAna->GenTempResourceName( 0 );
            node_skl *  pType = GetType();

            node_skl *  pActualType;

            if ( pType->NodeKind() == NODE_DEF )
                pActualType = MakeIDNode( pName, pType );
            else
                pActualType = MakePtrIDNode( pName, pType );

            SetResource( pAna->AddLocalResource( pName,
                                                 pActualType ));
            }

        SetAllocatedOnStack( 1 );
        }
    return CG_OK;
}

CG_STATUS
CG_IIDIS_INTERFACE_POINTER::MarshallAnalysis(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Perform marshall analysis for interface ptr.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
{
    pAna;
    return CG_OK;
}




/****************************************************************************
 *	utility functions
 ***************************************************************************/
U_ACTION
CG_POINTER::RecommendUAction(
	SIDE		CurrentSide,
	BOOL		fMemoryAllocated,
	BOOL		fRefAllocated,
	BOOL		fBufferReUsePossible,
	UAFLAGS		AdditionalFlags )
{
	U_ACTION	UAction =  CG_NDR::RecommendUAction( CurrentSide,
									 					fMemoryAllocated,
									 					fRefAllocated,
									 					fBufferReUsePossible,
									 					AdditionalFlags );
	return UAction;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\analysis\typeana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	typeana.cxx

 Abstract:

	transmit_as analysis stuff.

 Notes:


 History:

	Dec-08-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "allana.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/


CG_STATUS
CG_TRANSMIT_AS::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	((CG_NDR *)GetChild())->MarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_TRANSMIT_AS::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	((CG_NDR *)GetChild())->UnMarshallAnalysis( pAna );

	return CG_OK;

	}

CG_STATUS
CG_TRANSMIT_AS::S_OutLocalAnalysis(
	ANALYSIS_INFO * pAna )
{
	if( pAna->IsRefAllocDone() )
		{

		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( 0 );
			SetResource( pAna->AddLocalResource( pName,
									 	 	MakeIDNode( pName,
													    GetPresentedType()
													  )
								   	   		));
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
}

CG_STATUS
CG_REPRESENT_AS::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	((CG_NDR *)GetChild())->MarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_REPRESENT_AS::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	((CG_NDR *)GetChild())->UnMarshallAnalysis( pAna );

	return CG_OK;

	}

CG_STATUS
CG_REPRESENT_AS::S_OutLocalAnalysis(
	ANALYSIS_INFO * pAna )
{
	if( pAna->IsRefAllocDone() )
		{

		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( 0 );
			SetResource( pAna->AddLocalResource( pName,
									 	 	MakeIDNodeFromTypeName(
													    pName,
													    GetRepAsTypeName()
													  )
								   	   		));
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\analysis\stana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	stana.cxx	

 Abstract:

	structure marshalling / unmarshalling analysis.

 Notes:


 History:

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_STRUCT::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
        pAna;        

	return CG_OK;
	}

CG_STATUS
CG_STRUCT::UnMarshallAnalysis( ANALYSIS_INFO* )
	{
	return CG_OK;
	}

CG_STATUS
CG_COMP::S_OutLocalAnalysis(
	ANALYSIS_INFO * pAna )
	{
	if( pAna->IsRefAllocDone() )
		{
		if( pAna->GetCurrentSide() != C_SIDE )
			{
			char Buffer[ 256 ];
			CG_NDR	*	pLPC = pAna->GetLastPlaceholderClass();
	
			sprintf( Buffer, "%s", pLPC->GetType()->GetSymName() );

			PNAME	pName	= pAna->GenTRNameOffLastParam( Buffer );

			pAna->AddLocalResource( pName,
								MakeIDNode( pName, GetType() )
							  );
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\bindndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    bindndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    the code generation bind classes.

 Notes:


 History:

    DKays     Dec-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

extern CMD_ARG * pCommand;

void
CG_HANDLE::GenNdrParamDescription( CCB * )
{
    MIDL_ASSERT(0);
}

void
CG_HANDLE::GenNdrParamDescriptionOld( CCB * )
{
    MIDL_ASSERT(0);
}

unsigned char
CG_HANDLE::MakeExplicitHandleFlag(
    CG_PARAM *      pHandleParam )
/*++

Description:

    Produces a handle flag byte (actually, a nibble) that can keep the
    following simple flags:

        HANDLE_PARAM_IS_VIA_PTR - Bind param is a pointer to a handle type.

Note:

    Flags are set on the upper nibble (lower nibble is used for generic
    handle size).

--*/
{
    unsigned char  Flag = 0;

    if ( pHandleParam->GetChild()->IsPointer() )
        Flag |= HANDLE_PARAM_IS_VIA_PTR;

    return( Flag );
}

unsigned char
CG_CONTEXT_HANDLE::MakeExplicitHandleFlag(
    CG_PARAM *      pHandleParam )
/*++

Description:

    Produces a handle flag byte (actually, a nibble) that can keep the
    following simple flags:

        HANDLE_PARAM_IS_VIA_PTR - Bind param is a pointer to a handle type.
        HANDLE_PARAM_IS_IN -      Bind param is [in] (context handles only).
        HANDLE_PARAM_IS_OUT -     Bind param is [out] (context handles only).
        HANDLE_PARAM_IS_RETURN -  Bind param is return (context handles only).

Note:

    Flags are set on the upper nibble (lower nibble is used for generic
    handle size).

--*/
{
    unsigned char  Flag = CG_HANDLE::MakeExplicitHandleFlag( pHandleParam );

    if ( pHandleParam->IsParamIn() )
        Flag |= HANDLE_PARAM_IS_IN;
    if ( pHandleParam->IsParamOut() )
        Flag |= HANDLE_PARAM_IS_OUT;
    if ( pHandleParam->GetCGID() == ID_CG_RETURN )
        Flag |= HANDLE_PARAM_IS_RETURN;

    return ( Flag );
}

void
CG_PRIMITIVE_HANDLE::GetNdrHandleInfo( CCB * pCCB, NDR64_BINDINGS *pBinding )
{
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pBinding->Primitive.HandleType = (NDR64_FORMAT_CHAR)(pCommand->IsNDR64Run() ? FC64_BIND_PRIMITIVE :
                                                              FC_BIND_PRIMITIVE);
    pBinding->Primitive.Flags = MakeExplicitHandleFlag( pBindParam );
    pBinding->Primitive.Reserved = 0;    
    pBinding->Primitive.StackOffset = 0xBAAD;
    // StackOffset should be reset by the callee
}

void
CG_PRIMITIVE_HANDLE::GenNdrHandleFormat( CCB * pCCB )
/*++
    The layout is:

        FC_BIND_PRIMITIVE
        handle flag <1>
        stack offset<2>
--*/
{
    FORMAT_STRING *pProcFormatString = pCCB->GetProcFormatString();
    CG_PARAM      *pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    NDR64_BINDINGS binding;

    SetNdrBindDescriptionOffset( pProcFormatString->GetCurrentOffset() );
    GetNdrHandleInfo( pCCB, &binding );

    MIDL_ASSERT( FC_BIND_PRIMITIVE == binding.Primitive.HandleType );
    pProcFormatString->PushFormatChar( 
                            (FORMAT_CHARACTER ) binding.Primitive.HandleType );
    pProcFormatString->PushByte( binding.Primitive.Flags );

    pProcFormatString->PushUShortStackOffsetOrSize(
                    pBindParam->GetStackOffset( pCCB, I386_STACK_SIZING ));
}

void
CG_GENERIC_HANDLE::GetNdrHandleInfo( CCB * pCCB, NDR64_BINDINGS *pBinding )
{
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    NDR64_UINT8 Flags = MakeExplicitHandleFlag( pBindParam );

    NDR64_UINT8 RoutineIndex = (NDR64_UINT8) 
                               ( pCCB->LookupBindingRoutine(
                                                GetHandleTypeName() ) - 1 );

    pBinding->Generic.HandleType   = (NDR64_FORMAT_CHAR)(pCommand->IsNDR64Run() ? FC64_BIND_GENERIC :
                                                              FC_BIND_GENERIC);
    pBinding->Generic.Flags        = Flags;
    pBinding->Generic.RoutineIndex = RoutineIndex;
    pBinding->Generic.Size         = (NDR64_UINT8) GetMemorySize();
    pBinding->Generic.StackOffset  = 0xBAAD;
    // StackOffset should be reset by the callee

    // Make a note if the table would be actually used by the interpreter.

    if ( pCCB->GetOptimOption()  &  OPTIMIZE_INTERPRETER )
        pCCB->SetInterpretedRoutinesUseGenHandle();

    //
    // Register the handle.
    //
    pCCB->RegisterGenericHandleType( GetHandleType() );
}


void
CG_GENERIC_HANDLE::GenNdrHandleFormat( CCB * pCCB )
/*++
    The layout is:

        FC_BIND_GENERIC
        handle flag, handle size <high nibble, low nibble>
        stack offset <2>
        routine index<1>
        FC_PAD
--*/
{
    FORMAT_STRING * pProcFormatString = pCCB->GetProcFormatString();
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    NDR64_BINDINGS  binding;

    SetNdrBindDescriptionOffset( pProcFormatString->GetCurrentOffset() );
    GetNdrHandleInfo( pCCB, &binding );

    MIDL_ASSERT( FC_BIND_GENERIC == binding.Primitive.HandleType );
    pProcFormatString->PushFormatChar( 
                            (FORMAT_CHARACTER) binding.Generic.HandleType );
    pProcFormatString->PushByte(
                            binding.Generic.Flags | binding.Generic.Size );

    pProcFormatString->PushUShortStackOffsetOrSize(
                    pBindParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    pProcFormatString->PushByte( binding.Generic.RoutineIndex );
    pProcFormatString->PushFormatChar( FC_PAD );
}


void
CG_CONTEXT_HANDLE::GetNdrHandleInfo( CCB * pCCB, NDR64_BINDINGS *pBinding )
{
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    unsigned char   uFlags;

    MIDL_ASSERT( pCCB->GetCGNodeContext()->IsProc() );

    uFlags = MakeExplicitHandleFlag( pBindParam );
    if ( fStrictContext )
        {
        uFlags |= NDR_STRICT_CONTEXT_HANDLE;
        }
    if ( fNoSerialize )
        {
        uFlags |= NDR_CONTEXT_HANDLE_NOSERIALIZE;
        }
    else if ( fSerialize )
        {
        uFlags |= NDR_CONTEXT_HANDLE_SERIALIZE;
        }

    NDR64_UINT8 RoutineIndex = (NDR64_UINT8) 
                               ( pCCB->LookupRundownRoutine(
                                                GetRundownRtnName() ) - 1 );

    pBinding->Context.HandleType   = (NDR64_FORMAT_CHAR)(pCommand->IsNDR64Run() ? FC64_BIND_CONTEXT :
                                                              FC_BIND_CONTEXT);
    pBinding->Context.Flags        = uFlags;
    pBinding->Context.RoutineIndex = RoutineIndex;
    pBinding->Context.Ordinal      = 0;      // BUGBUG
    pBinding->Context.StackOffset  = 0xBAAD;
    // StackOffset should be reset by the callee

    if ( GetHandleType()->NodeKind() == NODE_DEF )
        {
        pCCB->RegisterContextHandleType( GetHandleType() );
        }
}

void
CG_CONTEXT_HANDLE::GenNdrHandleFormat( CCB * pCCB )
/*++
    The layout is:

        FC_BIND_CONTEXT
        handle flag  <1>  upper nibble ptr,in,out,ret, lower: strict,no,ser
        stack offset <2>
        routine index<1>
        FC_PAD
--*/
{
    FORMAT_STRING * pProcFormatString = pCCB->GetProcFormatString();
    CG_PARAM      * pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    NDR64_BINDINGS  binding;

    SetNdrBindDescriptionOffset( pProcFormatString->GetCurrentOffset() );
    GetNdrHandleInfo( pCCB, &binding );

    MIDL_ASSERT( FC_BIND_CONTEXT == binding.Context.HandleType );
    pProcFormatString->PushFormatChar( 
                            (FORMAT_CHARACTER) binding.Context.HandleType );
    pProcFormatString->PushContextHandleFlagsByte( binding.Context.Flags );
                  
    pProcFormatString->PushUShortStackOffsetOrSize(
                    pBindParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    pProcFormatString->PushByte( binding.Context.RoutineIndex );
    pProcFormatString->PushByte( binding.Context.Ordinal );
}


void
CG_PRIMITIVE_HANDLE::GenNdrFormat( CCB * )
/*++

Routine Description :
    
--*/
{
    // Do nothing.
}

void
CG_GENERIC_HANDLE::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :
    
    This routine is only called in the case of a pointer to a generic handle
    in which case the context handle just acts as an intermediary between the
    pointer and underlying user type.

--*/
{
    CG_NDR *    pChild;

    pChild = (CG_NDR *)GetChild();

    if ( GetFormatStringOffset() != -1 )
        return;

    pChild->GenNdrFormat( pCCB );

    SetFormatStringOffset( pChild->GetFormatStringOffset() );

    MIDL_ASSERT( pCCB->GetCGNodeContext()->IsProc() );

    //
    // Register the generic handle.
    //
    if ( ((CG_PROC *)pCCB->GetCGNodeContext())->GetHandleClassPtr() == this )
        pCCB->RegisterGenericHandleType( GetHandleType() );
}

void
CG_CONTEXT_HANDLE::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :
    
--*/
{
    FORMAT_STRING * pFormatString;
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    CG_PROC *       pProc;
    
    pProc = (CG_PROC *) pCCB->GetCGNodeContext();
    MIDL_ASSERT( pProc->IsProc() );

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    //
    // Output an abbreviated description in the type format string.
    //
    pFormatString->PushFormatChar( FC_BIND_CONTEXT );

    //
    // Register the rundown routine always, even if the context handle is
    // not used as the binding paramter.
    //
    if ( GetHandleType()->NodeKind() == NODE_DEF )
        {
        pCCB->RegisterContextHandleType( GetHandleType() );
        }

    // Flags.
    unsigned char uFlags = MakeExplicitHandleFlag( pBindParam );
    if ( fStrictContext )
        {
        uFlags |= NDR_STRICT_CONTEXT_HANDLE;
        }
    if ( fNoSerialize )
        {
        uFlags |= NDR_CONTEXT_HANDLE_NOSERIALIZE;
        }
    else if ( fSerialize )
        {
        uFlags |= NDR_CONTEXT_HANDLE_SERIALIZE;
        }
    if ( GetCannotBeNull()  ||  
         pBindParam->IsParamIn() && !pBindParam->IsParamOut() )
        {
        uFlags |= NDR_CONTEXT_HANDLE_CANNOT_BE_NULL;
        }

    pFormatString->PushContextHandleFlagsByte( uFlags );
                  

    // Routine index.
    // IndexMgr keeps indexes 1..n, we use indexes 0..n-1

    pFormatString->PushByte(
            (char) (pCCB->LookupRundownRoutine(GetRundownRtnName()) - 1) );

    if ( pCCB->GetOptimOption() & OPTIMIZE_NON_NT351 )
        {
        // Context handle's parameter number.
        pFormatString->PushByte( pProc->GetContextHandleCount() );
        pProc->SetContextHandleCount( short(pProc->GetContextHandleCount() + 1) );
        }
    else
        {
        // Context handle's parameter number.  MIDL 2.00.102 and older stubs.
        pFormatString->PushByte( pBindParam->GetParamNumber() );
        }

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );

}

void
CG_PRIMITIVE_HANDLE::GenNdrParamOffline( CCB * )
{
    // Do nothing.
}

void
CG_GENERIC_HANDLE::GenNdrParamOffline( CCB * pCCB )
{
    ((CG_NDR *)GetChild())->GenNdrParamOffline( pCCB );

    MIDL_ASSERT( pCCB->GetCGNodeContext()->IsProc() );

    //
    // Register the generic handle.
    //
    if ( ((CG_PROC *)pCCB->GetCGNodeContext())->GetHandleClassPtr() == this )
        pCCB->RegisterGenericHandleType( GetHandleType() );
}

void
CG_CONTEXT_HANDLE::GenNdrParamOffline( CCB * pCCB )
{
    GenNdrFormat( pCCB );
}

void
CG_PRIMITIVE_HANDLE::GenNdrParamDescription( CCB * )
{
    // No description is emitted, handle_t is not marshalled.
}

void
CG_GENERIC_HANDLE::GetNdrParamAttributes( 
        CCB * pCCB, 
        PARAM_ATTRIBUTES *attributes )
{
    ((CG_NDR *)GetChild())->GetNdrParamAttributes( pCCB, attributes );
}

void
CG_GENERIC_HANDLE::GenNdrParamDescription( CCB * pCCB )
{
    ((CG_NDR *)GetChild())->GenNdrParamDescription( pCCB );
}

void
CG_CONTEXT_HANDLE::GetNdrParamAttributes(
        CCB * pCCB,
        PARAM_ATTRIBUTES *attributes )
{
    CG_NDR::GetNdrParamAttributes( pCCB, attributes );
}

void
CG_CONTEXT_HANDLE::GenNdrParamDescription( CCB * pCCB )
{
    CG_NDR::GenNdrParamDescription( pCCB );
}

//
// +++++++++++++++++++
// Old style parameter description routines.
// +++++++++++++++++++
//
void
CG_PRIMITIVE_HANDLE::GenNdrParamDescriptionOld( CCB * pCCB )
{
    FORMAT_STRING * pProcFormatString;

    pProcFormatString = pCCB->GetProcFormatString();

    pProcFormatString->PushFormatChar( FC_IGNORE );
}

void
CG_GENERIC_HANDLE::GenNdrParamDescriptionOld( CCB * pCCB )
{
    ((CG_NDR *)GetChild())->GenNdrParamDescriptionOld( pCCB );
}

void
CG_CONTEXT_HANDLE::GenNdrParamDescriptionOld( CCB * pCCB )
{
    CG_NDR::GenNdrParamDescriptionOld( pCCB );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\btgen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:
    
    btgen.cxx

 Abstract:

    code generation method implementations for the base type class.

 Notes:


 History:

    Sep-22-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
/****************************************************************************/
extern CMD_ARG * pCommand;


CG_STATUS
CG_BASETYPE::GenMarshall(
    CCB     *   pCCB )
{
    pCCB;
    MIDL_ASSERT(0);
    return CG_OK;
}
CG_STATUS
CG_BASETYPE::GenUnMarshall(
    CCB     *   pCCB )
{
    pCCB;
    MIDL_ASSERT(0);
    return CG_OK;

}

CG_STATUS
CG_BASETYPE::S_GenInitOutLocals(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the init call for the locals.

 Arguments:

    pCCB    - The ptr to code gen block.
    
 Return Value:
    
 Notes:

----------------------------------------------------------------------------*/
{
    expr_node   *   pExpr;

    if( !pCCB->IsRefAllocDone() )
        {
        pExpr   = new expr_sizeof( GetType() );
        Out_Alloc( pCCB, pCCB->GetSourceExpression(), 0, pExpr );
        }
    else
        {
        pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
        Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
        }
    return CG_OK;
}

FORMAT_CHARACTER
CG_BASETYPE::GetFormatChar( CCB *)
{
    switch ( GetType()->GetBasicType()->NodeKind() )
        {
        case NODE_BYTE :
            return FC_BYTE;
        case NODE_CHAR :
            return FC_CHAR;
        case NODE_SMALL :
        case NODE_BOOLEAN :
            return FC_SMALL;
        case NODE_WCHAR_T :
            return FC_WCHAR;
        case NODE_SHORT :
            return FC_SHORT;
        case NODE_LONG :
        case NODE_INT32 :
        case NODE_INT :
            return FC_LONG;
        case NODE_FLOAT :
            return FC_FLOAT;
        case NODE_HYPER :
        case NODE_INT64 :
        case NODE_LONGLONG :
            return FC_HYPER;
        case NODE_DOUBLE :
            return FC_DOUBLE;
        case NODE_INT3264:
			{
		    BOOL    IsUnsigned;

		    IsUnsigned = ((node_base_type *)(GetType()->GetBasicType()))->IsUnsigned();

            if ( pCommand->IsNDR64Run() || pCommand->Is64BitEnv() )
	            return (IsUnsigned ? FC_UINT3264 : FC_INT3264);
            else
                return FC_LONG;
			}
            break;
        case NODE_INT128:
            return FC_INT128;
        case NODE_FLOAT80:
            return FC_FLOAT80;
        case NODE_FLOAT128:
            return FC_FLOAT128;
        default:
            // remove FC_BLKHOLE & HookOLE
            MIDL_ASSERT(0);
            return FC_ZERO;
        }

    // unreachable code
    // return FC_ZERO;
}

NDR64_FORMAT_CHARACTER
CG_BASETYPE::GetNDR64FormatChar( CCB *)
{
    switch ( GetType()->GetBasicType()->NodeKind() )
        {
        case NODE_BYTE :
            return FC64_INT8;
        case NODE_CHAR :
            return FC64_CHAR;
        case NODE_SMALL :
        case NODE_BOOLEAN :
            return FC64_INT8;
        case NODE_WCHAR_T :
            return FC64_WCHAR;
        case NODE_SHORT :
            return FC64_INT16;
        case NODE_LONG :
        case NODE_INT32 :
        case NODE_INT :
            return FC64_INT32;
        case NODE_FLOAT :
            return FC64_FLOAT32;
        case NODE_HYPER :
        case NODE_INT64 :
        case NODE_LONGLONG :
            return FC64_INT64;
        case NODE_DOUBLE :
            return FC64_FLOAT64;
        case NODE_INT3264:
            return pCommand->Is64BitEnv() ? FC64_INT64 : FC64_INT32;
        case NODE_INT128:
            return FC64_INT128;
        case NODE_FLOAT80:
            return FC64_FLOAT80;
        case NODE_FLOAT128:
            return FC64_FLOAT128;
        default:
            // remove FC_BLKHOLE & HookOLE
            MIDL_ASSERT(0);
            return FC64_ZERO;
        }

    // unreachable code
    // return FC_ZERO;
}

FORMAT_CHARACTER
CG_BASETYPE::GetSignedFormatChar()
{
    BOOL    IsUnsigned;

    IsUnsigned = ((node_base_type *)(GetType()->GetBasicType()))->IsUnsigned();

    switch ( GetFormatChar() )
        {
        case FC_BYTE :
            // return FC_USMALL;
        case FC_SMALL :
        case FC_CHAR :
            return (IsUnsigned ? FC_USMALL : FC_SMALL);
        case FC_WCHAR :
            // return FC_USHORT;
        case FC_SHORT :
            return (IsUnsigned ? FC_USHORT : FC_SHORT);
        case FC_LONG :
            return (IsUnsigned ? FC_ULONG : FC_LONG);
        case FC_INT3264 :
        case FC_UINT3264 :
            return (IsUnsigned ? FC_UINT3264 : FC_INT3264);
        case FC_HYPER :
            return (IsUnsigned ? FC_HYPER : FC_HYPER);
        case FC_INT128 :
            return (IsUnsigned ? FC_UINT128 : FC_INT128);
        default :
            MIDL_ASSERT(0);
        }

    return FC_ZERO;
}

NDR64_FORMAT_CHARACTER
CG_BASETYPE::GetNDR64SignedFormatChar()
{
    BOOL    IsUnsigned;

    IsUnsigned = ((node_base_type *)(GetType()->GetBasicType()))->IsUnsigned();

    switch ( GetNDR64FormatChar() )
        {
        case FC64_INT8 :
        case FC64_CHAR :
            return (IsUnsigned ? FC64_UINT8 : FC64_INT8);
        case FC64_WCHAR :
            // return FC_USHORT;
        case FC64_INT16 :
            return (IsUnsigned ? FC64_UINT16 : FC64_INT16 );
        case FC64_INT32 :
            return (IsUnsigned ? FC64_UINT32 : FC64_INT32 );
        case FC64_INT64 :
            return (IsUnsigned ? FC64_UINT64 : FC64_INT64);
        case FC64_INT128 :
            return (IsUnsigned ? FC64_UINT128 : FC64_INT128);
        default :
            MIDL_ASSERT(0);
        }

    return FC64_ZERO;
}

char *
CG_BASETYPE::GetTypeName()
{
    return GetType()->GetSymName();
}

void
CG_BASETYPE::IncrementStackOffset( long * pOffset )
{
    if ( pCommand->Is64BitEnv() )
        {
        *pOffset = (*pOffset + 7) & ~ 0x7;
        *pOffset += 8;
        }
    else
        {

        unsigned short Env;
    
        Env = pCommand->GetEnv();
    
        switch ( GetFormatChar() )
            {
            case FC_HYPER :
            case FC_DOUBLE :
                *pOffset = (*pOffset + 3) & ~ 0x3;
                *pOffset += 8;
                break;
    
            case FC_LONG :
            case FC_FLOAT :
                *pOffset = (*pOffset + 3) & ~ 0x3;
                *pOffset += 4;
                break;
            
            case FC_INT128:
            case FC_FLOAT80:
            case FC_FLOAT128:
                // Check calling convention for these
                // once VC implements them.
                *pOffset = (*pOffset + 3) & ~ 0x3;
                *pOffset += 16;
                break;

            default :
                *pOffset += 4;
                break;
            }
        }
}

FORMAT_CHARACTER
CG_ENUM::GetFormatChar( CCB * )
{
    return ( IsEnumLong() ? FC_ENUM32 : FC_ENUM16 );
}

NDR64_FORMAT_CHARACTER
CG_ENUM::GetNDR64FormatChar( CCB * )
{
    MIDL_ASSERT( IsEnumLong() );
    return FC64_INT32;
}

FORMAT_CHARACTER
CG_ENUM::GetSignedFormatChar()
{
    return ( IsEnumLong() ? FC_LONG : FC_SHORT );
}

NDR64_FORMAT_CHARACTER
CG_ENUM::GetNDR64SignedFormatChar()
{
    MIDL_ASSERT( IsEnumLong() );
    return FC64_INT32;
}

FORMAT_CHARACTER
CG_ERROR_STATUS_T::GetFormatChar( CCB * )
{
    return FC_ERROR_STATUS_T;
}

NDR64_FORMAT_CHARACTER
CG_ERROR_STATUS_T::GetNDR64FormatChar( CCB * )
{
    return FC64_ERROR_STATUS_T;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\bindcls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
    
    bindcls.cxx

 Abstract:

    This module provides implementation of the binding handle code generation
    classes.

 Notes:


 History:

    Sep-19-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
/****************************************************************************/

PNAME
CG_CONTEXT_HANDLE::GetRundownRtnName()
{
    node_skl    *   pType   = GetHandleType();

    if ( ! pRundownRoutineName ) 
        {
        if( pType->NodeKind() == NODE_DEF )
            {
            pRundownRoutineName = new char[256];

            strcpy(pRundownRoutineName, pType->GetSymName());
            strcat(pRundownRoutineName, "_rundown");
            }
        else
            pRundownRoutineName = "0";
        }

    return pRundownRoutineName;
}

CG_STATUS
CG_CONTEXT_HANDLE::MarshallAnalysis(
    ANALYSIS_INFO   *   pAna )
    {
    pAna;
    return CG_OK;
    }

CG_STATUS
CG_CONTEXT_HANDLE::UnMarshallAnalysis(
    ANALYSIS_INFO   *   pAna )
    {
    pAna;
    return CG_OK;
    }

CG_STATUS               
CG_CONTEXT_HANDLE::S_GenInitOutLocals( CCB * pCCB )
{
    ISTREAM *   pStream = pCCB->GetStream();
    CG_PARAM *  pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pStream->NewLine();

    if ( HasNewContextFlavor() )
        {
        // For new flavors generate an initialization call that knows about flags.
        //
        //   handle = NdrContextHandleInitialize( & StubMsg, & TypeFormatStr[i] );
        //

        char            Buf[80];
        unsigned short  Spaces;

        Spaces = (unsigned short)(strlen( pParam->GetResource()->GetResourceName() ) + 7);

        pStream->Write( pParam->GetResource()->GetResourceName() );
        pStream->Write( " = " );
        pStream->Write( "NdrContextHandleInitialize(" );
        pStream->NewLine();
        pStream->Spaces( Spaces );
        pStream->Write( "(PMIDL_STUB_MESSAGE)& "STUB_MESSAGE_VAR_NAME"," );
        pStream->NewLine();
        pStream->Spaces( Spaces );
        pStream->Write( "(PFORMAT_STRING) &" );
        pStream->Write( FORMAT_STRING_STRUCT_NAME );
        sprintf( Buf, ".Format[%d] );", GetFormatStringOffset() );
        pStream->Write( Buf );
        }
    else
        {
        // Old style optimized initialization call
        //
        //   handle = NDRSContextUnmarshall( 0, DataRep );
        //
        pStream->Write( pParam->GetResource()->GetResourceName() );
        pStream->Write( " = " );
        pStream->Write( CTXT_HDL_S_UNMARSHALL_RTN_NAME );
        pStream->Write( "( (char *)0, " );                      // pBuf
        pStream->Write( PRPC_MESSAGE_DATA_REP );                // Data rep
        pStream->Write( " ); " );
        }

    pStream->NewLine();
    return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\arraygen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	arraygen.cxx

 Abstract:

	Implementation of array marshall and unmarshall.

 Notes:


 History:

 	Nov-13-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/


/*****************************************************************************
	utility
 *****************************************************************************/
BOOL
CG_ARRAY::IsBlockCopyPossible()
	{
	return GetBasicCGClass()->IsBlockCopyPossible();
	}
expr_node *
CG_ARRAY::FinalSizeExpression( CCB * pCCB )
	{
	CG_NDR	*	pC;
	expr_node	*	pFSExpr;

	if( (pC = (CG_NDR *)GetChild())->IsArray() )
		{
		pFSExpr = ((CG_ARRAY *)pC)->FinalSizeExpression( pCCB );
		pFSExpr = new expr_b_arithmetic(OP_STAR,
									 	pFSExpr,
									 	PresentedSizeExpression( pCCB ));
		}
	else
		pFSExpr = PresentedSizeExpression( pCCB );

	if( pFSExpr->IsConstant() )
		pFSExpr = new expr_constant( pFSExpr->Evaluate() );

	return pFSExpr;
	}

expr_node *
CG_ARRAY::FinalFirstExpression( CCB * pCCB )
	{
	CG_NDR	*	pC;
	expr_node	*	pFFExpr;

	// for an array a[ 0th ][ 1st]...[nth] the final first expression is:
	// ((First Of nth dim) * Size Nth dim ) + First N-1th dim) * Size N-1th dim
	// and so on.

	if( (pC = (CG_NDR *)GetChild())->IsArray() )
		{
		pFFExpr = ((CG_ARRAY *)pC)->FinalFirstExpression( pCCB );
		pFFExpr = new expr_b_arithmetic(OP_STAR,
									 	pFFExpr,
									 	((CG_ARRAY *)pC)->PresentedSizeExpression( pCCB ));
		pFFExpr	= new expr_b_arithmetic( OP_PLUS,
										  pFFExpr,
									 	((CG_ARRAY *)pC)->PresentedFirstExpression( pCCB ));
											
		}
	else
		pFFExpr = PresentedFirstExpression( pCCB );

	if( pFFExpr->IsConstant() )
		pFFExpr = new expr_constant( pFFExpr->Evaluate() );

	return pFFExpr;
	}
expr_node *
CG_ARRAY::FinalLengthExpression( CCB * pCCB )
	{
	CG_NDR	*	pC;
	expr_node	*	pFLExpr;

	if( (pC = (CG_NDR *)GetChild())->IsArray() )
		{
		pFLExpr = ((CG_ARRAY *)pC)->FinalLengthExpression( pCCB );
		pFLExpr = new expr_b_arithmetic(OP_STAR,
									 	pFLExpr,
									 	PresentedLengthExpression( pCCB ));
		}
	else
		pFLExpr = PresentedLengthExpression( pCCB );

	if( pFLExpr->IsConstant() )
		pFLExpr = new expr_constant( pFLExpr->Evaluate() );

	return pFLExpr;

	}

CG_NDR *
CG_ARRAY::GetBasicCGClass()
	{
	CG_NDR * pC	= (CG_NDR *)GetChild();

	while( pC->IsArray() && (pC->GetCGID() != ID_CG_STRING_ARRAY) )
		{
		pC = (CG_NDR *)pC->GetChild();
		}
	return pC;
	}
BOOL
CG_ARRAY::HasPointer()
	{
	CG_NDR * pBasicCGClass = (CG_NDR *)GetBasicCGClass();

	return ( ( pBasicCGClass->IsPointer() &&
               !pBasicCGClass->IsInterfacePointer() ) ||
             pBasicCGClass->HasPointer() );
	}

CG_STATUS
CG_ARRAY::S_GenInitOutLocals(
	CCB		*	pCCB )
	{
	BOOL		fFixedArrayOfXmitOrRepAs= FALSE;

	// If this is a fixed array, then the array would have been allocated
	// already. Remember, there is also a pointer associated with it.
	// Emit the initialization to the allocated array.

	// If this is a conformant array, then the size would have been
	// unmarshalled before this and so we need to allocate.

	if( IsFixedArray() )
		{
		if( ((CG_NDR *)GetChild())->IsXmitRepOrUserMarshal() )
			{
			fFixedArrayOfXmitOrRepAs = TRUE;
			}

		Out_Assign( pCCB,
                    pCCB->GetSourceExpression(),
                    MakeAddressExpressionNoMatterWhat( GetResource() ) );
		}
	else
		{
		CGPHASE	Phase = pCCB->GetCodeGenPhase();
		expr_node * pElementSizeExpr	=
					 new expr_constant( GetBasicCGClass()-> GetMemorySize() );
		expr_node * pFinalSizeExpr;
		BOOL        fIsSigned;

		// Get the final size expression.
		// Make array believe it is actually on the marshall side, so that the
		// presented expression comes out right.

		pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

		pFinalSizeExpr = FinalSizeExpression( pCCB );

                fIsSigned = !((node_base_type *)pFinalSizeExpr->AlwaysGetType()->GetBasicType())->IsUnsigned();

		pFinalSizeExpr = new expr_b_arithmetic( OP_STAR,
												 pFinalSizeExpr,
												 pElementSizeExpr );

		// Allocate the proper size.
		// If the size expression is signed and the value is less than 0, we
		// need to raise an exception.

		if( pCCB->MustCheckBounds() && fIsSigned )
		    {
		    expr_node * pCheckExpr;
		    pCheckExpr = new expr_op_binary( OP_LESS,
		                                     pFinalSizeExpr,
		                                     new expr_constant(0L));
		    Out_If( pCCB, pCheckExpr);
		    Out_RaiseException( pCCB, "RPC_X_INVALID_BOUND" );
		    Out_Endif( pCCB );
		    }

		Out_Alloc( pCCB,
				   pCCB->GetSourceExpression(),
				   0,
				   pFinalSizeExpr );

		pCCB->SetCodeGenPhase( Phase );
		}


	if( IsArrayOfRefPointers()	|| fFixedArrayOfXmitOrRepAs )
		{
		// Zero out this array of pointers.
		expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
		pProc->SetParam( new expr_param( pCCB->GetSourceExpression() ) );
		pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
		pProc->SetParam( new expr_param( new expr_sizeof( GetType())));
		pCCB->GetStream()->NewLine();
		pProc->PrintCall( pCCB->GetStream(), 0, 0 );
		}

	return CG_OK;
	}

expr_node *
CG_CONFORMANT_ARRAY::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		expr_node * pExpr = GetSizeIsExpr();

		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_VARYING_ARRAY::PresentedLengthExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetLengthResource();
		}
	else
		{
		expr_node * pExpr = GetLengthIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_VARYING_ARRAY::PresentedFirstExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetFirstResource();
		}
	else
		{
		expr_node * pExpr = GetFirstIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_CONFORMANT_VARYING_ARRAY::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		expr_node * pExpr = GetSizeIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_CONFORMANT_VARYING_ARRAY::PresentedLengthExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetLengthResource();
		}
	else
		{
		expr_node * pExpr = GetLengthIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_CONFORMANT_VARYING_ARRAY::PresentedFirstExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetFirstResource();
		}
	else
		{
		expr_node * pExpr = GetFirstIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}
expr_node *
CG_FIXED_ARRAY::PresentedSizeExpression(
	CCB	*)
	{
	expr_node * pExpr =  new expr_constant( GetSizeIsExpr()->Evaluate() );

	return pExpr;
	}

expr_node *
CG_STRING_ARRAY::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		expr_node * pExpr = GetSizeIsExpr();

		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}
expr_node *
CG_CONFORMANT_STRING_ARRAY::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		expr_node * pExpr = GetSizeIsExpr();

		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

BOOL
CG_ARRAY::IsArrayOfRefPointers()
	{
	CG_NDR * pCG	= GetBasicCGClass();
	return ( pCG->IsPointer() &&
			 !pCG->IsInterfacePointer() &&
			 ((CG_POINTER *)pCG)->IsRef() );
	}

BOOL
CG_ARRAY::MustBeAllocatedOnUnMarshall(
	CCB	*	pCCB )
	{
	BOOL	fIsTopLevelArray = (pCCB->GetCurrentEmbeddingLevel() == 0) &&
					   		   (pCCB->GetCurrentIndirectionLevel() == 0 );

	//
	// The array must be allocated if:
	// 	1. Not a top level array on client or server.
	//	2. On the server side, if it is an array of ref pointers.
	//	3. Is not fixed.

	if(!fIsTopLevelArray ||
	   ((pCCB->GetCodeGenSide() == CGSIDE_SERVER) && IsArrayOfRefPointers()) ||
	   !IsFixedArray()
	  )
	  	return TRUE;
	else
		return FALSE;
	}

CG_STATUS
CG_ARRAY::GenRefChecks(
	CCB	*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform ref pointer checks on an array of ref pointers.

 Arguments:

 	pCCB	- The code gen block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	if( IsArrayOfRefPointers() )
		{
		pCCB->SetSourceExpression(new expr_index(
										 pCCB->GetSourceExpression(),
								   		 GetIndexResource()));
        expr_node* pLenExpr     = PresentedLengthExpression( pCCB );
        expr_node* pFirstExpr   = PresentedFirstExpression( pCCB );
        expr_node* pFinalVal    = 0;

        if ( pLenExpr )
            {
            pFinalVal = new expr_b_arithmetic( OP_PLUS, pFirstExpr, pLenExpr );
            }
        else
            {
            pFinalVal = PresentedSizeExpression( pCCB );
            }

		Out_For( pCCB,
				  GetIndexResource(),
				  pFirstExpr,
				  pFinalVal,
				  new expr_constant( 1L )
			   );

		((CG_NDR *)GetChild())->GenRefChecks( pCCB );

		Out_EndFor( pCCB );
		}

	return CG_OK;
	}

CG_STATUS
CG_ARRAY::S_GenInitInLocals(
	CCB	*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 Arguments:

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	if( IsArrayOfRefPointers() && IsFixedArray() )
		{
		expr_node	*	pSrc = pCCB->GetSourceExpression();
		expr_node	*	InLocalResource = GetInLocalResource();
		expr_node	*	pExpr = new expr_assign(
										pSrc,
										MakeAddressExpressionNoMatterWhat(
															 InLocalResource ));
		pCCB->GetStream()->NewLine();
		pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
		pCCB->GetStream()->Write(';');

		expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );

		pProc->SetParam( new expr_param( pSrc ) );
		pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
		pProc->SetParam( new expr_param( new expr_sizeof( GetType())));
		pCCB->GetStream()->NewLine();
		pProc->PrintCall( pCCB->GetStream(), 0, 0 );
		}

	return CG_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\arrayndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    arrayndr.cxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    array types, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

#define OUT_CORRELATION_DESC( x, y )    (x)->PushCorrelationFlagsShort(y)

//*************************************************************************
// CG_ARRAY
//*************************************************************************

BOOL
CG_ARRAY::GenNdrFormatArrayProlog( CCB * pCCB )
/*++

Routine Description :

    Handles some common tasks for array Ndr format string generation.

Arguments :

    pCCB    - pointer to code control block

Return :

    TRUE if format string generation should continue, FALSE if the format
    string for the array has already been generated.

 --*/
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pChild;

    if ( GetFormatStringOffset() != -1 )
        return FALSE;

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    if ( pChild->IsArray() )
        {
        SetIsInMultiDim( TRUE );
        ((CG_ARRAY *)pChild)->SetIsInMultiDim( TRUE );
        }

    //
    // If the array's element type is a structure, pointer, or another array
    // then generate either it's description (structure/array) or it's
    // pointee's description (pointer).
    //
    if ( pChild->IsStruct() ||
         pChild->IsArray() ||
         pChild->IsUnion() ||
         pChild->IsInterfacePointer() ||
         pChild->IsXmitRepOrUserMarshal() )
        {
        pChild->GenNdrFormat( pCCB );
        }

    if ( pChild->IsPointer() && 
        !pChild->IsInterfacePointer() )
        {
        // Only generate the pointee format string if the pointee is not a
        // base type or non-sized string pointer.
        if ( ! pChild->IsPointerToBaseType() &&
             (pChild->GetCGID() != ID_CG_STRING_PTR) )
            ((CG_POINTER *)pChild)->GenNdrFormatPointee( pCCB );
        }

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    //
    // If this is a cs_char array, generate the FC_CS_ARRAY prolog
    //
    GenNdrCSArrayProlog( pCCB );

    //
    // For an array which has [unique] or [ptr] applied to it, we generate
    // a format string description of a pointer to the array.
    //
    if ( GetPtrType() != PTR_REF )
        {
        pFormatString->PushFormatChar( GetPtrType() == PTR_UNIQUE ?
                                       FC_UP : FC_FP );
        pFormatString->PushByte( 0 );
        pFormatString->PushShortOffset( 2 );
        }

    //
    // Check if this is a complex array.
    //
    if ( IsComplex() ) 
        {
        GenNdrFormatComplex( pCCB );
        return FALSE;
        }

    // Push the type.
    switch ( GetCGID() )
        {
        case ID_CG_ARRAY :
        case ID_CG_VAR_ARRAY :
            //
            // Fixed and varying array's fill this in later when they know
            // their size.
            //
            pFormatString->PushByte( 0 );
            break;
        case ID_CG_CONF_ARRAY :
            pFormatString->PushFormatChar( FC_CARRAY );
            break;
        case ID_CG_CONF_VAR_ARRAY :
            pFormatString->PushFormatChar( FC_CVARRAY );
            break;
        }

    //
    // Push the correct alignment value.
    //
    pFormatString->PushByte( ( pChild->IsUnion() ? 1 : pChild->GetWireAlignment() ) - 1 );

    return TRUE;
}

BOOL
CG_ARRAY::GenNdrFormatArrayLayout( CCB * pCCB )
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pChild;
    BOOL                fCanOptimize = TRUE;

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    //
    // See if we need to generate a pointer layout.
    //
    if ( (pChild->IsPointer() && 
          !pChild->IsInterfacePointer()  ) ||
         (pChild->IsStruct() && ((CG_STRUCT *)pChild)->HasPointer()) )
        {
        //
        // Not home free yet.  Even if the array has pointers, we only
        // output a pointer layout if one of the following is true :
        //   1. The array is a top level parameter.
        //   2. The array is really a fabrication of a size or size length
        //      pointer (of structures which contain pointers).
        //   3. The array is embedded in a complex or hard struct.
        // Otherwise the array's pointer description will be in its structure's
        // pointer layout.
        //
        // We also never generate a pointer layout for complex arrays.
        //
        // We know if it was fabricated from a size or size-length pointer
        // if IsDupedSizePtr() is TRUE.
        //
        // BUGBUG: Another case where we should generate the pointer layout
        //         is if our parent is a simple pointer.  One scenario where
        //         this occurs is a struct containing a pointer to an array.
        //         The simple scenario of a top-level pointer to an array is
        //         taken care of because then the node context is the proc.

        CG_NDR * pParent;

        pParent = pCCB->GetCGNodeContext();
        
        if ( pParent->IsProc() ||
             (pParent->GetCGID() == ID_CG_COMPLEX_STRUCT) ||
             (pParent->IsStruct() && 
              ((CG_STRUCT *)pParent)->IsHardStruct()) ||
             IsDupedSizePtr()
           )
            {
            if ( ! IsComplex() )
                GenNdrFormatArrayPointerLayout( pCCB,
                                                FALSE );
            }
        }

    SetElementDescriptionOffset( pFormatString->GetCurrentOffset() );

    //
    // Now generate the element description.
    //
    if ( pChild->IsStruct() || 
         pChild->IsArray() ||
         pChild->IsUnion() ||
         pChild->IsInterfacePointer() ||
         pChild->IsXmitRepOrUserMarshal() )
        {
        pFormatString->PushFormatChar( FC_EMBEDDED_COMPLEX );

        // Not used.
        pFormatString->PushByte( 0 );

        // if embedded complex member has an offset zero, then it is a
        // recursive definition.  Register it for fixup later.

        if ( pChild->GetFormatStringOffset() == 0 )
            {   
            fCanOptimize = FALSE;
            pCCB->RegisterRecPointerForFixup( 
                            pChild, 
                            pFormatString->GetCurrentOffset() );
            }

        pFormatString->PushShortOffset( pChild->GetFormatStringOffset() - 
                                          pFormatString->GetCurrentOffset() );
        }

    if ( pChild->IsPointer() && 
         !pChild->IsInterfacePointer() )
        {
        // 
        // For complex arrays of pointers we put the actual pointer description
        // in the layout, otherwise we put a long.
        //
        if ( IsComplex() )
            {
            ((CG_POINTER *)pChild)->GenNdrFormatAlways( pCCB );
            // This may return zero when pointee is not generated yet. It would
            // need to be checked if we wanted to call the string optimizer.
            }
        else
            {
            pFormatString->PushFormatChar( FC_LONG );
            }
        }

    if ( pChild->IsSimpleType() )
        {
        pChild->GenNdrFormat( pCCB );
        }

    // Possibly align the format string and spit out the FC_END.
    if ( ! (pFormatString->GetCurrentOffset() % 2) )
        pFormatString->PushFormatChar( FC_PAD );

    pFormatString->PushFormatChar( FC_END );
    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );

    return fCanOptimize;
}

void
CG_ARRAY::GenNdrFormatArrayPointerLayout( CCB * pCCB,
                                          BOOL  fNoPP )
/*++

Routine Description :

    Generates the Ndr format string pointer layout for a conformant array.

Arguments :

    pCCB    - pointer to the code control block
    fNoPP   - TRUE if no FC_PP or FC_END should be generated

 --*/
{
    ITERATOR            Iterator;
    FORMAT_STRING *     pFormatString;
    CG_STRUCT *         pStruct;
    CG_NDR *            pImbedingNode;
    unsigned long       MemOffsetToArray;
    unsigned long       BufOffsetToArray;
    long                ImbedingMemSize;
    long                ImbedingBufSize;

    // Get the current imbeding sizes.
    ImbedingMemSize = pCCB->GetImbedingMemSize();
    ImbedingBufSize = pCCB->GetImbedingBufSize();

    pFormatString = pCCB->GetFormatString();

    pImbedingNode = pCCB->GetCGNodeContext();

    MemOffsetToArray = ImbedingMemSize;
    BufOffsetToArray = ImbedingBufSize;

    if ( pImbedingNode->IsStruct() )
        {
        pStruct = (CG_STRUCT *) pImbedingNode;

        if ( GetCGID() == ID_CG_CONF_ARRAY ||
             GetCGID() == ID_CG_CONF_VAR_ARRAY )
            {
            ; // Do nothing, imbeding sizes set offset right.
            }
        else // GetCGID() == ID_CG_ARRAY || ID_CG_VAR_ARRAY
            {
            CG_FIELD *      pField;

            //
            // If we're embedded in a complex struct then we do nothing - our
            // offset will end up being 0.
            //
            if ( pStruct->GetCGID() != ID_CG_COMPLEX_STRUCT )
                {
                pField = pStruct->GetArrayField( this );

                //
                // If we don't find the array's field, that's because the 
                // array must have been contained within a union which was
                // part of a Hard Structure.
                //
                if ( pField )
                    {
                    //
                    // What has to be done here is to actually subract the
                    // difference between the struct's sizes and the field's
                    // offsets, since the array appears somewhere inside the 
                    // struct whose size has already been added to the 
                    // imbeding sizes.
                    //
                    MemOffsetToArray -= pStruct->GetMemorySize() -
                                        pField->GetMemOffset();
                    BufOffsetToArray -= pStruct->GetWireSize() -
                                        pField->GetWireOffset();
                    }
                }
            }
        }

    if ( ! fNoPP )
        {
        pFormatString->PushFormatChar( FC_PP );
        pFormatString->PushFormatChar( FC_PAD );
        }

    //
    // Stuff for fixed arrays.
    //
    if ( GetCGID() == ID_CG_ARRAY )
        {
        pFormatString->PushFormatChar( FC_FIXED_REPEAT );
        pFormatString->PushFormatChar( FC_PAD );
        pFormatString->PushShort( (short)
            ((CG_FIXED_ARRAY *)this)->GetNumOfElements() );
        }

    //
    // Stuff for conformant arrays.
    //
    if ( GetCGID() == ID_CG_CONF_ARRAY )
        {
        pFormatString->PushFormatChar( FC_VARIABLE_REPEAT );
        pFormatString->PushFormatChar( FC_FIXED_OFFSET );
        }

    //
    // Stuff for conformant varying and varying arrays.
    //
    if ( GetCGID() == ID_CG_CONF_VAR_ARRAY ||
         GetCGID() == ID_CG_VAR_ARRAY )
        {
        pFormatString->PushFormatChar( FC_VARIABLE_REPEAT );
        pFormatString->PushFormatChar( FC_VARIABLE_OFFSET );
        }

    if ( GetChild()->IsPointer() && 
         !GetChild()->IsInterfacePointer() )
        {
        CG_POINTER *        pPointer;

        pPointer = (CG_POINTER *) GetChild();

        //
        // Push the increment amount between successive pointers.  In this
        // case it's always 4.
        //
        pFormatString->PushShort( (short) SIZEOF_MEM_PTR() );

        // offset_to_array<2>
        pFormatString->PushShort( (short) MemOffsetToArray );

        // number_of_pointers<2> 
        pFormatString->PushShort( (short) 1 );

        // offset_to_pointer_in_memory<2>
        pFormatString->PushShort( (short) MemOffsetToArray );

        // offset_to_pointer_in_buffer<2>
        pFormatString->PushShort( (short) BufOffsetToArray );

        // Push the pointer description.
        pPointer->GenNdrFormatEmbedded( pCCB );
        }

    if ( GetChild()->IsStruct() )
        {
        ITERATOR        Iterator;
        CG_STRUCT *     pStruct;

        long ImbBufSizeSave = pCCB->GetImbedingBufSize();

        pStruct = (CG_STRUCT *) GetChild();

        //
        // Increment between successive pointers is the memory size of
        // the structure.
        //
        pFormatString->PushShort( (short) pStruct->GetMemorySize() );

        // offset_to_array<2>
        pFormatString->PushShort( (short) MemOffsetToArray );

        // number_of_pointers<2>
        pFormatString->PushShort( (short) pStruct->GetNumberOfPointers() );

        if ( GetCGID() == ID_CG_CONF_VAR_ARRAY ||
             GetCGID() == ID_CG_VAR_ARRAY )
            {
            // Account for varying information in the buffer in front of the array.
            // It effectively makes the flat part of the struct bigger.
            // Imbedded size should be zero for top level and non-embedded arrays.
            if ( ImbBufSizeSave )
                pCCB->SetImbedingBufSize( ImbBufSizeSave + 8 );
            }

        pStruct->GenNdrStructurePointerLayout( pCCB, TRUE, TRUE );
        pCCB->SetImbedingBufSize( ImbBufSizeSave );
        } 

    MIDL_ASSERT( !GetChild()->IsUnion() && !GetChild()->IsArray() );

    if ( ! fNoPP )
        pFormatString->PushFormatChar( FC_END );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
}

void
CG_ARRAY::GenNdrFormatComplex( CCB * pCCB )
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pChild;

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    pFormatString->PushFormatChar( FC_BOGUS_ARRAY );

    // Alignment.
    pFormatString->PushByte( ( pChild->IsUnion() ? 1 : pChild->GetWireAlignment() ) - 1 );

    //
    // Number of elements - 0 if conformant.
    //
    switch ( GetCGID() )
        {
        case ID_CG_ARRAY :
            pFormatString->PushShort( (short)
                    ((CG_FIXED_ARRAY *)this)->GetNumOfElements() );
            break;
        case ID_CG_VAR_ARRAY :
            pFormatString->PushShort( (short)
                    ((CG_VARYING_ARRAY *)this)->GetNumOfElements() );
            break;
        default :
            pFormatString->PushShort( (short) 0 );
            break;
        }

    //
    // Conformance description.
    //
    switch ( GetCGID() )
        {
        case ID_CG_CONF_ARRAY :
            ((CG_CONFORMANT_ARRAY *)this)->
              GenFormatStringConformanceDescription( pCCB, 
                                                     IsDupedSizePtr(),
                                                     IsInMultiDim() );
            break;
        case ID_CG_CONF_VAR_ARRAY :
            ((CG_CONFORMANT_VARYING_ARRAY *)this)->
              GenFormatStringConformanceDescription( pCCB, 
                                                     IsDupedSizePtr(),
                                                     IsInMultiDim() );
            break;
        default :
            pFormatString->PushLong( 0xffffffff );
            if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
                {
                OUT_CORRELATION_DESC( pFormatString, 0 );
                }

            break;
        }
    //
    // Variance description.
    //
    switch ( GetCGID() )
        {
        case ID_CG_CONF_VAR_ARRAY :
            ((CG_CONFORMANT_VARYING_ARRAY *)this)->
              GenFormatStringVarianceDescription( pCCB, 
                                                  IsDupedSizePtr(),
                                                  FALSE,
                                                  IsInMultiDim() );
            break;
        case ID_CG_VAR_ARRAY :
            ((CG_VARYING_ARRAY *)this)->
              GenFormatStringVarianceDescription( pCCB, 
                                                  FALSE,
                                                  TRUE,
                                                  IsInMultiDim() );
            break;
        default :
            pFormatString->PushLong( 0xffffffff );
            if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
                {
                OUT_CORRELATION_DESC( pFormatString, 0 );
                }

            break;
        }

    if ( GenNdrFormatArrayLayout( pCCB ) )
        pFormatString->OptimizeFragment( this );

    // This call needs some preparation that I have no time for.
//    FixupEmbeddedComplex( pCCB );
}

long
CG_ARRAY::GetElementSize()
{
    CG_NDR *            pChild;

    pChild = (CG_NDR *) GetChild();

    if ( pChild->IsSimpleType() )
        {
        // Cheat a little.  Size is equal to wire alignment value.
        return pChild->GetWireAlignment();
        }

    if ( pChild->IsPointer() )
        return SIZEOF_MEM_PTR();

    if ( pChild->IsStruct() )
        return ((CG_STRUCT *)pChild)->GetMemorySize();

    if ( pChild->IsArray() )
        {
        MIDL_ASSERT ( pChild->GetCGID() == ID_CG_ARRAY );

        CG_FIXED_ARRAY * pArray = (CG_FIXED_ARRAY *) pChild;

        return pArray->GetElementSize() * pArray->GetNumOfElements();
        }

    if ( pChild->IsInterfacePointer()  )
        return SIZEOF_MEM_PTR();

    MIDL_ASSERT( !"Shouldn't be able to get here" );

    return 0;   // for the compiler
}

BOOL                    
CG_ARRAY::IsComplex()
{
    if ( IsForcedComplex() )
        {
        return TRUE;
        }
    //
    // If this is a conformant and/or varying array, then it becomes
    // complex if it is part of a multidimensional array (but not a multi
    // level sized pointer).
    //
    if ( (GetCGID() == ID_CG_CONF_ARRAY) ||
         (GetCGID() == ID_CG_CONF_VAR_ARRAY) ||
         (GetCGID() == ID_CG_VAR_ARRAY) )
        {
        if ( IsInMultiDim() && ! IsDupedSizePtr() )
            return TRUE;
        }

    // multi dimensional array of struct embedding pointers needs to be
    // marked complex.
    if ( IsFixedArray() && IsInMultiDim() && HasPointer() )
         return TRUE;

    CG_NDR* pChild = ( CG_NDR* ) GetChild();

    // [range] on an element of an array makes the array complex
    if ( pChild->GetRangeAttribute() )
        {
        return TRUE;
        }

    //
    // Is the array complex by Ndr Engine standards.  Any array of complex
    // or hard structs, encapsulated unions, transmit_as or represent_as, 
    // enums, ref pointers, or another complex array, is complex.
    //
    // Any multidimensional array with at least one dimension with conformance 
    // or variance is complex as well.
    //
    // On 64bit platforms array of pointers are also complex.
    //
    switch ( pChild->GetCGID() )
        {
        case ID_CG_STRUCT :
            return( ((CG_STRUCT *)GetChild())->IsComplexStruct() ||
                    ((CG_STRUCT *)GetChild())->IsHardStruct()    ||
                    GetWireSize() != GetMemorySize() ); 

        case ID_CG_ARRAY :
            switch ( GetCGID() )
                {
                case ID_CG_CONF_ARRAY :
                case ID_CG_CONF_VAR_ARRAY :
                case ID_CG_VAR_ARRAY :
                    return TRUE;
                default :
                    //
                    // The array is complex if the next lower fixed array 
                    // dimension is complex.
                    //
                    return ((CG_ARRAY *) GetChild())->IsComplex();
                }

        case ID_CG_COMPLEX_STRUCT :
        case ID_CG_ENCAP_STRUCT :
        case ID_CG_CONF_ARRAY :
        case ID_CG_CONF_VAR_ARRAY :
        case ID_CG_VAR_ARRAY :
        case ID_CG_STRING_ARRAY :
        case ID_CG_CONF_STRING_ARRAY :
        case ID_CG_TRANSMIT_AS :
        case ID_CG_REPRESENT_AS :
        case ID_CG_USER_MARSHAL :
        case ID_CG_INTERFACE_PTR :
        case ID_CG_IIDIS_INTERFACE_PTR :
        case ID_CG_INT3264 :
            return TRUE;

        case ID_CG_ENUM :
            //
            // The array is complex if it is an array of enum16 or __int3264,
            //  and for a similar reason, bigger in memory than on wire.
            //
            return ! ((CG_ENUM *)GetChild())->IsEnumLong();

        case ID_CG_CONF_STRUCT :
        case ID_CG_CONF_VAR_STRUCT :
            return TRUE;

        default :
            //
            // Make a final check for an array of ref pointers.
            //
            if ( GetChild()->IsPointer() )
                {
                if ( pCommand->Is64BitEnv() )
                    return TRUE;
                else
                    return (((CG_POINTER *)GetChild())->GetPtrType() == PTR_REF);

                }

            return FALSE;
        }
}

BOOL                    
CG_ARRAY::IsMultiConfOrVar()
{
    CG_NDR * pNdr;

    switch ( GetCGID() )
        {
        case ID_CG_CONF_ARRAY :
        case ID_CG_CONF_VAR_ARRAY :
        case ID_CG_VAR_ARRAY :
            break;
        default :
            return FALSE;
        }

    //
    // Search for an inner dimension array other than fixed.
    //
    pNdr = (CG_NDR *) GetChild();

    for ( ; pNdr && pNdr->IsArray(); pNdr = (CG_NDR *) pNdr->GetChild() )
        {   
        if ( pNdr->GetCGID() == ID_CG_ARRAY )
            continue;
        else
            return TRUE;
        }

    return FALSE;
}

BOOL
CG_ARRAY::ShouldFreeOffline()
{
    CG_NDR *    pChild;

    pChild = (CG_NDR *) GetChild();

    switch ( GetCGID() )
        {
        case ID_CG_STRING_ARRAY :
        case ID_CG_CONF_STRING_ARRAY :
            return FALSE;

        default :
            if ( pChild->IsSimpleType() )
                return FALSE;

            if ( pChild->IsStruct() )
                return ((CG_STRUCT *)pChild)->ShouldFreeOffline();

            if ( pChild->IsArray() )
                return ((CG_ARRAY *)pChild)->ShouldFreeOffline();
                
            return TRUE;
        }
}

void
CG_ARRAY::GenFreeInline( CCB * pCCB )
{
    CG_PARAM *  pParam;
    BOOL        fFree;

    fFree = FALSE;

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    //
    // Don't free a [unique] or [ptr] array inline.
    //
    if ( GetPtrType() != PTR_REF )
        return;

    if ( IsComplex() )
        {
        //
        // If the array is complex then we must free it unless it is a
        // fixed or varying array of ref pointers or an [out] fixed or varying 
        // array.
        // Pointer in 64 bit env is already complex
        if ( ! pParam->IsParamIn() || 
              GetBasicCGClass()->IsPointer()  )
            fFree = (GetCGID() == ID_CG_CONF_ARRAY) ||
                    (GetCGID() == ID_CG_CONF_VAR_ARRAY) ;
        else
            fFree = TRUE;
        }
    else
        {
        //
        // For non complex arrays the rules are :
        //  Fixed - never free, we use the buffer.
        //  Conformant - free if [out] only.
        //  Conformant Varying - always free.
        //  Varying - free if [in] or [in,out].
        // 
        //  String array - free always.
        //  Conformant string array - free if sized.
        //
        switch ( GetCGID() )
            {
            case ID_CG_ARRAY :
                break; 

            case ID_CG_CONF_ARRAY :
                fFree = ! pParam->IsParamIn();
                break;

            case ID_CG_CONF_VAR_ARRAY :
                fFree = TRUE;
                break;

            case ID_CG_VAR_ARRAY :
                fFree = pParam->IsParamIn();
                break;

            case ID_CG_STRING_ARRAY :
                fFree = TRUE;
                break;
            
            case ID_CG_CONF_STRING_ARRAY :
                fFree = GetSizeIsExpr() != 0;
                break;
            }
        }

    if ( fFree )
        Out_FreeParamInline( pCCB );
}

//*************************************************************************
// CG_FIXED_ARRAY
//*************************************************************************

void 
CG_FIXED_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a fixed array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    unsigned long       ArraySize;

    if ( GenNdrFormatArrayProlog( pCCB ) )
        {
        MIDL_ASSERT( GetSizeIsExpr()->IsConstant() );

        ArraySize = GetNumOfElements() * GetElementSize();

        //
        // If the array size is >= 64K then the format is different.
        //
        if ( ArraySize >= (64 * 1024) )
            {
            pFormatString->PushFormatChar( FC_LGFARRAY,
                                           pFormatString->GetCurrentOffset() - 2 );
            pFormatString->PushLong( ArraySize );
            }
        else
            {
            pFormatString->PushFormatChar( FC_SMFARRAY,
                                           pFormatString->GetCurrentOffset() - 2 );
            pFormatString->PushShort( (short) ArraySize );
            }

        if ( GenNdrFormatArrayLayout( pCCB ) )
            pFormatString->OptimizeFragment( this );
        }
}

long
CG_FIXED_ARRAY::FixedBufferSize( CCB * pCCB )
{
    CG_NDR *    pNdr;
    long        BufSize;
    long        TotalSize;

    pNdr = (CG_NDR *)GetChild();

    // skip these nodes to get to the transmitted element type.

    if ( pNdr->IsXmitRepOrUserMarshal() )
        pNdr = (CG_NDR *)pNdr->GetChild();

    if ( pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsPointerToBaseType() )
        {
        CG_POINTER * pPointer;

        //
        // Special case arrays of pointers to base types so that we 
        // don't grossly overestimate the buffer size.
        //

        pPointer = (CG_POINTER *) pNdr;
        pNdr = (CG_NDR *) pNdr->GetChild();

        // If this is the 64bit transfer syntax, include 
        // the size of ref pointers in the buffer size.

        BufSize = ( ( pPointer->GetPtrType() == PTR_REF ) &&
                    !pCommand->IsNDR64Run() ) ? 0 : SIZEOF_WIRE_PTR();
        
        BufSize += pNdr->GetWireSize(); 

        return MAX_WIRE_ALIGNMENT + (GetNumOfElements() * BufSize);
        }

    if ( pNdr->IsStruct() || pNdr->IsArray() || pNdr->IsPointer() 
         || pNdr->IsUnion() )
        {
        BufSize = pNdr->FixedBufferSize( pCCB );

        if ( BufSize == -1 ) 
            return -1;

        // Success!
        TotalSize = GetNumOfElements() * BufSize;
        }
    else
        {
        // Fixed array of basetypes.
        TotalSize = MAX_WIRE_ALIGNMENT + GetWireSize();
        }

    return TotalSize;
}

//*************************************************************************
// CG_CONFORMANT_ARRAY
//*************************************************************************

void
CG_CONFORMANT_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a conformant or array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    long                ElementSize;

    if ( ! GenNdrFormatArrayProlog( pCCB ) )
        return;

    ElementSize = GetElementSize();

    if ( ElementSize >= (64 * 1024) )
        {
        RpcError(NULL, 0, ARRAY_ELEMENT_TOO_BIG, GetSymName());
        exit(ARRAY_ELEMENT_TOO_BIG);
        }

    pFormatString->PushShort( ElementSize );

    GenFormatStringConformanceDescription( pCCB, 
                                           IsDupedSizePtr(),
                                           IsInMultiDim() );

    if ( GenNdrFormatArrayLayout( pCCB ) )
        pFormatString->OptimizeFragment( this );

}

//*************************************************************************
// CG_CONFORMANT_VARYING_ARRAY
//*************************************************************************

void CG_CONFORMANT_VARYING_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a conformant varying array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    long                ElementSize;

    if ( ! GenNdrFormatArrayProlog( pCCB ) )
        return;

    ElementSize = GetElementSize();

    if ( ElementSize >= (64 * 1024) )
        {
        RpcError(NULL, 0, ARRAY_ELEMENT_TOO_BIG, GetSymName());
        exit(ARRAY_ELEMENT_TOO_BIG);
        }

    pFormatString->PushShort( ElementSize );

    GenFormatStringConformanceDescription( pCCB, 
                                           IsDupedSizePtr(),
                                           IsInMultiDim() );

    GenFormatStringVarianceDescription( pCCB,
                                        IsDupedSizePtr(),
                                        FALSE,
                                        IsInMultiDim() );

    if ( GenNdrFormatArrayLayout( pCCB ) )
        pFormatString->OptimizeFragment( this );

}

void CG_VARYING_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a varying array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    long                Elements;
    long                ElementSize;
    long                ArraySize;

    if ( ! GenNdrFormatArrayProlog( pCCB ) )
        return;

    //
    // Size must be constant.
    //
    MIDL_ASSERT( GetSizeIsExpr()->IsConstant() );

    Elements = GetNumOfElements();
    ElementSize = GetElementSize();

    ArraySize = Elements * ElementSize;

    //
    // Check if this is a large varying array.
    //
    if ( ArraySize >= (64 * 1024) )
        {
        pFormatString->PushFormatChar( FC_LGVARRAY,
                                       pFormatString->GetCurrentOffset() - 2 );
        pFormatString->PushLong( ArraySize );
        pFormatString->PushLong( Elements );
        }
    else
        {
        pFormatString->PushFormatChar( FC_SMVARRAY,
                                       pFormatString->GetCurrentOffset() - 2 );
        pFormatString->PushShort( ArraySize );
        pFormatString->PushShort( Elements );
        }

    pFormatString->PushShort( ElementSize );

    GenFormatStringVarianceDescription( pCCB,
                                        FALSE,
                                        TRUE,
                                        FALSE );

    if ( GenNdrFormatArrayLayout( pCCB ) )
        pFormatString->OptimizeFragment( this );

}

//*************************************************************************
// CG_STRING_ARRAY
//*************************************************************************

void CG_STRING_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a string array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING * pFormatString;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    GenNdrCSArrayProlog( pCCB );

    if ( IsStringableStruct() )
        {
        pFormatString->PushFormatChar( FC_SSTRING );
        pFormatString->PushByte( ((CG_NDR *)GetChild())->GetWireSize() );
        }
    else
        {
        switch ( ((CG_BASETYPE *)GetChild())->GetFormatChar() )
            {
            case FC_CHAR :
            case FC_BYTE :
                pFormatString->PushFormatChar( FC_CSTRING );
                break;
            case FC_WCHAR :
                pFormatString->PushFormatChar( FC_WSTRING );
                break;
            default :
                MIDL_ASSERT(0);
            }

        pFormatString->PushFormatChar( FC_PAD );
        }

    MIDL_ASSERT( GetSizeIsExpr()->IsConstant() );

    __int64 SizeIs = GetSizeIsExpr()->GetValue();

    if ( _UI16_MAX <= SizeIs )
        {
        RpcError(NULL, 0, ARRAY_SIZE_EXCEEDS_64K, GetSymName());
        exit(ARRAY_SIZE_EXCEEDS_64K);
        }

    pFormatString->PushShort( (short) SizeIs );

    // optimize away duplicates
    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );

    pFormatString->OptimizeFragment( this );

}

void CG_CONFORMANT_STRING_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a conformant string array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING * pFormatString;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    GenNdrCSArrayProlog( pCCB );

    if ( IsStringableStruct() )
        {
        pFormatString->PushFormatChar( FC_C_SSTRING );
        pFormatString->PushByte( ((CG_NDR *)GetChild())->GetWireSize() );
        }
    else
        {
        switch ( ((CG_BASETYPE *)GetChild())->GetFormatChar() )
            {
            case FC_CHAR :
            case FC_BYTE :
                pFormatString->PushFormatChar( FC_C_CSTRING );
                break;
            case FC_WCHAR :
                pFormatString->PushFormatChar( FC_C_WSTRING );
                break;
            default :
                MIDL_ASSERT(0);
            }
        }

    if ( GetSizeIsExpr() )
        {
        pFormatString->PushFormatChar( FC_STRING_SIZED );

        if ( IsStringableStruct() )
            pFormatString->PushFormatChar( FC_PAD );

        //
        // Set the IsPointer parameter to FALSE.
        //
        GenFormatStringConformanceDescription( pCCB, FALSE, IsInMultiDim() );
        }
    else
        {
        if ( ! IsStringableStruct() )
            pFormatString->PushFormatChar( FC_PAD );
        }

    // optimize away duplicates
    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );

    pFormatString->OptimizeFragment( this );

}

//*************************************************************************
// CG_CONF_ATTRIBUTE
//*************************************************************************

void
CG_CONF_ATTRIBUTE::GenFormatStringConformanceDescription( 
    CCB * pCCB,
    BOOL  IsPointer,
    BOOL  IsMultiDArray )
/*++

Routine Description :

    Generates the conformace description field for a conformant (varying)
    array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    GenNdrFormatAttributeDescription( pCCB,
                                      GetMinIsExpr(),
                                      GetSizeIsExpr(),
                                      IsPointer,
                                      FALSE,
                                      FALSE,
                                      IsMultiDArray,
                                      pCommand->IsSwitchDefined( SWITCH_ROBUST ) );
}

//*************************************************************************
// CG_VARY_ATTRIBUTE
//*************************************************************************

void
CG_VARY_ATTRIBUTE::GenFormatStringVarianceDescription( 
    CCB *   pCCB,
    BOOL    IsPointer,
    BOOL    IsVaryingArray,
    BOOL    IsMultiDArray )
/*++

Routine Description :

    Generates the variance description for a (conformant) varying array.

Arguments :

    pCCB    - pointer to the code control block
    IsPointer   - TRUE if the array is actually a length_is pointer
    IsVaryingArray  - TRUE if the array is varying only

 --*/
{
    GenNdrFormatAttributeDescription( pCCB,
                                      GetFirstIsExpr(),
                                      GetLengthIsExpr(),
                                      IsPointer,
                                      FALSE,
                                      IsVaryingArray,
                                      IsMultiDArray,
                                      pCommand->IsSwitchDefined( SWITCH_ROBUST ) );
}

void
GenNdrFormatAttributeDescription( CCB *         pCCB,
                                  expr_node *   pMinExpr,
                                  expr_node *   pSizeExpr,
                                  BOOL          IsPointer,
                                  BOOL          IsUnion,
                                  BOOL          IsVaryingArray,
                                  BOOL          IsMultiDArray,
                                  BOOL          fGenCorrelationDesc,
                                  unsigned char uFlags
                                  )
/*++

Routine Description :

    Generates the conformance, variance, switch_is, or iid_is description for
    an array, pointer, union, or interface pointer.

Arguments :

    pCCB        - Pointer to code control block.
    pMinExpr    - Either the min_is expression (conformance), first_is
                  expression (variance), or 0 for a switch_is (union)
                  or iid_is (interface pointer).
    pSizeExpr   - Either the size_is (conformance), length_is (variance), 
                  switch_is (union), or iid_is (interface pointer) expression.
    IsPointer   - Is the conformance or variance a pointer attribute.
    IsUnion     - Are we generating a switch_is description.

--*/
{
    FORMAT_STRING *     pFormatString;
    node_skl *          pAttributeNodeType;
    long                Offset;
    FORMAT_CHARACTER    Op;
    unsigned char       Type;
    unsigned char       uConfFlags = uFlags;
    pFormatString = pCCB->GetFormatString();

    //
    // Make sure the min_is() or first_is() is constant 0.
    // The pMinExpr is NULL if we're handling a union's switch_is.
    //
    if ( pMinExpr )
        {
        if ( ! pMinExpr->IsConstant() ) 
            goto ComplexAttribute;
        else
            if ( ((expr_constant *)pMinExpr)->GetValue() != 0 )  
                goto ComplexAttribute;
        }

    if ( pSizeExpr->IsConstant() )
        {
        __int64    Size;

        pFormatString->PushCorrelationTypeByte( FC_CONSTANT_CONFORMANCE );

        Size = ((expr_constant *)pSizeExpr)->GetValue();

        //
        // We push the lower 24 bits of the constant size.
        //
        pFormatString->PushByte( (char) ((Size & 0x00ff0000) >> 16) );
        pFormatString->PushShort( (short) (Size & 0x0000ffff) );
        if ( fGenCorrelationDesc )
            {
            OUT_CORRELATION_DESC( pFormatString, uConfFlags );
            }
        return;
        }

    if ( pSizeExpr->IsAVariable() )
        {
        Op = FC_ZERO;
        pAttributeNodeType = pSizeExpr->GetType();
        }
    else
        {
        expr_node * pLeftExpr;
        expr_node * pRightExpr;
        OPERATOR        Operator;

        if ( pSizeExpr->IsBinaryOperator() )
            {
            pLeftExpr = ((expr_op_binary *)pSizeExpr)->GetLeft();
            pRightExpr = ((expr_op_binary *)pSizeExpr)->GetRight();
            }
        else
            if ( pSizeExpr->IsUnaryOperator() )
                pLeftExpr = ((expr_op_unary *)pSizeExpr)->GetLeft();
            else
                goto ComplexAttribute;

        switch ( Operator = ((expr_operator *)pSizeExpr)->GetOperator() )
            {
            case OP_SLASH :
            case OP_STAR :
                if ( pLeftExpr->IsAVariable() &&
                     pRightExpr->IsConstant() &&
                     ((expr_constant *)pRightExpr)->GetValue() == 2 )
                    {
                    Op = ((Operator == OP_SLASH) ? FC_DIV_2 : FC_MULT_2);

                    pAttributeNodeType = pLeftExpr->GetType();
                    }
                else
                    {
                    goto ComplexAttribute;
                    }
                break;

            case OP_PLUS :
            case OP_MINUS :
                if ( ( pLeftExpr->IsAVariable() &&
                       pRightExpr->IsConstant() &&
                       ((expr_constant *)pRightExpr)->GetValue() == 1 ) ||
                     ( pRightExpr->IsAVariable() &&
                       pLeftExpr->IsConstant() &&
                       ((expr_constant *)pLeftExpr)->GetValue() == 1 ) )
                    {
                    Op = ((Operator == OP_PLUS) ? FC_ADD_1 : FC_SUB_1);

                    pAttributeNodeType = pLeftExpr->GetType();
                    }
                else
                    {
                    goto ComplexAttribute;
                    }
                break;

            case OP_UNARY_INDIRECTION :
                if ( ! pLeftExpr->IsAVariable() )
                    goto ComplexAttribute;

                pAttributeNodeType = pLeftExpr->GetType();

                Op = FC_DEREFERENCE;

                break;

            default :
                goto ComplexAttribute;
            }
        }

    // Will hold the switch_is node.
    CG_NDR *        pSwitchNode;

    //
    // Check if this is top level conformance.
    //
    if (  pCCB->GetCGNodeContext()->IsProc() )
        {
        CG_PROC *       pProc       = (CG_PROC *) pCCB->GetCGNodeContext();
        CG_PARAM *      pParam      = 0;
        CG_PARAM*       pCurrParam  = ( CG_PARAM*) pCCB->GetCurrentParam();
        CG_NDR*         pFirst      = 0;

        CG_ITERATOR     Iterator;

        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_SIZE) &&
             IsMultiDArray )
            Type = FC_TOP_LEVEL_MULTID_CONFORMANCE;
        else
            Type = FC_TOP_LEVEL_CONFORMANCE;

        pProc->GetMembers( Iterator );
        //
        // Find out the type of the attribute descriptor.
        //
        while ( ITERATOR_GETNEXT( Iterator, pParam ) )
            {
            // determine early/late correlation
            if ( pFirst == 0 )
                {
                if ( pCurrParam == pParam )
                    {
                    pFirst = pParam;
                    }
                }
            if ( pParam->GetType() == pAttributeNodeType )
                {
                // determine early/late correlation
                if ( pFirst == 0 )
                    {
                    pFirst = pParam;
                    uConfFlags |= FC_EARLY_CORRELATION;
                    }
                break;
                }
            }

        if ( ( ( node_param* ) pAttributeNodeType )->IsSaveForAsyncFinish() )
            {
            uConfFlags |= FC_SPLIT_CORRELATION;
            Op = ( FORMAT_CHARACTER ) ( ( ( unsigned char ) Op ) | 0x20 );
            }

        pParam = ( ( node_param* ) pAttributeNodeType )->GetCG();
        pSwitchNode = (CG_NDR*) pParam->GetChild();
        //
        // Get the actual base type if the attribute is a dereference.
        //
        if ( Op == FC_DEREFERENCE || Op == FC_SPLIT_DEREFERENCE )
            {
            pSwitchNode = (CG_NDR *) pSwitchNode->GetChild();
            }

        // Code the type of the size_is etc. expression.

        if ( pCommand->Is64BitEnv() )
            {
            if ( pSwitchNode->IsPointer() )
                {
                // iid_is
                Type |= FC_HYPER;
                }
            else
                {
                // Special treatment for __int3264.
                // hyper is here till the front end prevents it.

				// Note that to support __int3264 in sizing expressions etc., for robust
				// we would need to know the real size of memory variable.
				// Hence at that point we need a mapping from FC_*3264 to a type in <0..f>.
				// It looks like the only tokens that are left are these
				//     FC_INT3264 -> FC_WCHAR, 
				//	   FC_UINT3264 -> FC_FLOAT
				//     FC_UHYPER -> FC_DOUBLE
				// Please compare Xxx_Is_Type_OK in fldattr.cxx.

                FORMAT_CHARACTER  fc = ((CG_BASETYPE *)pSwitchNode)->GetSignedFormatChar();
        
                if ( fc == FC_INT3264  ||  fc == FC_UINT3264  ||  fc == FC_HYPER )
                    {
                    if ( fc == FC_INT3264 )
                        fc = FC_LONG;
                    else
                        fc = FC_ULONG;
                    }
                Type |= fc;
                }
            }
        else
            {
            if ( pSwitchNode->IsPointer() )
                {
                // iid_is
                Type |= FC_LONG;
                }
            else
                Type |= ((CG_BASETYPE *)pSwitchNode)->GetSignedFormatChar();
            }

        pFormatString->PushCorrelationTypeByte( Type );
        pFormatString->PushFormatChar( Op );

        if ( IsPointer && IsMultiDArray &&
             (pProc->GetOptimizationFlags() & OPTIMIZE_SIZE) )
            {
            CG_QUALIFIED_POINTER* pSizePointer = pCCB->GetCurrentSizePointer();
            pFormatString->PushShort( pSizePointer->GetDimension() ); 
            }
        else
            {
            CG_NDR* pOld = 0;
            if ( ( uConfFlags & FC_SPLIT_CORRELATION ) && pProc->IsFinishProc() )
                {
                pOld = pCCB->SetCGNodeContext( pProc->GetAsyncRelative() );
                }

            pFormatString->PushShortStackOffset( 
                            pParam->GetStackOffset( pCCB, I386_STACK_SIZING )
                            );
            if ( ( uConfFlags & FC_SPLIT_CORRELATION ) && pProc->IsFinishProc() )
                {
                pCCB->SetCGNodeContext( pOld );
                }
            }
        }
    else // structure cg class
        {
        CG_STRUCT *         pStruct;
        CG_FIELD *          pField;
        CG_ITERATOR         Iterator;
        CG_NDR*             pFirst = 0;
        CG_NDR*             pCurrentField = pCCB->GetLastPlaceholderClass();

        if ( IsPointer )
            Type = FC_POINTER_CONFORMANCE;
        else
            Type = FC_NORMAL_CONFORMANCE;

        pStruct = (CG_STRUCT *) pCCB->GetCGNodeContext();

        pStruct->GetMembers( Iterator );

        while ( ITERATOR_GETNEXT( Iterator, pField ) )
            {
            pSwitchNode = (CG_NDR *) pField->GetChild();

            if ( pCurrentField == pField )
                {
                if ( pFirst == 0 )
                    {
                    pFirst = pField;
                    uConfFlags = 0; // late correlation
                    }
                }

            if ( pField->GetType() == pAttributeNodeType  &&
                 ! pField->GetSizeIsDone() )
                {
                if ( pFirst == 0 )
                    {
                    pFirst = pField;
                    uConfFlags = FC_EARLY_CORRELATION; // early correlation
                    }
                pField->SetSizeIsDone( TRUE );

                //
                // Get the actual base type if the attribute is a dereference.
                //
                if ( Op == FC_DEREFERENCE )
                    pSwitchNode = (CG_NDR *) pSwitchNode->GetChild();

                // Code the type of the size etc. expression.

                if ( pSwitchNode->IsPointer() )
                    {
                    // Iid_is check.
                    //
                    if ( pCommand->Is64BitEnv() )
                        Type |= FC_HYPER;
                    else
                        Type |= FC_LONG;

                    break;
                    }

                if ( pCommand->Is64BitEnv() )
                    {
                    // Special treatment for __int3264.
                    // hyper is here till the front end prevents it.

                    FORMAT_CHARACTER  fc = ((CG_BASETYPE *)pSwitchNode)->GetSignedFormatChar();
        
                    if ( fc == FC_INT3264  ||  fc == FC_UINT3264  || fc == FC_HYPER )
                        {
                        if ( fc == FC_INT3264 )
                            fc = FC_LONG;
                        else
                            fc = FC_ULONG;
                        }
                    Type |= fc;
                    }
                else
                    Type |= ((CG_BASETYPE *)pSwitchNode)->GetSignedFormatChar();

                break;
                }
            }

            //
            // Offset to the attribute field in the structure.  Below are
            // the three possible ways to compute the offset, with the order
            // of precedence.
            //
            // For pointers (either sized pointers, or a pointer to a union)
            // this is a positive offset from the beginning of the structure.
            // For imbeded unions this is the offset from the union's position
            // in the structure to the attribute's position.
            // For conformant (varying) arrays it's a negative offset from the
            // end of the structure.
            //
            if ( IsPointer )
                Offset = pField->GetMemOffset();
            else
                {
                if ( IsUnion || IsVaryingArray )
                    {
                    CG_FIELD * pUnionField;

                    pUnionField = (CG_FIELD *) pCCB->GetLastPlaceholderClass();

                    Offset = pField->GetMemOffset() -
                             pUnionField->GetMemOffset();
                    }
                else
                    {
                    Offset = pField->GetMemOffset() -
                             pStruct->GetMemorySize();
                    }
                }

        pFormatString->PushCorrelationTypeByte( Type );
        pFormatString->PushFormatChar( Op );
        pFormatString->PushShort( Offset );
        }

    if ( fGenCorrelationDesc )
        {
        OUT_CORRELATION_DESC( pFormatString, uConfFlags );
        }

    return;

ComplexAttribute:

    char *      PrintPrefix = "";
    CG_NDR *    pNdr;

    pNdr = pCCB->GetCGNodeContext();

    //
    // If this is a top level attribute and we're compiling /Os then we 
    // don't need the callback since the expression is computed inline in 
    // the stub.
    //
    if ( pNdr->IsProc() &&
         (((CG_PROC *)pNdr)->GetOptimizationFlags() & OPTIMIZE_SIZE) )
        {
        pFormatString->PushCorrelationTypeByte( 
                IsMultiDArray ? 
                FC_TOP_LEVEL_MULTID_CONFORMANCE : FC_TOP_LEVEL_CONFORMANCE );
        pFormatString->PushByte( 0 );
        pFormatString->PushShort( (short) 0 );
        }
    else
        {
        long    Displacement;

        if ( pCCB->GetCGNodeContext()->IsProc() )
            Displacement = 0;
        else
            {
            CG_STRUCT *     pStruct;
            CG_FIELD *      pField;
            CG_NDR *        pNdr;

            // Get the imbeding struct.
            pStruct = (CG_STRUCT *) pCCB->GetCGNodeContext();

            // Get the field whose attribute we're handling.
            pField = (CG_FIELD *) pCCB->GetLastPlaceholderClass();

            //
            // Set the PrintPrefix string correctly.
            //
            PrintPrefix = pField->GetPrintPrefix();

            pNdr = (CG_NDR *) pField->GetChild();

            switch ( pNdr->GetCGID() )
                {
                case ID_CG_CONF_ARRAY :
                case ID_CG_CONF_VAR_ARRAY :
                case ID_CG_CONF_STRING_ARRAY :
                    // Displacement is imbeding struct's size.
                    Displacement = pStruct->GetMemorySize();
                    break;

                case ID_CG_VAR_ARRAY :
                case ID_CG_STRING_ARRAY :
                case ID_CG_ENCAP_STRUCT :
                case ID_CG_UNION :
                    // Displacement is imbeded node's offset in the struct.
                    Displacement = pField->GetMemOffset();
                    break;

                default :
                    Displacement = 0;
                    break;
                }
            }

        GenNdrFormatComplexAttributeDescription( pCCB,
                                                 pMinExpr,
                                                 pSizeExpr,
                                                 Displacement,
                                                 PrintPrefix,
                                                 IsPointer );
        }

    if ( fGenCorrelationDesc )
        {
        OUT_CORRELATION_DESC( pFormatString, uConfFlags );
        }

}


void
GenNdrFormatComplexAttributeDescription( CCB *          pCCB,
                                         expr_node *    pMinExpr,
                                         expr_node *    pSizeExpr,
                                         long           StackTopDisplacement,
                                         char *         PrintPrefix,
                                         BOOL           IsPointer )
/*++

Routine description:

    This routine generates
     - an auxuliary routine that evaluates a complicated expression.
     - a description of the callback call into the current code stream.

    The routine has the following signature:

        void  <name>( PMIDL_STUB_MESSAGE pStubMsg );

    The description is as follows (takes 4 bytes):

        0, FC_CALLBACK, <<routine_index>>

    The naming convention for the routine is currently as follows

        <name> is  <proc_or_struct_name>exprEval_<routine_index>

    Routine generation is postponed by using a Registry object.

Arguments:

    pCCB        - ptr to the code control block
    pMinExpr    - pointer to an expression tree, relates to min_is, first_is
    pSizeExpr   - pointer to an expression tree, relates to size_is, max_is etc.
    StackTopDisplacement    - For an attribute expression on a field in a 
                              a structure, this is the number of bytes to 
                              subtract from StackTop to get the proper 
                              structure pointer.
    PrinfPrefix - The prefix to print after "pS->" when accessing a field. 
    IsPointer   - Is this a description for an attribute on a pointer

    The interpretation of the two input expressions (pMinExpr and pSizeExpr)
    is such that when both of them are present, it is enough to take
    the difference to come up with the proper sizing.

    The algorithm used here is thus as follows:
        pMin    pSize

        NULL    NULL    impossible (assert)
        !=NULL  NULL    impossible (assert)

        NULL    !=NULL  Generate a routine that evaluates the following:
                          pStubMsg->Offset = 0
                          pStubMsg->MaxCount = eval(pSize)

        !=NULL  !=NULL  Generate a routine that evaluates the following:
                          pStubMsg->Offset = eval(pMin)
                          pStubMsg->MaxCount  = eval(pSize) - pStubMsg->Offset
Returns:


--*/
{
    MIDL_ASSERT( pSizeExpr != NULL );

    // Make the name of the routine and put it into the table.
    // Each call to the routine we are in right now will create a new entry
    // in the ExprEval routine table.

    CG_NDR *  pContainer = pCCB->GetCGNodeContext();
    unsigned short Index = (unsigned short)
                           (pCCB->GetExprEvalIndexMgr()->GetIndex() - 1);

    char * pContainerName = pContainer->GetType()->GetSymName();
    char * pName = new char[ strlen(pCCB->GetInterfaceName()) +
                             1 +  // "_"
                             strlen(pContainerName) +
                             sizeof("ExprEval_0000") + 1 ];
    strcpy( pName, pCCB->GetInterfaceName() );
    strcat( pName, "_" );
    strcat( pName, pContainerName );
    strcat( pName, "ExprEval_" );

    char * pBuf = pName + strlen(pName);
    sprintf( pBuf, "%04x", Index );

    pCCB->GetExprEvalIndexMgr()->Lookup( pName );

    // generate the description of the callback

    // If this is a top level attribute we note that in the description.
    if ( pCCB->GetCGNodeContext()->IsProc() )
        pCCB->GetFormatString()->PushCorrelationTypeByte(FC_TOP_LEVEL_CONFORMANCE);
    else
        if ( IsPointer ) 
            pCCB->GetFormatString()->PushCorrelationTypeByte(FC_POINTER_CONFORMANCE);
        else
            pCCB->GetFormatString()->PushCorrelationTypeByte(0);

    pCCB->GetFormatString()->PushFormatChar( FC_CALLBACK );
    pCCB->GetFormatString()->PushShort( (short) Index );

    // Register the routine to be generated for future use.

    EXPR_EVAL_CONTEXT * pExprEvalContext = new EXPR_EVAL_CONTEXT;
    pExprEvalContext->pContainer = pContainer;
    pExprEvalContext->pMinExpr = pMinExpr;
    pExprEvalContext->pSizeExpr = pSizeExpr;
    pExprEvalContext->pRoutineName = pName;
    pExprEvalContext->pPrintPrefix = PrintPrefix;
    pExprEvalContext->Displacement = StackTopDisplacement;

    pCCB->RegisterExprEvalRoutine( (node_skl *) pExprEvalContext );

}



void
CG_ARRAY::GenNdrCSArrayProlog( CCB * pCCB )
/*++

Routine description:

    Generate the format string for an array of international characters
    (if necessary).

Arguments:

    pCCB    - pointer to the code control block

Notes:

    This function also inserts the name of the user type and the name of the
    tag routines used (if any) into their respective lists so that the 
    prototypes can be emitted later.
   
    The FC_CSARRAY format:

        FC_CSARRAY
        FC_PAD
        reserved<2>                     // reserved
        element_size<2>                 // size of the user type
        index_of_cs_routines<2>         // offset of sizing/conversion routine
        offset_to_array_or_string<4>    // offset to the underlying type
        
--*/
{
    PNAME   pUserTypeName = GetCSUserTypeName();

    // If there's no CS user type name, this is not a cs array and we can quit.

    if ( ! pUserTypeName )
        return;

    FORMAT_STRING *pFormatString = pCCB->GetFormatString();
    short          TypeIndex = pCCB->GetCsTypeList().Insert( pUserTypeName );

    pFormatString->PushFormatChar( FC_CSARRAY );
    pFormatString->PushByte( 0 );
    pFormatString->PushShort( GetCSElementSize() );
    pFormatString->PushShort( TypeIndex );    
    pFormatString->PushShort( (short) 0 );      // reserved

    // Push the offset to the underlying array/string descriptor.  For now
    // it will always be immediately after the FC_CSARRAY so we can push a
    // constant value

    pFormatString->PushLong( 12 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\btndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    btndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    base types, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

extern CMD_ARG * pCommand;

void
CG_BASETYPE::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a simple type.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    FORMAT_CHARACTER fc = GetFormatChar();
    // Generate the base type's description always.

    if ( GetRangeAttribute() )
        {
        if ( GetFormatStringOffset() == -1 )
            {
            SetFormatStringOffset( pFormatString->GetCurrentOffset() );
            GenRangeFormatString(
                                pFormatString,
                                GetRangeAttribute(),
                                0,  // flags
                                fc
                                );
            }
        }
    else
        {
        pFormatString->PushFormatChar( fc );
        }
}

void CG_BASETYPE::GetNdrParamAttributes(
        CCB * pCCB,
        PARAM_ATTRIBUTES *attributes )
{
    CG_PARAM *pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    attributes->MustSize = 0;
    attributes->MustFree = 0;
    attributes->IsPipe = 0;
    attributes->IsIn = (unsigned short) pParam->IsParamIn();
    attributes->IsOut = (unsigned short) pParam->IsParamOut();
    attributes->IsReturn = (pParam->GetCGID() == ID_CG_RETURN);
    attributes->IsBasetype = ( GetRangeAttribute() == 0 );
    attributes->IsByValue = ( GetRangeAttribute() != 0 );
    attributes->IsSimpleRef = 0;
    attributes->IsDontCallFreeInst = 0;
    attributes->ServerAllocSize = 0;
    attributes->SaveForAsyncFinish = pParam->IsSaveForAsyncFinish();
    attributes->IsPartialIgnore = pParam->IsParamPartialIgnore();
    attributes->IsForceAllocate = 0;
}

void                    
CG_BASETYPE::GenNdrParamDescription( CCB * pCCB )
{
    FORMAT_STRING *     pProcFormatString;
    PARAM_ATTRIBUTES    Attributes;
    CG_PARAM           *pParam;

    pProcFormatString = pCCB->GetProcFormatString();

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    GetNdrParamAttributes( pCCB, &Attributes );

    // Attributes.
    pProcFormatString->PushParamFlagsShort( *((short *)&Attributes) );

    // Stack offset as number of ints.
    pProcFormatString->PushUShortStackOffsetOrSize(
            pParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    if ( GetRangeAttribute() )
        {
        pProcFormatString->PushShort( GetFormatStringOffset() );
        }
    else
        {
        pProcFormatString->PushFormatChar( GetFormatChar() );
        pProcFormatString->PushByte( 0 );
        }
}

long                    
CG_BASETYPE::FixedBufferSize( CCB * )
{
    long    WireSize;

    WireSize = GetWireSize();

    //
    // Return twice the size of the basetype on the wire to cover alignment 
    // padding, plus the difference of it's size with a long if it is smaller
    // than a long.  The second value allows us to do a slightly optimized 
    // marshall/unmarshall of basetypes in the interpreter.
    //
    return (long)((WireSize * 2) + 
           ((WireSize < sizeof(long)) ? (sizeof(long) - WireSize) : 0));
}

void
GenRangeFormatString(
                    FORMAT_STRING*      pFormatString,
                    node_range_attr*    pRangeAttr,
                    unsigned char       uFlags,
                    FORMAT_CHARACTER    formatChar
                    )
{
    if ( pRangeAttr )
        {
        pFormatString->PushFormatChar( FC_RANGE );
        pFormatString->PushByte( ( uFlags & 0xF0 ) | unsigned char( formatChar & 0x0F ) );      // flags:type
// RKK64: TBD: full range on hypers
        pFormatString->PushLong( (ulong) pRangeAttr->GetMinExpr()->GetValue() );  // min.
        pFormatString->PushLong( (ulong) pRangeAttr->GetMaxExpr()->GetValue() );  // max.
        }
}


void
CG_CS_TAG::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a cs_tag type.

Arguments :

    pCCB        - pointer to the code control block.

Notes :

    FC_CS_TAG
    ndr_cs_tag_flags<1>         // Flags (this is cs_stag, etc)
    index_of_tag_routine<2>     // The tag routine index

--*/
{
    FORMAT_STRING *pFormatString = pCCB->GetFormatString();
    CG_PROC       *pProc = (CG_PROC *) pCCB->GetCGNodeContext();
    node_proc     *pTagRoutine;
    short          index;

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    pTagRoutine = pProc->GetCSTagRoutine();

    if ( pTagRoutine )
        {
        index = pCCB->GetCsTagRoutineList().Insert( pTagRoutine->GetSymName() );
        MIDL_ASSERT( index != NDR_INVALID_TAG_ROUTINE_INDEX );
        }   
    else
        {
        index = NDR_INVALID_TAG_ROUTINE_INDEX;
        }

    pFormatString->PushFormatChar( FC_CS_TAG );
    pFormatString->PushByte( * (unsigned char * ) & Flags );
    pFormatString->PushShort( index );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ccb.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    ccb.cxx

 Abstract:

    Some method implementations of the ccb code generation class.

 Notes:


 History:

    Sep-20-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4505 )

 /****************************************************************************
 *      include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

extern  CMD_ARG *   pCommand;

/****************************************************************************
 *      local definitions
 ***************************************************************************/



/****************************************************************************
 *      local data
 ***************************************************************************/

/****************************************************************************
 *      externs
 ***************************************************************************/
/****************************************************************************/

CCB::CCB(
    PNAME           pGBRtnName,
    PNAME           pSRRtnName,
    PNAME           pFBRtnName,
    OPTIM_OPTION    OptimOption,
    BOOL            fManagerEpv,
    BOOL            fNoDefEpv,
    BOOL            fOldNames,
    unsigned long   Mode,
    BOOL            fRpcSSSwitchSetInCompiler,
    BOOL            fMustCheckAllocError,
    BOOL            fCheckRef,
    BOOL            fCheckEnum,
    BOOL            fCheckBounds,
    BOOL            fCheckStubData )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 Arguments:

    pGBRtnName      - default get buffer routine name
    pSRRtnName      - default send receive routine name
    pFBRtnName      - default free buffer routine name
    OptimOption     - optimisation options.
    fManagerEpvFlag - manager epv flag.
    fOldNames       - Do we want MIDL 1.0 style names.
    fNoDefEpv       - we dont want a default epv generated.
    Mode            - Compiler mode : 0 for osf, 1 for ms_ext
    fRpcSSSwitchSetInCompiler - corresponds to -rpcss enabled
    fMustCheckAllocError - corresponds to -error allocation on command line
    fCheckRef       - Check ref pointers
    fCheckEnum      - Check enums
    fCheckBounds    - Check array bounds.
    fCheckStubData  - Check for bad stub data.

 Return Value:

 Notes:

    If the manager epv was set, then we generate the epv calls. Else produce
    statically linked stubs (default behaviour).
----------------------------------------------------------------------------*/
{
    SetStream( 0, NULL );
    SetOptimOption( OptimOption );

    // We can't use SetRuntimeRtnNames here because if any of the names
    // are NULL the member won't get initialized.  This also make the 
    // existing version of SetRuntimeRtnNames obsolete.

    pGetBufferRtnName = pGBRtnName;
    pSendReceiveRtnName = pSRRtnName;
    pFreeBufferRtnName = pFBRtnName;

    // These don't appear to be used

    pIUnknownCG = 0;
    pIClassfCG = 0;
    pStubDescResource = 0;

    // These all seem to be lazily initialized so strictly speaking they don't
    // need to be initialized here but it's lots safer
   
    EmbeddingLevel = 0;
    IndirectionLevel = 0;
    fDeferPointee = 0;
    fAtLeastOneDeferredPointee = 0;
    fMemoryAllocDone = 0;
    fRefAllocDone = 0;
    fReturnContext = 0;

    pInterfaceCG = 0;
    pFileCG = 0;
    pInterfaceName = 0;
    MajorVersion = 0;
    MinorVersion = 0;
    CurrentProcNum = 0;
    CurrentVarNum = 0;
    RpcFlags = 0;
    pAllocRtnName = 0;
    pFreeRtnName = 0;
    pResDictDatabase = 0;
    pCurrentSizePointer = 0;
    lcid = 0;

    // There is no "uninitialized" value to set CodeGenPhase and CodeGenSide
    // to nor any logical value to initialize them to at this point.  Manual
    // inspection seems to indicate that they are properly set as needed.

    // CodeGenPhase = ??
    // CodeGenSide = ??

    //
    // GetPtrToPtrInBuffer is used in CG_POINTER::PointerChecks but nobody
    // seems to call SetPtrInPtrInBuffer so this may be dead wood
    //

    PtrToPtrInBuffer = 0;

    pFormatString = NULL;
    pProcFormatString = NULL;
    pExprFormatString = NULL;

    pGenericHandleRegistry  = new TREGISTRY;
    pContextHandleRegistry  = new TREGISTRY;
    pPresentedTypeRegistry  = new TREGISTRY;
    pRepAsWireTypeRegistry  = new TREGISTRY;
    pQuintupleRegistry      = new TREGISTRY;
    pExprEvalRoutineRegistry= new TREGISTRY;
    pSizingRoutineRegistry  = new TREGISTRY;
    pMarshallRoutineRegistry= new TREGISTRY;
    pUnMarshallRoutineRegistry = new TREGISTRY;
    pFreeRoutineRegistry    = new TREGISTRY;
    pMemorySizingRoutineRegistry = new TREGISTRY;
    pTypeAlignSizeRegistry  = new TREGISTRY;
    pTypeEncodeRegistry     = new TREGISTRY;
    pTypeDecodeRegistry     = new TREGISTRY;
    pTypeFreeRegistry       = new TREGISTRY;
    pPickledTypeList        = new IndexedList;
    pProcEncodeDecodeRegistry= new TREGISTRY;
    pCallAsRoutineRegistry  = new TREGISTRY;

    pRecPointerFixupRegistry = NULL;

    SetImplicitHandleIDNode( 0 );

    SetCGNodeContext( NULL );
    pCurrentRegionField = NULL;
    SetLastPlaceholderClass( NULL );
    
    SetPrefix( 0 );

    pGenericIndexMgr = new CCB_RTN_INDEX_MGR();
    pContextIndexMgr = new CCB_RTN_INDEX_MGR();

    pExprEvalIndexMgr = new CCB_RTN_INDEX_MGR();

    pExprFrmtStrIndexMgr = NULL;

    pTransmitAsIndexMgr = new CCB_RTN_INDEX_MGR();
    pRepAsIndexMgr = new CCB_RTN_INDEX_MGR();

    pQuintupleDictionary = new QuintupleDict;
    pQuadrupleDictionary = new QuadrupleDict;

    pRepAsPadExprDictionary = new RepAsPadExprDict();
    pRepAsSizeDictionary    = new RepAsSizeDict();

    SetImbedingMemSize(0);
    SetImbedingBufSize(0);

    ClearInCallback();

    fMEpV   = fManagerEpv;
    fNoDefaultEpv = fNoDefEpv;
    fInterpretedRoutinesUseGenHandle = 0;

    ClearOptionalExternFlags();
    fSkipFormatStreamGeneration = 1;

    SetOldNames( (fOldNames == TRUE) ? 1 : 0 );

    SetMode( Mode );

    SetInObjectInterface( FALSE );

    SetRpcSSSwitchSet( fRpcSSSwitchSetInCompiler );
    SetMustCheckAllocationError( fMustCheckAllocError );
    SetMustCheckRef( fCheckRef );
    SetMustCheckEnum( fCheckEnum );
    SetMustCheckBounds( fCheckBounds );
    SetMustCheckStubData( fCheckStubData );
    pCreateTypeLib = NULL;
    pCreateTypeInfo = NULL;
    szDllName = NULL;
    SetInDispinterface(FALSE);

    SetCurrentParam( 0 );
    SetInterpreterOutSize( 0 );

    SetNdr64Format( NULL );
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 These routines simply bounce to the file level routines.  They really
 should be inline but the depencies between ccb.hxx and filecls.cxx are
 really ugly and I haven't figured them out yet

----------------------------------------------------------------------------*/

BOOL CCB::GetMallocAndFreeStructExternEmitted()
{
    return pFile->GetMallocAndFreeStructExternEmitted();
}

void CCB::SetMallocAndFreeStructExternEmitted()
{
    pFile->SetMallocAndFreeStructExternEmitted();
}



char *
CCB::GenMangledName()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Given an input name, mangle it with the interface name and version.

 Arguments:

 Return Value:

    A pointer to allocated string containing the complete mangled string.

 Notes:

    This is how the mangling takes place:

    <interface-name>_v<Major>_<Minor>_<pInputName>

    This is what is returned by the routine:

        "v<Major>_<Minor>"

        or

        ""
----------------------------------------------------------------------------*/
{
static  char    TempBuf[30];
    unsigned short  M,m;

    GetVersion( &M, &m );

    if( IsOldNames() )
        {
        TempBuf[ 0 ] = '\0';
        }
    else
        {
        sprintf( TempBuf,
            "_v%d_%d",
            M,
            m );
        }

    return TempBuf;
}

RESOURCE *
CCB::GetStandardResource(
    STANDARD_RES_ID ResID )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Search for a resource with a standard name.

 Arguments:

    ResID   - The standard resource ID.

 Return Value:

 Notes:

    Translate the enum to the name. Search in all dictionaries.
----------------------------------------------------------------------------*/
{
    PNAME       pName;
    RESOURCE *  pResource;

    static char * LocalResIDToResName[] =
        {
        RPC_MESSAGE_VAR_NAME
        ,STUB_MESSAGE_VAR_NAME
        ,GetInterfaceCG()->GetStubDescName()
        ,BUFFER_POINTER_VAR_NAME
        ,RPC_STATUS_VAR_NAME
        ,LENGTH_VAR_NAME
        ,BH_LOCAL_VAR_NAME
        ,PXMIT_VAR_NAME
        };

    static char * ParamResIDToResName[] =
        {
        PRPC_MESSAGE_VAR_NAME
        };

    static char * GlobalResIDToResName[] =
        {
        AUTO_BH_VAR_NAME
        };

    if( IS_STANDARD_LOCAL_RESOURCE( ResID ) )
        {
        pName = LocalResIDToResName[ ResID - ST_LOCAL_RESOURCE_START ];
        }
    else if( IS_STANDARD_PARAM_RESOURCE( ResID ) )
        {
        pName = ParamResIDToResName[ ResID - ST_PARAM_RESOURCE_START ];
        }
    else if( IS_STANDARD_GLOBAL_RESOURCE( ResID ) )
        {
        pName = GlobalResIDToResName[ ResID - ST_GLOBAL_RESOURCE_START ];
        }
#if defined(MIDL_ENABLE_ASSERTS)
    else MIDL_ASSERT(0);
#endif

    if ( ( pResource = GetResDictDatabase()->GetLocalResourceDict()->Search( pName ) ) == 0 )
        {
        if ( ( pResource = GetResDictDatabase()->GetParamResourceDict()->Search( pName ) ) == 0)
            {
            if ( (pResource = GetResDictDatabase()->GetTransientResourceDict()->Search(pName) ) == 0)
                {
                if ( ( pResource=GetResDictDatabase()->GetGlobalResourceDict()->Search(pName) ) == 0 )
                    return 0;
                }
            }
        }

    return pResource;
}

RESOURCE *
CCB::DoAddResource(
    RESOURCE_DICT   *   pResDict,
    PNAME               pName,
    node_skl        *   pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Add a resource to a dictionary.

 Arguments:

    pResDict - A pointer to the resource dictionary.
    pName    - The resource name.
    pType    - The type of the resource.

 Return Value:

 Notes:

    If the type of the resource does not indicate a param node, assume it
    is an ID node and create an id node for it.

----------------------------------------------------------------------------*/
{
    RESOURCE * pRes;

    if( (pRes = pResDict->Search( pName )) == 0 )
        {
        pRes = pResDict->Insert( pName, pType );
        }

    return pRes;
}

RESOURCE *
CCB::SetStubDescResource()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set up the stub descriptor resource.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    node_id * pStubDescVar = new node_id( GetInterfaceCG()->GetStubDescName() );

    pStubDescVar->SetBasicType( (node_skl *)
        new node_def( STUB_DESC_STRUCT_TYPE_NAME ) );

    pStubDescVar->SetEdgeType( EDGE_USE );

    pStubDescResource = new RESOURCE( GetInterfaceCG()->GetStubDescName(),
                                      (node_skl *)pStubDescVar );
    return pStubDescResource;
}


void
CCB::OutputRundownRoutineTable()
{
    OutputSimpleRoutineTable( pContextIndexMgr,
                              RUNDOWN_ROUTINE_TABLE_TYPE,
                              RUNDOWN_ROUTINE_TABLE_VAR );
}

void
CCB::OutputExprEvalRoutineTable()
{
    OutputSimpleRoutineTable( pExprEvalIndexMgr,
                              EXPR_EVAL_ROUTINE_TABLE_TYPE,
                              EXPR_EVAL_ROUTINE_TABLE_VAR );
}

void
CCB::OutputSimpleRoutineTable(
    CCB_RTN_INDEX_MGR * pIndexMgr,
    char *              pTableTypeName,
    char *              pTableVarName
    )
{
    long                        i;
    char *              pName;

    pStream->NewLine();
    pStream->Write( "static const " );
    pStream->Write( pTableTypeName );
    pStream->Write( ' ' );
    pStream->Write( pTableVarName );
    pStream->Write( "[] = ");

    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->NewLine();

    for ( i = 1; ( pName = pIndexMgr->Lookup(i) ) != 0 ; i++ )
        {
        if ( i != 1 )
            pStream->Write( ',' );
        pStream->Write( pName );
        pStream->NewLine();
        }

    pStream->Write( "};" );

    pStream->IndentDec();
    pStream->NewLine( 2 );
}

void 
CCB::OutputOldExprEvalRoutine(EXPR_EVAL_CONTEXT *pExprEvalContext)
{
    CG_NDR *        pContainer  = pExprEvalContext->pContainer;
    expr_node *     pMinExpr    = pExprEvalContext->pMinExpr;
    expr_node *     pSizeExpr   = pExprEvalContext->pSizeExpr;
    char *          pRoutineName= pExprEvalContext->pRoutineName;
    unsigned long   Displacement= pExprEvalContext->Displacement;
    pStream     =   GetStream();

    // generate the header of the evaluation routine

    pStream->NewLine();
    pStream->Write( "static void __RPC_USER " );
    pStream->Write( pRoutineName );
    pStream->Write( "( PMIDL_STUB_MESSAGE pStubMsg )" );
    pStream->NewLine();
    pStream->Write( '{');
    pStream->IndentInc();
    pStream->NewLine();

    //
    // Get the proper struct type.
    //
    char * pContainerTypeName = 0;

    MIDL_ASSERT( pContainer->IsStruct() || pContainer->IsProc() );

    if ( pContainer->IsProc() )
        {
        MIDL_ASSERT( GetOptimOption() | OPTIMIZE_INTERPRETER );

        SetCGNodeContext( pContainer );

        ((CG_PROC *)pContainer)->GenNdrInterpreterParamStruct( this );

        pContainerTypeName = PARAM_STRUCT_TYPE_NAME;
        }
    else
        {
        pContainerTypeName = ((CG_STRUCT *)pContainer)->
                                GetType()->GetSymName();
        }

    expr_node * pExpr = new expr_variable( "pStubMsg->StackTop" );

    if ( Displacement )
        {
        expr_constant * pConstExpr =
                            new expr_constant( (long) Displacement );
        expr_op_binary * pSubtrExpr = new expr_op_binary( OP_MINUS,
                                                          pExpr,
                                                          pConstExpr );
        pExpr = pSubtrExpr;
        }

    //
    // Don't change this call - Dave.
    //
    node_id * pId;

    if ( pContainer->IsProc() )
        {
        pId = MakePtrIDNodeFromTypeNameWithCastedExpr(
                "pS",
                pContainerTypeName,
                pExpr );
        }
    else
        {
        pId = MakePtrIDNodeWithCastedExpr(
                "pS",
                pContainer->GetType(),
                pExpr );
        }

    pId->PrintType( PRT_ID_DECLARATION, pStream );
    pStream->NewLine();

    // generate calculation for the Offset field
    char    TotalPrefix[256];

    strcpy( TotalPrefix, "pS->" );
    strcat( TotalPrefix, pExprEvalContext->pPrintPrefix );

    pStream->Write( "pStubMsg->Offset = " );
    if ( pMinExpr )
        {
        pMinExpr->PrintWithPrefix( pStream, TotalPrefix );
        pStream->Write( ';' );
        }
    else
        pStream->Write( "0;" );
    pStream->NewLine();

    // generate calculation for MaxCount.

    if ( pCommand->Is64BitEnv() )
        {
        // pStubMsg->MaxCount = (ULONG_PTR) ...
        pStream->Write( "pStubMsg->MaxCount = (ULONG_PTR) ( " );
        }
    else
        {
        // pStubMsg->MaxCount = ( unsigned long ) ...
        pStream->Write( "pStubMsg->MaxCount = ( unsigned long ) ( " );
        }
    pSizeExpr->PrintWithPrefix( pStream, TotalPrefix );

    pStream->Write( " );" );

/***
 *** Let's leave this out as the default for now.  This means first_is() with
     last_is() is broken, but first_is() with length_is() will work.

    if ( pMinExpr )
        {
        pStream->Write( " - pStubMsg->Offset;" );
        }
    else
        pStream->Write( ";" );

 ***
 ***/

    // generate the closing of the evaluation routine

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();
}

void
CCB::OutputRegisteredExprEvalRoutines()
{
    ITERATOR            RegisteredRoutines;
    EXPR_EVAL_CONTEXT * pExprEvalContext;

    GetListOfExprEvalRoutines( RegisteredRoutines);

    while ( ITERATOR_GETNEXT( RegisteredRoutines, pExprEvalContext ) )
        {
        OutputOldExprEvalRoutine(pExprEvalContext);
        }
}

void 
CCB::OutputExpressionFormatString()
{
    CCB_EXPR_INDEX_MGR * pIndexMgr = GetExprFrmtStrIndexMgr();
    char    Buf[200];
    
    pStream->NewLine();
    pStream->Write("static const unsigned short "EXPR_FORMAT_STRING_OFFSET_TABLE "[] =") ;
    pStream->NewLine();
    pStream->Write("{");
    pStream->NewLine();

    for (long i = 1; i < pIndexMgr->GetIndex(); i++)
        {
        pStream->Write( MIDL_ITOA(pIndexMgr->GetOffset(i), Buf, 10 ) );
        pStream->NewLine();
        }
    pStream->Write("};");
    pStream->NewLine();
    
    
//    GetExprFormatString()->OutputExprEvalFormatString(GetStream());       

}

// ========================================================================
//       user_marshall Quadruple table
// ========================================================================

void
CCB::OutputQuadrupleTable()
{

    static  char * QuadrupleNames[] =
        {
        USER_MARSHAL_SIZE,
        USER_MARSHAL_MARSHALL,
        USER_MARSHAL_UNMARSHALL,
        USER_MARSHAL_FREE
        };

    static  char * Ndr64QuadrupleNames[] =
        {
        NDR64_USER_MARSHAL_SIZE,
        NDR64_USER_MARSHAL_MARSHALL,
        NDR64_USER_MARSHAL_UNMARSHALL,
        NDR64_USER_MARSHAL_FREE
        };


    long NoOfEntries = GetQuadrupleDictionary()->GetCount();

    pStream->NewLine();
    pStream->Write("static const " USER_MARSHAL_ROUTINE_TABLE_TYPE );
    
    if ( pCommand->IsNDR64Run() )
        {
        pStream->Write( " " NDR64_USER_MARSHAL_ROUTINE_TABLE_VAR 
                    "[ " WIRE_MARSHAL_TABLE_SIZE " ] = " );
        }
    else
        {
        pStream->Write( " " USER_MARSHAL_ROUTINE_TABLE_VAR 
                    "[ " WIRE_MARSHAL_TABLE_SIZE " ] = " );
        }
    pStream->IndentInc();
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    USER_MARSHAL_CONTEXT * * QuadrupleLookupTable;
    USER_MARSHAL_CONTEXT *   pQContext;
    int i;

    QuadrupleLookupTable = new USER_MARSHAL_CONTEXT *[ NoOfEntries ];

    ITERATOR  Quadruples;

    GetQuadrupleDictionary()->GetListOfItems( Quadruples );

    for ( i = 0;
          ITERATOR_GETNEXT( Quadruples, pQContext );
          i++ )
        {
        MIDL_ASSERT( pQContext->Index < NoOfEntries  &&  "look up index violation" );
        QuadrupleLookupTable[ pQContext->Index ] = pQContext;
        }

    MIDL_ASSERT( i == NoOfEntries );

    ISTREAM * pStream = GetStream();

    for ( i = 0; i < NoOfEntries; i++ )
        {
        pQContext = QuadrupleLookupTable[i];

        if ( i )
            pStream->Write( ',' );
        pStream->NewLine();
        pStream->Write( '{' );
        pStream->NewLine();
        for ( int FuncNo = 0;  FuncNo < 4; FuncNo++)
            {
            if ( FuncNo )
                pStream->Write( ',' );
            pStream->Write( pQContext->pTypeName );
            if ( pCommand->IsNDR64Run() )
                pStream->Write( Ndr64QuadrupleNames[ FuncNo ]  );
            else
                pStream->Write( QuadrupleNames[ FuncNo ]  );
            pStream->NewLine();
            }
        pStream->Write( '}' );
        }

    pStream->IndentDec();
    pStream->NewLine( 2 );
    pStream->Write( "};" );

    pStream->IndentDec();
    pStream->IndentDec();
    pStream->NewLine( 2 );

    delete QuadrupleLookupTable;
}


// =======================================================================
//          International character sizing/conversion routine table
// =======================================================================

void CCB::OutputCsRoutineTables()
{
    char *pRoutineSuffix[4] = 
                {
                CS_NET_SIZE,
                CS_TO_NET_CS,
                CS_LOCAL_SIZE,
                CS_FROM_NET_CS
                };

    //
    // Output the sizing/conversion routines table
    //

    pStream->Write( CS_SIZE_CONVERT_ROUTINE_TABLE_TYPE );
    pStream->Write( ' ' );
    pStream->Write( CS_SIZE_CONVERT_ROUTINE_TABLE_VAR );
    pStream->Write( "[] =" );
    pStream->IndentInc();
    pStream->WriteOnNewLine( '{' );
    pStream->IndentInc();

    PNAME       pType;
    bool        fFirst = true;

    ITERATOR_INIT( CsTypes );

    while ( ITERATOR_GETNEXT( CsTypes, pType ) )
        {
        if ( ! fFirst )
            pStream->Write( ',' );

        pStream->WriteOnNewLine( '{' );

        for (int i = 0; i < 4; i++ )
            {
            pStream->WriteOnNewLine( pType );            
            pStream->Write( pRoutineSuffix[i] );
            pStream->Write( ',' );
            }

        pStream->WriteOnNewLine( '}' );

        fFirst = false;
        }
    
    pStream->IndentDec();
    pStream->WriteOnNewLine( "};" );
    pStream->IndentDec();
    pStream->NewLine();

    //
    // Output the tag routines table
    //

    if ( 0 != CsTagRoutines.GetCount() )
        {
        pStream->WriteOnNewLine( CS_TAG_ROUTINE_TABLE_TYPE );
        pStream->Write( ' ' );
        pStream->Write( CS_TAG_ROUTINE_TABLE_VAR );
        pStream->Write( "[] =" );
        pStream->IndentInc();
        pStream->WriteOnNewLine( '{' );
        
        fFirst = true;

        ITERATOR_INIT( CsTagRoutines );

        while ( ITERATOR_GETNEXT( CsTagRoutines, pType ) )
            {
            if ( ! fFirst )
                pStream->Write( ',' );

            pStream->WriteOnNewLine( pType );

            fFirst = false;
            }

        pStream->WriteOnNewLine( "};" );
        pStream->IndentDec();
        pStream->NewLine();
        }

    //
    // Output the pointers-to-tables structure
    //

    pStream->WriteOnNewLine( CS_ROUTINE_TABLES_TYPE );
    pStream->Write( ' ' );
    pStream->Write( CS_ROUTINE_TABLES_VAR );
    pStream->Write( " =" );
    pStream->IndentInc();
    pStream->WriteOnNewLine( '{' );
    pStream->WriteOnNewLine( CS_SIZE_CONVERT_ROUTINE_TABLE_VAR );
    pStream->Write( ',' );
    pStream->WriteOnNewLine( ( 0 != CsTagRoutines.GetCount() )
                                    ? CS_TAG_ROUTINE_TABLE_VAR
                                    : "0" );
    pStream->WriteOnNewLine( "};" );
    pStream->IndentDec();
    pStream->NewLine();
}


// =======================================================================
//          Transmit as and Represent As tables.
// =======================================================================

char *
MakeAnXmitName(
    char *          pTypeName,
    char *          pRoutineName,
    unsigned short )
/*++
    makes the following name: <type_name>_<routine_name>_<index>
--*/
{
    MIDL_ASSERT( pTypeName  &&  pRoutineName );
    char * pXmitName = new char[ strlen(pTypeName) +
                                 strlen(pRoutineName) + 1 ];
    strcpy( pXmitName, pTypeName );
    strcat( pXmitName, pRoutineName );
    return( pXmitName );
}


#define QUINTUPLE_SIZE  4

typedef struct _QUINTUPLE_NAMES
    {
    char * TableType;
    char * TableVar;
    char * FuncName[ QUINTUPLE_SIZE ];
    } QUINTUPLE_NAMES;

void
CCB::OutputQuintupleTable()
{
    static  QUINTUPLE_NAMES TransmitNames =
        {
        XMIT_AS_ROUTINE_TABLE_TYPE,
        XMIT_AS_ROUTINE_TABLE_VAR,
        XMIT_TO_XMIT,
        XMIT_FROM_XMIT,
        XMIT_FREE_XMIT,
        XMIT_FREE_INST
        };

    static  QUINTUPLE_NAMES RepNames=
        {
        REP_AS_ROUTINE_TABLE_TYPE,
        REP_AS_ROUTINE_TABLE_VAR,
        REP_FROM_LOCAL,
        REP_TO_LOCAL,
        REP_FREE_INST,
        REP_FREE_LOCAL
        };

    long NoOfEntries = GetQuintupleDictionary()->GetCount();

    pStream->NewLine();
    pStream->Write("static const "XMIT_AS_ROUTINE_TABLE_TYPE );
    pStream->Write( " " XMIT_AS_ROUTINE_TABLE_VAR 
                    "[ " TRANSMIT_AS_TABLE_SIZE " ] = " );

    pStream->IndentInc();
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    // Now construct a lookup table with entries in the order of indexes.
    // (we have to keep index managers separate for rep_as and xmit_as
    //  and we still have a common table)

    XMIT_AS_CONTEXT * * QuintupleLookupTable;
    XMIT_AS_CONTEXT *   pQContext;
    int                 i;

    QuintupleLookupTable = new XMIT_AS_CONTEXT *[ NoOfEntries ];

    ITERATOR  Quintuples;

    GetListOfQuintuples( Quintuples );
    for ( i = 0;
          ITERATOR_GETNEXT( Quintuples, pQContext );
          i++ )
        {
        MIDL_ASSERT( pQContext->Index < NoOfEntries  &&  "look up index violation" );
        QuintupleLookupTable[ pQContext->Index ] = pQContext;
        }


    ISTREAM * pStream = GetStream();

    for ( i = 0; i < NoOfEntries; i++ )
        {
        pQContext = QuintupleLookupTable[i];

        char *  pName = pQContext->fXmit
                        ? pQContext->pTypeName
                        : ((CG_REPRESENT_AS *)pQContext->pXmitNode)->
                            GetTransmittedType()->GetSymName();
        unsigned short Index = pQContext->Index;

        MIDL_ASSERT( (i == Index)  && " xmit index violation" );

        QUINTUPLE_NAMES *   pQNames = pQContext->fXmit ?  & TransmitNames
                                                       :  & RepNames;
        if ( i )
            pStream->Write( ',' );
        pStream->NewLine();
        pStream->Write( '{' );
        pStream->NewLine();
        for ( int FuncNo = 0;  FuncNo < QUINTUPLE_SIZE; FuncNo++)
            {
            char * pTempName = MakeAnXmitName( pName,
                                               pQNames->FuncName[ FuncNo ],
                                               Index );
            if ( FuncNo )
                pStream->Write( ',' );
            pStream->Write( pTempName );
            pStream->NewLine();
            delete pTempName;
            }
        pStream->Write( '}' );
        }

    pStream->IndentDec();
    pStream->NewLine( 2 );
    pStream->Write( "};" );

    pStream->IndentDec();
    pStream->IndentDec();
    pStream->NewLine( 2 );

    delete QuintupleLookupTable;
}


// =======================================================================
//   helpers for  Transmit as and Represent As routines
// =======================================================================

static void
OpenXmitOrRepRoutine(
    ISTREAM *   pStream,
    char *      pName )
/*++
Routine description:

    This routine emits the header of a *_as helper routine:

        void  __RPC_API
        <name>(  PMIDL_STUB_MESSAGE pStubMsg )
        {

Note:

    There is a side effect here that the name of the routine is deleted
    (this is always the name created by a call to MakeAnXmitName).

--*/
{
    pStream->Write  ( "NDR_SHAREABLE void __RPC_USER" );
    pStream->NewLine();
    pStream->Write  ( pName );
    pStream->Write  ( "( PMIDL_STUB_MESSAGE pStubMsg )" );
    pStream->NewLine();
    pStream->Write( '{');
    pStream->IndentInc();
    pStream->NewLine();

    delete pName;
}

static void
CloseXmitOrRepRoutine(
    ISTREAM *   pStream )
/*++
Routine description:

    Just a complement to the OpenXmitOrRepRoutine:

        }

--*/
{
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}');
    pStream->NewLine();
}

static void
OutputPresentedTypeInit(
    ISTREAM *   pStream,
    char *      pPresentedTypeName )
/*++
Routine description:

    Emits

        memset( pStubMsg->pPresentedType, 0, sizeof( <presented type> ));

--*/
{
    pStream->NewLine();
    pStream->Write( MIDL_MEMSET_RTN_NAME "( "PSTUB_MESSAGE_PAR_NAME"->pPresentedType, 0, sizeof(" );
    pStream->Write( pPresentedTypeName );
    pStream->Write( " ));" );
}

static void
OutputCastedPtr(
    ISTREAM *   pStream,
    char *      pTypeName,
    char *      pVarName )
{
    pStream->Write( '(' );
    pStream->Write( pTypeName );
    pStream->Write( " *) " );
    pStream->Write( pVarName );
}


// =======================================================================
//          Transmit as
// =======================================================================
//
// The presented type size problem.
// The engine doesn't use pStubMsg->PresentedTypeSize field anymore.
// The presented type size nowadays is passed within the format code.
//

static void
OutputToXmitCall(
    ISTREAM *   pStream,
    char *      pPresentedTypeName,
    char *      pTransmitTypeName )
{
    pStream->Write( pPresentedTypeName );
    pStream->Write( "_to_xmit( " );
    OutputCastedPtr( pStream,
                     pPresentedTypeName,
                     PSTUB_MESSAGE_PAR_NAME"->pPresentedType, " );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '(' );
    pStream->Write( pTransmitTypeName );
    pStream->Write( " * *) &pStubMsg->pTransmitType );" );
    pStream->IndentDec();
//    pStream->NewLine();
}

static void
OutputFreeXmitCall(
    ISTREAM *   pStream,
    char *      pPresentedTypeName,
    char *      pTransmitTypeName )
{
    pStream->Write( pPresentedTypeName );
    pStream->Write( "_free_xmit( " );
    OutputCastedPtr( pStream, pTransmitTypeName, "pStubMsg->pTransmitType );" );
}


void
CCB::OutputTransmitAsQuintuple(
    void *   pQuintupleContext
    )
/*++
Routine description:

    This routine emits the following helper routines for a transmit as type:

    static void  __RPC_API
    <pres_type>_Xmit_ToXmit_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <pres_type>_to_xmit( (<pres_type> *) pStubMsg->pPresentedType,
                             (<tran_type> * *) &pStubMsg->pTransmitType );
    }

    static void  __RPC_API
    <pres_type>_Xmit_FromXmit_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <pres_type>_from_xmit(
                        (<tran_type> *)  pStubMsg->pTransmitType,
                        (<pres_type> *)  pStubMsg->pPresentedType );

    }

    static void  __RPC_API
    <pres_type>_Xmit_FreeXmit_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <pres_type>_free_xmit(
                        (<tran_type> *)  pStubMsg-p>TransmitType );

    }

    static void  __RPC_API
    <pres_type>_Xmit_FreeInst_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <pres_type>_free_xmit(
                        (<pres_type> *) pStubMsg->pPresentedType );

    }

--*/
{
    XMIT_AS_CONTEXT * pTransmitAsContext = (XMIT_AS_CONTEXT*) pQuintupleContext;
    int i = pTransmitAsContext->Index;

    ISTREAM * pStream = GetStream();
    pStream->NewLine();

    CG_TRANSMIT_AS* pXmitNode = (CG_TRANSMIT_AS *)
                                pTransmitAsContext->pXmitNode;

    char * pPresentedTypeName = pXmitNode->GetPresentedType()->GetSymName();
    char * pTransmitTypeName = pXmitNode->GetTransmittedType()->
                                                           GetSymName();
    // *_XmitTranslateToXmit

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pPresentedTypeName,
                                                   XMIT_TO_XMIT,
                                                   unsigned short(i) ) );
    OutputToXmitCall( pStream, pPresentedTypeName, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_XmitTranslateFromXmit

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pPresentedTypeName,
                                                   XMIT_FROM_XMIT,
                                                   unsigned short(i) ) );
    pStream->Write( pPresentedTypeName );
    pStream->Write( "_from_xmit( " );
    OutputCastedPtr( pStream, pTransmitTypeName, "pStubMsg->pTransmitType, " );
    pStream->IndentInc();
    pStream->NewLine();
    OutputCastedPtr( pStream, pPresentedTypeName, "pStubMsg->pPresentedType ); " );
    pStream->IndentDec();
    CloseXmitOrRepRoutine( pStream );

    // *_XmitFreeXmit

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pPresentedTypeName,
                                                   XMIT_FREE_XMIT,
                                                   unsigned short(i) ) );
    OutputFreeXmitCall( pStream, pPresentedTypeName, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_XmitFreeInst

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pPresentedTypeName,
                                                   XMIT_FREE_INST,
                                                   unsigned short(i) ) );
    pStream->Write( pPresentedTypeName );
    pStream->Write( "_free_inst( " );
    OutputCastedPtr( pStream, pPresentedTypeName, "pStubMsg->pPresentedType ); " );
    CloseXmitOrRepRoutine( pStream );
}

void
CCB::OutputQuintupleRoutines()
/*++
--*/
{
    ITERATOR            Quintuples;
    XMIT_AS_CONTEXT *   pQuintupleContext;
    int                 i;

    // Multi-interface problem: This routine is only called after the last
        // interface.

    GetListOfQuintuples( Quintuples );
    for ( i = 1;
          ITERATOR_GETNEXT( Quintuples, pQuintupleContext );
          i++ )
        {
        if ( pQuintupleContext->fXmit )
            OutputTransmitAsQuintuple( pQuintupleContext );
        else
            OutputRepAsQuintuple( pQuintupleContext );
        }
}

// ========================================================================
//       Represent As
// ========================================================================
//
// There is a lot of symmetry between transmit as and represent as.
// We use that where possible. So, among other things there is the following
// mapping between represent as routines and the transmit as ones.
// (So called quintuple actually has 4 routines now.)
//
//  wrapers
//      pfnTranslateToXmit      *_to_xmit           *_from_local
//      pfnTranslateFromXmit    *_from_xmit         *_to_local
//      pfnFreeXmit             *_free_xmit         *_free_inst
//      pfnFreeInst             *_free_inst         *_free_local
//
// The presented type size problem.
//      This is either known and put into the format code explicitely,
//      or unknown and then put there via a C-compile macro.
//
// The presented type alignment problem.
//      There is a problem when there is a padding preceding a represent as
//      field. The engine needs to know what the alignment for the represent
//      as field is. As we may not know its type at the midl compile time,
//      the only way to deal with it is to use the parent structure name,
//      and the represent as field name.
//


static void
OutputToLocalCall(
    ISTREAM *   pStream,
    char *      pLocalTypeName,
    char *      pTransmitTypeName )
{
    pStream->Write( pTransmitTypeName );
    pStream->Write( "_to_local( " );
    OutputCastedPtr( pStream, pTransmitTypeName,
                     PSTUB_MESSAGE_PAR_NAME"->pTransmitType, " );
    pStream->IndentInc();
    pStream->NewLine();
    OutputCastedPtr( pStream, pLocalTypeName,
                     PSTUB_MESSAGE_PAR_NAME"->pPresentedType ); " );
    pStream->IndentDec();
}

static void
OutputFromLocalCall(
    ISTREAM *   pStream,
    char *      pLocalTypeName,
    char *      pTransmitTypeName )
{
    pStream->Write( pTransmitTypeName );
    pStream->Write( "_from_local( " );
    OutputCastedPtr( pStream, pLocalTypeName,
                     PSTUB_MESSAGE_PAR_NAME"->pPresentedType, " );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '(' );
    pStream->Write( pTransmitTypeName );
    pStream->Write( " * *) &pStubMsg->pTransmitType );" );
    pStream->IndentDec();
}

static void
OutputRepAsFreeInstCall(
    ISTREAM *   pStream,
    char *      pTransmitTypeName )
{
    pStream->Write( pTransmitTypeName );
    pStream->Write( "_free_inst( " );
    OutputCastedPtr( pStream, pTransmitTypeName,
        PSTUB_MESSAGE_PAR_NAME"->pTransmitType );" );
}



void
CCB::OutputRepAsQuintuple(
    void *   pQuintupleContext
    )
/*++
Routine description:

    This routine emits the following helper routines for a transmit as type:

    static void  __RPC_API
    <trans_type>_RepAsFromLocal_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <trans_type>_from_local(
                        (<pres_type> *) pStubMsg->pPresentedType,
                        (<tran_type> * *) &pStubMsg->pTransmitType );
    }

    static void  __RPC_API
    <trans_type>_RepAsToLocal_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <trans_type>_to_local(
                        (<tran_type> *)  pStubMsg->pTransmitType,
                        (<pres_type> *)  pStubMsg->pPresentedType );

    }

    static void  __RPC_API
    <trans_type>_RepAsFreeInst_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <trans_type>_free_inst(
                        (<tran_type> *)  pStubMsg-p>TransmitType );

    }

    static void  __RPC_API
    <trans_type>_RepAsFreeLocal_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <trans_type>_free_local(
                        (<pres_type> *) pStubMsg->pPresentedType );

    }

--*/
{
    XMIT_AS_CONTEXT * pRepAsContext = (XMIT_AS_CONTEXT*) pQuintupleContext;
    int               i = pRepAsContext->Index;

    ISTREAM * pStream = GetStream();

    CG_REPRESENT_AS * pRepAsNode = (CG_REPRESENT_AS *)
                                      pRepAsContext->pXmitNode;

    char * pLocalTypeName = pRepAsNode->GetRepAsTypeName();
    char * pTransmitTypeName = pRepAsNode->GetTransmittedType()->
                                                           GetSymName();
    // *_RepAsTranslateToLocal

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pTransmitTypeName,
                                                   REP_TO_LOCAL,
                                                   unsigned short(i) ) );
    OutputToLocalCall( pStream, pLocalTypeName, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_RepAsTranslateFromLocal

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pTransmitTypeName,
                                                   REP_FROM_LOCAL,
                                                   unsigned short(i) ) );
    OutputFromLocalCall( pStream, pLocalTypeName, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_RepAsFreeInst

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pTransmitTypeName,
                                                   REP_FREE_INST,
                                                   unsigned short(i) ) );
    OutputRepAsFreeInstCall( pStream, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_RepAsFreeLocal

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pTransmitTypeName,
                                                   REP_FREE_LOCAL,
                                                   unsigned short(i) ) );
    pStream->Write( pTransmitTypeName );
    pStream->Write( "_free_local( " );
    OutputCastedPtr( pStream, pLocalTypeName, "pStubMsg->pPresentedType ); " );
    CloseXmitOrRepRoutine( pStream );

}

// ========================================================================
//       end of Transmit As and Represent As
// ========================================================================


BOOL
CCB::HasBindingRoutines( CG_HANDLE * pImplicitHandle )
{
    return  ! pGenericIndexMgr->IsEmpty() ||
        (pImplicitHandle &&
        pImplicitHandle->IsGenericHandle());
}

void
CCB::OutputBindingRoutines()
{
    long   i;
    char * pName;

    pStream->NewLine();
    pStream->Write( "static const " BINDING_ROUTINE_TABLE_TYPE );
    pStream->Write( " "  BINDING_ROUTINE_TABLE_VAR 
                    "[ " GENERIC_BINDING_TABLE_SIZE " ] = " );

    pStream->IndentInc();
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->NewLine();

    for ( i = 1; ( pName = pGenericIndexMgr->Lookup(i) ) != 0 ; i++ )
        {
        if ( i != 1 )
            pStream->Write( ',' );
        pStream->Write( '{' );
        pStream->IndentInc();
        pStream->NewLine();

        pStream->Write( "(" GENERIC_BINDING_ROUTINE_TYPE ")" );
        pStream->Write( pName );
        pStream->Write( "_bind" );
        pStream->Write( ',' );
        pStream->NewLine();

        pStream->Write( "(" GENERIC_UNBINDING_ROUTINE_TYPE ")" );
        pStream->Write( pName );
        pStream->Write( "_unbind" );

        pStream->IndentDec();
        pStream->NewLine();

        pStream->Write( " }" );
        pStream->NewLine();
        }

    pStream->NewLine();
    pStream->Write( "};" );

    pStream->IndentDec();
    pStream->IndentDec();
    pStream->NewLine();
    pStream->NewLine();
}


void
CCB::OutputMallocAndFreeStruct()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs the malloc and free struct for the RpcSsm connection.

    This is needed only at the client side and non object interfaces.

    If the [enable_allocate] affects a remote routine, the client side stub
    defaults to malloc and free when unmarshalling regardless of the
    compiler mode (osf vs. non-osf).

    Therefore, the structure gets generated:
        - always in the osf mode or
        - in non-osf when at least one routine is affected by the attribute.
    This is one-per-many-interfaces structure.

    Because of win16 DS register problems, malloc and free have to be
    accessed via wrappers with appropriate calling conventions.
    To simplify, we generate wrappers for every platform.

    REVIEW: win16 is gone, we should be able to get rid of the wrappers.

----------------------------------------------------------------------------*/
{
    // malloc and free wrappers.

    pStream->NewLine();
    pStream->Write( "static void * __RPC_USER" );
    pStream->NewLine();
    pStream->Write( GetInterfaceName() );
    pStream->Write( "_malloc_wrapper( size_t _Size )" );
    pStream->NewLine();
    pStream->Write( "{" );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( "return( malloc( _Size ) );" );
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "}" );
    pStream->NewLine();

    pStream->NewLine();
    pStream->Write( "static void  __RPC_USER" );
    pStream->NewLine();
    pStream->Write( GetInterfaceName() );
    pStream->Write( "_free_wrapper( void * _p )" );
    pStream->NewLine();
    pStream->Write( "{" );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( "free( _p );" );
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "}" );
    pStream->NewLine();

    // The structure.

    pStream->NewLine();
    pStream->Write( "static " MALLOC_FREE_STRUCT_TYPE_NAME );
    pStream->Write( " " MALLOC_FREE_STRUCT_VAR_NAME " = ");
    pStream->NewLine();
    pStream->Write( "{");
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( GetInterfaceName() );
    pStream->Write( "_malloc_wrapper," );
    pStream->NewLine();
    pStream->Write( GetInterfaceName() );
    pStream->Write( "_free_wrapper" );

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "};" );
    pStream->NewLine();
}

// ========================================================================


void
CCB::OutputExternsToMultipleInterfaceTables()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the tables that may be common to multiple interfaces.

 Arguments:

    pCCB - A pointer to the code gen controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    CGSIDE  Side = GetCodeGenSide();

    pStream->NewLine();

    //
    // Emit extern to the rundown routine table on the server Oi side,
    // if needed.
    //
    if ( (Side == CGSIDE_SERVER) &&
        ( GetOptimOption() & OPTIMIZE_INTERPRETER) &&
        HasRundownRoutines()  && ! GetRundownExternEmitted() )
        {
        pStream->Write( "extern const " RUNDOWN_ROUTINE_TABLE_TYPE );
        pStream->Write( " " RUNDOWN_ROUTINE_TABLE_VAR "[];" );
        pStream->NewLine();
        SetRundownExternEmitted();
        }

    //
    // Emit extern to the binding routine pair table on the client Oi stub
    // if needed.
    //
    if ( (Side == CGSIDE_CLIENT) &&
         GetInterpretedRoutinesUseGenHandle()  &&
         ! GetGenericHExternEmitted()
         )
        {
        pStream->Write( "extern const " BINDING_ROUTINE_TABLE_TYPE );
        pStream->Write( " "  BINDING_ROUTINE_TABLE_VAR 
                        "[ " GENERIC_BINDING_TABLE_SIZE " ];" );
        pStream->NewLine();
        SetGenericHExternEmitted();
        }

    //
    // Emit extern to the expr eval routine table on both sides.
    //
    if ( HasExprEvalRoutines()  &&  ! GetExprEvalExternEmitted() )
        {
        pStream->Write( "extern const " EXPR_EVAL_ROUTINE_TABLE_TYPE );
        pStream->Write( " " EXPR_EVAL_ROUTINE_TABLE_VAR "[];" );
        pStream->NewLine();
        SetExprEvalExternEmitted();
        }

    //
    // Emit extrn to the transmit as and rep as routine table on both sides.
    //
    if ( HasQuintupleRoutines()  &&  ! GetQuintupleExternEmitted() )
        {
        pStream->Write( "extern const " XMIT_AS_ROUTINE_TABLE_TYPE );
        pStream->Write( " " XMIT_AS_ROUTINE_TABLE_VAR 
                        "[ " TRANSMIT_AS_TABLE_SIZE " ];" );
        pStream->NewLine();
        SetQuintupleExternEmitted();
        }

    //
    // Emit extrn to the user_marshal routine table on both sides.
    //
    if ( HasQuadrupleRoutines()  &&  ! GetQuadrupleExternEmitted() )
        {
        if ( pCommand->NeedsNDR64Run() )
            {
            pStream->Write( "extern const " USER_MARSHAL_ROUTINE_TABLE_TYPE );
            pStream->Write( " " NDR64_USER_MARSHAL_ROUTINE_TABLE_VAR 
                            "[ " WIRE_MARSHAL_TABLE_SIZE " ];" );
            pStream->NewLine();
            }
        if ( pCommand->NeedsNDRRun() )
            {
            pStream->Write( "extern const " USER_MARSHAL_ROUTINE_TABLE_TYPE );
            pStream->Write( " " USER_MARSHAL_ROUTINE_TABLE_VAR 
                            "[ " WIRE_MARSHAL_TABLE_SIZE " ];" );
            pStream->NewLine();
            }
        SetQuadrupleExternEmitted();
        }

    if ( HasCsTypes() )
        {
        //
        // Emit the international character sizing/conversion routine table
        //
        OutputCsRoutineTables();
        }
}

void
OutputPlatformCheck( ISTREAM * pStream )
/*++

Routine Description :

    Outputs an ifdef checking if the platform usage is as expected

Arguments :

    pStream - Stream to output the format string to.

 --*/
{
    pStream->NewLine();
    if ( pCommand->GetEnv() == ENV_WIN64 )
        {
        pStream->Write( "#if !defined(__RPC_WIN64__)" );
        }
    else
        pStream->Write( "#if !defined(__RPC_WIN32__)" );

    pStream->NewLine();
    pStream->Write( "#error  Invalid build platform for this stub." );
    pStream->NewLine();
    pStream->Write( "#endif" );
    pStream->NewLine();
}

const char * Nt51Guard[] =
    {
    "#if !(TARGET_IS_NT51_OR_LATER)",
    "#error You need a Windows XP or later to run this stub because it uses these features:",
    0
    };

const char * Nt50Guard[] =
    {
    "",
    "#if !(TARGET_IS_NT50_OR_LATER)",
    "#error You need a Windows 2000 or later to run this stub because it uses these features:",
    0
    };

const char * Nt40Guard[] =
    {
    "",
    "#if !(TARGET_IS_NT40_OR_LATER)",
    "#error You need a Windows NT 4.0 or later to run this stub because it uses these features:",
    0
    };

const char * Nt351win95Guard[] =
    {
    "",
    "#if !(TARGET_IS_NT351_OR_WIN95_OR_LATER)",
    "#error You need a Windows NT 3.51 or Windows95 or later to run this stub because it uses these features:",
    0
    };

const char * NtGuardClose[] =
    {
    "#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.",
    "#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.",
    "#endif",
    0
    };

void
OutputMultilineMessage(
    ISTREAM *       pStream,
    const char *    Message[] )
{
    for (int i = 0; Message[i]; i++)
        {
        pStream->Write( Message[i] );
        pStream->NewLine();
        }
}

// should be local OutputVersion Guard but it can't.

class   MessageSet
{
private:
    char      * Messages[10];
    int         MessageCount;
    ISTREAM   * pStream;

public:
                MessageSet( ISTREAM * pIStream )
                    : MessageCount(0),
                      pStream( pIStream )
                    {
                    }

    void        AddMessage( char * Message )
                    {
                    if ( MessageCount < 10 )
                        Messages[ MessageCount++ ] = Message;
                    }

    void        PrintMessages()
                    {
                    pStream->Write( "#error   " );
                    for (int i = 0; i < MessageCount; i++ )
                        {
                        pStream->Write( Messages[i] );
                        pStream->Write( (i < MessageCount -1) ? ", "
                                                              : ".\n" );
                        }
                    }
};


void
OutputNdrVersionGuard( ISTREAM * pStream )
/*++

Routine Description :

    Outputs  target release guards.

Arguments :

    pStream  - Stream to output the format string to.

 --*/
{
    MessageSet          Features( pStream );
    NdrVersionControl & VC = pCommand->GetNdrVersionControl();

    if ( VC.HasNdr60Feature() )
        {
        OutputMultilineMessage( pStream, Nt51Guard );
        if ( VC.HasStructPadN() )
            Features.AddMessage( "large structure padding" );
        if ( VC.HasForceAllocate() )
            Features.AddMessage( "The [force_allocate] attribte" );
        if ( VC.HasPartialIgnore() )
            Features.AddMessage( "The [partial_ignore] attribute" );
        if ( VC.HasMultiTransferSyntax() )
            Features.AddMessage( "Uses -protocol all or -protocol ndr64" );
        }
    else if ( VC.HasNdr50Feature() )
        {
        OutputMultilineMessage( pStream, Nt50Guard );
        if ( VC.HasAsyncHandleRpc() )
            Features.AddMessage( "[async] attribute" );
        if ( VC.HasNT5VTableSize() )
            Features.AddMessage( "more than 110 methods in the interface" );
        if ( VC.HasDOA() )
            Features.AddMessage( "/robust command line switch" );
        if ( VC.HasAsyncUUID() )
            Features.AddMessage( "[async_uuid] attribute" );
        if ( VC.HasInterpretedNotify() )
            Features.AddMessage( "[notify] or [notify_flag] attribute in interpreted mode" );
        if ( VC.HasContextSerialization() )
            Features.AddMessage( "[serialize] or [noserialize] attribute" );
        if ( VC.HasOicfPickling() )
            Features.AddMessage( "[encode] or [decode] with -Oicf" );
        }
    else if ( VC.HasNdr20Feature() )
        {
        OutputMultilineMessage( pStream, Nt40Guard );
        if ( VC.HasOi2() )
            Features.AddMessage( "-Oif or -Oicf" );
        if ( VC.HasUserMarshal() )
            Features.AddMessage( "[wire_marshal] or [user_marshal] attribute" );
        if ( VC.HasRawPipes() )
            Features.AddMessage( "idl pipes" );
        if ( VC.HasMoreThan64DelegatedProcs() )
            Features.AddMessage( "more than 64 delegated procs" );
        if ( VC.HasFloatOrDoubleInOi() )
            Features.AddMessage( "float, double or hyper in -Oif or -Oicf" );
        if ( VC.HasMessageAttr() )
            Features.AddMessage( "[message] attribute" );
        if ( VC.HasNT4VTableSize() )
            Features.AddMessage( "more than 32 methods in the interface" );
        }
    else if ( VC.HasNdr11Feature() )
        {
        OutputMultilineMessage( pStream, Nt351win95Guard );
        if ( VC.HasStublessProxies() )
            Features.AddMessage( "old (-Oic) stubless proxies" );
        if ( VC.HasCommFaultStatusInOi12() )
            Features.AddMessage( "[comm_status] or [fault_status] in an -Oi* mode" );
        }
    else
        return;

    Features.PrintMessages();
    OutputMultilineMessage( pStream, NtGuardClose );

    pStream->NewLine();
}



void
CCB::OutputMultipleInterfaceTables()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the tables that may be common to multiple interfaces.

 Arguments:

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    CGSIDE  Side = GetCodeGenSide();

    // First, output the platform consistency check.
    
    OutputPlatformCheck( pStream );
    
    // Now, the ndr version guard against usage on old platforms.

    if ( pCommand->GetEnv() == ENV_WIN32 )
        OutputNdrVersionGuard( pStream );


    MIDL_ASSERT( pCommand->IsNDRRun() || pCommand->IsNDR64Run() );

    if ( pCommand->IsNDRRun() )
        {
        
        if ( pCommand->IsNDRRun() )    
            GetProcFormatString()->Output( pStream,
                                       PROC_FORMAT_STRING_TYPE_NAME,
                                       PROC_FORMAT_STRING_STRUCT_NAME,
                                       GetRepAsPadExprDict(),
                                       GetRepAsSizeDict() );
        
        FixupRecPointers();
        
        GetFormatString()->Output( pStream,
                               FORMAT_STRING_TYPE_NAME,
                               FORMAT_STRING_STRUCT_NAME,
                               GetRepAsPadExprDict(),
                               GetRepAsSizeDict() );

        }
     else 
         {

         // If this is the 64bit transfer syntax run, then the proc and type format strings 
         // should be NULL.
         MIDL_ASSERT(  NULL == GetProcFormatString() );
         MIDL_ASSERT(  NULL == GetFormatString() );

         GetNdr64Format()->Output();

         }

        if ( HasQuadrupleRoutines() )
            {
            //
            // Emit the user_marshall table on both sides.
            //
            OutputQuadrupleTable();
            }
    //
    // Emit the rundown routine table on the server side, if needed.
    //
    SetNoOutputIn2ndCodegen( this );

    if ( (Side == CGSIDE_SERVER) &&
        (GetOptimOption() & OPTIMIZE_INTERPRETER) &&
        HasRundownRoutines()
        )
        {
        OutputRundownRoutineTable();
        }

    //
    // Emit the binding routine pair table on the client interpreted stub
    // if needed.
    //
    if ( (Side == CGSIDE_CLIENT) &&
        GetInterpretedRoutinesUseGenHandle() )
        {
        OutputBindingRoutines();
        }

    if ( HasExprEvalRoutines() )
        {
        //
        // Emit the expr eval routines both sides.
        //
        OutputRegisteredExprEvalRoutines();

        //
        // Emit the expr eval routine table on both sides.
        //
        OutputExprEvalRoutineTable();
        }

    if ( HasExprFormatString() )
        {
        OutputExpressionFormatString();
        }

    if ( HasQuintupleRoutines() )
        {
        //
        // Emit transmit as and represent as routines both sides.
        //
        OutputQuintupleRoutines();

        //
        // Emit the xmit as and rep as routine table on both sides.
        //
        OutputQuintupleTable();
        }


    if ( GetMallocAndFreeStructExternEmitted() )
        {
        // This is needed for the RpcSs support.

        OutputMallocAndFreeStruct();
        }

    ResetNoOutputIn2ndCodegen( this );
}

long
CCB_RTN_INDEX_MGR::Lookup( char * pName )
{
    long    i;

    for ( i = 1; i < NextIndex; i++ )
        if ( ! strcmp(NameId[i],pName) )
            return i;

    //
    // Insert a new entry
    //

    MIDL_ASSERT( NextIndex < MGR_INDEX_TABLE_SIZE );

    NameId[NextIndex] = new char[strlen(pName) + 1];
    strcpy(NameId[NextIndex],pName);
    NextIndex++;

    return NextIndex - 1;
}

char *
CCB_RTN_INDEX_MGR::Lookup( long Index )
{
    if ( Index >= NextIndex )
        return NULL;

    return NameId[Index];
}

long
CCB_EXPR_INDEX_MGR::Lookup( char * pName )
{
    long    i;

    for ( i = 1; i < NextIndex; i++ )
        if ( ! strcmp(NameId[i],pName) )
            return i;

    //
    // Insert a new entry
    //

    MIDL_ASSERT( NextIndex < MGR_INDEX_TABLE_SIZE );

    NameId[NextIndex] = new char[strlen(pName) + 1];
    strcpy(NameId[NextIndex],pName);
    NextIndex++;

    return NextIndex - 1;
}

char *
CCB_EXPR_INDEX_MGR::Lookup( long Index )
{
    if ( Index >= NextIndex )
        return NULL;

    return NameId[Index];
}



PNAME
CCB::GenTRNameOffLastParam( char * pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the name for a temporary resource.

 Arguments:

    pPrefix - A null terminated prefix string. If this is null, nothing is
              added.

 Return Value:

    A freshly allocated resource name string.

 Notes:

----------------------------------------------------------------------------*/
{
    char TempBuffer[ 30 ];

    sprintf( TempBuffer,
        "_%sM",
        pPrefix ? pPrefix : ""
        );

    PNAME   pName   = (PNAME) new char [ strlen(TempBuffer) + 1 ];
    strcpy( pName, TempBuffer );
    return pName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\cgcls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	cgcls.cxx

 Abstract:

	Routines for the cgcls code generation class.

 Notes:


 History:

	Aug-31-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

short
CG_CLASS::GetMembers(
	ITERATOR&	I )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	GetMembers (list of child+its siblings) of the code generation class.

 Arguments:

 	I	- An iterator for the member list.
	
 Return Value:

 	Count of number of members.
	
 Notes:

----------------------------------------------------------------------------*/
{
	CG_CLASS	*	pC;
	short			Count = 0;

	if( ( pC = GetChild() ) != 0 )
		{
		ITERATOR_INSERT( I, pC );

		Count++;
		while( ( pC = pC->GetSibling() ) != 0 )
			{
			ITERATOR_INSERT( I, pC );
			Count++;
			}
		}

	return Count;
}

CG_CLASS *
CG_CLASS::GetLastSibling()
	{
	CG_CLASS * pLast = this;
	CG_CLASS * pS;

	while ( ( pS = pLast->GetSibling() ) != 0 )
		 pLast = pS;
	return pLast;
	}

// Set the member list on a class

void CG_CLASS::SetMembers( ITERATOR & I )
{
    CG_CLASS *pHead = NULL;
    ITERATOR_INIT( I );
    ITERATOR_GETNEXT( I, pHead );

    if (pHead)
        {

        CG_CLASS *pCurrent = pHead;
        CG_CLASS *pNext = NULL;
       
        while( ITERATOR_GETNEXT( I, pNext ) )
		    {
            pCurrent->SetSibling( pNext );
            pCurrent = pNext;
            }
        pCurrent->SetSibling( NULL );

        }

    SetChild( pHead );
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\frmtreg.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:
    
    frmtreg.cxx

 Abstract:

    Registry for format string reuse.

 Notes:

     This file defines reuse registry for format string fragments which may
     be reused later. 

 History:

     Mar-14-1993        GregJen        Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *    include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

/***********************************************************************
 * global data
 **********************************************************************/


FRMTREG_DICT::FRMTREG_DICT( FORMAT_STRING * pOurs)
        : Dictionary()
    {
    pOurFormatString = pOurs;
    }

SSIZE_T
FRMTREG_DICT::Compare( pUserType pL, pUserType pR )
    {

     FRMTREG_ENTRY *  pLeft  = (FRMTREG_ENTRY *) pL;
     FRMTREG_ENTRY *  pRight = (FRMTREG_ENTRY *) pR;

    // first, sort by string length

    int  Result = ( pLeft->EndOffset - pLeft->StartOffset ) -
                   ( pRight->EndOffset - pRight->StartOffset );

    if ( Result )
        return Result;

    long   LeftOffset   = pLeft->StartOffset;
    long   RightOffset  = pRight->StartOffset;

    unsigned char * pBuffer     = pOurFormatString->pBuffer;
    unsigned char * pBufferType = pOurFormatString->pBufferType;

    // the same format string is, of course identical
    if ( LeftOffset == RightOffset )
        return 0;

    // There is a tricky situation when the strings are apart by more than 32k.
    // In the proc format string there is no problem with that, we can optize.
    // With type format string, we optimize as this is our best bet for the
    // final accessability of fragments.

    // Sort by values of format characters

    while ( ( Result == 0 ) && ( LeftOffset < pLeft->EndOffset) )
        {

        if ( pBufferType[ LeftOffset ] != pBufferType[ RightOffset ] )
            {
            // Types don't match, force the result to be unequal.
            Result = pBufferType[ LeftOffset ] - pBufferType[ RightOffset ];
            continue;
            }

        switch ( pBufferType[ LeftOffset ] )
            {
            case FS_SHORT_TYPE_OFFSET:
                // This is a comparison for the absolute type offset.
                {
                    TypeOffsetDictElem  *pLeftTO, *pRightTO;
        
                    pLeftTO  = pOurFormatString->TypeOffsetDict.
                                                   LookupOffset( LeftOffset );
                    pRightTO = pOurFormatString->TypeOffsetDict.
                                                   LookupOffset( RightOffset );

                    Result = pLeftTO->TypeOffset - pRightTO->TypeOffset;

                    LeftOffset++; RightOffset++;
                }
                break;

            case FS_SHORT_OFFSET:
                // This is a comparison for the relative type offset.
                //
                {
                    TypeOffsetDictElem  *pLeftTO, *pRightTO;
        
                    pLeftTO  = pOurFormatString->TypeOffsetDict.
                                                   LookupOffset( LeftOffset );
                    pRightTO = pOurFormatString->TypeOffsetDict.
                                                   LookupOffset( RightOffset );

                    if ( ( pLeftTO->TypeOffset == 0 ) && 
                         ( pRightTO->TypeOffset == 0 ) )
                        Result = 0;
                    else
                        // compare absolute offsets
                        Result = ( LeftOffset + pLeftTO->TypeOffset ) -
                                 ( RightOffset + pRightTO->TypeOffset );
        
                    LeftOffset++; RightOffset++;
                }
                break;

            case FS_SHORT_STACK_OFFSET:
                // Compare stack offset - multiplatform issue.
                {
                    Result = *((short UNALIGNED *)(pBuffer + LeftOffset)) -
                             *((short UNALIGNED *)(pBuffer + RightOffset));
        
                    if ( Result == 0 )
                        {
                        BOOL f32bitServer = pCommand->Is32BitEnv();
        
                        if ( f32bitServer )
                            {
                            OffsetDictElem  *pLeftStackOffsets, *pRightStackOffsets;
        
                            pLeftStackOffsets  = pOurFormatString->OffsetDict.
                                                   LookupOffset( LeftOffset );
                            pRightStackOffsets = pOurFormatString->OffsetDict.
                                                   LookupOffset( RightOffset );
        
                            long Ilo = pLeftStackOffsets->X86Offset;
                            long Iro = pRightStackOffsets->X86Offset;
                            Result = Ilo - Iro;
                            }
                        }
        
                    LeftOffset++; RightOffset++;
                }
                break;

            case FS_PAD_MACRO:
            case FS_SIZE_MACRO:
            case FS_UNKNOWN_STACK_SIZE:
                // Can't compare those, so force the result to be unequal.
                //
                Result = LeftOffset - RightOffset;
                break;

            case FS_LONG:
                // Compare longs
                //
                Result = *((long UNALIGNED *)(pBuffer + LeftOffset)) -
                         *((long UNALIGNED *)(pBuffer + RightOffset));
        
                LeftOffset += 3; RightOffset += 3;
                break;

            case FS_SHORT:
            case FS_PARAM_FLAG_SHORT:
            case FS_MAGIC_UNION_SHORT:
            case FS_CORR_FLAG_SHORT:
                // Compare plain shorts.
                //
                Result = *((short UNALIGNED *)(pBuffer + LeftOffset)) -
                         *((short UNALIGNED *)(pBuffer + RightOffset));
        
                LeftOffset++; RightOffset++;
                break;

            case FS_FORMAT_CHARACTER:
            case FS_POINTER_FORMAT_CHARACTER:
            case FS_SMALL:
            case FS_SMALL_STACK_SIZE:
            case FS_OLD_PROC_FLAG_BYTE:
            case FS_Oi2_PROC_FLAG_BYTE:
            case FS_EXT_PROC_FLAG_BYTE:
            case FS_CORR_TYPE_BYTE:
            case FS_CONTEXT_HANDLE_FLAG_BYTE:
            default:
                // Compare bytes, format chars, bytes decorated for comments,
                //
                Result = pBuffer[ LeftOffset ] - pBuffer[ RightOffset ];
                break;
            }

        LeftOffset++; RightOffset++;
        }

    return Result;
    }


FRMTREG_ENTRY *
FRMTREG_DICT::IsRegistered(
    FRMTREG_ENTRY    *    pInfo )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Search for a type with the reuse registry.

 Arguments:

     pInfo    - A pointer to the type being registered.
    
 Return Value:

     The node that gets registered.
    
 Notes:

----------------------------------------------------------------------------*/
{
    Dict_Status    Status    = Dict_Find( pInfo );

    switch( Status )
        {
        case EMPTY_DICTIONARY:
        case ITEM_NOT_FOUND:
            return (FRMTREG_ENTRY *)0;
        default:
            return (FRMTREG_ENTRY *)Dict_Curr_Item();
        }
}

FRMTREG_ENTRY *
FRMTREG_DICT::Register(
    FRMTREG_ENTRY    *    pInfo )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Register a type with the dictionary.

 Arguments:
    
     pType    - A pointer to the type node.

 Return Value:

     The final inserted type.
    
 Notes:

----------------------------------------------------------------------------*/
{
        Dict_Insert( (pUserType) pInfo );
        return pInfo;
}

BOOL                
FRMTREG_DICT::GetReUseEntry( 
    FRMTREG_ENTRY * & pOut, 
    FRMTREG_ENTRY * pIn )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Register a type with the dictionary.

 Arguments:
    
     pRI      - A pointer to the returned FRMTREG_ENTRY block
     pNode    - A pointer to the type node.

 Return Value:

     True if the entry was already in the table,
     False if the entry is new.
    
 Notes:

----------------------------------------------------------------------------*/
{
    FRMTREG_ENTRY    *    pRealEntry;

    if ( ( pRealEntry = IsRegistered( pIn ) ) == 0 )
        {
        pRealEntry = new FRMTREG_ENTRY( pIn->StartOffset, pIn->EndOffset );
        Register( pRealEntry );
        pOut = pRealEntry;
        return FALSE;
        }

    pOut = pRealEntry;
    pOut->UseCount++;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\cgmain.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	cgmain.cxx

 Abstract:

	The main entry point for the code generator.

 Notes:


 History:

	VibhasC		Aug-13-1993		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"

#pragma hdrstop

#include "control.hxx"
#include "ilreg.hxx"

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/

extern node_interface	*	pBaseInterfaceNode;
extern CMD_ARG			*	pCommand;
extern ccontrol			*	pCompiler;

extern CG_CLASS			*	Transform( node_skl * pIL );
extern	void				print_memstats();

/****************************************************************************/



void
CGMain(
	node_skl	*	pNode )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	The main code generator entry point.

 Arguments:
	
	pNode	- A pointer to the type graph source node.

 Return Value:

 	Code generation status.
	
 Notes:

----------------------------------------------------------------------------*/
{
	CG_CLASS		*	pCGSource;

	//
	// Transform the type graph into the Code generation IL.
	//

    pCompiler->SetPassNumber( ILXLAT_PASS );

	pCGSource		= Transform( pNode );


#ifdef MIDL_INTERNAL
	printf("ILxlate done\n");
	if(pCommand->IsSwitchDefined( SWITCH_DUMP ) )
		{
		print_memstats();
		};
#endif // MIDL_INTERNAL

	//
	// This is temporary initialization code. The final code may differ.
	//

	
	CCB					CCB( DEFAULT_GB_RTN_NAME,
							 DEFAULT_SR_RTN_NAME,
							 DEFAULT_FB_RTN_NAME,
							 pCommand->GetOptimizationFlags(),
							 pCommand->IsSwitchDefined( SWITCH_USE_EPV ),
							 pCommand->IsSwitchDefined( SWITCH_NO_DEFAULT_EPV ),
							 pCommand->IsSwitchDefined( SWITCH_OLDNAMES ),
							 pCommand->IsSwitchDefined( SWITCH_MS_EXT ) ? 1 : 0,
							 pCommand->IsRpcSSAllocateEnabled(),
							 ((pCommand->GetErrorOption() & ERROR_ALLOCATION) == ERROR_ALLOCATION),
							 ((pCommand->GetErrorOption() & ERROR_REF) == ERROR_REF),
							 ((pCommand->GetErrorOption() & ERROR_ENUM) == ERROR_ENUM),
							 ((pCommand->GetErrorOption() & ERROR_BOUNDS_CHECK) == ERROR_BOUNDS_CHECK),
							 ((pCommand->GetErrorOption() & ERROR_STUB_DATA) == ERROR_STUB_DATA)
						  );

	//
	// Do the code generation.
	//

#ifdef MIDL_INTERNAL
	if( pCommand->IsSwitchDefined( SWITCH_DUMP ) )
		{
		printf("dumping IL\n");
		pCGSource->Dump(0);
		}
#endif // MIDL_INTERNAL



	pCompiler->SetPassNumber( CODEGEN_PASS );


// define NO_CODEGEN to stop after IL translation
#ifndef NO_CODEGEN
	pCGSource->GenCode( &CCB );
#endif



}

CG_CLASS* ILSecondGenTransform( CG_CLASS *pClass );

void
Ndr64CGMain(
	node_skl	*	pNode )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	The main code generator entry point.

 Arguments:
	
	pNode	- A pointer to the type graph source node.

 Return Value:

 	Code generation status.
	
 Notes:

----------------------------------------------------------------------------*/
{
	CG_CLASS		*	pCGSource;

	//
	// Transform the type graph into the Code generation IL.
	//

    pCompiler->SetPassNumber( NDR64_ILXLAT_PASS );

	pCGSource		= Transform( pNode );


#ifdef MIDL_INTERNAL
	printf("\nStage1 of ILxlate done\n");
	if(pCommand->IsSwitchDefined( SWITCH_DUMP ) )
		{
        printf("\n");
        printf("dumping stage 1 IL\n");
        pCGSource->Dump();
		};
#endif // MIDL_INTERNAL

    pCGSource = ILSecondGenTransform( pCGSource );

#ifdef MIDL_INTERNAL
	printf("\nStage2 of ILxlate done\n");
	if(pCommand->IsSwitchDefined( SWITCH_DUMP ) )
		{
        printf("\n");
        printf("dumping stage 2 IL\n");
        pCGSource->Dump();
		};
#endif // MIDL_INTERNAL
	//
	// This is temporary initialization code. The final code may differ.
	//

	
	CCB					CCB( DEFAULT_GB_RTN_NAME,
							 DEFAULT_SR_RTN_NAME,
							 DEFAULT_FB_RTN_NAME,
							 pCommand->GetOptimizationFlags(),
							 pCommand->IsSwitchDefined( SWITCH_USE_EPV ),
							 pCommand->IsSwitchDefined( SWITCH_NO_DEFAULT_EPV ),
							 pCommand->IsSwitchDefined( SWITCH_OLDNAMES ),
							 pCommand->IsSwitchDefined( SWITCH_MS_EXT ) ? 1 : 0,
							 pCommand->IsRpcSSAllocateEnabled(),
							 ((pCommand->GetErrorOption() & ERROR_ALLOCATION) == ERROR_ALLOCATION),
							 ((pCommand->GetErrorOption() & ERROR_REF) == ERROR_REF),
							 ((pCommand->GetErrorOption() & ERROR_ENUM) == ERROR_ENUM),
							 ((pCommand->GetErrorOption() & ERROR_BOUNDS_CHECK) == ERROR_BOUNDS_CHECK),
							 ((pCommand->GetErrorOption() & ERROR_STUB_DATA) == ERROR_STUB_DATA)
						  );

	//
	// Do the code generation.
	//

	pCompiler->SetPassNumber( NDR64_CODEGEN_PASS );


// define NO_CODEGEN to stop after IL translation
#ifndef NO_CODEGEN
	pCGSource->GenCode( &CCB );
#endif



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\dtable.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	dtable.cxx

 Abstract:

	Dispatch table class implementation.

 Notes:


 History:

 	Oct-01-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

void
DISPATCH_TABLE::RegisterProcedure(
	node_skl			*	pProc,
	DISPATCH_TABLE_FLAGS	Flags )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Register a procedure into the dispatch table.

 Arguments:

 	pProc		-	The procedure node to be registered.
 	Flags		-	Additional information flags.
	
 Return Value:
	
 	None.

 Notes:

    if the flags field indicates a pure interpreter procedure, then
    the node pointer is really a pointer to a name, and not a node_skl

----------------------------------------------------------------------------*/
{
	PNAME						pProcName;
	node_skl                *   pN          = pProc;
	DISPATCH_TABLE_ENTRY	*	pDEntry;

	pProcName = pProc->GetSymName();
	pN = pProc;

	//
	// Allocate a dispatch table entry.
	//

	pDEntry	= new DISPATCH_TABLE_ENTRY;

	pDEntry->pName	= pProcName;
	pDEntry->Flags	= Flags;
	pDEntry->pNode	= pN;

	AddElement( (IDICTELEMENT) pDEntry );

}

DISPATCH_TABLE::~DISPATCH_TABLE()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	The destructor.

 Arguments:
	
 	None.

 Return Value:
	
	NA.

 Notes:

----------------------------------------------------------------------------*/
{
	short						i		= 0;
	short						Count	= GetNumberOfElements();
	DISPATCH_TABLE_ENTRY	*	pDEntry;

	//
	// remove the dispatch table entries. The procedure name is NOT
	// owned by the dipatch table, DO NOT delete it. Just delete the
	// dispatch table entry.
	//

	for( i = 0; i < Count; ++i )
		{
		pDEntry	= (DISPATCH_TABLE_ENTRY *)GetElement( (IDICTKEY)i );
		delete pDEntry;
		}
	
}

unsigned short
DISPATCH_TABLE::GetProcList(
	ITERATOR&				DTableEntryList,
	DISPATCH_TABLE_FLAGS	Flags )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Return a list of all procedures which conform to the specified dispatch
 	table flags.

 Arguments:
	
	DTableEntryList	- A pre-allocated iterator for receiving the list of
                      dispatch table entries.
	Flags		    - flags which determine what entries will be picked up.

 Return Value:
	
	A count of the number of procedures in the list.

 Notes:

 	The flags field is a filter for the dispatch table entries. Only those
 	dispatch table entries which have conforming properties are returned in 
 	the list.
    There are 2 types of entries:
      normal (call with DTF_NONE) and interpreter (call with DTF_INTERPRETER).
    The way it works is that 
    - call with DTF_NONE        returns DTF_NONEs        or DTF_PICKLING_PROCs
    - call with DTF_INTERPRETER returns DTF_INTERPRETERs or DTF_PICKLING_PROCs

----------------------------------------------------------------------------*/
{

	short						ListCount,
								i,
								Count;

	DISPATCH_TABLE_ENTRY	*	pDEntry;

	for( ListCount = 0, i = 0, Count = GetNumberOfElements();
		 i < Count;
		 ++i
	   )
	   	{
	   	pDEntry	= (DISPATCH_TABLE_ENTRY *)GetElement( (IDICTKEY)i );
	   	if( (pDEntry->Flags & Flags ) == Flags )
	   		{
	   		ITERATOR_INSERT( DTableEntryList, pDEntry );
	   		ListCount++;
	   		}
	   }

	return ListCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\filecls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    filecls.hxx

 Abstract:

    Code generation methods for file cg classes.

 Notes:


 History:

    Sep-01-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4238 4239 )

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *  local definitions
 ***************************************************************************/

/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
extern CMD_ARG * pCommand;
char* GetRpcNdrHVersionGuard( char* );
char* GetRpcProxyHVersionGuard( char* );

extern BOOL                     IsTempName( char * );


/****************************************************************************/

void
CG_FILE::EmitFileHeadingBlock(
    CCB *   pCCB,
    char *  CommentStr,
    char *  CommentStr2,
    bool    fDualFile )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit double platform ifdef as needed and the opening comment to the file.

 Arguments:

    pCCB        - a pointer to the code generation control block.
    CommentStr  - a comment customizing the file.
    CommentStr2 - optional comment used in *_i.c
    fDualFile   - true for client stub, server stub and froxy file
                  false for the header file

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();

        // A guard for double, i.e. 32b-64b, files.

    pStream->NewLine();
    pStream->Write( "#pragma warning( disable: 4049 )  /* more than 64k source lines */");

    // Comment customizing the file.

    pStream->NewLine(2);
    pStream->Write( "/* this ALWAYS GENERATED file contains " );
    pStream->Write( CommentStr );
    pStream->Write( " */" );
    pStream->NewLine(2);
    if ( CommentStr2 )
        {
        pStream->Write( "/* " );
        pStream->Write( CommentStr2 );
        pStream->Write( " */" );
        pStream->NewLine(2);
        }

    EmitStandardHeadingBlock( pCCB );

    if ( fDualFile )
        {
        pStream->NewLine();
        if ( pCommand->Is64BitEnv() )
            pStream->Write( "#if defined(_M_IA64) || defined(_M_AMD64)" );
        else if ( pCommand->Is32BitEnv() )
            {
            pStream->Write( "#if !defined(_M_IA64) && !defined(_M_AMD64)" );
            }
        }
}

void
CG_FILE::EmitFileClosingBlock(
    CCB *   pCCB,
    bool    fDualFile )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit an endif matching the one emitted in EmitFileHeadingBlock

 Arguments:

    pCCB        - a pointer to the code generation control block.
    CommentStr  - a comment customizing the file.
    fDualFile   - true for client stub, server stub and froxy file
                  false for the header file

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();

    if ( fDualFile )
        {
        pStream->NewLine(2);
        if ( pCommand->Is64BitEnv() )
            pStream->Write( "#endif /* defined(_M_IA64) || defined(_M_AMD64)*/" );
        else if ( pCommand->Is32BitEnv() )
            {
            pStream->Write( "#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/" );
            }
        }

    pStream->NewLine(2);
}

void
CG_FILE::EmitStandardHeadingBlock(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit standard block comment file heading portion.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();

    pStream->NewLine();

    pStream->Write(" /* File created by MIDL compiler version ");
    pStream->Write( pCommand->GetCompilerVersion() );
    pStream->Write(" */");

    pStream->NewLine();

    if ( !pCommand->IsSwitchDefined( SWITCH_NO_STAMP ) )
        {
        pStream->Write("/* at ");
        pStream->Write( pCommand->GetCompileTime() );
        pStream->Write(" */");
        pStream->NewLine();
        }

    // Emit command line switches information.

    pCommand->EmitConfirm( pStream );

    // Write this remnant of the reparsing scheme for our testers.
    pStream->Write( "//@@MIDL_FILE_HEADING(  )" );

    pStream->NewLine();

}

void
CG_FILE::Out_TransferSyntaxDefs(
    CCB     * pCCB )
{
    ISTREAM *pStream = pCCB->GetStream();

    // NDR transfer syntax id is needed for
    if ( pCommand->NeedsNDRRun() )
        {
        // BUGBUG: transfer syntax guids should be in rpcrt4.lib or something
        pStream->WriteOnNewLine("static " TRANSFER_SYNTAX_TYPE_NAME "  ");
        pStream->Write( NDR_TRANSFER_SYNTAX_VAR_NAME );
        pStream->Write( " = ");
        pStream->NewLine();
        Out_TransferSyntax( pCCB,
                            TransferSyntaxGuidStrs,
                            NDR_UUID_MAJOR_VERSION,
                            NDR_UUID_MINOR_VERSION );
        pStream->Write( ';' );
        pStream->NewLine();

        }

    if ( pCommand->NeedsNDR64Run() )
        {
        pStream->WriteOnNewLine("static  " TRANSFER_SYNTAX_TYPE_NAME "  ");
        pStream->Write( NDR64_TRANSFER_SYNTAX_VAR_NAME );
        pStream->Write( " = ");
        pStream->NewLine();
        if ( pCommand->IsSwitchDefined( SWITCH_INTERNAL ) &&
             pCommand->GetEnv() == ENV_WIN32 )
            Out_TransferSyntax( pCCB,
                        FakeNDR64TransferSyntaxGuidStrs,
                        NDR64_UUID_MAJOR_VERSION,
                        NDR64_UUID_MINOR_VERSION );
        else
            Out_TransferSyntax( pCCB,
                            NDR64TransferSyntaxGuidStrs,
                            NDR64_UUID_MAJOR_VERSION,
                            NDR64_UUID_MINOR_VERSION );
        pStream->Write( ';' );
        pStream->NewLine();

        }

}


void
CG_FILE::EmitFormatStringTypedefs(
    CCB      *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit dummy #defines with sizes for the format string structs,
    then emit typedefs for the type and proc format string structs.
    Sets the context position in the file node for later use.
    Additional tables serviced here:
        transmit_as,     element is a quad
        wire_marshal     element is a quad

 Arguments:

    pCCB        - a pointer to the code generation control block.

 Notes:

    The typedefs are going to be fixed later by a call to
    EmitFixupToFormatStringTypedefs. This is needed for ANSI.
    The dummies would work for ANSI non-compliant code.

--------------------------------------------------------------------------*/
{
    ISTREAM  *  pStream    = pCCB->GetStream();

    // we'll only generate this once in the first run.
    if ( pCommand->Is2ndCodegenRun() )
        return;

    pStream->NewLine(2);
    if ( pCommand->NeedsNDRRun() )
        {
        pStream->Write( "#define TYPE_FORMAT_STRING_SIZE   " );
        SetOptionalTableSizePosition( TypeFormatStringSizePosition,
                                  pStream->GetCurrentPosition() );
        pStream->Write( "                                  " );
        pStream->NewLine();

        pStream->Write( "#define PROC_FORMAT_STRING_SIZE   " );
        SetOptionalTableSizePosition( ProcFormatStringSizePosition,
                                  pStream->GetCurrentPosition() );
        pStream->Write( "                                  " );

        pStream->NewLine();
        }


    pStream->Write( "#define " TRANSMIT_AS_TABLE_SIZE "    " );
    SetOptionalTableSizePosition( TransmitAsSizePosition,
                                  pStream->GetCurrentPosition() );
    pStream->Write( "             " );
    pStream->NewLine();

    pStream->Write( "#define " WIRE_MARSHAL_TABLE_SIZE "   " );
    SetOptionalTableSizePosition( WireMarshalSizePosition,
                                  pStream->GetCurrentPosition() );
    pStream->Write( "             " );
    pStream->NewLine();

    if ( pCommand->NeedsNDRRun() )
        {
        pStream->NewLine();

        pStream->Write( "typedef struct _" FORMAT_STRING_TYPE_NAME );
        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write( "{" );
        pStream->NewLine();
        pStream->Write( "short          Pad;" );
        pStream->NewLine();
        pStream->Write( "unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];" );
        pStream->NewLine();
        pStream->Write( "} " FORMAT_STRING_TYPE_NAME ";" );
        pStream->IndentDec();
        pStream->NewLine(2);

        pStream->Write( "typedef struct _" PROC_FORMAT_STRING_TYPE_NAME );
        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write( "{" );
        pStream->NewLine();
        pStream->Write( "short          Pad;" );
        pStream->NewLine();
        pStream->Write( "unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];" );
        pStream->NewLine();
        pStream->Write( "} " PROC_FORMAT_STRING_TYPE_NAME ";" );
        pStream->IndentDec();
        pStream->NewLine(2);
        }

}

void
CG_FILE::EmitFixupToFormatStringTypedefs(
    CCB      *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Fixes he dummy #defines emitted by EmitFormatStringTypedefs.

 Arguments:

    pCCB        - a pointer to the code generation control block.
    pContext    - a pointer to the position context

--------------------------------------------------------------------------*/
{
    char        Buffer[20];
    ISTREAM  *  pStream = pCCB->GetStream();
    long        EofPosition;

    EofPosition = pStream->GetCurrentPosition();

    if ( !pCommand->Is2ndCodegenRun() )
        {
        pStream->SetCurrentPosition(
                GetOptionalTableSizePosition( TransmitAsSizePosition ) );
        sprintf( Buffer, "%d", pCCB->GetQuintupleDictionary()->GetCount() );
        pStream->Write( Buffer );

        pStream->SetCurrentPosition(
                GetOptionalTableSizePosition( WireMarshalSizePosition ) );
        sprintf( Buffer, "%d", pCCB->GetQuadrupleDictionary()->GetCount() );
        pStream->Write( Buffer );
        }

    if ( pCommand->IsNDRRun() )
        {
        pStream->SetCurrentPosition(
            GetOptionalTableSizePosition( TypeFormatStringSizePosition ) );
        sprintf( Buffer, "%d",  pCCB->GetFormatString()->GetCurrentOffset() + 1);
        pStream->Write( Buffer );

        pStream->SetCurrentPosition(
            GetOptionalTableSizePosition( ProcFormatStringSizePosition ) );
        sprintf( Buffer, "%d",  pCCB->GetProcFormatString()->GetCurrentOffset() + 1);
        pStream->Write( Buffer );
#ifdef     PRINT_METRICS
            printf  (
                    "Format string sizes %16d, %16d, %s\n",
                    pCCB->GetFormatString()->GetCurrentOffset() + 1,
                    pCCB->GetProcFormatString()->GetCurrentOffset() + 1,
                    GetFileName()
                    );
#endif

        }

    pStream->SetCurrentPosition( EofPosition );
}


void
CG_FILE::EmitOptionalClientTableSizeTypedefs(
    CCB  *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit dummy #defines with sizes for the optional tables:
        generic handles, element is a pair
    Tables serviced in the EmitFormStringtypedefs routine:
        transmit_as
        wire_marshal

 Arguments:

    pCCB        - a pointer to the code generation control block.

 Notes:

    The typedefs are going to be fixed later by a call to
    EmitFixupToOptionalTableSizeTypedefs. This is needed for ANSI.
    Note that we have the following tables that are not affected
    by the ANSI issue because element is not a struct:
        context rundown routine table
        expression evaluation table
        notify table

--------------------------------------------------------------------------*/
{
    ISTREAM  *  pStream    = pCCB->GetStream();

    pStream->NewLine(2);

    pStream->Write( "#define " GENERIC_BINDING_TABLE_SIZE "   " );
    SetOptionalTableSizePosition( GenericHandleSizePosition,
                                  pStream->GetCurrentPosition() );
    pStream->Write( "             " );
    pStream->NewLine();

}

void
CG_FILE::EmitFixupToOptionalClientTableSizeTypedefs(
    CCB  *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit dummy #defines with sizes for the optional tables:
        generic handles,

 Arguments:

    pCCB        - a pointer to the code generation control block.

 Notes:

    The typedefs are going to be fixed later by a call to
    EmitFixupOptionalTableSizeTpedefs. This is needed for ANSI.

--------------------------------------------------------------------------*/
{
    char        Buffer[20];
    ISTREAM  *  pStream = pCCB->GetStream();

    long EofPosition = pStream->GetCurrentPosition();

    pStream->SetCurrentPosition(
                GetOptionalTableSizePosition( GenericHandleSizePosition ) );
    sprintf( Buffer, "%d",  pCCB->GetGenericIndexMgr()->GetIndex() - 1 );
    pStream->Write( Buffer );

    pStream->SetCurrentPosition( EofPosition );
}

CG_STATUS
CG_SOURCE::GenCode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the source node.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR I;
    CG_FILE *   pCG;

    //
    // for all files nodes in this interface, generate code.
    //

    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pCG->GenCode( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_CSTUB_FILE::GenCode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    CG_NDR          *   pCG;
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];


    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    ISTREAM     Stream( GetFileName(), 4 );
    ISTREAM *   pStream     = &Stream;

    pCCB->SetStream( pStream, this );

    // Set HasStublessProxies and HasOi2 for each interface.

    EvaluateVersionControl();

    EmitFileHeadingBlock( pCCB, "the RPC client stubs" );

    SetNoOutputIn2ndCodegen( pCCB );

    // Emit the hash includes.

    Out_IncludeOfFile( pCCB, STRING_H_INC_FILE_NAME, TRUE );
    pStream->NewLine();

    // rpcssm puts a reference to malloc and free in the stub_c.c.
    // So, we have to emit the appropriate include.
    // In ms_ext when explicit, in osf always, to cover some weird cases.

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( ( ((CG_INTERFACE *)pCG)->GetUsesRpcSS() || (pCCB->GetMode() == 0) ))
            {
            Out_IncludeOfFile( pCCB, "malloc.h", TRUE );
            break;
            }
        }

    _splitpath( GetHeaderFileName(), Drive, Path, Name, Ext );
    strcpy( Buffer, Name );
    strcat( Buffer, Ext );
    Out_IncludeOfFile( pCCB, Buffer, FALSE );
    EmitFormatStringTypedefs( pCCB );


    Out_TransferSyntaxDefs( pCCB );

    //
    // Emit the external variables needed.
    //

    pStream->NewLine();

    //
    // Emit the format string extern declarations.
    //

    Out_FormatInfoExtern( pCCB );
    Out_TypeFormatStringExtern( pCCB );
    Out_ProcFormatStringExtern( pCCB );

    EmitOptionalClientTableSizeTypedefs( pCCB );
    pCCB->ClearOptionalExternFlags();

    pCCB->SetFileCG(this);

    MIDL_ASSERT( pCommand->IsNDR64Run() || pCommand->IsNDRRun() );

    if ( pCommand->IsNDR64Run() )
        {
        pCCB->SetFormatString( NULL );
        pCCB->SetProcFormatString( NULL );
        pCCB->SetNdr64Format( GenNdr64Format::CreateInstance( pCCB ) );
        }

    else
        {
        //
        // Create a new format string object if it does not yet exist.
        //
        if ( !pCCB->GetFormatString() )
        {
            pCCB->SetFormatString( new FORMAT_STRING() );

            // push a dummy short 0 at the beginning. This disambiguates
            // the case where offset 0 means recursion and a valid offset

            // always push the 0 at the beginning, otherwise we'll av in
            // some idl files (contain VARIANT for example) if -internal
            // is specified.
//            if ( !pCommand->IsSwitchDefined( SWITCH_INTERNAL ) )
//                {
                pCCB->GetFormatString()->PushShort( ( short ) 0 );
//                }
        }

        if ( !pCCB->GetProcFormatString() )
        {
            pCCB->SetProcFormatString( new FORMAT_STRING() );
        }
        }

    //
    // for all interfaces in this file, generate format info.
    //

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
                ((CG_INTERFACE *)pCG)->OutputInterfaceIdComment( pCCB );
                ((CG_INTERFACE *)pCG)->GenClientInfo( pCCB );
                break;
            }
        }

    //
    // Output the tables that may be common to several interfaces.
    //
    EmitFixupToOptionalClientTableSizeTypedefs( pCCB );
    ResetNoOutputIn2ndCodegen( pCCB );

    EmitFixupToFormatStringTypedefs( pCCB );

    // REVIEW: The externs may not be necessary anymore
    pCCB->OutputExternsToMultipleInterfaceTables();
    pCCB->OutputMultipleInterfaceTables();

    OutputTypePicklingTables( pCCB );

    //
    // for all interfaces in this file, output stubs, proc tables, etc.
    //

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
                ((CG_INTERFACE *)pCG)->OutputClientStub( pCCB );
                break;
           }
        }


    EmitFileClosingBlock( pCCB );

    return CG_OK;
}



void
CG_CSTUB_FILE::OutputTypePicklingTables(
        CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output tables of offsets to type information for type pickling.
    If this is the final run, also output the "table of tables"

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Notes:

    Pickled simple types don't end up in the the table.  They are special
    cased.

    Tables looks like:

        static unsigned long DCE_TypePicklingOffsets[] =
        {
            ...
        };

        static unsigned long Ndr64_TypePicklingOffsets[] =
        {
            ...
        };

        static unsigned long * TypePicklingOffsetTable[] =
        {
            DCE_TypePicklingOffsets,
            Ndr64_TypePicklingOffsets
        }

----------------------------------------------------------------------------*/
{
    // straight DCE mode passes the offset directly to the type pickling API

    if ( !pCommand->NeedsNDR64Run() )
        return;

    IndexedList PickledTypes = pCCB->GetListOfPickledTypes();

    if ( 0 == PickledTypes.GetCount() )
        return;

    ISTREAM        *pStream = pCCB->GetStream();
    PNAME           syntax;
    CG_TYPE_ENCODE *type;
    bool            first = true;

    if ( pCommand->IsNDR64Run() )
        syntax = "FormatInfoRef Ndr64";
    else
        syntax = "unsigned long DCE";

    //
    // Output the type offset table for the current syntax
    //

    pStream->NewLine();
    pStream->WriteFormat(
                    "static %s_TypePicklingOffsets[] =",
                    syntax );
    pStream->WriteOnNewLine( '{' );
    pStream->IndentInc();

    ITERATOR_INIT( PickledTypes );

    while ( ITERATOR_GETNEXT( PickledTypes, type ) )
        {
        if ( !first )
            pStream->Write( ',' );

        pStream->NewLine();

        CG_NDR *pChild = (CG_NDR *) type->GetChild();
        ulong   TypeOffset;
        char   *format;

        if ( pCommand->IsNDR64Run() )
            {
            format = "&__midl_frag%d";
            TypeOffset = (ulong) (size_t) pCCB->GetNdr64Format()->GetRoot()
                                        ->LookupFragmentID( pChild );
            MIDL_ASSERT( 0 != TypeOffset );
            }
        else
            {
            format = "%d";
            TypeOffset = pChild->GetFormatStringOffset();
            MIDL_ASSERT( ((ulong) -1) != TypeOffset );
            }

        pStream->WriteFormat( format, TypeOffset );
        pStream->WriteFormat( "   /* %s */", type->GetSymName() );
        first = false;
        }

    pStream->IndentDec();
    pStream->WriteOnNewLine( "};" );
    pStream->NewLine();

    //
    // If this isn't the final protocol, quit now.  Otherwise output the
    // table of tables.
    //

    if ( !pCommand->IsFinalProtocolRun() )
        return;

    pStream->WriteOnNewLine( "static unsigned long * "
                                    "TypePicklingOffsetTable[] =" );
    pStream->WriteOnNewLine( "{" );
    pStream->IndentInc();

    first = true;

    if ( pCommand->NeedsNDRRun() )
        {
        pStream->WriteOnNewLine( "DCE_TypePicklingOffsets" );
        first = false;
        }
    if ( pCommand->NeedsNDR64Run() )
        {
        if ( !first ) pStream->Write( ',' );
        pStream->WriteOnNewLine( "(unsigned long *) Ndr64_TypePicklingOffsets" );
        first = false;
        }

    pStream->IndentDec();
    pStream->WriteOnNewLine( "};" );
    pStream->NewLine();
}



/****************************************************************************
 *  sstub file implementation class.
 ***************************************************************************/

CG_STATUS
CG_SSTUB_FILE::GenCode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    CG_NDR      *   pCG;
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    ISTREAM     Stream( GetFileName(), 4 );
    ISTREAM *   pStream     = &Stream;

    pCCB->SetStream( pStream, this );

    // Set HasStublessProxies and HasOi2 for each interface.

    EvaluateVersionControl();

    EmitFileHeadingBlock( pCCB, "the RPC server stubs" );

    //
    // Emit the hash includes.
    //
    SetNoOutputIn2ndCodegen( pCCB );

    Out_IncludeOfFile( pCCB, STRING_H_INC_FILE_NAME, TRUE );
    _splitpath( GetHeaderFileName(), Drive, Path, Name, Ext );
    strcpy( Buffer, Name );
    strcat( Buffer, Ext );
    Out_IncludeOfFile( pCCB, Buffer, FALSE );

    EmitFormatStringTypedefs( pCCB );

    Out_TransferSyntaxDefs( pCCB );
    //
    // Emit the external variables needed.
    //

    //
    // Emit the format string extern declarations.
    //
    Out_FormatInfoExtern( pCCB );
    Out_TypeFormatStringExtern( pCCB );
    Out_ProcFormatStringExtern( pCCB );

    pCCB->ClearOptionalExternFlags();

    pCCB->SetFileCG(this);

    Out_NotifyTableExtern( pCCB );

    MIDL_ASSERT( pCommand->IsNDR64Run() || pCommand->IsNDRRun() );

    if ( pCommand->IsNDR64Run() )
        {
        pCCB->SetFormatString( NULL );
        pCCB->SetProcFormatString( NULL );
        pCCB->SetNdr64Format( GenNdr64Format::CreateInstance( pCCB ) );
        }

    else
        {

        //
        // Create a new format string object if it does not exist.
        //
        if ( !pCCB->GetFormatString() )
        {
            pCCB->SetFormatString( new FORMAT_STRING() );

            // push a dummy short 0 at the beginning. This disambiguates
            // the case where offset 0 means recursion and a valid offset

            pCCB->GetFormatString()->PushShort( ( short ) 0 );
        }

        if ( !pCCB->GetProcFormatString() )
        {
            pCCB->SetProcFormatString( new FORMAT_STRING() );
        }

        }

    //
    // Send the message to the children to emit code.
    //

    //
    // For all interfaces in this file, generate code.
    //

    BOOL            HasInterpretedProc = FALSE;

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( pCG->GetCGID() == ID_CG_INTERFACE )
            {
            if ( ! ((CG_INTERFACE *)pCG)->HasPicklingStuffOnly() )
                {
                pCCB->SetSkipFormatStreamGeneration( FALSE );

                ((CG_INTERFACE *)pCG)->OutputInterfaceIdComment( pCCB );
                ((CG_INTERFACE *)pCG)->GenServerInfo( pCCB );

                if ( ((CG_INTERFACE *)pCG)->HasInterpretedProc() )
                    HasInterpretedProc = TRUE;
                }
            }
        }

    //
    // Output the tables that may be common to several interfaces.

    pCCB->SetCodeGenSide( CGSIDE_SERVER );

    Out_NotifyTable( pCCB );

    ResetNoOutputIn2ndCodegen( pCCB );

    //
    // If there was at least one interpreted proc in the interfaces of this
    // file than make sure to turn the optimization bit in the CCB's
    // OptimOption on.
    //
    EmitFixupToFormatStringTypedefs( pCCB );

    if ( HasInterpretedProc )
        pCCB->SetOptimOption( unsigned short( pCCB->GetOptimOption() | OPTIMIZE_INTERPRETER ) );

    // REVIEW: The externs may not be necessary anymore
    pCCB->OutputExternsToMultipleInterfaceTables();
    pCCB->OutputMultipleInterfaceTables();

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( pCG->GetCGID() == ID_CG_INTERFACE )
            {
            if ( ! ((CG_INTERFACE *)pCG)->HasPicklingStuffOnly() )
                {
                ((CG_INTERFACE *)pCG)->OutputServerStub( pCCB );
                }
            }
        }


    EmitFileClosingBlock( pCCB );

    return CG_OK;
}


class GUID_DICTIONARY   : public Dictionary
    {
public:
                GUID_DICTIONARY()
                    {
                    }

    virtual
    SSIZE_T     Compare (pUserType p1, pUserType p2)
                    {
                    INTERNAL_UUID   *   u1  = &( ((CG_INTERFACE *)p1)->GetGuidStrs().Value );
                    INTERNAL_UUID   *   u2  = &( ((CG_INTERFACE *)p2)->GetGuidStrs().Value );

                    return memcmp( u1, u2, 16 );
                    }


    };

void
CG_PROXY_FILE::MakeImplementedInterfacesList( CCB* )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Make a list of all the interfaces supported by this proxy file
    ( non-inherited, non-local interfaces ).

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_INTERFACE        *    pCG;
    CG_ITERATOR                I;
    GUID_DICTIONARY            GuidDict;

    // work directly on the real list
    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( pCG->GetCGID() != ID_CG_OBJECT_INTERFACE )
            continue;

        // Note that we don't need proxies and stubs for a pipe interface.

        if ( ((CG_OBJECT_INTERFACE*)pCG)->IsLocal() )
            continue;

        GuidDict.Dict_Insert( pCG );
        }

    GuidDict.Dict_GetList( ImplementedInterfaces );
    GuidDict.Dict_Discard();
}

void
CG_FILE::EvaluateVersionControl()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Calculates HasStublessProxies and Oi2 flags only through the
    interfaces.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:
 Notes:

----------------------------------------------------------------------------*/
{
    if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_STUBLESS_CLIENT ) ||
          pCommand->GetNdrVersionControl().HasStublessProxies() )
        GetNdrVersionControl().SetHasStublessProxies();

    if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) ||
          pCommand->GetNdrVersionControl().HasOi2() )
        GetNdrVersionControl().SetHasOi2();

    CG_ITERATOR         I;
    CG_NDR        *     pCG;
    CG_INTERFACE  *     pIntf;

    if( !GetMembers( I ) )
        {
        return;
        }

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pIntf = (CG_INTERFACE *)pCG;

        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
            case ID_CG_INHERITED_OBJECT_INTERFACE:
            case ID_CG_OBJECT_INTERFACE:
                pIntf->EvaluateVersionControl();

                if ( pIntf->HasStublessProxies() )
                    GetNdrVersionControl().SetHasStublessProxies();
                if ( pIntf->GetNdrVersionControl().HasOi2() )
                    GetNdrVersionControl().SetHasOi2();
                break;

            default:
                break;
            }
        }

    if ( GetNdrVersionControl().HasStublessProxies() )
        pCommand->GetNdrVersionControl().SetHasStublessProxies();
    if ( GetNdrVersionControl().HasOi2() )
        pCommand->GetNdrVersionControl().SetHasOi2();
}

CG_STATUS
CG_PROXY_FILE::GenCode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a proxy file containing the proxies and stubs for
    the [object] interfaces defined in the IDL file.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR I;
    CG_NDR *    pCG;
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];
    unsigned long index = 0;

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    ISTREAM     Stream( GetFileName(), 4 );
    ISTREAM *    pStream        = &Stream;

    pCCB->SetStream( pStream, this );

    // Set HasStublessProxies and HasOi2 for each interface.

    EvaluateVersionControl();

    EmitFileHeadingBlock( pCCB, "the proxy stub code" );

    SetNoOutputIn2ndCodegen( pCCB );
    //
    // Check if midl was invoked with -O1.  This means we can create
    // binaries using stubless proxies (if also compiled -Oi).  These
    // proxies will not work on 807.
    //
    if ( GetNdrVersionControl().HasStublessProxies() )
        {
        pStream->NewLine();
        pStream->Write( "#define USE_STUBLESS_PROXY" );

        pStream->NewLine();
        }


    // rpcproxy.h version guard
    pStream->NewLine(2);
    char sz[192];
    pStream->Write( GetRpcProxyHVersionGuard( sz ) );

    //
    // Emit the hash includes.
    //
    Out_IncludeOfFile( pCCB, "rpcproxy.h", FALSE );

    // rpcproxy.h version guard
    char *sz2 = "\n"
                "#ifndef __RPCPROXY_H_VERSION__\n"
                "#error this stub requires an updated version of <rpcproxy.h>\n"
                "#endif // __RPCPROXY_H_VERSION__\n\n";
    pStream->Write( sz2 );

    _splitpath( GetHeaderFileName(), Drive, Path, Name, Ext );
    strcpy( Buffer, Name );
    strcat( Buffer, Ext );
    Out_IncludeOfFile( pCCB, Buffer, FALSE );

    EmitFormatStringTypedefs( pCCB );

    Out_TransferSyntaxDefs( pCCB );
    //
    // Emit the external variables needed.
    //

    pStream->NewLine();

    //
    // Emit the format string extern declarations.
    //
    Out_FormatInfoExtern( pCCB );
    Out_TypeFormatStringExtern( pCCB );
    Out_ProcFormatStringExtern( pCCB );

    pCCB->ClearOptionalExternFlags();

    pStream->NewLine();

    pCCB->SetFileCG(this);

    MIDL_ASSERT( pCommand->IsNDR64Run() || pCommand->IsNDRRun() );

    if ( pCommand->IsNDR64Run() )
        {
        pCCB->SetFormatString( NULL );
        pCCB->SetProcFormatString( NULL );
        pCCB->SetNdr64Format( GenNdr64Format::CreateInstance( pCCB ) );
        }

    else
        {

        //
        // Create a new format string object if it does not yet exist.
        //
        if ( !pCCB->GetFormatString() )
        {
            pCCB->SetFormatString( new FORMAT_STRING() );

            // push a dummy short 0 at the beginning. This disambiguates
            // the case where offset 0 means recursion and a valid offset
//            if ( !pCommand->IsSwitchDefined( SWITCH_INTERNAL ) )
//                {
                pCCB->GetFormatString()->PushShort( ( short ) 0 );
//                }
        }

        if ( !pCCB->GetProcFormatString() )
        {
            pCCB->SetProcFormatString( new FORMAT_STRING() );
        }

        }

    // make the list of interfaces provided by this proxy file
    MakeImplementedInterfacesList( pCCB );

    //
    // Send the message to the children to emit code.
    //

    //
    // generate code for all [object] interfaces in the IDL file.
    //

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INHERITED_OBJECT_INTERFACE:
                {
                CG_INHERITED_OBJECT_INTERFACE * pInhObjCG =
                              ( CG_INHERITED_OBJECT_INTERFACE * ) pCG;
                //
                // Generate format string description for all procs.
                //
                pInhObjCG->GenProxy( pCCB );
                break;
                }
            case ID_CG_OBJECT_INTERFACE:
                {
                CG_OBJECT_INTERFACE * pObjCG;

                pObjCG = (CG_OBJECT_INTERFACE *) pCG;

                // make no code or tables for local interfaces
                pObjCG->GenProxy( pCCB );
                if ( pObjCG->IsLocal()  )
                    break;

                index++;   // index is index in stub/proxy buffer tables
                break;
                }
            default:
                break;
            }
        }

    Out_NotifyTable( pCCB );

    pCCB->SetSkipFormatStreamGeneration( FALSE );

    pStream->NewLine();
//  BUGBUG: figure out where to put this. yongqu
//    pStream->Write( "#pragma data_seg(\".rdata\")" );
//    pStream->NewLine();

    ResetNoOutputIn2ndCodegen( pCCB );

    pCCB->OutputExternsToMultipleInterfaceTables();

    EmitFixupToFormatStringTypedefs( pCCB );

    pCCB->OutputMultipleInterfaceTables();

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
                ((CG_INTERFACE *)pCG)->OutputInterfaceIdComment( pCCB );
                break;

            case ID_CG_INHERITED_OBJECT_INTERFACE:
                {
                CG_INHERITED_OBJECT_INTERFACE * pInhObjCG =
                              ( CG_INHERITED_OBJECT_INTERFACE * ) pCG;
                //
                // Generate format string description for all procs.
                //
                pInhObjCG->OutputInterfaceIdComment( pCCB );
                pInhObjCG->OutputProxy( pCCB );
                // make no code or tables for local interfaces
                if ( pInhObjCG->IsLocal() )
                    break;

                //
                // Both of these do nothing right now.  4/25.
                //
                pInhObjCG->GenInterfaceProxy( pCCB, index );
                pInhObjCG->GenInterfaceStub( pCCB, index );
                break;
                }

            case ID_CG_OBJECT_INTERFACE:
                {
                CG_OBJECT_INTERFACE * pObjCG;

                pObjCG = (CG_OBJECT_INTERFACE *) pCG;

                // make no code or tables for local interfaces
                pObjCG->OutputInterfaceIdComment( pCCB );
                pObjCG->OutputProxy( pCCB );
                if ( pObjCG->IsLocal()  )
                    break;

                pObjCG->GenInterfaceProxy( pCCB, index );   // index is not used
                pObjCG->GenInterfaceStub( pCCB, index );    // index is not used

                index++;   // index is index in stub/proxy buffer tables
                break;
                }

            default:
                break;
            }
        }

    Out_StubDescriptor(0, pCCB);

    if ( pCommand->IsFinalProtocolRun() )
        Out_ProxyFileInfo(pCCB);

    EmitFileClosingBlock( pCCB );

    UpdateDLLDataFile( pCCB );

    return CG_OK;
}

void
CG_HDR_FILE::OutputImportIncludes(
    CCB     *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the header file.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    none.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR    *       pImpList    = GetImportList();
    node_file   *       pIFile;
    ISTREAM     *       pStream     = pCCB->GetStream();
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];

    if( pImpList && pImpList->NonNull() )
        {

        pStream->NewLine();
        pStream->Write( "/* header files for imported files */" );

        pImpList->Init();
        while( ITERATOR_GETNEXT( (*pImportList), pIFile ) )
            {
            pStream->NewLine();
            // if this was specified with ACF include, print out as is
            if ( pIFile->IsAcfInclude() )
                sprintf( Buffer, "#include \"%s\"", pIFile->GetSymName() );
            else if ( pIFile->HasComClasses() )
                {
                _splitpath( pIFile->GetSymName(), Drive, Path, Name, Ext );
                sprintf( Buffer, "#include \"%s_d.h\"", Name );
                }
            else
                {
                _splitpath( pIFile->GetSymName(), Drive, Path, Name, Ext );
                sprintf( Buffer, "#include \"%s.h\"", Name );
                }
            pStream->Write( Buffer );
            }

        pStream->NewLine();
        }
}


void OutputInterfaceForwards(
    ISTREAM  * pStream,
    CG_ITERATOR & I )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the forwards section of the header file.

 Arguments:

    pCCB    - The code gen controller block.
    I       - an iterator for the nodes to process

 Return Value:

    none.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_INTERFACE *  pCG;
    char *          pszInterfaceName;
    ID_CG           id;

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        id = pCG->GetCGID();
        switch( id )
            {
            case ID_CG_INTERFACE:
            case ID_CG_INHERITED_OBJECT_INTERFACE:
                break;

            case ID_CG_OBJECT_INTERFACE:
            case ID_CG_DISPINTERFACE:
            case ID_CG_COCLASS:
                pszInterfaceName = pCG->GetType()->GetSymName();

                pStream->NewLine();

                // put out the interface guards
                pStream->Write("\n#ifndef __");
                pStream->Write( pszInterfaceName );
                pStream->Write( "_FWD_DEFINED__\n" );

                pStream->Write( "#define __");
                pStream->Write( pszInterfaceName );
                pStream->Write( "_FWD_DEFINED__\n" );

                // put out the forward definition
                if ( ID_CG_COCLASS == id )
                    {
                    pStream->Write("\n#ifdef __cplusplus\n");
                    pStream->Write("typedef class ");
                    pStream->Write(pszInterfaceName);
                    pStream->Write(' ');
                    pStream->Write(pszInterfaceName);
                    pStream->Write(';');
                    pStream->Write("\n#else\n");
                    pStream->Write("typedef struct ");
                    pStream->Write(pszInterfaceName);
                    pStream->Write(' ');
                    pStream->Write(pszInterfaceName);
                    pStream->Write(';');
                    pStream->Write( "\n#endif /* __cplusplus */\n");
                    }
                else
                    {
                    pStream->Write("typedef interface ");
                    pStream->Write(pszInterfaceName);
                    pStream->Write(' ');
                    pStream->Write(pszInterfaceName);
                    pStream->Write(';');
                    }

                // put out the trailing interface guard
                pStream->Write( "\n#endif \t/* __");
                pStream->Write( pszInterfaceName );
                pStream->Write( "_FWD_DEFINED__ */\n" );

                break;

            case ID_CG_LIBRARY:
                {
                CG_ITERATOR Inner;
                if ( pCG->GetMembers( Inner ) )
                    {
                    OutputInterfaceForwards( pStream, Inner );
                    }

                break;
                }
            default:
                break;
            }
        }
}

#define NibbleToAscii(x)  ((x) >= 0x0A ? (x) + 'A' - 0x0A : (x) + '0')
#define IsAlphaNum_(x)    (((x) >= '0' && (x) <= '9') || ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || (x) == '_')

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    Setup a flag (fIgnore) in STREAM no to write anything out .


 Arguments:


 Return Value:

    none.

 Notes:

    This routine is called to avoid generating the same data structure twice, in
    both NDR32 and NDR64 run.

----------------------------------------------------------------------------*/
void SetNoOutputIn2ndCodegen( CCB *pCCB)
{
    if ( pCommand->Is2ndCodegenRun() )
        {
        pCCB->GetStream()->SetIgnore();
        }
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    Reset Ignore flag in STREAM so Write will really write to the stream.


 Arguments:


 Return Value:

    none.

 Notes:

    This routine is called to avoid generating the same data structure twice, in
    both NDR32 and NDR64 run. This should be called after SetNoOutputInNdr64 to
    resume regular output to stream. Current I assume we'll already generate both.
    The correct checking should be Is2ndNdrRun().

----------------------------------------------------------------------------*/
void ResetNoOutputIn2ndCodegen( CCB *pCCB)
{
    if ( pCommand->Is2ndCodegenRun() )
        {
        pCCB->GetStream()->ResetIgnore();
        }
}

void NormalizeString(
    char*   szSrc,
    char*   szNrm )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Transform a string by converting spaces to underscores and other non-
    alphanumerics to thier hex representation.

 Arguments:

    szSrc   - The source string
    szNrm   - The normalized string

 Return Value:

    none.

 Notes:

    This routine is typically called when some generated variable is biased
    by the filename.  If the filename has a space or DBCS chars then the
    generated variable wouldn't conform to C/C++ naming rules.

----------------------------------------------------------------------------*/
{
    for ( ; *szSrc; szSrc++ )
        {
        if (IsAlphaNum_(*szSrc))
            {
            *szNrm++ = *szSrc;
            }
        else if (*szSrc == ' ')
            {
            *szNrm++ = '_';
            }
        else
            {
            unsigned char ch;

            ch = unsigned char( (*szSrc >> 4) & 0x0F );
            *szNrm++ = (char) NibbleToAscii(ch);
            ch = unsigned char(*szSrc & 0x0F);
            *szNrm++ = (char)NibbleToAscii(ch);
            }
        }
    *szNrm = 0;
}

CG_STATUS
CG_HDR_FILE::GenCode(
    CCB     *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the header file.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK   if all is well.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM         Stream( GetFileName(), 4 );
    ISTREAM    *    pStream = pCCB->SetStream( &Stream, this );
    CG_ITERATOR     I;
    CG_INTERFACE *  pCG;
    BOOL            fHasPickle = FALSE;
    BOOL            fHasObject = FALSE;
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    if ( pCommand->Is64BitEnv()  &&  pCommand->HasAppend64() )
        {
        // Don't generate the same h file definitions twice.
        return CG_OK;
        }

    EmitFileHeadingBlock( pCCB,
                          "the definitions for the interfaces",
                          0,        // optional comment
                          false );  // no 64 vs.32 ifdef

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( pCG->HasPicklingStuff() )
            {
            fHasPickle = TRUE;
            }
        if ( pCG->IsObject() )
            {
            fHasObject = TRUE;
            }
        }

    // rpcndr.h version guard
    pStream->NewLine(2);
    char sz[192];
    pStream->Write( GetRpcNdrHVersionGuard( sz ) );

    // Include standard files.

    pStream->Write( "#include \"rpc.h\"\n#include \"rpcndr.h\"\n" );

    // rpcndr.h version guard
    if ( pCommand->GetNdrVersionControl().HasNdr50Feature() || fHasObject )
        {
        char *sz2 = "\n"
                    "#ifndef __RPCNDR_H_VERSION__\n"
                    "#error this stub requires an updated version of <rpcndr.h>\n"
                    "#endif // __RPCNDR_H_VERSION__\n\n";
        pStream->Write( sz2 );
        }

    // If there is at least one pickle interface, emit the include
    // of midles.h

    if ( fHasPickle )
        {
        pStream->Write( "#include \"midles.h\"\n" );
        }

    if ( fHasObject )
        {
        pStream->Write( "#ifndef COM_NO_WINDOWS_H\n");
        pStream->Write( "#include \"windows.h\"\n#include \"ole2.h\"\n" );
        pStream->Write( "#endif /*COM_NO_WINDOWS_H*/\n");
        }

    // extract the name and the extension to create the ifdefs

    _splitpath( GetFileName(), Drive, Path, Name, Ext );
    char        szNrmName[ _MAX_FNAME * 2 + 1 ];
    char        szNrmExt[ _MAX_EXT * 2 + 1 ];

    NormalizeString( Name, szNrmName );
    // ignore the '.' preceding the extension
    if ( '.' == Ext[0] )
        NormalizeString( &Ext[1], szNrmExt );
    else
        NormalizeString( Ext, szNrmExt );

    // Write out the #ifndefs and #defines
    pStream->NewLine();
    sprintf( Buffer,
             "#ifndef __%s_%s__\n#define __%s_%s__",
             szNrmName,
             szNrmExt,
             szNrmName,
             szNrmExt
           );

    pStream->Write( Buffer );
    pStream->NewLine( 2 );

    // Generate the #pragma once.
    pStream->Write( "#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n" );
    pStream->Write( "#pragma once\n#endif" );
    pStream->NewLine(2);

    //Generate forward declarations for object interfaces.
    pStream->Write("/* Forward Declarations */ ");
    I.Init();
    OutputInterfaceForwards( pStream, I );
    pStream->NewLine();

    // Include the import files.
    OutputImportIncludes( pCCB );
    pStream->NewLine();

    // Write out the cplusplus guard.
    pStream->Write( "#ifdef __cplusplus\nextern \"C\"{\n#endif " );
    pStream->NewLine( 2 );

    pStream->Write(
         "void * __RPC_USER MIDL_user_allocate(size_t);" );
    pStream->NewLine();
    pStream->Write(
         "void __RPC_USER MIDL_user_free( void * ); " );

    pStream->NewLine();

    //
    // For all interfaces in this file, generate code.
    //

    I.Init();
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
            case ID_CG_OBJECT_INTERFACE:
            case ID_CG_LIBRARY:
                pCG->GenHeader( pCCB );
            case ID_CG_INHERITED_OBJECT_INTERFACE:
            default:
                break;
            }
        }

    // put out all the prototypes that are only needed once
    OutputMultipleInterfacePrototypes( pCCB );

    // print out the closing endifs.
    // first the cplusplus stuff.

    pStream->Write( "#ifdef __cplusplus\n}\n#endif\n" );

    // The endif for the file name ifndef

    pStream->NewLine();

    pStream->Write( "#endif" );
    pStream->NewLine();

    EmitFileClosingBlock( pCCB, false );

    pStream->Close();

    return CG_OK;
}

void
CG_HDR_FILE::OutputMultipleInterfacePrototypes(
    CCB     *   pCCB )

{
    ITERATOR        I;
    ITERATOR        UserI;
    ISTREAM     *   pStream     = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("/* Additional Prototypes for ALL interfaces */");
    pStream->NewLine();

    // ALERT! we are using the same iterator for all different type of objects,
    // so none of code below should Init the list or it'll step into something else.
    // Use a new iterator if you need to rewind the list.
    if( pCCB->GetListOfGenHdlTypes( I ) )
        {
        Out_GenHdlPrototypes( pCCB, I );
        }

    if( pCCB->GetListOfCtxtHdlTypes( I ) )
        {
        Out_CtxtHdlPrototypes( pCCB, I );
        }

    if( pCCB->GetListOfPresentedTypes( I ) )
        {
        Out_TransmitAsPrototypes( pCCB, I );
        }

    if( pCCB->GetListOfRepAsWireTypes( I ) )
        {
        Out_RepAsPrototypes( pCCB, I );
        }

    if( pCCB->GetQuadrupleDictionary()->GetListOfItems( UserI ) )
        {
        Out_UserMarshalPrototypes( pCCB, UserI );
        }

    Out_CSSizingAndConversionPrototypes( pCCB, pCCB->GetCsTypeList() );

    if( pCCB->GetListOfTypeAlignSizeTypes( I ) )
        {
        Out_TypeAlignSizePrototypes( pCCB, I );
        }

    if( pCCB->GetListOfTypeEncodeTypes( I ) )
        {
        Out_TypeEncodePrototypes( pCCB, I );
        }

    if( pCCB->GetListOfTypeDecodeTypes( I ) )
        {
        Out_TypeDecodePrototypes( pCCB, I );
        }

    if( pCCB->GetListOfTypeFreeTypes( I ) )
        {
        Out_TypeFreePrototypes( pCCB, I );
        }

    if ( pCCB->GetListOfCallAsRoutines( I ) )
        {
        Out_CallAsProxyPrototypes( pCCB, I );
        }

    if ( pCCB->GetListOfCallAsRoutines( I ) )
        {
        Out_CallAsServerPrototypes( pCCB, I );
        }

    if( pCCB->GetListOfNotifyTableEntries( I ) )
        {
        Out_NotifyPrototypes( pCCB, I );
        }

    pStream->NewLine();
    pStream->Write("/* end of Additional Prototypes */");
    pStream->NewLine( 2 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\cgobject.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    cgobject.cxx

 Abstract:

    code generation for object interfaces.
    CG_OBJECT_INTERFACE
    CG_OBJECT_PROC


 Notes:


 History:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
#include "buffer.hxx"
extern "C"
{
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <errno.h>
}
#include "szbuffer.h"

// Needed to time out a synchronize write to dlldata.c
void MidlSleep( int time_in_sec);

// number of times (1 sec delay per attempt) before quitting.
#define DLLDATA_OPEN_ATTEMPT_MAX    25

/****************************************************************************
 *  externs
 ***************************************************************************/
extern  CMD_ARG             *   pCommand;
char* GetRpcProxyHVersionGuard( char* );

/****************************************************************************
 *  global flags
 ***************************************************************************/
BOOL            fDllDataDelegating  = FALSE;





CG_OBJECT_INTERFACE::CG_OBJECT_INTERFACE(
    node_interface *pI,
    GUID_STRS       GStrs,
    BOOL            fCallbacks,
    BOOL            fMopInfo,
    CG_OBJECT_INTERFACE *   pBaseIF
    ) : CG_INTERFACE(pI, GStrs, fCallbacks, fMopInfo, 0, pBaseIF)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    The constructor for the code generation file node.

 Arguments:

    pI          - A pointer to the interface node in type graph.
    GStrs       - guid strings
    fCallbacks  - Does the interface have any callbacks ?
    fMopInfo    - Does the interface have any mops ?
    
 Return Value:
    
 Notes:

----------------------------------------------------------------------------*/
{
    SetBaseInterfaceCG( pBaseIF );
    pThisDeclarator = MakePtrIDNodeFromTypeName( "This",
                                                 GetType()->GetSymName() );
    // all object interfaces use the same stub desc name

    pStubDescName     = "Object" STUB_DESC_STRUCT_VAR_NAME;
    
    fLocal            = GetType()->FInSummary( ATTR_LOCAL );
    fForcedDelegation = FALSE;
    fVisited          = FALSE;

}

//--------------------------------------------------------------------
//
// CountMemberFunctions
//
// Notes: This function counts the member functions in an interface,
//        including inherited member functions.
//
//
//
//--------------------------------------------------------------------
unsigned long 
CG_OBJECT_INTERFACE::CountMemberFunctions() 
{
    return ((node_interface*)GetType())->GetProcCount();
}

BOOL                        
CG_OBJECT_INTERFACE::IsLastObjectInterface()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Return TRUE if there are no more object interfaces after us.

 Arguments:
    
    none.

 Return Value:

    TRUE if there are no more non-local object interfaces.
    
 Notes:

----------------------------------------------------------------------------*/
{
    CG_INTERFACE    *   pNext = (CG_INTERFACE *) GetSibling();

    while ( pNext )
        {
        if ( pNext->IsObject() && !( (CG_OBJECT_INTERFACE*)pNext)->IsLocal() )
            return FALSE;

        pNext = (CG_INTERFACE *) pNext->GetSibling();
        } 

    return TRUE;
}


CG_STATUS
CG_OBJECT_INTERFACE::GenProxy(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    CG_PROC         *   pCG;
    ISTREAM         *   pStream = pCCB->GetStream();

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    // do nothing for local interfaces and types-only base interfaces


    if( IsLocal() || !( GetMembers( I ) || GetBaseInterfaceCG() ) )
        {
        return CG_OK;
        }
    
    Out_StubDescriptorExtern( pCCB );

    // Check for use of [enable_allocate]

    if ( GetUsesRpcSS() )
        pCCB->SetMallocAndFreeStructExternEmitted();

    Out_InterpreterServerInfoExtern( pCCB );

    pStream->NewLine();
    pStream->WriteFormat( 
                    "extern const MIDL_STUBLESS_PROXY_INFO %s_ProxyInfo;",
                    GetSymName() );
    pStream->NewLine();

    //
    // for all procedure in this interface, generate code.
    //

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pCCB->SetCodeGenSide( CGSIDE_CLIENT );
        pCG->GenClientStub( pCCB );

        pCCB->SetCodeGenSide( CGSIDE_SERVER );
        pCG->GenServerStub( pCCB );
        }

    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::OutputProxy(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    ISTREAM         *   pStream = pCCB->GetStream();

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    // do nothing for local interfaces and types-only base interfaces

    if( IsLocal() || !( GetMembers( I ) || GetBaseInterfaceCG() ) )
        {
        return CG_OK;
        }

    pStream->NewLine();

    pStream->Write("#pragma code_seg(\".orpc\")");

    Out_ProcOffsetTable( pCCB );

    if ( pCommand->NeedsNDR64Run() )
        Out_ProxyInfo( pCCB, FALSE );
    else
        GenProxyInfo( pCCB, FALSE );

        Out_InterpreterServerInfo( pCCB, CGSIDE_SERVER );

    return CG_OK;
}

unsigned long 
CG_OBJECT_INTERFACE::PrintProxyMemberFunctions(
    ISTREAM *   pStream,
    BOOL        fForcesDelegation ) 
/*++

Routine Description:

    This function prints out the member functions of an interface proxy.
    The function calls itself recursively to print out inherited member functions.

Arguments:

    pStream - Specifies the destination stream for output.

--*/
{
    CG_OBJECT_PROC      *   pProc;
    CG_ITERATOR             I;
    CG_OBJECT_INTERFACE *   pBaseInterface  = (CG_OBJECT_INTERFACE  *)GetBaseInterfaceCG();

    if(pBaseInterface)
        pBaseInterface->PrintProxyMemberFunctions(pStream, fForcesDelegation );
    else    // special stuff for IUnknown
        {
#ifdef OK_TO_HAVE_0_IN_VTABLES
        pStream->NewLine();
        pStream->Write( "0 /* QueryInterface */ ," );
        pStream->NewLine();
        pStream->Write( "0 /* AddRef */ ," );
        pStream->NewLine();
        pStream->Write( "0 /* Release */" );
#else
        pStream->NewLine();
        pStream->Write( "IUnknown_QueryInterface_Proxy," );
        pStream->NewLine();
        pStream->Write( "IUnknown_AddRef_Proxy," );
        pStream->NewLine();
        pStream->Write( "IUnknown_Release_Proxy" );
#endif
        return 0;
        }

    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pProc )  )
        {
        pStream->Write( " ," );

        pStream->NewLine();
        pProc->OutProxyRoutineName( pStream, fForcesDelegation );
        }
    return 0;
}

/*
This routine is used to see if we need to force proxies with a thunk for static
linking. We need a thunk if the proc number is too big for the engine to handle.
Method limits apply only to stubless proxies. /Oicf and /Oic but not /Oi or /Os.

The engine was capable of supporting different number of methods depending on
the size of the stubless client routine vtable. This is the size of the stubless 
client vtbl over releases:

            < 32        Windows NT 3.51-
            32 - 110    Windows NT 4.0
            110 - 512   Windows NT 4.0 SP3
            128         Windows NT 5 beta2
            infinity    Windows 2000

In NT5 beta2 we put a new support for stubless client vtbl that removed any 
limitations. At the same time we decreased the size of the default vtbl to 128.
However, we had a bug, and the support for unlimited methods didn't work, so 
effectively we, we are doing the same thing again with NT5 beta3 (2000 beta 3).
 
*/
BOOL CG_OBJECT_PROC::IsStublessProxy()
{
    BOOL res = TRUE;

    if ( ! GetCallAsName() &&
         ( GetOptimizationFlags() & OPTIMIZE_STUBLESS_CLIENT ) &&
         ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) )
        {
        if (pCommand->GetNdrVersionControl().HasNdr50Feature())
            {
            // Temporary till we deploy a fix in NT5 beta3.
            // With beta3 fix, this branch should simply say
            //    res = TRUE;
            res = GetProcNum() < 128;
            }
        else
            {
            unsigned int lMaxProcNumAllowed;

            // NT4 engine had the NDR version 2.0
            if (pCommand->GetNdrVersionControl().HasNdr20Feature())
                lMaxProcNumAllowed = 110;
            else
                lMaxProcNumAllowed = 32; // NT3.51

            res = GetProcNum() < lMaxProcNumAllowed;
            }
        }
    else
        res = FALSE;

    return res;
}

void                    
CG_OBJECT_PROC::OutProxyRoutineName( 
    ISTREAM *   pStream,
    BOOL        fForcesDelegation ) 
{
    char    *   pszProcName;
    BOOL        fIsStublessProxy;

    // In NT5, we can fill in -1 for all the non-delegation methods, and generate 
    // a stubless proxy. For older platforms, due to limits of the support for
    // stubless proxies we have to generate actual name for static linking.
    // The name corrsponds to a thunk, or a mini-stub, calling into interpreter.
    // See IsStublessProxy() for vtbl limits.
    // Later during proxy creation in ndr engine, we'll fill in ObjectStublessProxy
    // vtbl with entries that we take from the default table or that we generate on fly.
    // In fact, for 2000 final, we don't have any limits and we could do it for all 
    // interfaces but we do have a backward compatibility problem due to the above 
    // limitations on old platforms.
    // Also, midl has been issuing a warning that NT4SP3 doesn't support more than 512
    // methods etc.,  although that's applicable to late-binding only. We are removing
    // this warning.

    fIsStublessProxy = IsStublessProxy(); 

    //
    // Delegated and interpreted proxies have their Vtables filled in 
    // at proxy creation time (see ndr20\factory.c).
    //
    if ( IsDelegated () )
        pStream->Write( "0 /* " );

    if ( fIsStublessProxy )
        {
        if ( fForcesDelegation  &&  ! IsDelegated() )
            pStream->Write( "0 /* forced delegation " );
        else
            pStream->Write( "(void *) (INT_PTR) -1 /* " );
        }

    if ( GetCallAsName() )
        pszProcName = GetCallAsName();
    else 
        pszProcName = GetSymName();

    if ( fIsStublessProxy )
        {
        // Just a nitpicky different comment for the stubless guys.
        pStream->Write( GetInterfaceName() );
        pStream->Write( "::" );
        pStream->Write( pszProcName );
        }
    else
        {
        pStream->Write( GetInterfaceName() );
        pStream->Write( '_' );
        pStream->Write( pszProcName );
        pStream->Write( "_Proxy" );
        }

    if ( IsDelegated () || fIsStublessProxy )
        pStream->Write(  " */" );
}

CG_STATUS
CG_INTERFACE::GenProxyInfo( CCB *pCCB,
                            BOOL IsForCallback )
{
    ISTREAM         *   pStream             = pCCB->GetStream();
    
    pStream->Write( "static const MIDL_STUBLESS_PROXY_INFO " );
    pStream->Write( GetSymName() );
    pStream->Write( "_ProxyInfo =" );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( "{" );
    pStream->NewLine();

    // Stub descriptor.
    pStream->Write( '&' );
    pStream->Write( GetStubDescName() );
    pStream->Write( ',' );
    pStream->NewLine();

    // Proc format string.
    if (pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );
    else
        pStream->Write( PROC_FORMAT_STRING_STRING_FIELD );
    pStream->Write( ',' );
    pStream->NewLine();

    // Proc format string offset table.
    if (pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
        pStream->Write( "(unsigned short *) " );

    if ( IsObject() )
        pStream->Write( '&' );

    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );
        
    pStream->Write( GetSymName() );

    if (pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
        pStream->Write( "_Ndr64ProcTable" );
    else
        pStream->Write( FORMAT_STRING_OFFSET_TABLE_NAME );

    if ( IsObject() )
        pStream->Write( "[-3]," );
    else
        pStream->Write( ',' );
        
    pStream->NewLine();

            
    if ( !pCommand->NeedsNDR64Run() )
        {
        pStream->Write( "0," );
        pStream->NewLine();        
        pStream->Write( "0,");
        pStream->NewLine();
        pStream->Write( "0");
        }
    else
        {
        // BUGBUG: what if we let ndr64 as default?
        pStream->Write( '&' );
        if ( pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
            pStream->Write( NDR64_TRANSFER_SYNTAX_VAR_NAME );
        else
            pStream->Write( NDR_TRANSFER_SYNTAX_VAR_NAME );
        
        pStream->Write( ',' );
        pStream->NewLine();
        // SyntaxInfo is only generated when NDR64 is required.
        // MIDL_SYNTAX_INFO will be generated for each transfer syntax supported.
        if ( pCommand->NeedsNDRRun() )
            pStream->Write( "2," );
        else
            pStream->Write( "1," );
        pStream->NewLine();
        if ( IsForCallback )
            pStream->Write( MIDL_CALLBACK_VAR_NAME );
        pStream->Write( GetMulSyntaxInfoName() );
        pStream->NewLine();
        }

    pStream->NewLine();
    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();
    pStream->NewLine();

    return CG_OK;

}

CG_STATUS
CG_INTERFACE::GenSyntaxInfo( CCB * pCCB,
                             BOOL IsForCallback)
{
    if ( !pCommand->NeedsNDR64Run() || !pCommand->IsFinalProtocolRun() )
        return CG_OK;

    long nCount = pCommand->NeedsNDRRun() ? 2 : 1 ;
    ISTREAM *pStream = pCCB->GetStream();

    pStream->WriteOnNewLine("static " MIDL_SYNTAX_INFO_TYPE_NAME " ");
    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );

    pStream->Write( GetSymName() );      
    pStream->Write( MIDL_SYNTAX_INFO_VAR_NAME " [ ");
    pStream->WriteNumber(" %d ] = ", nCount );
    pStream->IndentInc();
    
    pStream->WriteOnNewLine( "{" );
    pStream->NewLine();

    if ( pCommand->NeedsNDRRun() )
        Out_OneSyntaxInfo( pCCB, IsForCallback, SYNTAX_DCE );

    if ( nCount > 1 )
        pStream->Write( "," );
        
    if ( pCommand->NeedsNDR64Run() )
        Out_OneSyntaxInfo( pCCB, IsForCallback, SYNTAX_NDR64 );
        
    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine(2);

    return CG_OK;
}

CG_STATUS
CG_OBJECT_INTERFACE::GenInterfaceProxy( 
    CCB *pCCB, 
    unsigned long )
{
    if ( !pCommand->IsFinalProtocolRun() )
        return CG_OK;

    char            *   pszInterfaceName    = GetSymName();
    ISTREAM         *   pStream             = pCCB->GetStream();
    BOOL                fDelegates          = (NULL != GetDelegatedInterface());

    //
    // Output the interface proxy.
    //

    //
    // If we have to delegate or if we have interpreted methods, then we
    // can not emit the const because in both of these instances the proxy
    // Vtable must be modified during proxy creation time (see 
    // ndr20\factory.c).
    //

    if ( ! fDelegates && ! HasStublessProxies() )
        pStream->Write("const ");

    char TmpBuff[10];
    long Count = CountMemberFunctions();

    // Use a struct macro for Ansi [] compatibility.

    pStream->Write("CINTERFACE_PROXY_VTABLE(" );
    sprintf( TmpBuff, "%ld%", Count );
    pStream->Write( TmpBuff );
    pStream->Write(") _");
    pStream->Write(pszInterfaceName);
    pStream->Write("ProxyVtbl = ");
    pStream->NewLine();
    pStream->Write("{");
    pStream->IndentInc();

    //
    // Emit ProxyInfo field for stubless proxies
    // (NT 3.5 incompatible).
    //

    BOOL    fForcesDelegation = HasStublessProxies()  &&
                                ! HasItsOwnStublessProxies()  &&
                                CountMemberFunctions() > 3;

    if ( fForcesDelegation )
        SetHasForcedDelegation();

    if ( HasStublessProxies() ) 
        {
        // The ProxyInfo.
        pStream->NewLine();

        if ( HasItsOwnStublessProxies() )   
            {
            pStream->Write( '&' );
            pStream->Write( pszInterfaceName );
            pStream->Write( "_ProxyInfo" );
            }
        else
            {
            // In fact, we delegate for empty interfaces or interfaces
            // with os methods only.

            pStream->Write( '0' );
            }

        pStream->Write( ',' );
        }
    else if ( pCommand->GetNdrVersionControl().HasStublessProxies() )
        {
        // Add a dummy 0 for proxy info pointer for a proxy that is
        // oi or os in the file that has stubles proxies

        pStream->NewLine();
        pStream->Write( "0,    /* dummy for table ver 2 */" );
        }
    
    //Write the IID
    pStream->NewLine();
    pStream->Write( "&IID_" );
    pStream->Write( pszInterfaceName );
    pStream->Write( ',' );

    //initialize the vtable
    PrintProxyMemberFunctions( pStream, fForcesDelegation );

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();

    return CG_OK;
}

unsigned long 
CG_OBJECT_INTERFACE::PrintStubMemberFunctions(
    ISTREAM       * pStream) 
/*++

Routine Description:

    This function prints out the member functions of an interface stub dispatch table
    The function calls itself recursively to print out inherited member functions.

Arguments:

    pInterface - Specifies the interface node.

    pStream - Specifies the destination stream for output.

--*/
{
    unsigned long           count           = 0;
    CG_OBJECT_PROC *        pProc;
    CG_ITERATOR             I;
    CG_OBJECT_INTERFACE *   pBaseInterface  = (CG_OBJECT_INTERFACE  *)GetBaseInterfaceCG();

    if ( IsIUnknown() )
        return 0;

    if ( pBaseInterface )
        count = pBaseInterface->PrintStubMemberFunctions(pStream);

    GetMembers( I );

    for( ; ITERATOR_GETNEXT( I, pProc ); count++ )
        {
        if ( ((node_proc*) (pProc->GetType()))->IsFinishProc() )
            {
            continue;
            }
        if( count != 0 )
            pStream->Write(',');

        pStream->NewLine();
        pProc->OutStubRoutineName( pStream );

        }
    return count;
}

void                    
CG_OBJECT_PROC::OutStubRoutineName( 
    ISTREAM * pStream )
{
    node_proc* pProc = (node_proc*) GetType();

    if ( IsDelegated() )
        {
        pStream->Write( "STUB_FORWARDING_FUNCTION" );
        return;
        }

    // local procs don't need proxys and stubs
    if ( IsLocal() )
        {
        pStream->Write( '0' );
        return;
        }

    if ( pProc->IsBeginProc() )
        {
        pStream->Write( S_NDR_CALL_RTN_NAME_DCOM_ASYNC );
        return;
        }

#ifndef TEMPORARY_OI_SERVER_STUBS

    if ( (GetOptimizationFlags() &
            (OPTIMIZE_INTERPRETER_V2 | OPTIMIZE_INTERPRETER)) ==
            (OPTIMIZE_INTERPRETER_V2 | OPTIMIZE_INTERPRETER) )
        {
        if ( HasAsyncHandle() )
            pStream->Write( S_OBJECT_NDR_CALL_RTN_NAME_ASYNC );
        else
            {
            if ( pCommand->NeedsNDR64Run() )
                pStream->Write( S_OBJECT_NDR64_CALL_RTN_NAME );
            else
                pStream->Write( S_OBJECT_NDR_CALL_RTN_NAME_V2 );
            }
        return;
        }
    if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
        {
        pStream->Write( S_OBJECT_NDR_CALL_RTN_NAME );
        return;
        }
#endif // TEMPORARY_OI_SERVER_STUBS

    pStream->Write( GetInterfaceName() );
    pStream->Write( '_' );
    pStream->Write( GetSymName() );
    pStream->Write( "_Stub" );

}


CG_STATUS
CG_OBJECT_INTERFACE::GenInterfaceStub( 
    CCB *pCCB, 
    unsigned long )
{
    if ( !pCommand->IsFinalProtocolRun() )
        return CG_OK;


    node_interface  *       pInterface          = (node_interface *) GetType();
    char *                  pszInterfaceName    = pInterface->GetSymName();

    ISTREAM             *   pStream             = pCCB->GetStream();
    unsigned long           count;

#ifdef TEMPORARY_OI_SERVER_STUBS
    BOOL                    fPureInterpreted    = FALSE;
#else // TEMPORARY_OI_SERVER_STUBS
    BOOL                    fPureInterpreted    = HasOnlyInterpretedMethods();
#endif // TEMPORARY_OI_SERVER_STUBS

    BOOL                    fDelegates          = (NULL != GetDelegatedInterface()) || fForcedDelegation;

    // if any of our base interfaces are delegated, we can't be pure interpreted

    if ( fDelegates )
        fPureInterpreted = FALSE;

    // pure interpreted uses no dispatch table, special invoke function instead
    if ( !fPureInterpreted )
        {
        // Generate the dispatch table
        pStream->NewLine(2);
        pStream->Write( "static const PRPC_STUB_FUNCTION " );
        pStream->Write( pszInterfaceName );
        pStream->Write( "_table[] =" );
        pStream->NewLine();
        pStream->Write('{');
        pStream->IndentInc();

        // Print out the names of all the procedures.
        count = PrintStubMemberFunctions(pStream);

        if ( count == 0 )
            {
            // This is possible for an empty interface inheriting
            // directly from IUnknown. As we don't print first three
            // entries, the table would be empty.
            // We add a zero to simplify references.

            pStream->NewLine();
            pStream->Write( "0    /* a dummy for an empty interface */" );
            }

        pStream->IndentDec();
        pStream->NewLine();
        pStream->Write( "};" );
        pStream->NewLine();
        }

    count = CountMemberFunctions();

    //initialize an interface stub
    pStream->NewLine();
    if ( !fDelegates && !( ( node_interface* ) GetType() )->IsAsyncClone() )
        pStream->Write( "const " );
    pStream->Write( "CInterfaceStubVtbl _" );
    pStream->Write( pszInterfaceName );
    pStream->Write( "StubVtbl =" );
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //Write the IID
    pStream->NewLine();
    pStream->Write( "&IID_" );
    pStream->Write( pszInterfaceName );
    pStream->Write( "," );

    //
    // Interpreter server info fits in the middle here.
    //
    pStream->NewLine();

        pStream->Write( '&' );
        pStream->Write( pszInterfaceName );
        pStream->Write( SERVER_INFO_VAR_NAME );
    pStream->Write( ',' );

    //Write the count
    pStream->NewLine();
    pStream->WriteNumber( "%d", count );
    pStream->Write(',');

    //Write the pointer to dispatch table.
    pStream->NewLine();
    if ( fPureInterpreted )
        pStream->Write( "0, /* pure interpreted */" );
    else
        {
        pStream->Write( '&' );
        pStream->Write( pszInterfaceName );
        pStream->Write( "_table[-3]," );
        }

    //initialize the vtable
    pStream->NewLine();
    if ( ( ( node_interface* ) GetType() )->IsAsyncClone() )
        {
        if ( fDelegates )
            pStream->Write("CStdAsyncStubBuffer_DELEGATING_METHODS");
        else
            pStream->Write("CStdAsyncStubBuffer_METHODS");
        }
    else
        {
        if ( fDelegates )
            pStream->Write("CStdStubBuffer_DELEGATING_METHODS");
        else
            pStream->Write("CStdStubBuffer_METHODS");
        }

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();

    return CG_OK;
}

CG_STATUS
CG_INHERITED_OBJECT_INTERFACE::GenProxy(
    CCB *   )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
/*
    ITERATOR            I;
    CG_PROC         *   pProc;

    // Initialize the CCB for this interface.
    InitializeCCB( pCCB );

    if( IsLocal() || !GetMembers( I ) )
        {
        return CG_OK;
        }

    //
    // Send the message to the children to emit code.
    //

    //
    // for all procedures in this interface, generate code.
    //

    while( ITERATOR_GETNEXT( I, pProc ) )
        {
        if ( pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
            {
            pProc->GenNdrFormat( pCCB );

            if ( pProc->NeedsServerThunk( pCCB, CGSIDE_SERVER ) )
                {
                CG_ITERATOR    Iterator;
                CG_PARAM *  pParam;
                CG_RETURN * pReturn;
                CG_NDR *    pChild;
                node_skl *  pType;  
                node_skl *  pActualType;
                PNAME       pName;

                pProc->GetMembers( Iterator );

                while ( ITERATOR_GETNEXT( Iterator, pParam ) )
                    {
                    pType = pParam->GetType();
                    pActualType = pType->GetChild();
                    pName = pType->GetSymName();

                    pChild = (CG_NDR *) pParam->GetChild();

                    if( pChild->IsArray() )
                        pActualType = MakePtrIDNode( pName, pActualType );
                    else
                        pActualType = MakeIDNode( pName, pActualType );

                    pParam->SetResource( new RESOURCE( pName, pActualType ) );
                    }

                if ( ( pReturn = pProc->GetReturnType() ) != 0 )
                    {
                    pReturn->SetResource( 
                        new RESOURCE( RETURN_VALUE_VAR_NAME, 
                                      MakeIDNode( RETURN_VALUE_VAR_NAME,
                                                  pReturn->GetType() ) ) );
                    }

                pProc->GenNdrThunkInterpretedServerStub( pCCB );
                }
            }
        }
*/
    return CG_OK;
}

CG_STATUS
CG_INHERITED_OBJECT_INTERFACE::OutputProxy(
    CCB *   )
{
    return CG_OK;
}


STATUS_T
CG_OBJECT_INTERFACE::PrintVtableEntries( CCB * pCCB  )
/*++

Routine Description:

    This routine prints the vtable entries for an interface.  


--*/
{
    CG_OBJECT_PROC      *   pC;
    CG_OBJECT_INTERFACE*    pBaseCG = (CG_OBJECT_INTERFACE*) GetBaseInterfaceCG();

    if( pBaseCG )
        pBaseCG->PrintVtableEntries( pCCB );

    pC = (CG_OBJECT_PROC *) GetChild();
    while ( pC )
        {
        pC->PrintVtableEntry( pCCB );

        pC = (CG_OBJECT_PROC *) pC->GetSibling();
        }

    return STATUS_OK;
}


CG_STATUS
CG_OBJECT_PROC::C_GenProlog(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the procedure prolog for the stub procedure.

 Arguments:
    
    pCCB    - A pointer to the code generation controller block.

 Return Value:
    
    CG_OK   if all is well
    error   Otherwise

 Notes:

    Increment the stream indentation at the end of the prolog.
    Although we register params as param resources, we dont generate the
    procedure signature using the PrintType/Decl facility.

    We have added an explicit "this" pointer as the first parameter.
----------------------------------------------------------------------------*/
{

    ITERATOR        I;
    ITERATOR        T;
    ISTREAM *   pStream = pCCB->GetStream();
    BufferManager Buffer(10);


    // Output the bare procedure declaration
    pStream->NewLine();
    Out_ProxyFunctionPrototype(pCCB, 0);
    pStream->IndentDec();

    //
    // Write the opening brace on a new line.
    //

    pStream->WriteOnNewLine( "{" );

    pStream->NewLine();



    // Generate declarations for pre-allocated and analyser-determined locals.

    pCCB->GetListOfLocalResources( I );
    Out_ClientLocalVariables( pCCB, I );

    pCCB->GetListOfTransientResources( T );
    Out_ClientLocalVariables( pCCB, T );


        // If the rpc ss package is to be enabled, do so.
    // It would need to be enabled explicitely on the client side when
    // in non-osf mode, with the attribute on the operation AND
    //      - the routine is a callback, 
    //      - the routine is not a callback and the interface doesn't
    //        have the attribute (if it does, we optimized via stub descr.)

    if( pCCB->GetMode()  &&  MustInvokeRpcSSAllocate()
        &&
        (  GetCGID() == ID_CG_CALLBACK_PROC  ||
           GetCGID() != ID_CG_CALLBACK_PROC  &&
                            !pCCB->GetInterfaceCG()->IsAllRpcSS())
      )
        {
        Out_RpcSSSetClientToOsf( pCCB );
        }


    // Increment the indentation of the output stream. Reset at epilog time.

    Out_IndentInc( pCCB );

    //
    // Initialize all [out] unique and interface pointers to 0.
    //

    CG_ITERATOR     Iterator;
    CG_PARAM *      pParam;
    CG_NDR *        pNdr;
    CG_NDR  *       pTopPtr = 0;
    long            Derefs;
    expr_node *      pSizeof;

    GetMembers( Iterator );

    for ( ; ITERATOR_GETNEXT(Iterator, pParam); )
        {
        if ( pParam->IsParamIn() )
            continue;

        pNdr = (CG_NDR *) pParam->GetChild();

        if ( ! pNdr->IsPointer()  &&  ! pNdr->IsArray() )
            continue;

        Derefs = 0;

        //
        // Skip the ref pointer(s) to the pointee.
        //
        for ( ; 
              pNdr->IsPointer() && 
              ((CG_POINTER *)pNdr)->GetPtrType() == PTR_REF &&
              !pNdr->IsInterfacePointer();
              Derefs++, pNdr = (CG_NDR *) pNdr->GetChild() )
            {
            if( Derefs == 0 )
                pTopPtr = pNdr;
            }

        // No ref, no service.

        if ( ! Derefs  &&  ! pNdr->IsArray() )
            continue;

        // Ready to zero out.
        // Note, however, that in case where the ref checks are required,
        // we need to be careful and skip zeroing if ref pointers are null.
        // This is because we cannot raise exception immediately
        // as then some of the variables may not be zeroed out yet.

        //
        // Memset a struct, union or an array in case there are
        // embedded unique, full or interface pointers.
        // Same for user types of transmit_as, represent_as, user_marshal.
        //

        if ( pNdr->GetCGID() == ID_CG_TRANSMIT_AS )
            {
            pSizeof = new expr_sizeof( ((CG_TRANSMIT_AS*)pNdr)->GetPresentedType() );
            }
        else if ( pNdr->GetCGID() == ID_CG_USER_MARSHAL  &&
                    ((CG_USER_MARSHAL*)pNdr)->IsFromXmit() )
            {
            pSizeof = new expr_sizeof( ((CG_USER_MARSHAL*)pNdr)->GetRepAsType() );
            }
        else
            pSizeof = new expr_sizeof( pNdr->GetType() );


        if ( pNdr->IsStruct() || pNdr->IsUnion() || pNdr->IsArray() ||
             pNdr->IsXmitRepOrUserMarshal() || pNdr->IsInterfacePointer() )
            {
            if ( pCCB->MustCheckRef() )
                {
                Out_If( pCCB,
                        new expr_variable( pParam->GetType()->GetSymName() ));
                }

            expr_proc_call *   pCall;

            pStream->NewLine();

            pCall = new expr_proc_call( MIDL_MEMSET_RTN_NAME );

            pCall->SetParam( 
                    new expr_param( 
                    new expr_variable( pParam->GetType()->GetSymName() ) ) );

            pCall->SetParam(
                    new expr_param( 
                    new expr_variable( "0" ) ) );

            if ( pNdr->IsInterfacePointer() )
                {
                pSizeof = new expr_sizeof( pParam->GetChild()->GetType() );
                }

            if( pTopPtr && ((CG_POINTER *)pTopPtr)->IsQualifiedPointer() &&
                !(pTopPtr->GetCGID() == ID_CG_STRING_PTR ) )
                {
                _expr_node * pFinalExpr;
                CGPHASE Ph = pCCB->GetCodeGenPhase();
                pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

                pFinalExpr = ((CG_POINTER *)pTopPtr)->FinalSizeExpression( pCCB );
                pSizeof = new expr_op_binary( OP_STAR, pFinalExpr, pSizeof );
                pCCB->SetCodeGenPhase( Ph );
                }

            pCall->SetParam(
                    new expr_param( pSizeof ) );

            pCall->PrintCall( pStream, 0, 0 );

            if ( pCCB->MustCheckRef() )
                Out_Endif( pCCB );

            continue;
            }

        //
        // Are we at a non ref pointer now?
        //
        if ( ( pNdr->IsPointer() && 
                 (((CG_POINTER *)pNdr)->GetPtrType() != PTR_REF) ) ||
             pNdr->IsInterfacePointer() ) 
            {
            if ( pCCB->MustCheckRef() )
                {
                Out_If( pCCB,
                        new expr_variable( pParam->GetType()->GetSymName() ));
                }

            pStream->NewLine();

            for ( ; Derefs--; )
                pStream->Write( '*' );

            pStream->Write( pParam->GetResource()->GetResourceName() );
            pStream->Write( " = 0;" );

            if ( pCCB->MustCheckRef() )
                Out_Endif( pCCB );
            }
        }

    return CG_OK;
}



CG_STATUS
CG_OBJECT_PROC::C_GenBind(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to bind to server.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream         = pCCB->GetStream();
    ITERATOR            BindingParamList;
    expr_node      *   pExpr;
    expr_proc_call *   pProcCall;

    //
    // collect standard arguments to the init procedure.
    //
    
    // The implicit "this" pointer.  
    pExpr   = new RESOURCE( "This",
                            (node_skl *)0 );

    pExpr   = MakeExpressionOfCastToTypeName( "void *",
                                              pExpr );

    ITERATOR_INSERT( BindingParamList, pExpr );

    // The rpc message variable.

    pExpr   = pCCB->GetStandardResource( ST_RES_RPC_MESSAGE_VARIABLE );
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PRPC_MESSAGE_TYPE_NAME, pExpr );

    ITERATOR_INSERT(
                    BindingParamList,
                    pExpr
                   );

    // The stub message variable.

    pExpr   = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE);
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME, pExpr );

    ITERATOR_INSERT(
                    BindingParamList,
                    pExpr
                   );

    // The stub descriptor structure variable. This is not allocated as
    // a resource explicitly.

    pExpr   = new RESOURCE( pCCB->GetInterfaceCG()->GetStubDescName(),
                            (node_skl *)0 );

    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_DESC_STRUCT_TYPE_NAME,
                                              pExpr );

    ITERATOR_INSERT( BindingParamList, pExpr );

    //
    // Proc num.
    //
    ITERATOR_INSERT( BindingParamList,
                     new expr_constant( (long) GetProcNum() ) );


    //Build the procedure call expression.
    pProcCall   = MakeProcCallOutOfParamExprList("NdrProxyInitialize", 0, BindingParamList);

    pStream->NewLine();
    pProcCall->PrintCall( pCCB->GetStream(), 0, 0 );
    pStream->NewLine();

    Out_SetOperationBits(pCCB, GetOperationBits());

    pStream->NewLine();


    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::GenGetBuffer(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the message buffer.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *pStream = pCCB->GetStream();
    CGSIDE Side = pCCB->GetCodeGenSide();

    pStream->NewLine();
    
    if(Side == CGSIDE_SERVER)
        pStream->Write("NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);");
    else
        pStream->Write("NdrProxyGetBuffer(This, &_StubMsg);");

    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::C_GenSendReceive(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to call IRpcChannelBuffer::SendReceive.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:
----------------------------------------------------------------------------*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("NdrProxySendReceive(This, &_StubMsg);");
    pStream->NewLine();

    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::C_GenFreeBuffer(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to call IRpcChannelBuffer::FreeBuffer.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:
----------------------------------------------------------------------------*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("NdrProxyFreeBuffer(This, &_StubMsg);");
    pStream->NewLine();

    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::C_GenUnBind( CCB* )
{
    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::S_GenProlog(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side stub prolog.

 Arguments:

    pCCB    - A pointer to the code generation controller block.
    
 Return Value:

    CG_OK   if all is well
    error   Otherwise.
    
 Notes:

    Print out the signature, locals, the stub descriptor if needed and the
    adjust indent in anticipation of code.
----------------------------------------------------------------------------*/
{

    ITERATOR    LocalsList;
    ITERATOR    TransientList;
    expr_proc_call *   pCall;

    // Collect all the params and locals into lists ready to print.

    pCCB->GetListOfLocalResources( LocalsList );
    pCCB->GetListOfTransientResources( TransientList );

    // Print out the procedure signature and the local variables. This
    // procedure will also print out the stub descriptor.

    Out_ServerStubProlog( pCCB,
                               LocalsList,
                               TransientList
                             );

    //
    // Done for interpretation op.  No indent needed either.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
        return CG_OK;

    // Start a new indent for code.

    Out_IndentInc( pCCB );

    //
    // Call the NdrStubInitialize routine.
    //

    pCall = new expr_proc_call( "NdrStubInitialize" );

    pCall->SetParam( new expr_param (
                     new expr_variable( PRPC_MESSAGE_VAR_NAME ) ) );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( 
                            pCCB->GetInterfaceCG()->GetStubDescName() ) ) ) );

    pCall->SetParam( new expr_param (
                     new expr_variable( "_pRpcChannelBuffer" ) ) );

    pCall->PrintCall( pCCB->GetStream(), 0, 0 );

    // if the rpc ss package is to be enabled, do so.

    if( MustInvokeRpcSSAllocate() )
        {
        Out_RpcSSEnableAllocate( pCCB );
        }

    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::S_GenInitMarshall( CCB* )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side marshall init.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well,
    error   otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    return CG_OK;
}


void
CG_OBJECT_PROC::S_PreAllocateResources(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Pre-allocate variables that are needed on the server side.

 Arguments:

    pAna            - A pointer to the analysis block.
    
 Return Value:
    
    None.

 Notes:

    1. The rpc message is a parameter resource allocated on the server side.
    2. All other local variables, are decided during/after the analysis phase.
    
----------------------------------------------------------------------------*/
{
    node_param  *   pInterfaceStubType  = new node_param();
    node_param  *   pChannelType    = new node_param();

    //pointer to interface stub

    pInterfaceStubType->SetSymName( "This" );
    pInterfaceStubType->SetBasicType( (node_skl *)
                                    new node_def ("IRpcStubBuffer *") );
    pInterfaceStubType->SetEdgeType( EDGE_USE );

    pAna->AddParamResource( "This",
                            (node_skl *) pInterfaceStubType
                          );

    //The pointer to IRpcChannelBuffer
    pChannelType->SetSymName( "_pRpcChannelBuffer" );
    pChannelType->SetBasicType( (node_skl *)
                                    new node_def ("IRpcChannelBuffer *") );
    pChannelType->SetEdgeType( EDGE_USE );

    pAna->AddParamResource( "_pRpcChannelBuffer",
                            (node_skl *) pChannelType
                          );

    CG_PROC::S_PreAllocateResources( pAna );

}



CG_STATUS
CG_OBJECT_PROC::S_GenCallManager(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:
    
    pCCB    - A pointer to the code generation controller block.

 Return Value:
    
    CG_OK   if all is well
    error   otherwise.

 Notes:

    Make a procedure node with all the parameters that need to be passed to
    the manager code. The actual expression that needs to be passed to the
    actual manager code is set up during earlier passes. This is called the
    result expression.

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    PNAME               pName;
    expr_proc_call  *   pProc;
    CG_PARAM        *   pParam;
    expr_node       *   pExpr;
    expr_node       *   pReturnExpr = 0;
    CG_RETURN       *   pRT;
    CSzBuffer Buffer;
    ISTREAM         *   pStream = pCCB->GetStream();

    if ( GetCallAsName() )
        {
        pName   = (PNAME ) new char[ strlen(GetCallAsName()) + 
                                     strlen( pCCB->GetInterfaceName() )
                                     + 7 ];
        strcpy( pName, pCCB->GetInterfaceName() );
        strcat( pName, "_" );
        strcat( pName, GetCallAsName() );
        strcat( pName, "_Stub" );
        }
    else
        pName   = (PNAME ) GetType()->GetSymName();

    pProc   = new expr_proc_call( pName );



    //implicit this pointer.
    Buffer.Append("(");
    Buffer.Append(pCCB->GetInterfaceName());
    Buffer.Append(" *) ((CStdStubBuffer *)This)->pvServerObject");

    pProc->SetParam( 
        new expr_param( 
        new expr_variable(Buffer)));


    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pParam ) )
        {
        if ( ( pExpr = pParam->GetFinalExpression() ) != 0 )
            {
            CG_NDR * pChild = (CG_NDR *)pParam->GetChild();

            //
            // We have to dereference arrays because of how they are defined
            // in the stub.
            //
            if ( pChild->IsArray() )
                pExpr = new expr_u_deref( pExpr );

            pProc->SetParam( new expr_param( pExpr ) );
            }
        }

    if ( ( pRT = GetReturnType() ) != 0 )
        {
        pReturnExpr = pRT->GetFinalExpression();
        }


    //Set flag before calling server object.
    pStream->NewLine();
    if ( ReturnsHRESULT() )
        pStream->WriteOnNewLine("*_pdwStubPhase = STUB_CALL_SERVER;");
    else
        pStream->WriteOnNewLine("*_pdwStubPhase = STUB_CALL_SERVER_NO_HRESULT;");
    pStream->NewLine();

    // stubs with call_as must call the user routine, instead of the
    // member function.  The user function must then call the member function

    if ( GetCallAsName() )
        Out_CallManager( pCCB, pProc, pReturnExpr, FALSE );
    else
        Out_CallMemberFunction( pCCB, pProc, pReturnExpr, FALSE );

    //Set flag before marshalling.
    pStream->NewLine();
    pStream->WriteOnNewLine("*_pdwStubPhase = STUB_MARSHAL;");

    return CG_OK;

}


void
CG_OBJECT_PROC::GenNdrInterpretedManagerCall(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the interpreted manager routine.

 Arguments:
    
    pCCB    - A pointer to the code generation controller block.

 Return Value:
    
    none

 Notes:

    Make a procedure node with all the parameters that need to be passed to
    the manager code. The actual expression that needs to be passed to the
    actual manager code is set up during earlier passes. This is called the
    result expression.

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    PNAME               pName;
    expr_proc_call  *   pProc;
    CG_PARAM        *   pParam;
    expr_node       *   pReturnExpr = 0;
    CG_RETURN       *   pRT;
    CSzBuffer Buffer;
    ISTREAM         *   pStream = pCCB->GetStream();

    if ( GetCallAsName() )
        {
        pName   = (PNAME ) new char[ strlen(GetCallAsName()) + 
                                     strlen( pCCB->GetInterfaceName() )
                                     + 7 ];
        strcpy( pName, pCCB->GetInterfaceName() );
        strcat( pName, "_" );
        strcat( pName, GetCallAsName() );
        strcat( pName, "_Stub" );
        }
    else
        pName   = (PNAME ) GetType()->GetSymName();

    pProc   = new expr_proc_call( pName );



    //implicit this pointer.
    Buffer.Append("(");
    Buffer.Append(pCCB->GetInterfaceName());
    Buffer.Append(" *) pParamStruct->This");
    
    pProc->SetParam( 
        new expr_param( 
        new expr_variable(Buffer)));


    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pParam ) )
        {
        CG_NDR *        pNdr;
        char *          pName;
        expr_node *     pExpr;
        char *          pPlainName  = pParam->GetResource()->GetResourceName();

        pNdr = (CG_NDR *) pParam->GetChild();

        pName = new char[strlen(pPlainName) + strlen("pParamStruct->")+1 ];

        strcpy( pName, "pParamStruct->" );
        strcat( pName, pPlainName );

        pExpr = new expr_variable( pName );

        pProc->SetParam( new expr_param ( pExpr ) );
        }

    if( ( pRT = GetReturnType() ) != 0 && !HasAsyncHandle() )
        {
        pReturnExpr = new expr_variable( 
                            "pParamStruct->" RETURN_VALUE_VAR_NAME );
        }


    pStream->WriteOnNewLine("/* Call the server */");

    // stubs with call_as must call the user routine, instead of the
    // member function.  The user function must then call the member function
    if ( GetCallAsName() )
        Out_CallManager( pCCB, pProc, pReturnExpr, FALSE );
    else
        Out_CallMemberFunction( pCCB, pProc, pReturnExpr, TRUE );

    pStream->NewLine();

    return;

}

void
Out_CallCMacroFunction(
    CCB         *   pCCB,
    expr_proc_call *   pProcExpr)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pProcExpr   - A pointer to the complete procedure expression.
    pRet        - An optional pointer to ther return variable.

 Return Value:

    None.

 Notes:

    //call proxy
    (*(This)->lpVtbl -> LockServer)( This, fLock);

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();

    // allocate the nodes on the stack
    expr_variable   VtblExpr( "(This)->lpVtbl" );
    expr_pointsto   VtblEntExpr( &VtblExpr, pProcExpr );
    // expr_op_unary    VtblEntExprCall( OP_UNARY_INDIRECTION, &VtblEntExpr ); 

    pStream->IndentInc();
    pStream->NewLine();

    VtblEntExpr.Print( pStream );

    pStream->IndentDec();


}


CG_STATUS
CG_OBJECT_PROC::GenCMacro(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the proxy routine.

 Arguments:
    
    pCCB    - A pointer to the code generation controller block.

 Return Value:
    
    CG_OK   if all is well
    error   otherwise.

 Notes:

    Make a procedure node with all the parameters that need to be passed to
    the manager code. The actual expression that needs to be passed to the
    actual manager code is set up during earlier passes. This is called the
    result expression.

----------------------------------------------------------------------------*/
{
    node_param      *   pParam;
    ISTREAM         *   pStream = pCCB->GetStream();
    node_proc       *   pProc   = (node_proc *) GetType();

    if ( SupressHeader())
        return CG_OK;

    if ( GetCallAsName() )
        {
        node_call_as    *   pCallAs =   (node_call_as *)
                                            pProc->GetAttribute( ATTR_CALL_AS );

        pProc = (node_proc *) pCallAs->GetCallAsType();

        MIDL_ASSERT ( pProc );
        }

    // construct all these on the stack...
    MEM_ITER            MemIter( pProc );

    expr_proc_call     Proc( pProc->GetSymName() );
    expr_variable      ThisVar( "This" );
    expr_param         ThisParam( &ThisVar );

    Proc.SetParam( &ThisParam );


    while ( ( pParam = (node_param *) MemIter.GetNext() ) != 0 )
        {
        Proc.SetParam( new expr_param( 
                            new expr_variable( pParam->GetSymName() ) ) );
        }

    // print out the #define line
    pStream->NewLine();
    pStream->Write("#define ");
    pStream->Write( pCCB->GetInterfaceName() );
    pStream->Write( '_' );

    Proc.Print( pStream );

    pStream->Write( "\t\\" );

    Out_CallCMacroFunction( pCCB, &Proc );

    return CG_OK;

}

void
CG_PROXY_FILE::Out_ProxyBuffer(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a CStdProxyBuffer for the [object] interfaces defined
    in the IDL file.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            &   I       = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE *   pCG;
    ISTREAM *               pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("const CInterfaceProxyVtbl * _");
    pStream->Write(pFName);
    pStream->Write("_ProxyVtblList[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        pStream->Write("( CInterfaceProxyVtbl *) &_");
        pStream->Write(pCG->GetSymName());
        pStream->Write("ProxyVtbl,");
        }
    pStream->NewLine();
    pStream->Write('0');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

void
CG_PROXY_FILE::Out_StubBuffer(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a CStdStubBuffer for the [object] interfaces defined
    in the IDL file.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            &   I       = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE *   pCG;
    ISTREAM *               pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("const CInterfaceStubVtbl * _");
    pStream->Write(pFName);
    pStream->Write("_StubVtblList[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        pStream->Write("( CInterfaceStubVtbl *) &_");
        pStream->Write( pCG->GetSymName() );
        pStream->Write("StubVtbl,");
        }
    pStream->NewLine();
    pStream->Write('0');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

void
CG_PROXY_FILE::Out_InterfaceNamesList(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate an interface name list for the [object] interfaces defined
    in the IDL file.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            &   I       = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE *   pCG;
    ISTREAM *               pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("PCInterfaceName const _");
    pStream->Write(pFName);
    pStream->Write("_InterfaceNamesList[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        pStream->Write('\"');
        pStream->Write(pCG->GetSymName());
        pStream->Write("\",");
        }
    pStream->NewLine();
    pStream->Write('0');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

void
CG_PROXY_FILE::Out_AsyncInterfaceTable  (
                                        CCB*    pCCB,
                                        char*
                                        )
    {
    ITERATOR&               I = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE*    pCG;
    ISTREAM*                pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("static const IID * _AsyncInterfaceTable[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        if ( ((node_interface*)pCG->GetType())->GetAsyncInterface() == 0 )
            {
            if ( ((node_interface*)pCG->GetType())->IsAsyncClone() )
                {
                pStream->Write( "(IID*) -1" );
                }
            else
                {
                pStream->Write( "(IID*) 0" );
                }
            }
        else
            {
            pStream->Write( "(IID*) &IID_" );
            pStream->Write(((node_interface*)pCG->GetType())->GetAsyncInterface()->GetSymName());
            }
        pStream->Write(",");
        }
    pStream->NewLine();
    pStream->Write( "(IID*) 0" );
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
    }

void
CG_PROXY_FILE::Out_BaseIntfsList(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a base interface list for the [object] interfaces defined
    in the IDL file that need delegation

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR                &   I       = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE     *   pCG;
    CG_OBJECT_INTERFACE     *   pBaseCG;
    ISTREAM *                   pStream = pCCB->GetStream();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        
        // if we needed delegation, add it to the list
        if ( ( (pBaseCG = pCG->GetDelegatedInterface() ) != 0 ) || pCG->HasForcedDelegation())
            {
            fDllDataDelegating = TRUE;
            break;
            }
        }

    ITERATOR_INIT( I );

    // if there is no delegating, we don't need this table
    if ( !fDllDataDelegating )
        return;

    pStream->NewLine();
    pStream->Write("const IID *  _");
    pStream->Write(pFName);
    pStream->Write("_BaseIIDList[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        
        // if we needed delegation, add it to the list
        if ( ( pBaseCG = pCG->GetDelegatedInterface() ) != 0 )
            {
            fDllDataDelegating = TRUE;
            pStream->Write("&IID_");
            pStream->Write( pBaseCG->GetSymName() );
            pStream->Write(',');
            }
        else if ( pCG->HasForcedDelegation() )
            {
            fDllDataDelegating = TRUE;
            pStream->Write("&IID_");
            pStream->Write( pCG->GetBaseInterfaceCG()->GetSymName() );
            pStream->Write(',');
            pStream->Write("   /* forced */");
            }
        else
            pStream->Write("0,");
        }
    pStream->NewLine();
    pStream->Write('0');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

inline 
unsigned char
log2( unsigned long ulVal )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Compute the log base 2 (rounded down to integral) of a number
    Returns 0 for 0 or 1

 Arguments:
    
    ulVal        - the value to check on.

 Notes:
    uses binary search to find the highest set bit

    to find the smallest power of 2 >= a number, use 1 << log2( 2n-1 )

----------------------------------------------------------------------------*/
{
    unsigned char   result = 0;

    if ( ( ulVal >>16 ) > 0 )
        {
        ulVal >>= 16;
        result = 16;
        }

    if ( ( ulVal >>8 ) > 0 )
        {
        ulVal >>= 8;
        result += 8;
        }

    if ( ( ulVal >>4 ) > 0 )
        {
        ulVal >>= 4;
        result += 4;
        }

    if ( ( ulVal >>2 ) > 0 )
        {
        ulVal >>= 2;
        result += 2;
        }

    if ( ulVal > 1 )
        {
        result++;
        }

    return result;
}

void
CG_PROXY_FILE::Out_InfoSearchRoutine(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a search function for the interfaces defined in this proxy file

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR                &   I       = GetImplementedInterfacesList();
    ISTREAM *        pStream    = pCCB->GetStream();
    unsigned long    ListSize = I.GetCount();
    CSzBuffer        CheckIIDName;
    unsigned long    CurIndex;

    
    CheckIIDName.Append("_");
    CheckIIDName.Append( pFName );
    CheckIIDName.Append( "_CHECK_IID" );

    pStream->NewLine(2);
    pStream->Write( "#define " );
    pStream->Write( CheckIIDName );
    pStream->Write( "(n)\tIID_GENERIC_CHECK_IID( _");
    pStream->Write( pFName );
    pStream->Write( ", pIID, n)");


    pStream->NewLine( 2 );
    pStream->Write( "int __stdcall _" );
    pStream->Write( pFName );
    pStream->Write( "_IID_Lookup( const IID * pIID, int * pIndex )" );
    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    if ( ListSize == 0 )
        {
        pStream->Write( "return 0;" );
        }
    else if ( ListSize < 2 )
        {

        expr_variable       SetValue( "*pIndex" );

        expr_param          IndexParam( NULL );
        expr_proc_call      CheckIIDExpr( CheckIIDName );

        CheckIIDExpr.SetParam( &IndexParam );

        expr_u_not          TopExpr( &CheckIIDExpr );

        for ( CurIndex = 0; CurIndex < ListSize; CurIndex++ )
            {
            expr_constant       IndexNode( CurIndex );

            IndexParam.SetLeft( &IndexNode );

            Out_If( pCCB, &TopExpr );
            Out_Assign( pCCB, &SetValue, &IndexNode );
            pStream->NewLine();
            pStream->Write( "return 1;" );
            Out_Endif( pCCB );
            }
        
        pStream->NewLine(2);
        pStream->Write( "return 0;" );
        }
    else
        {
        unsigned long       curStep = 1 << log2( ListSize - 1 );

        pStream->Write( "IID_BS_LOOKUP_SETUP" );
        pStream->NewLine(2);
        
        pStream->Write( "IID_BS_LOOKUP_INITIAL_TEST( _" );
        pStream->Write( pFName );
        pStream->Write( ", " );
        pStream->WriteNumber( "%d", ListSize );
        pStream->Write( ", " );
        pStream->WriteNumber( "%d", curStep );
        pStream->Write( " )" );
        pStream->NewLine();

        for ( curStep >>= 1 ; curStep > 0 ; curStep >>= 1 )
            {
            pStream->Write( "IID_BS_LOOKUP_NEXT_TEST( _" );
            pStream->Write( pFName );
            pStream->Write( ", " );
            pStream->WriteNumber( "%d", curStep );
            pStream->Write( " )" );
            pStream->NewLine();
            }
        
        pStream->Write( "IID_BS_LOOKUP_RETURN_RESULT( _" );
        pStream->Write( pFName );
        pStream->Write( ", " );
        pStream->WriteNumber( "%d", ListSize );
        pStream->Write( ", *pIndex )" );
        pStream->NewLine();

        }

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

}


void
CG_PROXY_FILE::Out_ProxyFileInfo(
    CCB *pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a ProxyFileInfo structure for the [object] interfaces defined
    in the IDL file.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR        &   I       = GetImplementedInterfacesList();
    char                BaseName[ _MAX_FNAME ];
    char                Name[ _MAX_FNAME ];
    ISTREAM *           pStream = pCCB->GetStream();
    unsigned long       count   = 0;

    //Get the IDL file name.
    pCommand->GetInputFileNameComponents(NULL, NULL, BaseName, NULL );
    NormalizeString( BaseName, Name);

    //////////////////////////////////////////
    // put out the ancilliary data structures    
    Out_ProxyBuffer(pCCB, Name );
    Out_StubBuffer(pCCB, Name );
    Out_InterfaceNamesList(pCCB, Name );
    Out_BaseIntfsList(pCCB, Name);
    Out_InfoSearchRoutine( pCCB, Name );
    // AsyncIFTable
    if ( pCommand->GetNdrVersionControl().HasAsyncUUID() )
        {
        Out_AsyncInterfaceTable( pCCB, Name );
        }

    //////////////////////////////////////////
    // put out the ProxyFileInfo struct

    //list of interface proxies.
    count = ITERATOR_GETCOUNT( I );

    pStream->NewLine();
    pStream->Write("const ExtendedProxyFileInfo ");
    pStream->Write(Name);
    pStream->Write("_ProxyFileInfo = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //pointer to the proxy buffer
    pStream->NewLine();
    pStream->Write("(PCInterfaceProxyVtblList *) & _");
    pStream->Write(Name);
    pStream->Write("_ProxyVtblList,");


    //pointer to the stub buffer
    pStream->NewLine();
    pStream->Write("(PCInterfaceStubVtblList *) & _");
    pStream->Write(Name);
    pStream->Write("_StubVtblList,");

    //pointer to the interface names list
    pStream->NewLine();
    pStream->Write("(const PCInterfaceName * ) & _");
    pStream->Write(Name);
    pStream->Write("_InterfaceNamesList,");

    //pointer to the base iids list
    pStream->NewLine();
    // no table if no delegation
    if ( fDllDataDelegating )
        {
        pStream->Write("(const IID ** ) & _");
        pStream->Write(Name);
        pStream->Write("_BaseIIDList,");
        }
    else
        {
        pStream->Write( "0, // no delegation" );
        }

    // IID lookup routine
    pStream->NewLine();
    pStream->Write( "& _" );
    pStream->Write( Name );
    pStream->Write( "_IID_Lookup, ");

    // table size
    pStream->NewLine();
    pStream->WriteNumber( "%d", count );
    pStream->Write( ',' );
    pStream->NewLine();

    // table version
    unsigned short uTableVer = 1;
    if ( pCommand->GetNdrVersionControl().HasStublessProxies() )
        {
        uTableVer = 2;
        }
    if ( pCommand->GetNdrVersionControl().HasAsyncUUID() )
        {
        uTableVer |= 4;
        }
    pStream->WriteNumber( "%d", uTableVer );
    pStream->Write( ',' );
    pStream->NewLine();

    // AsyncIFTable
    if ( pCommand->GetNdrVersionControl().HasAsyncUUID() )
        {
        pStream->Write( "(const IID**) &_AsyncInterfaceTable[0],");
        }
    else
        {
        pStream->Write( "0,");
        }
    pStream->Write( " /* table of [async_uuid] interfaces */" );

    pStream->NewLine();
    pStream->Write( "0, /* Filler1 */" );
    pStream->NewLine();
    pStream->Write( "0, /* Filler2 */" );
    pStream->NewLine();
    pStream->Write( "0  /* Filler3 */" );

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  String constants for the DllData file

----------------------------------------------------------------------------*/

#define DLLDATA_LIST_START  "/* Start of list */\n"
#define DLLDATA_LIST_END    "/* End of list */\n"

#define DLLDATA_HEADER_COMMENT  \
    "/*********************************************************\n"  \
    "   DllData file -- generated by MIDL compiler \n\n"    \
    "        DO NOT ALTER THIS FILE\n\n"    \
    "   This file is regenerated by MIDL on every IDL file compile.\n\n"    \
    "   To completely reconstruct this file, delete it and rerun MIDL\n"    \
    "   on all the IDL files in this DLL, specifying this file for the\n"   \
    "   /dlldata command line option\n\n"   \
    "*********************************************************/\n\n"

#define DLLDATA_HAS_DELEGATION  "#define PROXY_DELEGATION\n"
    
#define DLLDATA_HEADER_INCLUDES     \
    "\n#include <rpcproxy.h>\n\n" \
    "#ifdef __cplusplus\n"  \
    "extern \"C\"   {\n" \
    "#endif\n"  \
    "\n"

#define DLLDATA_EXTERN_CALL "EXTERN_PROXY_FILE( %s )\n"
#define DLLDATA_REFERENCE   "  REFERENCE_PROXY_FILE( %s ),\n"
#define DLLDATA_START       "\n\nPROXYFILE_LIST_START\n" DLLDATA_LIST_START
#define DLLDATA_END         DLLDATA_LIST_END "PROXYFILE_LIST_END\n"

#define DLLDATA_TRAILER     \
    "\n\nDLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )\n"   \
    "\n"    \
    "#ifdef __cplusplus\n"  \
    "}  /*extern \"C\" */\n" \
    "#endif\n"  \
    "\n/* end of generated dlldata file */\n"

void
DllDataParse(
    FILE * pDllData,
    STRING_DICT & Dict )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Parse the "dlldata" file, extracting info on all the included files.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    const char *    pStart  = DLLDATA_LIST_START;
    const char *    pEnd    = DLLDATA_LIST_END;
    const char *    pDelegating = DLLDATA_HAS_DELEGATION;

    char Input[100];

    // skip everything up to (and including) pStart
    while ( !feof( pDllData ) )
        {
        if ( !fgets(    Input, 100, pDllData ) )
            break;
        if ( !strcmp( Input, pDelegating ) )
            {
            fDllDataDelegating = TRUE;
            continue;
            }
        if ( !strcmp( Input, pStart ) )
            break;
        }

    // parse list (looking for pEnd)
    while ( !feof( pDllData ) &&
             fgets( Input, 100, pDllData ) &&
             strcmp( Input, pEnd ) )
        {
        char    *   pOpenParen = strchr( Input, '(' );
        char    *   pCloseParen = strchr( Input, ')' );
        char    *   pSave;

        if ( !pOpenParen || !pCloseParen )
            {
            // formatting error on this line
            continue;
            }

        // chop off the close paren, and skip the open paren
        *(pCloseParen--) = '\0';
        pOpenParen++;
        // delete leading and trailing spaces
        while ( isspace( *pOpenParen ) )
            pOpenParen++;
        while ( isspace( *pCloseParen ) )
            *(pCloseParen--) = '\0';
        pSave = new char[ strlen( pOpenParen ) + 1 ];
        
        strcpy( pSave, pOpenParen );

        // add file name to dictionary
        Dict.Dict_Insert( pSave );
        }

}

void
DllDataEmit(
    FILE * pDllData,
    STRING_DICT & Dict )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit a new "dlldata" file, including info on all the included files.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    Dict_Status     Status;
    char    *       pCur;
    char            Normalized[ _MAX_FNAME ];
    BOOL            fFirst = TRUE;

    // emit header

    fputs( DLLDATA_HEADER_COMMENT, pDllData );

    if ( fDllDataDelegating )
        fputs( DLLDATA_HAS_DELEGATION, pDllData );

    // rpcproxy.h version guard
    // do not generate the version guard in dlldata.c for now because
    // MIDL does not regenerate the file. It adds to the existing
    // dlldata.c This causes problems when the old compiler has
    // generated the existing dlldata.c and vice-versa.
    /*
    fputs( "\n\n", pDllData  );
    char sz[192];
    fputs( GetRpcProxyHVersionGuard( sz ), pDllData  );
    fputs( "\n", pDllData  );
    */

    fputs( DLLDATA_HEADER_INCLUDES, pDllData );

    // emit extern definitions
    Status = Dict.Dict_Init();

    while( SUCCESS == Status )
        {
        pCur    = (char *) Dict.Dict_Curr_Item();
        NormalizeString( pCur, Normalized ); 
        fprintf( pDllData, DLLDATA_EXTERN_CALL, Normalized );
        Status = Dict.Dict_Next( (pUserType)pCur );
        }

    // emit header for type

    fputs( DLLDATA_START, pDllData );

    // emit extern references, adding comma on all but the first
    Status = Dict.Dict_Init();

    while( SUCCESS == Status )
        {
        pCur    = (char *) Dict.Dict_Curr_Item();
        NormalizeString( pCur, Normalized );
        fprintf( pDllData,
                 DLLDATA_REFERENCE, 
                 Normalized );
        fFirst = FALSE;
        Status = Dict.Dict_Next( (pUserType)pCur );
        }

    // emit trailer for type

    fputs( DLLDATA_END, pDllData );

    // emit trailer

    fputs( DLLDATA_TRAILER, pDllData );
}




void                        
CG_PROXY_FILE::UpdateDLLDataFile( CCB* )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Update the "dlldata" file, adding info for this file if needed.

    If no changes at all are required, leave the file untouched.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    char        *   pszDllDataName = pCommand->GetDllDataFName();
    FILE        *   pDllData;
    STRING_DICT     ProxyFileList;
    char            BaseName[ _MAX_FNAME ];
    char            Name[ _MAX_FNAME ];

    // Use sopen to make sure there always is a file to process.
    // (fsopen with "r+" requires an existing file).

    int DllDataHandle = _sopen( pszDllDataName,
                                (_O_CREAT | _O_RDWR | _O_TEXT),
                                _SH_DENYRW,
                                (_S_IREAD | _S_IWRITE ) );

    // if the file exists already and/or is busy, it's ok.

    if ( DllDataHandle == -1  &&
         (errno != EEXIST  &&  errno != EACCES) )
        {
        // unexpected error
        RpcError((char *)NULL, 0, INPUT_OPEN, pszDllDataName );
        return;
        }

    if ( DllDataHandle != -1 )
        {
        _close(DllDataHandle);
        }

    // Attempt to open the file for reading and writing.
    // Because we can have a race condition when updating this file,
    // we try several times before quitting.

    for ( int i = 0;
          (i < DLLDATA_OPEN_ATTEMPT_MAX)  &&
          ( ( pDllData = _fsopen( pszDllDataName, "r+t", _SH_DENYRW ) ) == 0 );
          i++ )
        {
        printf("waiting for %s ...\n", pszDllDataName);
        MidlSleep(1);
        }

    if ( !pDllData )
        {
        RpcError((char *)NULL, 0, INPUT_OPEN, pszDllDataName );
        return;
        }

    //Get the IDL file name.
    pCommand->GetInputFileNameComponents(NULL, NULL, BaseName, NULL );
    NormalizeString( BaseName, Name );

    // If file is empty, the following is a no op.
    // skip up to the proxyfileinfo stuff and read/make sorted list of files

    DllDataParse( pDllData, ProxyFileList );

    // insert our file name
    ProxyFileList.Dict_Insert( Name ); 
    
    // re-emit everything

    rewind( pDllData );
    DllDataEmit( pDllData, ProxyFileList );

    // close the file to give others a chance

    if ( fclose( pDllData ))
        {
        RpcError((char *)NULL, 0, ERROR_WRITING_FILE, pszDllDataName );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\cgdump.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	cgdump.cxx

 Abstract:

	A debug code generation object dumper.

 Notes:


 History:

	VibhasC		Aug-13-1993		Created.
    mzoran      Nov-15-1999     Modified to print tree.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

//
//  Characters for class graph dumper
//
#if defined(WIN32)

const char CharElbow         = '';
const char CharTee           = '';
const char CharVLine         = '';
const char StringTeeLine[]   = "";
const char StringElbowLine[] = "";

#else

const char CharElbow         = '\\';
const char CharTee           = '>';
const char CharVLine         = '|';
const char StringTeeLine[]   = ">---";
const char StringElbowLine[] = "\\---";


#endif

#ifdef MIDL_INTERNAL

typedef PTR_SET<CG_CLASS> CG_DUMP_SET;
typedef MAP<CG_CLASS*, unsigned long> CG_DUMP_MAP;

const char * DoGetAdditionalDumpInfo( CG_CLASS *pClass )
{
    if ( ( dynamic_cast<CG_FILE*>( pClass ) != NULL ) && 
         ( static_cast<CG_FILE*>( pClass )->GetFileName() != NULL ) )
        {
        return static_cast<CG_FILE*>( pClass )->GetFileName();
        }
    else if ( ( dynamic_cast<CG_HANDLE*>( pClass ) != NULL ) &&
              ( static_cast<CG_HANDLE*>( pClass )->GetHandleType() != NULL ) &&
              ( static_cast<CG_HANDLE*>( pClass )->GetHandleType()->GetSymName() != NULL ) )
        {
        return static_cast<CG_HANDLE*>( pClass )->GetHandleType()->GetSymName();
        }
    else if ( dynamic_cast<CG_FIELD*>( pClass ) != NULL )
        {
        CG_FIELD *pField = dynamic_cast<CG_FIELD*>( pClass );
        size_t Length = strlen(pField->GetSymName()) + 
                        strlen(pField->GetPrintPrefix()) + 1;
        char *p = new char[Length];
        strcpy( p, pField->GetPrintPrefix() );
        strcat( p, pField->GetSymName() );
        return p;
        }
    else if ( ( pClass->GetType() != NULL ) &&
              ( pClass->GetType()->GetSymName() != NULL ) )
        {
        return pClass->GetType()->GetSymName();
        }
    else 
        {
        return "";
        }
}

unsigned long DoDumpCGClassList( CG_CLASS *pClass, CG_DUMP_MAP  & DumpMap, unsigned long  & LastNodeNum )
{

    if ( pClass == NULL )
        return 0;

    // See if this node has already been printed
    unsigned long Me;
    if ( DumpMap.Lookup( pClass, &Me ) )
        return Me;

    Me = ++LastNodeNum;
    DumpMap.Insert( pClass, Me );

    CG_CLASS	*	pChild	= pClass->GetChild();
	CG_CLASS	*	pSibling= pClass->GetSibling();

    CG_CLASS *pReturnType;
    if ( ( dynamic_cast<CG_PROC*>( pClass ) != NULL ) && 
         ( ( pReturnType = static_cast<CG_PROC*>( pClass )->GetReturnType()  ) != NULL ) )
        {
        DoDumpCGClassList( pReturnType, DumpMap, LastNodeNum );
        }

    unsigned long Ch = DoDumpCGClassList( pChild,   DumpMap, LastNodeNum );    
    unsigned long Si = DoDumpCGClassList( pSibling, DumpMap, LastNodeNum );
    const char *pName = typeid( *pClass ).name();
    const char *pAdditionalInfo = DoGetAdditionalDumpInfo( pClass );

    fprintf( stderr,
			 "%30s : %.4d(0x%p) : Ch = %.4d, Si = %.4d %s\n", 
			 pName,
			 Me,
             pClass,
			 Ch,
			 Si,
			 pAdditionalInfo
		   );
    
    return Me;
                             
}

void DoDumpCGClassList( CG_CLASS *pClass, CG_DUMP_MAP *pDumpMap = NULL )
{
    
    unsigned long NodeNum = 0;
    if ( NULL == pDumpMap )
        {
        CG_DUMP_MAP DumpMap;
        DoDumpCGClassList( pClass, DumpMap, NodeNum );
        }
    else
        DoDumpCGClassList( pClass, *pDumpMap, NodeNum );
    fprintf( stderr, "\n" );   
}

void DoDumpCGClassGraph( CG_CLASS *pClass, CG_DUMP_MAP  * pDumpMap, CG_DUMP_SET & DumpSet, 
                         const char *pPrefixString )
{
    if ( pClass == NULL )
        return;
    
    //
    // Print Myself
    //
    unsigned long Me;
    BOOL LookupResult = pDumpMap->Lookup( pClass, &Me );
    MIDL_ASSERT( LookupResult );

    fprintf( stderr, "%s%s, %.4d(0x%p), %s\n",
        pPrefixString, 
        typeid( *pClass ).name(),
        Me,
        pClass,
        DoGetAdditionalDumpInfo( pClass ) ); 

    //
    // If this node has already been printed, do not print children.
    //
    if ( DumpSet.Lookup( pClass ) )
        return;

    DumpSet.Insert( pClass );

    //
    // Copy old prefix
    //
    const size_t PrevStrLen = strlen( pPrefixString );
    const size_t NewStringLength = PrevStrLen + 4 + sizeof('\0');
    char *pNewPrefix = new char[ NewStringLength ];
    char *pNewPrefixTail = pNewPrefix + PrevStrLen;
    memset( pNewPrefix, 0xBD, NewStringLength );
    memcpy( pNewPrefix, pPrefixString, PrevStrLen + 1 );

    //
    // Modify the previous characters.   If this was the last child,
    // convert previous 4 characters to spaces, otherwise convert
    // to a line with spaces.
    // 
    if ( PrevStrLen >= 4 )
        {
        pNewPrefix[PrevStrLen - 3] = ' ';
        pNewPrefix[PrevStrLen - 2] = ' ';                              
        pNewPrefix[PrevStrLen - 1] = ' ';                              
        if (pNewPrefix[PrevStrLen - 4] == CharElbow)                         
            pNewPrefix[PrevStrLen - 4] = ' ';                          
        else if ( pNewPrefix[PrevStrLen - 4] == CharTee )                  
            pNewPrefix[PrevStrLen - 4] = CharVLine;
        else MIDL_ASSERT( false );
        }

    gplistmgr Children;
    pClass->GetMembers( Children );
    
    //
    // Add return type for procs
    //
    CG_CLASS *pReturnType;
    if ( ( dynamic_cast<CG_PROC*>( pClass ) != NULL ) && 
         ( ( pReturnType = static_cast<CG_PROC*>( pClass )->GetReturnType()  ) != NULL ) )
        {
        Children.InsertHead( pReturnType );
        }

    CG_CLASS *pChild;
    CG_CLASS *pNext;
    ITERATOR_INIT( Children );
    if ( ITERATOR_GETNEXT( Children, pChild ) )
        {
        for(;;)
            {
            if ( ITERATOR_GETNEXT( Children, pNext ) )
                {
                //
                // Additional children follow
                //
                memcpy( pNewPrefixTail, StringTeeLine, sizeof(StringTeeLine));
                DoDumpCGClassGraph( pChild, pDumpMap, DumpSet, pNewPrefix );
                pChild = pNext;
                }
            else 
                {
                //
                // No more children
                //
                memcpy( pNewPrefixTail, StringElbowLine, sizeof(StringElbowLine) );
                DoDumpCGClassGraph( pChild, pDumpMap, DumpSet, pNewPrefix );
                break;
                }
            }
        }

    delete[] pNewPrefix;

}

void DoDumpCGClassGraph( CG_CLASS *pClass, CG_DUMP_MAP * pDumpMap = NULL )
{
    CG_DUMP_SET DumpSet;
    DoDumpCGClassGraph( pClass, pDumpMap, DumpSet, "");
    fprintf( stderr, "\n" );
}

void CG_CLASS::Dump( const char *pTitle )
{
    if ( pTitle )
        {
        fprintf( stderr, pTitle );
        fprintf( stderr, "\n" );        
        }

    CG_DUMP_MAP DumpMap;
    DoDumpCGClassList( this, &DumpMap );
    DoDumpCGClassGraph( this, &DumpMap );
}

#endif // MIDL_INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\frmtstr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    frmtstr.hxx

 Abstract:


 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

extern CMD_ARG          *   pCommand;

const char * pExprFormatCharNames[] = 
{
    ""
    ,"FC_EXPR_CONST32"
    ,"FC_EXPR_CONST64"
    ,"FC_EXPR_VAR"
    ,"FC_EXPR_OPER"
    ,"FC_EXPR_PAD"
};


const char * pFormatCharNames[] =
                {
                "",                         // FC_ZERO
                "FC_BYTE",
                "FC_CHAR",
                "FC_SMALL",
                "FC_USMALL",
                "FC_WCHAR",
                "FC_SHORT",
                "FC_USHORT",
                "FC_LONG",
                "FC_ULONG",
                "FC_FLOAT",
                "FC_HYPER",
                "FC_DOUBLE",

                "FC_ENUM16",
                "FC_ENUM32",
                "FC_IGNORE",
                "FC_ERROR_STATUS_T",

                "FC_RP",                    // 11
                "FC_UP",
                "FC_OP",
                "FC_FP",                    

                "FC_STRUCT",
                "FC_PSTRUCT",
                "FC_CSTRUCT",
                "FC_CPSTRUCT",
                "FC_CVSTRUCT",
                "FC_BOGUS_STRUCT",

                "FC_CARRAY",
                "FC_CVARRAY",
                "FC_SMFARRAY",
                "FC_LGFARRAY",
                "FC_SMVARRAY",
                "FC_LGVARRAY or FC_SPLIT",  // 20
                "FC_BOGUS_ARRAY",           

                "FC_C_CSTRING",
                "FC_C_BSTRING",
                "FC_C_SSTRING",
                "FC_C_WSTRING",
        
                "FC_CSTRING",
                "FC_BSTRING",
                "FC_SSTRING",
                "FC_WSTRING",               

                "FC_ENCAPSULATED_UNION",
                "FC_NON_ENCAPSULATED_UNION",

                "FC_BYTE_COUNT_POINTER",
    
                "FC_TRANSMIT_AS",
                "FC_REPRESENT_AS",

                "FC_IP",

                "FC_BIND_CONTEXT",          // 30
                "FC_BIND_GENERIC",
                "FC_BIND_PRIMITIVE",
                "FC_AUTO_HANDLE",
                "FC_CALLBACK_HANDLE",
                "FC_UNUSED1",
    
                "FC_POINTER",

                "FC_ALIGNM2",
                "FC_ALIGNM4",
                "FC_ALIGNM8",
                "FC_UNUSED2",
                "FC_UNUSED3",
                "FC_UNUSED4",           
        
                "FC_STRUCTPAD1",
                "FC_STRUCTPAD2",
                "FC_STRUCTPAD3",
                "FC_STRUCTPAD4",            // 40
                "FC_STRUCTPAD5",
                "FC_STRUCTPAD6",
                "FC_STRUCTPAD7",

                "FC_STRING_SIZED",
                "FC_UNUSED5",       

                "FC_NO_REPEAT",
                "FC_FIXED_REPEAT",
                "FC_VARIABLE_REPEAT",
                "FC_FIXED_OFFSET",
                "FC_VARIABLE_OFFSET",       
    
                "FC_PP",

                "FC_EMBEDDED_COMPLEX",

                "FC_IN_PARAM",
                "FC_IN_PARAM_BASETYPE",
                "FC_IN_PARAM_NO_FREE_INST",
                "FC_IN_OUT_PARAM",          // 50
                "FC_OUT_PARAM",
                "FC_RETURN_PARAM",          
                "FC_RETURN_PARAM_BASETYPE",

                "FC_DEREFERENCE",           // 54
                "FC_DIV_2",                 // 55
                "FC_MULT_2",                // 56
                "FC_ADD_1",                 // 57
                "FC_SUB_1",                 // 58
                "FC_CALLBACK",              // 59

                "FC_CONSTANT_IID",          // 5a

                "FC_END",                   // 5b
                "FC_PAD",                   // 5c

                "FC_EXPR",                  // 5d
                "FC_PARTIAL_IGNORE_PARAM",  // 5e, 
                "?",                        // 5f

                "?", "?", "?", "?", "?", "?", "?", "?",    // 60-67
                "?", "?", "?", "?", "?", "?", "?", "?",    // 68-6f

                "?", "?", "?", "?",         //  70-73
                "FC_SPLIT_DEREFERENCE",     // 74
                "FC_SPLIT_DIV_2",           // 75
                "FC_SPLIT_MULT_2",          // 76
                "FC_SPLIT_ADD_1",           // 77
                "FC_SPLIT_SUB_1",           // 78
                "FC_SPLIT_CALLBACK",        // 79
                "?", "?", "?", "?", "?", "?",  //  7a-7f

                "?", "?", "?", "?", "?", "?", "?", "?",    // 80-87
                "?", "?", "?", "?", "?", "?", "?", "?",    // 88-8f
                "?", "?", "?", "?", "?", "?", "?", "?",    // 90-97
                "?", "?", "?", "?", "?", "?", "?", "?",    // 98-9f
                "?", "?", "?", "?", "?", "?", "?", "?",    // a0-a7
                "?", "?", "?", "?", "?", "?", "?", "?",    // a8-af
            
                "?",                        // b0

                "FC_HARD_STRUCT",           

                "FC_TRANSMIT_AS_PTR",
                "FC_REPRESENT_AS_PTR",

                "FC_USER_MARSHAL",

                "FC_PIPE",

                "?",               // FC_BLKHOLE. obselete

                "FC_RANGE",                 // b7
                "FC_INT3264",               // b8
                "FC_UINT3264",              // b9

                // Post NT5.0

                "FC_CSARRAY",               // ba
                "FC_CS_TAG",                // bb

                "FC_STRUCTPADN",            // bc
                "FC_INT128",                // 0xbd
                "FC_UINT128",               // 0xbe
                "FC_FLOAT80",               // 0xbf
                "FC_FLOAT128",              // 0xc0
                "FC_BUFFER_ALIGN",          // 0xc1

                "FC_ENCAP_UNION",           // 0xc2
                
                // new 64bit array types
                "FC_FIX_ARRAY",             // 0xc3
                "FC_CONF_ARRAY",            // 0xc4
                "FC_VAR_ARRAY",             // 0xc5 
                "FC_CONFVAR_ARRAY",         // 0xc6 
                "FC_FIX_FORCED_BOGUS_ARRAY",// 0xc7  
                "FC_FIX_BOGUS_ARRAY",       // 0xc8 
                "FC_FORCED_BOGUS_ARRAY",    // 0xc9  

                "FC_CHAR_STRING",           // 0xca
                "FC_WCHAR_STRING",          // 0xcb
                "FC_STRUCT_STRING",         // 0xcc

                "FC_CONF_CHAR_STRING",      // 0xcd
                "FC_CONF_WCHAR_STRING",     // 0xce
                "FC_CONF_STRUCT_STRING",    // 0xcf

                // new structure types
                "FC_CONF_STRUCT",           // 0xd0
                "FC_CONF_PSTRUCT",          // 0xd1
                "FC_CONFVAR_STRUCT",        // 0xd2
                "FC_CONFVAR_PSTRUCT",       // 0xd3
                "FC_FORCED_BOGUS_STRUCT",   // 0xd4
                "FC_CONF_BOGUS_STRUCT",     // 0xd5
                "FC_FORCED_CONF_BOGUS_STRUCT",// 0xd7
                
                "FC_END_OF_UNIVERSE"        // 0xd8
                };


const char * pExprOpFormatCharNames[] = 
                {
                "",
                "OP_UNARY_PLUS",
                "OP_UNARY_MINUS",
                "OP_UNARY_NOT",
                "OP_UNARY_COMPLEMENT",
                "OP_UNARY_INDIRECTION",
                "OP_UNARY_CAST",
                "OP_UNARY_AND",
                "OP_UNARY_SIZEOF",
                "OP_UNARY_ALIGNOF",
                "OP_PRE_INCR",
                "OP_PRE_DECR",
                "OP_POST_INCR",
                "OP_POST_DECR",
                "OP_PLUS",
                "OP_MINUS",
                "OP_STAR",
                "OP_SLASH",
                "OP_MOD",
                "OP_LEFT_SHIFT",
                "OP_RIGHT_SHIFT",
                "OP_LESS",
                "OP_LESS_EQUAL",
                "OP_GREATER_EQUAL",
                "OP_GREATER",
                "OP_EQUAL",
                "OP_NOT_EQUAL",

                "OP_AND",
                "OP_OR",
                "OP_XOR",

                "OP_LOGICAL_AND",
                "OP_LOGICAL_OR",
                "OP_EXPRESSION",
                "",
                "",
                "", // function
                "", // param
                "", // pointsto
                "", // dot
                "", // index
                "", // comma
                "", // stmt
                "", // assign
                "OP_ASYNCSPLIT", // asyncsplit
                "OP_CORR_POINTER", // corr_pointer
                "OP_CORR_TOP_LEVEL", // corr_toplevel

                };

//
// This table is indexed by FORMAT_CHARACTER (see ndrtypes.h).
// To construct the correct name concatenate the name in this table with
// "Marshall", "Unmarshall", "BufferSize" etc.
//
char *      pNdrRoutineNames[] =
            {
            "",                             // FC_ZERO
            "NdrSimpleType",                // FC_BYTE
            "NdrSimpleType",                // FC_CHAR
            "NdrSimpleType",                // FC_SMALL
            "NdrSimpleType",                // FC_USMALL
            "NdrSimpleType",                // FC_WCHAR
            "NdrSimpleType",                // FC_SHORT
            "NdrSimpleType",                // FC_USHORT
            "NdrSimpleType",                // FC_LONG
            "NdrSimpleType",                // FC_ULONG
            "NdrSimpleType",                // FC_FLOAT
            "NdrSimpleType",                // FC_HYPER
            "NdrSimpleType",                // FC_DOUBLE

            "NdrSimpleType",                // FC_ENUM16
            "NdrSimpleType",                // FC_ENUM32
            "NdrSimpleType",                // FC_IGNORE
            "NdrSimpleType",                // FC_ERROR_STATUS_T

            "NdrPointer",                   // FC_RP
            "NdrPointer",                   // FC_UP
            "NdrPointer",                   // FC_OP
            "NdrPointer",                   // FC_FP

            "NdrSimpleStruct",              // FC_STRUCT
            "NdrSimpleStruct",              // FC_PSTRUCT
            "NdrConformantStruct",          // FC_CSTRUCT
            "NdrConformantStruct",          // FC_CPSTRUCT
            "NdrConformantVaryingStruct",   // FC_CVSTRUCT

            "NdrComplexStruct",             // FC_BOGUS_STRUCT

            "NdrConformantArray",           // FC_CARRAY
            "NdrConformantVaryingArray",    // FC_CVARRAY
            "NdrFixedArray",                // FC_SMFARRAY
            "NdrFixedArray",                // FC_LGFARRAY
            "NdrVaryingArray",              // FC_SMVARRAY
            "NdrVaryingArray",              // FC_LGVARRAY

            "NdrComplexArray",              // FC_BOGUS_ARRAY

            "NdrConformantString",          // FC_C_CSTRING
            "NdrConformantString",          // FC_C_BSTRING
            "NdrConformantString",          // FC_C_SSTRING
            "NdrConformantString",          // FC_C_WSTRING

            "NdrNonConformantString",       // FC_CSTRING
            "NdrNonConformantString",       // FC_BSTRING
            "NdrNonConformantString",       // FC_SSTRING
            "NdrNonConformantString",       // FC_WSTRING
        
            "NdrEncapsulatedUnion",         // FC_ENCAPSULATED_UNION
            "NdrNonEncapsulatedUnion",      // FC_NON_ENCAPSULATED_UNION

            "NdrByteCountPointer",          // FC_BYTE_COUNT_POINTER

            "NdrXmitOrRepAs",               // FC_TRANSMIT_AS
            "NdrXmitOrRepAs",               // FC_REPRESENT_AS

            "NdrInterfacePointer",          // FC_INTERFACE_POINTER

            "NdrContextHandle",             // FC_BIND_CONTEXT
            
            "?", "?", "?", "?", "?", "?", "?",         // 31-37
            "?", "?", "?", "?", "?", "?", "?", "?",    // 38-3f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 40-47
            "?", "?", "?", "?", "?", "?", "?", "?",    // 48-4f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 50-57

            "?", "?", "?",                             // 58-5a
            "?", "?",                        // FC_END & FC_PAD
            "?", "?", "?",                             // 5d-5f

            "?", "?", "?", "?", "?", "?", "?", "?",    // 60-67
            "?", "?", "?", "?", "?", "?", "?", "?",    // 68-6f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 70-77
            "?", "?", "?", "?", "?", "?", "?", "?",    // 78-7f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 80-87
            "?", "?", "?", "?", "?", "?", "?", "?",    // 88-8f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 90-97
            "?", "?", "?", "?", "?", "?", "?", "?",    // 98-9f
            "?", "?", "?", "?", "?", "?", "?", "?",    // a0-a7
            "?", "?", "?", "?", "?", "?", "?", "?",    // a8-af

            "?",                                       // 0xb0

            "NdrHardStruct",                // FC_HARD_STRUCT

            "NdrXmitOrRepAs",               // FC_TRANSMIT_AS_PTR
            "NdrXmitOrRepAs",               // FC_REPRESENT_AS_PTR

            "NdrUserMarshal",               // FC_USER_MARSHAL

            "NdrPipe",                      // FC_PIPE

            0,                              // FC_BLKHOLE

            0,                              // FC_RANGE
            "NdrSimpleType",                // FC_INT3264
            "NdrSimpleType",                // FC_UINT3264

            "NdrCsArray",                   // FC_CSARRAY
            "NdrCsTag",                     // FC_CS_TAG

            0
            };

// ============================================================================
//
//   FORMAT_STRING class, general comments on fragment optimization.
//
//   There are 3 type of offsets that matter a lot when format string fragments
//   are optimized. These are absolute type offsets, relative type offsets and
//   stack (or field) offsets.
//
//   - Absolute type offsets are offsets from the proc format string to type 
//   format string. For 32b implementation they are limited to ushort32 range.
//   An absolute type offset indicates a type of a parameter.
//   Note that there is only one absolute type offset for a parameter regardless
//   of the platform.
//
//   - Relative type offsets are offsets within the type format string. 
//   For 32b implementation they are limited to short32 range.
//   A relative type offset indicates a type of a component for a compund type.
//   Note that there is only one relative type offset for a field or element 
//   regardless of the platform.
//
//   - Stack offset is a stack offset to a parameter within a proc stack or 
//   a field offset to a field within a struct.
//   For a 32b implementation stack offsets are limited to a short32 range. This
//   is because some of these offsets are relative to a current position within
//   a struct or union. They have been clampd together because of correlation
//   descriptors may have stack or field offsets.
//   Proper stack offsets actually come in a ushort and usmall range variaty. 
//   Proper field offsets come in as shorts. 
//   For a given position in the format string, there is a set of stack offsets
//   as in general a x86 stack offset is different from other platform offsets
//   and a field offset may be different as well.
//   
//   Proc format string uses only absolute type offsets and stack offsets.
//

// the constructor
FORMAT_STRING::FORMAT_STRING()
{
    // Allocate the buffer and align it on a short boundary.
    pBuffer = (unsigned char *) new short[ DEFAULT_FORMAT_STRING_SIZE / 2 ];

    // Allocate the cousin buffer type array.  This does not need to
    // be aligned.
    pBufferType = new unsigned char[ DEFAULT_FORMAT_STRING_SIZE ];

    memset( pBuffer,     0,                   DEFAULT_FORMAT_STRING_SIZE );
    memset( pBufferType, FS_FORMAT_CHARACTER, DEFAULT_FORMAT_STRING_SIZE );

    BufferSize = DEFAULT_FORMAT_STRING_SIZE;
    CurrentOffset = 0;
    LastOffset = 0;
    pReuseDict = new FRMTREG_DICT( this );
}

void
FORMAT_STRING::CheckSize()
/*++

Routine Description :
    
    Reallocates a new format string buffer if the current buffer is within
    4 bytes of overflowing.

Arguments :
    
    None.

 --*/
{
    //
    // Allocate a new buffer if we're within 4 bytes of
    // overflowing the current buffer.
    //
    if ( CurrentOffset + 3 > BufferSize )
        {
        unsigned char * pBufferNew;

        // double the Buffer size
        pBufferNew = (unsigned char *) new short[ BufferSize ];

        memcpy( pBufferNew,
                pBuffer,
                (unsigned int) BufferSize );
        memset( pBufferNew + BufferSize, 0, BufferSize );

        delete pBuffer;
        pBuffer = pBufferNew;

        // double the BufferType size
        pBufferNew = (unsigned char *) new short[ BufferSize ];

        memcpy( pBufferNew,
                pBufferType,
                (unsigned int) BufferSize );
        memset( pBufferNew + BufferSize, FS_FORMAT_CHARACTER, BufferSize );

        delete pBufferType;
        pBufferType = pBufferNew;
        
        BufferSize *= 2;
        }
}

//
// Push a short type-fmt-string offset at the current offset.
// This is used as the offset from a parameter into type format string.
// For 32b code, this needs to be a value within an unsigned short.
// We use a long value internally for better fragment optimization.
//
void    
FORMAT_STRING::PushShortTypeOffset( long s )
{
    CheckSize();

    if ( s < 0  ||  s > _UI16_MAX )
        {
//        CG_NDR * pNdr = pCCB->GetLastPlaceholderClass();
        CG_NDR * pNdr = 0;
        char *   pName = pNdr ? pNdr->GetSymName() 
                              : "";
        RpcError(NULL, 0, FORMAT_STRING_LIMITS, pName );
        exit( FORMAT_STRING_LIMITS );
        }

    pBufferType[CurrentOffset] = FS_SHORT_TYPE_OFFSET;
    pBufferType[CurrentOffset+1] = FS_SMALL;
    *((unsigned short UNALIGNED *)(pBuffer + CurrentOffset)) = (unsigned short)s;

    TypeOffsetDict.Insert( (long) CurrentOffset, s );

    IncrementOffset(2);
}

//
// Push a short offset at the current offset.
// This is the relative type offset within the type string.
// For 32b code, this needs to be a value within a signed short, eventually.
// We use a long value internally for better fragment optimization.
//
void    
FORMAT_STRING::PushShortOffset( long TypeOffset )
{
    CheckSize();

    // We don't check the range for the offset here for better optimization.

    pBufferType[ CurrentOffset     ] = FS_SHORT_OFFSET;
    pBufferType[ CurrentOffset + 1 ] = FS_SMALL;
    *((short UNALIGNED *)(pBuffer + CurrentOffset)) = (short)TypeOffset;

    TypeOffsetDict.Insert( (long) CurrentOffset, TypeOffset );

    IncrementOffset(2);
}

// This an auxilary method to handle relative offsets.
// It is used when we need to write out an offset temporarily and then fix it 
// later, for example in pointers, structs etc.
// 
void    
FORMAT_STRING::PushShortOffset( long TypeOffset, long Position )
{
    // We don't check the range for the offset here for better optimization.

    pBufferType[ Position     ] = FS_SHORT_OFFSET;
    pBufferType[ Position + 1 ] = FS_SMALL;
    *((short UNALIGNED *)(pBuffer + Position)) = (short)TypeOffset;

    TypeOffsetDict.Insert( Position, TypeOffset );
}


//
// Push a stack size or an absolute offset.
//
void
FORMAT_STRING::PushUShortStackOffsetOrSize( 
    long X86Offset )
{
    CheckSize();

    if ( X86Offset   < 0  ||  X86Offset   > _UI16_MAX )
        {
        //  Make it a warning with a name.

//        CG_NDR * pNdr = pCCB->GetLastPlaceholderClass();
        CG_NDR * pNdr = 0;
        char *   pName = pNdr ? pNdr->GetSymName() 
                              : "";
        RpcError(NULL, 0, STACK_SIZE_TOO_BIG, pName );
        exit( FORMAT_STRING_LIMITS );
        }

    pBufferType[CurrentOffset] = FS_SHORT_STACK_OFFSET;
    pBufferType[CurrentOffset+1] = FS_SMALL;
    *((short UNALIGNED *)(pBuffer + CurrentOffset)) = (short) X86Offset;

#if defined(RKK_FRAG_OPT)
        {
        printf("PushShortStackOffset CurrentOffset %d\n", CurrentOffset );
        int offLow = CurrentOffset - 10; if (offLow < 0) offLow = 0;
        int offHig = CurrentOffset + 10;
        printf("    off=%d ", offLow );
        for (int off = offLow; off < offHig; off++)
            printf("%02x ", pBuffer[ off ]);
        printf( "\n" );
        printf("    off=%d ", offLow );
        for (    off = offLow; off < offHig; off++)
            printf("%02x ", pBufferType[ off ]);
        printf( "\n" );
    }
#endif

    OffsetDict.Insert( (long) CurrentOffset, 
                       X86Offset );

    IncrementOffset(2);
}

//
// Push a stack offset. 
// Needs to be relative because of offsets in structs etc.
//
void
FORMAT_STRING::PushShortStackOffset( 
    long X86Offset )
{
    CheckSize();

    if ( X86Offset   < _I16_MIN  ||  X86Offset   > _I16_MAX )
        {
        //  Make it a warning with a name.

//        CG_NDR * pNdr = pCCB->GetLastPlaceholderClass();
        CG_NDR * pNdr = 0;
        char *   pName = pNdr ? pNdr->GetSymName() 
                              : "";
        RpcError(NULL, 0, FORMAT_STRING_LIMITS, pName );
        exit( FORMAT_STRING_LIMITS );
        }

    pBufferType[CurrentOffset] = FS_SHORT_STACK_OFFSET;
    pBufferType[CurrentOffset+1] = FS_SMALL;
    *((short UNALIGNED *)(pBuffer + CurrentOffset)) = (short) X86Offset;

#if defined(RKK_FRAG_OPT)
        {
        printf("PushShortStackOffset CurrentOffset %d\n", CurrentOffset );
        int offLow = CurrentOffset - 10; if (offLow < 0) offLow = 0;
        int offHig = CurrentOffset + 10;
        printf("    off=%d ", offLow );
        for (int off = offLow; off < offHig; off++)
            printf("%02x ", pBuffer[ off ]);
        printf( "\n" );
        printf("    off=%d ", offLow );
        for (    off = offLow; off < offHig; off++)
            printf("%02x ", pBufferType[ off ]);
        printf( "\n" );
    }
#endif

    OffsetDict.Insert( (long) CurrentOffset, 
                       X86Offset );

    IncrementOffset(2);
}

// =============================================================================
//
//  Helper routines writing comments about some tokens.
//

__inline void
Out_PointerFlags(
    ISTREAM *           pStream,
    unsigned char *     pFlags
    )
{
    if ( *pFlags & FC_ALLOCATE_ALL_NODES )
        pStream->Write( " [all_nodes]");
    if ( *pFlags & FC_DONT_FREE )
        pStream->Write( " [dont_free]");
    if ( *pFlags & FC_ALLOCED_ON_STACK )
        pStream->Write( " [alloced_on_stack]");
    if ( *pFlags & FC_SIMPLE_POINTER )
        pStream->Write( " [simple_pointer]");
    if ( *pFlags & FC_POINTER_DEREF )
        pStream->Write( " [pointer_deref]");
}

__inline void
Out_OldProcFlags(
    ISTREAM *           pStream,
    unsigned char *     pFlags
    )
{
    INTERPRETER_FLAGS * pOiFlags = (INTERPRETER_FLAGS *)pFlags;

    if ( pOiFlags->FullPtrUsed )
        pStream->Write( " full ptr,");
    if ( pOiFlags->RpcSsAllocUsed )
        pStream->Write( " DCE mem package,");
    if ( pOiFlags->ObjectProc )
        {
        pStream->Write( " object,");
        if ( pOiFlags->IgnoreObjectException )
            pStream->Write( " ignore obj exc,");
        if ( pOiFlags->HasCommOrFault )
            pStream->Write( " Oi2");
        }
    else
        {
        if ( pOiFlags->IgnoreObjectException )
            pStream->Write( " encode,");
        if ( pOiFlags->HasCommOrFault )
            pStream->Write( " comm or fault/decode");
        }
}

__inline void
Out_Oi2ProcFlags(
    ISTREAM *           pStream,
    unsigned char *     pFlags
    )
{
    INTERPRETER_OPT_FLAGS * pOi2Flags = (INTERPRETER_OPT_FLAGS *)pFlags;

    if ( pOi2Flags->ServerMustSize )
        pStream->Write( " srv must size,");
    if ( pOi2Flags->ClientMustSize )
        pStream->Write( " clt must size,");
    if ( pOi2Flags->HasReturn )
        pStream->Write( " has return,");
    if ( pOi2Flags->HasPipes )
        pStream->Write( " has pipes,");
    if ( pOi2Flags->HasAsyncUuid )
        pStream->Write( " has async uuid,");
    if ( pOi2Flags->HasExtensions )
        pStream->Write( " has ext,");
    if ( pOi2Flags->HasAsyncHandle )
        pStream->Write( " has async handle");
}

__inline void
Out_ExtProcFlags(
    ISTREAM *           pStream,
    unsigned char *     pFlags
    )
{
    INTERPRETER_OPT_FLAGS2 * pExtFlags = (INTERPRETER_OPT_FLAGS2 *)pFlags;

    if ( pExtFlags->HasNewCorrDesc )
        pStream->Write( " new corr desc,");
    if ( pExtFlags->ClientCorrCheck )
        pStream->Write( " clt corr check,");
    if ( pExtFlags->ServerCorrCheck )
        pStream->Write( " srv corr check,");
    if ( pExtFlags->HasNotify )
        pStream->Write( " has notify");
    if ( pExtFlags->HasNotify2 )
        pStream->Write( " has notify_flag");
    if ( pExtFlags->HasComplexReturn )
        pStream->Write( " has complex return");
}

__inline void
Out_ParameterFlags(
    ISTREAM *           pStream,
    PARAM_ATTRIBUTES *  pParamAttr
    )
{
    char Buf[8];

    if ( pParamAttr->MustSize )
        pStream->Write( " must size,");
    if ( pParamAttr->MustFree )
        pStream->Write( " must free,");
    if ( pParamAttr->IsPipe )
        pStream->Write( " pipe,");
    if ( pParamAttr->IsIn )
        pStream->Write( " in,");
    if ( pParamAttr->IsOut )
        pStream->Write( " out,");
    if ( pParamAttr->IsReturn )
        pStream->Write( " return,");
    if ( pParamAttr->IsBasetype )
        pStream->Write( " base type,");
    if ( pParamAttr->IsByValue )
        pStream->Write( " by val,");
    if ( pParamAttr->IsSimpleRef )
        pStream->Write( " simple ref,");
    if ( pParamAttr->IsDontCallFreeInst )
        pStream->Write( " dont call free inst,");
    if ( pParamAttr->IsForceAllocate )
        pStream->Write( " force allocate," );
    if ( pParamAttr->SaveForAsyncFinish )
        pStream->Write( " split async,");
    if ( pParamAttr->ServerAllocSize )
        {
        pStream->Write( " srv alloc size=");
        pStream->Write( MIDL_ITOA( 8 * pParamAttr->ServerAllocSize, Buf, 10) );
        }
}

__inline void
Out_CorrelationType(
    ISTREAM *           pStream,
    unsigned char *     pCorrType
    )
{
    unsigned char   CorrType = *pCorrType;

    if ( CorrType & FC_NORMAL_CONFORMANCE )
        pStream->Write( " field, ");
    if ( CorrType & FC_POINTER_CONFORMANCE )
        pStream->Write( " field pointer, ");
    if ( CorrType & FC_TOP_LEVEL_CONFORMANCE )
        pStream->Write( " parameter, ");
    if ( CorrType & FC_TOP_LEVEL_MULTID_CONFORMANCE )
        pStream->Write( " multidim parameter, ");

    if ( CorrType & FC_CONSTANT_CONFORMANCE )
        {
        unsigned long    ConstVal;
                 char    Buf[12];

        pStream->Write( " constant, val=");
        // next three bytes: just a weird way of generating it
        ConstVal = (ulong) pCorrType[1] << 16;
        ConstVal |= *(unsigned short UNALIGNED *)( pCorrType + 2);
        pStream->Write( MIDL_ITOA( ConstVal, Buf, 10) );
        }
    else
        {
        pStream->Write( pFormatCharNames[ CorrType & 0xf ] );
        }
}

__inline void
Out_CorrelationFlags(
    ISTREAM *           pStream,
    unsigned char *     pNewCorrFlags
    )
{
    NDR_CORRELATION_FLAGS *  pCorrFlags = (NDR_CORRELATION_FLAGS *)pNewCorrFlags;

    if ( pCorrFlags->Early )
        pStream->Write( " early," );
    if ( pCorrFlags->Split )
        pStream->Write( " split," );
    if ( pCorrFlags->IsIidIs )
        pStream->Write( " iid_is," );
    if ( pCorrFlags->DontCheck )
        pStream->Write( " dont check" );
}

__inline void
Out_ContextHandleFlags(
    ISTREAM *           pStream,
    unsigned char *     pContextFlags
    )
{
    PNDR_CONTEXT_HANDLE_FLAGS   pFlags = (PNDR_CONTEXT_HANDLE_FLAGS)pContextFlags;

    if ( pFlags->IsViaPtr )
        pStream->Write( " via ptr," );
    if ( pFlags->IsIn )
        pStream->Write( " in," );
    if ( pFlags->IsOut )
        pStream->Write( " out," );
    if ( pFlags->IsReturn )
        pStream->Write( " ret," );
    if ( pFlags->IsStrict )
        pStream->Write( " strict," );
    if ( pFlags->NoSerialize )
        pStream->Write( " no serialize," );
    if ( pFlags->Serialize )
        pStream->Write( " serialize," );
    if ( pFlags->CannotBeNull)
        pStream->Write( " can't be null" );
}


__inline void
Out_SmallStackSize(
    ISTREAM *   pStream,
    long        StackSize,
    char *      pEnvComment
    )
{
    char    Buf[102];
    
    //
    // Non-Alpha stack size.
    //
    pStream->Write( "0x" );
    pStream->Write( MIDL_ITOA(StackSize, Buf, 16) );
    pStream->Write( ",\t\t/* ");
    pStream->Write( pEnvComment );
    pStream->Write( " stack size = ");
    pStream->Write( MIDL_ITOA(StackSize, Buf, 10) );
    pStream->Write( " */");

}

// The comment table is initialized in FORMAT_STRING::Output as appropriate 
// for a given environment { 64b, 32b, others }.
// The comments correspond to the ifdef situation described below.

static char *  Env64Comment = "ia64";
static char *  Env32Comment = "x86";
static char *  OtherEnvComment = "";


__inline void
Out_ShortStackOffset(
    ISTREAM *           pStream,
    OffsetDictElem *    pStackOffsets,
    char *              EnvComment
    )
{
    char    Buf[102];

    //
    // Emit the main (x86 or ia64) offset.
    //

    unsigned long  OffsetValue = pStackOffsets->X86Offset;

    pStream->Write( "NdrFcShort( 0x" );
    pStream->Write( MIDL_ITOA( OffsetValue, Buf, 16) );
    pStream->Write( " ),\t/* " );
    pStream->Write( EnvComment );
    pStream->Write( " Stack size/offset = " );
    pStream->Write( MIDL_ITOA( OffsetValue, Buf, 10) );
    pStream->Write( " */");
}


void
FORMAT_STRING::Output(
    ISTREAM *           pStream,
    char *              pTypeName,
    char *              pName,
    RepAsPadExprDict *  pPadDict,
    RepAsSizeDict    *  pSizeDict )
/*++

Routine Description :
    
    Outputs the format string structure.

Arguments :
    
    pStream             - Stream to output the format string to.

 --*/
{
    long                    Offset;
    long                    LastPrinted = 0;
    char                    Buf[102];
    BOOL                    InPP = FALSE;
    REP_AS_PAD_EXPR_DESC *  pPadExprDesc;
    REP_AS_SIZE_DESC     *  pSizeDesc;
    char *                  pComment;
    BOOL                    fLimitErr = FALSE;

    pStream->NewLine();
    pStream->Write( "static const " );
    pStream->Write( pTypeName );
    pStream->Write( ' ' );
    pStream->Write( pName );
    pStream->Write( " =");
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( "0," );
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();

    // Reset the pad and size macro dictionaries

    pPadExprDesc = pPadDict->GetFirst();
    pSizeDesc    = pSizeDict->GetFirst();

    pStream->IndentDec();
    pStream->IndentDec();
    pStream->IndentDec();

    BOOL f32 = pCommand->GetEnv() == ENV_WIN32;
    BOOL f64 = pCommand->GetEnv() == ENV_WIN64;

    char * EnvComment;

    if ( f32 )
        {
        EnvComment   = Env32Comment;
        }
    else if ( f64 )
        {
        EnvComment   = Env64Comment;
        }
    else
        {
        EnvComment   = OtherEnvComment;
        }


    for ( Offset = 0; Offset < (long)LastOffset; )
        {
        pStream->NewLine();

        pComment = CommentDict.GetComments( Offset );

        if ( pComment )
            pStream->Write( pComment );

        if ( ! (Offset % 2) && ( Offset != LastPrinted ) )
            {
            sprintf(Buf,"/* %2d */\t",Offset);
            LastPrinted = Offset;
            pStream->Write(Buf);
            }
        else
            {
            pStream->Write("\t\t\t");
            }

        switch ( pBufferType[Offset] )
            {
            case FS_FORMAT_CHARACTER :
                // Make the format string readable.
                switch ( pBuffer[Offset] )
                    {
                    case FC_IN_PARAM :
                    case FC_IN_OUT_PARAM :
                    case FC_PARTIAL_IGNORE_PARAM :
                    case FC_OUT_PARAM :
                    case FC_RETURN_PARAM :
                    case FC_STRUCT :
                    case FC_PSTRUCT :
                    case FC_CSTRUCT :
                    case FC_CPSTRUCT :
                    case FC_CVSTRUCT :
                    case FC_BOGUS_STRUCT :
                    case FC_NO_REPEAT :
                    case FC_FIXED_REPEAT :
                    case FC_VARIABLE_REPEAT :
                    case FC_CARRAY :
                    case FC_CVARRAY :
                    case FC_SMFARRAY :
                    case FC_LGFARRAY :
                    case FC_SMVARRAY :
                    case FC_LGVARRAY :
                    case FC_BOGUS_ARRAY :
                    case FC_C_CSTRING :
                    case FC_C_SSTRING :
                    case FC_C_WSTRING :
                    case FC_CSTRING :
                    case FC_SSTRING :
                    case FC_WSTRING :
                    case FC_ENCAPSULATED_UNION :
                    case FC_NON_ENCAPSULATED_UNION :
                    case FC_IP :
                        pStream->NewLine();
                        pStream->Write("\t\t\t");
                        break;

                    case FC_RP :
                    case FC_UP :
                    case FC_OP :
                    case FC_FP :
                        //
                        // If we're not in a pointer layout, and the previous
                        // format char was not a param/result char then print
                        // a new line.
                        //
                        if  ( ! InPP &&
                              ( Offset &&
                                pBuffer[Offset - 1] != FC_IN_PARAM &&
                                pBuffer[Offset - 1] != FC_IN_OUT_PARAM &&
                                pBuffer[Offset - 1] != FC_PARTIAL_IGNORE_PARAM &&
                                pBuffer[Offset - 1] != FC_OUT_PARAM &&
                                pBuffer[Offset - 1] != FC_IN_PARAM_NO_FREE_INST &&
                                pBuffer[Offset - 1] != FC_RETURN_PARAM    )
                            )
                            {
                            pStream->NewLine();
                            pStream->Write("\t\t\t");
                            }
                        break;

                    case FC_PP :
                        InPP = TRUE;
                        pStream->NewLine();
                        pStream->Write("\t\t\t");
                        break;

                    case FC_END :
                        if ( InPP )
                            {
                            pStream->NewLine();
                            pStream->Write("\t\t\t");
                            }
                        break;

                    default:
                        break;
                    }

                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset], Buf, 16 ) );
                pStream->Write( ",\t\t/* ");
                pStream->Write( pFormatCharNames[pBuffer[Offset]] );
                pStream->Write( " */");

                if ( (pBuffer[Offset] == FC_END) && InPP )
                    {
                    pStream->NewLine();
                    InPP = FALSE;
                    }

                Offset++;
                break;

            case FS_POINTER_FORMAT_CHARACTER :
                //
                // If we're not in a pointer layout, and the previous
                // format char was not a param/result char then print
                // a new line.
                //
                if  ( ! InPP &&
                      ( Offset &&
                        pBuffer[Offset - 1] != FC_IN_PARAM &&
                        pBuffer[Offset - 1] != FC_IN_OUT_PARAM &&
                        pBuffer[Offset - 1] != FC_PARTIAL_IGNORE_PARAM &&
                        pBuffer[Offset - 1] != FC_OUT_PARAM &&
                        pBuffer[Offset - 1] != FC_RETURN_PARAM    )
                    )
                    {
                    pStream->NewLine();
                    pStream->Write("\t\t\t");
                    }

                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset], Buf, 16 ) );
                pStream->Write( ", 0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset + 1] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t/* ");
                pStream->Write( pFormatCharNames[pBuffer[Offset]] );
                Out_PointerFlags( pStream, pBuffer + Offset + 1 );
                pStream->Write( " */");

                Offset += 2;
                break;

            case FS_SMALL :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t\t/* ");
                pStream->Write( MIDL_ITOA( pBuffer[Offset], Buf, 10 ) );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_OLD_PROC_FLAG_BYTE :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t\t/* Old Flags: ");
                Out_OldProcFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_Oi2_PROC_FLAG_BYTE :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t\t/* Oi2 Flags: ");
                Out_Oi2ProcFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_EXT_PROC_FLAG_BYTE :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t\t/* Ext Flags: ");
                Out_ExtProcFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_CORR_TYPE_BYTE :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );                
                pStream->Write( ",\t\t/* Corr desc: ");
                Out_CorrelationType( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_CONTEXT_HANDLE_FLAG_BYTE :
                pStream->Write( "0x" );

                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );                
                pStream->Write( ",\t\t/* Ctxt flags: ");
                Out_ContextHandleFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_SHORT :
                pStream->Write( "NdrFcShort( 0x" );
                pStream->Write(
                    MIDL_ITOA( *((unsigned short UNALIGNED *)(pBuffer+Offset)), Buf, 16));
                pStream->Write( " ),\t/* ");
                pStream->Write(
                    MIDL_ITOA(*((short UNALIGNED *)(pBuffer+Offset)), Buf, 10));
                pStream->Write( " */");

                Offset += 2;
                break;
        
            case FS_MAGIC_UNION_SHORT :
                pStream->Write( "NdrFcShort( 0x" );
                pStream->Write(
                        MIDL_ITOA( *((unsigned short UNALIGNED *)(pBuffer+Offset)), Buf, 16));
                pStream->Write( " ),\t/* Simple arm type: ");
                pStream->Write( pFormatCharNames[ pBuffer[Offset] ]  
                                    ?  pFormatCharNames[ pBuffer[Offset] ]
                                    : "" );
                pStream->Write( " */");

                Offset += 2;
                break;
        
            case FS_PARAM_FLAG_SHORT :
                pStream->Write( "NdrFcShort( 0x" );
                pStream->Write( 
                    MIDL_ITOA( *((unsigned short UNALIGNED *)(pBuffer + Offset)), Buf, 16));
                pStream->Write( " ),\t/* Flags: ");
                Out_ParameterFlags( pStream, (PARAM_ATTRIBUTES *)(pBuffer + Offset) );
                pStream->Write( " */");

                Offset += 2;
                break;
        
            case FS_CORR_FLAG_SHORT :
                pStream->Write( "NdrFcShort( 0x" );
                pStream->Write( 
                    MIDL_ITOA( *((unsigned short UNALIGNED *)(pBuffer + Offset)), Buf, 16));
                pStream->Write( " ),\t/* Corr flags: ");
                Out_CorrelationFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset += 2;
                break;
        
            case FS_SHORT_OFFSET :
                {
                // The relative type offset.

                TypeOffsetDictElem  *   pTO;
                long                    ItsOffset; 
                    
                ItsOffset = *((short UNALIGNED *)(pBuffer + Offset));
        
                pTO = TypeOffsetDict.LookupOffset( Offset );

                if ( pTO->TypeOffset != ItsOffset  ||
                     pTO->TypeOffset < UNION_OFFSET16_MIN )
                    {
                    pStream->Write( "Relative type offset out of range" );
                    pStream->NewLine();
                    RpcError(NULL, 0, FORMAT_STRING_LIMITS, "" );
                    fLimitErr = TRUE;
                    }
                
                if ( 0 == ( pTO->TypeOffset + Offset )  ||
                    -1 == ( pTO->TypeOffset + Offset ) )
                    {
                    fprintf( stdout, "  MIDL_fixup: Invalid offset at %d\n", Offset );
                    RpcError( NULL, 0, FORMAT_STRING_OFFSET_IS_ZERO, "" );
                    }

                pStream->Write( "NdrFcShort( 0x" );
                pStream->Write( MIDL_ITOA( ItsOffset, Buf, 16 ) );
                pStream->Write( " ),\t/* Offset= ");
                pStream->Write( MIDL_ITOA(