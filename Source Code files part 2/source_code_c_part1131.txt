         50
#define IDS_TEMPLATEFILES_INTEL         51
#define IDS_TEMPLATEFILES_ALPHA         52
#define IDS_LARGEFONTNAME               53
#define IDS_NORMALFONTNAME              55
#define IDS_INTEL                       56
#define IDS_AND                         57
#define IDS_ALPHA                       58
#define IDS_CREATINGDIRECTORYTREE       59
#define IDS_COPYINGFILES                60
#define IDS_UPDATINGREGISTRY            61
#define IDS_BUILDINGFILELIST            62
#define IDI_SETUP                       97
#define IDB_WATERMARK16                 98
#define IDB_WATERMARK256                99
#define IDB_BUTTON                      100
#define IDD_WELCOME                     101
#define IDD_FINISH                      102
#define IDD_SETUPDIR                    103
#define IDD_INFO                        104
#define IDD_SETUP                       105
#define IDD_RBDIRECTORY                 106
#define IDD_OS                          107
#define IDD_SETUPFAILED                 108
#define IDC_L_SETUP                     1000
#define IDC_E_RBPATH                    1001
#define IDC_E_SOURCEPATH                1002
#define IDC_B_BROWSE                    1003
#define IDC_P_METER                     1004
#define IDC_S_OPERATION                 1005
#define IDC_C_INTEL                     1006
#define IDC_C_ALPHA                     1007
#define IDC_DIVIDER                     1008
#define IDC_S_BOLD1                     1009
#define IDC_S_BOLD3                     1010
#define IDC_S_BOLD2                     1011
#define IDC_S_TITLE1                    1012
#define IDC_S_TITLE2                    1013
#define IDC_S_TITLE3                    1014
#define IDC_I_BUTTON1                   1015
#define IDC_I_BUTTON2                   1016
#define IDC_I_BUTTON3                   1017
#define IDC_I_BUTTON4                   1018
#define IDC_I_BUTTON5                   1019
#define IDC_I_BUTTON6                   1020
#define IDC_I_BUTTON7                   1021
#define IDC_E_OSNAME                    1022
#define IDC_G_OPERATION                 1023
#define IDC_S_SOURCEPATH                1024
#define IDC_S_CLIENTS                   1025
#define IDC_S_REMOTEBOOT                1026
#define IDC_S_PLATFORM                  1027

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\client\pch.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: PCH.H

  Precompiled header file for RBSETUP.
 
 ***************************************************************************/

#define UNICODE

#if DBG == 1
#define DEBUG
#endif

#include <windows.h>

#include "debug.h"
#include "resource.h"

extern HINSTANCE g_hinstance;

// Global macros
#define ARRAYSIZE( _x ) ( sizeof( _x ) / sizeof( _x[ 0 ] ) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\client\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rbclient.rc
//
#define IDS_FILESTOBECOPIED             1
#define IDS_DOSNETINFFILENAME           2
#define IDS_INTELPATH                   3
#define IDS_BOOTLOADER                  4
#define IDS_IMAGES                      5
#define IDS_SETUP                       6
#define IDS_REG_BINL_PARAMETER          7
#define IDS_BOOTINI                     8
#define IDS_WINNTSIF                    9
#define IDS_REMOTEBOOT                  10
#define IDS_BOOTFILENAME                11
#define IDS_BOOTINIOPTIONS              12
#define IDS_WINNTTEMPLATEFILES          13
#define IDS_TEMPLATES                   14
#define IDD_CLIENT                      101
#define IDC_E_MAC                       1000
#define IDC_E_MACHINENAME               1001
#define IDC_E_SERVER                    1002
#define IDC_E_BOOTFILE                  1003
#define IDC_E_BOOTFILENAME              1003
#define IDC_E_REMOTEBOOT                1004
#define IDC_E_BOOTINIOPTIONS            1005
#define IDC_CB_INSTALLATION             1006
#define IDC_E_CLIENTDOMAIN              1007
#define IDC_E_ADMINUSER                 1008
#define IDC_E_ADMINPASSWD               1009
#define IDC_CB_WINNTSIF                 1010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\client\main.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include "pch.h"

#include <windowsx.h>
#include <setupapi.h>
#include <advpub.h>
#include <regstr.h>
#include <lm.h>

#include "utils.h"

DEFINE_MODULE("Main");

// Globals
HINSTANCE g_hinstance = NULL;

#define SMALL_BUFFER_SIZE   256
#define MAX_FILES_SIZE      512
#define STRING_BUFFER_SIZE  65535

static TCHAR g_szServerName[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szRemoteBoot[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szBootFilename[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szBootIniOptions[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szClientName[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szMAC[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szInstallation[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szClientDomain[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szAdminUser[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szAdminPasswd[ SMALL_BUFFER_SIZE ] = { 0 };
static TCHAR g_szWinntTemplate[ SMALL_BUFFER_SIZE ] = { 0 };


// search and replace structure
typedef struct {
    LPTSTR  pszToken;
    LPTSTR  pszString;
} SAR, * LPSAR;

//
// Searches and replaces text.
//
// NOTE: There is no check for writing beyond the buffer even though
//       I passed the paramater.
//
void
SearchAndReplace( 
    LPSAR psarList, 
    LPTSTR pszString, 
    DWORD dwSize )
{
    LPTSTR psz = pszString;

    if ( !psarList || !pszString )
        return;

    while ( *psz )
    {
        if ( *psz == TEXT('%') )
        {
            LPSAR psar = psarList;
            
            psz++;  // move forward

            while( psar->pszToken )
            {
                int iCmp;
                DWORD  dwString = lstrlen( psar->pszString );
                DWORD  dwToken  = lstrlen( psar->pszToken );
                LPTSTR pszTemp  = psz + dwToken;
                TCHAR ch = *pszTemp;
                *pszTemp = 0;

                iCmp = lstrcmpi( psz, psar->pszToken );

                *pszTemp = ch;

                if ( !iCmp )
                {   // match, so replace
                    psz--;  // move back

                    if ( 2 + dwToken < dwString )
                    {
                        DWORD dwLen = lstrlen( &psz[ 2 + dwToken ] ) + 1;
                        MoveMemory( &psz[ dwString ], &psz[ 2 + dwToken ], dwLen * sizeof(TCHAR));
                    }

                    CopyMemory( psz, psar->pszString, dwString * sizeof(TCHAR) );

                    if ( 2 + dwToken > dwString )
                    {
                        lstrcpy( &psz[ dwString ], &psz[ 2 + dwToken ] );
                    }

                    psz++;  // move forward
                    break;
                }

                psar++;
            }
        }
        else
        {
            psz++;
        }
    }
}

//
// Munge the registry
//
LONG
MungeRegistry( 
    LPCTSTR pszPath, 
    LPCTSTR pszKey, 
    LPTSTR  pszResult, 
    LPDWORD pdwSize )
{
    HKEY  hkeyComputer;
    LONG  lResult;

    lResult = RegOpenKey( HKEY_LOCAL_MACHINE, 
                          pszPath, 
                          &hkeyComputer );
    if ( lResult != ERROR_SUCCESS )
        goto Finish;

    lResult = RegQueryValueEx( hkeyComputer,
                               pszKey, 
                               NULL,    // reserved
                               NULL,    // type
                               (LPBYTE) pszResult,
                               pdwSize );

    RegCloseKey( hkeyComputer );

Finish:
    return lResult;
}

//
// Munges the registry for the computer name
//
LONG 
RetrieveComputerName( void )
{
    DWORD dwSize = sizeof( g_szServerName );
    return MungeRegistry( REGSTR_PATH_COMPUTRNAME, 
                          REGSTR_VAL_COMPUTERNAME,
                          g_szServerName,
                          &dwSize );
}

//
// Populates the Installation ComboBox
//
HRESULT
PopulateInstallationComboBox( 
    HWND hDlg )
{
    BOOL     fKeepSearching = TRUE;
    HRESULT  hr = S_OK;
    TCHAR    szPath[ MAX_PATH ];
    DWORD    dwLen;
    WIN32_FIND_DATA fd;
    HANDLE   handle;
    HWND     hwndCB = GetDlgItem( hDlg, IDC_CB_INSTALLATION );
    LPSHARE_INFO_2 psi = NULL;

    NetShareGetInfo( NULL,  // this machine
                     g_szRemoteBoot,
                     2,     // share level 2
                     (LPBYTE *) &psi );

    // create the directory
    lstrcpy( szPath, psi->shi2_path );
    dwLen = lstrlen( szPath );
    szPath[ dwLen++ ] = TEXT('\\');
    LoadString( g_hinstance, IDS_SETUP, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
    dwLen = lstrlen( szPath );
    lstrcpy( &szPath[ dwLen ], TEXT("\\*") );

    handle = FindFirstFile( szPath, &fd );
    if ( handle == INVALID_HANDLE_VALUE )
        goto Cleanup;

    while ( fKeepSearching)
    {
        if ( fd.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY &&
            lstrcmp( fd.cFileName, TEXT(".") ) &&     // ignore
            lstrcmp( fd.cFileName, TEXT("..") ) )     // ignore
        {
            ComboBox_AddString( hwndCB, fd.cFileName );
        }

        fKeepSearching = FindNextFile( handle, &fd );
    }

    ComboBox_SetCurSel( hwndCB, 0 );

Cleanup:
    if ( handle != INVALID_HANDLE_VALUE)
        FindClose( handle );

    if ( psi )
        NetApiBufferFree( psi );

    return hr;
}
//
// Populates the Configuration ComboBox
//
HRESULT
PopulateConfigurationComboBox( 
    HWND hDlg )
{
    BOOL     fKeepSearching = TRUE;
    HRESULT  hr = S_OK;
    TCHAR    szPath[ MAX_PATH ];
    DWORD    dwLen;
    WIN32_FIND_DATA fd;
    HANDLE   handle;
    HWND     hwndCB = GetDlgItem( hDlg, IDC_CB_WINNTSIF );
    LPSHARE_INFO_2 psi = NULL;
    int      iSel;

    ComboBox_ResetContent( hwndCB );

    NetShareGetInfo( NULL,  // this machine
                     g_szRemoteBoot,
                     2,     // share level 2
                     (LPBYTE *) &psi );

    // create the directory
    lstrcpy( szPath, psi->shi2_path );
    dwLen = lstrlen( szPath );
    szPath[ dwLen++ ] = TEXT('\\');
    LoadString( g_hinstance, IDS_TEMPLATES, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
    dwLen = lstrlen( szPath );
    szPath[ dwLen++ ] = TEXT('\\');
    LoadString( g_hinstance, IDS_INTELPATH, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
    dwLen = lstrlen( szPath );
    szPath[ dwLen++ ] = TEXT('\\');
    LoadString( g_hinstance, IDS_WINNTTEMPLATEFILES, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );

    handle = FindFirstFile( szPath, &fd );
    if ( handle == INVALID_HANDLE_VALUE )
        goto Cleanup;

    while ( fKeepSearching)
    {
        // whack it at the period
        LPTSTR psz = fd.cFileName;
        while ( *psz )
        {
            if ( *psz == TEXT('.') )
            {
                *psz = 0;
                break;
            }
            psz++;
        }

        ComboBox_AddString( hwndCB, fd.cFileName );
        fKeepSearching = FindNextFile( handle, &fd );
    }

    ComboBox_SetCurSel( hwndCB, 0 );

Cleanup:
    if ( handle != INVALID_HANDLE_VALUE)
        FindClose( handle );

    if ( psi )
        NetApiBufferFree( psi );

    return hr;
}


//
//
//
BOOL CALLBACK
ClientDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
	DWORD dw;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            CenterDialog( hDlg );
            SetDlgItemText( hDlg, IDC_E_SERVER, g_szServerName );
            SetDlgItemText( hDlg, IDC_E_REMOTEBOOT, g_szRemoteBoot );
            SetDlgItemText( hDlg, IDC_E_BOOTFILENAME, g_szBootFilename );
            SetDlgItemText( hDlg, IDC_E_BOOTINIOPTIONS, g_szBootIniOptions);
            PopulateInstallationComboBox( hDlg );
            PopulateConfigurationComboBox( hDlg );
            Edit_LimitText( GetDlgItem( hDlg, IDC_E_MAC ), 12 );
            break;

        case WM_COMMAND:
            {
                switch ( LOWORD( wParam ) )
                {
                case IDOK:
                    {
                        DWORD dwLen;
                        TCHAR sz[ SMALL_BUFFER_SIZE ];
                        GetDlgItemText( hDlg, IDC_E_SERVER, g_szServerName, ARRAYSIZE( g_szServerName ));
                        GetDlgItemText( hDlg, IDC_E_REMOTEBOOT, g_szRemoteBoot, ARRAYSIZE( g_szRemoteBoot ));
                        GetDlgItemText( hDlg, IDC_E_BOOTFILENAME, g_szBootFilename, ARRAYSIZE( g_szBootFilename ));
                        GetDlgItemText( hDlg, IDC_E_BOOTINIOPTIONS, g_szBootIniOptions, ARRAYSIZE( g_szBootIniOptions ));
                        GetDlgItemText( hDlg, IDC_E_MAC, g_szMAC, ARRAYSIZE( g_szMAC ));
                        GetDlgItemText( hDlg, IDC_E_MACHINENAME, g_szClientName, ARRAYSIZE( g_szClientName ));
                        GetDlgItemText( hDlg, IDC_CB_INSTALLATION, g_szInstallation, ARRAYSIZE( g_szInstallation ));
                        GetDlgItemText( hDlg, IDC_E_CLIENTDOMAIN, g_szClientDomain, ARRAYSIZE( g_szClientDomain ));
                        GetDlgItemText( hDlg, IDC_E_ADMINUSER, g_szAdminUser, ARRAYSIZE( g_szAdminUser ));
                        GetDlgItemText( hDlg, IDC_E_ADMINPASSWD, g_szAdminPasswd, ARRAYSIZE( g_szAdminPasswd ));
                        GetDlgItemText( hDlg, IDC_CB_WINNTSIF, g_szWinntTemplate, ARRAYSIZE( g_szWinntTemplate ));
                    
                        // add that extension
                        dw = LoadString( g_hinstance, IDS_WINNTTEMPLATEFILES, sz, ARRAYSIZE( sz ));
						Assert( dw );
                        dwLen = lstrlen( g_szWinntTemplate );
                        lstrcpy( &g_szWinntTemplate[ dwLen ], &sz[ 1 ] );

                        EndDialog( hDlg, IDOK );
                    }
                    break;

                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    break;
                }
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

//
// change semicolon delinated list to double-null list
//
void
SemiColonToDoubleNullList( LPTSTR pszList )
{
    while ( *pszList )
    {
        if ( *pszList == TEXT(';') )
        {
            *pszList = 0;
        }

        pszList++;
    }
    pszList++;
    *pszList = 0;   // double the null.
}

//
// Adds files to the Queue to be copied. It returns the number of files added
// to the Queue.
//
DWORD 
CopyFilesAddToQueue( 
    HSPFILEQ Queue,     // setup Queue
    LPTSTR pszSource,
    LPTSTR pszDest,
    LPTSTR pszFiles,    // Double-null terminated file list
    LPTSTR pszSubpath ) // optional sub-path
{
    DWORD  dwCount = 0;
    LPTSTR psz = pszFiles;

    while ( *pszFiles )
    {
        DWORD  dwLen;        

        // check for comma which indicates rename
        psz = pszFiles;
        while (*psz && *psz != TEXT(','))
            psz++;

        if ( *psz == TEXT(',') )
        {
            *psz= 0;   // terminate
            psz++;
        }
        else
        {   // sources name is dest name
            psz = pszFiles;
        }

        SetupQueueCopy( 
            Queue, 
            pszSource, 
            NULL, 
            pszFiles,
            NULL, 
            NULL, 
            pszDest, 
            psz,
            SP_COPY_NEWER | SP_COPY_NOOVERWRITE | SP_COPY_WARNIFSKIP );

        // get next file
        pszFiles = psz + lstrlen( psz ) + 1;
        dwCount++;
    }

    return dwCount;
}

//
//
//
HRESULT
SetupClient( )
{
    HRESULT  hr = E_FAIL;
    TCHAR    szImage[ MAX_PATH ];
    TCHAR    szSetup[ MAX_PATH ];
    TCHAR    szTemplates[ MAX_PATH ];
    TCHAR    szBootIni[ MAX_PATH ];
    TCHAR    szString[ MAX_PATH ];
    TCHAR    szDosNetFilename[ MAX_PATH ];
    TCHAR    szWinntSif[ MAX_PATH ];
    DWORD    dwLen;
    DWORD    dw;
    HSPFILEQ Queue;
    PVOID    pContext;
    HANDLE   hFile = INVALID_HANDLE_VALUE;
    HKEY     hkeyBINL;
    HKEY     hkeyMAC;
    LPTSTR   pszFiles = (LPTSTR) TraceAlloc( GMEM_FIXED, MAX_FILES_SIZE );
    LPTSTR   psz = NULL;
    LPSHARE_INFO_2 psi = NULL;
    LPVOID   args[ 6 ];
    SAR     sExpand[] = {
                    { TEXT("BINLSERVER"), g_szServerName },
                    { TEXT("INSTALLATION"), g_szInstallation },
                    { TEXT("CLIENTNAME"), g_szClientName },
                    { TEXT("REMOTEBOOT"), g_szRemoteBoot },
                    { TEXT("CLIENTDOMAIN"), g_szClientDomain },
                    { TEXT("ADMINUSER"), g_szAdminUser },
                    { TEXT("ADMINPASSWD"), g_szAdminPasswd },
                    { NULL, NULL }  // end of list
                };
    char     chString[ STRING_BUFFER_SIZE ];

    NetShareGetInfo( NULL,  // this machine
                     g_szRemoteBoot,
                     2,     // share level 2
                     (LPBYTE *) &psi );

    // create the directory
    lstrcpy( szImage, psi->shi2_path );
    dwLen = lstrlen( szImage );
    szImage[ dwLen++ ] = TEXT('\\');
    dw = LoadString( g_hinstance, IDS_IMAGES, &szImage[ dwLen ], ARRAYSIZE( szImage ) - dwLen );
	Assert( dw );
    dwLen = lstrlen( szImage );
    szImage[ dwLen++ ] = TEXT('\\');
    lstrcpy( &szImage[ dwLen ], g_szClientName );

    CreateDirectory( szImage, NULL );

    // setup path
    lstrcpy( szSetup, psi->shi2_path );
    dwLen = lstrlen( szSetup );
    szSetup[ dwLen++ ] = TEXT('\\');
    dw = LoadString( g_hinstance, IDS_SETUP, &szSetup[ dwLen ], ARRAYSIZE( szSetup ) - dwLen );
	Assert( dw );
    dwLen = lstrlen( szSetup );
    szSetup[ dwLen++ ] = TEXT('\\');
    lstrcpy( &szSetup[ dwLen ], g_szInstallation );
    dwLen = lstrlen( szSetup );
    szSetup[ dwLen++ ] = TEXT('\\');
    dw = LoadString( g_hinstance, IDS_INTELPATH, &szSetup[ dwLen ], ARRAYSIZE( szSetup ) - dwLen );
	Assert( dw );

    // Create DOSNET.INF filepath
    lstrcpy( szDosNetFilename, szSetup );
    dwLen = lstrlen( szDosNetFilename );
    szDosNetFilename[ dwLen ] = TEXT('\\');
    dwLen++;
    dw = LoadString( g_hinstance, IDS_DOSNETINFFILENAME, 
        &szDosNetFilename[ dwLen ], ARRAYSIZE( szDosNetFilename ) - dwLen );
	Assert( dw );

    Queue = SetupOpenFileQueue( );
    
    // Retrieve the list of files from the INF and add to Queue
    GetPrivateProfileSection( TEXT("RootBootFiles"), pszFiles, MAX_FILES_SIZE, 
        szDosNetFilename );
    CopyFilesAddToQueue( Queue, szSetup, szImage, pszFiles, NULL );

    // add additional files from resources
    dw = LoadString( g_hinstance, IDS_FILESTOBECOPIED, pszFiles, MAX_FILES_SIZE );
	Assert( dw );
    SemiColonToDoubleNullList( pszFiles );
    CopyFilesAddToQueue( Queue, szSetup, szImage, pszFiles, NULL );

    // copy winnt.sif template
    lstrcpy( szTemplates, psi->shi2_path );
    dwLen = lstrlen( szTemplates );
    szTemplates[ dwLen++ ] = TEXT('\\');
    dw = LoadString( g_hinstance, IDS_TEMPLATES, &szTemplates[ dwLen ], ARRAYSIZE( szTemplates ) - dwLen );
	Assert( dw );
    dwLen = lstrlen( szTemplates );
    szTemplates[ dwLen++ ] = TEXT('\\');
    dw = LoadString( g_hinstance, IDS_INTELPATH, &szTemplates[ dwLen ], ARRAYSIZE( szTemplates ) - dwLen );
	Assert( dw );

    lstrcpy( pszFiles, g_szWinntTemplate );
    dwLen = lstrlen( pszFiles );
    pszFiles[ dwLen++ ] = TEXT(',');
    dw = LoadString( g_hinstance, IDS_WINNTSIF, &pszFiles[ dwLen ], MAX_PATH );
	Assert( dw );
    SemiColonToDoubleNullList( pszFiles );
    CopyFilesAddToQueue( Queue, szTemplates, szImage, pszFiles, NULL );

    TraceFree( pszFiles );

    pContext = SetupInitDefaultQueueCallback( NULL );

    if (!SetupCommitFileQueue( NULL, Queue, SetupDefaultQueueCallback, 
        pContext ) )
        goto Cleanup;

    dw = LoadString( g_hinstance, IDS_REG_BINL_PARAMETER, szString, ARRAYSIZE( szString ));
	Assert( dw );
    if ( ERROR_SUCCESS ==
        RegOpenKey( HKEY_LOCAL_MACHINE, szString, &hkeyBINL ) )
    {
        if ( ERROR_SUCCESS ==
            RegCreateKey( hkeyBINL, g_szMAC, &hkeyMAC ) )
        {
            dw = LoadString( g_hinstance, IDS_IMAGES, szString, ARRAYSIZE( dw ));
			Assert( dw );
            dwLen = lstrlen( szString );
            szString[ dwLen++ ] = TEXT('\\');
            lstrcpy( &szString[ dwLen ], g_szClientName );
            dwLen = lstrlen( szString );
            szString[ dwLen++ ] = TEXT('\\');
            lstrcpy( &szString[ dwLen ], g_szBootFilename );
            dwLen = ( lstrlen( szString ) + 1 ) * sizeof(TCHAR);

            RegSetValueEx( hkeyMAC, TEXT("BootFileName"), 0, REG_SZ, (LPBYTE) szString, dwLen );

            dwLen = ( lstrlen( g_szServerName ) + 1 ) * sizeof(TCHAR);
            RegSetValueEx( hkeyMAC, TEXT("HostName"), 0, REG_SZ, (LPBYTE) g_szServerName, dwLen );

            RegCloseKey( hkeyMAC );
        }
        RegCloseKey( hkeyBINL );
    }

    // create MAC Address file
    lstrcpy( szString, szImage );
    dwLen = lstrlen( szString );
    szString[ dwLen++ ] = TEXT('\\');
    lstrcpy( &szString[ dwLen ], g_szMAC );

    hFile = CreateFile( szString, 
                        GENERIC_WRITE, 
                        FILE_SHARE_READ,
                        NULL,                   // security attribs
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,  // maybe FILE_ATTRIBUTE_HIDDEN
                        NULL );                 // template
    CloseHandle( hFile );

    lstrcpy( szBootIni, szImage );
    dwLen = lstrlen( szBootIni );
    szBootIni[ dwLen++ ] = TEXT('\\');
    dw = LoadString( g_hinstance, IDS_BOOTINI, &szBootIni[ dwLen ], ARRAYSIZE( szBootIni ) - dwLen );
	Assert( dw );

    hFile = CreateFile( szBootIni, 
                        GENERIC_WRITE, 
                        FILE_SHARE_READ,
                        NULL,                   // security attribs
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,  // maybe FILE_ATTRIBUTE_HIDDEN
                        NULL );                 // template
    if ( hFile == INVALID_HANDLE_VALUE )
        goto Cleanup;

    dw = LoadString( g_hinstance, IDS_BOOTLOADER, szString, ARRAYSIZE( szString ));
	Assert( dw );

    args[0] = (LPVOID) &g_szServerName;
    args[1] = (LPVOID) &g_szRemoteBoot;
    args[2] = (LPVOID) &g_szClientName;
    args[3] = (LPVOID) &g_szInstallation;
    args[4] = (LPVOID) &g_szBootIniOptions;

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        szString,
        NULL,   // message id - n/a
        NULL,   // language - use system
        (LPTSTR) &psz,
        0,      // minimum length
        (char **) &args );
    DebugMemoryAddAddress( psz );

    WideCharToMultiByte( CP_ACP, 0, psz, -1, chString, ARRAYSIZE( chString ), NULL, NULL );

    dwLen = lstrlenA( chString );
    WriteFile( hFile, chString, dwLen, &dw, NULL );

    CloseHandle( hFile );
    TraceFree( psz );

    // process WINNT.SIF
    lstrcpy( szWinntSif, szImage );
    dwLen = lstrlen( szWinntSif );
    szWinntSif[ dwLen++ ] = TEXT('\\');
    dw = LoadString( g_hinstance, IDS_WINNTSIF, &szWinntSif[ dwLen ], ARRAYSIZE( szWinntSif ) - dwLen );
	Assert( dw );

    hFile = CreateFile( szWinntSif, 
                        GENERIC_READ, 
                        FILE_SHARE_READ,
                        NULL,                   // security attribs
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,  // maybe FILE_ATTRIBUTE_HIDDEN
                        NULL );                 // template
    if ( hFile == INVALID_HANDLE_VALUE )
        goto Cleanup;

    ReadFile( hFile, chString, ARRAYSIZE( chString ), &dw, NULL );
    Assert( dw != ARRAYSIZE( chString ));

    CloseHandle( hFile );

    psz = (LPTSTR) TraceAlloc( GMEM_FIXED, ARRAYSIZE( chString ));
    MultiByteToWideChar( CP_ACP, 0, chString, -1, psz, ARRAYSIZE( chString ));

    SearchAndReplace( sExpand, psz, ARRAYSIZE( chString ));

    hFile = CreateFile( szWinntSif, 
                        GENERIC_WRITE, 
                        FILE_SHARE_READ,
                        NULL,                   // security attribs
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,  // maybe FILE_ATTRIBUTE_HIDDEN
                        NULL );                 // template
    if ( hFile == INVALID_HANDLE_VALUE )
        goto Cleanup;

    WideCharToMultiByte( CP_ACP, 0, psz, -1, chString, ARRAYSIZE( chString ), NULL, NULL );

    dwLen = lstrlenA( chString );
    WriteFile( hFile, chString, dwLen, &dw, NULL );

    CloseHandle( hFile );
    TraceFree( psz );

    hr = S_OK;

Cleanup:

    if ( Queue )
        SetupCloseFileQueue( Queue );

    if ( psi )
        NetApiBufferFree( psi );

    return hr;
}

//
// WinMain()
//
int APIENTRY 
WinMain(
    HINSTANCE hInstance, 
    HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, 
    int nCmdShow)
{
    HANDLE  hMutex;
    HRESULT hr = S_OK;
	DWORD dw;

    g_hinstance = hInstance;

    INITIALIZE_TRACE_MEMORY;

    // Initialize
    RetrieveComputerName( );
    dw = LoadString( g_hinstance, IDS_REMOTEBOOT, g_szRemoteBoot, ARRAYSIZE( g_szRemoteBoot ));
	Assert( dw );
    dw = LoadString( g_hinstance, IDS_BOOTFILENAME, g_szBootFilename, ARRAYSIZE( g_szBootFilename ));
	Assert( dw );
    dw = LoadString( g_hinstance, IDS_BOOTINIOPTIONS, g_szBootIniOptions, ARRAYSIZE( g_szBootIniOptions ));
	Assert( dw );

    if ( IDOK == DialogBox( g_hinstance, MAKEINTRESOURCE( IDD_CLIENT ), NULL, ClientDlgProc ) )
    {
        if ( lstrlen( g_szMAC ) != 12 )
            goto Cleanup;
    
        if ( !lstrlen( g_szClientName ) )
            goto Cleanup;

        hr = SetupClient( );
    }

Cleanup:
    UNINITIALIZE_TRACE_MEMORY;

    RRETURN(hr);
}


// stolen from the CRT, used to shrink our code
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();


    if ( *pszCmdLine == '\"' ) 
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else 
    {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) 
    {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never come here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\client\debug.cpp ===
/****************************************************************************

  Copyright (c) Microsoft Corporation 1997
  All rights reserved

  File: DEBUG.CPP

  Debugging utilities
 
 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("Debugging");

#ifdef DEBUG

// Constants
#define DEBUG_OUTPUT_BUFFER_SIZE  512

// Globals
DWORD g_TraceMemoryIndex = 0;
DWORD g_dwCounter        = 0;
DWORD g_dwTraceFlags     = TF_FUNC | TF_CALLS;

// Statics
static const TCHAR g_szNULL[]    = TEXT("");
static const TCHAR g_szTrue[]    = TEXT("True");
static const TCHAR g_szFalse[]   = TEXT("False");
static const TCHAR g_szFormat[]  = TEXT("%-40s  %-10.10s ");
static const TCHAR g_szUnknown[] = TEXT("<unknown>");

//
// Debugging strrchr( )
//
LPCTSTR
dbgstrrchr( LPCTSTR lpsz, char ch )
{
    LPCTSTR psz = lpsz;

    while ( *psz )
        ++psz;

    while ( psz >= lpsz && *psz != ch )
        --psz;

    return psz;

}

//
// Adds 'g_dwCounter' spaces to debug spew
//
void
dbgspace( void )
{
    for( DWORD dw = 1; dw < g_dwCounter; dw++ )
        DebugMsg( TEXT("| ") );
}

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPTSTR
dbgmakefilelinestring( 
    LPTSTR  pszBuf, 
    LPCTSTR pszFile, 
    UINT    uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = (LPVOID) uLine;

    FormatMessage( 
        FORMAT_MESSAGE_FROM_STRING | 
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        TEXT("%1(%2!u!):"),
        0,                          // error code
        0,                          // default language
        (LPTSTR) pszBuf,            // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (char**) &args );           // arguments

    return pszBuf;
}



//
// TraceMsg()
//
void
TraceMsg( 
    DWORD dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS 
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );
    }
}

//
// TraceMessage()
//
void
TraceMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS 
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        OutputDebugString( szBuf );

        dbgspace( );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );
    }

}

//
// DebugMessage()
//
void
DebugMessage( 
    LPCTSTR  pszFile, 
    UINT    uLine, 
    LPCTSTR  pszModule, 
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

    if ( !pszModule )
    {
        pszModule = g_szUnknown;
    }

    if ( !pszFile )
    {
        wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
    }
    else
    {
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgmakefilelinestring( szFileLine, pszFile, uLine );
        wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
    }

    OutputDebugString( szBuf );

    dbgspace( );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );

    OutputDebugString( szBuf );

}

//
// DebugMsg()
//
void 
DebugMsg( 
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );

    OutputDebugString( szBuf );
}


//
// Displays a dialog box with the failed assertion. User has the option of
// breaking.
//
BOOL
AssertMessage( 
    LPCTSTR  pszFile, 
    UINT    uLine, 
    LPCTSTR  pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue )
{
    if ( !fTrue )
    {
        TCHAR szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszFile == NULL )
        {
            pszFile = g_szNULL;
        }

        if ( pszModule == NULL )
        {
            pszModule = g_szNULL;
        }

        if ( pszfn == NULL )
        {
            pszfn = g_szNULL;
        }

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-40s  %-10s ASSERT: %s\n"),
            szFileLine, pszModule, pszfn );

        OutputDebugString( szBuf );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn );

        if ( IDNO == MessageBox( NULL, szBuf, TEXT("Assertion Failed!"), 
                MB_YESNO|MB_ICONWARNING ) )
            return FALSE;   // don't break
    }

    return !fTrue;

}

//
// Traces HRESULT errors. A dialog will appear is there is an error
// in the hr.
//
HRESULT
TraceHR( 
    LPCTSTR  pszFile, 
    UINT    uLine, 
    LPCTSTR  pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr )
{
    if ( hr )
    {
        TCHAR  szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR pszMsgBuf;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = TEXT("S_FALSE\n");
            break;

        default:
            FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR)&pszMsgBuf,
                0,
                NULL
            );
        }

        // Make sure everything is cool before we blow up somewhere else.
        Assert( pszMsgBuf != NULL );
        Assert( pszFile != NULL );
        Assert( pszModule != NULL );
        Assert( pszfn != NULL );

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-40s  %-10s HRESULT: hr = 0x%08x - %s"),
            szFileLine, pszModule, hr, pszMsgBuf );

        OutputDebugString( szBuf );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x - %s\t\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn, hr, pszMsgBuf );

        if ( IDYES == MessageBox( NULL, szBuf, TEXT("Trace HRESULT"), 
                MB_YESNO|MB_ICONWARNING ) )
            DEBUG_BREAK;

        LocalFree( pszMsgBuf );

    }

    return hr;

}


//
// Memory allocation and tracking
//

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCTSTR pszFile;
    UINT    uLine;
    LPCTSTR pszModule;
    LPCTSTR pszComment;
    _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc( 
                                                    GMEM_FIXED, 
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete( 
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmbLast = NULL;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );
            }
        }
    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    HGLOBAL       hglobal = GlobalAlloc( uFlags, dwBytes );

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree( 
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );

    while ( pmb )
    {
        LPVOID args[ 5 ];
        TCHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
          //OutputDebugString("1234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            OutputDebugString(TEXT("Filename(Line Number):                    Module     Addr/HGLOBAL  Size   String\n"));
            fFoundLeak = TRUE;
        }

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = (LPVOID) pmb->dwBytes;
        args[4] = (LPVOID) pmb->pszModule;

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessage( 
                FORMAT_MESSAGE_FROM_STRING | 
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-40s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (char**) &args );           // arguments
        }
        else
        {    
            FormatMessage( 
                FORMAT_MESSAGE_FROM_STRING | 
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-40s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (char**) &args );           // arguments
        }

        OutputDebugString( szOutput );

        pmb = pmb->pNext;
    }

    if ( fFoundLeak == TRUE )
    {
        OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
    }

    Assert( !fFoundLeak );
}

#endif // DEBUG

//
// Global Management Functions - 
//
// These are in debug and retail but are internally they change
// depending on the build.
//

void * __cdecl operator new(unsigned int t_size )
{
    return DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, GPTR, t_size, TEXT("new()") );
}

void __cdecl operator delete(void *pv)
{
    TraceFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\utils.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("Utils");

#define SMALL_BUFFER_SIZE   256

//
// Centers a dialog.
//
void 
CenterDialog( 
    HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen; 
    int     cyScreen; 

    SystemParametersInfo( SPI_GETWORKAREA, 0, &rcScreen, 0 );

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect( hwndDlg, &rc );

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ( ( cyScreen - cyDlg ) / 2 );
    x = rcScreen.left + ( ( cxScreen - cxDlg ) / 2 );

    SetWindowPos( hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE );
}

//
// Eats all mouse and keyboard messages.
//
void 
ClearMessageQueue( void )
{
    MSG   msg;

    while ( PeekMessage( (LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST, 
                PM_NOYIELD | PM_REMOVE ) );
}

//
// Create a message box from resource strings.
//
int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType )
{
    TCHAR szText[ SMALL_BUFFER_SIZE ];
    TCHAR szCaption[ SMALL_BUFFER_SIZE ];
	DWORD dw;

    dw = LoadString( g_hinstance, idsCaption, szCaption, ARRAYSIZE( szCaption ));
	Assert( dw );
    dw = LoadString( g_hinstance, idsText, szText, ARRAYSIZE( szText ));
	Assert( dw );

    return MessageBox( hParent, szText, szCaption, uType );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\setup.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include "pch.h"
#include <shlobj.h>
#include <setupapi.h>
#include <advpub.h>
#include <lm.h>

#include "dialogs.h"

DEFINE_MODULE("Setup");

#define SMALL_BUFFER_SIZE   256
#define MAX_FILES_SIZE      640000

static const TCHAR chSlash = TEXT('\\');

//
// Opens the layout.inf file for a particular platform.
//
HINF
OpenLayoutInf( )
{
    TCHAR   szFilename[ MAX_PATH ];
    HANDLE  hFile;
    UINT    uErr;
    DWORD   dwLen;
	DWORD   dw;

    lstrcpy( szFilename, g_Options.szSourcePath );

    dwLen = lstrlen( szFilename );
    szFilename[ dwLen++ ] = chSlash;

    dw = LoadString( g_hinstance, IDS_NTSETUPINFFILENAME, 
        &szFilename[ dwLen ], ARRAYSIZE( szFilename ) - dwLen );
	Assert( dw );

    hFile = SetupOpenInfFile( szFilename, NULL, INF_STYLE_WIN4, &uErr );	

    return hFile;
}

//
// Creates the RemoteBoot directory tree.
//
HRESULT
CreateDirectories( HWND hDlg )
{
    BOOL  fReturn = FALSE;
    TCHAR szPath[ MAX_PATH ];
    TCHAR szCreating[ SMALL_BUFFER_SIZE ];
    HWND  hProg = GetDlgItem( hDlg, IDC_P_METER );
    DWORD dwLen;
	DWORD dw;

    SendMessage( hProg, PBM_SETRANGE, 0, 
        MAKELPARAM(0, 4 + ( g_Options.fCreateDirectory ? 1 : 0 )) );
    SendMessage( hProg, PBM_SETSTEP, 1, 0 );

    dw = LoadString( g_hinstance, IDS_CREATINGDIRECTORIES, szCreating, 
        ARRAYSIZE( szCreating ) );
	Assert( dw );
    SetWindowText( GetDlgItem( hDlg, IDC_S_OPERATION ), szCreating );

    if ( g_Options.fCreateDirectory )
    {
        fReturn = CreateDirectory( g_Options.szRemoteBootPath, NULL );
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
        if ( !fReturn )
            goto Finish;
    }

    lstrcpy( szPath, g_Options.szRemoteBootPath );

    dwLen = lstrlen( szPath );
    szPath[ dwLen ] = chSlash;
    dwLen++;

    dw = LoadString( g_hinstance, IDS_IMAGES, &szPath[ dwLen ], 
        ARRAYSIZE( szPath ) - dwLen );
	Assert( dw );
    CreateDirectory( szPath, NULL );
    SendMessage( hProg, PBM_DELTAPOS, 1, 0 );

    lstrcpy( g_Options.szImagesPath, szPath );

    dw = LoadString( g_hinstance, IDS_TEMPLATEPATH, &szPath[ dwLen ], 
        ARRAYSIZE( szPath )- dwLen );
	Assert( dw );
    CreateDirectory( szPath, NULL );
    SendMessage( hProg, PBM_DELTAPOS, 1, 0 );

    dw = LoadString( g_hinstance, IDS_SETUP, &szPath[ dwLen ], 
        ARRAYSIZE( szPath ) - dwLen );
	Assert( dw );
    CreateDirectory( szPath, NULL );
    SendMessage( hProg, PBM_DELTAPOS, 1, 0 );

    dwLen = lstrlen( szPath );
    szPath[ dwLen ] = chSlash;
    dwLen++;

    lstrcpy( &szPath[ dwLen ], g_Options.szName );
    CreateDirectory( szPath, NULL );
    SendMessage( hProg, PBM_DELTAPOS, 1, 0 );

    /*
    // add '\i386'
    dwLen = lstrlen( szPath );
    szPath[ dwLen ] = chSlash;
    dwLen++;
    dw = LoadString( g_hinstance, IDS_INTELPATH, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
	Assert( dw );
    */
    lstrcpy( g_Options.szSetupPath, szPath );

    fReturn = TRUE;

Finish:
    g_Options.fError = !fReturn;
    return fReturn ? S_OK : E_FAIL;
}


//
// Find the filename part from a complete path.
//
LPTSTR FilenameOnly( LPTSTR pszPath )
{
    LPTSTR psz = pszPath;

    // find the end
    while ( *psz )
        psz++;

    // find the slash
    while ( psz > pszPath && *psz != chSlash )
        psz--;

    // move in front of the slash
    if ( psz != pszPath )
        psz++;

    return psz;
}

typedef struct {
    PVOID pContext;                             // "Context" for DefaultQueueCallback
    HWND  hProg;                                // hwnd to the progress meter
    HWND  hOperation;                           // hwnd to the "current operation"
    DWORD nCopied;                              // number of files copied
    DWORD nToBeCopied;                          // number of file to be copied
    DWORD dwCopyingLength;                      // length of the IDS_COPYING
    TCHAR szCopyingString[ SMALL_BUFFER_SIZE ]; // buffer to create "Copying file.ext..."
} MYCONTEXT, *LPMYCONTEXT;

//
//
//
UINT CALLBACK
CopyFilesCallback(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT Param1,
    IN UINT Param2
    )
{
    MSG  Msg;
    LPMYCONTEXT pMyContext = (LPMYCONTEXT) Context;
	DWORD dw;

    // process some messages
    if ( PeekMessage( &Msg, NULL, 0, 0, PM_REMOVE ) )
    {
        TranslateMessage( &Msg );
        DispatchMessage( &Msg );
    }

    if ( g_Options.fAbort )
    {        
        if ( !g_Options.fError )
        {
            TCHAR    szAbort[ SMALL_BUFFER_SIZE ];

            // change filename text to aborting...
            dw = LoadString( g_hinstance, IDS_ABORTING, szAbort, 
                ARRAYSIZE( szAbort ) );
			Assert( dw );
            SetWindowText( pMyContext->hOperation, szAbort );

            g_Options.fError = TRUE;
        }

        SetLastError(ERROR_CANCELLED);
        return FILEOP_ABORT;
    }

    switch ( Notification )
    {
    case SPFILENOTIFY_ENDCOPY:
        pMyContext->nCopied++;
        SendMessage( pMyContext->hProg, PBM_SETPOS, 
            (1000 * pMyContext->nCopied) / pMyContext->nToBeCopied, 0 );
        break;

    case SPFILENOTIFY_STARTCOPY:
        {
            DWORD    dwLen;
            LPTSTR * ppszCopyingFile = (LPTSTR *) Param1;

            lstrcpy( &pMyContext->szCopyingString[ pMyContext->dwCopyingLength ], 
                FilenameOnly( *ppszCopyingFile ) );
            dwLen = lstrlen( pMyContext->szCopyingString );
            lstrcpy( &pMyContext->szCopyingString[ dwLen ], TEXT("...") );

            SetWindowText( pMyContext->hOperation, pMyContext->szCopyingString );
        }
        break;
    
    case SPFILENOTIFY_RENAMEERROR:
    case SPFILENOTIFY_DELETEERROR:
    case SPFILENOTIFY_COPYERROR:
    case SPFILENOTIFY_NEEDMEDIA:
    case SPFILENOTIFY_LANGMISMATCH:
    case SPFILENOTIFY_TARGETEXISTS:
    case SPFILENOTIFY_TARGETNEWER:
        return SetupDefaultQueueCallback( pMyContext->pContext, Notification, 
            Param1, Param2 );
    }

    return FILEOP_DOIT;
}

//
// Find a character in a NULL terminated string.
//
// Returns NULL is not found.
//
LPTSTR
FindChar( LPTSTR pszSrc, TCHAR ch )
{
    if ( pszSrc )
    {
        while ( *pszSrc )
        {
            if ( *pszSrc == ch )
                return pszSrc;

            pszSrc++;
        }
    }

    return NULL;
}

//
// change layout format to double-null list
//
void
LayoutToDoubleNullList( LPTSTR pszList )
{
/*
    Borrowed from LAYOUT.INF for reference
;
; filename_on_source = diskid,subdir,size,checksum,spare,spare
; extra fields are nt-specific
;   bootmediaord: _1 (floppy #1)
;                 _2 (floppy #2)
;                 _3 (floppy #3)
;                 _x (textmode setup)
;                nothing (gui mode setup)
;   targetdirectory : 1 - 41 (see "WinntDirectories", above)
;   upgradedisposition : 0 (always copy)
;                        1 (copy if present)
;                        2 (copy if not present)
;                        3 (never copy)
;   textmodedisposition:
;   targetname
;
*/

    static const TCHAR chComma = TEXT(',');
    LPTSTR pszFile     = pszList;
    LPTSTR pszCopyHere = pszList;

    while ( *pszFile )
    {
        MSG    Msg;
        DWORD  dwToNextFile = lstrlen( pszFile );
        LPTSTR pszNext;
        LPTSTR psz = FindChar( pszFile, TEXT('=') );
        Assert( psz );

        // process some messages
        if ( PeekMessage( &Msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &Msg );
            DispatchMessage( &Msg );
        }

        *psz = 0;
        psz++;

        pszNext  = FindChar( psz, chComma );
        *pszNext = 0;

        // must be "1"
        if ( !lstrcmp( psz, TEXT("1") ) )
        {
            // copy file name
            lstrcpy( pszCopyHere, pszFile );

            // advance copy pointer
            pszCopyHere += 1 + lstrlen( pszCopyHere );
        }
        else
        {
            AssertMsg( FALSE, "Now what?!" );
        }

        // advanced file pointer
        pszFile += dwToNextFile + 1;
    }

    *pszCopyHere = 0;
}

//
// change semicolon delinated list to double-null list
//
void
SemiColonToDoubleNullList( LPTSTR pszList )
{
    while ( *pszList )
    {
        if ( *pszList == TEXT(';') )
        {
            *pszList = 0;
        }

        pszList++;
    }
    pszList++;
    *pszList = 0;   // double the null.
}


//
// Adds double-null terminated list of file name to the Queue. The filename 
// can have a comma in it indicating a rename operation:
// optionalpath\newname.ext,optionalpath\sourcefil.ext
//
// Returns the number of files added to the Queue.
//
DWORD 
CopyFilesAddToQueue( 
    HSPFILEQ Queue,     // setup Queue
    LPTSTR pszSource,   // source directory
    LPTSTR pszDest,     // destination directory
    LPTSTR pszFiles,    // Double-null terminated file list
    LPTSTR pszSubpath,  // optional sub-path
    DWORD  dwCopyStyle) // flags
{
    DWORD  dwCount = 0;
    LPTSTR psz = pszFiles;
    static const TCHAR chComma = TEXT(',');

    while ( *pszFiles )
    {
        DWORD dwLen;

        psz = pszFiles;
        // check for comma which indicates rename
        while (*psz && *psz != chComma)
            psz++;

        if ( *psz == chComma )
        {
            *psz= 0;   // terminate
            psz++;
        }
        else
        {   // sources name is dest name
            psz = pszFiles;
        }

        SetupQueueCopy( 
            Queue, 
            pszSource, 
            pszSubpath, 
            psz,
            NULL, 
            NULL, 
            pszDest, 
            pszFiles,
            dwCopyStyle );

        // get next file
        pszFiles = psz + lstrlen( psz ) + 1;
        dwCount++;
    }

    return dwCount;
}

//
// Copies the files into the setup directory.
//
HRESULT
CopyFiles( HWND hDlg )
{
    TCHAR   szLayoutFilename[ MAX_PATH ];
    TCHAR   szSystemPath[ MAX_PATH ];
    DWORD   dwLen;
    LPTSTR  psz;
    BOOL    fReturn  = FALSE;
    HWND    hProg    = GetDlgItem( hDlg, IDC_P_METER );
    LPTSTR  pszFiles = (LPTSTR) TraceAlloc( GMEM_FIXED, MAX_FILES_SIZE );
    DWORD   dwCount  = 0;
	DWORD   dw;

    HSPFILEQ Queue;
    MYCONTEXT MyContext;

    if ( !pszFiles || g_Options.fAbort )
        goto Finish;

    // Setup and display next section of dialog
    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 1000 ));
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    dw = LoadString( g_hinstance, IDS_BUILDINGFILELIST, szLayoutFilename, ARRAYSIZE( szLayoutFilename ));
	Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szLayoutFilename );

    // Create layout filepath
    lstrcpy( szLayoutFilename, g_Options.szSourcePath );
    dwLen = lstrlen( szLayoutFilename );
    szLayoutFilename[ dwLen ] = chSlash;
    dwLen++;

    dw = LoadString( g_hinstance, IDS_NTSETUPINFFILENAME, 
        &szLayoutFilename[ dwLen ], ARRAYSIZE( szLayoutFilename )- dwLen );
	Assert( dw );

    Queue = SetupOpenFileQueue( );
    
    // add the files from the INF to the Queue
    GetPrivateProfileSection( TEXT("SourceDisksFiles"), pszFiles, MAX_FILES_SIZE, 
        szLayoutFilename );
    LayoutToDoubleNullList( pszFiles );

    if ( g_Options.fIntel )
    {
        TCHAR szPath[ MAX_PATH ];
        DWORD dwLen;

        lstrcpy( szPath, g_Options.szSetupPath );
        dwLen = lstrlen( szPath );
        szPath[ dwLen++ ] = chSlash;
        dw = LoadString( g_hinstance, IDS_INTELPATH, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
		Assert( dw );

        dwCount += CopyFilesAddToQueue( Queue, g_Options.szSourcePath, szPath, 
            pszFiles, NULL, SP_COPY_NEWER | SP_COPY_WARNIFSKIP );

        // add the processor dependant files from the INF to the Queue
        GetPrivateProfileSection( TEXT("SourceDisksFiles.x86"), pszFiles, MAX_FILES_SIZE, 
            szLayoutFilename );
        LayoutToDoubleNullList( pszFiles );
        dwCount += CopyFilesAddToQueue( Queue, g_Options.szSourcePath, szPath, 
            pszFiles, NULL, SP_COPY_NEWER | SP_COPY_WARNIFSKIP );

        // additional files not listed
        dw = LoadString( g_hinstance, IDS_FILESTOBECOPIED, pszFiles, MAX_FILES_SIZE );
        SemiColonToDoubleNullList( pszFiles );
        dwCount += CopyFilesAddToQueue( Queue, g_Options.szSourcePath, szPath, pszFiles, NULL,
            SP_COPY_NEWER | SP_COPY_WARNIFSKIP );
    }

    if ( g_Options.fAlpha )
    {
        TCHAR szPath[ MAX_PATH ];
        DWORD dwLen;

        lstrcpy( szPath, g_Options.szSetupPath );
        dwLen = lstrlen( szPath );
        szPath[ dwLen++ ] = chSlash;
        dw = LoadString( g_hinstance, IDS_ALPHAPATH, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
		Assert( dw );

        dwCount += CopyFilesAddToQueue( Queue, g_Options.szSourcePath, szPath, 
            pszFiles, NULL, SP_COPY_NEWER | SP_COPY_WARNIFSKIP );

        // add the processor dependant files from the INF to the Queue
        GetPrivateProfileSection( TEXT("SourceDisksFiles.Alpha"), pszFiles, MAX_FILES_SIZE, 
            szLayoutFilename );
        LayoutToDoubleNullList( pszFiles );
        dwCount += CopyFilesAddToQueue( Queue, g_Options.szSourcePath, szPath, 
            pszFiles, NULL, SP_COPY_NEWER | SP_COPY_WARNIFSKIP );

        // additional files not listed
        dw = LoadString( g_hinstance, IDS_FILESTOBECOPIED, pszFiles, MAX_FILES_SIZE );
		Assert( dw );
        SemiColonToDoubleNullList( pszFiles );
        dwCount += CopyFilesAddToQueue( Queue, g_Options.szSourcePath, szPath, pszFiles, NULL,
            SP_COPY_NEWER | SP_COPY_WARNIFSKIP );
    }

    // add template files
    if ( g_Options.fIntel )
    {
        TCHAR szPath[ MAX_PATH ];
        DWORD dwLen;

        lstrcpy( szPath, g_Options.szRemoteBootPath );
        dwLen = lstrlen( szPath );
        szPath[ dwLen++ ] = chSlash;
        dw = LoadString( g_hinstance, IDS_TEMPLATEPATH, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
		Assert( szPath );
        dwLen = lstrlen( szPath );
        szPath[ dwLen++ ] = chSlash;
        dw = LoadString( g_hinstance, IDS_INTELPATH, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
		Assert( dw );

        dw = LoadString( g_hinstance, IDS_TEMPLATEFILES_INTEL, pszFiles, MAX_FILES_SIZE );
		Assert( dw );
        SemiColonToDoubleNullList( pszFiles );
        dwCount += CopyFilesAddToQueue( Queue, g_Options.szSourcePath, szPath, 
            pszFiles, NULL, SP_COPY_NEWER | SP_COPY_NOOVERWRITE | SP_COPY_WARNIFSKIP );
    }

    if ( g_Options.fAlpha )
    {
        TCHAR szPath[ MAX_PATH ];
        DWORD dwLen;

        lstrcpy( szPath, g_Options.szRemoteBootPath );
        dwLen = lstrlen( szPath );
        szPath[ dwLen++ ] = chSlash;
        dw = LoadString( g_hinstance, IDS_TEMPLATEPATH, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
		Assert( dw );
        dwLen = lstrlen( szPath );
        szPath[ dwLen++ ] = chSlash;
        dw = LoadString( g_hinstance, IDS_INTELPATH, &szPath[ dwLen ], ARRAYSIZE( szPath ) - dwLen );
		Assert( dw );

        dw = LoadString( g_hinstance, IDS_TEMPLATEFILES_ALPHA, pszFiles, MAX_FILES_SIZE );
		Assert( dw );

        dwCount += CopyFilesAddToQueue( Queue, g_Options.szSourcePath, szPath, 
            pszFiles, NULL, SP_COPY_NEWER | SP_COPY_NOOVERWRITE | SP_COPY_WARNIFSKIP );
    }

    /* BEGIN

        ADD/REMOVE PROGRAMS SHOULD DO THIS PART 
    // add the services to the Queue
    GetSystemDirectory( szSystemPath, MAX_PATH );
    dw = LoadString( g_hinstance, IDS_SERVICESFILES, pszFiles, MAX_FILES_SIZE );
	Assert( dw );
    SemiColonToDoubleNullList( pszFiles );
    dwCount += CopyFilesAddToQueue( Queue, g_Options.szSourcePath, szSystemPath, pszFiles, NULL,
        SP_COPY_NEWER | SP_COPY_NOOVERWRITE | SP_COPY_WARNIFSKIP );

       END */

    // This information will be passed to CopyFileCallback() as
    // the Context.
    MyContext.nToBeCopied        = dwCount;
    MyContext.nCopied            = 0;
    MyContext.pContext           = SetupInitDefaultQueueCallback( hDlg );
    MyContext.hProg              = hProg;
    MyContext.hOperation          = GetDlgItem( hDlg, IDC_S_OPERATION );
    MyContext.dwCopyingLength = 
        LoadString( g_hinstance, IDS_COPYING, MyContext.szCopyingString, 
        ARRAYSIZE( MyContext.szCopyingString ) );
	Assert( MyContext.dwCopyingLength );

    // Start copying
    fReturn = SetupCommitFileQueue( hDlg, Queue, (PSP_FILE_CALLBACK) CopyFilesCallback, 
        (PVOID) &MyContext );

Finish:
    SendMessage( hProg, PBM_SETPOS, 1000, 0 );

    if ( Queue )
        SetupCloseFileQueue( Queue );

    if ( pszFiles )
        TraceFree( pszFiles );

    g_Options.fError = !fReturn;
    return fReturn ? S_OK : E_FAIL;
}


//
// Modifies registry entries from the SELFREG.INF resource
//
HRESULT
ModifyRegistry( HWND hDlg )
{
    HRESULT  hr = E_FAIL;
    char     szRemoteBootPath[ MAX_PATH ];
    TCHAR    szText[ SMALL_BUFFER_SIZE ];
    STRENTRY seReg[] = {
        { "25", "%SystemRoot%" },           // NT-specific
        { "11", "%SystemRoot%\\system32" }, // NT-specific
        { "RemoteBoot", szRemoteBootPath },
    };
    STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
    HWND hProg = GetDlgItem( hDlg, IDC_P_METER );
	DWORD dw;

    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 1 ));
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    dw = LoadString( g_hinstance, IDS_UPDATING_REGISTRY, szText, ARRAYSIZE( szText ) );
	Assert( dw );
    SetWindowText( GetDlgItem( hDlg, IDC_S_OPERATION ), szText );

    // fill in substitution variables
    WideCharToMultiByte( CP_ACP, 0, g_Options.szRemoteBootPath, -1,
        szRemoteBootPath, ARRAYSIZE( szRemoteBootPath ), NULL, NULL );

    hr = THR( RegInstall( g_hinstance, "InstallRemoteBoot", &stReg) );

    SendMessage( hProg, PBM_SETPOS, 1 , 0 );
    return hr;
}

//
// Creates the services needed for remote boot.
//
HRESULT
StartRemoteBootServices( HWND hDlg )
{
    TCHAR     szTFTPD[ SMALL_BUFFER_SIZE ];
    TCHAR     szBINL[ SMALL_BUFFER_SIZE ];
    TCHAR     szTFTPDName[ SMALL_BUFFER_SIZE ];
    TCHAR     szBINLName[ SMALL_BUFFER_SIZE ];
    TCHAR     szText[ SMALL_BUFFER_SIZE ];
    SC_HANDLE schSystem;
    SC_HANDLE schTFTPD;
    SC_HANDLE schTCPService;
    DWORD     dwErr = S_OK;
    HWND      hProg = GetDlgItem( hDlg, IDC_P_METER );
	DWORD     dw;

    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 1 ));
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    dw = LoadString( g_hinstance, IDS_STARTING_SERVICES, szText, ARRAYSIZE( szText ) );
	Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    dw = LoadString( g_hinstance, IDS_TFTPD,             szTFTPD, 
        ARRAYSIZE( szTFTPD ) );
	Assert( dw );
    dw = LoadString( g_hinstance, IDS_BINL,              szBINL,      
        ARRAYSIZE( szBINL ) );
	Assert( dw );
    dw = LoadString( g_hinstance, IDS_TFTPD_SERVICENAME, szTFTPDName, 
        ARRAYSIZE( szTFTPDName ) );
	Assert( dw );
    dw = LoadString( g_hinstance, IDS_BINL_SERVICENAME,  szBINLName,  
        ARRAYSIZE( szBINLName ) );
	Assert( dw );

    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    Assert( schSystem );
    if ( !schSystem )
        goto Cleanup;

    schTFTPD = OpenService( schSystem, szTFTPD, 
        STANDARD_RIGHTS_REQUIRED | SERVICE_START );

    schTCPService = OpenService( schSystem, szBINL, 
        STANDARD_RIGHTS_REQUIRED | SERVICE_START );

    // start TFTPD
    if ( !StartService( schTFTPD, 0, NULL ) )
    {
        dwErr = GetLastError( );
        switch ( dwErr )
        {
        default:
            dw = LoadString( g_hinstance, IDS_ERROR_STARTING_SERVICE, szText, 
                ARRAYSIZE( szText ) );
			Assert( dw );
            MessageBox( hDlg, szText, szTFTPDName, MB_OK );
            break;

        case ERROR_SERVICE_ALREADY_RUNNING:
            break;
        }
    }

    // start TCP services
    dw = LoadString( g_hinstance, IDS_STARTING_SERVICES, szText, ARRAYSIZE( szText ) );
	Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );
    if ( !StartService( schTCPService, 0, NULL ) )
    {
        dwErr = GetLastError( );
        switch ( dwErr )
        {
        default:
            dw = LoadString( g_hinstance, IDS_ERROR_STARTING_SERVICE, szText, 
                ARRAYSIZE( szText ) );
			Assert( dw );
            MessageBox( hDlg, szText, szBINLName, MB_OK );
            break;

        case ERROR_SERVICE_ALREADY_RUNNING:
            break;
        }
    }
    SendMessage( hProg, PBM_SETPOS, 1 , 0 );

Cleanup:    
    if ( schTCPService )
        CloseServiceHandle( schTCPService );

    if ( schTFTPD )
        CloseServiceHandle( schTFTPD );

    if ( schSystem )
        CloseServiceHandle( schSystem );

    return dwErr;
}

//
// create RemoteBoot share
//
HRESULT
CreateRemoteBootShare( HWND hDlg )
{
    SHARE_INFO_502  si502;
    TCHAR szRemark[ SMALL_BUFFER_SIZE ];
    TCHAR szRemoteBoot[ SMALL_BUFFER_SIZE ];
    TCHAR szText[ SMALL_BUFFER_SIZE ];
    DWORD dwErr;
    HWND  hProg = GetDlgItem( hDlg, IDC_P_METER );
	DWORD dw;

    dw = LoadString( g_hinstance, IDS_CREATINGSHARES, szText, ARRAYSIZE( szText ) );
	Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    dw = LoadString( g_hinstance, IDS_REMOTEBOOTSHAREREMARK, szRemark, 
        ARRAYSIZE( szRemark ) );
	Assert( dw );
    dw = LoadString( g_hinstance, IDS_REMOTEBOOTSHARENAME, szRemoteBoot, 
        ARRAYSIZE( szRemoteBoot ) );
	Assert( dw );

    si502.shi502_netname             = szRemoteBoot;
    si502.shi502_type                = STYPE_DISKTREE;
    si502.shi502_remark              = szRemark;
    si502.shi502_permissions         = ACCESS_ALL;
    si502.shi502_max_uses            = -1;   // unlimited
    si502.shi502_current_uses        = 0;
    si502.shi502_path                = g_Options.szRemoteBootPath;
    si502.shi502_passwd              = NULL; // ignored
    si502.shi502_reserved            = 0;    // must be zero
    si502.shi502_security_descriptor = NULL;

    NetShareAdd( NULL, 502, (LPBYTE) &si502, &dwErr );
    switch ( dwErr )
    {
        // ignore these
    case NERR_Success:
    case NERR_DuplicateShare:
        break;

    default:
        MessageBoxFromStrings( hDlg, IDS_SHAREERRORCAPTION, IDS_SHAREERRORTEXT, MB_OK );
    }

    SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\client\utils.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _UTILS_H_
#define _UTILS_H_

void 
CenterDialog( 
    HWND hwndDlg );

void 
ClearMessageQueue( void );


#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\automate.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997-1999
   All rights reserved

 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("RISETUP")

//
// GetAutomatedOptions( )
//
HRESULT
GetAutomatedOptions( )
{
    TraceFunc("GetAutomatedOptions( )\n" );

    HRESULT hr = S_OK;
    BOOL    b;
    DWORD   dwSize;
    WCHAR   szTemp[ 32 ];
    DWORD pathlen,archlen;
    WCHAR archscratch[10];

    INFCONTEXT SectionContext;
    INFCONTEXT context;

    Assert( g_Options.hinfAutomated != INVALID_HANDLE_VALUE );

    // make sure this is our automated file
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", NULL, &SectionContext );
    if ( !b ) goto Cleanup;

    // Tree Root
    dwSize = ARRAYSIZE( g_Options.szIntelliMirrorPath );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"RootDir", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szIntelliMirrorPath, dwSize, &dwSize );
    if ( !b ) goto Cleanup;
    g_Options.fIMirrorDirectory = TRUE;

    // Source Path
    dwSize = ARRAYSIZE( g_Options.szSourcePath );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Source", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szSourcePath, dwSize, &dwSize );
    if ( !b ) goto Cleanup;

    // Installation Directory Name
    dwSize = ARRAYSIZE( g_Options.szInstallationName );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Directory", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szInstallationName, dwSize, &dwSize );
    if ( !b ) goto Cleanup;

    // SIF Description
    dwSize = ARRAYSIZE( g_Options.szDescription );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Description", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szDescription, dwSize, &dwSize );
    if ( !b ) goto Cleanup;
    g_Options.fRetrievedWorkstationString = TRUE;

    // SIF Help Text
    dwSize = ARRAYSIZE( g_Options.szHelpText );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"HelpText", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szHelpText, dwSize, &dwSize );
    if ( !b ) goto Cleanup;

    // language -- OPTIONAL --
    dwSize = ARRAYSIZE( g_Options.szLanguage );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Language", &context );
    if ( b ) {
        b = SetupGetStringField( &context, 1, g_Options.szLanguage, dwSize, &dwSize );
        g_Options.fLanguageSet = TRUE;
        if (b) {
            g_Options.fLanguageOverRide = TRUE;
        }
    }

    // OSC Screens - OPTIONAL - defaults to LeaveAlone
    g_Options.fScreenLeaveAlone = FALSE;
    g_Options.fScreenOverwrite  = FALSE;
    g_Options.fScreenSaveOld    = FALSE;
    dwSize = ARRAYSIZE( szTemp );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Screens", &context );
    if ( b ) 
    {
        b = SetupGetStringField( &context, 1, szTemp, dwSize, &dwSize );
        if ( b ) 
        {
            if ( _wcsicmp( szTemp, L"overwrite" ) == 0 )
            {
                DebugMsg( "AUTO: Overwrite existing screens\n" );
                g_Options.fScreenOverwrite = TRUE;
            }
            else if ( _wcsicmp( szTemp, L"backup" ) == 0 )
            {
                g_Options.fScreenSaveOld = TRUE;
            }
        }
    }
    if ( !g_Options.fScreenOverwrite && !g_Options.fScreenSaveOld )
    {
        g_Options.fScreenLeaveAlone = TRUE;
    }

    // Archtecture - OPTIONAL - defaults to INTEL
    dwSize = ARRAYSIZE( szTemp );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Architecture", &context );
    if ( b ) 
    {
        b = SetupGetStringField( &context, 1, szTemp, dwSize, &dwSize );
        if ( b ) 
        {
            if ( _wcsicmp( szTemp, L"ia64" ) == 0 )
            {
                g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                wcscpy( g_Options.ProcessorArchitectureString, L"ia64" );
            }

            if ( _wcsicmp( szTemp, L"x86" ) == 0 )
            {
                g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                wcscpy( g_Options.ProcessorArchitectureString, L"i386" );
            }
        }
    }


    if (g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        wcscpy( archscratch, L"\\i386");
        archlen = 5;
    } else {        
        wcscpy( archscratch, L"\\ia64");
        archlen = 5;
    }
    
    pathlen = wcslen(g_Options.szSourcePath);

    // Remove any trailing slashes
    if ( g_Options.szSourcePath[ pathlen - 1 ] == L'\\' ) {
        g_Options.szSourcePath[ pathlen - 1 ] = L'\0';
        pathlen -= 1;
    }

    //
    // remove any processor specific subdir at the end of the path
    // if that's there as well, being careful not to underflow
    // the array
    //
    if ( (pathlen > archlen) &&
         (0 == _wcsicmp(
                    &g_Options.szSourcePath[pathlen-archlen],
                    archscratch))) {
        g_Options.szSourcePath[ pathlen - archlen ] = L'\0';
    }




    g_Options.fNewOS = TRUE;
    b = TRUE;

Cleanup:
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( NULL, L"RISETUP" );
    }

    if ( g_Options.hinfAutomated != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( g_Options.hinfAutomated );

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\client\utils.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("Utils");

//
// Centers a dialog.
//
void 
CenterDialog( 
    HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen; 
    int     cyScreen; 

    SystemParametersInfo( SPI_GETWORKAREA, 0, &rcScreen, 0 );

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect( hwndDlg, &rc );

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ( ( cyScreen - cyDlg ) / 2 );
    x = rcScreen.left + ( ( cxScreen - cxDlg ) / 2 );

    SetWindowPos( hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE );
}

//
// Eats all mouse and keyboard messages.
//
void 
ClearMessageQueue( void )
{
    MSG   msg;

    while ( PeekMessage( (LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST, 
                PM_NOYIELD|PM_REMOVE ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\automate.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997-1999
   All rights reserved

 ***************************************************************************/

#ifndef _AUTOMATE_H_
#define _AUTOMATE_H_

HRESULT
GetAutomatedOptions( );


#endif // _AUTOMATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\check.h ===
/************************************************************************

   Copyright (c) Microsoft Corporation 1997-1998
   All rights reserved
 
 ***************************************************************************/

#ifndef _CHECK_H_
#define _CHECK_H_

HRESULT
CheckInstallation( );

HRESULT
CheckServerVersion( );

DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle );

#endif // _CHECK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\debug.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: DEBUG.H

  Debugging utilities header
 
 ***************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_

// Trace Flags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_QUERYINTERFACE   0x00000001   // Query Interface details
#define TF_FUNC             0x00000002   // Functions entrances w/parameters
#define TF_CALLS            0x00000004   // Function calls
#define TF_MEMORYALLOCS     0x00000008   // Memory Allocations
#define TF_DLL              0x00000010   // DLL specific
#define TF_WM               0x00000020   // Window Messages
#define TF_SCP              0x00000030   // SCP objects
#define TF_HRESULTS         0x80000000   // Trace HRESULTs active

#ifdef DEBUG

#pragma message("BUILD: DEBUG macros being built")

// Globals
extern DWORD g_TraceMemoryIndex;
extern DWORD g_dwCounter;
extern DWORD g_dwTraceFlags;

extern const TCHAR g_szTrue[];
extern const TCHAR g_szFalse[];


// Macros
#define DEFINE_MODULE( _module ) static const TCHAR g_szModule[] = TEXT(_module);
#define __MODULE__ g_szModule
#define DEFINE_THISCLASS( _class ) static const TCHAR g_szClass[] = TEXT(_class); 
#define __THISCLASS__ g_szClass
#define DEFINE_SUPER( _super ) static const TCHAR g_szSuper[] = TEXT(_super);
#define __SUPER__ g_szSuper

#if defined(_X86_)
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK         DebugBreak( );
#endif

#define INITIALIZE_TRACE_MEMORY_PROCESS     \
    g_TraceMemoryIndex = TlsAlloc( );       \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define INITIALIZE_TRACE_MEMORY_THREAD      \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define UNINITIALIZE_TRACE_MEMORY           \
    DebugMemoryCheck( );                    \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Memory tracing terminated.\n") )

#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), !!(_fn) ) ) DEBUG_BREAK

#define TraceAlloc( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, _size, TEXT(#_size) )
#define TraceFree( _hmem )          DebugFree( _hmem )

//
// Tracing Macros
//
// All functions that begin with "Trace" are in both DEBUG and RETAIL, but
// in RETAIL they do not spew output.
//

// Displays file, line number, module and "_msg" only if the TF_FUNC is set
// in g_dwTraceFlags.
#define TraceFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ ") TEXT(_msg) );

// Displays file, line number, module, class name and "_msg" only if the 
// TF_FUNC is set in g_dwTraceFlags.
#define TraceClsFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ %s::%s"), g_szClass, TEXT(_msg) );

// Return macro for TraceFunc() and TraceClsFunc()
#define TraceFuncExit() { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V*\n") ); \
    InterlockDecrement(g_dwCounter); \
    return; \
}
#define RETURN( _rval ) { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _rval; \
}

// If the value is not S_OK, it will display it.
#define HRETURN( _hr ) { \
    if ( _hr ) \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V hr = 0x%08x\n"), _hr ); \
    else \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _hr; \
}

// Displays the file, line number, module and function call and return from the
// function call (no return value displayed) for "_fn" only if the TF_CALLS is 
// set in g_dwTraceFlags. 
#define TraceDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}

// Displays the file, line number, module and function call and return value
// which is formatted in "_msg" for "_fn" only if the TF_CALLS is set in 
// g_dwTraceFlags. 
#define TraceMsgDo( _fn, _msg ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    TraceMessageDo( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT(_msg), TEXT(#_fn), _fn ); \
    InterlockDecrement(g_dwCounter); \
}

// This functions only asserts if the result is ZERO.
#define TraceAssertIfZero( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#define TraceMsgGUID( _flag, _guid ) \
    TraceMsg( _flag, TEXT("{%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"), \
        _guid.Data1, _guid.Data2, _guid.Data3,  \
        _guid.Data4[0], _guid.Data4[1], _guid.Data4[2], _guid.Data4[3], \
        _guid.Data4[4], _guid.Data4[5], _guid.Data4[6], _guid.Data4[7] )

#define ErrorMsg( _fmt, _arg ) \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_ALWAYS, TEXT(_fmt), _arg );

//
// Debug Macros
//
// These calls are only compiled in DEBUG. They are a NOP in RETAIL (not even
// compiled in.
//

// Same as TraceDo() but only compiled in DEBUG.
#define DebugDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}

// Same as TraceMsgDo() but only compiled in DEBUG.
#define DebugMsgDo( _fn, _msg ) {\
    InterlockIncrement(g_dwCounter); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    DebugMessageDo( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), TEXT(#_fn), _fn); \
    InterlockDecrement(g_dwCounter); \
}

//
// HRESULT testing macros
//
// These functions check HRESULT return values and display UI if conditions
// warrant only in DEBUG.
//

// Warning is display if HRESULT is anything but S_OK (0).
#define THR( _fn ) \
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

// Warning is display if HRESULT is anything but S_OK (0).
#define RRETURN( _fn ) { \
    RETURN( TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn ) ); \
    }

// Warning is display if HRESULT is anything but S_OK (0) only if 
// TF_QUERYINTERFACE is set in g_dwTraceFlags, otherwise only a debug message
// will be printed.
#define QIRETURN( _fn, _riid ) { \
    if ( !!( TF_QUERYINTERFACE & g_dwTraceFlags ) ) { \
        RETURN(TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )); \
    } else if ( hr ) \
        DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("HRESULT: QueryInterface({%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}) failed()\n"),  _riid.Data1, _riid.Data2, _riid.Data3,  _riid.Data4[0], _riid.Data4[1], _riid.Data4[2], _riid.Data4[3], _riid.Data4[4], _riid.Data4[5], _riid.Data4[6], _riid.Data4[7] ); \
    RETURN(_fn); \
    }

// Warning is display if HRESULT is not S_OK (0) or "_ok".
#define RRETURN1( _hr, _ok ) {\
    RETURN(TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_hr), \
                    ( ( _hr == _ok ) ? S_OK : _hr ) ) ); \
    }

//
// Other
//
#define BOOLTOSTRING( _fBool ) ( !!(_fBool) ? g_szTrue : g_szFalse )

//
// Trace/Debug Functions - these do not exist in RETAIL.
//
void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCSTR pszFormat,
    ... );

void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCWSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCWSTR pszFormat,
    ... );

void
TraceMessage( 
    LPCTSTR pszFile, 
    const int uLine,
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void
TraceMessageDo( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... );

void 
DebugMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    ... );

void 
DebugMessageDo( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... );

BOOL
AssertMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue );

HRESULT
TraceHR( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr );

//
// Memory tracing functions - these are remapped to the "Global" memory 
// functions when in RETAIL.
//
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

HGLOBAL
DebugFree( 
    HGLOBAL hMem );

// The memory functions don't exist in RETAIL.
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

#define DebugMemoryAddHandle( _handle ) \
    DebugMemoryAdd( _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT(#_handle) );

#define DebugMemoryAddAddress( _pv ) \
    DebugMemoryAdd( _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT(#_pv) );

#define TraceStrDup( _sz ) \
    DebugMemoryAdd( StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("StrDup(") TEXT(#_sz) TEXT(")") );

void
DebugMemoryDelete( 
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

#ifdef __cplusplus
extern void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule );
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )

#endif

//
//
#else // it's RETAIL    ******************************************************
//
//

// Debugging -> NOPs
#define Assert( _fn )           
#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define DEFINE_MODULE( _module )
#define DEFINE_THISCLASS( _class )
#define DEFINE_SUPER( _super )
#define BOOLTOSTRING( _fBool )  NULL
#define AssertMsg                   1 ? (void)0 : (void) 
#define TraceMsg                    1 ? (void)0 : (void) 
#define TraceMsgGUID( _f, _g )      
#define DebugMsg                    1 ? (void)0 : (void) 
#define ErrorMsg                    1 ? (void)0 : (void) 
#define TraceMessage                1 ? (void)0 : (void) 
#define DebugMessage                1 ? (void)0 : (void) 
#define AssertMessage               1 ? (void)0 : (void) 
#define TraceHR                     1 ? (void)0 : (void) 
#define TraceFunc                   1 ? (void)0 : (void) 
#define TraceClsFunc                1 ? (void)0 : (void) 
#define TraceFuncExit()
#define DebugMemoryAddHandle( _handle )
#define DebugMemoryAddAddress( _pv )
#define INITIALIZE_TRACE_MEMORY_PROCESS
#define INITIALIZE_TRACE_MEMORY_THREAD
#define UNINITIALIZE_TRACE_MEMORY
#define DebugMemoryDelete( _h )

// Tracing -> just do operation
#define TraceDo( _fn )              _fn
#define TraceMsgDo( _fn, _msg )     _fn
#define TraceAssertIfZero( _fn )    _fn

// RETURN testing -> do retail
#define THR
#define RETURN( _fn )               return _fn
#define RRETURN( _fn )              return _fn
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi

// Memory Functions -> do retail
#define TraceAlloc( _flags, _size )     GlobalAlloc( _flags, _size )
#define TraceFree( _pv )                GlobalFree( _pv )
#define TraceStrDup( _sz )              StrDup( _sz )

#endif // DBG==1

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\check.cpp ===
/************************************************************************

   Copyright (c) Microsoft Corporation 1997-1998
   All rights reserved

 ***************************************************************************/

#include "pch.h"

#include "setup.h"
#include "check.h"

DEFINE_MODULE("Check");
#define SMALL_BUFFER_SIZE 256
#define FILTER_SIZE 128
#define BIG_BUFFER        4096

//
// Ldap_InitializeConnection( )
//
DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle )
{
    TraceFunc( "Ldap_InitializeConnection( ... )\n" );

    PLDAPMessage OperationalAttributeLdapMessage;
    PLDAPMessage CurrentEntry;

    DWORD LdapError = LDAP_SUCCESS;

    if ( !( *LdapHandle ) ) {
        ULONG temp = DS_DIRECTORY_SERVICE_REQUIRED |
                     DS_IP_REQUIRED;

        *LdapHandle = ldap_init( NULL, LDAP_PORT);

        if ( !*LdapHandle )
        {
            LdapError = GetLastError( );
            goto e0;
        }

        ldap_set_option( *LdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &temp );

        temp = LDAP_VERSION3;
        ldap_set_option( *LdapHandle, LDAP_OPT_VERSION, &temp );

        //
        //  our searches should be contained to a single naming context, though
        //  we should be able to go outside the root of the tree to find the
        //  naming context we're interested in.
        //

        temp = LDAP_CHASE_EXTERNAL_REFERRALS;
        ldap_set_option( *LdapHandle, LDAP_OPT_REFERRALS, &temp );

        LdapError = ldap_connect( *LdapHandle, 0 );

        if ( LdapError != LDAP_SUCCESS )
            goto e1;

        LdapError = ldap_bind_s( *LdapHandle, NULL, NULL, LDAP_AUTH_SSPI );

        if ( LdapError != LDAP_SUCCESS )
            goto e1;
    }

e0:
    if ( LdapError != LDAP_SUCCESS ) {
        DebugMsg( "!!Error initializing LDAP connection.\n" );
    }
    RETURN( LdapError );

e1:
    ldap_unbind( *LdapHandle );
    *LdapHandle = NULL;
    goto e0;
}


//
// CheckDSForSCP( )
//
HRESULT
CheckDSForSCP( )
{
    TraceFunc( "CheckDSForSCP( )\n" );

    HRESULT hr = S_FALSE;
    PLDAP LdapHandle = NULL;
    DWORD LdapError = LDAP_SUCCESS;
    DWORD count;

    LPWSTR * ppszPath;
    PLDAPMessage CurrentEntry;
    PLDAPMessage LdapMessage;

    ULONG  ulSize;
    LPWSTR pMachineDN = NULL;

    //  Paramters we want from the Computer Object
    LPWSTR ComputerAttrs[2];
    ComputerAttrs[0] = TEXT("netbootSCPBL");
    ComputerAttrs[1] = NULL;

    //
    // We already detected it
    //
    if ( g_Options.fBINLSCPFound ) {
        Assert( LdapError == LDAP_SUCCESS );
        hr = S_OK;
        goto e0;
    }

    if ( !GetComputerObjectName( NameFullyQualifiedDN, NULL, &ulSize ) ) {
        DWORD Error = GetLastError( );
        MessageBoxFromStrings( NULL, IDS_DOMAINMEMBERSHIP_TITLE, IDS_DOMAINMEMBERSHIP_TEXT, MB_OK );
        hr = THR(E_FAIL);
        goto e0;
    }

    pMachineDN = (LPWSTR) TraceAlloc( LPTR, ulSize * sizeof(WCHAR) );
    
    if ( !pMachineDN ) {
        hr = THR(E_OUTOFMEMORY);
        goto e0;
    }

    if ( !GetComputerObjectName( NameFullyQualifiedDN, pMachineDN, &ulSize ) ) {
        DWORD Error = GetLastError( );
        MessageBoxFromStrings( NULL, IDS_DOMAINMEMBERSHIP_TITLE, IDS_DOMAINMEMBERSHIP_TEXT, MB_OK );
        hr = THR(E_FAIL);
        goto e0;
    }

    DebugMsg( "Our MAO's DN is %s.\n", pMachineDN );

    LdapError = Ldap_InitializeConnection( &LdapHandle );
    if ( LdapError != ERROR_SUCCESS ) {
        hr = THR( HRESULT_FROM_WIN32( LdapMapErrorToWin32( LdapError ) ) );
        MessageBoxFromError( NULL, NULL, LdapMapErrorToWin32(LdapError) );
        LdapError = LDAP_SUCCESS;
        goto e0;
    }

    LdapError = ldap_search_ext_s( LdapHandle,
                                    pMachineDN,
                                    LDAP_SCOPE_BASE,
                                    L"(objectClass=computer)",
                                    ComputerAttrs,
                                    FALSE,
                                    NULL,
                                    NULL,
                                    NULL,
                                    0,
                                    &LdapMessage);

    if (LdapError == LDAP_NO_SUCH_ATTRIBUTE ) {
        DebugMsg( "SCP not found.\n" );
        LdapError = ERROR_SUCCESS;
        hr = S_FALSE;
        goto e1;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );
    if (count!= 1) {
        //
        //  What should we do with two entries for the same server?
        //
        if ( count ) {
            Assert(FALSE);
        }
        DebugMsg( "SCP not found.\n" );
        goto e2;
    }

    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    ppszPath = ldap_get_values( LdapHandle, CurrentEntry, TEXT("netbootSCPBL") );
    if ( !ppszPath ) {
        DebugMsg( "SCP not found.\n" );
        LdapError = LDAP_OTHER;
        goto e2;
    }

    DebugMsg( "SCP found.\n" );

    g_Options.fBINLSCPFound = TRUE;

    hr = S_OK;

    ldap_value_free(ppszPath);

e2:
    ldap_msgfree( LdapMessage );

e1:
    ldap_unbind( LdapHandle );

e0:
    if ( LdapError != LDAP_SUCCESS ) {
        hr = S_FALSE;
    }

    if ( pMachineDN ) {
        TraceFree( pMachineDN );
    }

    HRETURN(hr);
}

//
// CheckDirectoryTree( )
//
HRESULT
CheckDirectoryTree( )
{
    HRESULT hr = S_FALSE;
    LPSHARE_INFO_502 psi;
    WCHAR szPath[ MAX_PATH ];
    WCHAR szCreating[ SMALL_BUFFER_SIZE ];
    DWORD dwLen;
    DWORD dw;
    BOOL  f;

    TraceFunc( "CheckDirectoryTree()\n" );

    Assert( g_Options.hinf != INVALID_HANDLE_VALUE );

    //
    // Try to find the IMIRROR share
    //
    if ( !g_Options.fIMirrorShareFound  ) {
        dw = LoadString( g_hinstance, IDS_REMOTEBOOTSHARENAME, szPath, ARRAYSIZE( szPath ));
        Assert( dw );
        if ( NERR_Success == NetShareGetInfo( NULL, szPath, 502, (LPBYTE *)&psi ) ) {
            if ( !g_Options.fIMirrorDirectory ) {
                lstrcpy( g_Options.szIntelliMirrorPath, psi->shi502_path );
                Assert( wcslen(g_Options.szIntelliMirrorPath) < ARRAYSIZE(g_Options.szInstallationPath) );
                g_Options.fIMirrorDirectory  = TRUE;
            }

            g_Options.fIMirrorShareFound = TRUE;

            DebugMsg( "Found the IMIRROR share, using it for the IntelliMirror Directory: %s\n", g_Options.szIntelliMirrorPath );

            NetApiBufferFree( psi );
        }
    }

    //
    // Try to use the TFTPD's reg key to find the IntelliMirror tree.
    //
    if ( !g_Options.fIMirrorDirectory
      && !g_Options.fTFTPDDirectoryFound ) {
        //
        // Try finding TFTPD's regkey to find the IntelliMirror Directory
        //
        HKEY  hkey;

        dw = LoadString( g_hinstance, IDS_TFTPD_SERVICE_PARAMETERS, szPath, ARRAYSIZE( szPath ));
        Assert( dw );

        if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            szPath,
                                            0, // options
                                            KEY_QUERY_VALUE,
                                            &hkey ) ) {
            ULONG l;
            DWORD dwType;
            LONG lErr;

            l = sizeof(g_Options.szTFTPDDirectory);
            lErr = RegQueryValueEx( hkey,
                                    L"Directory",
                                    0, // reserved
                                    &dwType,
                                    (LPBYTE) g_Options.szTFTPDDirectory,
                                    &l );
            Assert( wcslen(g_Options.szTFTPDDirectory) < ARRAYSIZE(g_Options.szTFTPDDirectory) );
            if ( lErr == ERROR_SUCCESS ) {
                DebugMsg( "Found TFTPD's Directory regkey: %s\n", g_Options.szTFTPDDirectory );
                g_Options.fTFTPDDirectoryFound = TRUE;
            }
            RegCloseKey( hkey );
        }
    }

    if ( !g_Options.fIMirrorDirectory
       && g_Options.fTFTPDDirectoryFound ) {
        StrCpy( g_Options.szIntelliMirrorPath, g_Options.szTFTPDDirectory );
        Assert( wcslen(g_Options.szIntelliMirrorPath) < ARRAYSIZE(g_Options.szInstallationPath) );
        g_Options.fIMirrorDirectory = TRUE;
        DebugMsg( "Used the TFTPD RegKey to find the IntelliMirror Directory.\n" );
    }

    //
    // Did we find the IntelliMirror directory?
    //
    if ( !g_Options.fIMirrorDirectory ) {
        //
        // Nope... so figure out which drive we can put it on.
        // Find a non-system, fixed disk, drive to place the
        // IntelliMirror directory tree
        //
        WCHAR chSystemDriveLetter;
        WCHAR chLargestDriveLetter = 0;
        ULARGE_INTEGER uliBiggestFree = { 0 };
        WCHAR szRootDrive[ 4 ] = TEXT("C:\\");

        DebugMsg( "Could not find the IntelliMirror directory.\n" );

        dw = LoadString( g_hinstance, IDS_DEFAULTPATH, szPath, ARRAYSIZE( szPath ) );
        Assert( dw );
        dw = ExpandEnvironmentStrings( szPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(g_Options.szInstallationPath));
        Assert( dw );

        // The default string actually contains the system drive letter
        chSystemDriveLetter = g_Options.szIntelliMirrorPath[0];
        DebugMsg(  "Searching for suitable drive:" );

        for( ; szRootDrive[0] <= TEXT('Z'); szRootDrive[0]++ )
        {
            ULARGE_INTEGER uliFree;
            ULARGE_INTEGER uliTotal;
            ULARGE_INTEGER uliBytesFree;
            UINT uDriveType;

            DebugMsg( "%s ", szRootDrive );

            uDriveType = GetDriveType( szRootDrive );

            if ( DRIVE_FIXED != uDriveType
              || szRootDrive[0] == chSystemDriveLetter )
                continue; // skip non-fixed and non-system drives

            if ( !GetDiskFreeSpaceEx( szRootDrive, &uliFree, &uliTotal, &uliBytesFree ) )
                continue; // error - skip it.

            if ( uliBytesFree.QuadPart > uliBiggestFree.QuadPart )
            {
                chLargestDriveLetter = szRootDrive[0];
                uliBiggestFree = uliBytesFree;
            }
        }
        DebugMsg( "\n" );

        if ( !chLargestDriveLetter )
        {
            g_Options.szIntelliMirrorPath[0] = chSystemDriveLetter;
            DebugMsg( "BAD! Using system drive as default.\n" );
        }
        else
        {
            g_Options.szIntelliMirrorPath[0] = chLargestDriveLetter;
            DebugMsg( "Suggesting %s for the IntelliMirror Drive/Directory.\n", g_Options.szIntelliMirrorPath );
        }

        goto e0; // skip the tree
    }

    //
    // Check the directory tree.
    // If any of these fail, just recreate the whole tree.
    //
    DebugMsg( "Checking Directory Tree:\n" );
    //
    // Create
    // "D:\IntelliMirror"
    //
    DebugMsg( "%s\n", g_Options.szIntelliMirrorPath );
    if ( 0xFFFFffff == GetFileAttributes( g_Options.szIntelliMirrorPath ) )
        goto e0;

    //
    // Create
    // "D:\IntelliMirror\Setup"
    //
    wcscpy( szPath, g_Options.szIntelliMirrorPath );
    ConcatenatePaths( szPath, L"\\Setup" );
    Assert( wcslen(szPath) < ARRAYSIZE(szPath));
    DebugMsg( "%s\n", szPath );
    if ( 0xFFFFffff == GetFileAttributes( szPath ) )
        goto e0;

    //
    // Create the OS Chooser tree
    // "D:\IntelliMirror\OSChooser"
    //
    wcscpy( g_Options.szOSChooserPath, g_Options.szIntelliMirrorPath );
    ConcatenatePaths( g_Options.szOSChooserPath, L"\\OSChooser" );
    Assert( wcslen(g_Options.szOSChooserPath) < ARRAYSIZE(g_Options.szOSChooserPath) );
    DebugMsg( "%s\n", g_Options.szOSChooserPath );
    if ( 0xFFFFffff == GetFileAttributes( g_Options.szOSChooserPath ) )
        goto e0;

    g_Options.fOSChooserDirectory = TRUE;

    if ( !g_Options.fOSChooserDirectoryTreeExists ) {
        WCHAR szFile[ MAX_PATH ];
        BOOL fFound;
        INFCONTEXT context;

        fFound = SetupFindFirstLine( g_Options.hinf, L"OSChooser", NULL, &context );
        AssertMsg( fFound, "Could not find 'OSChooser' section in REMINST.INF.\n" );

        while ( fFound
             && SetupGetStringField( &context, 1, szFile, ARRAYSIZE(szFile), NULL ) )
        {
            LPWSTR psz = StrChr( szFile, L'\\' );
            if ( psz ) {
                *psz = L'\0'; // terminate
                wsprintf( szPath,
                          L"%s\\%s",
                          g_Options.szOSChooserPath,
                          szFile );
                Assert( wcslen(szPath) < ARRAYSIZE(szPath) );

                DebugMsg( "%s\n", szPath );

                if ( 0xFFFFffff == GetFileAttributes( szPath ) )
                    goto e0;
            }

            fFound = SetupFindNextLine( &context, &context );
        }

        g_Options.fOSChooserDirectoryTreeExists = TRUE;
    }

    g_Options.fDirectoryTreeExists = TRUE;

e0:
    if ( g_Options.fIMirrorDirectory
        && g_Options.fIMirrorShareFound
        && g_Options.fDirectoryTreeExists
        && g_Options.fOSChooserDirectory
        && g_Options.fOSChooserDirectoryTreeExists ) {
        DebugMsg( "All directories found.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "Directory tree check failed.\n" );
    }

    HRETURN(hr);
}

BOOL
CheckService(
    SC_HANDLE schSystem,
    LPWSTR ServiceName,
    LPBOOL Started
    )
{
    SC_HANDLE sch;
    SERVICE_STATUS status;
    BOOL b;

    sch = OpenService( schSystem,
                       ServiceName,
                       SERVICE_ALL_ACCESS );
    if ( sch == NULL ) {
        DebugMsg( "%ws is NOT installed.\n", ServiceName );
        return FALSE;
    }

    DebugMsg( "%ws is installed.\n", ServiceName );

    b = QueryServiceStatus( sch, &status);
    *Started = (BOOL)(b && (status.dwCurrentState == SERVICE_RUNNING));
    DebugMsg( "%ws is %wsrunning.\n", ServiceName, *Started ? L"" : L"not " );

    CloseServiceHandle( sch );

    return TRUE;

} // CheckService

//
// CheckBINL( )
//
HRESULT
CheckBINL(
    SC_HANDLE schSystem )
{
    HRESULT   hr = S_FALSE;
    WCHAR     szPath[ MAX_PATH ];
    WCHAR     szFiles[ MAX_PATH ];
    LPWSTR    psz;
    DWORD     dw;
    BOOL      started = TRUE;

    TraceFunc( "CheckBINL( )\n" );

    //
    // Check to see if the service manager can find the service
    //
    if ( !g_Options.fBINLServiceInstalled ) {

        if ( CheckService( schSystem, L"BINLSVC", &started ) ) {
            g_Options.fBINLServiceInstalled = TRUE;
        }
    }

    //
    // Read the REMINST.INF for the files need for the service
    //
    if ( !g_Options.fBINLFilesFound ) {
        WCHAR szSystem32Path[ MAX_PATH ];
        WCHAR szFile[ MAX_PATH ];
        UINT  index;
        BOOL  b;
        INFCONTEXT context;

        dw = ExpandEnvironmentStrings( TEXT("%windir%"), szSystem32Path, ARRAYSIZE( szSystem32Path ));
        Assert( dw );
        StrCat( szSystem32Path, TEXT("\\system32") );

        b = SetupFindFirstLine( g_Options.hinf, L"Service.BINLSVC", L"FilesRequired", &context );
        Assert( b );
        if ( !b )
            goto BINLCheckSCP;

        index = 1;
        while ( SetupGetStringField( &context, index, szFile, ARRAYSIZE( szFile ), NULL ) )
        {
            WCHAR szPath[ 2 * MAX_PATH ];

            wsprintf( szPath,
                      L"%s\\%s",
                      szSystem32Path,
                      szFile );

            if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                DebugMsg( "%s is missing for Service BINLSVC.\n", szPath );
                goto BINLCheckSCP;
            }

            DebugMsg( "%s found.\n", szPath );

            index++;
        }

        g_Options.fBINLFilesFound = TRUE;
    }

    //
    // Check to see if the SCP exists
    //
BINLCheckSCP:
    hr = CheckDSForSCP( );

    if ( hr == S_OK
      && g_Options.fBINLFilesFound
      && g_Options.fBINLServiceInstalled
      && started ) {
        DebugMsg( "All BINL services checked out OK.\n");
        hr = S_OK;
    } else if ( hr == S_OK ) {
        DebugMsg( "BINL check found something strange with the SCP. Ignoring.\n" );
        hr = S_FALSE;
    } else {
        DebugMsg( "BINL check failed.\n" );
    }

    HRETURN(hr);
}

//
// CheckTFTPD( )
//
HRESULT
CheckTFTPD(
    SC_HANDLE schSystem )
{
    HRESULT   hr = S_FALSE;
    WCHAR     szPath[ MAX_PATH ];
    WCHAR     szFiles[ MAX_PATH ];
    LPWSTR    psz;
    DWORD     dw;
    HKEY hkey;
    BOOL      started = TRUE;

    TraceFunc( "CheckTFTPD( )\n" );

    //
    // Check to see if the service manager can find the service
    //
    if ( !g_Options.fTFTPDServiceInstalled ) {

        if ( CheckService( schSystem, L"TFTPD", &started ) ) {
            g_Options.fTFTPDServiceInstalled = TRUE;
        }
    }

    //
    // Read the REMINST.INF for the files need for the service
    //
    if ( !g_Options.fTFTPDFilesFound ) {
        WCHAR szSystem32Path[ MAX_PATH ];
        WCHAR szFile[ MAX_PATH ];
        UINT  index;
        BOOL  b;
        INFCONTEXT context;

        dw = ExpandEnvironmentStrings( TEXT("%windir%"), szSystem32Path, ARRAYSIZE( szSystem32Path ) );
        Assert( dw );
        StrCat( szSystem32Path, TEXT("\\system32") );

        b = SetupFindFirstLine( g_Options.hinf, L"Service.TFTPD", L"FilesRequired", &context );
        Assert( b );
        if ( !b )
            goto TFTPDCheckReg;

        index = 1;
        while ( SetupGetStringField( &context, index, szFile, ARRAYSIZE( szFile ), NULL ) )
        {
            WCHAR szPath[ 2 * MAX_PATH ];

            wsprintf( szPath,
                      L"%s\\%s",
                      szSystem32Path,
                      szFile );

            if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                DebugMsg( "%s is missing for Service TFTPD.\n", szPath );
                goto TFTPDCheckReg;
            }

            DebugMsg( "%s found.\n", szPath );

            index++;
        }

        g_Options.fTFTPDFilesFound = TRUE;
    }

TFTPDCheckReg:
    //
    // Check to see if the Directory reg key exists
    //
    if ( !g_Options.fTFTPDDirectoryFound ) {
        dw = LoadString( g_hinstance, IDS_TFTPD_SERVICE_PARAMETERS, szPath, ARRAYSIZE( szPath ));
        Assert( dw );

        if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            szPath,
                                            0, // options
                                            KEY_QUERY_VALUE,
                                            &hkey ) ) {
            ULONG l;
            DWORD dwType;
            LONG lErr;

            l = sizeof(g_Options.szTFTPDDirectory);
            lErr = RegQueryValueEx( hkey,
                                    L"Directory",
                                    0, // reserved
                                    &dwType,
                                    (LPBYTE) g_Options.szTFTPDDirectory,
                                    &l );
            if ( lErr == ERROR_SUCCESS ) {
                DebugMsg( "TFTPD's Directory RegKey found: %s\n", g_Options.szTFTPDDirectory );
                Assert( wcslen(g_Options.szTFTPDDirectory) < ARRAYSIZE(g_Options.szTFTPDDirectory) );

                if ( 0xFFFFffff == GetFileAttributes( g_Options.szTFTPDDirectory ) ) {
                    DebugMsg( "BUT, %s was not found.\n", g_Options.szTFTPDDirectory );
                }

                g_Options.fTFTPDDirectoryFound = TRUE;
            }

            RegCloseKey( hkey );
        } else {
            DebugMsg( "HKLM\\%s not found.\n", szPath );
        }
    }

    if ( g_Options.fTFTPDDirectoryFound
      && g_Options.fTFTPDFilesFound
      && g_Options.fTFTPDServiceInstalled
      && started ) {
        DebugMsg( "All TFTPD services checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "TFTPD check failed.\n" );
    }

    HRETURN(hr);
}

//
// CheckSIS( )
//
HRESULT
CheckSIS(
    SC_HANDLE schSystem )
{
    HRESULT   hr = S_FALSE;
    WCHAR     szPath[ MAX_PATH ];
    WCHAR     szFiles[ MAX_PATH ];
    WCHAR     szVolumePath[ MAX_PATH ];
    LPWSTR    psz;
    DWORD     dw;
    BOOL      started = TRUE;

    TraceFunc( "CheckSIS( )\n" );

    //
    // Check to see if the service manager can find the service
    //
    if ( !g_Options.fSISServiceInstalled ) {

        if ( CheckService( schSystem, L"SIS", &started ) ) {
            g_Options.fSISServiceInstalled = TRUE;
        }
    }

    //
    // Read the REMINST.INF for the files need for the service
    //
    if ( !g_Options.fSISFilesFound ) {
        WCHAR szSystem32Path[ MAX_PATH ];
        WCHAR szFile[ MAX_PATH ];
        UINT  index;
        BOOL  b;
        INFCONTEXT context;

        dw = ExpandEnvironmentStrings( TEXT("%windir%"), szSystem32Path, ARRAYSIZE( szSystem32Path ));
        Assert( dw );
        StrCat( szSystem32Path, TEXT("\\system32") );

        b = SetupFindFirstLine( g_Options.hinf, L"Service.SIS", L"FilesRequired", &context );
        Assert( b );
        if ( !b )
            goto SISCheckVolume;

        index = 1;
        while ( SetupGetStringField( &context, index, szFile, ARRAYSIZE( szFile ), NULL ) )
        {
            WCHAR szPath[ 2 * MAX_PATH ];

            wsprintf( szPath,
                      L"%s\\%s",
                      szSystem32Path,
                      szFile );

            if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                DebugMsg( "%s is missing for Service SIS.\n", szPath );
                goto SISCheckVolume;
            }

            DebugMsg( "%s found.\n", szPath );

            index++;
        }

        g_Options.fSISFilesFound = TRUE;
    }

SISCheckVolume:
    if ( !g_Options.fSISVolumeCreated ) {
        //
        // If we know the IMirrorDirectory (and hence the volume), check
        // to see if the Common Store Directory has been created.
        //
        if ( g_Options.fIMirrorDirectory ) {

            GetVolumePathName( g_Options.szIntelliMirrorPath, szVolumePath, ARRAYSIZE( szVolumePath ));
            wsprintf( szPath, L"%s\\SIS Common Store", szVolumePath );
            Assert( wcslen(szPath) < ARRAYSIZE(szPath) );

            if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                DebugMsg( "%s is missing.\n", szPath );
                goto e0;
            }

            DebugMsg( "%s found.\n", szPath );

            g_Options.fSISVolumeCreated = TRUE;
        }
    }

    if ( g_Options.fSISVolumeCreated
      && g_Options.fSISFilesFound
      && g_Options.fSISServiceInstalled
      && started ) {
        DebugMsg( "All SIS services checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "SIS check failed.\n" );
    }

e0:
    HRETURN(hr);

}

//
// CheckSISGroveler( )
//
HRESULT
CheckSISGroveler(
    SC_HANDLE schSystem )
{
    HRESULT   hr = S_FALSE;
    WCHAR     szPath[ MAX_PATH ];
    WCHAR     szFiles[ MAX_PATH ];
    LPWSTR    psz;
    DWORD     dw;
    BOOL      started = TRUE;

    TraceFunc( "CheckSISGroveler( )\n" );

    //
    // Check to see if the service manager can find the service
    //
    if ( !g_Options.fSISGrovelerServiceInstalled ) {

        if ( CheckService( schSystem, L"Groveler", &started ) ) {
            g_Options.fSISGrovelerServiceInstalled = TRUE;
        }
    }

    //
    // Read the REMINST.INF for the files need for the service
    //
    if ( !g_Options.fSISGrovelerFilesFound ) {
        WCHAR szSystem32Path[ MAX_PATH ];
        WCHAR szFile[ MAX_PATH ];
        UINT  index;
        BOOL  b;
        INFCONTEXT context;

        dw = ExpandEnvironmentStrings( TEXT("%windir%"), szSystem32Path, ARRAYSIZE( szSystem32Path ));
        Assert( dw );
        StrCat( szSystem32Path, TEXT("\\system32") );

        b = SetupFindFirstLine( g_Options.hinf, L"Service.SISGroveler", L"FilesRequired", &context );
        Assert( b );
        if ( !b )
            goto e0;

        index = 1;
        while ( SetupGetStringField( &context, index, szFile, ARRAYSIZE( szFile ), NULL ) )
        {
            WCHAR szPath[ 2 * MAX_PATH ];

            wsprintf( szPath,
                      L"%s\\%s",
                      szSystem32Path,
                      szFile );

            if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                DebugMsg( "%s is missing for Service SIS Groveler.\n", szPath );
                goto e0;
            }

            DebugMsg( "%s found.\n", szPath );

            index++;
        }

        g_Options.fSISGrovelerFilesFound = TRUE;
    }

    if ( g_Options.fSISGrovelerFilesFound
      && g_Options.fSISGrovelerServiceInstalled
      && started ) {
        DebugMsg( "All SIS Groveler services checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "SIS Groveler check failed.\n" );
    }

e0:
    HRETURN(hr);

}

//
// CheckRegSrvDlls( )
//
HRESULT
CheckRegSrvDlls( )
{
    HRESULT hr = S_FALSE;
    WCHAR   szSection[ SMALL_BUFFER_SIZE ];
    WCHAR   szRegSrv[ SMALL_BUFFER_SIZE ];
    WCHAR   szFile[ MAX_PATH ];
    WCHAR   szSystem32Path[ MAX_PATH ];
    DWORD   dw;
    INT     index;
    BOOL    fMissingDll = FALSE;
    BOOL    fRegistrationFailed = FALSE;
    BOOL    b;
    INFCONTEXT context;

    TraceFunc( "CheckRegSrvDlls( )\n" );

    if ( !g_Options.fRegSrvDllsFilesFound ||
        ! g_Options.fRegSrvDllsRegistered ) {
        dw = ExpandEnvironmentStrings( TEXT("%windir%"), szSystem32Path, ARRAYSIZE( szSystem32Path ));
        Assert( dw );
        StrCat( szSystem32Path, TEXT("\\system32") );

        dw = LoadString( g_hinstance, IDS_INF_SECTION, szSection, ARRAYSIZE( szSection ));
        Assert( dw );

        b = SetupInstallFromInfSection(NULL,            // hwndOwner
                                       g_Options.hinf,  // inf handle
                                       szSection,       // name of component
                                       SPINST_REGSVR,
                                       NULL,            // relative key root
                                       NULL,            // source root path
                                       0,               // copy flags
                                       NULL,            // callback routine
                                       NULL,            // callback routine context
                                       NULL,            // device info set
                                       NULL);           // device info struct
        if ( !b )
        {
            DWORD dwErr = GetLastError( );
            DebugMsg( "SetupInstallFromInfSection failed - error 0x%08x\n", dwErr );
            //
            // For now do extra work and try both copying and re-registering the DLL,
            // otw if we want to optimize we might be able to use the error code to 
            // determine which to do.  However, this case is extremely rare, so the 
            // simple extra work is not a burden.
            //
            fMissingDll = TRUE;
            fRegistrationFailed = TRUE;
        }
        
        g_Options.fRegSrvDllsFilesFound = !fMissingDll;
        g_Options.fRegSrvDllsRegistered = !(fMissingDll || fRegistrationFailed);
    }

    if ( g_Options.fRegSrvDllsFilesFound
      && g_Options.fRegSrvDllsRegistered ) {
        DebugMsg( "All DLLs found and registered.\n" );
        hr = S_OK;
    }

    HRETURN(hr);
}

//
// CheckOSChooser( )
//
HRESULT
CheckOSChooser( )
{
    HRESULT hr = S_FALSE;
    WCHAR szOSChooserScreensPath[ MAX_PATH ];
    DWORD dw;

    TraceFunc( "CheckOSChooser( )\n" );

    //
    // Make sure the OS Chooser files for all platforms
    // are installed
    //
    if ( !g_Options.fOSChooserInstalled
      && g_Options.fOSChooserDirectory ) {
        WCHAR szFile[ MAX_PATH ];
        BOOL  fFound;
        INFCONTEXT context;

        fFound = SetupFindFirstLine( g_Options.hinf, L"OSChooser", NULL, &context );
        Assert( fFound );
        if ( !fFound ) {
            DebugMsg( "Could not find 'OSChooser' section in REMINST.INF.\n" );
            goto OSChooserCheckScreens;
        }

        while ( fFound
             && SetupGetStringField( &context, 1, szFile, ARRAYSIZE(szFile), NULL ) )
        {
            WCHAR szPath[ MAX_PATH ];
            wsprintf( szPath,
                      L"%s\\%s",
                      g_Options.szOSChooserPath,
                      szFile );
            Assert( wcslen(szPath) < ARRAYSIZE(szPath) );

            if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                DebugMsg( "%s is missing for OS Chooser.\n", szPath );
                goto OSChooserCheckScreens;
            }

            fFound = SetupFindNextLine( &context, &context );
        }

        DebugMsg( "All OS Chooser files found.\n" );
        g_Options.fOSChooserInstalled = TRUE;
    }

OSChooserCheckScreens:
    //
    // Check to see if all the screens are present
    //
    // Make the check only if we have a language set.
    if ( g_Options.fLanguageSet ) {

        // First check for the directory
        if ( !g_Options.fOSChooserScreensDirectory ) {
            WCHAR szOSChooserScreensPath[ MAX_PATH ];

            wsprintf( szOSChooserScreensPath,
                      L"%s\\%s",
                      g_Options.szOSChooserPath,
                      g_Options.szLanguage );
            Assert( wcslen(szOSChooserScreensPath) < ARRAYSIZE(szOSChooserScreensPath) );


            if ( 0xFFFFffff == GetFileAttributes( szOSChooserScreensPath ) ) {
                DebugMsg( "%s directory not found.\n", szOSChooserScreensPath );
                goto OSChooserExitCheckScreens;
            }

            DebugMsg( "%s directory found.\n", szOSChooserScreensPath );
            g_Options.fOSChooserScreensDirectory = TRUE;
        }

        // now check for files
        if ( !g_Options.fOSChooserScreens
           && g_Options.fOSChooserScreensDirectory ) {
            WCHAR szFile[ MAX_PATH ];
            BOOL  fFound;
            INFCONTEXT context;

            fFound = SetupFindFirstLine( g_Options.hinf, L"OSChooser Screens", NULL, &context );
            Assert( fFound );
            if ( !fFound )
                goto OSChooserExitCheckScreens;

            while ( fFound
                 && SetupGetStringField( &context, 1, szFile, ARRAYSIZE(szFile), NULL ) )
            {
                WCHAR szPath[ MAX_PATH ];
                wsprintf( szPath,
                          L"%s\\%s\\%s",
                          g_Options.szOSChooserPath,
                          g_Options.szLanguage,
                          szFile );
                Assert( wcslen(szPath) < ARRAYSIZE(szPath) );

                if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                    DebugMsg( "%s is missing for OS Chooser.\n", szPath );
                    goto OSChooserExitCheckScreens;
                }

                fFound = SetupFindNextLine( &context, &context );
            }

            g_Options.fOSChooserScreens = TRUE;
            DebugMsg( "All OS Chooser screens found for language %s.\n", g_Options.szLanguage );
        }
    }
OSChooserExitCheckScreens:

    if ( g_Options.fOSChooserDirectory
      && g_Options.fOSChooserInstalled
      && ( !g_Options.fLanguageSet
        ||  ( g_Options.fOSChooserScreensDirectory
           && g_Options.fOSChooserScreens ) ) ) {
        DebugMsg( "All OS Chooser services checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "OS Chooser check failed.\n" );
    }

    HRETURN(hr);
}

//
// CheckServerVersion( )
//
HRESULT
CheckServerVersion( )
{
    HRESULT hr = S_OK;

    TraceFunc( "CheckServerVersion( )\n" );

    // DebugMsg( "Fudging Server Version check...\n" );
    // g_Options.fServerCompatible = TRUE;

    if ( !g_Options.fServerCompatible
       && g_Options.szWorkstationRemBootInfPath[0] ) {
        OSVERSIONINFO osver;

        hr = E_FAIL;

        osver.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
        if ( GetVersionEx( &osver ) ) {

            WCHAR szSection[ MAX_PATH ];
            WCHAR szBestBuild[ MAX_PATH ];
            WCHAR szPath[ MAX_PATH ];
            WCHAR szServerMajor[ 10 ];
            WCHAR szServerMinor[ 10 ];
            WCHAR szServerBuild[ 10 ];
            DWORD dw;
            BOOL  fFound;
            HINF  hinf;
            UINT  uLineNum;
            INFCONTEXT context;

            dw = LoadString( g_hinstance, IDS_COMPATIBILITY, szSection, ARRAYSIZE( szSection ));
            Assert( dw );

            wsprintf( szServerMajor, L"%u", osver.dwMajorVersion );
            wsprintf( szServerMinor, L"%u", osver.dwMinorVersion );
            wsprintf( szServerBuild, L"%u", osver.dwBuildNumber  );

            DebugMsg( "Server Version: %u.%u  Build: %u  Service Pack: %s\n",
                      osver.dwMajorVersion,
                      osver.dwMinorVersion,
                      osver.dwMinorVersion,
                      osver.szCSDVersion );

            hinf = SetupOpenInfFile( g_Options.szWorkstationRemBootInfPath, NULL, INF_STYLE_WIN4, &uLineNum);
            if ( hinf == INVALID_HANDLE_VALUE ) {
                ErrorBox( NULL, g_Options.szWorkstationRemBootInfPath );
                goto Error;
            }

            fFound = SetupFindFirstLine( hinf, szSection, NULL, &context );
            if ( !fFound ) {
                ErrorBox( NULL, g_Options.szWorkstationRemBootInfPath );
                goto Error;
            }

            while ( fFound )
            {
                WCHAR szMajor[ SMALL_BUFFER_SIZE ];
                WCHAR szMinor[ SMALL_BUFFER_SIZE ];
                WCHAR szBuild[ SMALL_BUFFER_SIZE ];
                WCHAR szServicePack[ SMALL_BUFFER_SIZE ];

                fFound = SetupGetStringField( &context, 1, szMajor, ARRAYSIZE(szMajor), NULL );
                Assert( fFound );
                if (!fFound)
                    break;

                fFound = SetupGetStringField( &context, 2, szMinor, ARRAYSIZE(szMinor), NULL );
                Assert( fFound );
                if (!fFound)
                    break;

                fFound = SetupGetStringField( &context, 3, szBuild, ARRAYSIZE(szBuild), NULL );
                Assert( fFound );
                if (!fFound)
                    break;

                fFound = SetupGetStringField( &context, 4, szServicePack, ARRAYSIZE(szServicePack), NULL );
                Assert( fFound );
                if (!fFound)
                    break;

                // Does it correspond to the server version?
                if ( StrCmpI( szServerMajor, szMajor ) >= 0 // must match or greater
                  && StrCmpI( szServerMinor, szMinor ) >= 0 // must match or greater
                  && StrCmpI( szServerBuild, szBuild ) >= 0 // must match or server build is greater
                  && ( szServicePack[0] == L'\0'            // ignore service pack if not specified
                     || StrCmpI( osver.szCSDVersion, szServicePack ) == 0 ) ) {
                    // found match
                    DebugMsg( "Server is compatiable with Workstation.\n");
                    hr = S_OK;
                    break;
                }

                fFound = SetupFindNextLine( &context, &context );
            }

            if ( FAILED(hr) ) {
                WCHAR szTitle[ MAX_PATH ];
                WCHAR szCaption[ 4096 ];
                WCHAR szBuf[ 4096 ];
                WCHAR szMajor[ SMALL_BUFFER_SIZE ];
                WCHAR szMinor[ SMALL_BUFFER_SIZE ];
                WCHAR szBuild[ SMALL_BUFFER_SIZE ];
                WCHAR szServicePack[ SMALL_BUFFER_SIZE ];
                INFCONTEXT context;

                DebugMsg( "Server doesn't look like it is compatiable with the Workstation Build.\n" );

                fFound = SetupFindFirstLine( hinf, szSection, NULL, &context );
                Assert( fFound );

                fFound = SetupGetStringField( &context, 1, szMajor, ARRAYSIZE(szMajor), NULL );
                Assert( fFound );

                fFound = SetupGetStringField( &context, 2, szMinor, ARRAYSIZE(szMinor), NULL );
                Assert( fFound );

                fFound = SetupGetStringField( &context, 3, szBuild, ARRAYSIZE(szBuild), NULL );
                Assert( fFound );

                fFound = SetupGetStringField( &context, 4, szServicePack, ARRAYSIZE(szServicePack), NULL );
                Assert( fFound );

                dw = LoadString( g_hinstance, IDS_INCOMPATIBLE_SERVER_VERSION_TITLE, szTitle, ARRAYSIZE( szTitle ));
                Assert( dw );
                dw = LoadString( g_hinstance, IDS_INCOMPATIBLE_SERVER_VERSION_CAPTION, szBuf, ARRAYSIZE( szBuf ));
                Assert( dw );

                wsprintf( szCaption, szBuf, szMajor, szMinor, szBuild, szServicePack );

                MessageBox( NULL, szCaption, szTitle, MB_OK );
                Assert( hr == E_FAIL );
            }

Error:
            if ( hinf != INVALID_HANDLE_VALUE ) {
                SetupCloseInfFile( hinf );
            }
        }

        g_Options.fServerCompatible = ( hr == S_OK );

    }

    if (g_Options.fServerCompatible ) {
        DebugMsg( "Server compatibility checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "Server compatibility failed.\n" );
    }

    HRETURN(hr);
}

//
// CheckFirstInstall( )
//
// This really checks for the existence of the REMINST directory
// under the system32 directory which was created during OCM setup.
//
HRESULT
CheckFirstInstall( )
{
    HRESULT hr = S_OK;

    TraceFunc( "CheckFirstInstall( )\n" );

    if ( !g_Options.fRemBootDirectory ) {
        DWORD dw;
        WCHAR      szFilePath[ MAX_PATH ];

        dw = ExpandEnvironmentStrings( TEXT("%windir%"), g_Options.szRemBootDirectory, ARRAYSIZE(g_Options.szRemBootDirectory) );
        Assert( dw );

        wcscpy( szFilePath, g_Options.szRemBootDirectory );
        wcscat( szFilePath, L"\\System32\\reminst.inf" );

        StrCat( g_Options.szRemBootDirectory, L"\\System32\\REMINST" );
        Assert( wcslen(g_Options.szRemBootDirectory) < ARRAYSIZE(g_Options.szRemBootDirectory) );

        if ( 0xFFFFffff != GetFileAttributes( g_Options.szRemBootDirectory ) ) 
        {
            DebugMsg( "Found the %s directory.\n", g_Options.szRemBootDirectory );

            HINF       hinf = INVALID_HANDLE_VALUE;
            INFCONTEXT context;

            // now check to see if the files are still in there.
            hinf = SetupOpenInfFile( szFilePath, NULL, INF_STYLE_WIN4, NULL );
            if ( hinf != INVALID_HANDLE_VALUE )
            {
                WCHAR szFile[ MAX_PATH ];
                BOOL  fFound;

                fFound = SetupFindFirstLine( hinf, L"OSChooser", NULL, &context );
                Assert( fFound );
                if ( !fFound ) {
                    DebugMsg( "Could not find 'OSChooser' section in REMINST.INF.\n" );
                    hr = S_FALSE;
                    goto bail;
                }

                wcscpy( szFilePath, g_Options.szRemBootDirectory );
                wcscat( szFilePath, L"\\" );
                dw = wcslen( szFilePath );

                while ( fFound )
                {
                    fFound = SetupGetStringField( &context, 2, szFile, ARRAYSIZE(szFile), NULL );
                    if ( !fFound )
                    {
                        fFound = SetupGetStringField( &context, 2, szFile, ARRAYSIZE(szFile), NULL );
                        if ( !fFound )
                            goto skipit;
                    }

                    wcscpy( &szFilePath[ dw ], szFile );
                    Assert( wcslen(szFilePath) < ARRAYSIZE(szFilePath) );

                    if ( 0xFFFFffff == GetFileAttributes( szFilePath ) ) {
                        DebugMsg( "%s is missing.\n", szFilePath );
                        goto bail;
                    }

skipit:
                    fFound = SetupFindNextLine( &context, &context );
                }

                DebugMsg( "All REMINST files found.\n" );
                g_Options.fRemBootDirectory = TRUE;
            }
            else
            {
                DebugMsg( "File not found. Error 0x%08x\n", GetLastError( ) );
            }

bail:
            if ( hinf != INVALID_HANDLE_VALUE )
            {
                SetupCloseInfFile( hinf );
            }
        }
    }

    if ( g_Options.fRemBootDirectory )
    {
        DebugMsg( "REMINST directory checked out OK.\n" );
    }
    else
    {
        DebugMsg( "REMINST directory is missing or missing files. This may require the server CD.\n ");
    }

    HRETURN(hr);
}

//
// CheckRegistry( )
//
HRESULT
CheckRegistry( )
{
    HRESULT    hr = S_FALSE;
    WCHAR      szSection[ SMALL_BUFFER_SIZE ];
    INFCONTEXT context;
    BOOL       fFound;
    DWORD      dw;
    BOOL       b;
    UINT       uLineNum;
    INT        index;

    TraceFunc( "CheckRegistry( )\n" );

    if ( !g_Options.fRegistryIntact ) {
        dw = LoadString( g_hinstance, IDS_INF_SECTION, szSection, ARRAYSIZE( szSection ) );
        Assert( dw );

        fFound = SetupFindFirstLine( g_Options.hinf, szSection, L"AddReg", &context );
        Assert( fFound );
        if ( !fFound )
            goto Error;

        // Assume SUCCESS and use it to exit the loop early
        g_Options.fRegistryIntact = TRUE;

        DebugMsg( "Checking Registry:\n" );

        index = 1;
        while ( g_Options.fRegistryIntact
             && SetupGetStringField( &context, index, szSection, ARRAYSIZE(szSection), NULL ) )
        {
            INFCONTEXT subcontext;
            fFound = SetupFindFirstLine( g_Options.hinf, szSection, NULL, &subcontext );
            Assert( fFound );

            while ( fFound && g_Options.fRegistryIntact )
            {
                WCHAR szRootKey[ 10 ];
                WCHAR szBaseKey[ MAX_PATH ];
                WCHAR szValueName[ MAX_PATH ];
                HKEY  hkeyRoot = NULL;
                HKEY  hkeyBase;
                LONG  lResult;

                SetupGetStringField( &subcontext, 1, szRootKey, ARRAYSIZE(szRootKey), NULL );
                SetupGetStringField( &subcontext, 2, szBaseKey, ARRAYSIZE(szBaseKey), NULL );
                SetupGetStringField( &subcontext, 3, szValueName, ARRAYSIZE(szValueName), NULL );

                DebugMsg( "%s, %s, %s - ", szRootKey, szBaseKey, szValueName );

                if ( StrCmpI( szRootKey, L"HKLM" ) == 0 ) {
                    hkeyRoot = HKEY_LOCAL_MACHINE;
                } else if ( StrCmpI( szRootKey, L"HKCU" ) == 0 ) {
                    hkeyRoot = HKEY_CURRENT_USER;
                } else if ( StrCmpI( szRootKey, L"HKCC" ) == 0 ) {
                    hkeyRoot = HKEY_CURRENT_CONFIG;
                } else if ( StrCmpI( szRootKey, L"HKCR" ) == 0 ) {
                    hkeyRoot = HKEY_CLASSES_ROOT;
                }

                //
                // If this Assert() fires, it is because the INF is malformed
                //
                Assert( hkeyRoot );

                if ( hkeyRoot == NULL )
                    continue;

                
                lResult = RegOpenKeyEx( hkeyRoot, szBaseKey, 0, KEY_QUERY_VALUE, &hkeyBase );
                if ( lResult == ERROR_SUCCESS )
                {
                    lResult = RegQueryValueEx( hkeyBase, szValueName, 0, NULL, NULL, NULL );
                    if ( lResult != ERROR_SUCCESS ) {
                        DebugMsg("NOT " );
                        g_Options.fRegistryIntact = FALSE;
                        hr = S_FALSE;
                    }

                    RegCloseKey( hkeyBase );
                } else {
                    DebugMsg("NOT " );
                    g_Options.fRegistryIntact = FALSE;
                    hr = S_FALSE;
                }

                DebugMsg("found.\n" );
                
                fFound = SetupFindNextLine( &subcontext, &subcontext );
            }

            index++;
        }
    }

    if ( g_Options.fRegistryIntact ) {
        DebugMsg( "Registry checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "Registry check failed.\n" );
    }

Error:
    HRETURN(hr);
}

//
// Paranoid( )
//
// Catch all for double checking that common things across services
// match up.
//
HRESULT
Paranoid( )
{
    HRESULT hr = S_OK;

    TraceFunc( "Paranoid( )\n" );

    // Make sure that the IntelliMirror directory are the same
    // for TFTPD and for the IMIRROR share (binlsvc uses this).
    if ( g_Options.fIMirrorDirectory
      && g_Options.fTFTPDDirectoryFound
      && StrCmpI( g_Options.szIntelliMirrorPath, g_Options.szTFTPDDirectory ) != 0 ) {
        //
        // If they are not the same, force the registry to modify the TFTPD key.
        //
        DebugMsg( "TFTPD doesn't agree with IMIRROR share. Forcing TFTPD registry update.\n" );
        g_Options.fTFTPDDirectoryFound = FALSE;
        hr = S_FALSE;
    }

    if ( hr != S_OK ) {
        DebugMsg( "Paranoid found a problem.\n" );
    } else {
        DebugMsg( "Paranoid is happy. 8~)\n" );
    }

    HRETURN( hr );
}

//
// CheckInstallation( )
//
HRESULT
CheckInstallation( )
{
    HRESULT hr = S_OK;
    BOOL    fSomethingbroke = FALSE;
    BOOL    fSomethingFailed = FALSE;
    DWORD   dw;
    DWORD   dwLen;
    UINT    uLineNum;
    SC_HANDLE  schSystem;
    WCHAR   szServerRemBootInfPath[ MAX_PATH ];
    CWaitCursor Wait;

    TraceFunc( "CheckInstallation( )\n");

    szServerRemBootInfPath[0] = L'\0';
    dw = ExpandEnvironmentStrings( TEXT("%SystemRoot%"), szServerRemBootInfPath, ARRAYSIZE( szServerRemBootInfPath ));
    Assert( dw );

    dwLen = lstrlen( szServerRemBootInfPath );
    StrCpy( &szServerRemBootInfPath[dwLen], L"\\System32\\" );
    dwLen = lstrlen( szServerRemBootInfPath );
    dw = LoadString( g_hinstance, IDS_REMBOOTINF, &szServerRemBootInfPath[dwLen], ARRAYSIZE( szServerRemBootInfPath ) - dwLen );
    Assert( dw );

    if ( 0xFFFFffff == GetFileAttributes( szServerRemBootInfPath ) ) {
        MessageBoxFromStrings( NULL,
                               IDS_MISSING_INF_TITLE,
                               IDS_MISSING_INF_MESSAGE,
                               MB_OK );
        fSomethingbroke = TRUE;
        goto e0;
    }

    if ( g_Options.hinf == INVALID_HANDLE_VALUE ) {
        g_Options.hinf = SetupOpenInfFile( szServerRemBootInfPath, NULL, INF_STYLE_WIN4, &uLineNum);
        Assert( g_Options.hinf != INVALID_HANDLE_VALUE );
        if ( g_Options.hinf == INVALID_HANDLE_VALUE ) {
            fSomethingbroke = TRUE;
            goto e0;
        }
    }

    hr = CheckServerVersion( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
        goto e0;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = CheckFirstInstall( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = CheckDirectoryTree( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    if ( !schSystem ) {
        hr = THR(E_FAIL);
        fSomethingbroke = TRUE;
        WCHAR szCaption[SMALL_BUFFER_SIZE]; 
        DWORD dw;
        dw = LoadString( g_hinstance, IDS_OPENING_SERVICE_MANAGER_TITLE, szCaption, ARRAYSIZE( szCaption ));
        Assert( dw );
        ErrorBox( NULL, szCaption );
        goto e0;
    }

    Assert( schSystem );

    if ( schSystem ) {
        hr = CheckBINL( schSystem );
        if ( FAILED(hr) ) {
            fSomethingbroke = TRUE;
        }
        if ( hr == S_FALSE ) {
            fSomethingFailed = TRUE;
        }

        hr = CheckTFTPD( schSystem );
        if ( FAILED(hr) ) {
            fSomethingbroke = TRUE;
        }
        if ( hr == S_FALSE ) {
            fSomethingFailed = TRUE;
        }

        hr = CheckSIS( schSystem );
        if ( FAILED(hr) ) {
            fSomethingbroke = TRUE;
        }
        if ( hr == S_FALSE ) {
            fSomethingFailed = TRUE;
        }

        hr = CheckSISGroveler( schSystem );
        if ( FAILED(hr) ) {
            fSomethingbroke = TRUE;
        }
        if ( hr == S_FALSE ) {
            fSomethingFailed = TRUE;
        }

        CloseServiceHandle( schSystem );
    }

    hr = CheckRegSrvDlls( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = CheckRegistry( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = CheckOSChooser( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = Paranoid( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

e0:
    if ( fSomethingbroke ) {
        DebugMsg( "Something is broken. Installation check failed to complete.\n" );
        hr = E_FAIL;
    } else if ( fSomethingFailed ) {
        DebugMsg( "Installation check found something wrong.\n" );
        hr = S_FALSE;
    } else {
        DebugMsg( "Installation check succeeded.\n" );
        hr = S_OK;
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\debug.cpp ===
/****************************************************************************

  Copyright (c) Microsoft Corporation 1997
  All rights reserved

  File: DEBUG.CPP

  Debugging utilities

 ***************************************************************************/

#include "pch.h"
#include <shlwapi.h>

DEFINE_MODULE("Debug");

#ifdef DEBUG

// Constants
#define DEBUG_OUTPUT_BUFFER_SIZE  512

// Globals
DWORD g_TraceMemoryIndex = 0;
DWORD g_dwCounter        = 0;
DWORD g_dwTraceFlags     = 0;
CRITICAL_SECTION g_DebugCS;
BOOL  g_fDebugInitialized = FALSE;

// Statics
static const TCHAR g_szNULL[]    = TEXT("");
static const TCHAR g_szTrue[]    = TEXT("True");
static const TCHAR g_szFalse[]   = TEXT("False");
static const TCHAR g_szFormat[]  = TEXT("%-50s  %-10.10s ");
static const TCHAR g_szUnknown[] = TEXT("<unknown>");

//
// Debugging strrchr( )
//
LPCTSTR
dbgstrrchr( LPCTSTR lpsz, char ch )
{
    LPCTSTR psz = lpsz;

    while ( *psz )
        ++psz;

    while ( psz >= lpsz && *psz != ch )
        --psz;

    return psz;

}

//
// Adds 'g_dwCounter' spaces to debug spew
//
void
dbgspace( void )
{
    for( DWORD dw = 1; dw < g_dwCounter; dw++ )
        DebugMsg( TEXT("| ") );
}

//
// Makes sure multiple threads don't trample debugging output.
//
void
dbgEnterCS( void )
{
    if ( !g_fDebugInitialized )
    {
        //
        // There is NO matching DeleteCriticalSection( ) since
        // this is only used for debugging purposes.
        //
        InitializeCriticalSection( &g_DebugCS );
        g_fDebugInitialized = TRUE;
    }

    EnterCriticalSection( &g_DebugCS );
}

void
dbgExitCS( void )
{
    LeaveCriticalSection( &g_DebugCS );
}

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPTSTR
dbgmakefilelinestring(
    LPTSTR  pszBuf,
    LPCTSTR pszFile,
    const int uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = IntToPtr(uLine);

    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        TEXT("%1(%2!u!):"),
        0,                          // error code
        0,                          // default language
        (LPTSTR) pszBuf,            // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (va_list*) &args );           // arguments

    return pszBuf;
}



//
// TraceMsg() - ascii
//
void
TraceMsg(
    DWORD dwCheckFlags,
    LPCSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifdef UNICODE
        TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
        mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, szFormat, valist );
        va_end( valist );
#else
        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );
#endif // UNICODE

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );
    }
}

//
// TraceMsg() - unicode
//
void
TraceMsg(
    DWORD dwCheckFlags,
    LPCWSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifndef UNICODE
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormat, lstrlenW( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

        dbgEnterCS( );

        OutputDebugStringW( szBuf );

        dbgExitCS( );
    }
}

//
// TraceMessage()
//
void
TraceMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgspace( );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );

        dbgExitCS( );
    }

}

//
// TraceMessageDo()
//
void
TraceMessageDo(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR   szVar[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPCTSTR psz = pszFunc;

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgspace( );

        while ( *psz && *psz != TEXT('='))
            psz++;

        lstrcpyn( szVar, pszFunc, (size_t)(1 + psz - pszFunc) );

        wsprintf( szBuf, TEXT("V %s= "), szVar );
        OutputDebugString( szBuf );

        va_start( valist, pszFunc );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );
        OutputDebugString( TEXT("\n") );

        dbgExitCS( );
    }

}

//
// DebugMessage()
//
void
DebugMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

    if ( !pszModule )
    {
        pszModule = g_szUnknown;
    }

    if ( !pszFile )
    {
        wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
    }
    else
    {
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgmakefilelinestring( szFileLine, pszFile, uLine );
        wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
    }

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgspace( );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );

    OutputDebugString( szBuf );

    dbgExitCS( );
}

//
// DebugMessageDo()
//
void
DebugMessageDo(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
    TCHAR   szVar[ DEBUG_OUTPUT_BUFFER_SIZE ];
    LPCTSTR psz = pszFunc;

    if ( !pszModule )
    {
        pszModule = g_szUnknown;
    }

    if ( !pszFile )
    {
        wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
    }
    else
    {
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgmakefilelinestring( szFileLine, pszFile, uLine );
        wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
    }

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgspace( );

    while ( *psz && *psz != TEXT('='))
        psz++;

    lstrcpyn( szVar, pszFunc, (size_t)(1 + psz - pszFunc) );

    wsprintf( szBuf, TEXT("V %s= "), szVar );
    OutputDebugString( szBuf );

    va_start( valist, pszFunc );
    wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );

    OutputDebugString( szBuf );
    OutputDebugString( TEXT("\n") );

    dbgExitCS( );
}

//
// DebugMsg()
//
void
DebugMsg(
    LPCSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifdef UNICODE
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgExitCS( );
}

//
// DebugMsg()
//
void
DebugMsg(
    LPCWSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifndef UNICODE
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormat, lstrlenW( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE


    dbgEnterCS( );

    OutputDebugStringW( szBuf );

    dbgExitCS( );
}


//
// Displays a dialog box with the failed assertion. User has the option of
// breaking.
//
BOOL
AssertMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    BOOL    fTrue )
{
    if ( !fTrue )
    {
        TCHAR szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszFile == NULL )
        {
            pszFile = g_szNULL;
        }

        if ( pszModule == NULL )
        {
            pszModule = g_szNULL;
        }

        if ( pszfn == NULL )
        {
            pszfn = g_szNULL;
        }

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s ASSERT: %s\n"),
            szFileLine, pszModule, pszfn );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn );

        if ( IDNO == MessageBox( NULL, szBuf, TEXT("Assertion Failed!"),
                MB_YESNO|MB_ICONWARNING ) )
            fTrue = !FALSE;   // don't break

    }

    return !fTrue;

}

//
// Traces HRESULT errors. A dialog will appear is there is an error
// in the hr.
//
HRESULT
TraceHR(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    HRESULT hr )
{
    static const LPTSTR pcszFalse = TEXT("S_FALSE\n");

    if ( !( g_dwTraceFlags & TF_HRESULTS ) )
        return hr; // bail

    if ( hr )
    {
        TCHAR  szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR pszMsgBuf;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = pcszFalse;
            break;

        default:
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR)&pszMsgBuf,
                0,
                NULL
            );
        }

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszMsgBuf == NULL )
        {
            pszMsgBuf = TEXT("<unknown error code returned>\n");
        }
        Assert( pszFile != NULL );
        Assert( pszModule != NULL );
        Assert( pszfn != NULL );

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s HRESULT: hr = 0x%08x - %s"),
            szFileLine, pszModule, hr, pszMsgBuf );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x - %s\t\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn, hr, pszMsgBuf );

        if ( IDYES == MessageBox( NULL, szBuf, TEXT("Trace HRESULT"),
                MB_YESNO|MB_ICONWARNING ) )
            DEBUG_BREAK;

        if ( pszMsgBuf != pcszFalse ) {
            LocalFree( pszMsgBuf );
        }
    }

    return hr;

}


//
// Memory allocation and tracking
//

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCTSTR pszFile;
    UINT    uLine;
    LPCTSTR pszModule;
    LPCTSTR pszComment;
    _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                    GMEM_FIXED,
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );
        TraceMessage( pmb->pszFile,
                      pmb->uLine,
                      pmb->pszModule,
                      TF_MEMORYALLOCS,
                      L"Alloced %s - %u bytes at 0x%08x (pmb=0x%08x)\n",
                      pszComment,
                      dwBytes,
                      pmb->hglobal,
                      pmb );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmbLast = NULL;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );
            }

            TraceMessage( pmbHead->pszFile,
                          pmbHead->uLine,
                          pmbHead->pszModule,
                          TF_MEMORYALLOCS,
                          L"Freeing %s - %u bytes from 0x%08x (pmb=0x%08x)\n",
                          pmbHead->pszComment,
                          pmbHead->dwBytes,
                          pmbHead->hglobal,
                          pmbHead );
            GlobalFree( pmbHead );
        }
        else
        {
            DebugMsg( "\n**** Attempted to free memory at 0x%08x (ThreadID = 0x%08x) ****\n\n",
                hglobal, GetCurrentThreadId( ) );
        }
    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    HGLOBAL       hglobal = GlobalAlloc( uFlags, dwBytes );

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );

    dbgEnterCS( );

    while ( pmb )
    {
        LPVOID args[ 5 ];
        TCHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            DebugMsg("\n******** Memory leak detected ******** ThreadID = 0x%08x ******** \n\n", GetCurrentThreadId( ) );
               //OutputDebugString("12345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            OutputDebugString(TEXT("Filename(Line Number):                              Module     Addr/HGLOBAL  Size   String\n"));
            fFoundLeak = TRUE;
        }

        if ( StrCmp( pmb->pszComment, TEXT("new( )" ) ) == 0 )
        {
            wsprintf(
                szFileLine,
                TEXT("Caller unknown - (Module %s, line %d)"),
                pmb->pszModule,
                pmb->uLine );
        }
        else
        {
            dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );
        }

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = UlongToPtr(pmb->dwBytes);
        args[4] = (LPVOID) pmb->pszModule;

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }
        else
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }

        OutputDebugString( szOutput );

        pmb = pmb->pNext;
    }

    if ( fFoundLeak == TRUE )
    {
        OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
    }

    dbgExitCS( );

    Assert( !fFoundLeak );

}

//
// Global Management Functions -
//
// These are in debug and retail but internally they change
// depending on the build.
//
#undef new
void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule )
{
    return DebugAlloc( pszFile, iLine, pszModule, GPTR, nSize, TEXT("new( )") );
}

void * __cdecl operator new(size_t t_size )
{
    AssertMsg( 0, "Macro failure" );
    return NULL;
}

void __cdecl operator delete(void *pv)
{
    TraceFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#else // ! DEBUG -- It's retail

//
// Global Management Functions -
//
// These are in debug and retail but are internally they change
// depending on the build.
//

void * __cdecl operator new(size_t t_size )
{
    return LocalAlloc( GPTR, t_size );
}

void __cdecl operator delete(void *pv)
{
    LocalFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\dhcp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dhcp.h

Abstract:

    Code to allow RIS to automatically authorize for DHCP.

Author:

    Hugh Leather (hughleat) 25-July-2000

Revision History:

--*/

#if !defined SENTINEL_DHCP
# define SENTINEL_DHCP

HRESULT
AuthorizeDhcp( HWND hDlg );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\dialogs.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#ifndef _DIALOGS_H_
#define _DIALOGS_H_

INT_PTR CALLBACK
WelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
IntelliMirrorRootDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
SCPDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
WarningDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
OptionsDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
ImageSourceDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
OSDirectoryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
DefaultSIFDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
ScreensDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
LanguageDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
SummaryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
ServerOKDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
AddWelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
CheckWelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
ExamineServerDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
SetupDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

#define SMALL_BUFFER_SIZE   256

enum { STATE_WONTSTART, STATE_NOTSTARTED, STATE_STARTED, STATE_DONE, STATE_ERROR };

typedef HRESULT (*PFNOPERATION)( HWND hDlg );

typedef struct {
    HANDLE hChecked;
    HANDLE hError;
    HANDLE hArrow;
    HANDLE hFontNormal;
    HANDLE hFontBold;
    int    dwWidth;
    int    dwHeight;
} SETUPDLGDATA, *LPSETUPDLGDATA;

typedef struct {
    UINT   uState;
    UINT   rsrcId;
    PFNOPERATION pfn;
    TCHAR  szText[ SMALL_BUFFER_SIZE ];
} LBITEMDATA, *LPLBITEMDATA;

extern LBITEMDATA items[];

#endif // _DIALOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\dhcp.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dhcp.cpp

Abstract:

    Code to allow RIS to automatically authorize for DHCP.

Author:

    Hugh Leather (hughleat) 25-July-2000

Revision History:

--*/


#include "pch.h"


#include "dhcpapi.h"
#include "dhcp.h"
#include "setup.h"

DEFINE_MODULE("DHCP");

PSTR
pSetupUnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    )

/*++

Routine Description:

    Convert a string from unicode to ansi.

Arguments:

    UnicodeString - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if out of memory or invalid codepage.
    Caller can free buffer with pSetupFree().

--*/

{
    UINT WideCharCount;
    PSTR String;
    UINT StringBufferSize;
    UINT BytesInString;
    PSTR p;

    WideCharCount = lstrlenW(UnicodeString) + 1;

    //
    // Allocate maximally sized buffer.
    // If every unicode character is a double-byte
    // character, then the buffer needs to be the same size
    // as the unicode string. Otherwise it might be smaller,
    // as some unicode characters will translate to
    // single-byte characters.
    //
    StringBufferSize = WideCharCount * 2;
    String = new char[StringBufferSize];
    if(String == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    BytesInString = WideCharToMultiByte(
                        Codepage,
                        0,                      // default composite char behavior
                        UnicodeString,
                        WideCharCount,
                        String,
                        StringBufferSize,
                        NULL,
                        NULL
                        );

    if(BytesInString == 0) {
        delete(String);
        return(NULL);
    }

    return(String);
}



//////////////////////////////////////////////////////////////////////////////////////////////
// Dhcp Authorization
// ------------------
// Authorization works like this:
//     S <- List of authorized servers (from call to DhcpEnumServers)
//   I <- IP addresses for this machine (from gethostaddr( 0 ))
//   c <- fully qualified physical DNS name of local machine (from GetComputerNameEx)
//   for each i such that i is a member of I and i is not a member of S do
//       Authorize( i, c ) (by a call to DhcpAddServer)
//
// Aurguments
//   hDlg
//      Parent window (only used for displaying message boxes modally).  Can be NULL.
//
// Returns
//   Whatever error code is first generated (or ERROR_SUCCESS if none).  A message box will
//   be displayed if there is an error.
//
// Used By
//   This code is only used by dialogs.cpp
////////////////////////////////////////////////////////////////////////////////////////////// 
HRESULT AuthorizeDhcp( HWND hDlg ) {
    DWORD err;
    PWCHAR computer_name = 0;
    // Have to use a dll for dhcp authorization function.
    // This code loads them.
    HMODULE module;
    DWORD ( __stdcall *EnumServersFn )( DWORD, void* , DHCP_SERVER_INFO_ARRAY** ,void* ,void* ); 
    DWORD ( __stdcall *AddServerFn )( DWORD, void* , DHCP_SERVER_INFO* ,void* ,void* );
    module = LoadLibraryA( "dhcpsapi.dll" );
    if( module ) {
        EnumServersFn = ( DWORD ( __stdcall * )( DWORD, void* , DHCP_SERVER_INFO_ARRAY** ,void* ,void* )) GetProcAddress( module, "DhcpEnumServers" );
        if( !EnumServersFn ) { 
            err = GetLastError(); 
            DebugMsg( "GetProcAddress(DhcpEnumServers) failed, ec = %d\n", err );
            goto fail;
        }
        AddServerFn = ( DWORD ( __stdcall * )( DWORD, void* , DHCP_SERVER_INFO* ,void* ,void* )) GetProcAddress( module, "DhcpAddServer" );
        if( !AddServerFn ) { 
            err = GetLastError(); 
            DebugMsg( "GetProcAddress(DhcpAddServer) failed, ec = %d\n", err );
            goto fail;
        }
    }
    else {  
            err = GetLastError(); 
            DebugMsg( "LoadLibrary failed, ec = %d\n", err );
            goto fail;
        }

    // We need the list of ip addresses associated with this machine.  This we do through sockets.
    HOSTENT* host;
#if 0
    DWORD ip;
    ip = 0;
    host = gethostbyaddr(( const char* )&ip, sizeof( DWORD ), AF_INET );
    if( host == NULL ) { 
        err = WSAGetLastError(); 
        DebugMsg( "gethostbyaddr failed, ec = %d\n", err );
        goto fail;
    }
    if( host->h_addrtype != AF_INET || host->h_length != sizeof( DWORD )) { 
        err = E_FAIL;
        DebugMsg( "gethostbyaddr returned invalid data\n" );
        goto fail;
    }
#endif

    // We get the entire list of dhcp servers.
    DHCP_SERVER_INFO_ARRAY* _servers;
    if(( err = EnumServersFn( 0, NULL, &_servers, NULL, NULL )) != ERROR_SUCCESS ) {
        //
        // if this API fails, it will fail with a private DCHP error code that has
        // no win32 mapping.  So set the error code to something generic and
        // reasonable.
        //
        DebugMsg( "DhcpEnumServers failed, ec = %d\n", err );
        err = ERROR_DS_GENERIC_ERROR;
        goto fail;
    }

    // We will need the name of the machine if we have to authorize it.  Get the physical name as I'm not sure I trust what happens in the 
    // clustered case.
    DWORD computer_name_len;
    computer_name_len = MAX_COMPUTERNAME_LENGTH * 2; // Allow for extra DNS characters.
    computer_name = new WCHAR[ MAX_COMPUTERNAME_LENGTH * 2 ];
    if (!computer_name) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        DebugMsg( "new failed, ec = %d\n", err );
        goto fail;
    }
    if( !GetComputerNameEx( ComputerNamePhysicalDnsFullyQualified, computer_name, &computer_name_len )) {
        err = GetLastError();
        if( err == ERROR_MORE_DATA ) {
            delete [] computer_name;
            computer_name = new WCHAR[ computer_name_len ];
            if (!computer_name) {
                err = ERROR_NOT_ENOUGH_MEMORY;
                DebugMsg( "new failed, ec = %d\n", err );
                goto fail;
            }
            if( !GetComputerNameEx( ComputerNamePhysicalDnsFullyQualified, computer_name, &computer_name_len )) {
                err = GetLastError();
                DebugMsg( "GetComputerNameEx failed, ec = %d\n", err );
                goto fail;
            }
        }
        else goto fail;
    }

    DebugMsg( "ComputerName = %s\n", computer_name );

#if 1
    char ComputerNameA[400];
    DWORD ip;

    WideCharToMultiByte(CP_ACP,
                        0,                      // default composite char behavior
                        computer_name,
                        -1,
                        ComputerNameA,
                        400,
                        NULL,
                        NULL
                        );


    host = gethostbyname( ComputerNameA );
    if( host == NULL ) { 
        err = WSAGetLastError(); 
        DebugMsg( "gethostbyaddr failed, ec = %d\n", err );
        goto fail;
    }
    if( host->h_addrtype != AF_INET || host->h_length != sizeof( DWORD )) { 
        err = E_FAIL;
        DebugMsg( "gethostbyaddr returned invalid data\n" );
        goto fail;
    }


#endif

    // Cool now that we have all of that jazz, we can check that each of our ip addresses is authorized.
    for( PCHAR* i = host->h_addr_list; *i != 0; ++i ) {
        ip = ntohl( *( DWORD* )*i );
        DebugMsg( "searching server list for %d.%d.%d.%d\n",  
                  ip & 0xFF, 
                  (ip >> 8) & 0xFF,
                  (ip >> 16) & 0xFF,
                  (ip >> 24) & 0xFF );
        BOOL this_address_authorized = FALSE;
        for( unsigned j = 0; j < _servers->NumElements; ++j ) {
            DebugMsg( "server list entry: %d.%d.%d.%d\n",  
                  _servers->Servers[ j ].ServerAddress & 0xFF, 
                  (_servers->Servers[ j ].ServerAddress >> 8) & 0xFF,
                  (_servers->Servers[ j ].ServerAddress >> 16) & 0xFF,
                  (_servers->Servers[ j ].ServerAddress >> 24) & 0xFF );
            if( _servers->Servers[ j ].ServerAddress == ip ) {
                DebugMsg("found a match in list\n");
                this_address_authorized = TRUE;
                err = ERROR_SUCCESS;
                break;
            }
        }
        if( !this_address_authorized ) {
            // Authorize it!
            DHCP_SERVER_INFO server_info = { 0 };
            server_info.ServerAddress = ip;
            server_info.ServerName = computer_name;
            DebugMsg("authorizing %s (%d.%d.%d.%d)\n",
                     server_info.ServerName,
                     server_info.ServerAddress & 0xFF, 
                     (server_info.ServerAddress >> 8) & 0xFF,
                     (server_info.ServerAddress >> 16) & 0xFF,
                     (server_info.ServerAddress >> 24) & 0xFF);
            err = AddServerFn( 0, NULL, &server_info, NULL, NULL );
            if( err != ERROR_SUCCESS ) {
                //
                // if this API fails, it will fail with a private DCHP error code that has
                // no win32 mapping.  So set the error code to something generic and
                // reasonable.
                //
                DebugMsg("DhcpAddServer failed, ec = %d\n",
                         err
                        );
                err = ERROR_DS_GENERIC_ERROR;
                goto fail;
            }
        } else {
            DebugMsg("skipping authorization of interface, it's already authorized\n");
        }
    }
    
    err = ERROR_SUCCESS;
    goto exit;

fail :

    MessageBoxFromStrings( 
                    hDlg, 
                    IDS_AUTHORIZING_DHCP, 
                    IDS_AUTHORIZE_DHCP_FAILURE,
                    MB_OK | MB_ICONERROR );

exit :
    if (computer_name) {
        delete [] computer_name;
    }
    return HRESULT_FROM_WIN32( err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\dialogs.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#include "pch.h"

#include "dialogs.h"
#include "setup.h"
#include "check.h"
#include "dhcp.h"

DEFINE_MODULE("Dialogs");

#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define LG_BITMAP_WIDTH 32
#define LG_BITMAP_HEIGHT 32

static WNDPROC g_pOldEditWndProc;

//
// global window message for cancelling autoplay.
//
UINT g_uQueryCancelAutoPlay = 0;


//
// Check to see if the directory exists. If not, ask the user if we
// should create it.
//
HRESULT
CheckDirectory( HWND hDlg, LPWSTR pszPath )
{
    TraceFunc( "CheckDirectory( ... )\n" );

    HRESULT hr = E_FAIL;
    DWORD dwAttrib = GetFileAttributes( pszPath );

    if ( dwAttrib != 0xFFFFffff 
      && g_Options.fAutomated == FALSE )
    {
        INT iResult =  MessageBoxFromStrings( hDlg,
                                              IDS_DIRECTORYEXISTS_CAPTION,
                                              IDS_DIRECTORYEXISTS_TEXT,
                                              MB_YESNO );
        if ( iResult == IDNO )
            goto Cleanup;
    }


    hr = S_OK;

Cleanup:
    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, (hr == S_OK ? 0 : -1 ) );

    HRETURN(hr);
}

//
// Base dialog proc - all unhandled calls are passed here. If they are not
// handled here, then the default dialog proc will handle them.
//
INT_PTR CALLBACK
BaseDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        SetDialogFont( hDlg, IDC_S_TITLE1, DlgFontTitle );
        //SetDialogFont( hDlg, IDC_S_TITLE2, DlgFontTitle );
        //SetDialogFont( hDlg, IDC_S_TITLE3, DlgFontTitle );
        SetDialogFont( hDlg, IDC_S_BOLD1,  DlgFontBold  );
        SetDialogFont( hDlg, IDC_S_BOLD2,  DlgFontBold  );
        SetDialogFont( hDlg, IDC_S_BOLD3,  DlgFontBold  );
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wParam != hDlg)
        {
            InvalidateRect(hDlg, NULL, NULL);
            UpdateWindow(hDlg);
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

//
// WelcomeDlgProc( )
//
// "Welcome's" (the first page's) dialog proc.
//
INT_PTR CALLBACK
WelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        CenterDialog( GetParent( hDlg ) );
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fAddOption
              || g_Options.fCheckServer )
            {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }

            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
            ClearMessageQueue( );
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// VerifyRootDirectoryName( )
//
BOOL
VerifyRootDirectoryName( )
{
    TraceFunc( "VerifyRootDirectoryName()\n" );
    BOOL fReturn = FALSE;

    LPWSTR psz = g_Options.szIntelliMirrorPath;

    while ( *psz >= 32 && *psz < 127 )
        psz++;

    if ( *psz == L'\0' )
    {
        fReturn = TRUE;
    }

    RETURN(fReturn);
}

//
// IntelliMirrorRootDlgProc( )
//
INT_PTR CALLBACK
IntelliMirrorRootDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
    DWORD       dwPathLength;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        {
            HWND hwndEdit = GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT );
            Edit_LimitText( hwndEdit, ARRAYSIZE(g_Options.szIntelliMirrorPath) - 1 );
            Edit_SetText( hwndEdit, g_Options.szIntelliMirrorPath );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
        }

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            Edit_GetText( GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT ),
                          g_Options.szIntelliMirrorPath,
                          ARRAYSIZE( g_Options.szIntelliMirrorPath ) );
            if ( !CheckIntelliMirrorDrive( hDlg ) )
            {
                g_Options.fIMirrorDirectory = TRUE;
            }
            //
            // Remove any trailing \ from the path, since NetShareAdd
            // can't handle those.
            //
            dwPathLength = lstrlen( g_Options.szIntelliMirrorPath );
            while ( ( dwPathLength > 0 ) &&
                    ( g_Options.szIntelliMirrorPath[dwPathLength-1] == L'\\' ) ) {
                g_Options.szIntelliMirrorPath[dwPathLength-1] = L'\0';
                --dwPathLength;
            }
            if ( !VerifyRootDirectoryName( ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_ROOT_DIRECTORY_RESTRICTION_TITLE, IDS_OSCHOOSER_ROOT_DIRECTORY_RESTRICTION_TEXT, MB_OK );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || g_Options.fIMirrorShareFound
              || g_Options.fTFTPDDirectoryFound ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
            }
            else
            {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT ) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    case WM_COMMAND:
        switch( LOWORD( wParam))
        {
        case IDC_E_INTELLIMIRRORROOT:
        {
            if ( HIWORD(wParam) == EN_CHANGE )
            {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT) );
                PropSheet_SetWizButtons( GetParent( hDlg ), dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
            }
        }
        break;

        case IDC_B_BROWSE:
            {
                WCHAR szTitle[ SMALL_BUFFER_SIZE ];
                WCHAR szPath[ MAX_PATH ];

                BROWSEINFO bs;
                DWORD      dw;
                ZeroMemory( &bs, sizeof(bs) );
                bs.hwndOwner = hDlg;
                dw = LoadString( g_hinstance, IDS_BROWSECAPTION_RBDIR, szTitle, ARRAYSIZE( szTitle ));
                Assert( dw );
                bs.lpszTitle = (LPWSTR) &szTitle;
                bs.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;
                LPITEMIDLIST pidl = SHBrowseForFolder( &bs );

                if ( pidl && SHGetPathFromIDList( pidl, szPath ) ) {
                    if ( wcslen( szPath ) > ARRAYSIZE(g_Options.szSourcePath) - 2 ) {
                        MessageBoxFromStrings( hDlg, IDS_PATH_TOO_LONG_TITLE, IDS_PATH_TOO_LONG_TEXT, MB_OK );
                        szPath[ ARRAYSIZE(g_Options.szSourcePath) - 1 ] = L'\0';
                    }
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT ), szPath );
                }
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// SCPCheckWindows( )
//
void
SCPCheckWindows( HWND hDlg )
{
    // LONG lAllowNewClients = Button_GetCheck( GetDlgItem( hDlg, IDC_C_ACCEPTSNEWCLIENTS ) );
    // LONG lLimitClients    = Button_GetCheck( GetDlgItem( hDlg, IDC_C_LIMITCLIENTS ) );
    LONG lAnswerRequests  = Button_GetCheck( GetDlgItem( hDlg, IDC_C_RESPOND ) );

    // EnableWindow( GetDlgItem( hDlg, IDC_C_LIMITCLIENTS ), lAllowNewClients );
    // EnableWindow( GetDlgItem( hDlg, IDC_E_LIMIT ), lAllowNewClients && lLimitClients );
    // EnableWindow( GetDlgItem( hDlg, IDC_SPIN_LIMIT ), lAllowNewClients && lLimitClients );
    EnableWindow( GetDlgItem( hDlg, IDC_C_KNOWNCLIENTS ), lAnswerRequests );
}

//
// SCPDlgProc( )
//
// SCP default setup settings
//
INT_PTR CALLBACK
SCPDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
    static UINT uDlgState = 0;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        // Edit_LimitText( GetDlgItem( hDlg, IDC_E_LIMIT ), 3 );
        SCPCheckWindows( hDlg );
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            {
                LONG lResult;
                //lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_C_ACCEPTSNEWCLIENTS ) );
                //scpdata[0].pszValue = ( lResult == BST_CHECKED ? L"TRUE" : L"FALSE" );

                //lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_C_LIMITCLIENTS ) );
                //scpdata[1].pszValue = ( lResult == BST_CHECKED ? L"TRUE" : L"FALSE" );

                //if ( lResult == BST_CHECKED ) {
                //    GetDlgItemText( hDlg, IDC_E_LIMIT, scpdata[3].pszValue, 4 );
                //}

                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_C_RESPOND ) );
                scpdata[4].pszValue = ( lResult == BST_CHECKED ? L"TRUE" : L"FALSE" );

                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_C_KNOWNCLIENTS ) );
                scpdata[5].pszValue = ( lResult == BST_CHECKED ? L"TRUE" : L"FALSE" );
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError || g_Options.fAbort || g_Options.fBINLSCPFound ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
            ClearMessageQueue( );
            break;
        }
        break;

    case WM_COMMAND:
        {
            if ( HIWORD( wParam ) == BN_CLICKED ) {
                SCPCheckWindows( hDlg );
            }
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// WarningDlgProc( )
//
INT_PTR CALLBACK
WarningDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError || g_Options.fAbort || g_Options.fNewOS) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
            }
            else
            {
                HRESULT hr = CheckInstallation( );
                if ( hr == S_OK || g_Options.fFirstTime ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // do not show this page
                    break;
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_FINISH );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// OptionsDlgProc( )
//
INT_PTR CALLBACK
OptionsDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            Button_SetCheck( GetDlgItem( hDlg, IDC_B_ADD ), BST_CHECKED );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_NOTIFY:
            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
            lpnmhdr = (NMHDR FAR *) lParam;
            switch ( lpnmhdr->code )
            {
            case PSN_WIZNEXT:
                if ( BST_CHECKED == Button_GetCheck( GetDlgItem( hDlg, IDC_B_ADD ) ) ) {
                    g_Options.fNewOS = TRUE;
                } else {
                    g_Options.fNewOS = FALSE;
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
                break;

            case PSN_QUERYCANCEL:
                return VerifyCancel( hDlg );

            case PSN_SETACTIVE:
                if ( g_Options.fFirstTime 
                  || g_Options.fAddOption ) {
                    g_Options.fNewOS = TRUE;
                }
                if ( g_Options.fFirstTime
                  || g_Options.fAddOption
                  || g_Options.fError
                  || g_Options.fAbort
                  || g_Options.fCheckServer ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                    break;
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                ClearMessageQueue( );
                break;
            }
            break;

        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// ImageSourceDlgProc( )
//
INT_PTR CALLBACK
ImageSourceDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        {
            HWND hwndEdit = GetDlgItem( hDlg, IDC_E_IMAGESOURCE );
            SHAutoComplete(hwndEdit, SHACF_AUTOSUGGEST_FORCE_ON | SHACF_FILESYSTEM);
            Edit_LimitText( hwndEdit, ARRAYSIZE(g_Options.szSourcePath) - 1 );
            Edit_SetText( hwndEdit, g_Options.szSourcePath );
#ifdef SHOW_ARCHITECTURERADIOBUTTON
            if( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ) {
                Button_SetCheck( GetDlgItem( hDlg, IDC_C_X86 ), BST_CHECKED );
            } else if( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ) {
                Button_SetCheck( GetDlgItem( hDlg, IDC_C_IA64 ), BST_CHECKED );
            }
#endif
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
        }

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            {
                CWaitCursor Wait;
                HRESULT hr;
                DWORD pathlen,archlen;
                WCHAR archscratch[10];
                BOOL FirstTime = TRUE;

                PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
                Edit_GetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ),
                              g_Options.szSourcePath,
                              ARRAYSIZE( g_Options.szSourcePath ) );
#ifdef SHOW_ARCHITECTURERADIOBUTTON
                if( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_X86 ) ) ) == BST_CHECKED ) {
                    g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                    wcscpy( g_Options.ProcessorArchitectureString, L"i386" );
                    wcscpy( archscracth, L"\\i386");
                    archlen = 5;
                }

                if( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_IA64 ) ) ) == BST_CHECKED ) {
                    g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                    wcscpy(g_Options.ProcessorArchitectureString, L"ia64" );
                    wcscpy( archscracth, L"\\ia64");
                    archlen = 5;
                }

                pathlen = wcslen(g_Options.szSourcePath);


                // Remove any trailing slashes
                if ( g_Options.szSourcePath[ pathlen - 1 ] == L'\\' ) {
                    g_Options.szSourcePath[ pathlen - 1 ] = L'\0';
                    pathlen -= 1;
                }

                //
                // remove any processor specific subdir at the end of the path
                // if that's there as well, being careful not to underflow
                // the array
                //
                if ( (pathlen > archlen) &&
                     (0 == _wcsicmp(
                                &g_Options.szSourcePath[pathlen-archlen],
                                archscracth))) {
                    g_Options.szSourcePath[ pathlen - archlen ] = L'\0';
                }

                hr = FindImageSource( hDlg );
                if ( hr != S_OK ) {
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), g_Options.szSourcePath );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                    break;
                }
#else
                if (g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
                    wcscpy(g_Options.ProcessorArchitectureString, L"i386" );
                    wcscpy( archscratch, L"\\i386");
                    archlen = 5;
                } else {
                    wcscpy(g_Options.ProcessorArchitectureString, L"ia64" );
                    wcscpy( archscratch, L"\\ia64");
                    archlen = 5;
                }
                pathlen = wcslen(g_Options.szSourcePath);

                // Remove any trailing slashes
                if ( g_Options.szSourcePath[ pathlen - 1 ] == L'\\' ) {
                    g_Options.szSourcePath[ pathlen - 1 ] = L'\0';
                    pathlen -= 1;
                }

tryfindimagesource:
                //
                // remove any processor specific subdir at the end of the path
                // if that's there as well, being careful not to underflow
                // the array
                //
                if ( (pathlen > archlen) &&
                     (0 == _wcsicmp(
                                &g_Options.szSourcePath[pathlen-archlen],
                                archscratch))) {
                    g_Options.szSourcePath[ pathlen - archlen ] = L'\0';
                }


                //
                // try the default architecture for the image.
                // If it doesn't work then try again with another architecture.
                //
                hr = FindImageSource( hDlg );
                if ( hr != S_OK ) {
                    if (FirstTime) {
                        FirstTime = FALSE;
                        if (g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {
                            g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                            wcscpy( g_Options.ProcessorArchitectureString, L"i386" );
                            wcscpy( archscratch, L"\\i386");
                            archlen = 5;
                        } else {
                            g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                            wcscpy(g_Options.ProcessorArchitectureString, L"ia64" );
                            wcscpy( archscratch, L"\\ia64");
                            archlen = 5;
                        }
                        goto tryfindimagesource;
                    } else {
                        //
                        // We didn't find it.  print a failure message.
                        //
                        MessageBoxFromStrings( hDlg, IDS_FILE_NOT_FOUND_TITLE, IDS_FILE_NOT_FOUND_TEXT, MB_OK );
                        Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), g_Options.szSourcePath );
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                        break;
                    }
                }
#endif

                hr = CheckImageSource( hDlg );

                if ( hr != S_OK )
                {
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), g_Options.szSourcePath );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                    break;
                }

                Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), g_Options.szSourcePath );
                hr = CheckInstallation( );
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || !g_Options.fNewOS ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }
            else
            {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_IMAGESOURCE) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    case WM_COMMAND:
            DWORD dwLen;
        switch( LOWORD( wParam))
        {
        case IDC_E_IMAGESOURCE:
            if ( HIWORD(wParam) != EN_CHANGE )
                return BaseDlgProc( hDlg, uMsg, wParam, lParam );
            // fall thru...
#ifdef SHOW_ARCHITECTURERADIOBUTTON
        case IDC_C_X86:
        case IDC_C_IA64:
            {
                if( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_X86 ) ) ) == BST_CHECKED ) {
                    g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                    wcscpy( g_Options.ProcessorArchitectureString, L"i386" );
                }

                if( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_IA64 ) ) ) == BST_CHECKED ) {
                    g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                    wcscpy( g_Options.ProcessorArchitectureString, L"ia64" );
                }
                dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                    ( dwLen) ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
            }
            break;
#else
            dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ) );
            PropSheet_SetWizButtons( 
                            GetParent( hDlg ), 
                            ( dwLen) ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
            break;
#endif
        case IDC_B_BROWSE:
            {
                WCHAR szPath[ MAX_PATH ];
                WCHAR szTitle[ SMALL_BUFFER_SIZE ];
                BROWSEINFO bs;
                DWORD dw;
                ZeroMemory( &bs, sizeof(bs) );
                bs.hwndOwner = hDlg;
                dw = LoadString( g_hinstance, IDS_BROWSECAPTION_SOURCEDIR, szTitle, ARRAYSIZE( szTitle ));
                Assert( dw );
                bs.lpszTitle = (LPWSTR) &szTitle;
                bs.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;
                LPITEMIDLIST pidl = SHBrowseForFolder( &bs );

                if ( pidl && SHGetPathFromIDList( pidl, szPath) ) {
                    if ( wcslen( szPath ) > ARRAYSIZE(g_Options.szSourcePath) - 2 ) {
                        MessageBoxFromStrings( hDlg, IDS_PATH_TOO_LONG_TITLE, IDS_PATH_TOO_LONG_TEXT, MB_OK );
                        //
                        // SHGetPathFromIDList() returns the path with a 
                        // trailing backslash, which we want to drop
                        // The directory that the user selected will be
                        // validated when the user clicks next
                        szPath[ ARRAYSIZE(g_Options.szSourcePath) - 1 ] = L'\0';
                    }
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), szPath );
                }
            }
            break;

        default:
            break;
        }
        break;

    default:           
        //
        // try to cancel CD autoplay
        //
        if (!g_uQueryCancelAutoPlay) {
            g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
            DebugMsg( "generate autoplay message %d\n", g_uQueryCancelAutoPlay );
        }

        if (uMsg == g_uQueryCancelAutoPlay) {
            DebugMsg( "received autoplay message\n" );
            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }

        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// VerifyDirectoryName( )
//
BOOL
VerifyDirectoryName( )
{
    TraceFunc( "VerifyDirectoryName()\n" );
    BOOL fReturn = FALSE;

    LPWSTR psz = g_Options.szInstallationName;

    while ( *psz > 32 && *psz < 127 )
        psz++;

    if ( *psz == L'\0' )
    {
        fReturn = TRUE;
    }

    RETURN(fReturn);
}

//
// OSDirectoryDlgProc( )
//
INT_PTR CALLBACK
OSDirectoryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        {
            HWND hwndEdit = GetDlgItem( hDlg, IDC_E_OSDIRECTORY );
            Edit_LimitText( hwndEdit, ARRAYSIZE(g_Options.szInstallationName) - 1 );
            Edit_SetText( hwndEdit, g_Options.szInstallationName );
        }
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            Edit_GetText( GetDlgItem( hDlg, IDC_E_OSDIRECTORY ),
                          g_Options.szInstallationName,
                          ARRAYSIZE( g_Options.szInstallationName ) );
            if ( !VerifyDirectoryName( ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TITLE, IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TEXT, MB_OK );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            BuildDirectories( );
            CheckDirectory( hDlg, g_Options.szInstallationPath );
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || !g_Options.fNewOS ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }
            else
            {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_OSDIRECTORY) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    case WM_COMMAND:
        {
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_OSDIRECTORY ) );
                PropSheet_SetWizButtons( GetParent( hDlg ), ( dwLen  ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK ) );
            }
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// HelpTextEditWndProc( )
//
INT_PTR CALLBACK
HelpTextEditWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch ( uMsg )
    {
    case WM_KEYDOWN:
        // ignore CONTROL characters
        if ( 0 <= GetKeyState( VK_CONTROL ) )
        {
            // fake button presses
            if ( LOWORD( wParam ) == VK_RETURN ) {
                PropSheet_PressButton( GetParent( GetParent( hWnd ) ), PSBTN_NEXT );
                return FALSE;
            } else if ( LOWORD( wParam ) == VK_ESCAPE ) {
                PropSheet_PressButton( GetParent( GetParent( hWnd ) ), PSBTN_CANCEL );
                return FALSE;
            }
        }
        break;
    }

    return CallWindowProc(g_pOldEditWndProc, hWnd, uMsg, wParam, lParam);
}

//
// VerifySIFText( )
//
BOOL
VerifySIFText(
    LPWSTR pszText )
{
    TraceFunc( "VerifySIFText()\n" );
    BOOL fReturn = FALSE;

    if ( !pszText )
        RETURN(fReturn);

    //
    // make sure the string consists of valid characters that can be displayed
    // by the OS Chooser.  Note that the OS Chooser is not localized, so this
    // check is really for ASCII chars >= 32 (space) and < 127 (DEL)
    //
    while ( *pszText >= 32 && *pszText < 127 )
        pszText++;

    if ( *pszText == L'\0' )
    {
        fReturn = TRUE;
    }

    RETURN(fReturn);
}

//
// DefaultSIFDlgProc( )
//
// Generates the default SIF.
//
INT_PTR CALLBACK
DefaultSIFDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
    WCHAR szHelpTextFromInf[200];
    WCHAR szDescriptionFromInf[200];
    WCHAR szHelpTextFormat [200];
    DWORD dw;

    

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_DESCRIPTION ), ARRAYSIZE(g_Options.szDescription) - 1 );
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_HELPTEXT ), ARRAYSIZE(g_Options.szHelpText) - 1 );
        // subclass the edit boxes
        g_pOldEditWndProc = (WNDPROC) SetWindowLongPtr( GetDlgItem( hDlg, IDC_E_HELPTEXT), GWLP_WNDPROC, (LONG_PTR)&HelpTextEditWndProc);
        SetWindowLongPtr( GetDlgItem( hDlg, IDC_E_HELPTEXT), GWLP_WNDPROC, (LONG_PTR)&HelpTextEditWndProc);
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZBACK: //fall through           
        case PSN_WIZNEXT:
            Edit_GetText( GetDlgItem( hDlg, IDC_E_DESCRIPTION ),
                          szDescriptionFromInf,
                          ARRAYSIZE(szDescriptionFromInf) );
            Edit_GetText( GetDlgItem( hDlg, IDC_E_HELPTEXT ),
                          szHelpTextFromInf,
                          ARRAYSIZE(szHelpTextFromInf) );
            if ( !VerifySIFText( szDescriptionFromInf ) )
            {
                MessageBoxFromStrings( hDlg,
                                       IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE,
                                       IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT,
                                       MB_OK );
                SetFocus( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't go to next dialog
                break;
            }

            wcscpy( g_Options.szDescription, szDescriptionFromInf );

            if ( !VerifySIFText( szHelpTextFromInf ) )
            {
                MessageBoxFromStrings( hDlg,
                                       IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE,
                                       IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT,
                                       MB_OK );
                SetFocus( GetDlgItem( hDlg, IDC_E_HELPTEXT ) );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );  // don't go to next dialog
                break;
            }

            wcscpy( g_Options.szHelpText, szHelpTextFromInf );

            g_Options.fRetrievedWorkstationString = TRUE;
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || !g_Options.fNewOS ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }
            
            if (g_Options.szDescription[0] == L'\0') {
                //
                // we did not find a description from txtsetup.sif
                //
                if (SUCCEEDED(GetHelpAndDescriptionTextFromSif(
                                        szHelpTextFromInf,
                                        ARRAYSIZE(szHelpTextFromInf),
                                        szDescriptionFromInf,
                                        ARRAYSIZE(szDescriptionFromInf)))) {
                    wcscpy(g_Options.szDescription,szDescriptionFromInf);
                    wcscpy(g_Options.szHelpText,szHelpTextFromInf);
                }
            } else {
                //
                // We got a description and need to build the Help text
                //
                if (g_Options.szHelpText[0] == L'\0') {
                    dw = LoadString( g_hinstance, IDS_DEFAULT_HELPTEXT,
                                     szHelpTextFormat, ARRAYSIZE(szHelpTextFormat) );
                    Assert( dw );
                    wsprintf(g_Options.szHelpText, szHelpTextFormat, g_Options.szDescription);                
                }
            }
    
            SetDlgItemText( hDlg, IDC_E_DESCRIPTION, g_Options.szDescription );
            SetDlgItemText( hDlg, IDC_E_HELPTEXT, g_Options.szHelpText );

            DWORD dwLen1 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION) );
            DWORD dwLen2 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT) );
            PropSheet_SetWizButtons( GetParent( hDlg ),
                                     (dwLen1 && dwLen2 ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );           

            ClearMessageQueue( );
            break;
        }
        break;

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
        case IDC_E_DESCRIPTION:
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                DWORD dwLen1 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION) );
                DWORD dwLen2 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen1 && dwLen2 ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );                
            }
            break;

        case IDC_E_HELPTEXT:
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                DWORD dwLen1 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION) );
                DWORD dwLen2 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen1 && dwLen2 ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );                
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// ScreensDlgProc( )
//
INT_PTR CALLBACK
ScreensDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        SetFocus( GetDlgItem( hDlg, IDC_R_SAVEOLDFILES ) );
        BaseDlgProc( hDlg, uMsg, wParam, lParam );
        return FALSE;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || !g_Options.fNewOS
              || !g_Options.fOSChooserScreensDirectory
              || g_Options.fFirstTime ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }

            LONG lResult;
            lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_LEAVEALONE ) );
            g_Options.fScreenLeaveAlone = !!(lResult == BST_CHECKED);

            lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_OVERWRITE ) );
            g_Options.fScreenOverwrite = !!(lResult == BST_CHECKED);

            lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_SAVEOLDFILES ) );
            g_Options.fScreenSaveOld = !!(lResult == BST_CHECKED);
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK |
                ( g_Options.fScreenLeaveAlone
                | g_Options.fScreenOverwrite
                | g_Options.fScreenSaveOld ? PSWIZB_NEXT : 0 ) );
            ClearMessageQueue( );
            break;

        }
        break;

        case WM_COMMAND:
            if ( HIWORD( wParam ) == BN_CLICKED ) {
                LONG lResult;
                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_LEAVEALONE ) );
                g_Options.fScreenLeaveAlone = !!(lResult == BST_CHECKED);

                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_OVERWRITE ) );
                g_Options.fScreenOverwrite = !!(lResult == BST_CHECKED);

                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_SAVEOLDFILES ) );
                g_Options.fScreenSaveOld = !!(lResult == BST_CHECKED);

                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK |
                    ( g_Options.fScreenLeaveAlone
                    | g_Options.fScreenOverwrite
                    | g_Options.fScreenSaveOld ? PSWIZB_NEXT : 0 ) );
            }
            break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// LanguageDlgProc( )
//
INT_PTR CALLBACK
LanguageDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( !g_Options.fNewOS 
              || g_Options.fError
              || g_Options.fAbort ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // do not show this page
                return TRUE;
            } else {

                WCHAR szCodePage[ 32 ];
                DWORD dwCodePage;
                LPTSTR psz;

                if (g_Options.fAutomated) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                }

                // we should have the workstation language by now
                Assert( g_Options.fLanguageSet );

                if ((dwCodePage = GetSystemDefaultLCID())) {                
                    DebugMsg( "Server's Installation Code Page: 0x%04x\n", dwCodePage );
                    if ( dwCodePage != g_Options.dwWksCodePage ) {   
                        // Check to see if the OSChooser\<Language> exists. If it does,
                        // we don't show the warning page.
                        WCHAR szPath[ MAX_PATH ];
                        wsprintf( 
                            szPath, 
                            L"%s\\OSChooser\\%s", 
                            g_Options.szIntelliMirrorPath, 
                            g_Options.szLanguage );
                        
                        DebugMsg( "Checking for %s directory....", szPath );
                        if ( 0xFFFFffff == GetFileAttributes( szPath ) ) // doesn't exist
                        {   // show the page
                            DebugMsg( "doesn't exist.\n" );
                            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                            ClearMessageQueue( );
                            return TRUE;
                        } 
                        DebugMsg( "does. Skip warning.\n" );
                        // don't show the page, must have already been prompted
                        // before. 
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                        return TRUE;
                    } else {
                        // don't show the page, the locales match 
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                        return TRUE;
                    }
                }
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// SummaryDlgProc( )
//
INT_PTR CALLBACK
SummaryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( !g_Options.fNewOS 
              || g_Options.fError
              || g_Options.fAbort ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // do not show this page
                break;
            } else {
                WCHAR szText[ SMALL_BUFFER_SIZE ] = { L'\0' };
                WCHAR szFilepath[ MAX_PATH ];
                DWORD dwLen = 0;
                RECT  rect;

                if( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ) {

                    DWORD dw = LoadString( g_hinstance, IDS_X86, szText, ARRAYSIZE( szText ));
                    Assert( dw );

                } else if ( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ) {

                    DWORD dw = LoadString( g_hinstance, IDS_IA64, &szText[ dwLen ], ARRAYSIZE( szText ) - dwLen );                
                    Assert( dw );
                }

                // attempt to ellipsis path
                lstrcpy( szFilepath, g_Options.szSourcePath );
                GetWindowRect( GetDlgItem( hDlg, IDC_S_SOURCEPATH ), &rect );
                PathCompactPath( NULL, szFilepath, rect.right - rect.left );

                SetDlgItemText( hDlg, IDC_S_SOURCEPATH, szFilepath );
                SetDlgItemText( hDlg, IDC_S_OSDIRECTORY, g_Options.szInstallationName );
                SetDlgItemText( hDlg, IDC_S_PLATFORM,   szText );

                SetDlgItemText( hDlg, IDC_S_INTELLIMIRRORROOT, g_Options.szIntelliMirrorPath );
                SetDlgItemText( hDlg, IDC_S_LANGUAGE,   g_Options.szLanguage );

                wsprintf( szFilepath, L"%s.%s", g_Options.szMajorVersion, g_Options.szMinorVersion );
                SetDlgItemText( hDlg, IDC_S_NTVERSION,  szFilepath );

                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_FINISH | PSWIZB_BACK );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// ServerOKDlgProc( )
//
INT_PTR CALLBACK
ServerOKDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fNewOS 
              || g_Options.fError
              || g_Options.fAbort ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            HRESULT hr = CheckInstallation( );
            if ( hr != S_OK ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                PropSheet_PressButton( GetParent( hDlg ), PSBTN_FINISH );
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_FINISH );
            ClearMessageQueue( );
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// CheckWelcomeDlgProc( )
//
// "Check's Welcome" dialog proc.
//
INT_PTR CALLBACK
CheckWelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( !g_Options.fCheckServer ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
            ClearMessageQueue( );
            break;

        case PSN_WIZNEXT:
            // CheckInstallation( );
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// AddWelcomeDlgProc( )
//
// "Add's Welcome" dialog proc.
//
INT_PTR CALLBACK
AddWelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( !g_Options.fAddOption ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
            ClearMessageQueue( );
            break;

        case PSN_WIZNEXT:
            // CheckInstallation( );
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// ExamineServerDlgProc( )
//
// This is the screen that is shown wait CheckInstallation() runs for 
// the first time. I had to move it from the InitializeOptions() because 
// "-upgrade" shouldn't go through the exhaustive search and possibly
// show UI.
//
INT_PTR CALLBACK
ExamineServerDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fAlreadyChecked 
              || g_Options.fError 
              || g_Options.fAbort )
            {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
               
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            ClearMessageQueue( );
            PostMessage( hDlg, WM_USER, 0, 0 );
            break;
        }
        break;

    case WM_USER:
        {
            DWORD hr;
            HANDLE hThread;
            hThread = CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE) &CheckInstallation, NULL, NULL, NULL );
            while ( WAIT_TIMEOUT == WaitForSingleObject( hThread, 0) )
            {
                MSG Msg;
                if ( PeekMessage( &Msg, NULL, 0, 0, PM_REMOVE ) )
                {
                    DispatchMessage( &Msg );
                }
            }
            if ( GetExitCodeThread( hThread, &hr ) )
            {
                DebugMsg( "Thread Exit Code was 0x%08x\n", hr );
                // If check installation failed, bail!
                if ( FAILED( hr ) ) {
                    // Bail on the whole thing. Fake the finish button so
                    // we can exit without the "Are you sure?" dialog popping up.
                    g_Options.fError = TRUE;
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSBTN_FINISH );
                    PropSheet_PressButton( GetParent( hDlg ), PSBTN_FINISH );
                    break;
                }
            }

            CloseHandle( hThread );
            g_Options.fAlreadyChecked = TRUE;

            // Push the next button
            PropSheet_PressButton( GetParent( hDlg ), PSBTN_NEXT );
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


LBITEMDATA items[] = {
    { STATE_NOTSTARTED, IDS_CREATINGDIRECTORYTREE, CreateDirectories,           TEXT("") },  // 0
    { STATE_NOTSTARTED, IDS_COPYSERVERFILES,       CopyServerFiles,             TEXT("") },  // 1
    { STATE_NOTSTARTED, IDS_COPYINGFILES,          CopyClientFiles,             TEXT("") },  // 2
    { STATE_NOTSTARTED, IDS_UPDATINGSCREENS,       CopyScreenFiles,             TEXT("") },  // 3
    { STATE_NOTSTARTED, IDS_COPYTEMPLATEFILES,     CopyTemplateFiles,           TEXT("") },  // 4
    { STATE_NOTSTARTED, IDS_CREATING_SERVICES,     CreateRemoteBootServices,    TEXT("") },  // 5
    { STATE_NOTSTARTED, IDS_UPDATINGREGISTRY,      ModifyRegistry,              TEXT("") },  // 6
    { STATE_NOTSTARTED, IDS_CREATING_SIS_VOLUME,   CreateSISVolume,             TEXT("") },  // 7
    { STATE_NOTSTARTED, IDS_STARTING_SERVICES,     StartRemoteBootServices,     TEXT("") },  // 8
    { STATE_NOTSTARTED, IDS_AUTHORIZING_DHCP,      AuthorizeDhcp,               TEXT("") }   // 9
};


//
// SetupDlgProc( )
//
INT_PTR CALLBACK
SetupDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    static BOOL bDoneFirstPass;
    static UINT nItems;
    static HBRUSH hBrush = NULL;
    LPSETUPDLGDATA psdd = (LPSETUPDLGDATA) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            {
                BITMAP bm;

                // grab the bitmaps
                psdd = (LPSETUPDLGDATA) TraceAlloc( GMEM_FIXED, sizeof(SETUPDLGDATA) );

                if (psdd == NULL) {
                    return FALSE;
                }

                psdd->hChecked = LoadImage( g_hinstance,
                                            MAKEINTRESOURCE( IDB_CHECK ),
                                            IMAGE_BITMAP,
                                            0, 0,
                                            LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
                DebugMemoryAddHandle( psdd->hChecked );
                GetObject( psdd->hChecked, sizeof(bm), &bm );
                psdd->dwWidth = bm.bmWidth;

                psdd->hError   = LoadImage( g_hinstance,
                                            MAKEINTRESOURCE( IDB_X ),
                                            IMAGE_BITMAP,
                                            0, 0,
                                            LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
                DebugMemoryAddHandle( psdd->hError );
                GetObject( psdd->hError, sizeof(bm), &bm );
                psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ? psdd->dwWidth : bm.bmWidth );

                psdd->hArrow   = LoadImage( g_hinstance,
                                            MAKEINTRESOURCE( IDB_ARROW ),
                                            IMAGE_BITMAP,
                                            0, 0,
                                            LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
                DebugMemoryAddHandle( psdd->hArrow );
                GetObject( psdd->hArrow, sizeof(bm), &bm );
                psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ?
                                  psdd->dwWidth :
                                  bm.bmWidth );

                HWND    hwnd = GetDlgItem( hDlg, IDC_L_SETUP );

                HFONT hFontOld = (HFONT) SendMessage( hwnd, WM_GETFONT, 0, 0);
                if(hFontOld != NULL)
                {
                    LOGFONT lf;
                    if ( GetObject( hFontOld, sizeof(LOGFONT), (LPSTR) &lf ) )
                    {
                        psdd->hFontNormal = CreateFontIndirect(&lf);
                        DebugMemoryAddHandle( psdd->hFontNormal );

                        lf.lfWeight = FW_BOLD;
                        psdd->hFontBold = CreateFontIndirect(&lf);
                        DebugMemoryAddHandle( psdd->hFontBold );
                    }
                }

                HDC hDC = GetDC( NULL );
                HANDLE hOldFont = SelectObject( hDC, psdd->hFontBold );
                TEXTMETRIC tm;
                GetTextMetrics( hDC, &tm );
                psdd->dwHeight = tm.tmHeight + 2;
                SelectObject( hDC, hOldFont );
                ReleaseDC( NULL, hDC );

                ListBox_SetItemHeight( hwnd, -1, psdd->dwHeight );

                SetWindowLongPtr( hDlg, GWLP_USERDATA, (LONG_PTR) psdd );

                //
                // Eliminate things that have already been done
                //
                if ( g_Options.fDirectoryTreeExists
                  && g_Options.fIMirrorShareFound ) {
                    items[ 0 ].uState = STATE_WONTSTART;
                }

                if ( !g_Options.fFirstTime
                  && g_Options.fTFTPDFilesFound
                  && g_Options.fSISFilesFound
                  && g_Options.fSISGrovelerFilesFound
                  && g_Options.fOSChooserInstalled
                  && g_Options.fBINLFilesFound
                  && g_Options.fRegSrvDllsFilesFound ) {
                    items[ 1 ].uState = STATE_WONTSTART;
                }

                if ( !g_Options.fNewOS ) {
                    items[ 2 ].uState = STATE_WONTSTART;
                    items[ 3 ].uState = STATE_WONTSTART;
                }

                if ( !g_Options.fNewOS
                   || ( g_Options.fScreenLeaveAlone
                     && !g_Options.fFirstTime ) ) {
                    items[ 3 ].uState = STATE_WONTSTART;
                }

                if ( !g_Options.fNewOS ) {
                    items[ 4 ].uState = STATE_WONTSTART;
                }

                if ( g_Options.fBINLServiceInstalled
                  && g_Options.fTFTPDServiceInstalled
                  && g_Options.fSISServiceInstalled
                  && g_Options.fSISGrovelerServiceInstalled
                  && g_Options.fBINLSCPFound ) {
                    items[ 5 ].uState = STATE_WONTSTART;
                }

                if ( g_Options.fRegistryIntact
                  && g_Options.fRegSrvDllsRegistered
                  && g_Options.fTFTPDDirectoryFound ) {
                    items[ 6 ].uState = STATE_WONTSTART;
                }

                if ( g_Options.fSISVolumeCreated ) {
                    items[ 7 ].uState = STATE_WONTSTART;
                }

                if( g_Options.fDontAuthorizeDhcp ) {
                    items[ 9 ].uState = STATE_WONTSTART;
                }

                nItems = 0;
                for( int i = 0; i < ARRAYSIZE(items); i++ )
                {
                    if ( items[i].uState != STATE_WONTSTART ) {
                        DWORD dw = LoadString( g_hinstance,
                                               items[ i ].rsrcId,
                                               items[ i ].szText,
                                               ARRAYSIZE( items[ i ].szText ) );
                        Assert( dw );

                        ListBox_AddString( hwnd, &items[ i ] );
                        nItems++;
                    }
                }

                bDoneFirstPass = FALSE;

                //
                // Set a timer to fire in a few seconds so that we can force 
                // the setup to proceed even if we don't get the WM_DRAWITEM
                // messages
                //
                SetTimer(hDlg,1,3 * 1000,NULL);

            }

            CenterDialog( hDlg );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_DESTROY:
            {
                Assert( psdd );
                if ( hBrush != NULL )
                {
                    DeleteObject(hBrush);
                    hBrush = NULL;
                }
                DeleteObject( psdd->hChecked );
                DebugMemoryDelete( psdd->hChecked );
                DeleteObject( psdd->hError );
                DebugMemoryDelete( psdd->hError );
                DeleteObject( psdd->hArrow );
                DebugMemoryDelete( psdd->hArrow );
                DeleteObject( psdd->hFontNormal );
                DebugMemoryDelete( psdd->hFontNormal );
                DeleteObject( psdd->hFontBold );
                DebugMemoryDelete( psdd->hFontBold );
                TraceFree( psdd );
                SetWindowLongPtr( hDlg, GWLP_USERDATA, NULL );
            }
            break;

        case WM_STARTSETUP:
            {
                HWND hwnd = GetDlgItem( hDlg, IDC_L_SETUP );
                RECT rc;
                INT  nProgressBoxHeight = 0;
                HRESULT hr;

                                SetDlgItemText( hDlg, IDC_S_OPERATION, TEXT("") );
                                SendMessage( GetDlgItem( hDlg, IDC_P_METER) , PBM_SETPOS, 0, 0 );
                GetClientRect( hwnd, &rc );

                //
                // Create the directories paths...
                //
                BuildDirectories( );
                INT i = 0;

                if (g_Options.fError) {
                    // Already tanked, set the first item with an error. 
                    for(i=0;i< ARRAYSIZE(items);i++){
                        if(items[i].uState != STATE_WONTSTART){
                            items[i].uState = STATE_ERROR;
                            break;
                        }
                    }
                }

                while ( i < ARRAYSIZE( items )
                     && !g_Options.fError
                     && !g_Options.fAbort )
                {
                    if ( items[ i ].uState != STATE_WONTSTART )
                    {
                        hr = CheckInstallation( );
                        if ( FAILED(hr) ) {
                            g_Options.fError = TRUE;
                            items[i].uState = STATE_ERROR;
                            break;
                        }
                        items[ i ].uState = STATE_STARTED;
                        InvalidateRect( hwnd, &rc, TRUE );

                        // process some messages
                        MSG Msg;
                        while ( PeekMessage( &Msg, NULL, 0, 0, PM_REMOVE ) )
                        {
                            TranslateMessage( &Msg );
                            DispatchMessage( &Msg );
                        }
                        hr = THR( items[ i ].pfn( hDlg ) );
                        if ( FAILED(hr) ) {
                            // fatal error - halt installation
                            items[ i ].uState = STATE_ERROR;
                            g_Options.fError = TRUE;
                        } else if ( hr == S_FALSE ) {
                            // non-fatal error - but something went wrong
                            items[ i ].uState = STATE_ERROR;
                        } else {
                            items[ i ].uState = STATE_DONE;
                        }
                        InvalidateRect( hwnd, &rc, TRUE );
                    }

                    i++;
                }

                hr = THR( CheckInstallation( ) );

                if (g_Options.fFirstTime) {
                    // We believe this is the first time risetup has been run
                    if ( i > 0 ) {
                        // There were items in the list to start with
                        if ( items[ i - 1].rsrcId == IDS_AUTHORIZING_DHCP) {
                            //
                            // We reached the dhcp task, which implies we 
                            // finished
                            GetSetRanFlag( FALSE, FALSE );
                        } else {
                            //
                            // We never reached dhcp authorization (or we
                            // skipped it)
                            //
                            GetSetRanFlag( FALSE, g_Options.fError );
                        }
                    }                    
                }

                // If no errors, exit.
                if ( g_Options.fAutomated && !g_Options.fError )
                {
                    EndDialog( hDlg, 1 );
                }
                else
                {   // we are not bailing, resize, etc.
                    // disable & hide "Cancel" button
                    HWND hwndCancel = GetDlgItem( hDlg, IDCANCEL );
                    ShowWindow( hwndCancel, SW_HIDE );
                    EnableWindow( hwndCancel, FALSE );

                    // hide progress bar stuff
                    HWND hwndGroupBox = GetDlgItem( hDlg, IDC_G_OPERATION );
                    ShowWindow( GetDlgItem( hDlg, IDC_S_OPERATION), SW_HIDE );
                    ShowWindow( GetDlgItem( hDlg, IDC_P_METER), SW_HIDE );
                    ShowWindow( hwndGroupBox, SW_HIDE );
                    GetWindowRect( hwndGroupBox, &rc );
                    nProgressBoxHeight = rc.bottom - rc.top;

                    // make "Done" button move it up and make it visible
                    HWND hwndOK = GetDlgItem( hDlg, IDOK );
                    GetWindowRect( hwndOK, &rc );
                    MapWindowPoints( NULL, hDlg, (LPPOINT) &rc, 2 );
                    SetWindowPos( hwndOK,
                                  NULL,
                                  rc.left, rc.top - nProgressBoxHeight,
                                  0, 0,
                                  SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW );

                    // make "Done" the default button
                    LONG lStyle = GetWindowLong( hwndOK, GWL_STYLE );
                    lStyle |= BS_DEFPUSHBUTTON;
                    SetWindowLong( hwndOK, GWL_STYLE, lStyle );
                    EnableWindow( hwndOK, TRUE );

                    // Shrink dialog
                    GetWindowRect( hDlg, &rc );
                    MoveWindow( hDlg,
                                rc.left, rc.top,
                                rc.right - rc.left, rc.bottom - rc.top - nProgressBoxHeight,
                                TRUE );
                }
            }
            break;


        case WM_MEASUREITEM:
            {
                LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam;
                RECT    rc;
                HWND    hwnd = GetDlgItem( hDlg, IDC_L_SETUP );

                GetClientRect( hwnd, &rc );

                lpmis->itemWidth = rc.right - rc.left;
                lpmis->itemHeight = 15;
            }
            break;

        case WM_DRAWITEM:
            {
                Assert( psdd );

                LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;
                LPLBITEMDATA plbid = (LPLBITEMDATA) lpdis->itemData;
                RECT rc = lpdis->rcItem;
                HANDLE hOldFont = INVALID_HANDLE_VALUE;

                rc.right = rc.bottom = psdd->dwWidth;

                switch ( plbid->uState )
                {
                    case STATE_NOTSTARTED:
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                        break;

                    case STATE_STARTED:
                        DrawBitmap( psdd->hArrow, lpdis, &rc );
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontBold );
                        break;

                    case STATE_DONE:
                        DrawBitmap( psdd->hChecked, lpdis, &rc );
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                        break;

                    case STATE_ERROR:
                        DrawBitmap( psdd->hError, lpdis, &rc );
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                        break;
                }
                
                rc = lpdis->rcItem;
                rc.left += psdd->dwHeight;

                DrawText( lpdis->hDC, plbid->szText, -1, &rc, DT_LEFT | DT_VCENTER );

                if ( hOldFont != INVALID_HANDLE_VALUE )
                {
                    SelectObject( lpdis->hDC, hOldFont );
                }

                if ( !bDoneFirstPass && lpdis->itemID == nItems - 1 )
                {
                    // delay the message until we have painted at least once.
                    bDoneFirstPass = TRUE;
                    PostMessage( hDlg, WM_STARTSETUP, 0, 0 );
                }

            }
            break;

        case WM_CTLCOLORLISTBOX:
            {
                if ( hBrush == NULL )
                {
                    LOGBRUSH brush;
                    brush.lbColor = GetSysColor( COLOR_3DFACE );
                    brush.lbStyle = BS_SOLID;
                    hBrush = (HBRUSH) CreateBrushIndirect( &brush );
                }
                SetBkMode( (HDC) wParam, OPAQUE );
                SetBkColor( (HDC) wParam, GetSysColor( COLOR_3DFACE ) );
                return (INT_PTR)hBrush;
            }
            break;

        case WM_SETTINGCHANGE:
            if ( hBrush ) {
                DeleteObject( hBrush );
                hBrush = NULL;
            }
            break;

        case WM_COMMAND:
            {
                switch( LOWORD( wParam ) )
                {
                case IDCANCEL:
                    if ( HIWORD(wParam) == BN_CLICKED )
                    {
                        if ( !VerifyCancel( hDlg ) ) {
                            EndDialog( hDlg, 0 );
                        }
                    }
                    break;
                case IDOK:
                    if ( HIWORD(wParam) == BN_CLICKED )
                    {
                        EndDialog( hDlg, 1 );
                    }
                    break;
                }
            }

        case WM_TIMER:
            if ( !bDoneFirstPass && g_Options.fAutomated ) { 
                //
                // we're in an unattended setup.  We haven't gotten the
                // WM_STARTSETUP signal yet, so we'll do that right here.
                //
                bDoneFirstPass = TRUE;
                PostMessage( hDlg, WM_STARTSETUP, 0, 0 );                
            }
            KillTimer(hDlg, 1);
            //
            // fall through
            //
        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\pch.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: PCH.H

  Precompiled header file.

 ***************************************************************************/

#define UNICODE

#if DBG == 1
#define DEBUG
#endif

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <setupapi.h>
#include <advpub.h>
#include <lm.h>
#include <commdlg.h>
#include <prsht.h>
#include <pshpack2.h>
#include <poppack.h>
#include <commctrl.h>   // includes the common control header
#include <aclapi.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <winsock.h>
#include <dsgetdc.h>
#include <winldap.h>
#include <dsrole.h>
#include <ntdsapi.h>
#include <secext.h>
extern "C" {
#include <spapip.h>
#include <remboot.h>
}

#include "rbsetup.h"
#include "debug.h"
#include "utils.h"
#include "resource.h"

// from ntioapi.h
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000

//
// Inc/decrements macros.
//
#define InterlockDecrement( _var ) --_var;
#define InterlockIncrement( _var ) ++_var;

//
// ARRAYSIZE macro
//
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\main.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997-1999
   All rights reserved

 ***************************************************************************/

#include "pch.h"

#include "dialogs.h"
#include "check.h"
#include "setup.h"
#include "automate.h"

DEFINE_MODULE("Main");

// Globals
HINSTANCE g_hinstance = NULL;
OPTIONS   g_Options;

// Command line flags
#define OPTION_UNKNOWN              0x00
#define OPTION_VERSIONINGOVERRIDE   0x01
#define OPTION_DEBUG                0x02
#define OPTION_FUNC                 0x03
#define OPTION_CHECK                0x04
#define OPTION_ADD                  0x05
#define OPTION_UPGRADE              0x06

#define OPTION_AUTOMATED            0x08


// Constants
#define NUMBER_OF_PAGES 15

//
// Adds a page to the dialog.
//
void
AddPage(
    LPPROPSHEETHEADER ppsh,
    UINT id,
    DLGPROC pfn,
    UINT idTitle,
    UINT idSubtitle )
{
    PROPSHEETPAGE psp;
    TCHAR szTitle[ SMALL_BUFFER_SIZE ];
    TCHAR szSubTitle[ SMALL_BUFFER_SIZE ];

    ZeroMemory( &psp, sizeof(psp) );
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
    if ( id == IDD_WELCOME || id == IDD_WELCOME_ADD || id == IDD_WELCOME_CHECK )
    {
        psp.dwFlags |= PSP_HIDEHEADER;
    }
    else
    {
        psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

        if ( idTitle )
        {
            DWORD dw;

            dw = LoadString( g_hinstance, idTitle, szTitle, ARRAYSIZE(szTitle) );
            Assert( dw );
            psp.pszHeaderTitle = szTitle;
        }
        else
        {
            psp.pszHeaderTitle = NULL;
        }

        if ( idSubtitle )
        {
            DWORD dw;

            dw = LoadString( g_hinstance, idSubtitle , szSubTitle, ARRAYSIZE(szSubTitle) );
            Assert( dw );
            psp.pszHeaderSubTitle = szSubTitle;
        }
        else
        {
            psp.pszHeaderSubTitle = NULL;
        }
    }
    psp.pszTitle    = g_Options.fCheckServer 
                           ? MAKEINTRESOURCE( IDS_CHECK_SERVER_TITLE)
                           : MAKEINTRESOURCE( IDS_APPNAME );
    psp.hInstance   = ppsh->hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(id);
    psp.pfnDlgProc  = pfn;

    ppsh->phpage[ ppsh->nPages ] = CreatePropertySheetPage( &psp );
    if ( ppsh->phpage[ ppsh->nPages ] )
        ppsh->nPages++;
}

//
// Creates the UI pages and kicks off the property sheet.
//
HRESULT
WizardPages( )
{
    TraceFunc( "WizardPages( )\n" );

    HRESULT         hr = S_OK;
    HPROPSHEETPAGE  rPages[ NUMBER_OF_PAGES ];
    PROPSHEETHEADER pshead;

    ZeroMemory( &pshead, sizeof(pshead) );
    pshead.dwSize       = sizeof(pshead);
    pshead.dwFlags      = PSH_WIZARD97 | PSH_PROPTITLE | PSH_USEHICON
                        | PSH_WATERMARK | PSH_HEADER;
    pshead.hInstance    = g_hinstance;
    pshead.pszCaption   = g_Options.fCheckServer 
                           ? MAKEINTRESOURCE( IDS_CHECK_SERVER_TITLE)
                           : MAKEINTRESOURCE( IDS_APPNAME );
    pshead.phpage       = rPages;
    pshead.pszbmWatermark = MAKEINTRESOURCE( IDB_TITLEPAGE );
    pshead.pszbmHeader  = MAKEINTRESOURCE( IDB_HEADER );


    AddPage( &pshead, IDD_WELCOME,          (DLGPROC) WelcomeDlgProc,           0, 0 );
    AddPage( &pshead, IDD_WELCOME_ADD,      (DLGPROC) AddWelcomeDlgProc,        0, 0 );
    AddPage( &pshead, IDD_WELCOME_CHECK,    (DLGPROC) CheckWelcomeDlgProc,      0, 0 );
    AddPage( &pshead, IDD_EXAMINING_SERVER, (DLGPROC) ExamineServerDlgProc,     IDS_EXAMINING_TITLE, IDS_EXAMINING_SUBTITLE );
    AddPage( &pshead, IDD_INTELLIMIRRORROOT,(DLGPROC) IntelliMirrorRootDlgProc, IDS_INTELLIMIRRORROOT_TITLE, IDS_INTELLIMIRRORROOT_SUBTITLE );
    AddPage( &pshead, IDD_SCP,              (DLGPROC) SCPDlgProc,               IDS_SCP_TITLE, IDS_SCP_SUBTITLE );
    AddPage( &pshead, IDD_OPTIONS,          (DLGPROC) OptionsDlgProc,           IDS_OPTIONS_TITLE, IDS_OPTIONS_SUBTITLE );
    AddPage( &pshead, IDD_IMAGESOURCE,      (DLGPROC) ImageSourceDlgProc,       IDS_IMAGESOURCE_TITLE, IDS_IMAGESOURCE_SUBTITLE );
    AddPage( &pshead, IDD_LANGUAGE,         (DLGPROC) LanguageDlgProc,          IDS_LANGUAGE_TITLE, IDS_LANGUAGE_SUBTITLE );
    AddPage( &pshead, IDD_OSDIRECTORY,      (DLGPROC) OSDirectoryDlgProc,       IDS_OSDIRECTORY_TITLE, IDS_OSDIRECTORY_SUBTITLE );
    AddPage( &pshead, IDD_DEFAULTSIF,       (DLGPROC) DefaultSIFDlgProc,        IDS_DEFAULTSIF_TITLE, IDS_DEFAULTSIF_SUBTITLE );
    AddPage( &pshead, IDD_SCREENS,          (DLGPROC) ScreensDlgProc,           IDS_SCREENS_TITLE, IDS_SCREENS_SUBTITLE );
    AddPage( &pshead, IDD_SUMMARY,          (DLGPROC) SummaryDlgProc,           IDS_SUMMARY_TITLE, IDS_SUMMARY_SUBTITLE );
    AddPage( &pshead, IDD_WARNING,          (DLGPROC) WarningDlgProc,           IDS_WARNING_TITLE, IDS_WARNING_SUBTITLE );
    AddPage( &pshead, IDD_SERVEROK,         (DLGPROC) ServerOKDlgProc,          IDS_SERVEROK_TITLE, IDS_SERVEROK_SUBTITLE );

    PropertySheet( &pshead );

    if ( g_Options.fAbort )
    {
        hr = S_FALSE;
        goto Error;
    }

    if ( g_Options.fError )
    {
       hr = E_FAIL;
       goto Error;
    }

Error:
    RETURN(hr);
}

//
// Initializes g_Options.
//
HRESULT
InitializeOptions( void )
{
    DWORD   dw;
    LRESULT lResult;
    HKEY    hkeySetup;

    TraceFunc( "InitializeOptions( )\n" );

    //
    // Initialize all variable to NULL strings or FALSE
    //
    memset( &g_Options, 0, sizeof(OPTIONS) );

    //
    // Load default strings
    //
    dw = LoadString( g_hinstance, IDS_DEFAULTSETUP,
                     g_Options.szInstallationName, ARRAYSIZE(g_Options.szInstallationName) );
    Assert( dw );

    dw = LoadString( g_hinstance, IDS_UNKNOWN, g_Options.szLanguage, ARRAYSIZE(g_Options.szLanguage) );
    Assert( dw );

    wcscpy( g_Options.szSourcePath, L"C:\\" );
    for( ; g_Options.szSourcePath[0] <= L'Z'; g_Options.szSourcePath[0]++ )
    {
        UINT uDriveType;

        uDriveType = GetDriveType( g_Options.szSourcePath );

        if ( DRIVE_CDROM == uDriveType )
            break;
    }

    if ( g_Options.szSourcePath[0] > L'Z' ) {
        g_Options.szSourcePath[0] = L'\0';
    }

    g_Options.hinf = INVALID_HANDLE_VALUE;

    g_Options.fFirstTime = TRUE;
    lResult = RegOpenKey( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup", &hkeySetup );
    if ( lResult == ERROR_SUCCESS )
    {
        DWORD dwValue;
        DWORD cbValue;
        
        // Find out if we should authorize DCHP
        cbValue = sizeof(dwValue);
        lResult = RegQueryValueEx( hkeySetup, L"RemInst_DontAuthorizeDHCP", NULL, NULL, (LPBYTE)&dwValue, &cbValue );
        if ( lResult == ERROR_SUCCESS ) {
            g_Options.fDontAuthorizeDhcp = dwValue;
        }

        RegCloseKey( hkeySetup );
    }

    if (SUCCEEDED(GetSetRanFlag(TRUE, FALSE))) {
        g_Options.fFirstTime = FALSE;
    } else {
        g_Options.fFirstTime = TRUE;
    }

    HRETURN(S_OK);
}

//
// IsWhiteSpace()
//
BOOL
IsWhiteSpace( wchar_t ch )
{
    if ( ch <=32 )
        return TRUE;

    return FALSE;
}

//
// CheckWhichOption()
DWORD
CheckWhichOption(
    LPWSTR pszOption )
{
    DWORD dw;
    WCHAR szOptionTag[ 64 ];

    if ( StrCmpNI( pszOption, L"xyzzy", 6 ) == 0 )
        return OPTION_VERSIONINGOVERRIDE;

    if ( StrCmpNI( pszOption, L"debug", 5 ) == 0 )
        return OPTION_DEBUG;

    if ( StrCmpNI( pszOption, L"func", 4 ) == 0 )
        return OPTION_FUNC;

    if ( StrCmpNI( pszOption, L"add", 3 ) == 0 )
        return OPTION_ADD;

    if ( StrCmpNI( pszOption, L"check", 5 ) == 0 )
        return OPTION_CHECK;

    if ( StrCmpNI( pszOption, L"upgrade", 7 ) == 0 )
        return OPTION_UPGRADE;

    if ( StrCmpNI( pszOption, L"auto", 4 ) == 0 )
        return OPTION_AUTOMATED;

    // Internationalized words
    dw = LoadString( g_hinstance, IDS_ADD, szOptionTag, ARRAYSIZE(szOptionTag) );
    Assert( dw );
    if ( StrCmpNIW( pszOption, szOptionTag, lstrlen(szOptionTag) == 0 ) )
        return OPTION_ADD;

    dw = LoadString( g_hinstance, IDS_CHECK, szOptionTag, ARRAYSIZE(szOptionTag) );
    Assert( dw );
    if ( StrCmpNI( pszOption, szOptionTag, lstrlen(szOptionTag) == 0 ) )
        return OPTION_CHECK;

    return OPTION_UNKNOWN;
}

//
// ParseCommandLine()
// Returns false if the call required useage to be printed else true
//
BOOL
ParseCommandLine( LPWSTR lpCmdLine )
{
    LPWSTR psz = lpCmdLine;

    while (*psz)
    {
        if ( *psz == L'/' || *psz == L'-' )
        {
            LPWSTR pszStartOption = ++psz;

            while (*psz && !IsWhiteSpace( *psz ) )
                psz++;

            *psz = L'\0';    // terminate

            switch ( CheckWhichOption( pszStartOption ) )
            {
            case OPTION_VERSIONINGOVERRIDE:
                g_Options.fServerCompatible = TRUE;
                break;
#ifdef DEBUG
            case OPTION_DEBUG:
                g_dwTraceFlags |= TF_HRESULTS;
                break;

            case OPTION_FUNC:
                g_dwTraceFlags |= TF_FUNC;
                break;
#endif
            case OPTION_ADD:
                g_Options.fAddOption = TRUE;
                break;

            case OPTION_AUTOMATED:
                {
                    LPWSTR pszScriptFilename;
                    UINT ErrLine;
                    g_Options.fAutomated = TRUE;
                    WCHAR   UnattendedFile[MAX_PATH];
                    LPWSTR p;

                    //
                    // get the script name
                    //

                    //
                    // first eat all the whitespace
                    //
                    psz++;
                    while(*psz && IsWhiteSpace( *psz )) {
                        psz++;
                    }

                    //
                    // now get the filename, which may or may not be quoted
                    //
                    if (*psz == L'\"') {                        
                        pszScriptFilename = ++psz;
                        while (*psz && ( L'\"' != *psz ) ) {
                            psz++;
                        }                        
                    } else {                        
                        pszScriptFilename = psz;
                        while (*psz && !IsWhiteSpace( *psz ) ) {
                            psz++;
                        }
                    }
                    
                    //
                    // NULL terminate the filename and try to open the file as
                    // an INF file
                    //

                    *psz = L'\0';

                    g_Options.hinfAutomated = INVALID_HANDLE_VALUE;
                    if( GetFullPathName( pszScriptFilename,
                                         MAX_PATH,
                                         UnattendedFile,
                                         &p ) ) {

                        g_Options.hinfAutomated = SetupOpenInfFileW( UnattendedFile, NULL, INF_STYLE_WIN4, &ErrLine );
                    }

                    if ( g_Options.hinfAutomated == INVALID_HANDLE_VALUE ) {
                        ErrorBox( NULL, NULL );
                        g_Options.fError = TRUE;
                    }
                }
                break;

            case OPTION_CHECK:
                g_Options.fCheckServer = TRUE;
                break;

            case OPTION_UPGRADE:
                g_Options.fUpgrade = TRUE;
                break;

            case OPTION_UNKNOWN :
            default :
                WCHAR szCaption[ SMALL_BUFFER_SIZE ];
                WCHAR szUsage[ SMALL_BUFFER_SIZE * 2 ];
                DWORD dw;
                dw = LoadStringW( g_hinstance, IDS_APPNAME, szCaption, ARRAYSIZE( szCaption ) );
                Assert( dw );
                dw = LoadStringW( g_hinstance, IDS_USAGE, szUsage, ARRAYSIZE( szUsage ));
                Assert( dw );
                MessageBoxW( NULL, szUsage, szCaption, MB_OK );
                return FALSE;
            }
        }

        psz++;
    }
    return TRUE;
}

//
// DoSetup( )
//
HRESULT
DoSetup( )
{
    HRESULT hr = S_OK;
    INT iReturn;

    //
    // Setup dialog
    //
    iReturn = (INT)DialogBox( g_hinstance,
                         MAKEINTRESOURCE(IDD_TASKS),
                         NULL,
                         SetupDlgProc );
    return hr;
}

//
// CheckForReboot( )
//
void
CheckForReboot( )
{
    if ( !g_Options.fSISServiceInstalled )
    {
        MessageBoxFromStrings( NULL,
                               IDS_MUST_REBOOT_TITLE,
                               IDS_MUST_REBOOT_MESSAGE,
                               MB_OK | MB_ICONEXCLAMATION );

        SetupPromptReboot( NULL, NULL, FALSE );
    }
}

//
// RunningOnNTServer( )
//
BOOL
RunningOnNTServer(void)
{
    TraceFunc( "RunningOnNtServer()\n" );

    HKEY  hkey;
    LONG  lResult;
    WCHAR szProductType[50] = { 0 };
    DWORD dwType;
    DWORD dwSize  = ARRAYSIZE(szProductType);
    BOOL  fReturn = FALSE; // assume that we are not on NTServer.

    // Query the registry for the product type.
    lResult = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                             L"System\\CurrentControlSet\\Control\\ProductOptions",
                             0,
                             KEY_READ,
                             &hkey);
    Assert( lResult == ERROR_SUCCESS );
    if ( lResult != ERROR_SUCCESS )
        goto Error;

    lResult = RegQueryValueEx ( hkey,
                                L"ProductType",
                                NULL,
                                &dwType,
                                (LPBYTE) szProductType,
                                &dwSize);
    Assert( lResult == ERROR_SUCCESS );
    RegCloseKey (hkey);
    if (lResult != ERROR_SUCCESS)
        goto Error;

    if ( StrCmpI( szProductType, L"ServerNT" ) == 0 )
    {
        fReturn = TRUE; // yep. NT Server alright.
    }

    if ( StrCmpI( szProductType, L"LanmanNT" ) == 0 )
    {
        fReturn = TRUE; // yep. NT Server alright.
    }

Error:
    RETURN(fReturn);
}

//
// WinMain()
//
int APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    TraceFunc( "WinMain( ... )\n" );

    HANDLE  hMutex;
    HRESULT hr = E_FAIL;
    WSADATA wsdata;
    LPWSTR pszCommandLine = GetCommandLine( );
    int     iReturn;

    g_hinstance = hInstance;

    INITIALIZE_TRACE_MEMORY_PROCESS;

    // allow only one instance running at a time
    hMutex = CreateMutex( NULL, TRUE, L"RemoteBootSetup.Mutext");
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        MessageBoxFromStrings( NULL,
                               IDS_ALREADY_RUNNING_TITLE,
                               IDS_ALREADY_RUNNING_MESSAGE,
                               MB_OK | MB_ICONSTOP );
        goto Cleanup;
    }

    CoInitialize(NULL);
    WSAStartup( 0x02, &wsdata );

    if( !pSetupIsUserAdmin()
     || !pSetupDoesUserHavePrivilege(SE_SHUTDOWN_NAME)
     || !pSetupDoesUserHavePrivilege(SE_BACKUP_NAME)
     || !pSetupDoesUserHavePrivilege(SE_RESTORE_NAME)
     || !pSetupDoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME)) {

        MessageBoxFromStrings( NULL, IDS_MUST_BE_ADMINISTRATOR_CAPTION, IDS_MUST_BE_ADMINISTRATOR_TEXT, MB_OK );
        goto Cleanup;
    }

    if ( !RunningOnNTServer( ) )
    {
        MessageBoxFromStrings( NULL, IDS_NOT_RUNNING_ON_NT_SERVER_CAPTION, IDS_NOT_RUNNING_ON_NT_SERVER_TEXT, MB_OK );
        goto Cleanup;
    }

    hr = InitializeOptions( );
    if ( FAILED(hr) )
        goto Cleanup;

    if( !ParseCommandLine( pszCommandLine )) {
        goto Cleanup;
    }

    // Change SetupAPI to Non-backup mode.
    // also set a flag that makes it fail all signature checks.
    // since we're subject to non-driver signing policy and that
    // is set to ignore by default, this means that every copy
    // operation will generate a signature warning in setupapi.log
    // ...but the memory footprint and speed of risetup process
    // will both go down significantly since we won't drag the
    // crypto libraries into the process.
    // 
    pSetupSetGlobalFlags( pSetupGetGlobalFlags( ) | PSPGF_NO_BACKUP | PSPGF_AUTOFAIL_VERIFIES );

    //
    // Go figure out a default for what processor we're
    // building an image for.
    //
    GetProcessorType();


    if ( !g_Options.fUpgrade && !g_Options.fAutomated )
    {
        hr = WizardPages( );
        if ( hr != S_OK ) {
            goto Cleanup;
        }

        hr = DoSetup( );
        if ( hr != S_OK ) {
            goto Cleanup;
        }

        CheckForReboot( );
    }
    else if ( g_Options.fAutomated )
    {
        if ( g_Options.fError ) {
            goto Cleanup;
        }

        hr = GetAutomatedOptions( );
        if ( hr != S_OK ) {
            goto Cleanup;
        }

        hr = FindImageSource( NULL );
        if ( hr != S_OK ) {
            MessageBoxFromStrings( NULL, IDS_FILE_NOT_FOUND_TITLE, IDS_FILE_NOT_FOUND_TEXT, MB_OK );
            goto Cleanup;
        }

        hr = CheckImageSource( NULL );
        if ( hr != S_OK ) {
            goto Cleanup;
        }

        hr = CheckInstallation( );
        if ( FAILED(hr) ) {
            goto Cleanup;
        }

        hr = DoSetup( );
        if ( hr != S_OK ) {
            goto Cleanup;
        }
    }
    else if ( g_Options.fUpgrade )
    {
        hr = UpdateRemoteInstallTree( );
    }
    else
    {
        AssertMsg( 0, "How did I get here?" );
    }

Cleanup:
    CoUninitialize();    
    if ( hMutex ) {
        CloseHandle( hMutex );
    }
    if ( g_Options.hinf != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( g_Options.hinf );
    }

    UNINITIALIZE_TRACE_MEMORY;

    RETURN(hr);
}

// stolen from the CRT, used to shrink our code
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();


    if ( *pszCmdLine == '\"' )
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else
    {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' '))
    {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never come here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\rbsetup.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: RBSETUP.H
 
 ***************************************************************************/


#ifndef _RBINSTAL_H_
#define _RBINSTAL_H_

#include <remboot.h>

// Global macros
//#define ARRAYSIZE( _x ) ( sizeof( _x ) / sizeof( _x[ 0 ] ) ) - in spapip.h for some reason

#define WM_STARTSETUP    WM_USER + 0x200
#define WM_STARTCHECKING WM_USER + 0x200

// Global structures
typedef struct {
    //
    // Directory Tree
    //
    BOOL    fIMirrorDirectory:1;                // szIntelliMirrorPath is valid
    BOOL    fIMirrorShareFound:1;               // the IMIRROR share was found
    BOOL    fDirectoryTreeExists:1;             // If true, skip creating directories
    BOOL    fNewOSDirectoryExists:1;            // the user selected a directory that already existed
    BOOL    fOSChooserDirectory:1;              // directory exists szOSChooserPath is valid
    BOOL    fOSChooserDirectoryTreeExists:1;    // directory tree RemBoot.INF's "[OSChooser Tree]" is valid
    // fLanguageSet hast to be TRUE for these to be checked
    BOOL    fOSChooserScreensDirectory:1;       // the Language subdir exists

    //
    // BINL Service
    //
    BOOL    fBINLServiceInstalled:1;            // Service Manager says BINLSVC is installed
    BOOL    fBINLFilesFound:1;                  // the BINLSVC files are in the System32 directory
    BOOL    fBINLSCPFound:1;                    // We found the IntelliMirror SCP in the DS

    //
    // TFTPD Service
    //
    BOOL    fTFTPDServiceInstalled:1;           // Service Manager says TFTPD is installed
    BOOL    fTFTPDFilesFound:1;                 // the TFTPD files are in the System32 directory
    BOOL    fTFTPDDirectoryFound:1;             // the RegKey is found and matches the szIntelliMirrorPath

    //
    // SIS Service
    //
    BOOL    fSISServiceInstalled:1;             // Service Manager says TFTPD is installed
    BOOL    fSISFilesFound:1;                   // the TFTPD files are in the System32\drivers directory
    BOOL    fSISVolumeCreated:1;                // the "SIS Common Store" directory exists

    //
    // SIS Groveler
    //
    BOOL    fSISGrovelerServiceInstalled:1;     // Service Single-Instance Storage Groveler installed
    BOOL    fSISGrovelerFilesFound:1;           // the Groveler files are in the System32 directory

    //
    // Dll Registration/Registry Operations
    //
    BOOL    fRegSrvDllsRegistered:1;            // All DLLs that are RegServered have been
    BOOL    fRegSrvDllsFilesFound:1;            // All DLLs that are RegServered are in the System32 directory
    BOOL    fRegistryIntact:1;                  // Registry modifications made during setup have been entered

    //
    // OS Chooser Installation
    //
    BOOL    fOSChooserInstalled:1;              // all expected files for all platforms are installed
    // fLanguageSet hast to be TRUE for these to be checked
    BOOL    fOSChooserScreens:1;                // all expected screen are installed (per language)
    BOOL    fScreenLeaveAlone:1;                // don't touch the screen files
    BOOL    fScreenOverwrite:1;                 // overwrite the screen files
    BOOL    fScreenSaveOld:1;                   // rename the old screen files before copying

    //
    // Version compatibility
    //
    BOOL    fServerCompatible:1;                // Server is compatible with client workstation

    //
    // Flow Flags
    //
    BOOL    fNewOS:1;                           // This is a new OS installation
    BOOL    fLanguageSet:1;                     // szLanguage is valid
    BOOL    fRemBootDirectory:1;                // szRemBootDirectory is valid and found
    BOOL    fProblemDetected:1;                 // Setup detected a problem with the server.
    BOOL    fRetrievedWorkstationString:1;      // If szWorkstation* have been set.
    BOOL    fCheckServer:1;                     // Force server check (command line -check)
    BOOL    fAddOption:1;                       // -add command line specified
    BOOL    fFirstTime:1;                       // First time this server ever ran RISETUP?
    BOOL    fUpgrade:1;                         // Running during OCM, no GUI, just do the CopyServerFiles()
    BOOL    fAlreadyChecked:1;                  // If CheckInstallation() has run once, this is set to TRUE.
    BOOL    fAutomated:1;                       // Using script to automated installation
	BOOL	fDontAuthorizeDhcp:1;				// Should we authorize DHCP
    BOOL    fLanguageOverRide:1;                // was a language override specified in unattend file?

    //
    // Results of installation
    //
    BOOL    fAbort:1;                           // user abort
    BOOL    fError:1;                           // fatal error occurred

    //
    // Platform
    //
    ULONG   ProcessorArchitecture;              // Which processor architecture are we building an image for?
    WCHAR   ProcessorArchitectureString[16];
    DWORD   dwWksCodePage;                      // The codepage of the image source

    //
    // INF
    //
    HINF    hinf;                               // Server's open REMBOOT.INF handle
    HINF    hinfAutomated;                      // Handle to the automated script INF

    //
    // Image Info
    //
    WCHAR   szMajorVersion[5];
    WCHAR   szMinorVersion[5];
    DWORD   dwBuildNumber;

    //
    // Paths
    //
    WCHAR   szIntelliMirrorPath[ 128 ];                 // X:\IntelliMirror
    WCHAR   szSourcePath[ MAX_PATH ];               // CD:\i386 or \\server\share
    WCHAR   szInstallationName[ REMOTE_INSTALL_MAX_DIRECTORY_CHAR_COUNT ]; // "nt50.wks" or whatever the user chooses
    WCHAR   szLanguage[ 32 ];                           // "English" or a Language string
    WCHAR   szWorkstationRemBootInfPath[ MAX_PATH ];
    WCHAR   szWorkstationDiscName[ 128 ];               // "Windows NT Workstation 5.0"
    WCHAR   szWorkstationSubDir[ 32 ];                  // "\i386" or "\ia64" or ...
    WCHAR   szWorkstationTagFile[ MAX_PATH ];           // "\cdrom_i.5b2" or something similiar
    WCHAR   szTFTPDDirectory[ 128 ];                    // where TFTPD thinks the IntelliMirror directory is
    WCHAR   szRemBootDirectory[ MAX_PATH - (1+8+1+3)];  // %windir%\system32\remboot\ 

    //
    // SIF file stuff
    //
    WCHAR   szDescription[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT ];
    WCHAR   szHelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ];

    //
    // Generated path to be re-used
    //
    WCHAR   szInstallationPath[ MAX_PATH ];             // X:\IntelliMirror\Setup\<Lang>\Images\<Install>
    WCHAR   szOSChooserPath[ MAX_PATH ];                // X:\IntelliMirror\OSChooser

} OPTIONS, *LPOPTIONS;

// Globals
extern HINSTANCE g_hinstance;
extern OPTIONS g_Options;

#endif // _RBINSTAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\utils.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _UTILS_H_
#define _UTILS_H_

void 
CenterDialog( 
    HWND hwndDlg );

void 
ClearMessageQueue( void );

int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType );

void
MessageBoxFromError(
    HWND hParent,
    LPTSTR pszTitle,
    DWORD dwErr );

void
ErrorBox(
    HWND hParent,
    LPTSTR pszTitle );

//
// Enum for SetDialogFont().
//
typedef enum {
    DlgFontTitle,
    DlgFontBold
} MyDlgFont;


VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    );

void 
DrawBitmap( 
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis,
    LPRECT prc );

BOOL 
VerifyCancel( 
    HWND hParent );

HRESULT 
CheckImageSource( 
    HWND hDlg );

HRESULT
CheckIntelliMirrorDrive( 
    HWND hDlg );

VOID
ConcatenatePaths( 
    IN OUT LPWSTR Path1,
    IN LPCWSTR Path2 );



HRESULT
FindImageSource(
    HWND hDlg );

HRESULT
GetHelpAndDescriptionTextFromSif(
    OUT PWSTR HelpText,
    IN  DWORD HelpTextSizeInChars,
    OUT PWSTR DescriptionText,
    IN  DWORD DescriptionTextSizeInChars
    );

HRESULT
GetSetRanFlag(
    BOOL bQuery,
    BOOL bClear
    );

VOID
GetProcessorType(
    );

class CWaitCursor
{
private:
    HCURSOR _hOldCursor;

public:
    CWaitCursor( ) { _hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) ); };
    ~CWaitCursor( ) { SetCursor( _hOldCursor ); };
};

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\setup.cpp ===
/************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#include "pch.h"

#include <aclapip.h>
#include <winldap.h>
#include "check.h"
#include "dialogs.h"
#include "setup.h"
#include "check.h"

DEFINE_MODULE( "Setup" );

#ifdef SMALL_BUFFER_SIZE
#undef SMALL_BUFFER_SIZE
#endif

#define SMALL_BUFFER_SIZE   512
#define MAX_FILES_SIZE      1920000
#define BIG_BUFFER          4096
#define MACHINENAME_SIZE    32

static const WCHAR chSlash = TEXT('\\');
typedef LONGLONG INDEX;

SCPDATA scpdata[] = {
    { L"netbootAllowNewClients",           L"TRUE" },
    { L"netbootLimitClients",              L"FALSE" },
    { L"netbootCurrentClientCount",        L"0" },
    { L"netbootMaxClients",                L"100" },
    { L"netbootAnswerRequests",            L"TRUE" },
    { L"netbootAnswerOnlyValidClients",    L"FALSE" },
    { L"netbootNewMachineNamingPolicy",    L"%61Username%#" },
    { L"netbootNewMachineOU",              NULL },
    { L"netbootServer",                    NULL }

};

#define MACHINEOU_INDEX       7
#define NETBOOTSERVER_INDEX   8


#define BINL_PARAMETERS_KEY       L"System\\CurrentControlSet\\Services\\Binlsvc\\Parameters"


PCWSTR
SetupExtensionFromProcessorTag(
    PCWSTR ProcessorTag
    )
{
    if (wcscmp(ProcessorTag,L"i386")==0) {
        return(L"x86");
    } else {
        return(ProcessorTag);
    }
}



//
// KeepUIAlive( )
//
BOOL
KeepUIAlive(
    HWND hDlg )
{
    MSG Msg;
    //
    // process messages to keep UI alive
    //
    while ( PeekMessage( &Msg, NULL, 0, 0, PM_REMOVE ) )
    {
        TranslateMessage( &Msg );
        DispatchMessage( &Msg );
        if ( hDlg != NULL && Msg.message == WM_KEYUP && Msg.wParam == VK_ESCAPE ) {
            VerifyCancel( hDlg );
        }
    }

    return( g_Options.fError || g_Options.fAbort );
}

//
// CreateSCP( )
//
HRESULT
CreateSCP( 
    HWND hDlg
    )
/*++

Routine Description:

    Creates SCP information so that BINL can create the SCP when it starts up.

Arguments:

    hDlg - dialog window handle for putting up error messages.

Return Value:

    HRESULT indicating outcome.
    
--*/
{
    TraceFunc( "CreateSCP( )\n" );

    HRESULT hr;
    ULONG  ulSize;
    LPWSTR pszMachinePath = NULL;
   
    DWORD i,Err;
    HKEY hKey = 0;
    DWORD DontCare;

    Err = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    BINL_PARAMETERS_KEY,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_SET_VALUE,
                    NULL,
                    &hKey,
                    &DontCare);

    if (Err != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32( Err );
        goto e0;
    }
    
    
    if ( !GetComputerObjectName( NameFullyQualifiedDN, NULL, &ulSize )) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto e1;
    }

    pszMachinePath = (LPWSTR) TraceAlloc( LPTR, ulSize * sizeof(WCHAR) );
    if ( !pszMachinePath ) {
        hr = THR( E_OUTOFMEMORY );
        goto e1;
    }

    if ( !GetComputerObjectName( NameFullyQualifiedDN, pszMachinePath, &ulSize )) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto e2;
    }
        
    
    scpdata[MACHINEOU_INDEX].pszValue = pszMachinePath;
    scpdata[NETBOOTSERVER_INDEX].pszValue = pszMachinePath;

    //
    // Add default attribute values
    //
    for( i = 0; i < ARRAYSIZE(scpdata); i++ )
    {
        Err = RegSetValueEx( 
                    hKey, 
                    scpdata[i].pszAttribute, 
                    NULL, 
                    REG_SZ, 
                    (LPBYTE)scpdata[i].pszValue, 
                    (wcslen(scpdata[i].pszValue)+1)*sizeof(WCHAR) );

        if (Err != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32( Err );
            goto e3;
        }
    }


    hr = S_OK;

    Err = 0;

    RegSetValueEx( 
                hKey, 
                L"ScpCreated", 
                NULL, 
                REG_DWORD, 
                (LPBYTE)&Err, 
                sizeof(DWORD) );

e3:

    if (FAILED(hr)) {
        for( i = 0; i < ARRAYSIZE(scpdata); i++ ) {
            RegDeleteValue( 
                        hKey, 
                        scpdata[i].pszAttribute );
        }        
    } 

e2:
    TraceFree( pszMachinePath );    
e1:
    RegCloseKey(hKey);
e0:

    if ( FAILED(hr)) {
        MessageBoxFromStrings( hDlg, IDS_SCPCREATIONFAIL_CAPTION, IDS_SCPCREATIONFAIL_TEXT, MB_OK );
        ErrorMsg( "Error 0x%08x occurred.\n", hr );
    }    
    
    HRETURN(hr);
}

PWSTR
GenerateCompressedName(
    IN PCWSTR Filename
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

    Look backwards for a dot.  If there is no dot, append "._" to the name.
    If there is a dot followed by 0, 1, or 2 charcaters, append "_".
    Otherwise there is a 3-character or greater extension and we replace
    the last character with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

Return Value:

    Pointer to buffer containing nul-terminated compressed-form filename.
    The caller must free this buffer via TraceFree().

--*/

{
    PWSTR CompressedName,p,q;
    UINT u;

    //
    // The maximum length of the compressed filename is the length of the
    // original name plus 2 (for ._).
    //
    if(CompressedName = (PWSTR)TraceAlloc(LPTR, (wcslen(Filename)+3)*sizeof(WCHAR))) {

        wcscpy(CompressedName,Filename);

        p = wcsrchr(CompressedName,L'.');
        q = wcsrchr(CompressedName,L'\\');
        if(q < p) {

            //
            // If there are 0, 1, or 2 characters after the dot, just append
            // the underscore.  p points to the dot so include that in the length.
            //
            u = wcslen(p);
            if(u < 4) {
                wcscat(CompressedName,L"_");
            } else {
                //
                // There are at least 3 characters in the extension.
                // Replace the final one with an underscore.
                //
                p[u-1] = L'_';
            }
        } else {
            //
            // No dot, just add ._.
            //
            wcscat(CompressedName,L"._");
        }
    }

    return(CompressedName);
}


BOOL
IsFileOrCompressedVersionPresent(
    LPCWSTR FilePath,
    PWSTR *pCompressedName OPTIONAL
    ) 
/*++

Routine Description:

    Check if a file or a compressed version of it is present at the
    specified location.
        

Arguments:

    FilePath       - fully qualified path to the file to check for.
    pCompressedName - if the file is compressed, this can receive the compressed
                     name

Return Value:

    TRUE indicats the file or a compressed copy of it is present.
    
--*/
{
    BOOL FileIsPresent = FALSE, IsCompressed = FALSE;
    WCHAR ActualName[MAX_PATH];
    PWSTR p;


    wcscpy( ActualName, FilePath) ;

    if (0xFFFFFFFF != GetFileAttributes( ActualName )) {
        FileIsPresent = TRUE;
    } else {
        //
        // the file isn't present, so try generating the compressed name
        //
        p = GenerateCompressedName( ActualName );
        if (p) {
            wcscpy( ActualName, p );
            TraceFree( p );
            p = NULL;
                
            if (0xFFFFFFFF != GetFileAttributes( ActualName )) {
                IsCompressed = TRUE;
                FileIsPresent = TRUE;
            }
        }
        
    }

    if (FileIsPresent && IsCompressed && pCompressedName) {
        *pCompressedName = (PWSTR)TraceAlloc( LPTR, (wcslen(ActualName)+1) * sizeof(WCHAR));
        if (*pCompressedName) {
            wcscpy( *pCompressedName, ActualName) ;
        }
    }

    return( FileIsPresent == TRUE);

} 


//
// Builds the pathes used for installation
//
HRESULT
BuildDirectories( void )
{
    TraceFunc( "BuildDirectories( void )\n" );


    //
    // Create
    // "D:\IntelliMirror\Setup\English\Images\nt50.wks"
    //
    wcscpy( g_Options.szInstallationPath, g_Options.szIntelliMirrorPath );
    ConcatenatePaths( g_Options.szInstallationPath, L"\\Setup" );
    ConcatenatePaths( g_Options.szInstallationPath, g_Options.szLanguage );
    ConcatenatePaths( g_Options.szInstallationPath, REMOTE_INSTALL_IMAGE_DIR_W );
    ConcatenatePaths( g_Options.szInstallationPath, g_Options.szInstallationName );
    //ConcatenatePaths( g_Options.szInstallationPath, g_Options.ProcessorArchitectureString );
    Assert( wcslen(g_Options.szInstallationPath) < ARRAYSIZE(g_Options.szInstallationPath) );

    HRETURN(S_OK);
}

//
// Creates the IntelliMirror directory tree.
//
HRESULT
CreateDirectoryPath(
    HWND hDlg,
    LPWSTR DirectoryPath,
    PSECURITY_ATTRIBUTES SecurityAttributes,
    BOOL fAllowExisting
    )
{
    PWCHAR p, pBackslash;
    BOOL f;
    DWORD attributes;

    //
    // Find the \ that indicates the root directory. There should be at least
    // one \, but if there isn't, we just fall through.
    //

    p = wcschr( DirectoryPath, L'\\' );
    if ( p != NULL ) {

        //
        // Find the \ that indicates the end of the first level directory. It's
        // probable that there won't be another \, in which case we just fall
        // through to creating the entire path.
        //

        p = wcschr( p + 1, L'\\' );
        while ( p != NULL ) {

            //
            // Skip multiple \ that appear together.
            //
            pBackslash = p;
            ++p;
            while (*p == L'\\') {
                ++p;
            }
            if (*p == 0) {

                //
                // These \ are all at the end of the string, so we can
                // proceed to the creation of the leaf directory.
                //

                break;
            }

            //
            // Terminate the directory path at the current level.
            //

            *pBackslash = 0;

            //
            // Create a directory at the current level.
            //

            attributes = GetFileAttributes( DirectoryPath );
            if ( 0xFFFFffff == attributes ) {
                f = CreateDirectory( DirectoryPath, NULL );
                if ( !f ) {
                    if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
                        ErrorBox( hDlg, DirectoryPath );
                        HRETURN(E_FAIL);
                    }
                }
            } else if ( (attributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
                MessageBoxFromError( hDlg, DirectoryPath, ERROR_DIRECTORY );
                HRETURN(E_FAIL);
            }

            //
            // Restore the \ and find the next one.
            //

            *pBackslash = L'\\';
            p = wcschr( p, L'\\' );
        }
    }

    //
    // Create the target directory.
    //

    f = CreateDirectory( DirectoryPath, SecurityAttributes );
    if ( !f && (!fAllowExisting || (GetLastError() != ERROR_ALREADY_EXISTS)) ) {
        ErrorBox( hDlg, DirectoryPath );
        HRETURN(E_FAIL);
    }

    HRETURN(NO_ERROR);
}

//
// Creates the IntelliMirror directory tree.
//
HRESULT
CreateDirectories( HWND hDlg )
{
    HRESULT hr = S_OK;
    WCHAR szPath[ MAX_PATH ];
    WCHAR szCreating[ SMALL_BUFFER_SIZE ];
    HWND  hProg = GetDlgItem( hDlg, IDC_P_METER );
    DWORD dwLen;
    DWORD dw;
    BOOL  f;
    LPARAM lRange;
    PACL pAcl = NULL;
    SECURITY_DESCRIPTOR SecDescriptor;
    PSECURITY_DESCRIPTOR pSecDescriptor = &SecDescriptor;
    PSID pWorldSid = NULL;
    PSID pAdminsSid = NULL;
    DWORD attributes;

    TraceFunc( "CreateDirectories( hDlg )\n" );

    lRange = MAKELPARAM( 0 , 0
        + ( g_Options.fIMirrorShareFound    ? 0 : 1 )
        + ( g_Options.fDirectoryTreeExists  ? 0 : 7 )
        + ( g_Options.fOSChooserInstalled   ? 0 : 1 )
        + ( g_Options.fNewOSDirectoryExists ? 0 : 1 )
        + ( g_Options.fOSChooserScreensDirectory ? 0 : (g_Options.fLanguageSet ? 1 : 0 ) ) );

    SendMessage( hProg, PBM_SETRANGE, 0, lRange );
    SendMessage( hProg, PBM_SETSTEP, 1, 0 );

    dw = LoadString( g_hinstance, IDS_CREATINGDIRECTORIES, szCreating, ARRAYSIZE(szCreating));
    Assert( dw );
    SetWindowText( GetDlgItem( hDlg, IDC_S_OPERATION ), szCreating );

    if ( !g_Options.fDirectoryTreeExists ) {
        attributes = GetFileAttributes( g_Options.szIntelliMirrorPath );
        if ( 0xFFFFffff == attributes ) {
            EXPLICIT_ACCESS ExplicitEntries[2];
            SECURITY_ATTRIBUTES sa;
            SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;
            SID_IDENTIFIER_AUTHORITY worldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

            //
            // build AccessEntry structure
            //
            ZeroMemory( ExplicitEntries, sizeof(ExplicitEntries) );

            f = AllocateAndInitializeSid(
                    &ntSidAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAdminsSid );
            if ( !f || (pAdminsSid == NULL) ) {
                dw = GetLastError();
                MessageBoxFromError( hDlg, NULL, dw );
                hr = HRESULT_FROM_WIN32(dw);
                goto Error;
            }
            BuildTrusteeWithSid( &ExplicitEntries[0].Trustee, pAdminsSid );
            ExplicitEntries[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ExplicitEntries[0].grfAccessMode = SET_ACCESS;
            ExplicitEntries[0].grfAccessPermissions = FILE_ALL_ACCESS;

            f = AllocateAndInitializeSid(
                    &worldSidAuthority,
                    1,
                    SECURITY_WORLD_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pWorldSid );
            if ( !f || (pAdminsSid == NULL) ) {
                dw = GetLastError();
                MessageBoxFromError( hDlg, NULL, dw );
                hr = HRESULT_FROM_WIN32(dw);
                goto Error;
            }
            BuildTrusteeWithSid( &ExplicitEntries[1].Trustee, pWorldSid );
            ExplicitEntries[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ExplicitEntries[1].grfAccessMode = SET_ACCESS;
            ExplicitEntries[1].grfAccessPermissions = FILE_GENERIC_READ | FILE_GENERIC_EXECUTE;

            //
            // Set the Acl with the ExplicitEntry rights
            //
            dw = SetEntriesInAcl( 2,
                                  ExplicitEntries,
                                  NULL,
                                  &pAcl );
            if ( dw != ERROR_SUCCESS ) {
                MessageBoxFromError( hDlg, NULL, dw );
                hr = HRESULT_FROM_WIN32(dw);
                goto Error;
            }

            //
            // Create the Security Descriptor
            //
            InitializeSecurityDescriptor( pSecDescriptor, SECURITY_DESCRIPTOR_REVISION );

            if (!SetSecurityDescriptorDacl( pSecDescriptor, TRUE, pAcl, FALSE )) {
                dw = GetLastError();
            }

            if ( dw != ERROR_SUCCESS ) {
                MessageBoxFromError( hDlg, NULL, dw );
                hr = HRESULT_FROM_WIN32(dw);
                goto Error;
            }

            //
            // Create the Security Attributes structure
            //
            sa.nLength = sizeof(SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSecDescriptor;
            sa.bInheritHandle = TRUE;

            //
            // Create
            // "D:\IntelliMirror"
            //
            hr = CreateDirectoryPath( hDlg, g_Options.szIntelliMirrorPath, &sa, FALSE );
            if ( hr != NO_ERROR ) {
                goto Error;
            }

        } else if ( (attributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
            MessageBoxFromError( hDlg, g_Options.szIntelliMirrorPath, ERROR_DIRECTORY );
            hr = E_FAIL;
            goto Error;
        }

        // Prevent the index server from indexing the IntelliMirror directory.
        attributes = GetFileAttributes( g_Options.szIntelliMirrorPath );
        attributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
        f = SetFileAttributes( g_Options.szIntelliMirrorPath, attributes );
        if ( !f ) {
            ErrorBox( hDlg, g_Options.szIntelliMirrorPath );
            hr = THR(S_FALSE);
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );

#if 0
        //
        // Create
        // "D:\IntelliMirror\Clients"
        //
        wcscpy( szPath, g_Options.szIntelliMirrorPath );
        ConcatenatePaths( szPath, L"\\Clients" );
        Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
        if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
            f = CreateDirectory( szPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, szPath );
                hr = THR(S_FALSE);
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
#endif

        //
        // Create
        // "D:\IntelliMirror\Setup"
        //
        wcscpy( szPath, g_Options.szIntelliMirrorPath );
        ConcatenatePaths( szPath, L"\\Setup" );
        Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
        if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
            f = CreateDirectory( szPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, szPath );
                hr = THR(S_FALSE);
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );

        //
        // Create
        // "D:\IntelliMirror\Setup\English"
        //
        wcscpy( szPath, g_Options.szIntelliMirrorPath );
        ConcatenatePaths( szPath, L"\\Setup" );
        ConcatenatePaths( szPath, g_Options.szLanguage );
        Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
        if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
            f = CreateDirectory( szPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, szPath );
                hr = THR(S_FALSE);
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );

#if 0
        //
        // Create
        // "D:\IntelliMirror\Setup\English\Tools"
        //
        wcscpy( szPath, g_Options.szIntelliMirrorPath );
        ConcatenatePaths( szPath, L"\\Setup" );
        ConcatenatePaths( szPath, g_Options.szLanguage );
        ConcatenatePaths( szPath, L"\\Tools" );
        Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
        if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
            f = CreateDirectory( szPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, szPath );
                hr = THR(S_FALSE);
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
#endif

        //
        // Create
        // "D:\IntelliMirror\Setup\English\Images"
        //
        wcscpy( szPath, g_Options.szIntelliMirrorPath );
        ConcatenatePaths( szPath, L"\\Setup" );
        ConcatenatePaths( szPath, g_Options.szLanguage );
        ConcatenatePaths( szPath, REMOTE_INSTALL_IMAGE_DIR_W );
        Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
        if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
            f = CreateDirectory( szPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, szPath );
                hr = THR(S_FALSE);
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
    }

    if ( !g_Options.fNewOSDirectoryExists
       && g_Options.fNewOS ) {
        //
        // Create
        // "D:\IntelliMirror\Setup\English\Images\nt50.wks"
        /// by removing the "\i386" from the end.
        //
        DWORD  dwLen = lstrlen( g_Options.szInstallationPath );
#if 0
        LPWSTR psz = StrRChr( g_Options.szInstallationPath, &g_Options.szInstallationPath[dwLen], L'\\' );

        if (psz == NULL) {
            
            Assert( psz );
            SetLastError(ERROR_BAD_NETPATH);
            ErrorBox( hDlg, g_Options.szInstallationPath );
            hr = THR(S_FALSE);

        } else {

            *psz = L'\0'; // terminate
            if ( 0xFFFFffff == GetFileAttributes( g_Options.szInstallationPath ) ) {
                f = CreateDirectory( g_Options.szInstallationPath, NULL );
                if ( !f ) {
                    ErrorBox( hDlg, g_Options.szInstallationPath );
                    hr = THR(S_FALSE);
                }
            }
            *psz = L'\\'; // restore

        }
#endif
        

        //
        // Create
        // "D:\IntelliMirror\Setup\English\Images\nt50.wks\i386"
        //
        if ( 0xFFFFffff == GetFileAttributes( g_Options.szInstallationPath ) ) {
            f = CreateDirectory( g_Options.szInstallationPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, g_Options.szInstallationPath );
                hr = THR(S_FALSE);
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
    }

    if ( !g_Options.fOSChooserDirectory ) {
        //
        // Create the OS Chooser tree
        // "D:\IntelliMirror\OSChooser"
        //
        wcscpy( g_Options.szOSChooserPath, g_Options.szIntelliMirrorPath );
        ConcatenatePaths( g_Options.szOSChooserPath, L"\\OSChooser" );
        Assert( wcslen(g_Options.szOSChooserPath) < ARRAYSIZE(g_Options.szOSChooserPath) );
        if ( 0xFFFFffff == GetFileAttributes( g_Options.szOSChooserPath ) ) {
            f = CreateDirectory( g_Options.szOSChooserPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, g_Options.szOSChooserPath );
                hr = THR(E_FAIL);
                goto Error;
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
    }

    if ( g_Options.hinf != INVALID_HANDLE_VALUE
      && !g_Options.fOSChooserDirectoryTreeExists ) {
        WCHAR szFile[ MAX_PATH ];
        BOOL fFound;
        INFCONTEXT context;

        fFound = SetupFindFirstLine( g_Options.hinf, L"OSChooser", NULL, &context );
        AssertMsg( fFound, "Could not find 'OSChooser' section in REMINST.INF.\n" );

        while ( fFound
             && SetupGetStringField( &context, 1, szFile, ARRAYSIZE(szFile), NULL ) )
        {
            WCHAR szPath[ MAX_PATH ];
            DWORD dwLen = lstrlen( szFile );
            LPWSTR psz = StrRChr( szFile, &szFile[ dwLen ], L'\\' );
            if ( psz ) {
                *psz = L'\0';       // terminate
                wsprintf( szPath,
                          L"%s\\%s",
                          g_Options.szOSChooserPath,
                          szFile );
                Assert( wcslen(szPath) < ARRAYSIZE(szPath) );

                if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                    HRESULT hr2;
                    hr2 = CreateDirectoryPath( hDlg, szPath, NULL, TRUE );
                    if ( FAILED ( hr2 )) {
                        hr = hr2;
                    }
                }
            }

            fFound = SetupFindNextLine( &context, &context );
        }
    }
    if ( FAILED( hr )) goto Error;

    if ( !g_Options.fOSChooserScreensDirectory
      && g_Options.fLanguageSet ) {
        //
        // Create
        // "D:\IntelliMirror\OSChooser\English"
        //
        wcscpy( szPath, g_Options.szIntelliMirrorPath );
        ConcatenatePaths( szPath, L"\\OSChooser" );
        ConcatenatePaths( szPath, g_Options.szLanguage );
        Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
        if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
            f = CreateDirectory( szPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, szPath );
                hr = THR(E_FAIL);    // major error
                goto Error;
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
    }

    // do this last
    if ( !g_Options.fIMirrorShareFound ) {
        //
        // Add the share
        //
        hr = CreateRemoteBootShare( hDlg );

        SendMessage( hProg, PBM_SETPOS, 1 , 0 );
    }

Error:
    if ( pWorldSid ) {
        FreeSid( pWorldSid );
    }
    if ( pAdminsSid ) {
        FreeSid( pAdminsSid );
    }
    if ( pAcl ) {
        TraceFree( pAcl );
    }

    HRETURN(hr);
}


//
// Find the filename part from a complete path.
//
LPWSTR FilenameOnly( LPWSTR pszPath )
{
    LPWSTR psz = pszPath;

    // find the end
    while ( *psz )
        psz++;

    // find the slash
    while ( psz > pszPath && *psz != chSlash )
        psz--;

    // move in front of the slash
    if ( psz != pszPath )
        psz++;

    return psz;
}

//
// Private structure containing information that the CopyFilesCallback()
// needs.
//
typedef struct {
    PVOID pContext;                             // "Context" for DefaultQueueCallback
    HWND  hProg;                                // hwnd to the progress meter
    HWND  hOperation;                           // hwnd to the "current operation"
    DWORD nCopied;                              // number of files copied
    DWORD nToBeCopied;                          // number of file to be copied
    DWORD dwCopyingLength;                      // length of the IDS_COPYING
    WCHAR szCopyingString[ SMALL_BUFFER_SIZE ]; // buffer to create "Copying file.ext..."
    BOOL  fQuiet;                               // do things quietly
    HWND  hDlg;                                 // hwnd to the Tasks Dialog
} MYCONTEXT, *LPMYCONTEXT;

//
// Callback that the SETUP APIs calls. It handles updating the
// progress meters as well as UI updating. Any messages not
// handled are passed to the default SETUP callback.
//
UINT CALLBACK
CopyFilesCallback(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    LPMYCONTEXT pMyContext = (LPMYCONTEXT) Context;

    KeepUIAlive( pMyContext->hDlg );

    if ( g_Options.fAbort )
    {
        if ( !g_Options.fError )
        {
            WCHAR    szAbort[ SMALL_BUFFER_SIZE ];

            // change filename text to aborting...
            DWORD dw = LoadString( g_hinstance, IDS_ABORTING, szAbort, ARRAYSIZE(szAbort) );
            Assert( dw );
            SetWindowText( pMyContext->hOperation, szAbort );

            g_Options.fError = TRUE;
        }

        if ( g_Options.fError ) {
            SetLastError(ERROR_CANCELLED);
            return FILEOP_ABORT;
        }
    }

    switch ( Notification )
    {
    case SPFILENOTIFY_ENDCOPY:
        if ( !(pMyContext->fQuiet) ) {
            pMyContext->nCopied++;
            SendMessage( pMyContext->hProg, PBM_SETPOS,
                (5000 * pMyContext->nCopied) / pMyContext->nToBeCopied, 0 );
        }
        break;

    case SPFILENOTIFY_STARTCOPY:
        if ( !(pMyContext->fQuiet) ) {
            DWORD    dwLen;
            LPWSTR * ppszCopyingFile = (LPWSTR *) Param1;

            lstrcpy( &pMyContext->szCopyingString[ pMyContext->dwCopyingLength ],
                FilenameOnly( *ppszCopyingFile ) );
            dwLen = lstrlen( pMyContext->szCopyingString );
            lstrcpy( &pMyContext->szCopyingString[ dwLen ], L"..." );

            SetWindowText( pMyContext->hOperation, pMyContext->szCopyingString );
        }
        break;

    case SPFILENOTIFY_LANGMISMATCH:
    case SPFILENOTIFY_TARGETEXISTS:
    case SPFILENOTIFY_TARGETNEWER:
        if ( !pMyContext->fQuiet )
        {
            UINT u = SetupDefaultQueueCallback( pMyContext->pContext, Notification, Param1, Param2 );
            return u;
        }
        break;

    case SPFILENOTIFY_RENAMEERROR:
    case SPFILENOTIFY_DELETEERROR:
    case SPFILENOTIFY_COPYERROR:
        {
            
            FILEPATHS *fp = (FILEPATHS *) Param1;
            Assert( fp->Win32Error != ERROR_FILE_NOT_FOUND );  // Malformed DRIVERS.CAB file 
            
            if ( fp->Win32Error == ERROR_FILE_NOT_FOUND )
                return FILEOP_SKIP;

        }

    case SPFILENOTIFY_NEEDMEDIA:
        UINT u = SetupDefaultQueueCallback( pMyContext->pContext, Notification, Param1, Param2 );
        if ( u == FILEOP_ABORT )
        {
            g_Options.fAbort = g_Options.fError = TRUE;
        }
        return u;

    }

    return FILEOP_DOIT;
}

//
// CopyInfSection( )
//
HRESULT
CopyInfSection(
    HSPFILEQ Queue,
    HINF     hinf,
    LPCWSTR  pszSection,
    LPCWSTR  pszSourcePath,
    LPCWSTR  pszSubPath, OPTIONAL
    LPCWSTR  pszDescName,
    LPCWSTR  pszTagFile,
    LPCWSTR  pszDestinationRoot,
    LPDWORD  pdwCount )

/*++

Routine Description:

    queues up files from the specified section to be installed into the
    remote install directory.

Arguments:

    Queue      - queue handle to queue the copy operations to.
    hinf       - handle to inf which specifies the list of files to be copied
    pszSection - section listing files to be copied
    pszSourcePath - specifies the base source path,where the files may 
                 be found on the *source* media
    pszSubPath - specifies the subdirectory, if any, where the files may 
                 be found on the *source* media
    pszDescName- user printable description of the media where this file is
                  located.  this may be used when the queue is committed.
    pszTagFile - specifies the tag file that is to uniquely describe the media
                 where these files are located
    pszDestinationRoot - specifies the root location where files are to be 
                        copied to
    pdwCount   - specifies the number of files that were queued from this 
                 section on return.  if the function fails, this value is
                 undefined.    

Return Value:

    An HRESULT indicating the outcome.

--*/
{
    HRESULT hr = S_OK;
    INFCONTEXT context;
    BOOL b;

    TraceFunc( "CopyInfSection( ... )\n" );

    //
    // make sure the section we're looking for exists.  
    // We'll use this context to enumerate the files in the section
    //
    b = SetupFindFirstLine( hinf, pszSection, NULL, &context );
    AssertMsg( b, "Missing section?" );
    if ( !b ) {
        hr = S_FALSE;
    }

    while ( b )
    {
        LPWSTR pszDestRename = NULL;
        WCHAR  szDestPath[ MAX_PATH ],szRename[100];;
        WCHAR  szSrcName[ 64 ];
        DWORD  dw;

        KeepUIAlive( NULL );

        wcscpy(szDestPath, pszSubPath );

        dw = SetupGetFieldCount( &context );

        if ( dw > 1 ) {     
            //
            // first field is the destination name.
            // we overload this field to also contain a subdirectory where
            // the files should be placed as well
            //
            b = SetupGetStringField( 
                            &context,
                            1, 
                            szRename, 
                            ARRAYSIZE( szRename ), 
                            NULL );
            AssertMsg( b, "Missing field?" );
            if ( b ) {
                //
                // 2nd field is the actual source filename
                //
                b = SetupGetStringField( 
                                &context, 
                                2, 
                                szSrcName, 
                                ARRAYSIZE(szSrcName), 
                                NULL );
                AssertMsg( b, "Missing field?" );
                pszDestRename = szRename;
            }
        } else {
            //
            // if there's only one field, this is the actual source name.  the 
            // destination name will be the same as the source name.
            //
            b = SetupGetStringField( 
                            &context, 
                            1, 
                            szSrcName, 
                            ARRAYSIZE(szSrcName),
                            NULL );
            AssertMsg( b, "Missing field?" );
            
        }

        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        ConcatenatePaths( 
                    szDestPath, 
                    pszDestRename 
                     ? pszDestRename
                     : szSrcName );

        //
        // all files are installed into the 
        //
        b = SetupQueueCopy( Queue,
                            pszSourcePath,
                            pszSubPath,
                            szSrcName,
                            pszDescName,
                            pszTagFile,
                            pszDestinationRoot,
                            szDestPath,
                            SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER
                            | SP_COPY_WARNIFSKIP | SP_COPY_SOURCE_ABSOLUTE );
        if ( !b ) {
            ErrorBox( NULL, szSrcName );
            hr = THR(S_FALSE);
            goto SkipIt;
        }

        // increment file count
        (*pdwCount)++;

SkipIt:
        b = SetupFindNextLine( &context, &context );
    }

    HRETURN(hr);
}

typedef struct _EXPANDCABLISTPARAMS {
    HWND     hDlg;
    HINF     hinf;
    LPCWSTR  pszSection;
    LPCWSTR  pszSourcePath;
    LPCWSTR  pszDestPath;
    LPCWSTR  pszSubDir;
} EXPANDCABLISTPARAMS, *PEXPANDCABLISTPARAMS;


//
// ExpandCabList( )
//
DWORD WINAPI
ExpandCabList( LPVOID lpVoid )
{
    PEXPANDCABLISTPARAMS pParams = (PEXPANDCABLISTPARAMS) lpVoid;
    HRESULT hr = S_OK;
    INFCONTEXT context;
    WCHAR   TempDstPath[MAX_PATH];
    WCHAR   TempSrcPath[MAX_PATH];
    BOOL b;

    TraceFunc( "ExpandCabList( ... )\n" );

    // First make sure the DestPath exists, since we may call this
    // before we commit the setup copy queue.

    Assert( pParams->pszSection );
    Assert( pParams->pszSourcePath );
    Assert( pParams->pszDestPath );
    Assert( pParams->pszSubDir );

    DebugMsg( "Expand section %s from %s to %s\n",
              pParams->pszSection,
              pParams->pszSourcePath,
              pParams->pszDestPath );

    wcscpy( TempDstPath, pParams->pszDestPath);
    ConcatenatePaths( TempDstPath, pParams->pszSubDir );
    hr = CreateDirectoryPath( pParams->hDlg, TempDstPath, NULL, TRUE );
    if ( hr ) {
        HRETURN(hr);
    }

    wcscpy( TempSrcPath, pParams->pszSourcePath );
    ConcatenatePaths( TempSrcPath, pParams->pszSubDir );

    b = SetupFindFirstLine( pParams->hinf, pParams->pszSection, NULL, &context );
    AssertMsg( b, "Missing section?" );
    if ( !b ) {
        hr = S_FALSE;
    }

    while ( b && !g_Options.fError && !g_Options.fAbort )
    {
        LPWSTR pszDest = NULL;
        WCHAR wszCabName[ MAX_PATH ];
        CHAR szCabPath[ MAX_PATH ];
        CHAR szDestPath[ MAX_PATH ];
        DWORD dwSourcePathLen;

        b = SetupGetStringField( &context, 1, wszCabName, ARRAYSIZE(wszCabName), NULL );
        AssertMsg( b, "Missing field?" );
        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        // szCabPath is pszSourcePath\wszCabName, in ANSI

        dwSourcePathLen = wcslen(TempSrcPath);
        wcstombs( szCabPath, TempSrcPath, dwSourcePathLen );
        if (szCabPath[dwSourcePathLen-1] != '\\') {
            szCabPath[dwSourcePathLen] = '\\';
            ++dwSourcePathLen;
        }
        wcstombs( &szCabPath[dwSourcePathLen], wszCabName, wcslen(wszCabName)+1 );

        wcstombs( szDestPath, TempDstPath, wcslen(TempDstPath)+1 );

        hr = ExtractFiles( szCabPath, szDestPath, 0, NULL, NULL, 0 );

        if ( hr ) {
            ErrorBox( pParams->hDlg, wszCabName );
            goto SkipIt;
        }

SkipIt:
        b = SetupFindNextLine( &context, &context );
    }

    HRETURN(hr);
}

//
// RecursiveCopySubDirectory
//
HRESULT
RecursiveCopySubDirectory(
    HSPFILEQ Queue,         // Setup queue
    LPWSTR pszSrcDir,       // points to a buffer MAX_PATH big and contains the source dir to recurse
    LPWSTR pszDestDir,      // points to a buffer MAX_PATH big and contains the destination dir to recurse
    LPWSTR pszDiscName,     // CD name, if any
    LPWSTR pszTagFile,      // tagfile to look for, if any
    LPDWORD pdwCount )      // copy file counter

{
    HRESULT hr = S_OK;
    BOOL b;

    TraceFunc( "RecursiveCopySubDirectory( ... )\n" );

    WIN32_FIND_DATA fda;
    HANDLE hfda = INVALID_HANDLE_VALUE;

    LONG uOrginalSrcLength = wcslen( pszSrcDir );
    LONG uOrginalDstLength = wcslen( pszDestDir );

    ConcatenatePaths( pszSrcDir, L"*" );

    hfda = FindFirstFile( pszSrcDir, &fda );
    if ( hfda == INVALID_HANDLE_VALUE )
    {
        ErrorBox( NULL, pszSrcDir );
        hr = E_FAIL;
        goto Cleanup;
    }

    pszSrcDir[ uOrginalSrcLength ] = L'\0';

    do
    {
        KeepUIAlive( NULL );

        if (( fda.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
           && ( wcscmp( fda.cFileName, L"." ) )
           && ( wcscmp( fda.cFileName, L".." ) ))  // no dot dirs
        {
            if ( wcslen( fda.cFileName ) + uOrginalDstLength >= MAX_PATH
              || wcslen( fda.cFileName ) + uOrginalSrcLength >= MAX_PATH )
            {
                SetLastError( ERROR_BUFFER_OVERFLOW );
                ErrorBox( NULL, fda.cFileName );
                hr = E_FAIL;
                goto Cleanup;
            }

            ConcatenatePaths( pszSrcDir, fda.cFileName );
            ConcatenatePaths( pszDestDir, fda.cFileName );
            
            RecursiveCopySubDirectory( Queue,
                                       pszSrcDir,
                                       pszDestDir,
                                       pszDiscName,
                                       pszTagFile,
                                       pdwCount );

            pszSrcDir[ uOrginalSrcLength ] = L'\0';
            pszDestDir[ uOrginalDstLength ] = L'\0';
            goto SkipFile;
        }
        else if (fda.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            goto SkipFile;

        b = SetupQueueCopy( Queue,
                            pszSrcDir,
                            NULL,
                            fda.cFileName,
                            pszDiscName,
                            pszTagFile,
                            pszDestDir,
                            NULL,
                            SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER
                            | SP_COPY_WARNIFSKIP | SP_COPY_SOURCE_ABSOLUTE );
        if ( !b ) {
            ErrorBox( NULL, fda.cFileName );
            hr = THR(S_FALSE);
            goto SkipFile;
        }

        // increment file counter
        (*pdwCount)++;
SkipFile:
        ;   // nop
    } while ( FindNextFile( hfda, &fda ) );

Cleanup:
    if ( hfda != INVALID_HANDLE_VALUE ) {
        FindClose( hfda );
        hfda = INVALID_HANDLE_VALUE;
    }

    HRETURN(hr);
}

//
// CopyOptionalDirs
//
HRESULT
CopyOptionalDirs(
    HSPFILEQ Queue,
    HINF     hinf,
    LPWSTR   pszSection,
    LPWSTR   pszDiscName,
    LPWSTR   pszTagFile,
    LPDWORD  pdwCount )
{
    HRESULT    hr = S_OK;
    INFCONTEXT context;
    UINT       uLineNum;
    BOOL b;

    TraceFunc( "CopyOptionalDirs( ... )\n" );

    b = SetupFindFirstLine( hinf, pszSection, NULL, &context );
#if 0
    // this will hit installing a 2195 build because [AdditionalClientDirs]
    // is missing, so take it out for now
    AssertMsg( b, "Missing section?" );
#endif
    if ( !b ) {
        hr = S_FALSE;
    }

    while ( b && hr == S_OK )
    {
        WCHAR  szSrcPath[ 14 ]; // should be 8.3 directory name
        WCHAR  szSrcDir[ MAX_PATH ];
        WCHAR  szDestDir[ MAX_PATH ];
        WIN32_FIND_DATA fda;
        HANDLE hfda = INVALID_HANDLE_VALUE;
        LONG uOrginalSrcLength;
        LONG uOrginalDestLength;

        b  = SetupGetStringField( &context, 0, szSrcPath, ARRAYSIZE(szSrcPath), NULL );
        AssertMsg( b, "Missing field?" );
        if ( !b ) {
            hr = S_FALSE;
            goto Cleanup;
        }

        wcscpy( szSrcDir, g_Options.szSourcePath );
        ConcatenatePaths( szSrcDir, g_Options.ProcessorArchitectureString );
        ConcatenatePaths( szSrcDir, szSrcPath );
        Assert( wcslen( szSrcDir ) < ARRAYSIZE(szSrcDir) );

        wcscpy( szDestDir, g_Options.szInstallationPath );
        ConcatenatePaths( szDestDir, g_Options.ProcessorArchitectureString );
        ConcatenatePaths( szDestDir, szSrcPath );
        Assert( wcslen( szDestDir ) < ARRAYSIZE(szDestDir) );

        hr = RecursiveCopySubDirectory( Queue,
                                        szSrcDir,
                                        szDestDir,
                                        pszDiscName,
                                        pszTagFile,
                                        pdwCount );
        if (hr)
            goto Cleanup;

        b = SetupFindNextLine( &context, &context );
    }

Cleanup:

    HRETURN(hr);
}


//
// IsEntryInCab( )
BOOL
IsEntryInCab(
    HINF    hinf,
    PCWSTR  pszFileName
    )
{

    TraceFunc( "IsEntryInCab( ... )\n" );

    INFCONTEXT Context;
    INFCONTEXT SectionContext;
    WCHAR      szCabinetName[ MAX_PATH ];
    UINT       uField;
    UINT       uFieldCount;
    DWORD      dwLen = ARRAYSIZE( szCabinetName );

    Assert( hinf != INVALID_HANDLE_VALUE );
    Assert( pszFileName );

    // Find the cab files listing section
    if ( !SetupFindFirstLineW( hinf, L"Version", L"CabFiles", &SectionContext ) )
    {
        RETURN( FALSE );
    }

    do
    {
        uFieldCount = SetupGetFieldCount( &SectionContext );

        for( uField = 1; uField <= uFieldCount; uField++ )
        {
            SetupGetStringField( &SectionContext, uField, szCabinetName, dwLen, NULL );

            if( SetupFindFirstLineW( hinf, szCabinetName, pszFileName, &Context ) )
            {
                RETURN( TRUE ); // it's in a CAB
            }
        }

    } while ( SetupFindNextMatchLine( &SectionContext, L"CabFiles", &SectionContext ) );

    RETURN( FALSE );
}

typedef struct _LL_FILES_TO_EXTRACT LL_FILES_TO_EXTRACT;
typedef struct _LL_FILES_TO_EXTRACT {
    LL_FILES_TO_EXTRACT * Next;
    DWORD dwLen;
    WCHAR szFilename[ MAX_PATH ];
    WCHAR szSubDir[ MAX_PATH ];
} LL_FILES_TO_EXTRACT, * PLL_FILES_TO_EXTRACT;

PLL_FILES_TO_EXTRACT pExtractionList;

//
// AddEntryToExtractionQueue( )
//
HRESULT
AddEntryToExtractionQueue(
    LPWSTR pszFileName )
{
    TraceFunc( "AddEntryToExtractionQueue( ... )\n" );

    HRESULT hr = S_OK;
    PLL_FILES_TO_EXTRACT  pNode = pExtractionList;
    DWORD   dwLen;

    dwLen = wcslen( pszFileName );
    while ( pNode )
    {
        if ( dwLen == pNode->dwLen
          && _wcsicmp( pszFileName, pNode->szFilename ) == 0 )
        {
            hr = S_FALSE;
            goto exit; // duplicate
        }
        pNode = pNode->Next;
    }

    pNode = (PLL_FILES_TO_EXTRACT) LocalAlloc( LMEM_FIXED, sizeof(LL_FILES_TO_EXTRACT) );
    if ( pNode )
    {
        pNode->dwLen = dwLen;
        pNode->Next = pExtractionList;
        wcscpy( pNode->szFilename, pszFileName );

        pExtractionList = pNode;

        DebugMsg( "QUEUEING  : %s to be extracted.\n", pszFileName );
    }
    else
    {
        hr = THR( E_OUTOFMEMORY );
    }

exit:
    HRETURN(hr);
}

BOOL
MySetupGetSourceInfo( 
    IN HINF hInf, 
    IN UINT SrcId, 
    IN UINT InfoDesired,
    IN PCWSTR ProcessorArchitectureOverride, OPTIONAL
    OUT PWSTR Buffer,
    IN DWORD BufferSizeInBytes,
    OUT LPDWORD RequiredSize OPTIONAL
    )
/*++

Routine Description:

    Wrapper for SetupGetSourceInfo because it doesn't handle platform path 
    override correctly.

--*/
{
    WCHAR TempSectionName[MAX_PATH];
    WCHAR SourceId[20];
    INFCONTEXT Context;
    BOOL RetVal = FALSE;
    
    if (!ProcessorArchitectureOverride) {
        return SetupGetSourceInfo(
                            hInf,
                            SrcId,
                            InfoDesired,
                            Buffer,
                            BufferSizeInBytes,
                            RequiredSize );
    }

    Assert( InfoDesired == SRCINFO_PATH );


    wsprintf( TempSectionName, L"SourceDisksNames.%s", ProcessorArchitectureOverride );
    wsprintf( SourceId, L"%d", SrcId );
    
    if (!SetupFindFirstLine( hInf, TempSectionName,SourceId, &Context )) {
        wcscpy( TempSectionName, L"SourceDisksNames" );
        if (!SetupFindFirstLine( hInf, TempSectionName,SourceId, &Context )) {
            goto exit;
        }
    }

    RetVal = SetupGetStringField( &Context, 4, Buffer, BufferSizeInBytes/sizeof(TCHAR), NULL );

exit:

    return(RetVal);

}     


//
// CopyLayoutInfSection( )
//
HRESULT
CopyLayoutInfSection(
    HSPFILEQ Queue,
    HINF     hinf,
    HINF     hinfDrivers,
    LPCWSTR   pszSection,
    LPCWSTR   pszDescName,
    LPCWSTR   pszTagFile,
    LPCWSTR  pszDestination,
    LPDWORD  pdwCount )
/*++

Routine Description:

    Queues up files from the specified section in layout.inf to be installed
    into the remote install image directory.  This code is similar to what
    textmode setup does, and it reads several of the extended layout flags
    that textmode setup reads and setupapi doesn't have intrinsic knowledge
    about.

Arguments:

    Queue      - queue handle to queue the copy operations to.
    hinf       - handle to layout.inf
    hinfDrivers - handle to drvindex.inf, to be used to see if files are
                  located in the driver cabinet or not
    pszSection - section listing files to be copied
    pszDescName- user printable description of the media where this file is
                  located.  this may be used when the queue is committed.
    pszTagFile - specifies the tag file that is to uniquely describe the media
                 where these files are located
    pszDestination - specifies the location where files are to be 
                        copied to
    pdwCount   - specifies the number of files that were queued from this 
                 section on return.  if the function fails, this value is
                 undefined.    

Return Value:

    An HRESULT indicating the outcome.

--*/
{
    HRESULT hr = S_OK;
    INFCONTEXT context;
    BOOL b;

    TraceFunc( "CopyLayoutInfSection( ... )\n" );

    b = SetupFindFirstLine( hinf, pszSection, NULL, &context );
    AssertMsg( b, "Missing section?" );
    if ( !b ) {
        hr = S_FALSE;
    }

    while ( b )
    {
        BOOL   fDecompress = FALSE;
        WCHAR  szTemp[ 5 ]; // "_x" is the biggest string right now
        DWORD  SrcId;
        WCHAR  szSrcName[ MAX_PATH ];
        WCHAR  szSubDir[20];
        WCHAR  szSubDirPlusFileName[MAX_PATH];
        LPWSTR pszPeriod;

        KeepUIAlive( NULL );

        b  = SetupGetStringField( &context, 0, szSrcName, ARRAYSIZE(szSrcName), NULL );
        AssertMsg( b, "Missing field?" );
        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        //
        // get the subdirectory that this file is located in, based on the 
        // sourcedisksnames data in field 1
        //
        b  = SetupGetStringField( &context, 1, szTemp, ARRAYSIZE(szTemp), NULL );
        AssertMsg( b, "Missing field?" );
        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        SrcId = _wtoi(szTemp);

        b = MySetupGetSourceInfo( 
                    hinf, 
                    SrcId, 
                    SRCINFO_PATH,
                    SetupExtensionFromProcessorTag(g_Options.ProcessorArchitectureString),
                    szSubDir,
                    sizeof(szSubDir),
                    NULL );
        if (!b) {
            hr = S_FALSE;
            goto SkipIt;
        }

        // If there is an "_" in the 2nd character of "source" column of the
        // layout.inf file, then this file should be decompressed because
        // it is a file needed for booting.
        szTemp[1] = 0;
        b = SetupGetStringField( &context, 7, szTemp, ARRAYSIZE(szTemp), NULL );
        AssertMsg( b, "Missing field?" );
        if ( szTemp[1] == L'_' ) {
            fDecompress = TRUE;
            DebugMsg( "DECOMPRESS: %s is a boot driver.\n", szSrcName );
            goto CopyIt;
        }

        // If the 7th field isn't NULL, then the file exists outside the
        // CABs so just copy it.
        if ( wcslen( szTemp ) > 0 ) {
            DebugMsg( "BOOTFLOPPY: %s is external from CAB.\n", szSrcName );
            goto CopyIt;
        }

        // If it is in the CAB and didn't meet any of the conditions above,
        // don't copy the file. It'll be in the CAB when/if setup needs it.
        if ( IsEntryInCab( hinfDrivers, szSrcName ) ) {
#if DBG
            pszPeriod = wcschr(szSrcName, L'.');
            if ((pszPeriod != NULL) && (_wcsicmp(pszPeriod, L".inf") == 0)) {
                DebugMsg( 
                    "WARNING: %s is an INF in a cab.  This file will not be available for network inf processing .\n", 
                    szSrcName );
            }
#endif                
            DebugMsg( "SKIPPING  : %s in a CAB.\n", szSrcName );
            goto SkipIt;
        }

        // If the extension is ".inf", then decompress so binlsvc
        // can do its network .inf processing.
        pszPeriod = wcschr(szSrcName, L'.');
        if ((pszPeriod != NULL) && (_wcsicmp(pszPeriod, L".inf") == 0)) {
            fDecompress = TRUE;
            DebugMsg( "DECOMPRESS: %s is an INF.\n", szSrcName );            
        }

CopyIt:
        //
        // we do this so that files end up in the proper subdirectory
        //
        wcscpy(szSubDirPlusFileName, szSubDir );
        ConcatenatePaths( szSubDirPlusFileName, szSrcName );

        b = SetupQueueCopy( Queue,
                            g_Options.szSourcePath,
                            szSubDir,
                            szSrcName,
                            pszDescName,
                            pszTagFile,
                            pszDestination,
                            szSubDirPlusFileName,
                            SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER | SP_COPY_WARNIFSKIP
                            | SP_COPY_SOURCE_ABSOLUTE | ( fDecompress ? 0 : SP_COPY_NODECOMP ) );
        if ( !b ) {
            ErrorBox( NULL, szSrcName );
            hr = THR(S_FALSE);
            goto SkipIt;
        }

        // increment file counter
        (*pdwCount)++;

SkipIt:
        b = SetupFindNextLine( &context, &context );
    }

    HRETURN(hr);
}

//
// EnumNetworkDriversCallback( )
//
ULONG
EnumNetworkDriversCallback(
    LPVOID pContext,
    LPWSTR pszInfName,
    LPWSTR pszFileName )
{
    TraceFunc( "EnumNetworkDriversCallback( ... )\n" );

    MYCONTEXT * pMyContext = (MYCONTEXT *) pContext;
    HRESULT hr;

    Assert( pszFileName );
    Assert( pszInfName );

    //DebugMsg( "In %s: %s\n", pszInfName, pszFileName );

    if ( KeepUIAlive( pMyContext->hDlg ) )
    {
        RETURN(ERROR_CANCELLED);
    }

    hr = AddEntryToExtractionQueue( pszFileName );
    if ( hr == S_OK )
    {
        pMyContext->nToBeCopied++;
    }
    else if ( hr == S_FALSE )
    {   // duplicate found in queue... keep going
        hr = S_OK;
    }

    HRETURN(hr);
}

//
// EnumCabinetCallback( )
//
UINT CALLBACK
EnumCabinetCallback(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    TraceFunc( "EnumCabinetCallback( ... )\n" );

    UINT   uResult = 0;
    PLL_FILES_TO_EXTRACT pNode = pExtractionList;
    PLL_FILES_TO_EXTRACT pLast;
    DWORD  dwLen;
    PFILE_IN_CABINET_INFO pfici;

    MYCONTEXT *pMyContext = (MYCONTEXT *) Context;

    Assert( pMyContext );

    KeepUIAlive( pMyContext->hDlg );

    if ( g_Options.fAbort )
    {
        if ( !g_Options.fError )
        {
            WCHAR    szAbort[ SMALL_BUFFER_SIZE ];

            // change filename text to aborting...
            DWORD dw = LoadString( g_hinstance, IDS_ABORTING, szAbort, ARRAYSIZE(szAbort) );
            Assert( dw );
            SetWindowText( pMyContext->hOperation, szAbort );

            g_Options.fError = TRUE;
        }

        if ( g_Options.fError ) {
            SetLastError(ERROR_CANCELLED);
            uResult = FILEOP_ABORT;
            goto exit;
        }
    }

    if ( Notification == SPFILENOTIFY_FILEINCABINET )
    {
        pfici = (PFILE_IN_CABINET_INFO) Param1;
        Assert( pfici );
        Assert( pfici->NameInCabinet );

        dwLen = wcslen( pfici->NameInCabinet );
        while ( pNode )
        {
            if ( dwLen == pNode->dwLen
              && _wcsicmp( pfici->NameInCabinet, pNode->szFilename ) == 0 )
            {   // match! remove it from the list and extract it.
                if ( pNode == pExtractionList )
                {
                    pExtractionList = pNode->Next;
                }
                else
                {
                    pLast->Next = pNode->Next;
                }
                LocalFree( pNode );

                // create target path
                wcscpy( pfici->FullTargetName, g_Options.szInstallationPath );
                ConcatenatePaths( pfici->FullTargetName, g_Options.ProcessorArchitectureString );
                ConcatenatePaths( pfici->FullTargetName, pfici->NameInCabinet );

                if ( !(pMyContext->fQuiet) ) {
                    wcscpy( &pMyContext->szCopyingString[ pMyContext->dwCopyingLength ],
                        pfici->NameInCabinet );
                    dwLen = wcslen( pMyContext->szCopyingString );
                    wcscpy( &pMyContext->szCopyingString[ dwLen ], L"..." );

                    SetWindowText( pMyContext->hOperation, pMyContext->szCopyingString );
                }

                DebugMsg( "EXTRACTING: %s from CAB.\n", pfici->NameInCabinet );

                uResult = FILEOP_DOIT;
                goto exit;
            }
            pLast = pNode;
            pNode = pNode->Next;
        }

        uResult = FILEOP_SKIP;
    }
    else if ( Notification == SPFILENOTIFY_FILEEXTRACTED )
    {
        PFILEPATHS pfp = (PFILEPATHS) Param1;
        Assert( pfp );

        pMyContext->nCopied++;
        SendMessage( pMyContext->hProg, PBM_SETPOS, (5000 * pMyContext->nCopied) / pMyContext->nToBeCopied, 0 );

        uResult = pfp->Win32Error;
    }

exit:
    RETURN(uResult);
}

//
// AddInfSectionToExtractQueue( )
//
HRESULT
AddInfSectionToExtractQueue(
    HINF    hinf,
    LPWSTR  pszSection,
    LPMYCONTEXT Context )
{
    TraceFunc( "AddInfSectionToExtractQueue( ... )\n" );

    HRESULT hr = S_OK;
    BOOL    b;

    INFCONTEXT context;

    b = SetupFindFirstLine( hinf, pszSection, NULL, &context );
    if ( !b ) goto Cleanup; // nothing to do - don't complain!

    while ( b )
    {
        WCHAR szFilename[ MAX_PATH ];
        DWORD dwLen = ARRAYSIZE( szFilename );
        b = SetupGetStringField( &context, 1, szFilename, dwLen, NULL );
        if ( !b ) goto Error;

        hr = AddEntryToExtractionQueue( szFilename );
        if (FAILED( hr )) goto Cleanup;

        if (hr == S_OK) {
            Context->nToBeCopied += 1;
        }

        b = SetupFindNextLine( &context, &context );
    }

Cleanup:
    HRETURN(hr);
Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
    goto Cleanup;
}


//
// Copies the files into the setup directory.
//
HRESULT
CopyClientFiles( HWND hDlg )
{
    HRESULT hr = S_OK;
    DWORD   dwLen;
    LPWSTR  psz;
    BOOL    b;
    HWND    hProg    = GetDlgItem( hDlg, IDC_P_METER );
    DWORD   dwCount  = 0;
    DWORD   dw;
    WCHAR   szText[ SMALL_BUFFER_SIZE ];
    WCHAR   szFilepath[ MAX_PATH ];
    WCHAR   szTempPath[ MAX_PATH ];
    WCHAR   szInsertMedia[ MAX_PATH ];
    HINF    hinfLayout = INVALID_HANDLE_VALUE;
    HINF    hinfReminst = INVALID_HANDLE_VALUE;
    HINF    hinfDrivers = INVALID_HANDLE_VALUE;
    HINF    hinfDosnet = INVALID_HANDLE_VALUE;
    UINT    uLineNum;
    DWORD   dwFlags = IDF_CHECKFIRST | IDF_NOSKIP;
    WCHAR   *p;

    PLL_FILES_TO_EXTRACT  pNode;
    HMODULE hBinlsvc = NULL;
    PNETINFENUMFILES pfnNetInfEnumFiles = NULL;

    HANDLE hThread = NULL;
    EXPANDCABLISTPARAMS ExpandParams;

    INFCONTEXT context;

    HSPFILEQ  Queue = INVALID_HANDLE_VALUE;
    MYCONTEXT MyContext;

    TraceFunc( "CopyClientFiles( hDlg )\n" );

    //
    // Setup and display next section of dialog
    //
    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 5000 ));
    SendMessage( hProg, PBM_SETPOS, 0, 0 );
    dw = LoadString( g_hinstance, IDS_BUILDINGFILELIST, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    // Initialize
    ZeroMemory( &MyContext, sizeof(MyContext) );
    pExtractionList = NULL;
    ZeroMemory( &ExpandParams, sizeof(ExpandParams) );

    hBinlsvc = LoadLibrary( L"BINLSVC.DLL" );
    if ( hBinlsvc == NULL )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, L"BINLSVC.DLL" );
        goto Cleanup;
    }

    pfnNetInfEnumFiles = (PNETINFENUMFILES) GetProcAddress( hBinlsvc, NETINFENUMFILESENTRYPOINT );
    if ( pfnNetInfEnumFiles == NULL )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, L"BINLSVC.DLL" );
        goto Cleanup;
    }

    // Make sure the workstation CD is the CD-ROM drive
    dw = LoadString( g_hinstance, IDS_INSERT_MEDIA, szInsertMedia, ARRAYSIZE(szInsertMedia) );
    Assert( dw );

AskForDisk:
    wcscpy(szTempPath, g_Options.szSourcePath);
    ConcatenatePaths( szTempPath, g_Options.ProcessorArchitectureString);

    if ( DPROMPT_SUCCESS !=
            SetupPromptForDisk( hDlg,
                                szInsertMedia,
                                g_Options.szWorkstationDiscName,
                                szTempPath,
                                L"layout.inf",
                                g_Options.szWorkstationTagFile,
                                dwFlags,
                                g_Options.szSourcePath,
                                MAX_PATH,
                                NULL ) )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        goto Cleanup;
    }

    //
    // if they gave us a trailing architecture tag, then remove it
    //
    if (g_Options.szSourcePath[wcslen(g_Options.szSourcePath)-1] == L'\\') {
        //
        // lose the trailing backslash if present
        //
        g_Options.szSourcePath[wcslen(g_Options.szSourcePath)-1] = L'\0';
    }

    p = wcsrchr( g_Options.szSourcePath, L'\\');
    if (p) {
        p = StrStrI(p,g_Options.ProcessorArchitectureString);
            if (p) {
            *(p-1) = L'\0';
        }
    }

    dw = CheckImageSource( hDlg );
    if ( dw != ERROR_SUCCESS )
    {
        dwFlags = IDF_NOSKIP;
        goto AskForDisk;
    }

    if ( g_Options.fAbort || g_Options.fError )
        goto Cleanup;

    wcscpy(szFilepath, g_Options.szSourcePath);
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString);
    ConcatenatePaths( szFilepath, L"layout.inf");
    
    Assert( wcslen( szFilepath ) < ARRAYSIZE(szFilepath) );

    hinfLayout = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinfLayout == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    // Openning layout can take a long time. Update the UI and check to see
    // if the user wants to abort.
    if ( KeepUIAlive( hDlg ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
        goto Cleanup;
    }

    wcscpy(szFilepath, g_Options.szSourcePath);
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString);
    ConcatenatePaths( szFilepath, L"drvindex.inf");

    Assert( wcslen( szFilepath ) < ARRAYSIZE(szFilepath) );

    hinfDrivers = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinfDrivers == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    //
    // Create the Queue
    //
    Queue = SetupOpenFileQueue( );

    //
    // Copy to REMINST.inf quietly
    //
    dw = GetEnvironmentVariable( L"TMP",
                                 g_Options.szWorkstationRemBootInfPath,
                                 ARRAYSIZE(g_Options.szWorkstationRemBootInfPath) );
    Assert( dw );

    ConcatenatePaths( g_Options.szWorkstationRemBootInfPath, L"\\REMINST.inf" );
    Assert( wcslen(g_Options.szWorkstationRemBootInfPath) < ARRAYSIZE(g_Options.szWorkstationRemBootInfPath) );

    wcscpy(szTempPath, g_Options.szSourcePath);
    ConcatenatePaths( szTempPath, g_Options.ProcessorArchitectureString);
    
    b = SetupInstallFile( hinfLayout,
                          NULL,
                          L"REMINST.inf",
                          szTempPath,
                          g_Options.szWorkstationRemBootInfPath,
                          SP_COPY_FORCE_NEWER,
                          NULL,
                          NULL );
    if ( !b ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        WCHAR szCaption[SMALL_BUFFER_SIZE]; 
        DWORD dw;
        dw = LoadString( g_hinstance, IDS_COPYING_REMINST_TITLE, szCaption, SMALL_BUFFER_SIZE );
        Assert( dw );
        ErrorBox( hDlg, szCaption );
        AssertMsg( b, "Failed to copy REMINST.INF to TEMP" );
        goto Cleanup;
    }

    // The above call will initialize a lot of the SETUPAPI. This might take
    // a long time as well. Refresh the UI and check for user abort.
    if ( KeepUIAlive( hDlg ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
        goto Cleanup;
    }

    // Now check the version of the workstation to make sure it's compatible
    hr = CheckServerVersion( );
    if ( FAILED(hr) )
        goto Cleanup;


    //
    // Copy architecture-indepenedent files.
    //
    hr = CopyLayoutInfSection( Queue,
                               hinfLayout,
                               hinfDrivers,
                               L"SourceDisksFiles",                               
                               g_Options.szWorkstationDiscName,
                               g_Options.szWorkstationTagFile,
                               g_Options.szInstallationPath,
                               &dwCount );
    if ( FAILED(hr) ) {
        goto Cleanup;
    }

    //
    // Copy architecture-depenedent files.
    //
    wsprintf( 
        szTempPath, 
        L"SourceDisksFiles.%s", 
        SetupExtensionFromProcessorTag(g_Options.ProcessorArchitectureString) );

    hr = CopyLayoutInfSection( Queue,
                               hinfLayout,
                               hinfDrivers,
                               szTempPath,
                               g_Options.szWorkstationDiscName,
                               g_Options.szWorkstationTagFile,
                               g_Options.szInstallationPath,
                               &dwCount );
    if ( FAILED(hr) ) {
        goto Cleanup;
    }

    //
    // build the path to dosnet.inf
    //
    wcscpy( szFilepath, g_Options.szSourcePath );
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString );
    ConcatenatePaths( szFilepath, L"dosnet.inf" );

    Assert( wcslen( szFilepath ) < ARRAYSIZE(szFilepath));

    hinfDosnet = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinfDosnet == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( NULL, szFilepath );
        goto Cleanup;
    }

    hr = CopyOptionalDirs( Queue,
                           hinfDosnet,
                           L"OptionalSrcDirs",
                           g_Options.szWorkstationDiscName,
                           g_Options.szWorkstationTagFile,
                           &dwCount );
    if ( FAILED(hr) )
        goto Cleanup;


    SetupCloseInfFile( hinfLayout );
    hinfLayout = INVALID_HANDLE_VALUE;

    SetupCloseInfFile( hinfDosnet );
    hinfDosnet = INVALID_HANDLE_VALUE;


    //
    // Add additional files not specified in the LAYOUT.INF
    //
    hinfReminst = SetupOpenInfFile( g_Options.szWorkstationRemBootInfPath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinfReminst == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, g_Options.szWorkstationRemBootInfPath );
        goto Cleanup;
    }

    hr = CopyInfSection( Queue,
                         hinfReminst,
                         L"AdditionalClientFiles",
                         g_Options.szSourcePath,
                         g_Options.szWorkstationSubDir,
                         g_Options.szWorkstationDiscName,
                         g_Options.szWorkstationTagFile,
                         g_Options.szInstallationPath,
                         &dwCount );
    if( FAILED(hr) )
        goto Cleanup;

    //
    // Add additional directories not specified in LAYOUT.INF
    //
    hr = CopyOptionalDirs( Queue,
                           hinfReminst,
                           L"AdditionalClientDirs",
                           g_Options.szWorkstationDiscName,
                           g_Options.szWorkstationTagFile,
                           &dwCount );
    if ( FAILED(hr) )
        goto Cleanup;

    //
    // This information will be passed to CopyFileCallback() as
    // the Context.
    //
    MyContext.nToBeCopied        = dwCount;
    MyContext.nCopied            = 0;
    MyContext.pContext           = SetupInitDefaultQueueCallback( hDlg );
    MyContext.hProg              = hProg;
    MyContext.hOperation         = GetDlgItem( hDlg, IDC_S_OPERATION );
    MyContext.hDlg               = hDlg;
    MyContext.fQuiet             = FALSE;
    MyContext.dwCopyingLength =
        LoadString( g_hinstance, IDS_COPYING, MyContext.szCopyingString, ARRAYSIZE(MyContext.szCopyingString));
    Assert(MyContext.dwCopyingLength);

    //
    // Start copying
    //
    Assert( dwCount );
    if ( dwCount != 0 )
    {
        b = SetupCommitFileQueue( NULL,
                                  Queue,
                                  (PSP_FILE_CALLBACK) CopyFilesCallback,
                                  (PVOID) &MyContext );
        if ( !b ) {
            DWORD dwErr = GetLastError( );
            switch ( dwErr )
            {
            case ERROR_CANCELLED:
                hr = THR( HRESULT_FROM_WIN32( ERROR_CANCELLED ) );
                goto Cleanup;

            default:
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                MessageBoxFromError( hDlg, NULL, dwErr );
                goto Cleanup;
            }
        }
    }

    SetupCloseFileQueue( Queue );
    Queue = INVALID_HANDLE_VALUE;

    //
    // Ask BINL to go through the INFs to find the drivers
    // that we need to extract from the CABs.
    //
    dw = LoadString( g_hinstance, IDS_BUILDINGFILELIST, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    // Re-init these values
    MyContext.nCopied = 0;
    MyContext.nToBeCopied = 0;

    // Pre-fill the link list of things to extract from the cab with
    // things in the workstations REMINST.INF if needed. The section
    // can be missing if there is nothing to pre-fill.
    hr = AddInfSectionToExtractQueue( hinfReminst, L"ExtractFromCabs", &MyContext );
    if (FAILED( hr ))
        goto Cleanup;

    //!!!!bugbug doesn't seem to be working right!!!!
    // compile the list of files
    wcscpy( szTempPath, g_Options.szInstallationPath );
    ConcatenatePaths( szTempPath, g_Options.ProcessorArchitectureString );
    dw = pfnNetInfEnumFiles( szTempPath,
                             g_Options.ProcessorArchitecture,
                             &MyContext,
                             EnumNetworkDriversCallback );

    if ( dw != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( dw ) );
        MessageBoxFromError( hDlg, NULL, dw );
        goto Cleanup;
    }

    DebugMsg( "%d files need to be extracted from CABs.\n", MyContext.nToBeCopied );

    // Go through the CABs extracting only the ones in the link list
    if ( !SetupFindFirstLineW( hinfDrivers, L"Version", L"CabFiles", &context) )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, NULL );
        goto Cleanup;
    }

    do
    {
        UINT uFieldCount = SetupGetFieldCount( &context );
        DebugMsg( "uFieldCount = %u\n", uFieldCount );
        for( UINT uField = 1; uField <= uFieldCount; uField++ )
        {
            WCHAR CabinetNameKey[64];
            INFCONTEXT DrvContext;
            WCHAR szCabinetName[ MAX_PATH ];

            dwLen = ARRAYSIZE( szCabinetName );
            if (!SetupGetStringField( &context, uField, CabinetNameKey, ARRAYSIZE( CabinetNameKey ), NULL ) ||
                !SetupFindFirstLine( hinfDrivers, L"Cabs", CabinetNameKey, &DrvContext) ||
                !SetupGetStringField( &DrvContext, 1, szCabinetName, dwLen, NULL )) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, NULL );
                goto Cleanup;
            }

            wcscpy( szFilepath, g_Options.szInstallationPath);
            ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString );
            ConcatenatePaths( szFilepath, szCabinetName );
            DebugMsg( "Iterating: %s\n", szFilepath );
            if ( szCabinetName[0] == L'\0' )
                continue; // skip blanks
            b = SetupIterateCabinet( szFilepath,
                                     0,
                                     EnumCabinetCallback,
                                     &MyContext );
            if ( !b )
            {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szFilepath );
                goto Cleanup;
            }
        }
    } while ( SetupFindNextMatchLine( &context, L"CabFiles", &context ) );

    //
    // comment out this assert because it always fires -- some files we are 
    // queuing up (the ones in the ExtractFromCabs section) are not part of
    // any cab, so they are handled in the following section.
    //
#if 0
    // This should be empty - if not tell someone on the CHKed version.
    AssertMsg( pExtractionList == NULL, "Some network drivers are not in the CABs.\n\nIgnore this if you do not care." );
#endif
    if ( pExtractionList != NULL )
    {
        WCHAR szDstPath[ MAX_PATH ];

        // Ok. Someone decided that these files shouldn't be in the CAB. So
        // let's try to get them from outside the CAB.
        pNode = pExtractionList;
        while ( pNode )
        {
            DWORD dwConditionalFlags = 0;
            WCHAR cTmp;
            PWSTR CompressedName = NULL;
            //
            // see if we copied the file to the installation image already
            //
            // if the file is already at the destination, we can skip copying 
            // this file or just decompress it (and delete the compressed 
            // source).  In the case where the file is compressed, we may need
            // to tweak the file attributes so that the source file can be
            // successfully retreived.
            //
            wcscpy( szFilepath, g_Options.szInstallationPath );
            ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString );
            ConcatenatePaths( szFilepath, pNode->szFilename );            
            if ( !IsFileOrCompressedVersionPresent( szFilepath, &CompressedName )) {
                //
                // It's not already there, so check the source.
                //
                // Note that we don't care if the file is compressed or not, we
                // just want the file to be there, because setupapi can do the
                // rest without any help from us.
                //
                wcscpy( szFilepath, g_Options.szSourcePath );
                ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString );
                ConcatenatePaths( szFilepath, pNode->szFilename );
                if ( !IsFileOrCompressedVersionPresent( szFilepath, &CompressedName )) {
                    //
                    // it's not there on the source - we must give up
                    //
                    hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                    MessageBoxFromError( hDlg, pNode->szFilename, ERROR_FILE_NOT_FOUND );
                    goto Cleanup;
                }
            } else {
                if (CompressedName) {
                    //
                    // Make sure we can delete the compressed source file at 
                    // the destination path since we're going to decompress
                    // this file
                    //
                    DWORD dwAttribs = dwAttribs = GetFileAttributes( CompressedName );
                    DebugMsg( "!!compressed name!!: %s\n", CompressedName );                    
                    if ( dwAttribs & FILE_ATTRIBUTE_READONLY )
                    {
                        dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                        SetFileAttributes( CompressedName, dwAttribs );
                    }
                    
                    dwConditionalFlags = SP_COPY_DELETESOURCE;

                    TraceFree( CompressedName );

                } else {
                    //
                    // the file is already expanded in the destination - NOP.
                    //
                    goto DeleteIt;
                }
            }

            // Update UI
            wcscpy( &MyContext.szCopyingString[ MyContext.dwCopyingLength ], pNode->szFilename );
            wcscpy( &MyContext.szCopyingString[ wcslen( MyContext.szCopyingString ) ], L"..." );
            SetWindowText( MyContext.hOperation, MyContext.szCopyingString );

            DebugMsg( "!!COPYING!!: %s\n", szFilepath );

            wcscpy( szDstPath, g_Options.szInstallationPath );
            ConcatenatePaths( szDstPath, g_Options.ProcessorArchitectureString );
            ConcatenatePaths( szDstPath, pNode->szFilename );

            b= SetupInstallFile( NULL,
                                 NULL,
                                 szFilepath,
                                 NULL,
                                 szDstPath,
                                 SP_COPY_SOURCE_ABSOLUTE | SP_COPY_NEWER_ONLY
                                 | SP_COPY_FORCE_NEWER | dwConditionalFlags,
                                 NULL,
                                 NULL );
            if ( !b )
            {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szFilepath );
                goto Cleanup;
            }

            if ( KeepUIAlive( hDlg ) )
            {
                hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
                goto Cleanup;
            }

DeleteIt:
            // Update meter
            MyContext.nCopied++;
            SendMessage( MyContext.hProg, PBM_SETPOS, (5000 * MyContext.nCopied) / MyContext.nToBeCopied, 0 );

            pExtractionList = pNode->Next;
            LocalFree( pNode );
            pNode = pExtractionList;
        }
    }

    //
    // Finally, blow out all the files in these cabs
    //
    dw = LoadString( g_hinstance, IDS_EXPANDING_CABS, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    ExpandParams.hDlg          = hDlg;
    ExpandParams.hinf          = hinfReminst;
    ExpandParams.pszSection    = L"CabsToExpand";
    ExpandParams.pszSourcePath = g_Options.szSourcePath;
    ExpandParams.pszDestPath   = g_Options.szInstallationPath;
    ExpandParams.pszSubDir     = g_Options.ProcessorArchitectureString;

    // Expand CABs in background to keep UI alive
    hThread = CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE) ExpandCabList, (LPVOID) &ExpandParams, NULL, NULL );
    while ( WAIT_TIMEOUT == WaitForSingleObject( hThread, 10 ) )
    {
        KeepUIAlive( hDlg );
    }
    GetExitCodeThread( hThread, (ULONG*)&hr );
    DebugMsg( "Thread Exit Code was 0x%08x\n", hr );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( hThread != NULL )
        CloseHandle( hThread );

    if ( MyContext.pContext )
        SetupTermDefaultQueueCallback( MyContext.pContext );

    if ( Queue != INVALID_HANDLE_VALUE )
        SetupCloseFileQueue( Queue );

    if ( hinfLayout != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( hinfLayout );

    if ( hinfReminst != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( hinfReminst );

    if ( hinfDrivers != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( hinfDrivers );

    if ( hinfDosnet != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( hinfDosnet );

    if ( hBinlsvc != NULL )
        FreeLibrary( hBinlsvc );

    AssertMsg( pExtractionList == NULL, "The list still isn't empty.\n\nThe image will be missing some drivers.\n" );
    while ( pExtractionList )
    {
        PLL_FILES_TO_EXTRACT pNode = pExtractionList;
        pExtractionList = pExtractionList->Next;
        LocalFree( pNode );
    }

    b = DeleteFile( g_Options.szWorkstationRemBootInfPath );
    AssertMsg( b, "Failed to delete temp\\REMINST.INF\nThis was just a warning and can be ignored." );
    g_Options.szWorkstationRemBootInfPath[0] = L'\0';

    SendMessage( hProg, PBM_SETPOS, 5000, 0 );
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );

    HRETURN(hr);
}


//
// Modifies registry from the registry section of the REMINST.INF
//
HRESULT
ModifyRegistry( HWND hDlg )
{
    HRESULT hr = S_OK;
    HWND    hProg = GetDlgItem( hDlg, IDC_P_METER );
    WCHAR   szText[ SMALL_BUFFER_SIZE ];
    WCHAR   szSection[ SMALL_BUFFER_SIZE ];
    WCHAR   szFiles[ MAX_PATH ];
    WCHAR   szPath[ MAX_PATH ];
    BOOL    b;
    DWORD   dw;
    WCHAR   szRegSrvDlls[ MAX_PATH ];
    UINT    spinstFlags = 0;

    TraceFunc( "ModifyRegistry( hDlg )\n" );

    Assert( g_Options.hinf != INVALID_HANDLE_VALUE );
    if ( g_Options.hinf == INVALID_HANDLE_VALUE )
        HRETURN( HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE ) );    // need this handle!

    //
    // Update UI
    //
    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM( 0, 1 ) );
    dw = LoadString( g_hinstance, IDS_UPDATING_REGISTRY, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    dw = LoadString( g_hinstance, IDS_INF_SECTION, szSection, ARRAYSIZE(szSection));
    Assert( dw );

    //
    // Process the INF's registry section
    //
    if ( !g_Options.fRegistryIntact ) {
        spinstFlags |= SPINST_REGISTRY;
    }
    if ( !g_Options.fRegSrvDllsRegistered ) {
        spinstFlags |= SPINST_REGSVR;
    }

    b = SetupInstallFromInfSection( hDlg,           // hwndOwner
                                    g_Options.hinf, // inf handle
                                    szSection,      // name of component
                                    spinstFlags,
                                    NULL,           // relative key root
                                    NULL,           // source root path
                                    0,              // copy flags
                                    NULL,           // callback routine
                                    NULL,           // callback routine context
                                    NULL,           // device info set
                                    NULL);          // device info struct
    if ( !b ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szSection );
        goto Error;
    }

    //
    // Add the Reg Key for TFTPD
    //
    if ( !g_Options.fTFTPDDirectoryFound ) {
        HKEY hkey;
        dw = LoadString( g_hinstance, IDS_TFTPD_SERVICE_PARAMETERS, szPath, ARRAYSIZE(szPath));
        Assert( dw );

        if ( ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                              szPath,
                                              0,    // options
                                              NULL, // class
                                              0,    // options
                                              KEY_WRITE,
                                              NULL, // security
                                              &hkey,
                                              &dw   ) ) {   // disposition
            ULONG lLen;
            DWORD dwType;
            LONG lErr;

            // paranoid
            Assert( wcslen(g_Options.szIntelliMirrorPath) < ARRAYSIZE(g_Options.szIntelliMirrorPath));
            lLen = lstrlen( g_Options.szIntelliMirrorPath ) * sizeof(WCHAR);
            lErr = RegSetValueEx( hkey,
                                  L"Directory",
                                  0, // reserved
                                  REG_SZ,
                                  (LPBYTE) g_Options.szIntelliMirrorPath,
                                  lLen );
            if ( lErr == ERROR_SUCCESS ) {
                DebugMsg( "TFTPD's Directory RegKey set.\n" );
            } else {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szPath );
                DebugMsg( "HKLM\\%s could be not created.\n", szPath );
                goto Error;
            }

            RegCloseKey( hkey );
        } else {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szPath );
            DebugMsg( "HKLM\\%s could be not created.\n", szPath );
            goto Error;
        }
    }

Error:
    SendMessage( hProg, PBM_SETPOS, 1 , 0 );
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );
    HRETURN(hr);
}

//
// Stop a specific service
//
HRESULT
StopRBService(
    HWND hDlg,
    SC_HANDLE schSystem,
    LPWSTR pszService
    ) 
{
    HRESULT hr = S_OK;
    SC_HANDLE schService = NULL;
    SERVICE_STATUS ssStatus;
    BOOL b;
    DWORD dwErr;

    TraceFunc( "StopRBService( ... )\n" );

    Assert( schSystem );
    Assert( pszService );
    
    schService = OpenService( schSystem,
                              pszService,
                              SERVICE_STOP | SERVICE_QUERY_STATUS );
    if ( !schService ) {
        goto Cleanup;
    }

    b = ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus );
    

#define SLEEP_TIME 2000
#define LOOP_COUNT 30

    if ( !b && GetLastError() != ERROR_SERVICE_NOT_ACTIVE ) {
        dwErr = GetLastError( );
    } else {
        DWORD loopCount = 0;
        do {
            b = QueryServiceStatus( schService, &ssStatus);
            if ( !b ) {
                goto Cleanup;
            }
            if (ssStatus.dwCurrentState == SERVICE_STOP_PENDING) {
                if ( loopCount++ == LOOP_COUNT ) {
                    dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
                    break;
                }
                Sleep( SLEEP_TIME );
            } else {
                if ( ssStatus.dwCurrentState != SERVICE_STOPPED ) {
                    dwErr = ssStatus.dwWin32ExitCode;
                    if ( dwErr == ERROR_SERVICE_SPECIFIC_ERROR ) {
                        dwErr = ssStatus.dwServiceSpecificExitCode;
                    }
                } else {
                    dwErr = NO_ERROR;
                }
                break;
            }
        } while ( TRUE );
    }

Cleanup:
    if ( schService )
        CloseServiceHandle( schService );

    HRETURN(hr);

}

//
// Start a specific service
//
HRESULT
StartRBService(
    HWND      hDlg,
    SC_HANDLE schSystem,
    LPWSTR    pszService,
    LPWSTR    pszServiceName,
    LPWSTR    pszServiceDescription )
{
    HRESULT hr = S_OK;
    SC_HANDLE schService = NULL;
    SERVICE_STATUS ssStatus;
    BOOL b;
    DWORD dwErr;

    TraceFunc( "StartRBService( ... )\n" );

    Assert( schSystem );
    Assert( pszService );
    Assert( pszServiceName );

    schService = OpenService( schSystem,
                              pszService,
                              SERVICE_ALL_ACCESS );
    if ( !schService ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, pszServiceName );
        goto Cleanup;
    }

    b = ChangeServiceConfig( schService,
                             SERVICE_NO_CHANGE,
                             SERVICE_AUTO_START,
                             SERVICE_NO_CHANGE,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL );
    if ( !b ) {
        ErrorBox( hDlg, pszServiceName );
        hr = THR(S_FALSE);
    }

    // If the service is paused, continue it; else try to start it.

    b = QueryServiceStatus( schService, &ssStatus);
    if ( !b ) {
        ErrorBox( hDlg, pszServiceName );
        hr = THR(S_FALSE);
        goto Cleanup;
    }

    if ( ssStatus.dwCurrentState == SERVICE_PAUSED ) {
        b = ControlService( schService, SERVICE_CONTROL_CONTINUE, &ssStatus );
    } else {
        b = StartService( schService, 0, NULL );
    }

#define SLEEP_TIME 2000
#define LOOP_COUNT 30

    if ( !b ) {
        dwErr = GetLastError( );
    } else {
        DWORD loopCount = 0;
        do {
            b = QueryServiceStatus( schService, &ssStatus);
            if ( !b ) {
                ErrorBox( hDlg, pszServiceName );
                hr = THR(S_FALSE);
                goto Cleanup;
            }
            if ( ssStatus.dwCurrentState != SERVICE_RUNNING ) {
                if ( loopCount++ == LOOP_COUNT ) {

                    if ( (ssStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                         (ssStatus.dwCurrentState == SERVICE_START_PENDING) ) {
                        
                        dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
                    } else {
                        dwErr = ssStatus.dwWin32ExitCode;
                        if ( dwErr == ERROR_SERVICE_SPECIFIC_ERROR ) {
                            dwErr = ssStatus.dwServiceSpecificExitCode;
                        }
                    }
                
                    break;
                }

                Sleep( SLEEP_TIME );
            } else {
                dwErr = NO_ERROR;
                break;
            }

        } while ( TRUE );
    }

    if ( dwErr != NO_ERROR ) {
        switch ( dwErr )
        {
        default:
            hr = THR( HRESULT_FROM_WIN32( dwErr ) );
            MessageBoxFromError( hDlg, pszServiceName, dwErr );
            break;

        case ERROR_SERVICE_ALREADY_RUNNING:
            {
                // Attempt to HUP the service
                SERVICE_STATUS ss;
                ControlService( schService, SERVICE_CONTROL_INTERROGATE, &ss );
            }
            break;
        }
    }
    else {
        // There is a pathological case where the service is deleted and then risetup restarts it.  When it does so, it doesn't set the description string.
        // We check here if there is a description for the service and if not we give it one.
        // We can't do this in CreateRemoteBootServices beacuse the services must be started.
        SERVICE_DESCRIPTION description;
        DWORD bytes_needed;
        if( QueryServiceConfig2( schService, SERVICE_CONFIG_DESCRIPTION, ( LPBYTE )&description, sizeof( description ), &bytes_needed )) {
            // Now, if there were a description the previous call would have failed with a ERROR_INSUFFICIENT_BUFFER error.
            // We do a quick check to make sure that everything is valid.
            Assert( description.lpDescription == NULL );
            // Now we can change it.
            description.lpDescription = pszServiceDescription;
            ChangeServiceConfig2( schService, SERVICE_CONFIG_DESCRIPTION, &description );
            // If that caused an error, we'll ignore it since the description is not essential to the operation of RIS.
        }
        // Whatever error the query threw we don't care as the description isn't sufficiently vital to RIS.
    }


Cleanup:
    if ( schService )
        CloseServiceHandle( schService );

    HRETURN(hr);
}

//
// Start the services needed for remote boot.
//
HRESULT
StartRemoteBootServices( HWND hDlg )
{
    WCHAR     szService[ SMALL_BUFFER_SIZE ];
    WCHAR     szServiceName[ SMALL_BUFFER_SIZE ];
    WCHAR     szServiceDescription[ 1024 ]; // Size is the maximum allowed by ChangeServiceConfig2
    WCHAR     szText[ SMALL_BUFFER_SIZE ];
    SC_HANDLE schSystem;
    HWND      hProg = GetDlgItem( hDlg, IDC_P_METER );
    DWORD     dw;
    HRESULT   hr;
    HRESULT   hrFatalError = S_OK;
    HRESULT   hrStartFailure = S_OK;

    HWND hOper = GetDlgItem( hDlg, IDC_S_OPERATION );

    TraceFunc( "StartRemoteBootServices( hDlg )\n" );

    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM( 0, 2 ) );
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    dw = LoadString( g_hinstance, IDS_STARTING_SERVICES, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    Assert( schSystem );
    if ( !schSystem ) {
        hrFatalError = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        WCHAR szCaption[SMALL_BUFFER_SIZE]; 
        DWORD dw;
        dw = LoadString( g_hinstance, IDS_OPENING_SERVICE_MANAGER_TITLE, szCaption, SMALL_BUFFER_SIZE );
        Assert( dw );
        ErrorBox( hDlg, szCaption );
        goto Cleanup;
    }

    //
    // start TFTPD services
    //
    dw = LoadString( g_hinstance, IDS_TFTPD_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
    Assert( dw );
    dw = LoadString( g_hinstance, IDS_TFTPD_DESCRIPTION, szServiceDescription, ARRAYSIZE(szServiceDescription));
    Assert( dw );
    SetWindowText( hOper, szServiceName );

    hr = StartRBService( hDlg, schSystem, L"TFTPD", szServiceName, szServiceDescription );
    if ( FAILED(hr) ) {
        hrFatalError = hr;
        goto Cleanup;
    } else if ( hr != S_OK ) {
        hrStartFailure = hr;
    }

    //
    // start BINLSVC services
    //
    dw = LoadString( g_hinstance, IDS_BINL_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
    Assert( dw );
    dw = LoadString( g_hinstance, IDS_BINL_DESCRIPTION, szServiceDescription, ARRAYSIZE(szServiceDescription));
    Assert( dw );
    SetWindowText( hOper, szServiceName );    
    if (!g_Options.fBINLSCPFound) {
        StopRBService( hDlg, schSystem, L"BINLSVC" );
    }

    hr = StartRBService( hDlg, schSystem, L"BINLSVC", szServiceName, szServiceDescription );
    if ( FAILED(hr) ) {
        hrFatalError = hr;
        goto Cleanup;
    } else if ( hr != S_OK ) {
        hrStartFailure = hr;
    }

    //
    // start GROVELER services
    //
    dw = LoadString( g_hinstance, IDS_SISGROVELER_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
    Assert( dw );
    dw = LoadString( g_hinstance, IDS_SISGROVELER_DESCRIPTION, szServiceDescription, ARRAYSIZE(szServiceDescription));
    Assert( dw );
    SetWindowText( hOper, szServiceName );

    hr = StartRBService( hDlg, schSystem, L"GROVELER", szServiceName, szServiceDescription );
    if ( FAILED(hr) ) {
        hrFatalError = hr;
        goto Cleanup;
    } else if ( hr != S_OK ) {
        hrStartFailure = hr;
    }

Cleanup:
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );

    if ( schSystem )
        CloseServiceHandle( schSystem );

    if ( hrFatalError != S_OK ) {
        hr = hrFatalError;
    } else if ( hrStartFailure != S_OK ) {
        hr = hrStartFailure;
    } else {
        hr = S_OK;
    }

    RETURN(hr);
}

//
// create IntelliMirror share
//
HRESULT
CreateRemoteBootShare( HWND hDlg )
{
    SHARE_INFO_502  si502;
    SHARE_INFO_1005 si1005;
    WCHAR szRemark[ SMALL_BUFFER_SIZE ];
    WCHAR szRemoteBoot[ SMALL_BUFFER_SIZE ];
    WCHAR szText[ SMALL_BUFFER_SIZE ];
    WCHAR szPath[ 129 ];
    DWORD dwErr;
    HWND  hProg = GetDlgItem( hDlg, IDC_P_METER );
    DWORD dw;
    HRESULT hr;

    TraceFunc( "CreateRemoteBootShare( hDlg )\n" );

    dw = LoadString( g_hinstance, IDS_CREATINGSHARES, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    dw = LoadString( g_hinstance, IDS_REMOTEBOOTSHAREREMARK, szRemark, ARRAYSIZE(szRemark));
    Assert( dw );
    dw = LoadString( g_hinstance, IDS_REMOTEBOOTSHARENAME, szRemoteBoot, ARRAYSIZE(szRemoteBoot));
    Assert( dw );

    wcscpy( szPath, g_Options.szIntelliMirrorPath );
    if ( wcslen( szPath ) == 2 ) {
        wcscat( szPath, L"\\" );
    }

    si502.shi502_netname             = szRemoteBoot;
    si502.shi502_type                = STYPE_DISKTREE;
    si502.shi502_remark              = szRemark;
    si502.shi502_permissions         = ACCESS_ALL;
    si502.shi502_max_uses            = -1;   // unlimited
    si502.shi502_current_uses        = 0;
    si502.shi502_path                = szPath;
    si502.shi502_passwd              = NULL; // ignored
    si502.shi502_reserved            = 0;    // must be zero
    si502.shi502_security_descriptor = NULL;
    Assert( wcslen(g_Options.szIntelliMirrorPath) < ARRAYSIZE(g_Options.szIntelliMirrorPath) ); // paranoid

    dwErr = NetShareAdd( NULL, 502, (LPBYTE) &si502, NULL );
    switch ( dwErr )
    {
        // ignore these
    case NERR_Success:
    case NERR_DuplicateShare:
        dwErr = ERROR_SUCCESS;
        break;

    default:
        MessageBoxFromError( hDlg, g_Options.szIntelliMirrorPath, dwErr );
        goto Error;
    }

#ifdef REMOTE_BOOT
#error("Remote boot is dead!! Turn off the REMOTE_BOOT flag.")
    si1005.shi1005_flags = CSC_CACHE_AUTO_REINT;
    NetShareSetInfo( NULL, szRemoteBoot, 1005, (LPBYTE)&si1005, &dwErr );
    switch ( dwErr )
    {
        // ignore these
    case NERR_Success:
        dwErr = ERROR_SUCCESS;
        break;

    default:
        MessageBoxFromError( hDlg, g_Options.szIntelliMirrorPath, dwErr );
    }
#endif // REMOTE_BOOT

Error:
    hr = THR( HRESULT_FROM_WIN32(dwErr) );
    HRETURN(hr);
}


typedef int (WINAPI * REGISTERDLL)( void );

//
// Register Dlls
//
// If hDlg is NULL, this will fail silently.
//
HRESULT
RegisterDll( HWND hDlg, LPWSTR pszDLLPath )
{
    REGISTERDLL pfnRegisterDll = NULL;
    HINSTANCE hLib;
    HRESULT hr = S_OK;

    TraceFunc( "RegisterDll( ... )\n" );

    //
    // We'll try to register it locally, but if fails MMC should
    // grab it from the DS and register it on the machine.
    //
    hLib = LoadLibrary( pszDLLPath );
    AssertMsg( hLib, "RegisterDll: Missing DLL?" );
    if ( !hLib ) {
        hr = S_FALSE;
        goto Cleanup;
    }

    pfnRegisterDll = (REGISTERDLL) GetProcAddress( hLib, "DllRegisterServer" );
    AssertMsg( pfnRegisterDll, "RegisterDll: Missing entry point?" );
    if ( pfnRegisterDll != NULL )
    {
        hr = THR( pfnRegisterDll() );
        if ( FAILED(hr) && hDlg ) {
            MessageBoxFromStrings( hDlg,
                                   IDS_REGISTER_IMADMIU_FAILED_CAPTION,
                                   IDS_REGISTER_IMADMIU_FAILED_TEXT,
                                   MB_OK );
        }
    }

    FreeLibrary( hLib );

Cleanup:
    HRETURN(hr);
}


//
// Creates the services needed for remote boot.
//
HRESULT
CreateRemoteBootServices( HWND hDlg )
{
    HRESULT   hr = S_OK;
    WCHAR     szServiceName[ SMALL_BUFFER_SIZE ]; // TFTPD service name
    WCHAR     szText[ SMALL_BUFFER_SIZE ];      // general use
    WCHAR     szGroup[ SMALL_BUFFER_SIZE ];
    CHAR      szIntelliMirrorDrive[ 3 ];        // eg. "D:" - ASCII not UNICODE

    SC_HANDLE schSystem;        // Handle to System Services
    SC_HANDLE schService;       // Temp handle to new service

    DWORD     dw;               // general use
    LPARAM    lRange;

    HWND hProg = GetDlgItem( hDlg, IDC_P_METER );
    HWND hOper = GetDlgItem( hDlg, IDC_S_OPERATION );

    TraceFunc( "CreateRemoteBootServices( hDlg )\n" );

    lRange = 0;
    if ( !g_Options.fBINLServiceInstalled ) {
        lRange++;
    }
    if ( !g_Options.fBINLSCPFound ) {
        lRange++;
    }
    if ( !g_Options.fTFTPDServiceInstalled ) {
        lRange++;
    }
    if ( !g_Options.fSISServiceInstalled ) {
        lRange++;
    }
    lRange = MAKELPARAM( 0, lRange );

    SendMessage( hProg, PBM_SETRANGE, 0, lRange );
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    //
    // Display what we are doing in operations area
    //
    dw = LoadString( g_hinstance, IDS_STARTING_SERVICES, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetWindowText( hOper, szText );

    //
    // Open System Services Manager
    //
    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    Assert( schSystem );
    if ( !schSystem ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        WCHAR szCaption[SMALL_BUFFER_SIZE]; 
        DWORD dw;
        dw = LoadString( g_hinstance, IDS_OPENING_SERVICE_MANAGER_TITLE, szCaption, SMALL_BUFFER_SIZE );
        Assert( dw );
        ErrorBox( hDlg, szCaption );
        goto Cleanup;
    }

    //
    // Create TFTPD service
    //
    if ( !g_Options.fTFTPDServiceInstalled ) {
        dw = LoadString( g_hinstance, IDS_TFTPD_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
        Assert( dw );
        dw = LoadString( g_hinstance, IDS_TFTPD, szText, ARRAYSIZE(szText));
        Assert( dw );
        SetWindowText( hOper, szServiceName );
        dw = LoadString( g_hinstance, IDS_TFTPD_PATH, szText, ARRAYSIZE(szText));
        Assert( dw );
        schService = CreateService(
                        schSystem,
                        L"TFTPD",
                        szServiceName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_AUTO_START,
                        SERVICE_ERROR_NORMAL,
                        szText,
                        NULL,
                        NULL,
                        L"Tcpip\0",
                        NULL,
                        NULL );
        if ( !schService ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szServiceName );
        } else {
            CloseServiceHandle( schService );
        }

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }

    //
    // Create BINLSVC
    //
    if ( !g_Options.fBINLServiceInstalled ) {
        dw = LoadString( g_hinstance, IDS_BINL_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
        Assert( dw );
        SetWindowText( hOper, szServiceName );
        dw = LoadString( g_hinstance, IDS_BINL_PATH, szText, ARRAYSIZE(szText));
        Assert( dw );
        schService = CreateService(
                        schSystem,
                        L"BINLSVC",
                        szServiceName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        SERVICE_WIN32_SHARE_PROCESS,
                        SERVICE_AUTO_START,
                        SERVICE_ERROR_NORMAL,
                        szText,
                        NULL,
                        NULL,
                        L"Tcpip\0LanmanServer\0",
                        NULL,
                        NULL );
        if ( !schService ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szServiceName );
        } else {
            CloseServiceHandle( schService );
        }

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }

    //
    // Create SIS
    //
    if ( !g_Options.fSISServiceInstalled ) {
        dw = LoadString( g_hinstance, IDS_SIS_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
        Assert( dw );
        SetWindowText( hOper, szServiceName );
        dw = LoadString( g_hinstance, IDS_SIS_PATH, szText, ARRAYSIZE(szText));
        Assert( dw );
        dw = LoadString( g_hinstance, IDS_SIS_GROUP, szGroup, ARRAYSIZE(szGroup));
        Assert( dw );
        schService = CreateService(
                        schSystem,
                        L"SIS",
                        szServiceName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        SERVICE_FILE_SYSTEM_DRIVER,
                        SERVICE_BOOT_START,
                        SERVICE_ERROR_NORMAL,
                        szText,
                        szGroup,
                        NULL,
                        NULL,
                        NULL,
                        NULL );
        if ( !schService ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szServiceName );
        } else {
            CloseServiceHandle( schService );
        }

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }

    //
    // Create SIS Groveler
    //
    if ( !g_Options.fSISGrovelerServiceInstalled ) {
        dw = LoadString( g_hinstance, IDS_SISGROVELER_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
        Assert( dw );
        SetWindowText( hOper, szServiceName );
        dw = LoadString( g_hinstance, IDS_SISGROVELER_PATH, szText, ARRAYSIZE(szText));
        Assert( dw );
        dw = LoadString( g_hinstance, IDS_SISGROVELER_GROUP, szGroup, ARRAYSIZE(szGroup));
        Assert( dw );
        schService = CreateService(
                        schSystem,
                        L"Groveler",
                        szServiceName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_AUTO_START,
                        SERVICE_ERROR_NORMAL,
                        szText,
                        NULL,
                        NULL,
                        L"SIS\0",
                        NULL,
                        NULL );
        if ( !schService ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szServiceName );
        } else {
            CloseServiceHandle( schService );
        }

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }

    //
    // Create the BINL SCP
    //
    if ( !g_Options.fBINLSCPFound ) {
        dw = LoadString( g_hinstance, IDS_BINL_SERVICECONTROLPOINT, szText, ARRAYSIZE(szText) );
        Assert( dw );
        SetWindowText( hOper, szText );

        hr = CreateSCP( hDlg );

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }



Cleanup:
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );
    HRETURN(hr);
}

//
// Reads the server's layout.inf file for disc name, tag file and
// optional sub-dir. All parameters are assumed to be MAX_PATH in
// size except the tag files which can only be 10.3 format.
//
HRESULT
RetrieveServerDiscInfo(
    HWND   hDlg,
    LPWSTR pszDiscName,
    LPWSTR pszTagFile,
    LPWSTR pszSubDir )
{
    TraceFunc("RetrieveServerDiscInfo()\n");

    HRESULT hr = S_OK;
    HINF    hinf = INVALID_HANDLE_VALUE;
    UINT   uLineNum;
    INFCONTEXT context;
    WCHAR   szSourcePath[ MAX_PATH ];
    BOOL b;

    if ( !GetEnvironmentVariable(L"windir", szSourcePath, ARRAYSIZE(szSourcePath)) )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szSourcePath );
        goto Cleanup;
    }
    wcscat( szSourcePath, L"\\inf\\layout.inf" );

    hinf = SetupOpenInfFile( szSourcePath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szSourcePath );
        goto Cleanup;
    }


    b = FALSE;
    if ( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ) {
        b = SetupFindFirstLine( hinf, L"SourceDisksNames.x86", L"1", &context );
    } else if ( g_Options.ProcessorArchitecture  == PROCESSOR_ARCHITECTURE_IA64 ) {
        b = SetupFindFirstLine( hinf, L"SourceDisksNames.ia64", L"1", &context );
    }

    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szSourcePath );
        goto Cleanup;
    }



    if ( pszDiscName ) {
        b = SetupGetStringField( &context, 1, pszDiscName, MAX_PATH, NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szSourcePath );
            goto Cleanup;
        }
    }

    if ( pszTagFile )
    {
        b = SetupGetStringField( &context, 2, pszTagFile, 14 /* 10.3 + NULL */, NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szSourcePath );
            goto Cleanup;
        }
    }

    if ( pszSubDir )
    {
        b = SetupGetStringField( &context, 4, pszSubDir, MAX_PATH, NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szSourcePath );
            goto Cleanup;
        }
    }

Cleanup:
    if ( hinf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( hinf );

    HRETURN(hr);
}

//
// Copies the files needed by the server from where the server
// was orginally installed from.
//
HRESULT
CopyServerFiles( HWND hDlg )
{
    HRESULT hr = S_OK;
    HSPFILEQ Queue = INVALID_HANDLE_VALUE;
    WCHAR   szSection[ SMALL_BUFFER_SIZE ];
    HWND    hProg    = GetDlgItem( hDlg, IDC_P_METER );
    DWORD   dwCount  = 0;
    DWORD   dw;
    BOOL    b;
    UINT    iResult;
    WCHAR   szServerDiscName[ MAX_PATH ] = { L'\0' };
    MYCONTEXT MyContext;
    INFCONTEXT context;
    UINT       uLineNum;
    
    ZeroMemory( &MyContext, sizeof(MyContext) );

    TraceFunc( "CopyServerFiles( hDlg )\n" );

    Assert( g_Options.hinf != INVALID_HANDLE_VALUE );
    if ( g_Options.hinf == INVALID_HANDLE_VALUE ) {
        hr = E_FAIL;   // need this handle!
        goto Cleanup;
    }

    //
    // Setup and display next section of dialog
    //
    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 5000 ));
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    //
    // Ask for CD if any of the Services files are missing.
    // Or if the System32\RemBoot directory is missing and we
    // need the OS Chooser files (not screens).
    //
    if ( !g_Options.fBINLFilesFound
      || !g_Options.fTFTPDFilesFound
      || !g_Options.fSISFilesFound
      || !g_Options.fSISGrovelerFilesFound
      || !g_Options.fRegSrvDllsFilesFound
      || ( !g_Options.fRemBootDirectory && !g_Options.fOSChooserInstalled ) ) {

        WCHAR   szSourcePath[ MAX_PATH ];
        WCHAR   szServerTagFile[ 14 ] = { L'\0' };
        WCHAR   szInsertMedia[ 64 ];
        WCHAR   szServerSubDir[ MAX_PATH ] = { L'\0' };
        
        DebugMsg( "Queue and copy reminst files\n" );

        //
        // Ask user to check the CDROM to make sure the right CD is in the drive.
        // We skip this if it was installed from a share.
        //
        dw = LoadString( g_hinstance, IDS_INSERT_MEDIA, szInsertMedia, ARRAYSIZE(szInsertMedia) );
        Assert( dw );

        hr = RetrieveServerDiscInfo( hDlg, szServerDiscName, szServerTagFile, szServerSubDir );
        // if it fails, try to proceed anyway to see if the user is smart enough
        // to fix the problem.

        iResult = SetupPromptForDisk( hDlg,               // parent window of the dialog box
                                      szInsertMedia,      // optional, title of the dialog box
                                      szServerDiscName,   // optional, name of disk to insert
                                      NULL,               // optional, expected source path
                                      szServerTagFile,    // name of file needed
                                      szServerTagFile,    // optional, source media tag file
                                      IDF_CHECKFIRST | IDF_NODETAILS | IDF_NOSKIP, // specifies dialog box behavior
                                      szSourcePath,       // receives the source location
                                      MAX_PATH,           // size of the supplied buffer
                                      NULL );             // optional, buffer size needed
        if ( iResult != DPROMPT_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            goto Cleanup;
        }

        dw = LoadString( g_hinstance, IDS_INF_SECTION, szSection, ARRAYSIZE(szSection) );
        Assert( dw );

        //
        // Create the Queue
        //
        Queue = SetupOpenFileQueue( );

        //
        // Add the files
        //
        b = SetupInstallFilesFromInfSection( g_Options.hinf,
                                             NULL,
                                             Queue,
                                             szSection,
                                             szSourcePath,
                                             SP_COPY_WARNIFSKIP | SP_COPY_FORCE_NEWER
                                             | SP_COPY_NEWER_ONLY ); // copy flags
        Assert( b );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szSection );
            goto Cleanup;
        }

        //
        // Add a section that is done during textmode setup
        //
        b = SetupQueueCopySection(  Queue,
                                    szSourcePath,
                                    g_Options.hinf,
                                    NULL,
                                    L"REMINST.OtherSystemFiles",
                                    SP_COPY_WARNIFSKIP | SP_COPY_FORCE_NEWER
                                    | SP_COPY_NEWER_ONLY ); // copy flags
        Assert( b );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, L"REMINST.OtherSystemFiles" );
            goto Cleanup;
        }

        //
        // This information will be passed to CopyFileCallback() as
        // the Context.
        //
        MyContext.nToBeCopied        = 12;  // todo: generate this dynamically
        MyContext.nCopied            = 0;
        MyContext.pContext           = SetupInitDefaultQueueCallback( hDlg );
        MyContext.hProg              = hProg;
        MyContext.hOperation         = GetDlgItem( hDlg, IDC_S_OPERATION );
        MyContext.hDlg               = hDlg;
        MyContext.dwCopyingLength =
            LoadString( g_hinstance, IDS_COPYING, MyContext.szCopyingString, ARRAYSIZE(MyContext.szCopyingString));
        b = SetupCommitFileQueue( NULL, Queue, (PSP_FILE_CALLBACK) CopyFilesCallback, (PVOID) &MyContext );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, NULL );
        }

        SetupTermDefaultQueueCallback( MyContext.pContext );
        ZeroMemory( &MyContext, sizeof(MyContext) );

        SetupCloseFileQueue( Queue );
        Queue = INVALID_HANDLE_VALUE;

        // recheck
        HRESULT hr2 = CheckInstallation( );
        if ( FAILED(hr2) ) {
            hr = THR( hr2 );
            goto Cleanup;
        }

        // because of the recheck, this flag should be set
        Assert( g_Options.fRemBootDirectory );
        
        g_Options.fRemBootDirectory = TRUE;
    }

    //
    // Move OS Chooser files to the IntelliMirror\OSChooser tree.
    //
    if ( !g_Options.fOSChooserInstalled
      && g_Options.fRemBootDirectory ) {

        DebugMsg( "Queue and copy os chooser files\n" );

        Assert( g_Options.fIMirrorDirectory );
        Assert( g_Options.fOSChooserDirectory );

        b = SetupFindFirstLine( g_Options.hinf, L"OSChooser", NULL, &context );
        AssertMsg( b, "Missing section?" );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }

        if ( szServerDiscName[0] == L'\0' )
        {
            hr = RetrieveServerDiscInfo( hDlg, szServerDiscName, NULL, NULL );
            // if it fails, try to proceed anyway to see if the user is smart enough
            // to fix the problem.
        }

        dwCount = 0;

        //
        // Create the Queue
        //
        Queue = SetupOpenFileQueue( );

        while ( b )
        {
            WCHAR  szSrcFile[ MAX_PATH ];
            WCHAR  szDestFile[ MAX_PATH ];
            DWORD  dw;
            LPWSTR pszDest = NULL;

            dw = SetupGetFieldCount( &context );

            if ( dw > 1 ) {
                b = SetupGetStringField( &context, 1, szDestFile, ARRAYSIZE(szDestFile) , NULL );
                AssertMsg( b, "Missing field?" );
                if ( b ) {
                    b = SetupGetStringField( &context, 2, szSrcFile, ARRAYSIZE(szSrcFile), NULL );
                    AssertMsg( b, "Missing field?" );
                    pszDest = szDestFile;
                }
            } else {
                b = SetupGetStringField( &context, 1, szSrcFile, ARRAYSIZE(szSrcFile), NULL );
                AssertMsg( b, "Missing field?" );
            }

            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                goto SkipIt;
            }

            b = SetupQueueCopy( Queue,
                                g_Options.szRemBootDirectory,
                                NULL,
                                szSrcFile,
                                szServerDiscName,
                                NULL,
                                g_Options.szOSChooserPath,
                                pszDest,
                                SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER
                                | SP_COPY_WARNIFSKIP | SP_COPY_SOURCEPATH_ABSOLUTE );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( NULL, szSrcFile );
                goto SkipIt;
            }

            // increment file count
            dwCount++;

SkipIt:
            b = SetupFindNextLine( &context, &context );
        }

        b = SetupFindFirstLine( g_Options.hinf, L"OSChooser.NoOverwrite", NULL, &context );
        AssertMsg( b, "Missing section?" );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }

        while ( b )
        {
            WCHAR  szSrcFile[ MAX_PATH ];
            WCHAR  szDestFile[ MAX_PATH ];
            DWORD  dw;
            LPWSTR pszDest = NULL;

            dw = SetupGetFieldCount( &context );

            if ( dw > 1 ) {
                b = SetupGetStringField( &context, 1, szDestFile, ARRAYSIZE(szDestFile) , NULL );
                AssertMsg( b, "Missing field?" );
                if ( b ) {
                    b = SetupGetStringField( &context, 2, szSrcFile, ARRAYSIZE(szSrcFile) , NULL );
                    AssertMsg( b, "Missing field?" );
                    pszDest = szDestFile;
                }
            } else {
                b = SetupGetStringField( &context, 1, szSrcFile, ARRAYSIZE(szSrcFile) , NULL );
                AssertMsg( b, "Missing field?" );
            }

            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                goto SkipNonCritical;
            }

            b = SetupQueueCopy( Queue,
                                g_Options.szRemBootDirectory,
                                NULL,
                                szSrcFile,
                                szServerDiscName,
                                NULL,
                                g_Options.szOSChooserPath,
                                pszDest,
                                SP_COPY_NOOVERWRITE
                                | SP_COPY_WARNIFSKIP 
                                | SP_COPY_SOURCEPATH_ABSOLUTE );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( NULL, szSrcFile );
                goto SkipNonCritical;
            }

            // increment file count
            dwCount++;

SkipNonCritical:
            b = SetupFindNextLine( &context, &context );
        }


        //
        // This information will be passed to CopyFileCallback() as
        // the Context.
        //
        MyContext.nToBeCopied        = dwCount;
        MyContext.nCopied            = 0;
        MyContext.pContext           = SetupInitDefaultQueueCallback( hDlg );
        MyContext.hProg              = hProg;
        MyContext.hDlg               = hDlg;
        MyContext.hOperation         = GetDlgItem( hDlg, IDC_S_OPERATION );
        MyContext.dwCopyingLength =
            LoadString( g_hinstance, IDS_COPYING, MyContext.szCopyingString, ARRAYSIZE(MyContext.szCopyingString));

        b = SetupCommitFileQueue( NULL, Queue, (PSP_FILE_CALLBACK) CopyFilesCallback, (PVOID) &MyContext );
        if ( !b ) {
            DWORD dwErr = GetLastError( );
            hr = THR( HRESULT_FROM_WIN32( dwErr ) );
            switch ( dwErr )
            {
            case ERROR_CANCELLED:
                goto Cleanup;
                break; // expected

            default:
                MessageBoxFromError( hDlg, NULL, dwErr );
                goto Cleanup;
                break;
            }
        }

    }
    

Cleanup:
    if ( MyContext.pContext )
        SetupTermDefaultQueueCallback( MyContext.pContext );

    if ( Queue != INVALID_HANDLE_VALUE )
        SetupCloseFileQueue( Queue );

    HRETURN(hr);
}

//
// CopyTemplateFiles( )
//
HRESULT
CopyTemplateFiles( HWND hDlg )
{
    HRESULT hr = S_OK;
    WCHAR sz[ SMALL_BUFFER_SIZE ];
    WCHAR szSourcePath[ MAX_PATH ];
    WCHAR szTemplatePath[ MAX_PATH ];
    WCHAR szFileName[ MAX_PATH ];
    BOOL  fNotOverwrite;
    BOOL  b;
    DWORD dw;

    TraceFunc( "CopyTemplateFiles( ... )\n" );

    dw = LoadString( g_hinstance, IDS_UPDATING_SIF_FILE, sz, ARRAYSIZE(sz) );
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, sz );

    dw = LoadString( g_hinstance, IDS_DEFAULT_SIF, szFileName, ARRAYSIZE(szFileName) );
    Assert( dw );

    //
    // Create the path "IntelliMirror\Setup\English\nt50.wks\i386\default.sif"
    //
    wcscpy( szSourcePath, g_Options.szInstallationPath );
    ConcatenatePaths( szSourcePath, g_Options.ProcessorArchitectureString );
    ConcatenatePaths( szSourcePath, szFileName );
    
    Assert( wcslen( szSourcePath ) < ARRAYSIZE(szSourcePath) );

    //
    // Create the path "IntelliMirror\Setup\English\nt50.wks\i386\Templates"
    //
    wcscpy( szTemplatePath, g_Options.szInstallationPath );
    ConcatenatePaths( szTemplatePath, g_Options.ProcessorArchitectureString );
    ConcatenatePaths( szTemplatePath, L"Templates" );
    
    Assert( wcslen( szTemplatePath ) < ARRAYSIZE(szTemplatePath) );
    if ( 0xFFFFffff == GetFileAttributes( szTemplatePath ) ) {
        b = CreateDirectory( szTemplatePath, NULL );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szTemplatePath );
            goto Error;
        }
    }

    //
    // Create the path "IntelliMirror\Setup\English\nt50.wks\i386\Templates\default.sif"
    //
    ConcatenatePaths( szTemplatePath, szFileName );    
    Assert( wcslen( szTemplatePath ) < ARRAYSIZE(szTemplatePath) );

    DebugMsg( "Copying %s to %s...\n", szSourcePath, szTemplatePath );
    fNotOverwrite = TRUE;
    while ( hr == S_OK && !CopyFile( szSourcePath, szTemplatePath, fNotOverwrite) )
    {
        DWORD dwErr = GetLastError( );

        switch (dwErr)
        {
        case ERROR_FILE_EXISTS:
            {
                dw = LoadString( g_hinstance, IDS_OVERWRITE_TEXT, sz, ARRAYSIZE(sz) );
                Assert( dw );

                if ( IDYES == MessageBox( hDlg, sz, szFileName, MB_YESNO ) )
                {
                    fNotOverwrite = FALSE;
                }
                else
                {
                    OPENFILENAME ofn;

                    dw = LoadString( g_hinstance, IDS_SAVE_SIF_TITLE, sz, ARRAYSIZE(sz) );

GetFileNameAgain:
                    memset( &ofn, 0, sizeof( ofn ) );
                    ofn.lStructSize = sizeof( ofn );
                    ofn.hwndOwner = hDlg;
                    ofn.hInstance = g_hinstance;
                    ofn.lpstrFilter = L"Unattended Setup Answer Files\0*.SIF\0\0";
                    ofn.lpstrFile = szTemplatePath;
                    ofn.nMaxFile = MAX_PATH;
                    ofn.lpstrInitialDir = szTemplatePath;
                    ofn.lpstrTitle = sz;
                    ofn.Flags = OFN_CREATEPROMPT |
                                OFN_NOCHANGEDIR |
                                OFN_NONETWORKBUTTON |
                                OFN_NOREADONLYRETURN |
                                OFN_OVERWRITEPROMPT |
                                OFN_PATHMUSTEXIST;
                    ofn.nFileOffset = lstrlen( szTemplatePath ) - lstrlen( szFileName );
                    ofn.nFileExtension = lstrlen( szTemplatePath ) - 3;
                    ofn.lpstrDefExt = L"SIF";

                    b = GetSaveFileName( &ofn );
                    if ( !b ) {
                        hr = S_FALSE;
                    }

                    // paranoid
                    Assert( wcslen(szTemplatePath) < ARRAYSIZE(szTemplatePath) );
                    Assert( wcslen(g_Options.szIntelliMirrorPath) < ARRAYSIZE(g_Options.szIntelliMirrorPath) );

                    if ( wcslen(szTemplatePath) - wcslen(g_Options.szIntelliMirrorPath) + 53 >= 128 )
                    {
                        MessageBoxFromStrings( hDlg, IDS_BOOTP_FILENAME_LENGTH_RESTRICTION_TITLE, IDS_BOOTP_FILENAME_LENGTH_RESTRICTION_TEXT, MB_OK );
                        goto GetFileNameAgain;
                    }
                }
            }
            break;

        default:
            MessageBoxFromError( hDlg, szFileName, dwErr );
            hr = S_FALSE;
        }
    }

    if ( hr == S_OK )
    {
        //
        // Need to add "Quotes" around the text
        //
        WCHAR szDescription[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT + 2 ];
        WCHAR szHelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT + 2 ];
        WCHAR szOSVersion[ 32 ];

        wsprintf( szDescription, L"\"%s\"", g_Options.szDescription );
        Assert( wcslen(szDescription) < ARRAYSIZE(szDescription) );
        wsprintf( szHelpText, L"\"%s\"", g_Options.szHelpText );
        Assert( wcslen(szHelpText) < ARRAYSIZE(szHelpText) );
        wsprintf( szOSVersion, L"\"%s.%s (%d)\"", g_Options.szMajorVersion, g_Options.szMinorVersion, g_Options.dwBuildNumber );
        Assert( wcslen(szOSVersion) < ARRAYSIZE(szOSVersion) );

        WritePrivateProfileString( L"OSChooser",
                                   L"Description",
                                   szDescription,
                                   szTemplatePath );

        WritePrivateProfileString( L"OSChooser",
                                   L"Help",
                                   szHelpText,
                                   szTemplatePath );

        WritePrivateProfileString( L"OSChooser",
                                   L"ImageType",
                                   L"Flat",
                                   szTemplatePath );

        WritePrivateProfileString( L"OSChooser",
                                   L"Version",
                                   szOSVersion,
                                   szTemplatePath );
    }

Error:
    HRETURN(hr);
}

//
// Create Common Store Volume
//
HRESULT
CreateSISVolume( HWND hDlg )
{
    HRESULT hr = E_FAIL;
    WCHAR sz[ SMALL_BUFFER_SIZE ];
    DWORD dw;
    BOOL  b;

    HANDLE hVolume;
    WCHAR szVolumePath[ MAX_PATH ];

    WCHAR szSISPath[ MAX_PATH ];

    HANDLE hMaxIndex;
    WCHAR szIndexFilePath[ MAX_PATH ];
    PACL pAcl = NULL;
    SECURITY_DESCRIPTOR SecDescriptor;
    PSID pAdminsSid = NULL;
    EXPLICIT_ACCESS ExplicitEntries;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;

    TraceFunc( "CreateSISVolume( hDlg )\n" );

    // We may have not known the IntelliMirror Drive/Directory
    // until now and it was previously an SIS volume.
    if ( g_Options.fSISVolumeCreated ) {
        hr = S_OK;
        goto Error;
    }

    dw = LoadString( g_hinstance, IDS_CREATING_SIS_VOLUME, sz, ARRAYSIZE(sz) );
    Assert( dw );

    SetDlgItemText( hDlg, IDC_S_OPERATION, sz );

    b = GetVolumePathName( g_Options.szIntelliMirrorPath, szVolumePath, MAX_PATH );
    Assert( b );
    Assert( wcslen(szVolumePath) < ARRAYSIZE(szVolumePath) );
    TraceMsg( TF_ALWAYS, "Creating %s...\n", szVolumePath );

    wsprintf( szSISPath, L"%s\\SIS Common Store", szVolumePath );

    //
    // Create and zero SIS store
    //
    b = CreateDirectory( szSISPath, NULL );
    if ( !b ) {

        dw = GetLastError();
        if (ERROR_ALREADY_EXISTS != dw)  {

            hr = THR( HRESULT_FROM_WIN32( dw ) );
            ErrorBox( hDlg, szSISPath );
            DebugMsg( "Cannot create Common Store directory." );
            goto Error;
        }
    }

    b = SetFileAttributes( szSISPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM );
    if ( !b ) {
        ErrorBox( hDlg, szSISPath );
        DebugMsg( "Could not mark SIS Common Store directory as hidden and system. Error: %u\n", GetLastError() );
    }

    //
    // Create the MaxIndex file.
    //
    wsprintf( szIndexFilePath, L"%s\\MaxIndex", szSISPath );
    hMaxIndex = CreateFile( szIndexFilePath,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
    if ( hMaxIndex == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szIndexFilePath );
        DebugMsg( "Can't create %s.\n", szIndexFilePath );
        goto Error;
    } else {
        DWORD bytesWritten;
        INDEX maxIndex = 1;

        if ( !WriteFile( hMaxIndex, &maxIndex, sizeof maxIndex, &bytesWritten, NULL )
          || ( bytesWritten < sizeof maxIndex ) ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szIndexFilePath );
            DebugMsg( "Can't write MaxIndex. Error: %u\n", GetLastError() );
            CloseHandle( hMaxIndex );
            goto Error;
        } else {
            CloseHandle( hMaxIndex );

            TraceMsg( TF_ALWAYS, "MaxIndex of %lu written\n", maxIndex );

            hr = S_OK;
        }
    }

    //
    // Set security information on the common store directory
    //

    //
    // build AccessEntry structure
    //

    ZeroMemory( &ExplicitEntries, sizeof(ExplicitEntries) );

    b = AllocateAndInitializeSid(
            &ntSidAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,0,
          /*2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,*/
            0, 0, 0, 0, 0, 0,
            &pAdminsSid );

    if ( !b || (pAdminsSid == NULL) ) {
        dw = GetLastError();
        hr = THR( HRESULT_FROM_WIN32( dw ) );
        MessageBoxFromError( hDlg, NULL, dw );
        goto Error;
    }

    BuildTrusteeWithSid( &ExplicitEntries.Trustee, pAdminsSid );
    ExplicitEntries.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitEntries.grfAccessMode = SET_ACCESS;
    ExplicitEntries.grfAccessPermissions = FILE_ALL_ACCESS;

    //
    // Set the Acl with the ExplicitEntry rights
    //
    dw = SetEntriesInAcl( 1,
                          &ExplicitEntries,
                          NULL,
                          &pAcl );
    if ( dw != ERROR_SUCCESS ) {
        hr = THR( HRESULT_FROM_WIN32(dw) );
        MessageBoxFromError( hDlg, NULL, dw );
        goto Error;
    }

    //
    // Create the Security Descriptor
    //
    InitializeSecurityDescriptor( &SecDescriptor, SECURITY_DESCRIPTOR_REVISION );

    if (!SetSecurityDescriptorDacl( &SecDescriptor, TRUE, pAcl, FALSE )) {
        dw = GetLastError();
        hr = THR( HRESULT_FROM_WIN32(dw) );
        MessageBoxFromError( hDlg, NULL, dw );
        goto Error;
    }

    //
    //  SET security on the Directory
    //

    dw = SetFileSecurity(szSISPath,
                         DACL_SECURITY_INFORMATION,
                         &SecDescriptor);

    if ( !dw )  {
        dw = GetLastError();
        hr = THR( HRESULT_FROM_WIN32(dw) );
        MessageBoxFromError( hDlg, szSISPath, dw );
        goto Error;
    }



Error:
    if ( pAdminsSid ) {
        FreeSid( pAdminsSid );
    }
    if ( pAcl ) {
        TraceFree( pAcl );
    }

    HRETURN(hr);
}


//
// CopyScreenFiles( )
//
HRESULT
CopyScreenFiles( HWND hDlg )
{
    HRESULT hr = S_OK;
    WCHAR   szText[ SMALL_BUFFER_SIZE ];
    WCHAR   szRembootPath[ MAX_PATH ];
    WCHAR   szScreenDirectory[ MAX_PATH ];
    WCHAR   szRemboot[ 14 ];
    UINT    uLineNum;
    HINF    hinf = INVALID_HANDLE_VALUE;
    DWORD   dwCount = 0;
    DWORD   dw;
    BOOL    b;
    INFCONTEXT context;
    HSPFILEQ Queue = INVALID_HANDLE_VALUE;
    HWND    hProg    = GetDlgItem( hDlg, IDC_P_METER );
    BOOL    fWarning = FALSE;
    MYCONTEXT MyContext;
    ZeroMemory( &MyContext, sizeof(MyContext) );

    TraceFunc( "CopyScreenFiles( ... )\n" );

    AssertMsg( !g_Options.fScreenLeaveAlone, "Should not have made it here with this flag set." );

    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 5000 ));
    SendMessage( hProg, PBM_SETPOS, 0, 0 );
    dw = LoadString( g_hinstance, IDS_BUILDINGLIST, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    dw = LoadString( g_hinstance, IDS_REMBOOTINF, szRemboot, ARRAYSIZE(szRemboot) );
    Assert( dw );

    Assert( g_Options.fLanguageSet );

    wcscpy( szRembootPath, g_Options.szInstallationPath );
    ConcatenatePaths( szRembootPath, g_Options.ProcessorArchitectureString);
    ConcatenatePaths( szRembootPath, szRemboot );
    Assert( wcslen( szRembootPath ) < ARRAYSIZE(szRembootPath) );
    DebugMsg( "REMINST.INF: %s\n", szRembootPath );

    wcscpy( szScreenDirectory, g_Options.szOSChooserPath );
    ConcatenatePaths( szScreenDirectory, g_Options.szLanguage );
    Assert( wcslen(szScreenDirectory) < ARRAYSIZE(szScreenDirectory) );
    DebugMsg( "Destination: %s\n", szScreenDirectory );

    hinf = SetupOpenInfFile( szRembootPath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szRembootPath );
        goto Cleanup;
    }

    Queue = SetupOpenFileQueue( );

    b = SetupFindFirstLine( hinf, L"OSChooser Screens", NULL, &context );
    if ( !b ) {
        ErrorBox( hDlg, szRembootPath );
        hr = THR(S_FALSE);
    }

    while ( b )
    {
        LPWSTR pszDest = NULL;
        WCHAR  szSrcPath[ MAX_PATH ];
        WCHAR  szDestPath[ MAX_PATH ];
        DWORD  dw;

        dw = SetupGetFieldCount( &context );

        if ( dw > 1 ) {
            b = SetupGetStringField( &context, 1, szDestPath, ARRAYSIZE( szDestPath ), NULL );
            AssertMsg( b, "REMINST: Missing field?" );
            if ( b ) {
                b = SetupGetStringField( &context, 2, szSrcPath, ARRAYSIZE(szSrcPath), NULL );
                AssertMsg( b, "REMINST: Missing field?" );
                pszDest = szDestPath;
            }
        } else {
            b = SetupGetStringField( &context, 1, szSrcPath, ARRAYSIZE(szSrcPath), NULL );
            AssertMsg( b, "REMINST: Missing field?" );
        }

        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        if ( g_Options.fScreenSaveOld ) {
            WCHAR szPath[ MAX_PATH ];
            WCHAR szMovePath[ MAX_PATH ];
            LPWSTR psz;
            DWORD  dwLen;

            if ( pszDest ) {
                wcscpy( szPath, szScreenDirectory );
                ConcatenatePaths( szPath, pszDest );                
            } else {
                wcscpy( szPath, szScreenDirectory );
                ConcatenatePaths( szPath, szSrcPath );                                
            }

            // Rename to *.BAK
            StrCpy( szMovePath, szPath );
            dwLen = lstrlen( szMovePath );
            Assert( StrCmpI( &szMovePath[ dwLen - 3 ], L"OSC" ) == 0 );
            StrCpy( &szMovePath[ dwLen - 3 ], L"BAK");

            DebugMsg( "Renaming %s to %s...\n", szPath, szMovePath );

            b = DeleteFile( szMovePath );
            b = MoveFile( szPath, szMovePath );
            if ( !b ) {
                DWORD dwErr = GetLastError( );
                switch ( dwErr )
                {
#if 0   // blast over files
                case ERROR_FILE_EXISTS:
                    if ( !fWarning ) {
                        MessageBoxFromStrings( hDlg,
                                               IDS_BACKUPSCREENFILEEXISTS_CAPTION,
                                               IDS_BACKUPSCREENFILEEXISTS_TEXT,
                                               MB_OK );
                        fWarning = TRUE;
                    }
#endif
                case ERROR_FILE_NOT_FOUND:
                    break; // ignore this error
                    // It is possible that the user deleted the source files (old OSCs).

                default:
                    MessageBoxFromError( hDlg, NULL, dwErr );
                    break;
                }
            }
        }

        b = SetupQueueCopy( Queue,
                            g_Options.szInstallationPath,
                            g_Options.ProcessorArchitectureString,
                            szSrcPath,
                            NULL,
                            NULL,
                            szScreenDirectory,
                            pszDest,
                            g_Options.fScreenOverwrite ?
                                SP_COPY_FORCE_NEWER | SP_COPY_WARNIFSKIP :
                                SP_COPY_NOOVERWRITE  | SP_COPY_WARNIFSKIP  );
        if ( !b ) {
            ErrorBox( hDlg, szSrcPath );
            hr = THR(S_FALSE);
            goto SkipIt;
        }

        dwCount++;

SkipIt:
        b = SetupFindNextLine( &context, &context );
    }

    //
    // This information will be passed to CopyFileCallback() as
    // the Context.
    //
    MyContext.nToBeCopied        = dwCount;
    MyContext.nCopied            = 0;
    MyContext.pContext           = SetupInitDefaultQueueCallback( hDlg );
    MyContext.hProg              = hProg;
    MyContext.hOperation         = GetDlgItem( hDlg, IDC_S_OPERATION );
    MyContext.hDlg               = hDlg;
    MyContext.fQuiet             = FALSE;
    MyContext.dwCopyingLength =
    LoadString( g_hinstance, IDS_COPYING, MyContext.szCopyingString, ARRAYSIZE(MyContext.szCopyingString));
    Assert(MyContext.dwCopyingLength);

    //
    // Start copying
    //
    if ( dwCount != 0 )
    {
        b = SetupCommitFileQueue( NULL,
                                  Queue,
                                  (PSP_FILE_CALLBACK) CopyFilesCallback,
                                  (PVOID) &MyContext );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, NULL );
            goto Cleanup;
        }
    }

Cleanup:
    SendMessage( hProg, PBM_SETPOS, 5000, 0 );
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );

    if ( MyContext.pContext )
        SetupTermDefaultQueueCallback( MyContext.pContext );

    if ( Queue != INVALID_HANDLE_VALUE )
        SetupCloseFileQueue( Queue );

    if ( hinf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( hinf );

    HRETURN( hr );
}


//
// UpdateRemoteInstallTree( )
//
HRESULT
UpdateRemoteInstallTree( )
{
    TraceFunc( "UpdateRemoteInstallTree( )\n" );

    HRESULT hr = S_OK;
    LRESULT lResult;
    HKEY    hkey;
    DWORD   dw;
    BOOL    b;
    HINF    hinf = INVALID_HANDLE_VALUE;
    WCHAR   szServerRemBootInfPath[ MAX_PATH ];
    WCHAR   szRemInstSetupPath[ MAX_PATH ];
    WCHAR   szRemoteInstallPath[ MAX_PATH ];
    WCHAR   szPath[ MAX_PATH ];
    UINT    uLineNum;
    INFCONTEXT context;

    //
    // Try finding TFTPD's regkey to find the IntelliMirror Directory
    //

    dw = LoadString( g_hinstance, IDS_TFTPD_SERVICE_PARAMETERS, szPath, ARRAYSIZE( szPath ));
    Assert( dw );

    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        szPath,
                                        0, // options
                                        KEY_QUERY_VALUE,
                                        &hkey ) ) {
        ULONG l;
        DWORD dwType;
        LONG lErr;

        l = sizeof(szRemoteInstallPath);
        lErr = RegQueryValueEx( hkey,
                                L"Directory",
                                0, // reserved
                                &dwType,
                                (LPBYTE) szRemoteInstallPath,
                                &l );
        if ( lErr == ERROR_SUCCESS ) {
            DebugMsg( "Found TFTPD's Directory regkey: %s\n", szRemoteInstallPath );
            // now add "OSChooser"
            wcscat( szRemoteInstallPath, L"\\OSChooser" );

            if ( 0xFFFFffff == GetFileAttributes( szRemoteInstallPath ) ) {
                DebugMsg( "%s - directory doesn't exist.\n", szRemoteInstallPath );
                hr = S_FALSE;
            }

        } else {
            hr = S_FALSE;
        }
        RegCloseKey( hkey );
    }
    else
    {
        hr = S_FALSE;
    }


    if ( hr == S_OK )
    {
        // make x:\winnt
        dw = ExpandEnvironmentStrings( TEXT("%SystemRoot%"), szServerRemBootInfPath, ARRAYSIZE( szServerRemBootInfPath ));
        Assert( dw );

        // make x:\winnt\system32
        dw = lstrlen( szServerRemBootInfPath );
        StrCpy( &szServerRemBootInfPath[dw], L"\\System32\\" );
        StrCpy( szRemInstSetupPath, szServerRemBootInfPath );

        // make x:\winnt\system32\reminst.inf
        dw = lstrlen( szServerRemBootInfPath );
        dw = LoadString( g_hinstance, IDS_REMBOOTINF, &szServerRemBootInfPath[dw], ARRAYSIZE( szServerRemBootInfPath ) - dw );
        Assert( dw );

        // make x:\winnt\system32\reminst
        wcscat( szRemInstSetupPath, L"reminst" );

        DebugMsg( "RemBoot.INF Path: %s\n", szServerRemBootInfPath );
        DebugMsg( "RemInst Setup Path: %s\n", szRemInstSetupPath );

        hinf = SetupOpenInfFile( szServerRemBootInfPath, NULL, INF_STYLE_WIN4, &uLineNum);
        if ( hinf != INVALID_HANDLE_VALUE ) {

            b = SetupFindFirstLine( hinf, L"OSChooser", NULL, &context );
            AssertMsg( b, "Missing section?" );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            }

        } else {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }
    }

    if ( hr == S_OK )
    {
        HSPFILEQ Queue;

        //
        // Create the Queue
        //
        Queue = SetupOpenFileQueue( );

        b = TRUE;
        while ( b )
        {
            WCHAR  szSrcFile[ MAX_PATH ];
            WCHAR  szDestFile[ MAX_PATH ];
            DWORD  dw;
            LPWSTR pszDest = NULL;

            dw = SetupGetFieldCount( &context );

            if ( dw > 1 ) {
                b = SetupGetStringField( &context, 1, szDestFile, ARRAYSIZE(szDestFile), NULL );
                AssertMsg( b, "Missing field?" );
                if ( b ) {
                    b = SetupGetStringField( &context, 2, szSrcFile, ARRAYSIZE(szSrcFile), NULL );
                    AssertMsg( b, "Missing field?" );
                    pszDest = szDestFile;
                }
            } else {
                b = SetupGetStringField( &context, 1, szSrcFile, ARRAYSIZE(szSrcFile), NULL );
                AssertMsg( b, "Missing field?" );
            }

            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                goto SkipIt;
            }

            b = SetupQueueCopy( Queue,
                                szRemInstSetupPath,
                                NULL,
                                szSrcFile,
                                NULL,
                                NULL,
                                szRemoteInstallPath,
                                pszDest,
                                SP_COPY_NEWER | SP_COPY_FORCE_NEWER
                                | SP_COPY_WARNIFSKIP | SP_COPY_SOURCEPATH_ABSOLUTE );
            if ( !b ) {
                THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            }

SkipIt:
            b = SetupFindNextLine( &context, &context );
        }

        b = SetupCommitFileQueue( NULL,
                                  Queue,
                                  SetupDefaultQueueCallback,
                                  SetupInitDefaultQueueCallback( NULL ) );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }

        SetupCloseFileQueue( Queue );
    }

    if ( hinf != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinf );
    }

    HRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\setup.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _SETUP_H_
#define _SETUP_H_

typedef struct _sSCPDATA {
    LPWSTR pszAttribute;
    LPWSTR pszValue;
} SCPDATA, * LPSCPDATA;

extern SCPDATA scpdata[];

HRESULT
BuildDirectories( void );

HRESULT
CreateDirectories( HWND hDlg );

HRESULT
CopyClientFiles( HWND hDlg );

HRESULT
ModifyRegistry( HWND hDlg );

HRESULT
StartRemoteBootServices( HWND hDlg );

HRESULT
CreateRemoteBootShare( HWND hDlg );

HRESULT
CreateRemoteBootServices( HWND hDlg );

HRESULT
CopyServerFiles( HWND hDlg );

HRESULT
CopyScreenFiles( HWND hDlg );

HRESULT
UpdateSIFFile( HWND hDlg );

HRESULT
CopyTemplateFiles( HWND hDlg );

HRESULT
CreateSISVolume( HWND hDlg );

HRESULT
CreateSCP( HWND hDlg );

HRESULT
RegisterDll( HWND hDlg, LPWSTR pszDLLPath );

HRESULT
UpdateRemoteInstallTree( );

#endif // _SETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\cpuhold\main.c ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <winsock2.h>
#include <ntexapi.h>
#include <devioctl.h>
#include <stdlib.h>
#include "cpuhold.h"

//
// Defines for moving pointers to proper alignment within a buffer
//
#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))


char GlobalBuffer[4096];

#define MEM_ALLOC_SIZE (1024 * 1024)

PVOID AllocatedMemory[10000];


//
// Routines defined below
//
BOOL
EnableDebugPriv(
    VOID
    );

//
//
// Main routine
//
//
int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    DWORD Error;
    DWORD BytesReturned;
    DWORD ProcessId;
    DWORD PrintMessage = 0;
    PPROCESS_PRIORITY_CLASS PriorityClass;
    char *NewBuffer;
    DCB Dcb;
    ULONG AllocsMade;
    ULONG i;
    KPRIORITY Priority;
    DWORD Bytes;
    UCHAR OutBuffer[512];

    
    //
    // Give ourselve God access if possible
    //
    if (!EnableDebugPriv()) {
        goto Exit;
    }

    //
    // Now try and bump up our priority so that we can lock people out.
    //
    PriorityClass = (PPROCESS_PRIORITY_CLASS)GlobalBuffer;
    PriorityClass = (PPROCESS_PRIORITY_CLASS)(ALIGN_UP_POINTER(PriorityClass, PROCESS_PRIORITY_CLASS));

    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessPriorityClass,
                                       PriorityClass,
                                       sizeof(PROCESS_PRIORITY_CLASS),
                                       NULL
                                      );

    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    PriorityClass->PriorityClass = PROCESS_PRIORITY_CLASS_REALTIME;

    Status = NtSetInformationProcess(NtCurrentProcess(),
                                     ProcessPriorityClass,
                                     PriorityClass,
                                     sizeof(PROCESS_PRIORITY_CLASS)
                                    );

    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Now try and bump up our priority so that we can lock people out
    //
    Priority = HIGH_PRIORITY - 1;
    Status = NtSetInformationThread(NtCurrentThread(),
                                    ThreadPriority,
                                    &Priority,
                                    sizeof(KPRIORITY)
                                   );

    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Write the message
    //
    Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE,
                           NULL,
                           MSG_CPUHOLD_START,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           OutBuffer,
                           ARRAYSIZE(OutBuffer),
                           NULL
                          );

    ASSERT(Bytes != 0);


    OutBuffer[Bytes] = '\0';
        
    printf("%s\n", OutBuffer);

    for (; 1;) {
    }

Exit:    
    return 0;
}





BOOL
EnableDebugPriv(
    VOID
    )

/*++

Routine Description:

    Changes the process's privilige so that kill works properly.

Arguments:


Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    HANDLE hToken;
    LUID DebugValue;
    PTOKEN_PRIVILEGES ptkp;

    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        return FALSE;
    }

    //
    // Enable the SE_DEBUG_NAME privilege.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL, SE_DEBUG_NAME, &DebugValue)) {
        return FALSE;
    }

    ptkp = (PTOKEN_PRIVILEGES)GlobalBuffer;

    ptkp->PrivilegeCount = 4;
    ptkp->Privileges[0].Luid = DebugValue;
    ptkp->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the INCREASE_BASE_PRIORITY privilege.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL, SE_INC_BASE_PRIORITY_NAME, &DebugValue)) {
        return FALSE;
    }

    ptkp->Privileges[1].Luid = DebugValue;
    ptkp->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the SHUTDOWN privilege.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL, SE_SHUTDOWN_NAME, &DebugValue)) {
        return FALSE;
    }

    ptkp->Privileges[2].Luid = DebugValue;
    ptkp->Privileges[2].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the QUOTA privilege.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL, SE_INCREASE_QUOTA_NAME, &DebugValue)) {
        return FALSE;
    }

    ptkp->Privileges[3].Luid = DebugValue;
    ptkp->Privileges[3].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken,
                               FALSE,
                               ptkp,
                               sizeof(TOKEN_PRIVILEGES) + (3 * sizeof(LUID_AND_ATTRIBUTES)),
                               (PTOKEN_PRIVILEGES) NULL,
                               (PDWORD) NULL)) {
        //
        // The return value of AdjustTokenPrivileges be texted
        //
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\utils.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("Utils");

#define SMALL_BUFFER_SIZE   1024

BOOL
x86DetermineSystemPartition(
    IN  HWND   ParentWindow,
    OUT PTCHAR SysPartDrive
    );

BOOLEAN
GetBuildNumberFromImagePath(
    PDWORD pdwVersion,
    PCWSTR SearchDir,
    PCWSTR SubDir OPTIONAL
    );


//
// Centers a dialog.
//
void
CenterDialog(
    HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen;
    int     cyScreen;

    SystemParametersInfo( SPI_GETWORKAREA, 0, &rcScreen, 0 );

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect( hwndDlg, &rc );

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ( ( cyScreen - cyDlg ) / 2 );
    x = rcScreen.left + ( ( cxScreen - cxDlg ) / 2 );

    SetWindowPos( hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE );
}

//
// Eats all mouse and keyboard messages.
//
void
ClearMessageQueue( void )
{
    MSG   msg;

    while ( PeekMessage( (LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST,
                PM_NOYIELD | PM_REMOVE ) );
}

//
// Create a message box from resource strings.
//
int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType )
{
    TCHAR szText[ SMALL_BUFFER_SIZE ];
    TCHAR szCaption[ SMALL_BUFFER_SIZE ];
    DWORD dw;

    dw = LoadString( g_hinstance, idsCaption, szCaption, ARRAYSIZE( szCaption ));
    Assert( dw );
    dw = LoadString( g_hinstance, idsText, szText, ARRAYSIZE( szText ));
    Assert( dw );

    return MessageBox( hParent, szText, szCaption, uType );
}

//
// Creates a error message box
//
void
MessageBoxFromError(
    HWND hParent,
    LPTSTR pszTitle,
    DWORD dwErr )
{
    WCHAR szText[ SMALL_BUFFER_SIZE ];
    LPTSTR lpMsgBuf;

    if ( dwErr == ERROR_SUCCESS ) {
        AssertMsg( dwErr, "Why was MessageBoxFromError() called when the dwErr == ERROR_SUCCES?" );
        return;
    }

    if ( !pszTitle ) {
        DWORD dw;
        szText[0] = L'\0';
        dw = LoadString( g_hinstance, IDS_ERROR, szText, ARRAYSIZE( szText ));
        Assert( dw );
        pszTitle = szText;
    }

    if (!FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL )) {
        lpMsgBuf = NULL;
    }

    if (lpMsgBuf == NULL) {
        AssertMsg( dwErr, "Getting error message failed.  Why?" );
        return;
    }

    MessageBox( hParent, lpMsgBuf, pszTitle, MB_OK | MB_ICONERROR );
    LocalFree( lpMsgBuf );
}

//
// Creates a error message box
//
void
ErrorBox(
    HWND hParent,
    LPTSTR pszTitle )
{
    DWORD dw;
    DWORD dwErr = GetLastError( );
    WCHAR szText[ SMALL_BUFFER_SIZE ];
    LPTSTR lpMsgBuf;

    if ( dwErr == ERROR_SUCCESS ) {
        AssertMsg( dwErr, "Why was MessageBoxFromError() called when the dwErr == ERROR_SUCCES?" );
        return;
    }

    if ( !pszTitle ) {
        DWORD dw;
        dw = LoadString( g_hinstance, IDS_ERROR, szText, ARRAYSIZE( szText ));
        Assert( dw );
        pszTitle = szText;
    }

    dw = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        dwErr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPTSTR) &lpMsgBuf,
                        0,
                        NULL );
    if ( dw != 0 )
    {
        MessageBox( hParent, lpMsgBuf, pszTitle, MB_OK | MB_ICONERROR );
        LocalFree( lpMsgBuf );
    }
    else
    {
        WCHAR szString[ 256 ];
        dw = LoadString( g_hinstance, IDS_UNDEFINED_ERROR_STRING, szString, ARRAYSIZE(szString));
        Assert( dw );
        wsprintf( szText, szString, dwErr );
        MessageBox( hParent, szText, pszTitle, MB_OK | MB_ICONERROR );
    }
}

VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    )
{
    static HFONT BigBoldFont = NULL;
    static HFONT BoldFont    = NULL;
    static HFONT NormalFont  = NULL;
    HFONT Font;
    LOGFONT LogFont;
    WCHAR FontSizeString[24];
    int FontSize;
    HDC hdc;

    switch(WhichFont) {

    case DlgFontTitle:

        if(!BigBoldFont) {

            if ( Font =
                (HFONT) SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0) )
            {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont) )
                {
                    DWORD dw = LoadString( g_hinstance,
                                           IDS_LARGEFONTNAME,
                                           LogFont.lfFaceName,
                                           LF_FACESIZE);
                    Assert( dw );

                    dw =       LoadString( g_hinstance,
                                           IDS_LARGEFONTSIZE,
                                           FontSizeString,
                                           ARRAYSIZE(FontSizeString));
                    Assert( dw );

                    FontSize = wcstoul( FontSizeString, NULL, 10 );

                    // make sure we at least have some basic font
                    if (*LogFont.lfFaceName == 0 || FontSize == 0) {
                       lstrcpy(LogFont.lfFaceName,TEXT("MS Shell Dlg") );
                       FontSize = 18;
                    }
                    
                    LogFont.lfWeight   = FW_BOLD;
                    
                    if ( hdc = GetDC(hdlg) )
                    {
                        LogFont.lfHeight =
                            0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                        BigBoldFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BigBoldFont;
        break;

    case DlgFontBold:

        if ( !BoldFont )
        {
            if ( Font =
                (HFONT) SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0 ))
            {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont ) )
                {

                    LogFont.lfWeight = FW_BOLD;

                    if ( hdc = GetDC( hdlg ) )
                    {
                        BoldFont = CreateFontIndirect( &LogFont );
                        ReleaseDC( hdlg, hdc );
                    }
                }
            }
        }
        Font = BoldFont;
        break;

    default:
        //
        // Nothing to do here.
        //
        Font = NULL;
        break;
    }

    if( Font )
    {
        SendDlgItemMessage( hdlg, ControlId, WM_SETFONT, (WPARAM) Font, 0 );
    }
}


//
// Adjusts and draws a bitmap transparently in the RECT prc.
//
void
DrawBitmap(
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis,
    LPRECT prc )
{
    TraceFunc( "DrawBitmap( ... )\n" );

    BITMAP  bm;
    HDC     hDCBitmap;
    int     dy;

    GetObject( hBitmap, sizeof(bm), &bm );

    hDCBitmap = CreateCompatibleDC( NULL );

    if (hDCBitmap == NULL) {
        return;
    }

    SelectObject( hDCBitmap, hBitmap );

    // center the image
    dy = 2 + prc->bottom - bm.bmHeight;

    StretchBlt( lpdis->hDC, prc->left, prc->top + dy, prc->right, prc->bottom,
          hDCBitmap, 0, 0, bm.bmWidth, bm.bmHeight, SRCAND );

    DeleteDC( hDCBitmap );

    TraceFuncExit( );
}

//
// Verifies that the user wanted to cancel setup.
//
BOOL
VerifyCancel( HWND hParent )
{
    TraceFunc( "VerifyCancel( ... )\n" );

    INT iReturn;
    BOOL fAbort = FALSE;

    iReturn = MessageBoxFromStrings( hParent,
                                     IDS_CANCELCAPTION,
                                     IDS_CANCELTEXT,
                                     MB_YESNO | MB_ICONQUESTION );
    if ( iReturn == IDYES ) {
        fAbort = TRUE;
    }

    SetWindowLongPtr( hParent, DWLP_MSGRESULT, ( fAbort ? 0 : -1 ));

    g_Options.fAbort = fAbort;

    RETURN(!fAbort);
}

//
// RetrieveWorkstationLanguageFromHive
//
HRESULT
RetrieveWorkstationLanguageFromHive( 
    HWND hDlg )
{
    TraceFunc( "RetrieveWorkstationLanguageFromHive( )\n" );

    HRESULT hr = S_FALSE;
    HINF hinf;
    WCHAR szFilepath[ MAX_PATH ];
    INFCONTEXT context;
    WCHAR szCodePage[ 32 ];
    ULONG uResult;
    BOOL b;
    UINT uLineNum;
    LPWSTR psz;

    //
    // build the path to hivesys.inf
    //
    wcscpy( szFilepath, g_Options.szSourcePath );
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString);
    ConcatenatePaths( szFilepath, L"hivesys.inf" );

    
    //
    // open the file
    //
    hinf = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        DWORD dwErr = GetLastError( );
        switch ( dwErr )
        {
        case ERROR_FILE_NOT_FOUND:
            MessageBoxFromStrings( hDlg, IDS_FILE_NOT_FOUND_TITLE, IDS_FILE_NOT_FOUND_TEXT, MB_OK );
            break;

        default:
            ErrorBox( hDlg, szFilepath );
            break;
        }
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Cleanup;
    }

    // Find the "AddReg" section
    b = SetupFindFirstLine( hinf, L"Strings", L"Install_Language", &context );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    b = SetupGetStringField( &context, 1, szCodePage, ARRAYSIZE(szCodePage), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    g_Options.dwWksCodePage = (WORD) wcstoul( szCodePage, &psz, 16 );
    DebugMsg( "Image CodePage = 0x%04x\n", g_Options.dwWksCodePage );

    uResult = GetLocaleInfo( PRIMARYLANGID(g_Options.dwWksCodePage), 
                             LOCALE_SENGLANGUAGE, 
                             g_Options.szLanguage, 
                             ARRAYSIZE(g_Options.szLanguage));
    if ( uResult == 0 ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }
    DebugMsg( "Image Language: %s\n", g_Options.szLanguage );

    // Success!
    g_Options.fLanguageSet = TRUE;
    hr = S_OK;

Cleanup:
    if ( hinf != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinf );
    }
    HRETURN(hr);
}


//
// CheckImageSource( )
//
HRESULT
CheckImageSource(
    HWND hDlg )
{
    TraceFunc( "CheckImageSource( ... )\n" );

    HRESULT hr = S_FALSE;
    WCHAR szFilepath[ MAX_PATH ];
    WCHAR szTemp[ 32 ];
    BYTE szPidExtraData[ 14 ];
    WORD CodePage;
    HINF hinf;
    UINT uResult;
    UINT uLineNum;
    DWORD dw;
    BOOL b;
    LPWSTR psz;
    INFCONTEXT context;

    //
    // build the path to hivesys.inf
    //
    wcscpy( szFilepath, g_Options.szSourcePath );
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString);
    ConcatenatePaths( szFilepath, L"txtsetup.sif" );
    
    //
    // open the file
    //
    hinf = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        DWORD dwErr = GetLastError( );
        switch ( dwErr )
        {
        case ERROR_FILE_NOT_FOUND:
            MessageBoxFromStrings( hDlg, IDS_FILE_NOT_FOUND_TITLE, IDS_FILE_NOT_FOUND_TEXT, MB_OK );
            break;

        default:
            ErrorBox( hDlg, szFilepath );
            break;
        }
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Cleanup;
    }

#if 0
    //
    // Allow server installs - adamba 2/21/00
    //

    b = SetupFindFirstLine( hinf, L"SetupData", L"ProductType", &context );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        if ( hr == ERROR_LINE_NOT_FOUND ) {
            MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_NOT_NT5_MEDIA_SOURCE_TEXT, MB_OK );
        } else {
            ErrorBox( hDlg, szFilepath );
        }
        goto Cleanup;
    }

    b = SetupGetStringField( &context, 1, szTemp, ARRAYSIZE(szTemp), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    if ( StrCmp( szTemp, L"0" ) )
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_WORKSTATION_TITLE, IDS_NOT_WORKSTATION_TEXT, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }
#endif

    b = SetupFindFirstLine( hinf, L"SetupData", L"Architecture", &context );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        if ( hr == ERROR_LINE_NOT_FOUND ) {
            MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_NOT_NT5_MEDIA_SOURCE_TEXT, MB_OK );
        } else {
            ErrorBox( hDlg, szFilepath );
        }
        goto Cleanup;
    }

    b = SetupGetStringField( &context, 1, szTemp, ARRAYSIZE(szTemp), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    if ( (StrCmp(szTemp,L"i386")) && (StrCmp(szTemp,L"ia64")) )
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_SUPPORTED_ARCHITECTURE_TITLE, IDS_NOT_SUPPORTED_ARCHITECTURE_TEXT, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }

    if (StrCmp(g_Options.ProcessorArchitectureString,szTemp))
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_SUPPORTED_ARCHITECTURE_TITLE, IDS_NOT_SUPPORTED_ARCHITECTURE_TEXT, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!g_Options.fLanguageOverRide) {
        hr = RetrieveWorkstationLanguageFromHive( hDlg );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if (!GetBuildNumberFromImagePath(
                        &g_Options.dwBuildNumber,
                        g_Options.szSourcePath, 
                        g_Options.ProcessorArchitectureString)) {
#if 0
        MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_NOT_NT5_MEDIA_SOURCE_TEXT, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
#else           
#endif
    }
    

    // Get image Major version
    b = SetupFindFirstLine( hinf, L"SetupData", L"MajorVersion", &context );
    if ( !b )
    {
        DWORD dwErr = GetLastError( );
        switch ( dwErr )
        {
        case ERROR_LINE_NOT_FOUND:
            MessageBoxFromStrings( hDlg, IDS_LINE_MISSING_CAPTION, IDS_LINE_MISSING_TEXT, MB_OK );
            break;

        default:
            ErrorBox( hDlg, szFilepath );
            break;
        }
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Cleanup;
    }
    b = SetupGetStringField( &context, 1, g_Options.szMajorVersion, ARRAYSIZE(g_Options.szMajorVersion), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    // Get image Minor version
    b = SetupFindFirstLine( hinf, L"SetupData", L"MinorVersion", &context );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }
    b = SetupGetStringField( &context, 1, g_Options.szMinorVersion, ARRAYSIZE(g_Options.szMinorVersion), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    // Get image description
    if ( !g_Options.fRetrievedWorkstationString  )
    {
        b = SetupFindFirstLine( hinf, L"SetupData", L"LoadIdentifier", &context );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        b = SetupGetStringField( 
                        &context, 
                        1, 
                        g_Options.szDescription, 
                        ARRAYSIZE(g_Options.szDescription), 
                        NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        // if this hasn't been substituted from the strings section, then 
        // do the lookup manually.  to do this skip and remove the "%"s
        if (g_Options.szDescription[0] == L'%' && 
            g_Options.szDescription[wcslen(g_Options.szDescription)-1] == L'%') {
            
            g_Options.szDescription[wcslen(g_Options.szDescription)-1] = L'\0';
            
            wcscpy(szTemp,&g_Options.szDescription[1]);
                   
            b = SetupFindFirstLine( 
                            hinf, 
                            L"Strings", 
                            szTemp, 
                            &context );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szFilepath );
                goto Cleanup;
            }
            b = SetupGetStringField( 
                            &context, 
                            1, 
                            g_Options.szDescription, 
                            ARRAYSIZE(g_Options.szDescription), 
                            NULL );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szFilepath );
                goto Cleanup;
            }            
        }
        
        DebugMsg( "Image Description: %s\n", g_Options.szDescription );


        b = SetupFindFirstLine( hinf, L"SetupData", L"DefaultPath", &context );
        if ( b )
        {
            b = SetupGetStringField( 
                        &context, 
                        1, 
                        szTemp, 
                        ARRAYSIZE(szTemp), 
                        NULL );

            if (b) {
                PWSTR p;
                p = wcschr( szTemp, '\\');
                if (p) {
                    p += 1;
                } else {
                    p = szTemp;
                }
                wcscpy( g_Options.szInstallationName, p );
                DebugMsg( "Image Path: %s\n", g_Options.szInstallationName );
            }
        }
    }

    SetupCloseInfFile( hinf );

    //
    // build the path to layout.inf
    //
    wcscpy( szFilepath, g_Options.szSourcePath );
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString);
    ConcatenatePaths( szFilepath, L"layout.inf" );

    //
    // open the file
    //
    hinf = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    if ( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ) {
        b = SetupFindFirstLine( hinf, L"SourceDisksNames.x86", L"1", &context );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
    }

    if ( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ) {
        b = SetupFindFirstLine( hinf, L"SourceDisksNames.ia64", L"1", &context );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
    }

    if ( b ) {
        b = SetupGetStringField( &context, 1, g_Options.szWorkstationDiscName, ARRAYSIZE(g_Options.szWorkstationDiscName), NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        DebugMsg( "Workstation Disc Name: %s\n", g_Options.szWorkstationDiscName );

        b = SetupGetStringField( &context, 2, g_Options.szWorkstationTagFile, ARRAYSIZE(g_Options.szWorkstationTagFile), NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        DebugMsg( "Workstation Tag File: %s\n", g_Options.szWorkstationTagFile);

        b = SetupGetStringField( &context, 4, g_Options.szWorkstationSubDir, ARRAYSIZE(g_Options.szWorkstationSubDir), NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        DebugMsg( "Workstation Sub Dir: %s\n", g_Options.szWorkstationSubDir );
    }

    SetupCloseInfFile( hinf );
    hinf = INVALID_HANDLE_VALUE;

    //
    // build the path to setupp.ini
    //
    wcscpy( szFilepath, g_Options.szSourcePath );
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString);
    ConcatenatePaths( szFilepath, L"setupp.ini" );    

    b = GetPrivateProfileStruct(L"Pid",
                                L"ExtraData",
                                szPidExtraData,
                                sizeof(szPidExtraData),
                                szFilepath);
    if ( !b )
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_SETUP_INI_MISSING_OR_INVALID, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // For a valid full (non-upgrade) PID, the fourth and sixth bytes
    // are odd.
    //
    if (((szPidExtraData[3] % 2) == 0) || ((szPidExtraData[5] % 2) == 0))
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_UPGRADE_VERSION_NOT_SUPPORTED, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    if ( hinf != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinf );
    }
    HRETURN(hr);
}

HRESULT
GetHelpAndDescriptionTextFromSif(
    OUT PWSTR HelpText,
    IN  DWORD HelpTextSizeInChars,
    OUT PWSTR DescriptionText,
    IN  DWORD DescriptionTextInChars
    )
{
    WCHAR szSourcePath[MAX_PATH*2];
    WCHAR TempPath[MAX_PATH];
    WCHAR TempFile[MAX_PATH];
    HINF hInf;
    UINT uLineNum;
    HRESULT hr;
    INFCONTEXT context;

    PCWSTR szFileName = L"ristndrd.sif" ;

    //
    // Create the path to the default SIF file
    //
    wsprintf( szSourcePath,
              L"%s\\%s",
              g_Options.szSourcePath,
              szFileName );
    Assert( wcslen( szSourcePath ) < ARRAYSIZE(szSourcePath));

    if (GetTempPath(ARRAYSIZE(TempPath), TempPath) &&
        GetTempFileName(TempPath, L"RIS", 0, TempFile ) &&
        SetupDecompressOrCopyFile( szSourcePath, TempFile, NULL ) == ERROR_SUCCESS) {
    
        //
        // first try INF_STYLE_WIN4, and if that fails, then try 
        // INF_STYLE_OLDNT (in case the inf doesn't have a [version] section.
        //
        hInf = SetupOpenInfFile( TempFile, NULL, INF_STYLE_WIN4, &uLineNum);
        if (hInf == INVALID_HANDLE_VALUE) {
            hInf = SetupOpenInfFile( TempFile, NULL, INF_STYLE_OLDNT, &uLineNum);
            if (hInf == INVALID_HANDLE_VALUE) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto e1;        
            }
        }
    
        if (!SetupFindFirstLine( hInf, L"OSChooser", L"Help", &context )) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto e2;
        }
    
        if (!SetupGetStringField(
                    &context, 
                    1,
                    HelpText, 
                    HelpTextSizeInChars, 
                    NULL )) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto e2;
        }
    
        if (!SetupFindFirstLine( hInf, L"OSChooser", L"Description", &context )) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto e2;
        }
    
        if (!SetupGetStringField(
                    &context, 
                    1,
                    DescriptionText, 
                    DescriptionTextInChars, 
                    NULL )) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto e2;
        }

    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto e0;
    }

    hr = S_OK;
    
e2:
    SetupCloseInfFile( hInf );
e1:
    DeleteFile( TempFile );
e0:
    return(hr);
}


//
// CheckIntelliMirrorDrive( )
//
HRESULT
CheckIntelliMirrorDrive(
    HWND hDlg )
{
    TraceFunc( "CheckIntelliMirrorDrive( )\n" );

    HRESULT hr = S_OK;
    LONG lResult;
    BOOL  b;
    DWORD dw;
    WCHAR sz[ MAX_PATH ];
    WCHAR szExpanded[ MAX_PATH ];
    WCHAR szBootDir[3];
    WCHAR szVolumePath[ MAX_PATH ];
    WCHAR szVolumeName[ MAX_PATH ];
    WCHAR szVolumePath2[ MAX_PATH ];
    WCHAR szVolumeName2[ MAX_PATH ];

    WCHAR szFileSystemType[ MAX_PATH ];
    UINT uDriveType;

    //
    // Get the real volume name for the target directory.
    //
    b = GetVolumePathName( g_Options.szIntelliMirrorPath, szVolumePath, ARRAYSIZE( szVolumePath ));
    if (b) {
        b = GetVolumeNameForVolumeMountPoint( szVolumePath, szVolumeName, ARRAYSIZE( szVolumeName ));
    }

    //
    // Make sure the device is not a removable media, CDROM, RamDisk, etc...
    // Only allow fixed disks.
    //
    if (b) {
        uDriveType = GetDriveType( szVolumeName );
    }
    if ( !b || (uDriveType != DRIVE_FIXED) ) 
    {
        MessageBoxFromStrings( hDlg,
                               IDS_FIXEDDISK_CAPTION,
                               IDS_FIXEDDISK_TEXT,
                               MB_OK | MB_ICONSTOP );
        goto Error;
    }

    //
    // Get the real volume name for the system volume (%windir%).
    //
    // Get the default path which happens to be the
    // SystemDrive:\IntelliMirror
    //
    dw = LoadString( g_hinstance, IDS_DEFAULTPATH, sz, ARRAYSIZE( sz ));
    Assert( dw );
    dw = ExpandEnvironmentStrings( sz, szExpanded, ARRAYSIZE( sz ));
    Assert( dw );

    b = GetVolumePathName( szExpanded, szVolumePath2, ARRAYSIZE( szVolumePath2 ));
    Assert( b );
    b = GetVolumeNameForVolumeMountPoint( szVolumePath2, szVolumeName2, ARRAYSIZE( szVolumeName2 ));
    Assert( b );

    //
    // Don't let the target directory volume be the same as the system volume.
    //
    if ( StrCmpI( szVolumeName, szVolumeName2 ) == 0 )
    {
        MessageBoxFromStrings( hDlg,
                               IDS_SAME_DRIVE_AS_SYSTEM_TITLE,
                               IDS_SAME_DRIVE_AS_SYSTEM_MESSAGE,
                               MB_OK | MB_ICONSTOP );
        goto Error;
    }

#ifdef _X86_
    //
    // See if the system partition (the one with boot.ini on it)
    // is the drive the user has selected. We can't allow this
    // either since SIS might hide boot.ini.
    //

    b = x86DetermineSystemPartition( NULL, &szBootDir[0] );
    if ( !b )
    {
        szBootDir[0] = L'C';
    }
    szBootDir[1] = L':';
    szBootDir[2] = L'\\';

    b = GetVolumePathName( szBootDir, szVolumePath2, ARRAYSIZE( szVolumePath2 ));
    Assert( b );
    b = GetVolumeNameForVolumeMountPoint( szVolumePath2, szVolumeName2, ARRAYSIZE( szVolumeName2 ));
    Assert( b );

    //
    // Don't let the target directory volume be the same as the boot volume.
    //
    if ( StrCmpI( szVolumeName, szVolumeName2 ) == 0 )
    {
        MessageBoxFromStrings( hDlg,
                               IDS_SAME_DRIVE_AS_BOOT_PARTITION_TITLE,
                               IDS_SAME_DRIVE_AS_BOOT_PARTITION,
                               MB_OK | MB_ICONSTOP );
        goto Error;
    }
#endif

    //
    // Check to see if the IMirror directory will live on an NTFS
    // file system.
    //
    b = GetVolumeInformation( szVolumeName,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              NULL,
                              szFileSystemType,
                              ARRAYSIZE( szFileSystemType ));
    if ( !b || StrCmpNI( szFileSystemType, L"NTFS", 4 ) != 0 ) {
        MessageBoxFromStrings( hDlg,
                               IDS_SHOULD_BE_NTFS_TITLE,
                               IDS_SHOULD_BE_NTFS_MESSAGE,
                               MB_OK | MB_ICONSTOP );
        goto Error;
    }

    if ( 0xFFFFffff != GetFileAttributes( g_Options.szIntelliMirrorPath ) )
    {
        INT iResult = MessageBoxFromStrings( hDlg,
                                             IDS_DIRECTORYEXISTS_CAPTION,
                                             IDS_DIRECTORYEXISTS_TEXT,
                                             MB_YESNO | MB_ICONQUESTION );
        if ( iResult == IDNO )
            goto Error;
    }

Cleanup:
    HRETURN(hr);

Error:
    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
    hr = E_FAIL;
    goto Cleanup;
}

VOID
ConcatenatePaths(
    IN OUT LPWSTR  Path1,
    IN     LPCWSTR Path2
    )
{
    BOOL NeedBackslash = TRUE;
    DWORD l = wcslen( Path1 );

    //
    // Determine whether we need to stick a backslash between the components.
    //

    if ( (l != 0) && (Path1[l-1] == L'\\') ) {
        NeedBackslash = FALSE;
    }

    if ( *Path2 == L'\\' ) {

        if ( NeedBackslash ) {

            NeedBackslash = FALSE;

        } else {

            //
            // Not only do we not need a backslash, but we need to eliminate
            // one before concatenating.
            //

            Path2++;
        }
    }

    if ( NeedBackslash ) {
        wcscat( Path1, L"\\" );
    }
    wcscat( Path1, Path2 );

    return;
}

//
// FindImageSource( )
//
HRESULT
FindImageSource(
    HWND hDlg )
{
    TraceFunc( "FindImageSource( )\n" );

    INT     i;
    HANDLE  hFile;
    WCHAR   szFilePath[ MAX_PATH ];

    //
    // Look for txtsetup.sif where we think the files are located.
    // txtsetup.sif is in an architecture-specific subdirectory.
    //
    wcscpy( szFilePath, g_Options.szSourcePath );
    ConcatenatePaths( szFilePath, g_Options.ProcessorArchitectureString );
    ConcatenatePaths( szFilePath, L"\\txtsetup.sif" );
    hFile = CreateFile( szFilePath, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
    if ( hFile != INVALID_HANDLE_VALUE ) 
    {
         CloseHandle( hFile );

         HRETURN(S_OK);
    }    

    HRETURN( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) );
}



HRESULT
GetSetRanFlag(
    BOOL bQuery,
    BOOL bClear
    )
/*++

Routine Description:

    Set's or Get's the state of a registry flag that indicates setup has been
    run before.

Arguments:

    bQuery - if TRUE, indicates that the registry flag should be queried
    bClear - only valid if bQuery is FALSE.  If this parameter is TRUE, 
             it indicates that the flag should be set to the cleared state.
             FALSE indicates that the flag should be set.

Return Value:

    HRESULT indicating outcome.

--*/
{
    LONG lResult;
    HKEY hkeySetup;
    HRESULT Result = E_FAIL;
    
    lResult = RegOpenKeyEx( 
                    HKEY_LOCAL_MACHINE, 
                    L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup", 
                    0, 
                    bQuery 
                     ? KEY_QUERY_VALUE 
                     : KEY_SET_VALUE, 
                    &hkeySetup);
        
    
    if ( lResult == ERROR_SUCCESS ) {
        DWORD dwValue = (bClear == FALSE) ? 1 : 0;
        DWORD cbValue = sizeof(dwValue);
        DWORD type;

        if (bQuery) {
            lResult = RegQueryValueEx( hkeySetup, L"RemInst", NULL, &type, (LPBYTE)&dwValue, &cbValue );            
            if (lResult == ERROR_SUCCESS) {
                Result = (dwValue == 1) 
                           ? S_OK 
                           : E_FAIL;
            } else {
                Result = HRESULT_FROM_WIN32(lResult);
            }
        } else {
            lResult = RegSetValueEx( hkeySetup, L"RemInst", NULL, REG_DWORD, (LPBYTE)&dwValue, cbValue );
            Result = HRESULT_FROM_WIN32(lResult);
        }
        

        RegCloseKey( hkeySetup );
        
    } else {
        Result = HRESULT_FROM_WIN32(lResult);
    }

    return(Result);
}

//
// GetNtVersionInfo( )
//
// Retrieves the build version from the kernel
//
BOOLEAN
GetBuildNumberFromImagePath(
    PDWORD pdwVersion,
    PCWSTR SearchDir,
    PCWSTR SubDir OPTIONAL
    )
{
    DWORD Error = ERROR_SUCCESS;
    DWORD FileVersionInfoSize;
    DWORD VersionHandle;
    ULARGE_INTEGER TmpVersion;
    PVOID VersionInfo;
    VS_FIXEDFILEINFO * FixedFileInfo;
    UINT FixedFileInfoLength;
    WCHAR Path[MAX_PATH];
    BOOLEAN fResult = FALSE;

    TraceFunc("GetNtVersionInfo( )\n");

    *pdwVersion = 0;

    //
    // build a path to the kernel
    //
    // Resulting string should be something like:
    //      "\\server\reminst\Setup\English\Images\nt50.wks\i386\ntoskrnl.exe"
    //
    if (!SearchDir) {
        goto e0;
    }
    wcscpy(Path, SearchDir);
    if (SubDir) {
        ConcatenatePaths( Path, SubDir );
    }
    ConcatenatePaths( Path, L"ntkrnlmp.exe");

    //
    // need to expand this file to local location to crack it
    //
    

    FileVersionInfoSize = GetFileVersionInfoSize(Path, &VersionHandle);
    if (FileVersionInfoSize == 0)
        goto e0;

    VersionInfo = LocalAlloc( LPTR, FileVersionInfoSize );
    if (VersionInfo == NULL)
        goto e0;

    if (!GetFileVersionInfo(
             Path,
             VersionHandle,
             FileVersionInfoSize,
             VersionInfo))
        goto e1;

    if (!VerQueryValue(
             VersionInfo,
             L"\\",
             (LPVOID*)&FixedFileInfo,
             &FixedFileInfoLength))
        goto e1;

    TmpVersion.HighPart = FixedFileInfo->dwFileVersionMS;
    TmpVersion.LowPart = FixedFileInfo->dwFileVersionLS;
    
    *pdwVersion = HIWORD(FixedFileInfo->dwFileVersionLS);

    fResult = TRUE;

e1:
    LocalFree( VersionInfo );
e0:
    RETURN( fResult );
}


VOID
GetProcessorType(
    )
/*++

Routine Description:

    This function will pre-populate the g_Options.ProcessorArchitectureString variable
    with a default value.  This value is based on the processor
    architecture we're currently running on.

    We'll use this value to determine which backing file should
    be used to generate the remote install flat image on the
    server.

Arguments:

    None.

Return Value:

    None.

--*/
{
SYSTEM_INFO si;

    if( g_Options.ProcessorArchitectureString[0] == TEXT('\0') ) {

        //
        // We haven't been initialized yet.
        //

        GetSystemInfo( &si );
        switch (si.wProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_IA64:
                g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                wcscpy( g_Options.ProcessorArchitectureString, L"ia64" );
                break;

            //
            // if we get here, assume it's x86
            //
            default:
                g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                wcscpy( g_Options.ProcessorArchitectureString, L"i386" );
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\cpuhold\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

cpuhold.mc : cpuhold.$(LANGUAGE)
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\i386\syspart.cpp ===
/*++

Copyright (c) 1993-1999 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

    Copied from winnt32 to risetup by ChuckL 12-May-1999

--*/

#include "pch.h"
#pragma hdrstop

#include <winioctl.h>

DEFINE_MODULE("SysPart");

#define MALLOC(_size) TraceAlloc(LPTR,(_size))
#define FREE(_p) TraceFree(_p)

UINT
MyGetDriveType(
    IN TCHAR Drive
    );

BOOL
IsNEC98(
    VOID
    );

#define WINNT_DONT_MATCH_PARTITION 0
#define WINNT_MATCH_PARTITION_NUMBER  1
#define WINNT_MATCH_PARTITION_STARTING_OFFSET  2

DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
);

DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
);

BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
);

BOOL
x86DetermineSystemPartition(
    IN  HWND   ParentWindow,
    OUT PTCHAR SysPartDrive
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    On Win95, we always return C:. For NT, read on.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    With there being differences in the IO system mapping and introduction of Volumes for NT 50
    this has now become complicated. Listed below are the algorithms
    
    
    NT 5.0 Beta 2 and above :
    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Go Through all of the volumes in the system with FindFirstVolume/FindNextVolume/FindVolumeClose.
        3. Take off the trailing backslash to the name returne to get \\?\Volume{guid}.
        4. IOCTL_STORAGE_GET_DEVICE_NUMBER with \\?\Volume{guid} => Check for FILE_DEVICE_DISK. Remember the partition number. Goto 6
        5. If IOCTL_STORAGE_GET_DEVICE_NUMBER fails then use IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS which returns a list of harddisks.  
           For each harddisk remember the starting offset and goto 6.
        6. Check Harddisk # by using \\.\PhysicalDrive# with IOCTL_DISK_GET_DRIVE_LAYOUT.  If the signature matches then this is the disk we boot from.
        7. To find the partition that we boot from we look for boot indicator. If we used 2 we try to match the partition number stored in 6 
           else if 3 we try to match the starting offset.Then you have a \\?\Volume{guid}\ name for the SYSTEM volume. 
        8. Call GetVolumeNameForVolumeMountPoint with A:\, B:\, C:\, ... and check the result of the form \\?\Volume{guid}\ against your match 
           to see what the drive letter is.
           
           Important: Since the *Volume* APIs are post Beta2 we do dynamic loading of kernel32.dll based on the build number returned.

    Versions below NT 5.0 Beta 2
                                                                                                                                    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Enumerate the \?? directory and look for all entries that begin with PhysicalDrive#. 
        3. For each of the Disks look for a match with the signature above and if they match then find out the partition number used to boot 
           using IOCTL_DISK_GET_DRIVE_LAYOUT and the BootIndicator bit.
        4. On finding the Boot partition create a name of the form \Device\Harddisk#\Partition#
        5. Then go through c:,d:...,z: calling QueryDosDeviceName and look for a match. That would be your system partition drive letter

    
    
Arguments:

    ParentWindow - supplies window handle for window to be the parent for
        any dialogs, etc.

    SysPartDrive - if successful, receives drive letter of system partition.

Return Value:

    Boolean value indicating whether SysPartDrive has been filled in.
    If FALSE, the user will have been infomred about why.

--*/

{
    TCHAR DriveName[4];
    BOOL  GotIt=FALSE;
    TCHAR Buffer[512];
    TCHAR Drive;
    BOOL b;
    TCHAR SysPartSig[20], PartitionNum[MAX_PATH], SysVolGuid[MAX_PATH];
    TCHAR DriveVolGuid[MAX_PATH];
    


    if(IsNEC98()) {
        if (!GetWindowsDirectory(Buffer,sizeof(Buffer)/sizeof(TCHAR))) {
            return(FALSE);
        }
        *SysPartDrive = Buffer[0];
        return(TRUE);
    }

    //Get signature from registry - Step 1 listed above
    
    if( (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\EisaAdapter"),SysPartSig) != ERROR_SUCCESS )
        && (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\MultiFunctionAdapter"),SysPartSig) != ERROR_SUCCESS ) ){  
        GotIt = FALSE;
        goto c0;
    }

    
        //Get the SystemVolumeGUID - steps 2 through 7 listed above ( Beta 2 and after )

        if( GetSystemVolumeGUID( SysPartSig, SysVolGuid ) != ERROR_SUCCESS ){  
            GotIt = FALSE;
            goto c0;
        }


    
    DriveName[1] = TEXT(':');
    
    // 
    //  Enumerate all drive letters and compare their device names
    //

    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {

        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

            DriveName[0] = Drive;

                DriveName[2] = '\\';
                DriveName[3] = 0;

                if((*GetVolumeNameForVolumeMountPoint)((LPWSTR)DriveName, (LPWSTR)DriveVolGuid, MAX_PATH*sizeof(TCHAR))){
                    if(!lstrcmp(DriveVolGuid, SysVolGuid) ){
                        GotIt = TRUE;       // Found it
                        break;
                    }


                }

        }
    }

    
    // This helps for some builds ~1500 < buildnum < 1877 that are in a tough spot

    if(!GotIt) {
        //
        // Strange case, just assume C:
        //
        GotIt = TRUE;
        Drive = TEXT('C');
    }


c0:
    if(GotIt) {
        *SysPartDrive = Drive;
    }
    return(GotIt);
}


DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
)

/*++

Routine Description:

    This routine enumerates all the volumes and if successful returns the \\?\Volume{guid} name for the system partition.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    SysVolGuid - If successful, will contain a name of form \\?\Volume{guid} for the System Partition (the one we use to boot)

Return Value:

    Returns NO_ERROR if successful, otherwise it contains the error code.
    

--*/
{

    HANDLE hVolume, h;
    TCHAR VolumeName[MAX_PATH];
    TCHAR driveName[30];
    BOOL b,ret, DoExtent, MatchFound;
    STORAGE_DEVICE_NUMBER   number;
    DWORD Err = NO_ERROR;
    DWORD cnt;
    PVOLUME_DISK_EXTENTS Extent = NULL;
    PDISK_EXTENT Start, i;
    DWORD ExtentSize, bytes;
    PVOID p;
    ULONG PartitionNumToCompare;
    LARGE_INTEGER StartingOffToCompare;

    
    //Enuberate all volumes

    hVolume = (*FindFirstVolume)( (LPWSTR)VolumeName, MAX_PATH );
    if( hVolume == INVALID_HANDLE_VALUE ){
        return GetLastError();
    }

    MatchFound = FALSE;

    do{

        //Remove trailing backslash

        DoExtent = FALSE;
            
        if( wcsrchr( VolumeName,TEXT('\\') ) ){
            *wcsrchr( VolumeName,TEXT('\\') ) = 0;
        }else{
            continue;
        }


        //Open the volume

        h = CreateFile(VolumeName, GENERIC_READ, FILE_SHARE_READ |
                       FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue; // Move on to next volume
        }

        //Get the disk number

        ret = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);

        if( !ret ){
            
            // Try using IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS if the above failed

            Extent = (PVOLUME_DISK_EXTENTS)MALLOC(1024);
            ExtentSize = 1024;
            if(!Extent) {
                CloseHandle( h );
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            
            
        
retry:
        
            ret = DeviceIoControl( h, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                    NULL,0,(PVOID)Extent,ExtentSize,&bytes,NULL);
        
            if(!ret) {
        
                if((Err=GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {
        
                    ExtentSize += 1024;
                    FREE(Extent);
                    if(Extent = (PVOLUME_DISK_EXTENTS)MALLOC(ExtentSize)) {
                        ;
                    } else {
                        CloseHandle( h );
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto cleanup;
                    }
                    goto retry;
                } else {
                    CloseHandle( h );
                    continue;
                }
            }else{
                DoExtent = TRUE;
            }

        }
        
        // Done with the handle this time around

        CloseHandle( h );

        if( !DoExtent ){

             //
            //  Check to see if this is a disk and not CDROM etc.
            //

            if( number.DeviceType == FILE_DEVICE_DISK ){
                
                // Remember the partition number
                PartitionNumToCompare = number.PartitionNumber;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), number.DeviceNumber );


                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&PartitionNumToCompare, WINNT_MATCH_PARTITION_NUMBER  ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
                
            }
            // Move on ..
            continue;
            
        }else{
            // Go through all disks and try for match

            Start = Extent->Extents;
            cnt = 0;      
            for( i = Start; cnt < Extent->NumberOfDiskExtents; i++ ){
                cnt++;
                // Remember the starting offset
                StartingOffToCompare = i->StartingOffset;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), i->DiskNumber );
                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&StartingOffToCompare, WINNT_MATCH_PARTITION_STARTING_OFFSET ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
            }
            
        }
        
        if( MatchFound )
            break;
        

    }while( (*FindNextVolume)( hVolume, (LPWSTR)VolumeName, MAX_PATH ));


cleanup:

    if( hVolume != INVALID_HANDLE_VALUE )
        (*FindVolumeClose)( hVolume );

    if( Extent != NULL ) {
        FREE(Extent);
    }
    return Err;



}



BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
)
/*++

Routine Description:

    This routine compares the given disk signature with the one for the specified physical disk.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    DriveName -  Physical Drive name of the form \\.\PhysicalDrive#
    
    Compare   -  A pointer to a storage variable. The type depends on the value of Action
    
    Action    -  Should be one of the following
                
                WINNT_DONT_MATCH_PARTITION - Once disk signatures match it returns the boot partition number in Compare. Compare should be a PULONG.
                       
                WINNT_MATCH_PARTITION_NUMBER - Once disk signatures match it tries to match the boot partition number with the number passed in
                                               through Compare. Compare should be PULONG.
                
                WINNT_MATCH_PARTITION_STARTING_OFFSET - Once disk signatures match it tries to match the boot partition starting offset with the 
                                                        starting offset number passed in through Compare. Compare should be PLARGE_INTEGER.

Return Value:

    Returns TRUE if successful in getting a match.
    

--*/

{

    TCHAR temp[30];
    BOOL b,Found = FALSE;
    PLARGE_INTEGER Starting_Off;
    PPARTITION_INFORMATION Start, i;
    HANDLE hDisk;
    PDRIVE_LAYOUT_INFORMATION DriveLayout = NULL;
    DWORD DriveLayoutSize;
    DWORD cnt;
    DWORD DataSize;
    PULONG Disk_Num;
    ULONG Sig;
    


    if(!Compare )
        return FALSE;

    if( (Action==WINNT_MATCH_PARTITION_STARTING_OFFSET) && Compare )
        Starting_Off = (PLARGE_INTEGER) Compare;
    else
        Disk_Num = (PULONG) Compare;
    




    // On any failure return FALSE



    //
    // Get drive layout info for this physical disk.
    // If we can't do this something is very wrong.
    //
    hDisk = CreateFile(
                DriveName,
                FILE_READ_ATTRIBUTES | FILE_READ_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    
    if(hDisk == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    //
    // Get partition information.
    //
    DriveLayout = (PDRIVE_LAYOUT_INFORMATION)MALLOC(1024);
    DriveLayoutSize = 1024;
    if(!DriveLayout) {
        goto cleanexit;
    }
    
    
retry:

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT,
            NULL,
            0,
            (PVOID)DriveLayout,
            DriveLayoutSize,
            &DataSize,
            NULL
            );

    if(!b) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            DriveLayoutSize += 1024;
            FREE(DriveLayout);
            if(DriveLayout = (PDRIVE_LAYOUT_INFORMATION)MALLOC(DriveLayoutSize)) {
                ;
            } else {
                goto cleanexit;
            }
            goto retry;
        } else {
            goto cleanexit;
        }
    }else{

        // Now walk the Drive_Layout to find the boot partition
        
        Start = DriveLayout->PartitionEntry;
        cnt = 0;

        /*
        _ultot( DriveLayout->Signature, temp, 16 );
        if( lstrcmpi( temp, Signature ) )
            goto cleanexit;
        */

        Sig = wcstoul( Signature, NULL, 16 ); 
        if( Sig != DriveLayout->Signature )
            goto cleanexit;

        for( i = Start; cnt < DriveLayout->PartitionCount; i++ ){
            cnt++;
            
            
            if( i->BootIndicator == TRUE ){
                if( Action == WINNT_DONT_MATCH_PARTITION ){
                    *Disk_Num = i->PartitionNumber;
                    Found = TRUE;
                    goto cleanexit;

                }


                if( Action == WINNT_MATCH_PARTITION_NUMBER ){
                    if( *Disk_Num == i->PartitionNumber ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }else{
                    if( Starting_Off->QuadPart == i->StartingOffset.QuadPart ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }
                
                break;
            }
            
        }



    }

cleanexit:

    if( hDisk != INVALID_HANDLE_VALUE )
        CloseHandle( hDisk );

    if( DriveLayout != NULL ) {
        FREE(DriveLayout);
    }


    return Found;
}











DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
)
/*++

Routine Description:

    This routine fetches the disk signature for the first disk that the BIOS sees. This has to be the disk that we boot from on x86s.
    It is at location <AdapterKeyName>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier

Arguments:

    Signature -  If successful will contain the signature of the disk we boot off from in Hex.

Return Value:

    Returns ERROR_SUCCESS if successful, otherwise it contains the error code.
    

--*/
{

    DWORD Err, dwSize;
    HKEY hkey, BusKey, Controller, SystemDiskKey;
    int busnumber;
    TCHAR BusString[20], Identifier[100];



    Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        AdapterKeyName,
                        0,
                        KEY_READ,
                        &hkey );

    if( Err != ERROR_SUCCESS )
        return Err;

    
    // Start enumerating the buses

    for( busnumber=0; ;busnumber++){

        wsprintf( BusString, TEXT("%d"), busnumber );

        Err = RegOpenKeyEx( hkey,
                        BusString,
                        0,
                        KEY_READ,
                        &BusKey );

        

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( hkey );
            return Err;
        }
        
        Err = RegOpenKeyEx( BusKey,
                        TEXT("DiskController"),
                        0,
                        KEY_READ,
                        &Controller );

        
        RegCloseKey(BusKey);        // Not needed anymore

        
        if( Err != ERROR_SUCCESS )  // Move on to next bus
            continue;

        RegCloseKey( hkey );        // Not needed anymore

        Err = RegOpenKeyEx( Controller,
                        TEXT("0\\DiskPeripheral\\0"),
                        0,
                        KEY_READ,
                        &SystemDiskKey );

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( Controller );
            return Err;
        }

        RegCloseKey( Controller );  // Not needed anymore


        dwSize = sizeof(Identifier);
        Err = RegQueryValueEx( SystemDiskKey,
                               TEXT("Identifier"),
                               NULL,
                               NULL,
                               (PBYTE) Identifier,
                               &dwSize);

        if( Err != ERROR_SUCCESS  ){
            RegCloseKey( SystemDiskKey );
            return Err;
        }

        if( Identifier && (lstrlen(Identifier) > 9 ) ){
            PWCHAR p;

            lstrcpy( Signature,Identifier+9);
            p = wcsrchr( Signature,TEXT('-') );
            if( p ) {
                *p = 0;
            }
            RegCloseKey( SystemDiskKey );
            return ERROR_SUCCESS;
        }
        else{
            RegCloseKey( SystemDiskKey );
            return Err;
        }


         
    }

    // Should never get here


    RegCloseKey( hkey );
    
    return ERROR_PATH_NOT_FOUND;
    

}





UINT
MyGetDriveType(
    IN TCHAR Drive
    )

/*++

Routine Description:

    Same as GetDriveType() Win32 API except on NT returns
    DRIVE_FIXED for removeable hard drives.

Arguments:

    Drive - supplies drive letter whose type is desired.

Return Value:

    Same as GetDriveType().

--*/

{
    TCHAR DriveNameNt[] = TEXT("\\\\.\\?:");
    TCHAR DriveName[] = TEXT("?:\\");
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type. If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    //
    DriveName[0] = Drive;
    rc = GetDriveType(DriveName);

    if((rc != DRIVE_REMOVABLE) || (Drive < L'C')) {
        return(rc);
    }

    //
    // DRIVE_REMOVABLE on NT.
    //

    //
    // Disallow use of removable media (e.g. Jazz, Zip, ...).
    //


    DriveNameNt[4] = Drive;

    hDisk = CreateFile(
                DriveNameNt,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk != INVALID_HANDLE_VALUE) {

        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                &MediaInfo,
                sizeof(MediaInfo),
                &DataSize,
                NULL
                );

        //
        // It's really a hard disk if the media type is removable.
        //
        if(b && (MediaInfo.MediaType == RemovableMedia)) {
            rc = DRIVE_FIXED;
        }

        CloseHandle(hDisk);
    }


    return(rc);
}

BOOL
IsNEC98(
    VOID
    )
{
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rbsetup.rc
//
#define IDS_APPNAME                     1
#define IDB_CHECK                       1
#define IDB_X                           2
#define IDB_ARROW                       3
#define IDS_CANCELCAPTION               4
#define IDS_CANCELTEXT                  5
#define IDS_DEFAULTPATH                 6
#define IDS_DIRECTORYEXISTS_CAPTION     7
#define IDS_DIRECTORYEXISTS_TEXT        8
#define IDS_BROWSECAPTION_RBDIR         11
#define IDS_BROWSECAPTION_SOURCEDIR     12
#define IDS_CLOSE                       16
#define IDS_DEFAULTSETUP                17
#define IDS_INVALIDSOURCECAPTION        20
#define IDS_INVALIDSOURCETEXT           21
#define IDS_INTELPATH                   22
#define IDS_ABORTING                    23
#define IDS_STARTING_SERVICES           26
#define IDS_CREATINGDIRECTORIES         28
#define IDS_REGISTRYFAILEDCAPTION       30
#define IDS_REGISTRYFAILEDTEXT          31
#define IDS_COPYING                     32
#define IDS_TFTPD                       33
#define IDS_TFTPD_SERVICENAME           34
#define IDS_BINL                        35
#define IDS_BINL_SERVICENAME            36
#define IDS_REMOTEBOOTSHAREREMARK       37
#define IDS_REMOTEBOOTSHARENAME         38
#define IDS_SHAREERRORCAPTION           39
#define IDS_CREATINGSHARES              41
#define IDS_TFTPD_PATH                  44
#define IDS_BINL_PATH                   45
#define IDS_UPDATING_REGISTRY           46
#define IDS_MUSTSELECTCAPTION           47
#define IDS_MUSTSELECTTEXT              48
#define IDS_ALPHAPATH                   49
#define IDS_LARGEFONTSIZE               52
#define IDS_LARGEFONTNAME               53
#define IDS_NORMALFONTNAME              55
#define IDS_X86                         56
#define IDS_AND                         57
#define IDS_IA64                        58
#define IDS_CREATINGDIRECTORYTREE       59
#define IDS_COPYINGFILES                60
#define IDS_UPDATINGREGISTRY            61
#define IDS_BUILDINGFILELIST            62
#define IDS_CREATING_SERVICES           63
#define IDS_COPYSERVERFILES             65
#define IDS_INSERTSERVER_CAPTION        67
#define IDS_INSERTSERVER                68
#define IDS_COPYTEMPLATEFILES           72
#define IDS_DEFAULT_SIF                 77
#define IDS_DEFAULT_DESCRIPTION         83
#define IDS_DEFAULT_HELPTEXT            84
#define IDS_UPDATING_SIF_FILE           85
#define IDS_OVERWRITE_CAPTION           86
#define IDS_OVERWRITE_TEXT              87
#define IDS_SAVE_SIF_TITLE              88
#define IDS_SIS                         90
#define IDS_SIS_SERVICENAME             91
#define IDS_SIS_PATH                    92
#define IDS_SIS_GROUP                   93
#define IDI_SETUP                       97
#define IDS_INTELLIMIRRORROOT_SUBTITLE  97
#define IDS_IMAGESOURCE_TITLE           98
#define IDB_TITLEPAGE                   99
#define IDS_IMAGESOURCE_SUBTITLE        99
#define IDD_WELCOME                     101
#define IDS_DEFAULTSIF_TITLE            102
#define IDD_IMAGESOURCE                 103
#define IDS_DEFAULTSIF_SUBTITLE         103
#define IDD_SUMMARY                     104
#define IDS_SUMMARY_SUBTITLE            104
#define IDS_MUST_REBOOT_TITLE           105
#define IDD_TASKS                       105
#define IDC_S_BOLD2                     105
#define IDS_MUST_REBOOT_MESSAGE         106
#define IDS_ALREADY_RUNNING_TITLE       107
#define IDD_OSDIRECTORY                 107
#define IDS_ALREADY_RUNNING_MESSAGE     108
#define IDB_HEADER                      109
#define IDS_SAME_DRIVE_AS_SYSTEM_TITLE  109
#define IDS_SAME_DRIVE_AS_SYSTEM_MESSAGE 110
#define IDD_DEFAULTSIF                  110
#define IDD_INTELLIMIRRORROOT           113
#define IDD_SCP                         117
#define IDD_OPTIONS                     118
#define IDD_SCREENS                     119
#define IDS_SUMMARY_TITLE               119
#define IDD_WARNING                     120
#define IDS_OSDIRECTORY_TITLE           120
#define IDS_OSDIRECTORY_SUBTITLE        121
#define IDD_SERVEROK                    121
#define IDS_INTELLIMIRRORROOT_TITLE     122
#define IDD_LANGUAGE                    122
#define IDS_OPTIONS_TITLE               123
#define IDD_WELCOME_ADD                 123
#define IDS_OPTIONS_SUBTITLE            124
#define IDD_WELCOME_CHECK               124
#define IDS_DRIVERSPATH                 125
#define IDD_EXAMINING_SERVER            125
#define IDS_SERVERNOTALLOWED_CAPTION    127
#define IDS_FIXEDDISK_CAPTION           129
#define IDS_FIXEDDISK_TEXT              130
#define IDS_CREATING_SIS_VOLUME         131
#define IDS_INTELLIMIRRORSCP            132
#define IDS_REMOVABLEDISK_CAPTION       133
#define IDS_REMOVABLEDISK_TEXT          134
#define IDS_SCP_TITLE                   135
#define IDS_SCP_SUBTITLE                136
#define IDS_TFTPD_SERVICE_PARAMETERS    137
#define IDS_REGISTER_IMADMIU_FAILED_CAPTION 139
#define IDS_REGISTER_IMADMIU_FAILED_TEXT 140
#define IDS_OSCHOOSER_SCREENS           142
#define IDS_INCOMPATIBLE_SERVER_VERSION_TITLE 143
#define IDS_INCOMPATIBLE_SERVER_VERSION_CAPTION 144
#define IDS_COMPATIBILITY               145
#define IDS_INF_SECTION                 146
#define IDS_REMBOOTINF                  147
#define IDS_SHOULD_BE_NTFS_TITLE        150
#define IDS_SHOULD_BE_NTFS_MESSAGE      151
#define IDS_MISSING_INF_TITLE           152
#define IDS_MISSING_INF_MESSAGE         153
#define IDS_WARNING_TITLE               154
#define IDS_WARNING_SUBTITLE            155
#define IDS_BINL_SERVICECONTROLPOINT    156
#define IDS_ERROR                       157
#define IDS_SCPCREATIONFAIL_CAPTION     158
#define IDS_SCPCREATIONFAIL_TEXT        159
#define IDS_UPDATINGSCREENS             160
#define IDS_BUILDINGLIST                161
#define IDS_SCREENS_TITLE               162
#define IDS_SCREENS_SUBTITLE            163
#define IDS_BACKUPSCREENFILEEXISTS_CAPTION 164
#define IDS_BACKUPSCREENFILEEXISTS_TEXT 165
#define IDS_UNDEFINED_ERROR_STRING      166
#define IDS_INSERT_MEDIA                167
#define IDS_SERVEROK_TITLE              168
#define IDS_SERVEROK_SUBTITLE           169
#define IDS_DOMAINMEMBERSHIP_TITLE      170
#define IDS_DOMAINMEMBERSHIP_TEXT       171
#define IDS_NOT_WORKSTATION_TITLE       172
#define IDS_NOT_WORKSTATION_TEXT        173
#define IDS_SISGROVELER_SERVICENAME     174
#define IDS_SISGROVELER_PATH            175
#define IDS_SISGROVELER_GROUP           176
#define IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TITLE 177
#define IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TEXT 178
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE 179
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT 180
#define IDS_BOOTP_FILENAME_LENGTH_RESTRICTION_TITLE 181
#define IDS_BOOTP_FILENAME_LENGTH_RESTRICTION_TEXT 182
#define IDS_UNKNOWN                     183
#define IDS_ADD                         184
#define IDS_CHECK                       185
#define IDS_NOT_RUNNING_ON_NT_SERVER_CAPTION 186
#define IDS_NOT_RUNNING_ON_NT_SERVER_TEXT 187
#define IDS_LANGUAGE_TITLE              188
#define IDS_LANGUAGE_SUBTITLE           189
#define IDS_LINE_MISSING_CAPTION        190
#define IDS_LINE_MISSING_TEXT           191
#define IDS_FILE_NOT_FOUND_TITLE        192
#define IDS_FILE_NOT_FOUND_TEXT         193
#define IDS_NOT_SUPPORTED_ARCHITECTURE_TITLE 194
#define IDS_NOT_SUPPORTED_ARCHITECTURE_TEXT 195
#define IDS_PATH_TOO_LONG_TITLE         196
#define IDS_PATH_TOO_LONG_TEXT          197
#define IDS_EXAMINING_TITLE             198
#define IDS_EXAMINING_SUBTITLE          199
#define IDS_NOT_NT5_MEDIA_SOURCE_TITLE  200
#define IDS_NOT_NT5_MEDIA_SOURCE_TEXT   201
#define IDS_EXPANDING_CABS              202
#define IDS_OSCHOOSER_ROOT_DIRECTORY_RESTRICTION_TITLE 203
#define IDS_OSCHOOSER_ROOT_DIRECTORY_RESTRICTION_TEXT 204
#define IDS_SAME_DRIVE_AS_BOOT_PARTITION 205
#define IDS_SAME_DRIVE_AS_BOOT_PARTITION_TITLE 206
#define IDS_COPYING_REMINST_TITLE       207
#define IDS_OPENING_SERVICE_MANAGER_TITLE 208
#define IDS_MUST_BE_ADMINISTRATOR_CAPTION 209
#define IDS_MUST_BE_ADMINISTRATOR_TEXT  210
#define IDS_SETUP_INI_MISSING_OR_INVALID 211
#define IDS_UPGRADE_VERSION_NOT_SUPPORTED 212
#define IDS_TFTPD_DESCRIPTION           213
#define IDS_BINL_DESCRIPTION            214
#define IDS_SISGROVELER_DESCRIPTION     215
#define IDS_USAGE                       216
#define IDS_AUTHORIZING_DHCP            217
#define IDS_AUTHORIZE_DHCP_FAILURE      218
#define IDS_RISETUP_STARTMENU_TITLE     219
#define IDS_RISETUP_STARTMENU_TOOLTIP   220
#define IDS_CHECK_SERVER_TITLE          221
#define IDC_L_SETUP                     1000
#define IDC_E_INTELLIMIRRORROOT         1001
#define IDC_E_IMAGESOURCE               1002
#define IDC_B_BROWSE                    1003
#define IDC_P_METER                     1004
#define IDC_E_LIMIT                     1004
#define IDC_S_OPERATION                 1005
#define IDC_C_X86                     1006
#define IDC_C_IA64                      1007
#define IDC_S_BOLD1                     1009
#define IDC_S_BOLD3                     1010
#define IDC_S_TITLE1                    1012
#define IDC_C_LIMITCLIENTS              1014
#define IDC_C_RESPOND                   1015
#define IDC_C_KNOWNCLIENTS              1016
#define IDC_C_ACCEPTSNEWCLIENTS         1022
#define IDC_E_OSDIRECTORY               1022
#define IDC_G_OPERATION                 1023
#define IDC_S_SOURCEPATH                1024
#define IDC_S_INTELLIMIRRORROOT         1026
#define IDC_S_PLATFORM                  1027
#define IDC_E_HELPTEXT                  1030
#define IDC_SPIN_LIMIT                  1031
#define IDC_S_OSDIRECTORY               1033
#define IDC_E_DESCRIPTION               1042
#define IDC_R_LEAVEALONE                1050
#define IDC_R_OVERWRITE                 1051
#define IDC_R_SAVEOLDFILES              1052
#define IDC_S_LANGUAGE                  1054
#define IDC_S_NTVERSION                 1055
#define IDC_B_ADD                       1057
#define IDC_B_CHECK                     1058

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        124
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1070
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\lib\makefile.inc ===
error.mc : error.$(LANGUAGE)
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\net\server\makefile.inc ===
rcmdmsg.mc : rcmdmsg.$(LANGUAGE)
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\inc\rcclib.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1999
   All rights reserved
 
 ***************************************************************************/

//
// Defines for moving pointers to proper alignment within a buffer
//
#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))



//
// Routines defined in the lib
//

DWORD
RCCLibInit(
    OUT PVOID *GlobalBuffer,
    OUT PULONG GlobalBufferSize
    );
    
VOID
RCCLibExit(
    IN PVOID GlobalBuffer,
    IN ULONG GlobalBufferSize
    );
    
DWORD
RCCLibIncreaseMemory(
    OUT PVOID *GlobalBuffer,
    OUT PULONG GlobalBufferCurrentSize
    );
    
DWORD
RCCLibGetTListInfo(
    OUT PRCC_RSP_TLIST ResponseBuffer,
    IN  LONG ResponseBufferSize,
    OUT PULONG ResponseDataSize
    );

DWORD
RCCLibKillProcess(
    DWORD Pid
    );

DWORD
RCCLibLowerProcessPriority(
    DWORD Pid
    );

DWORD
RCCLibLimitProcessMemory(
    DWORD ProcessId,
    DWORD MemoryLimit
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\lib\lib.c ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1999
   All rights reserved
 
 ***************************************************************************/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <winsock2.h>
#include <ntexapi.h>
#include <devioctl.h>
#include <stdlib.h>
#include <rccxport.h>
#include "rcclib.h"
#include "error.h"

//
// Defines for our internal memory, starting size and then buffers are grown by the increment
//
#define START_MEMORY_SIZE 0x100000
#define MEMORY_INCREMENT 0x1000

BOOL
EnableDebugPriv(
    IN PVOID GlobalBuffer
    );

DWORD
RCCLibReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );
    
HANDLE RCCLibSemHandle = NULL;

DWORD
RCCLibInit(
    OUT PVOID *GlobalBuffer,
    OUT PULONG GlobalBufferCurrentSize
    )
{
    NTSTATUS Status;
    DWORD Error;
    ULONG Priority;
    PPROCESS_PRIORITY_CLASS PriorityClass;
    
    //
    // Check if another copy of this exe is running already
    //
    RCCLibSemHandle = CreateSemaphore(NULL, 1, 1, "RCCLibSem");

    Error = GetLastError();

    if (RCCLibSemHandle == NULL) {
        RCCLibReportEventA(ERROR_RCCLIB_CREATE_SEM_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           sizeof(DWORD), 
                           NULL, 
                           &Error
                          );
        return ERROR_RCCLIB_CREATE_SEM_FAILED;
    }

    if (Error == ERROR_ALREADY_EXISTS) {
        CloseHandle(RCCLibSemHandle);
        RCCLibReportEventA(ERROR_RCCLIB_ALREADY_RUNNING, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           sizeof(DWORD), 
                           NULL, 
                           &Error
                          );
        return ERROR_RCCLIB_ALREADY_RUNNING;
    }

    //
    // Allocate memory for our buffers
    //
    *GlobalBuffer = LocalAlloc(LPTR, START_MEMORY_SIZE * sizeof(char));

    if (*GlobalBuffer == NULL) {
        CloseHandle(RCCLibSemHandle);
        RCCLibSemHandle = NULL;
        RCCLibReportEventA(ERROR_RCCLIB_INITIAL_ALLOC_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           0, 
                           NULL, 
                           NULL
                          );
        return ERROR_RCCLIB_INITIAL_ALLOC_FAILED;
    }

    *GlobalBufferCurrentSize = START_MEMORY_SIZE * sizeof(char);

    //
    // Give ourselve God access if possible
    //
    if (!EnableDebugPriv(*GlobalBuffer)) {
        LocalFree(*GlobalBuffer);
        CloseHandle(RCCLibSemHandle);
        RCCLibSemHandle = NULL;
        Error = GetLastError();
        RCCLibReportEventA(ERROR_RCCLIB_PRIVILEDGES_FAILED, 
                           EVENTLOG_WARNING_TYPE, 
                           0, 
                           sizeof(DWORD), 
                           NULL, 
                           &Error
                          );
        return Error;
    }


    //
    // Now try and bump up our priority so that we can guarantee service
    //
    PriorityClass = (PPROCESS_PRIORITY_CLASS)(*GlobalBuffer);
    PriorityClass = (PPROCESS_PRIORITY_CLASS)(ALIGN_UP_POINTER(PriorityClass, PROCESS_PRIORITY_CLASS));

    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessPriorityClass,
                                       PriorityClass,
                                       sizeof(PROCESS_PRIORITY_CLASS),
                                       NULL
                                      );

    if (!NT_SUCCESS(Status)) {
        LocalFree(*GlobalBuffer);
        CloseHandle(RCCLibSemHandle);
        RCCLibSemHandle = NULL;
        Error = RtlNtStatusToDosError(Status);
        RCCLibReportEventA(ERROR_RCCLIB_QUERY_PRIORITY_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           sizeof(DWORD), 
                           NULL, 
                           &Error
                          );
        return Error;
    }

    PriorityClass->PriorityClass = PROCESS_PRIORITY_CLASS_REALTIME;

    Status = NtSetInformationProcess(NtCurrentProcess(),
                                     ProcessPriorityClass,
                                     PriorityClass,
                                     sizeof(PROCESS_PRIORITY_CLASS)
                                    );

    if (!NT_SUCCESS(Status)) {
        LocalFree(*GlobalBuffer);
        CloseHandle(RCCLibSemHandle);
        RCCLibSemHandle = NULL;
        Error = RtlNtStatusToDosError(Status);
        RCCLibReportEventA(ERROR_RCCLIB_SET_PRIORITY_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           sizeof(DWORD), 
                           NULL, 
                           &Error
                          );
        return Error;
    }


    //
    // A *total* DaveC hack is that if you use ThreadBasePriority, and send
    // down (HIGH_PRIORITY + 1) / 2, this actually puts you at HIGH_PRIORITY
    // such that you cannot be bumped back down in priority...  NT trivia for you.
    //
    Priority = (HIGH_PRIORITY + 1) / 2; 
    Status = NtSetInformationThread(NtCurrentThread(),
                                    ThreadBasePriority,
                                    &Priority,
                                    sizeof(Priority)
                                   );

    if (!NT_SUCCESS(Status)) {
        
        //
        // Log an error!
        //
        Error = RtlNtStatusToDosError(Status);
        RCCLibReportEventA(ERROR_RCCLIB_SET_PRIORITY_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           sizeof(DWORD), 
                           NULL, 
                           &Error
                          );
        return Error;
    }
    
}

VOID
RCCLibExit(
    IN PVOID GlobalBuffer,
    IN ULONG GlobalBufferSize
    )
{
    if (RCCLibSemHandle != NULL) {
        CloseHandle(RCCLibSemHandle);
        RCCLibSemHandle = NULL;
    }
    
    if (GlobalBuffer != NULL) {
        LocalFree(GlobalBuffer);    
    }
}



DWORD
RCCLibReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //
    EventlogHandle = RegisterEventSourceW(NULL, L"RCCLib");

    if (EventlogHandle == NULL) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //
    if(!ReportEventA(EventlogHandle,
                     (WORD)EventType,
                     0,            // event category
                     EventID,
                     NULL,
                     (WORD)NumStrings,
                     DataLength,
                     Strings,
                     Data
                     )) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = ERROR_SUCCESS;

Cleanup:

    if (EventlogHandle != NULL) {
        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


BOOL
EnableDebugPriv(
    IN PVOID GlobalBuffer
    )

/*++

Routine Description:

    Changes the process's privilige so that kill works properly.

Arguments:


Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    HANDLE hToken;
    LUID DebugValue;
    PTOKEN_PRIVILEGES ptkp;

    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        return FALSE;
    }

    //
    // Enable the SE_DEBUG_NAME privilege.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL, SE_DEBUG_NAME, &DebugValue)) {
        return FALSE;
    }

    ptkp = (PTOKEN_PRIVILEGES)GlobalBuffer;

    ptkp->PrivilegeCount = 4;
    ptkp->Privileges[0].Luid = DebugValue;
    ptkp->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the INCREASE_BASE_PRIORITY privilege.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL, SE_INC_BASE_PRIORITY_NAME, &DebugValue)) {
        return FALSE;
    }

    ptkp->Privileges[1].Luid = DebugValue;
    ptkp->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the SHUTDOWN privilege.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL, SE_SHUTDOWN_NAME, &DebugValue)) {
        return FALSE;
    }

    ptkp->Privileges[2].Luid = DebugValue;
    ptkp->Privileges[2].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the QUOTA privilege.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL, SE_INCREASE_QUOTA_NAME, &DebugValue)) {
        return FALSE;
    }

    ptkp->Privileges[3].Luid = DebugValue;
    ptkp->Privileges[3].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken,
                               FALSE,
                               ptkp,
                               sizeof(TOKEN_PRIVILEGES) + (3 * sizeof(LUID_AND_ATTRIBUTES)),
                               (PTOKEN_PRIVILEGES) NULL,
                               (PDWORD) NULL)) {
        //
        // The return value of AdjustTokenPrivileges be texted
        //
        return FALSE;
    }

    return TRUE;
}




DWORD
RCCLibGetTListInfo(
    OUT PRCC_RSP_TLIST ResponseBuffer,
    IN  LONG ResponseBufferSize,
    OUT PULONG ResponseDataSize
    )
{
    DWORD Error;
    NTSTATUS Status;
    TIME_FIELDS UpTime;
    LARGE_INTEGER Time;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;

    PUCHAR DataBuffer;
    PUCHAR StartProcessInfo;
    LONG CurrentBufferSize;
    ULONG ReturnLength;
    ULONG TotalOffset;
        
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;

    *ResponseDataSize = 0;

    if (ResponseBufferSize < sizeof(ResponseBuffer)) {
        return(RtlNtStatusToDosError(STATUS_INFO_LENGTH_MISMATCH));
    }
    
    DataBuffer = (PUCHAR)(ResponseBuffer + 1);
    CurrentBufferSize = ResponseBufferSize - sizeof(RCC_RSP_TLIST);
    
    if (CurrentBufferSize < 0) {
        return ERROR_OUTOFMEMORY;
    }

    //
    // Get system-wide information
    //
    Status = NtQuerySystemInformation(SystemTimeOfDayInformation,
                                      &(ResponseBuffer->TimeOfDayInfo),
                                      sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        return(RtlNtStatusToDosError(Status));
    }

    Status = NtQuerySystemInformation(SystemBasicInformation,
                                      &(ResponseBuffer->BasicInfo),
                                      sizeof(SYSTEM_BASIC_INFORMATION),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        return(RtlNtStatusToDosError(Status));
    }

    //
    // Get pagefile information
    //
    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)DataBuffer;
    Status = NtQuerySystemInformation(SystemPageFileInformation,
                                      PageFileInfo,
                                      CurrentBufferSize,
                                      &ReturnLength
                                     );

    if (NT_SUCCESS(Status)) {

        ResponseBuffer->PagefileInfoOffset = ResponseBufferSize - CurrentBufferSize;
        CurrentBufferSize -= ReturnLength;
        DataBuffer += ReturnLength;
    
        if (CurrentBufferSize < 0) {
            return ERROR_OUTOFMEMORY;
        }

        //
        // Go thru each pagefile and fixup the names...
        //
        for (; ; ) {

            if (PageFileInfo->PageFileName.Length > CurrentBufferSize) {
                return(RtlNtStatusToDosError(STATUS_INFO_LENGTH_MISMATCH));
            }

            RtlCopyMemory(DataBuffer, 
                          (PUCHAR)(PageFileInfo->PageFileName.Buffer), 
                          PageFileInfo->PageFileName.Length
                         );

            PageFileInfo->PageFileName.Buffer = (PWSTR)(ResponseBufferSize - CurrentBufferSize);
            DataBuffer += PageFileInfo->PageFileName.Length;
            CurrentBufferSize -= PageFileInfo->PageFileName.Length;

            if (CurrentBufferSize < 0) {
                return ERROR_OUTOFMEMORY;
            }

            if (PageFileInfo->NextEntryOffset == 0) {
                break;
            }

            PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);
        }


    } else if (((ULONG)CurrentBufferSize) < ReturnLength) {
        
        return(RtlNtStatusToDosError(STATUS_INFO_LENGTH_MISMATCH));
     
    } else {

        ResponseBuffer->PagefileInfoOffset = 0;

    }

    //
    // Get process information
    //
    Status = NtQuerySystemInformation(SystemFileCacheInformation,
                                      &(ResponseBuffer->FileCache),
                                      sizeof(ResponseBuffer->FileCache),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        return(RtlNtStatusToDosError(Status));
    }


    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &(ResponseBuffer->PerfInfo),
                                      sizeof(ResponseBuffer->PerfInfo),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        return(RtlNtStatusToDosError(Status));
    }

    //
    // Realign DataBuffer for the next query
    //
    DataBuffer = ALIGN_UP_POINTER(DataBuffer, SYSTEM_PROCESS_INFORMATION);
    CurrentBufferSize = ResponseBufferSize - (((ULONG_PTR)DataBuffer) - ((ULONG_PTR)ResponseBuffer));
        
    if (CurrentBufferSize < 0) {
        return ERROR_OUTOFMEMORY;
    }


    Status = NtQuerySystemInformation(SystemProcessInformation,
                                      DataBuffer,
                                      CurrentBufferSize,
                                      &ReturnLength
                                     );

    if (!NT_SUCCESS(Status)) {
        return(RtlNtStatusToDosError(Status));
    }


    StartProcessInfo = DataBuffer;

    ResponseBuffer->ProcessInfoOffset = ResponseBufferSize - CurrentBufferSize;
    DataBuffer += ReturnLength;
    CurrentBufferSize -= ReturnLength;

    if (CurrentBufferSize < 0) {
        return ERROR_OUTOFMEMORY;
    }

    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)StartProcessInfo;

    while (TRUE) {

        //
        // We have to take the name of each process and change the UNICODE_STRING to an offset, copying
        // the name to later in the buffer.
        //
        if (ProcessInfo->ImageName.Buffer) {

            if (CurrentBufferSize < ProcessInfo->ImageName.Length) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            RtlCopyMemory(DataBuffer, (PUCHAR)(ProcessInfo->ImageName.Buffer), ProcessInfo->ImageName.Length);

            ProcessInfo->ImageName.Buffer = (PWSTR)(ResponseBufferSize - CurrentBufferSize);

            DataBuffer += ProcessInfo->ImageName.Length;
            CurrentBufferSize -= ProcessInfo->ImageName.Length;
            
            if (CurrentBufferSize < 0) {
                return ERROR_OUTOFMEMORY;
            }

        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&(StartProcessInfo[TotalOffset]);
    }

    *ResponseDataSize = (ULONG)(ResponseBufferSize - CurrentBufferSize);

    return ERROR_SUCCESS;
}


DWORD
RCCLibKillProcess(
    DWORD ProcessId
    )
{
    DWORD Error;
    HANDLE Handle;

    //
    // Try to open the process
    //
    Handle = OpenProcess(PROCESS_TERMINATE, FALSE, ProcessId);
    
    if (Handle == NULL) {
        return GetLastError();
    }

    //
    // Kill it
    //
    if (!TerminateProcess(Handle, 1)) {
        CloseHandle(Handle);
        return GetLastError();
    }

    //
    // All done
    //
    CloseHandle(Handle);
    return ERROR_SUCCESS;
}


DWORD
RCCLibLowerProcessPriority(
    DWORD ProcessId
    )
{
    DWORD Error;
    HANDLE JobHandle;
    HANDLE ProcessHandle;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ProposedLimits;
    TCHAR NameBuffer[50];
    BOOLEAN CreatedJobObject;
    DWORD ReturnedLength;

    //
    // Create the name for the job object
    //
    sprintf(NameBuffer, "RCCSrv%d", ProcessId);

    //
    // Try and open the existing job object
    //
    JobHandle = OpenJobObject(MAXIMUM_ALLOWED, FALSE, NameBuffer);

    if (JobHandle == NULL) {
        
        //
        // Try to open the process
        //
        ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);

        if (ProcessHandle == NULL) {
            return GetLastError();
        }

        //
        // Now try and create a job object to wrap around this process.
        //
        JobHandle = CreateJobObject(NULL, NameBuffer);

        if (JobHandle == NULL) {
            CloseHandle(ProcessHandle);
            return GetLastError();
        }

        CreatedJobObject = TRUE;

        //
        // Assign the process to this new job object.
        //
        if (!AssignProcessToJobObject(JobHandle, ProcessHandle)) {
            CloseHandle(ProcessHandle);
            goto ErrorExit;        
        }

        CloseHandle(ProcessHandle);

    } else {

        CreatedJobObject = FALSE;

    }

    //
    // Get the current set of limits
    //
    if (!QueryInformationJobObject(JobHandle, 
                                   JobObjectExtendedLimitInformation, 
                                   &ProposedLimits, 
                                   sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                                   &ReturnedLength
                                  )) {
        goto ErrorExit;
    }
    

    //
    // Change the scheduling class and priority fields
    //
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;
    ProposedLimits.BasicLimitInformation.PriorityClass = IDLE_PRIORITY_CLASS;
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_SCHEDULING_CLASS;
    ProposedLimits.BasicLimitInformation.SchedulingClass = 0;

    if (!SetInformationJobObject(JobHandle, 
                                 JobObjectExtendedLimitInformation, 
                                 &ProposedLimits, 
                                 sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
                                )) {
        goto ErrorExit;

    }


    //
    // All done - leave the job handle out there, so we can get to it later.
    //
    return ERROR_SUCCESS;

ErrorExit:

    if (CreatedJobObject) {
        CloseHandle(JobHandle);
    }
    return GetLastError();
}



DWORD
RCCLibLimitProcessMemory(
    DWORD ProcessId,
    DWORD MemoryLimit  // in number of KB allowed
    )
{
    DWORD Error;
    HANDLE JobHandle;
    HANDLE ProcessHandle;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ProposedLimits;
    TCHAR NameBuffer[50];
    BOOLEAN CreatedJobObject;
    DWORD ReturnedLength;

    //
    // Create the name for the job object
    //
    sprintf(NameBuffer, "RCCSrv%d", ProcessId);

    //
    // Try and open the existing job object
    //
    JobHandle = OpenJobObject(MAXIMUM_ALLOWED, FALSE, NameBuffer);

    if (JobHandle == NULL) {
        
        //
        // Try to open the process
        //
        ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);

        if (ProcessHandle == NULL) {
            return GetLastError();
        }

        //
        // Now try and create a job object to wrap around this process.
        //
        JobHandle = CreateJobObject(NULL, NameBuffer);

        if (JobHandle == NULL) {
            CloseHandle(ProcessHandle);
            return GetLastError();
        }

        CreatedJobObject = TRUE;

        //
        // Assign the process to this new job object.
        //
        if (!AssignProcessToJobObject(JobHandle, ProcessHandle)) {
            CloseHandle(ProcessHandle);
            goto ErrorExit;        
        }

        CloseHandle(ProcessHandle);

    } else {

        CreatedJobObject = FALSE;

    }

    //
    // Get the current set of limits
    //
    if (!QueryInformationJobObject(JobHandle, 
                                   JobObjectExtendedLimitInformation,
                                   &ProposedLimits, 
                                   sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                                   &ReturnedLength
                                  )) {
        goto ErrorExit;
    }
    

    //
    // Change the memory limits
    //
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
    ProposedLimits.ProcessMemoryLimit = MemoryLimit * 1024 * 1024;
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_JOB_MEMORY;
    ProposedLimits.JobMemoryLimit = MemoryLimit * 1024 * 1024;

    if (!SetInformationJobObject(JobHandle, 
                                 JobObjectExtendedLimitInformation,
                                 &ProposedLimits, 
                                 sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
                                )) {
        goto ErrorExit;

    }


    //
    // All done - leave the job handle out there, so we can get to it later.
    //
    return ERROR_SUCCESS;

ErrorExit:

    if (CreatedJobObject) {
        CloseHandle(JobHandle);
    }
    return GetLastError();
}


DWORD
RCCLibIncreaseMemory(
    OUT PVOID *GlobalBuffer,
    OUT PULONG GlobalBufferCurrentSize
    )
{
    NTSTATUS Status;
    PVOID NewBuffer;
    
    NewBuffer = VirtualAlloc(NULL, 
                             *GlobalBufferCurrentSize + MEMORY_INCREMENT,
                             MEM_COMMIT,
                             PAGE_READWRITE | PAGE_NOCACHE
                            );

    if (NewBuffer == NULL) {
        return ERROR_OUTOFMEMORY;
    }
    
    VirtualFree(*GlobalBuffer, *GlobalBufferCurrentSize, MEM_DECOMMIT);
    *GlobalBufferCurrentSize += MEMORY_INCREMENT;
    *GlobalBuffer = NewBuffer;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\serial\main.c ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <winsock2.h>
#include <ntexapi.h>
#include <devioctl.h>
#include <stdlib.h>
#include <rccxport.h>
#include "rcclib.h"
#include "error.h"

ULONG GlobalBufferCurrentSize;
char *GlobalBuffer = NULL;


ULONG GlobalCommandLineSize;
char *GlobalCommandLine = NULL;
ULONG GlobalReadIndex;

BOOL GlobalPagingNeeded = TRUE;
BOOL GlobalDoThreads = TRUE;


UCHAR *StateTable[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Wait:",
    "Transition",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *WaitTable[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "EventPairHigh",
    "EventPairLow",
    "LpcReceive",
    "LpcReply",
    "VirtualMemory",
    "PageOut",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *Empty = " ";


DWORD
RCCSrvReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );

DWORD
RCCSrvGetCommandLine(
    IN HANDLE ComPortHandle,
    OUT PBOOL ControlC
    );

DWORD 
RCCSrvPrintMsg(
    IN HANDLE ComPortHandle,
    IN DWORD MessageId,
    IN DWORD SystemErrorCode
    );
    
DWORD 
RCCSrvPrint(
    IN HANDLE ComPortHandle,
    IN PUCHAR Buffer,
    IN DWORD BufferSize
    );
    
VOID
RCCSrvPrintTListInfo(
    IN HANDLE ComPortHandle, 
    IN PRCC_RSP_TLIST Buffer
    );

VOID
RCCSrvPutMore(
    IN HANDLE ComPortHandle,
    OUT PBOOL ControlC
    );

BOOL
AreYouSure(
    IN HANDLE ComPortHandle
    );


//
//
// Main routine
//
//
int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    HANDLE ComPortHandle;
    HANDLE RCCHandle = NULL;
    DWORD Error;
    DWORD BytesReturned;
    DWORD ProcessId;
    DWORD PrintMessage = 0;
    char *NewBuffer;
    DWORD ThisProcessId;
    DWORD MemoryLimit;
    DWORD DataLength;
    PUCHAR ComPort;
    DCB Dcb;
    char *pch;
    char *pTemp;
    char Command;
    BOOL Abort;
    STRING String1, String2;

    //
    // Init the library
    //
    Error = RCCLibInit(&GlobalBuffer, &GlobalBufferCurrentSize);
    
    if (Error != ERROR_SUCCESS) {
        PrintMessage = ERROR_RCCSRV_LIB_INIT_FAILED;
        goto Exit;
    }


    //
    // Check for arguments
    //
    if ((argc > 3) ||
        ((argc > 1) && ((argv[1][0] == '-') || (argv[1][0] == '/')))) {
        PrintMessage = MSG_RCCSRV_USAGE;
        goto Exit;
    }



    //
    // Allocate memory for the command line
    //
    GlobalCommandLine = VirtualAlloc(NULL, 
                                     80 * sizeof(char), 
                                     MEM_COMMIT,
                                     PAGE_READWRITE | PAGE_NOCACHE
                                    );

    if (GlobalCommandLine == NULL) {
        //
        // Log an error!
        //
        RCCSrvReportEventA(ERROR_RCCSRV_INITIAL_ALLOC_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           0, 
                           NULL, 
                           NULL
                          );
        PrintMessage = MSG_RCCSRV_GENERAL_FAILURE;
        goto Exit;
    }

    GlobalCommandLineSize = 80 * sizeof(char);

    //
    // Remember our process ID, so people cannot kill us.
    //
    ThisProcessId = GetCurrentProcessId();

    //
    // Open the Remote Command Console driver
    //
    RCCHandle = CreateFile("\\\\.\\RCC",
                           GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,                    // create disposition.
                           0,
                           0
                          );

    if (RCCHandle == INVALID_HANDLE_VALUE) {
        RCCHandle = NULL;
        Error = GetLastError();
        RCCSrvReportEventA(ERROR_RCCSRV_OPEN_RCCDRIVER_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           0, 
                           NULL, 
                           NULL
                          );
    }

    //
    // Open the serial port
    //
    if (argc > 1) {
        ComPort = argv[1];
    } else {
        ComPort = "COM1";
    }
    ComPortHandle = CreateFile(ComPort,
                               GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                               0,
                               NULL,
                               OPEN_EXISTING,                    // create disposition.
                               0,
                               0
                              );

    if (ComPortHandle == INVALID_HANDLE_VALUE) {
        //
        // Log an error!
        //
        Error = GetLastError();
        RCCSrvReportEventA(ERROR_RCCSRV_OPEN_COMPORT_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           0, 
                           NULL, 
                           NULL
                          );
        PrintMessage = MSG_RCCSRV_GENERAL_FAILURE;
        goto Exit;
    }

    //
    // Set the serial port line characteristics
    //
    Dcb.DCBlength = sizeof(DCB);

    if (!GetCommState(ComPortHandle, &Dcb)) {
        //
        // Log an error!
        //
        Error = GetLastError();
        RCCSrvReportEventA(ERROR_RCCSRV_OPEN_COMPORT_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           0, 
                           NULL, 
                           NULL
                          );
        PrintMessage = MSG_RCCSRV_GENERAL_FAILURE;
        goto Exit;
    }

    if (argc > 2) {
        Dcb.BaudRate = atoi(argv[2]);
    } else {
        Dcb.BaudRate = 9600;
    }
    Dcb.ByteSize = 8;
    Dcb.Parity = NOPARITY;
    Dcb.StopBits = ONESTOPBIT;

    if (!SetCommState(ComPortHandle, &Dcb)) {
        //
        // Log an error!
        //
        Error = GetLastError();
        RCCSrvReportEventA(ERROR_RCCSRV_OPEN_COMPORT_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           0, 
                           NULL, 
                           NULL
                          );
        PrintMessage = MSG_RCCSRV_GENERAL_FAILURE;
        goto Exit;
    }


    while (1) {

        //
        // Write the prompt
        //
        Error = RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_PROMPT, 0);

        if (Error != ERROR_SUCCESS) {
            RCCSrvReportEventA(ERROR_RCCSRV_SEND_FAILED, 
                               EVENTLOG_ERROR_TYPE, 
                               0, 
                               sizeof(DWORD), 
                               NULL, 
                               &Error
                              );
            goto Exit;
        }

        //
        // Get any response.
        //
        Error = RCCSrvGetCommandLine(ComPortHandle, &Abort);

        if (Error != ERROR_SUCCESS) {
            RCCSrvReportEventA(ERROR_RCCSRV_RCV_FAILED, 
                               EVENTLOG_ERROR_TYPE, 
                               0, 
                               sizeof(DWORD), 
                               NULL, 
                               &Error
                              );
            goto Exit;
        }

        if (Abort) {
            continue;
        }


        //
        // It completed, so we have data in the buffer - verify it and process the message.
        //
        pch = GlobalCommandLine;
        while (((*pch == ' ') || (*pch == '\t')) && 
               (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
            pch++;
        }
        
        if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
            continue;
        }

        Command = *pch;

        switch (Command) {
            
            case 'c':
            case 'C':
            
                //
                // Compare the command
                //
                
                pTemp = pch;
                
                while ((*pch != '\0') && (*pch != ' ') && 
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                *pch = '\0';
                
                RtlInitString(&String1, "crashdump");
                
                RtlInitString(&String2, pTemp);

                if (!RtlEqualString(&String1, &String2, TRUE)) {
                
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_HELP, 0);
                    continue;

                }
                
                if (RCCHandle == NULL) {
                
                    RCCSrvPrintMsg(ComPortHandle, ERROR_RCCSRV_OPEN_RCCDRIVER_FAILED, 0);                    
                    
                } else {
                
                    //
                    // Send back an acknowledgement that we got the command before starting the crash.
                    //
                    if (AreYouSure(ComPortHandle)) {
                        RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_CRASHING, 0);

                        if (!DeviceIoControl(RCCHandle,
                                             CTL_CODE(FILE_DEVICE_NETWORK, 0x3, METHOD_NEITHER, FILE_ANY_ACCESS),
                                             NULL,
                                             0,
                                             NULL,
                                             0,
                                             &BytesReturned,
                                             NULL
                                             )) {
                            RCCSrvPrintMsg(ComPortHandle, ERROR_RCCSRV_CRASH_FAILED, 0);                    
                            
                        }
                        
                    }
                    
                }
                                
                break;


            case 'f':
            case 'F':
                //
                // Toggle paging
                //
                GlobalDoThreads = !GlobalDoThreads;
                if (GlobalDoThreads) {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_THREADS_ENABLED, 0);
                } else {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_THREADS_DISABLED, 0);
                }
                break;

            case 'k':
            case 'K':
                
                //
                // Skip to next argument (process id)
                //
                while ((*pch != ' ') &&
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                while ((*pch == ' ') &&
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                ProcessId = atoi(pch);
                
                if (ProcessId != ThisProcessId) {
                    Error = RCCLibKillProcess(ProcessId);
                } else {
                    Error = ERROR_INVALID_PARAMETER;
                }

                if (Error == ERROR_SUCCESS) {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_RESULT_SUCCESS, 0);
                } else {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_RESULT_FAILURE, Error);
                }
                break;

            case 'l':
            case 'L':
                
                //
                // Skip to next argument (process id)
                //
                while ((*pch != ' ') &&
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                while ((*pch == ' ') &&
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                ProcessId = atoi(pch);

                if (ProcessId != ThisProcessId) {
                    Error = RCCLibLowerProcessPriority(ProcessId);
                } else {
                    Error = ERROR_INVALID_PARAMETER;
                }

                if (Error == ERROR_SUCCESS) {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_RESULT_SUCCESS, 0);
                } else {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_RESULT_FAILURE, Error);
                }
                break;

            case 'm':
            case 'M':
                
                //
                // Skip to next argument (process id)
                //
                while ((*pch != ' ') &&
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                while ((*pch == ' ') &&
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                ProcessId = atoi(pch);
                //
                // Skip to next argument (kb-allowed)
                //
                while ((*pch != ' ') &&
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                while ((*pch == ' ') &&
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                MemoryLimit = atoi(pch);

                if (ProcessId != ThisProcessId) {
                    Error = RCCLibLimitProcessMemory(ProcessId, MemoryLimit);
                } else {
                    Error = ERROR_INVALID_PARAMETER;
                }

                if (Error == ERROR_SUCCESS) {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_RESULT_SUCCESS, 0);
                } else {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_RESULT_FAILURE, Error);
                }
                break;

            case 'p':
            case 'P':
                //
                // Toggle paging
                //
                GlobalPagingNeeded = !GlobalPagingNeeded;
                if (GlobalPagingNeeded) {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_PAGING_ENABLED, 0);
                } else {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_PAGING_DISABLED, 0);
                }
                break;

            case 'r':
            case 'R':

                //
                // Compare the command
                //
                
                pTemp = pch;
                
                while ((*pch != '\0') && (*pch != ' ') && 
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                *pch = '\0';
                
                RtlInitString(&String1, "reboot");
                
                RtlInitString(&String2, pTemp);

                if (!RtlEqualString(&String1, &String2, TRUE)) {
                
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_HELP, 0);
                    continue;

                }
                                
                //
                // Send back an acknowledgement that we got the command before starting the reboot.
                //
                if (AreYouSure(ComPortHandle)) {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_SHUTTING_DOWN, 0);
                    NtShutdownSystem(ShutdownReboot);
                }
                break;


            case 's':
            case 'S':

                //
                // Compare the command
                //
                
                RtlInitString(&String1, "shutdown");
                
                pTemp = pch;
                
                while ((*pch != '\0') && (*pch != ' ') && 
                       (pch < (GlobalCommandLine + GlobalCommandLineSize))) {
                    pch++;
                }
                
                if (pch >= (GlobalCommandLine + GlobalCommandLineSize)) {
                    continue;
                }
                
                *pch = '\0';
                
                RtlInitString(&String2, pTemp);

                if (!RtlEqualString(&String1, &String2, TRUE)) {
                
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_HELP, 0);
                    continue;

                }
                                
                //
                // Send back an acknowledgement that we got the command before starting the reboot.
                //
                if (AreYouSure(ComPortHandle)) {
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_SHUTTING_DOWN, 0);
                    NtShutdownSystem(ShutdownNoReboot);
                }
                break;


            case 't':
            case 'T':

RetryTList:
                Error = RCCLibGetTListInfo((PRCC_RSP_TLIST)GlobalBuffer, 
                                           (LONG)GlobalBufferCurrentSize, 
                                           &DataLength
                                          );

                //
                // Try to get more memory, if not available, then just fail without out of memory error.
                //
                if (Error == ERROR_OUTOFMEMORY) {

                    Error = RCCLibIncreaseMemory(&GlobalBuffer, &GlobalBufferCurrentSize);
                                         
                    if (Error == ERROR_SUCCESS) {
                        goto RetryTList;                            
                    }
                    
                    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_OUT_OF_MEMORY, 0);                       
                    break;
                    
                }

                RCCSrvPrintTListInfo(ComPortHandle, (PRCC_RSP_TLIST)GlobalBuffer);
                break;

            //
            // Help
            //
            case '?':
                RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_HELP, 0);
                break;


            default:
                RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_INVALID_COMMAND, 0);
                break;
        }
        
    }

Exit:

    if (PrintMessage != 0) {
    
        BytesReturned = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                          FORMAT_MESSAGE_FROM_HMODULE | 
                                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      NULL,
                                      PrintMessage,
                                      0,
                                      (LPTSTR)&NewBuffer,
                                      0,
                                      (va_list *)&Error
                                     );

        if (BytesReturned != 0) {
            printf(NewBuffer);
            LocalFree(NewBuffer);
        }
        
    }

    RCCLibExit(GlobalBuffer, GlobalBufferCurrentSize);    
    
    if (GlobalCommandLine != NULL) {
        VirtualFree(GlobalCommandLine, GlobalCommandLineSize, MEM_DECOMMIT);
    }
    
    if (RCCHandle != NULL) {
        NtClose(RCCHandle);
    }
    
    return 0;
}

DWORD
RCCSrvReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //
    EventlogHandle = RegisterEventSourceW(NULL, L"RCCSer");

    if (EventlogHandle == NULL) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //
    if(!ReportEventA(EventlogHandle,
                     (WORD)EventType,
                     0,            // event category
                     EventID,
                     NULL,
                     (WORD)NumStrings,
                     DataLength,
                     Strings,
                     Data
                     )) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = ERROR_SUCCESS;

Cleanup:

    if (EventlogHandle != NULL) {
        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


DWORD
RCCSrvGetCommandLine(
    IN HANDLE ComPortHandle,
    OUT PBOOL ControlC
    )
{
    DWORD Bytes;
    DWORD i;
    
    GlobalReadIndex = 0;

    *ControlC = FALSE;

    do {

        if (GlobalReadIndex == GlobalCommandLineSize) {
            GlobalReadIndex--;
        }

        //
        // Read a (possibly) partial command line.
        //
        if (!ReadFile(ComPortHandle, 
                      &(GlobalCommandLine[GlobalReadIndex]), 
                      1,
                      &Bytes, 
                      NULL
                     )) {

            return GetLastError();

        }

        if (GlobalCommandLine[GlobalReadIndex] == 0x3) {
            *ControlC = TRUE;
            return ERROR_SUCCESS;
        }

        if ((GlobalCommandLine[GlobalReadIndex] == 0x8) ||   // backspace (^h)
            (GlobalCommandLine[GlobalReadIndex] == 0x7F)) {  // delete
            if (GlobalReadIndex > 0) {
                WriteFile(ComPortHandle,
                          &(GlobalCommandLine[GlobalReadIndex]),
                          1,
                          &Bytes,
                          NULL
                          );
                GlobalReadIndex--;
            }            
        } else {
            WriteFile(ComPortHandle,
                      &(GlobalCommandLine[GlobalReadIndex]),
                      1,
                      &Bytes,
                      NULL
                      );
            GlobalReadIndex++;
        }
        
    } while ((GlobalReadIndex == 0) || (GlobalCommandLine[GlobalReadIndex - 1] != '\r'));

    GlobalCommandLine[GlobalReadIndex - 1] = '\0';
    
    RCCSrvPrint(ComPortHandle, "\n", sizeof("\n") - 1);
    
    return ERROR_SUCCESS;
}

DWORD 
RCCSrvPrintMsg(
    IN HANDLE ComPortHandle,
    IN DWORD MessageId,
    IN DWORD SystemErrorCode
    )
{
    DWORD Bytes;
    UCHAR OutBuffer[512];

    Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE,
                           NULL,
                           MessageId,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           OutBuffer,
                           ARRAYSIZE(OutBuffer)),
                           NULL
                          );

    ASSERT(Bytes != 0);

    if (MessageId == MSG_RCCSRV_PROMPT) {
        Bytes -= 2; // remove the \r\n that get added in .mc files
    }

    RCCSrvPrint(ComPortHandle, OutBuffer, Bytes);

    if (SystemErrorCode != 0) {

        Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
                               NULL,
                               SystemErrorCode,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                               OutBuffer,
                               ARRAYSIZE(OutBuffer),
                               NULL
                              );

        if (Bytes == 0) {
            Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE,
                                   NULL,
                                   MSG_RCCSRV_ERROR_NOT_DEFINED,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   OutBuffer,
                                   ARRAYSIZE(OutBuffer),
                                   (LPVOID)&SystemErrorCode
                                  );

            ASSERT(Bytes != 0);
        }

        RCCSrvPrint(ComPortHandle, OutBuffer, Bytes);
        RCCSrvPrint(ComPortHandle, "\r\n\r\n", sizeof("\r\n\r\n") - 1);
    }

    return ERROR_SUCCESS;
}
    
DWORD 
RCCSrvPrint(
    IN HANDLE ComPortHandle,
    IN PUCHAR Buffer,
    IN DWORD BufferSize
    )
{
    DWORD BytesWritten;

    if (!WriteFile(ComPortHandle, Buffer, BufferSize, &BytesWritten, NULL)) {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


VOID
RCCSrvPrintTListInfo(
    IN HANDLE ComPortHandle, 
    IN PRCC_RSP_TLIST Buffer
    )
{
    LARGE_INTEGER Time;
    
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS UpTime;
    
    ULONG TotalOffset;
    SIZE_T SumCommit;
    SIZE_T SumWorkingSet;

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;

    ULONG i;

    PUCHAR ProcessInfoStart;
    PUCHAR BufferStart = (PUCHAR)Buffer;

    ANSI_STRING pname;

    ULONG LineNumber = 0;

    UCHAR OutputBuffer[200];  // should never be more than 80, but just to be safe....

    BOOL Stop;
    
    
    
    Time.QuadPart = Buffer->TimeOfDayInfo.CurrentTime.QuadPart - Buffer->TimeOfDayInfo.BootTime.QuadPart;

    RtlTimeToElapsedTimeFields(&Time, &UpTime);

    sprintf(OutputBuffer,
            "memory: %4ld kb  uptime:%3ld %2ld:%02ld:%02ld.%03ld \r\n\r\n",
            Buffer->BasicInfo.NumberOfPhysicalPages * (Buffer->BasicInfo.PageSize / 1024),
            UpTime.Day,
            UpTime.Hour,
            UpTime.Minute,
            UpTime.Second,
            UpTime.Milliseconds
           );

    RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));

    LineNumber += 2;

    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)(BufferStart + Buffer->PagefileInfoOffset);
        
    //
    // Print out the page file information.
    //

    if (Buffer->PagefileInfoOffset == 0) {
    
        sprintf(OutputBuffer, "no page files in use\r\n");
        RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
        LineNumber++;
        
    } else {
    
        for (; ; ) {

            PageFileInfo->PageFileName.Buffer = (PWCHAR)(((PUCHAR)BufferStart) + 
                                                         (ULONG_PTR)(PageFileInfo->PageFileName.Buffer));

            sprintf(OutputBuffer, "PageFile: %wZ\r\n", &PageFileInfo->PageFileName);
            
            RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
            LineNumber++;
            
            sprintf(OutputBuffer, "\tCurrent Size: %6ld kb  Total Used: %6ld kb   Peak Used %6ld kb\r\n",
                    PageFileInfo->TotalSize * (Buffer->BasicInfo.PageSize/1024),
                    PageFileInfo->TotalInUse * (Buffer->BasicInfo.PageSize/1024),
                    PageFileInfo->PeakUsage * (Buffer->BasicInfo.PageSize/1024)
                   );
            
            RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
            LineNumber++;
            
            if (PageFileInfo->NextEntryOffset == 0) {
                break;
            }

            PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);

        }

    }

    //
    // display pmon style process output, then detailed output that includes
    // per thread stuff
    //
    if (Buffer->ProcessInfoOffset == 0) {
        return;
    }

    TotalOffset = 0;
    SumCommit = 0;
    SumWorkingSet = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);
    ProcessInfoStart = (PUCHAR)ProcessInfo;
    
    while (TRUE) {
        SumCommit += ProcessInfo->PrivatePageCount / 1024;
        SumWorkingSet += ProcessInfo->WorkingSetSize / 1024;
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart +TotalOffset);
    }

    SumWorkingSet += Buffer->FileCache.CurrentSize/1024;

    if (LineNumber > 17) {
        RCCSrvPutMore(ComPortHandle, &Stop);

        if (Stop) {
            return;
        }

        LineNumber = 0;
    }

    sprintf(OutputBuffer, 
            "\r\n Memory:%7ldK Avail:%7ldK  TotalWs:%7ldK InRam Kernel:%5ldK P:%5ldK\r\n",
            Buffer->BasicInfo.NumberOfPhysicalPages * (Buffer->BasicInfo.PageSize/1024),
            Buffer->PerfInfo.AvailablePages * (Buffer->BasicInfo.PageSize/1024),
            SumWorkingSet,
            (Buffer->PerfInfo.ResidentSystemCodePage + Buffer->PerfInfo.ResidentSystemDriverPage) * 
              (Buffer->BasicInfo.PageSize/1024),
            (Buffer->PerfInfo.ResidentPagedPoolPage) * (Buffer->BasicInfo.PageSize/1024)
           );
    
    RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
    LineNumber += 2;
    if (LineNumber > 18) {
        RCCSrvPutMore(ComPortHandle, &Stop);

        if (Stop) {
            return;
        }

        LineNumber = 0;
    }

    sprintf(OutputBuffer,
            " Commit:%7ldK/%7ldK Limit:%7ldK Peak:%7ldK  Pool N:%5ldK P:%5ldK\r\n",
            Buffer->PerfInfo.CommittedPages * (Buffer->BasicInfo.PageSize/1024),
            SumCommit,
            Buffer->PerfInfo.CommitLimit * (Buffer->BasicInfo.PageSize/1024),
            Buffer->PerfInfo.PeakCommitment * (Buffer->BasicInfo.PageSize/1024),
            Buffer->PerfInfo.NonPagedPoolPages * (Buffer->BasicInfo.PageSize/1024),
            Buffer->PerfInfo.PagedPoolPages * (Buffer->BasicInfo.PageSize/1024)
           );

    RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
    LineNumber++;
    if (LineNumber > 18) {
        RCCSrvPutMore(ComPortHandle, &Stop);

        if (Stop) {
            return;
        }

        LineNumber = 0;
    }


    sprintf(OutputBuffer, "\r\n");
    
    RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
    RCCSrvPutMore(ComPortHandle, &Stop);

    if (Stop) {
        return;
    }

    LineNumber = 0;

    sprintf(OutputBuffer, "    User Time   Kernel Time    Ws   Faults  Commit Pri Hnd Thd Pid Name\r\n");

    RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
    LineNumber++;

    sprintf(OutputBuffer,
            "                           %6ld %8ld                         %s\r\n",
            Buffer->FileCache.CurrentSize/1024,
            Buffer->FileCache.PageFaultCount,
            "File Cache"
           );

    RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
    LineNumber++;
    
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    while (TRUE) {

        pname.Buffer = NULL;
        if (ProcessInfo->ImageName.Buffer) {
            ProcessInfo->ImageName.Buffer = (PWCHAR)(BufferStart + (ULONG_PTR)(ProcessInfo->ImageName.Buffer));
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
        }

        RtlTimeToElapsedTimeFields(&ProcessInfo->UserTime, &UserTime);
        RtlTimeToElapsedTimeFields(&ProcessInfo->KernelTime, &KernelTime);

        sprintf(OutputBuffer, 
                "%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
                UserTime.Hour,
                UserTime.Minute,
                UserTime.Second,
                UserTime.Milliseconds,
                KernelTime.Hour,
                KernelTime.Minute,
                KernelTime.Second,
                KernelTime.Milliseconds
               );
        RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));

        sprintf(OutputBuffer, 
                "%6ld %8ld %7ld",
                ProcessInfo->WorkingSetSize / 1024,
                ProcessInfo->PageFaultCount,
                ProcessInfo->PrivatePageCount / 1024
               );
        RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));

        sprintf(OutputBuffer, 
                " %2ld %4ld %3ld %3ld %s\r\n",
                ProcessInfo->BasePriority,
                ProcessInfo->HandleCount,
                ProcessInfo->NumberOfThreads,
                HandleToUlong(ProcessInfo->UniqueProcessId),
                ProcessInfo->UniqueProcessId == 0 ? 
                    "Idle Process" : 
                   (ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
               );

        RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
        LineNumber++;
        if (LineNumber > 18) {
            RCCSrvPutMore(ComPortHandle, &Stop);

            if (Stop) {
                return;
            }

            LineNumber = 0;
            
            if (GlobalPagingNeeded) {
                sprintf(OutputBuffer, "    User Time   Kernel Time    Ws   Faults  Commit Pri Hnd Thd Pid Name\r\n");

                RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
            }

            LineNumber++;
        }

        if (pname.Buffer) {
            RtlFreeAnsiString(&pname);
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);
    }


    if (!GlobalDoThreads) {
        return;
    }

    //
    // Beginning of normal old style pstat output
    //

    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    RCCSrvPutMore(ComPortHandle, &Stop);

    if (Stop) {
        return;
    }

    LineNumber = 0;

    sprintf(OutputBuffer, "\r\n");
    RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
    LineNumber++;

    while (TRUE) {

        pname.Buffer = NULL;

        if (ProcessInfo->ImageName.Buffer) {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
        }

        sprintf(OutputBuffer, 
                "pid:%3lx pri:%2ld Hnd:%5ld Pf:%7ld Ws:%7ldK %s\r\n",
                HandleToUlong(ProcessInfo->UniqueProcessId),
                ProcessInfo->BasePriority,
                ProcessInfo->HandleCount,
                ProcessInfo->PageFaultCount,
                ProcessInfo->WorkingSetSize / 1024,
                ProcessInfo->UniqueProcessId == 0 ? "Idle Process" : (
                ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
               );

        RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
        LineNumber++;
        if (LineNumber > 18) {
            RCCSrvPutMore(ComPortHandle, &Stop);

            if (Stop) {
                return;
            }

            LineNumber = 0;
        }

        if (pname.Buffer) {
            RtlFreeAnsiString(&pname);
        }

        i = 0;
        
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        
        if (ProcessInfo->NumberOfThreads) {

            if ((LineNumber < 18) || !GlobalPagingNeeded) {
                sprintf(OutputBuffer, " tid pri Ctx Swtch StrtAddr    User Time  Kernel Time  State\r\n");
                RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
                LineNumber++;
            } else {
                RCCSrvPutMore(ComPortHandle, &Stop);

                if (Stop) {
                    return;
                }

                LineNumber = 0;
            }

        }

        while (i < ProcessInfo->NumberOfThreads) {
            RtlTimeToElapsedTimeFields ( &ThreadInfo->UserTime, &UserTime);

            RtlTimeToElapsedTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
            
            sprintf(OutputBuffer, 
                    " %3lx  %2ld %9ld %p",
                    ProcessInfo->UniqueProcessId == 0 ? 0 : HandleToUlong(ThreadInfo->ClientId.UniqueThread),
                    ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->Priority,
                    ThreadInfo->ContextSwitches,
                    ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->StartAddress
                   );
            RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));

            sprintf(OutputBuffer, 
                    " %2ld:%02ld:%02ld.%03ld %2ld:%02ld:%02ld.%03ld",
                    UserTime.Hour,
                    UserTime.Minute,
                    UserTime.Second,
                    UserTime.Milliseconds,
                    KernelTime.Hour,
                    KernelTime.Minute,
                    KernelTime.Second,
                    KernelTime.Milliseconds
                   );
            RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));

            sprintf(OutputBuffer, 
                    " %s%s\r\n",
                    StateTable[ThreadInfo->ThreadState],
                    (ThreadInfo->ThreadState == 5) ? WaitTable[ThreadInfo->WaitReason] : Empty
                   );
            
            RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
            LineNumber++;
            
            if (LineNumber > 18) {
                RCCSrvPutMore(ComPortHandle, &Stop);

                if (Stop) {
                    return;
                }

                LineNumber = 0;

                if (GlobalPagingNeeded) {
                    sprintf(OutputBuffer, " tid pri Ctx Swtch StrtAddr    User Time  Kernel Time  State\r\n");
                    RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
                }

                LineNumber++;
            }


            ThreadInfo += 1;
            i += 1;

        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);

        sprintf(OutputBuffer, "\r\n");
        RCCSrvPrint(ComPortHandle, OutputBuffer, strlen(OutputBuffer));
        LineNumber++;

        if (LineNumber > 18) {
            RCCSrvPutMore(ComPortHandle, &Stop);

            if (Stop) {
                return;
            }

            LineNumber = 0;
        }

    }

}


VOID
RCCSrvPutMore(
    IN HANDLE ComPortHandle,
    OUT PBOOL Stop
    )
{

    if (GlobalPagingNeeded) {
        RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_MORE, 0);
        RCCSrvGetCommandLine(ComPortHandle, Stop);
    } else {
        *Stop = FALSE;
    }

}


BOOL
AreYouSure(
    IN HANDLE ComPortHandle
    )
{
    BOOL Stop;

    RCCSrvPrintMsg(ComPortHandle, MSG_RCCSRV_ARE_YOU_SURE, 0);
    RCCSrvGetCommandLine(ComPortHandle, &Stop);

    if (!Stop && ((GlobalCommandLine[0] == 'y') || (GlobalCommandLine[0] == 'Y'))) {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\net\client\testexe\main.c ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <winsock2.h>
#include <rccxport.h>

//
// Begin current exe
//
BOOLEAN
ProcessCommandLine(
    IN HANDLE RCCHandle,
    IN char *Command
    );

VOID
PrintTListInfo(
    IN PRCC_RSP_TLIST Buffer
    );


UCHAR *StateTable[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Wait:",
    "Transition",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *WaitTable[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "EventPairHigh",
    "EventPairLow",
    "LpcReceive",
    "LpcReply",
    "VirtualMemory",
    "PageOut",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *Empty = " ";

char Buffer[102400];
WCHAR UBuffer[102400];

//
// main()
//
int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    char ch;
    int i;
    BOOLEAN ContinueProcessing = TRUE;
    HANDLE RCCHandle;

    if (RCCClntCreateInstance(&RCCHandle) != ERROR_SUCCESS) {
        return -1;
    }

    //
    // loop until user wants to quit.
    //

    while (ContinueProcessing) {

        printf("RCCClnt> ");
        
        //
        // Read a full line at a time
        //
        for (i=0; i < sizeof(Buffer); i++) {
            
            scanf("%c", &ch);

            if (ch == '\n') {
                break;
            }

            Buffer[i] = ch;

        }

        Buffer[i] = '\0';

        //
        // Process it
        //
        ContinueProcessing = ProcessCommandLine(RCCHandle, Buffer);

    }

    RCCClntDestroyInstance(&RCCHandle);
    return 1;
}


BOOLEAN
ProcessCommandLine(
    IN HANDLE RCCHandle,
    IN char *Command
    )
{
    char *pch;
    DWORD Error;
    ULONG ResultLength;
    int pid;
    DWORD Limit;

    //
    // Skip leading blanks
    //
    pch = Command;
    while (*pch == ' ') {
        pch++;
    }

    switch (*pch) {
        
        //
        // Crash dump
        //
        case 'b':
        case 'B':

            Error = RCCClntCrashDump(RCCHandle);

            if (Error == ERROR_SUCCESS) {
                printf("Crash in progress - connection closed.\n");
            }
            break;

        //
        // Connect
        //
        case 'c': 
        case 'C':

            //
            // Skip to next argument (machine name)
            //
            while (*pch != ' ') {
                pch++;
            }
            while (*pch == ' ') {
                pch++;
            }

            Error = RCCClntConnectToRCCPort(RCCHandle, pch);

            if (Error == ERROR_SUCCESS) {
                printf("Connected to %s successfully.\n", pch);
            }
            break;

        //
        // Kill
        //
        case 'k':
        case 'K':
            //
            // Skip to next argument (process id)
            //
            while (*pch != ' ') {
                pch++;
            }
            while (*pch == ' ') {
                pch++;
            }
            pid = atoi(pch);
            Error = RCCClntKillProcess(RCCHandle, (DWORD)pid);

            if (Error == ERROR_SUCCESS) {
                printf("Process %d killed successfully.\n", pid);
            }
            break;



        //
        // Lower priority of a process
        //
        case 'l':
        case 'L':
            //
            // Skip to next argument (process id)
            //
            while (*pch != ' ') {
                pch++;
            }
            while (*pch == ' ') {
                pch++;
            }
            pid = atoi(pch);
            Error = RCCClntLowerProcessPriority(RCCHandle, (DWORD)pid);

            if (Error == ERROR_SUCCESS) {
                printf("Process %d lowered successfully.\n", pid);
            }
            break;


        //
        // Limit the memory usage of a process
        //
        case 'm':
        case 'M':
            //
            // Skip to next argument (process id)
            //
            while (*pch != ' ') {
                pch++;
            }
            while (*pch == ' ') {
                pch++;
            }
            pid = atoi(pch);
            //
            // Skip to next argument (kb-allowed)
            //
            while (*pch != ' ') {
                pch++;
            }
            while (*pch == ' ') {
                pch++;
            }
            Limit = (DWORD)atoi(pch);
            Error = RCCClntLimitProcessMemory(RCCHandle, (DWORD)pid, Limit);

            if (Error == ERROR_SUCCESS) {
                printf("Process %d was successfully limited to %d MB of memory usage.\n", pid, Limit);
            }
            break;


        //
        // Reboot
        //
        case 'r':
        case 'R':

            Error = RCCClntReboot(RCCHandle);

            if (Error == ERROR_SUCCESS) {
                printf("Reboot in progress - connection closed.\n");
            }
            break;



        //
        // Quit
        //
        case 'q':
        case 'Q':
            return FALSE;



        //
        // Get a tlist on the remote computer.
        //
        case 't':
        case 'T':

            Error = RCCClntGetTList(RCCHandle, sizeof(Buffer), (PRCC_RSP_TLIST)Buffer, &ResultLength);

            if ((Error == ERROR_SUCCESS) && (ResultLength != 0)) {
                PrintTListInfo((PRCC_RSP_TLIST)Buffer);
            }
            break;
        
        //
        // Help
        //
        case '?':
            printf("b                    Crash dump the machine currently connected to.\n");
            printf("c <machine-name>     Connect to machine-name. Note: Attempting to connect\n");
            printf("                        to a second machine automatically closes any\n");
            printf("                        current connection.\n");
            printf("k <pid>              Kill the given process.\n");
            printf("l <pid>              Lower the priority of a process to the lowest possible.\n");
            printf("m <pid> <MB-allowed> Limit the memory usage of a process to MB-allowed megabytes.\n");
            printf("q                    Quit.\n");
            printf("r                    Reboot the machine currently connected to.\n");
            printf("t                    Get tlist from current connection.\n");
            break;

        default:
            printf("Unknown command.  Type '?' for help.\n");
            Error = 0;
            break;
    }

    if (Error != 0) {
        printf("Command returned Error = 0x%X\n", Error);
    }

    return TRUE;
}

VOID
PrintTListInfo(
    IN PRCC_RSP_TLIST Buffer
    )
{
    LARGE_INTEGER Time;
    
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS UpTime;
    
    ULONG TotalOffset;
    SIZE_T SumCommit;
    SIZE_T SumWorkingSet;

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;

    ULONG i;

    PUCHAR ProcessInfoStart;
    PUCHAR BufferStart = (PUCHAR)Buffer;

    ANSI_STRING pname;
    
    
    
    Time.QuadPart = Buffer->TimeOfDayInfo.CurrentTime.QuadPart - Buffer->TimeOfDayInfo.BootTime.QuadPart;

    RtlTimeToElapsedTimeFields(&Time, &UpTime);

    printf("memory: %4ld kb  uptime:%3ld %2ld:%02ld:%02ld.%03ld \n\n",
           Buffer->BasicInfo.NumberOfPhysicalPages * (Buffer->BasicInfo.PageSize / 1024),
           UpTime.Day,
           UpTime.Hour,
           UpTime.Minute,
           UpTime.Second,
           UpTime.Milliseconds
          );

    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)(BufferStart + Buffer->PagefileInfoOffset);
        
    //
    // Print out the page file information.
    //

    if (Buffer->PagefileInfoOffset == 0) {
        printf("no page files in use\n");
    } else {
        for (; ; ) {

            PageFileInfo->PageFileName.Buffer = (PWCHAR)(((PUCHAR)Buffer) + 
                                                         (ULONG_PTR)(PageFileInfo->PageFileName.Buffer));

            printf("PageFile: %wZ\n", &PageFileInfo->PageFileName);
            printf("\tCurrent Size: %6ld kb  Total Used: %6ld kb   Peak Used %6ld kb\n",
                   PageFileInfo->TotalSize * (Buffer->BasicInfo.PageSize/1024),
                   PageFileInfo->TotalInUse * (Buffer->BasicInfo.PageSize/1024),
                   PageFileInfo->PeakUsage * (Buffer->BasicInfo.PageSize/1024));
            if (PageFileInfo->NextEntryOffset == 0) {
                break;
            }
            PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);
        }
    }

    //
    // display pmon style process output, then detailed output that includes
    // per thread stuff
    //
    if (Buffer->ProcessInfoOffset == 0) {
        return;
    }

    TotalOffset = 0;
    SumCommit = 0;
    SumWorkingSet = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);
    ProcessInfoStart = (PUCHAR)ProcessInfo;
    
    while (TRUE) {
        SumCommit += ProcessInfo->PrivatePageCount / 1024;
        SumWorkingSet += ProcessInfo->WorkingSetSize / 1024;
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart +TotalOffset);
    }

    SumWorkingSet += Buffer->FileCache.CurrentSize/1024;
    printf("\n Memory:%7ldK Avail:%7ldK  TotalWs:%7ldK InRam Kernel:%5ldK P:%5ldK\n",
           Buffer->BasicInfo.NumberOfPhysicalPages * (Buffer->BasicInfo.PageSize/1024),
           Buffer->PerfInfo.AvailablePages * (Buffer->BasicInfo.PageSize/1024),
           SumWorkingSet,
           (Buffer->PerfInfo.ResidentSystemCodePage + Buffer->PerfInfo.ResidentSystemDriverPage) * 
             (Buffer->BasicInfo.PageSize/1024),
           (Buffer->PerfInfo.ResidentPagedPoolPage) * (Buffer->BasicInfo.PageSize/1024)
          );

    printf(" Commit:%7ldK/%7ldK Limit:%7ldK Peak:%7ldK  Pool N:%5ldK P:%5ldK\n",
           Buffer->PerfInfo.CommittedPages * (Buffer->BasicInfo.PageSize/1024),
           SumCommit,
           Buffer->PerfInfo.CommitLimit * (Buffer->BasicInfo.PageSize/1024),
           Buffer->PerfInfo.PeakCommitment * (Buffer->BasicInfo.PageSize/1024),
           Buffer->PerfInfo.NonPagedPoolPages * (Buffer->BasicInfo.PageSize/1024),
           Buffer->PerfInfo.PagedPoolPages * (Buffer->BasicInfo.PageSize/1024)
          );

    printf("\n");


    printf("    User Time   Kernel Time    Ws   Faults  Commit Pri Hnd Thd Pid Name\n");

    printf("                           %6ld %8ld                         %s\n",
           Buffer->FileCache.CurrentSize/1024,
           Buffer->FileCache.PageFaultCount,
           "File Cache"
          );

    
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    while (TRUE) {

        pname.Buffer = NULL;
        if (ProcessInfo->ImageName.Buffer) {

            ProcessInfo->ImageName.Buffer = (PWCHAR)(BufferStart + (ULONG_PTR)(ProcessInfo->ImageName.Buffer));
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
        }

        RtlTimeToElapsedTimeFields(&ProcessInfo->UserTime, &UserTime);
        RtlTimeToElapsedTimeFields(&ProcessInfo->KernelTime, &KernelTime);

        printf("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
               UserTime.Hour,
               UserTime.Minute,
               UserTime.Second,
               UserTime.Milliseconds,
               KernelTime.Hour,
               KernelTime.Minute,
               KernelTime.Second,
               KernelTime.Milliseconds
              );

        printf("%6ld %8ld %7ld",
               ProcessInfo->WorkingSetSize / 1024,
               ProcessInfo->PageFaultCount,
               ProcessInfo->PrivatePageCount / 1024
              );

        printf(" %2ld %4ld %3ld %3ld %s\n",
               ProcessInfo->BasePriority,
               ProcessInfo->HandleCount,
               ProcessInfo->NumberOfThreads,
               HandleToUlong(ProcessInfo->UniqueProcessId),
               ProcessInfo->UniqueProcessId == 0 ? 
                   "Idle Process" : 
                   (ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
              );

        if (pname.Buffer) {
            RtlFreeAnsiString(&pname);
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);
    }


    //
    // Beginning of normal old style pstat output
    //

    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    printf("\n");

    while (TRUE) {

        pname.Buffer = NULL;

        if (ProcessInfo->ImageName.Buffer) {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
        }

        printf("pid:%3lx pri:%2ld Hnd:%5ld Pf:%7ld Ws:%7ldK %s\n",
                HandleToUlong(ProcessInfo->UniqueProcessId),
                ProcessInfo->BasePriority,
                ProcessInfo->HandleCount,
                ProcessInfo->PageFaultCount,
                ProcessInfo->WorkingSetSize / 1024,
                ProcessInfo->UniqueProcessId == 0 ? "Idle Process" : (
                ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
                );

        if (pname.Buffer) {
            RtlFreeAnsiString(&pname);
        }

        i = 0;
        
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        
        if (ProcessInfo->NumberOfThreads) {
            printf(" tid pri Ctx Swtch StrtAddr    User Time  Kernel Time  State\n");
        }

        while (i < ProcessInfo->NumberOfThreads) {
            RtlTimeToElapsedTimeFields ( &ThreadInfo->UserTime, &UserTime);

            RtlTimeToElapsedTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
            
            printf(" %3lx  %2ld %9ld %p",
                   ProcessInfo->UniqueProcessId == 0 ? 0 : HandleToUlong(ThreadInfo->ClientId.UniqueThread),
                   ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->Priority,
                   ThreadInfo->ContextSwitches,
                   ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->StartAddress
                  );

            printf(" %2ld:%02ld:%02ld.%03ld %2ld:%02ld:%02ld.%03ld",
                   UserTime.Hour,
                   UserTime.Minute,
                   UserTime.Second,
                   UserTime.Milliseconds,
                   KernelTime.Hour,
                   KernelTime.Minute,
                   KernelTime.Second,
                   KernelTime.Milliseconds
                  );

            printf(" %s%s\n",
                   StateTable[ThreadInfo->ThreadState],
                   (ThreadInfo->ThreadState == 5) ? WaitTable[ThreadInfo->WaitReason] : Empty
                  );

            ThreadInfo += 1;
            i += 1;

        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);

        printf("\n");

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\net\client\rccclnt.c ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <winsock2.h>
#include <rccxport.h>


//
// Main entry routine
//
DWORD
RCCClntInitDll(
    HINSTANCE hInst,
    DWORD Reason,
    PVOID Context
    )

/*++

Routine Description:

    This routine simply returns TRUE.  Normally it would initialize all global information, but we have none.

Arguments:

    hInst - Instance that is calling us.

    Reason - Why we are being invoked.

    Context - Context passed for this init.

Return Value:

    TRUE if successful, else FALSE

--*/

{
    return(TRUE);
}




DWORD
RCCClntCreateInstance(
    OUT HANDLE *phHandle
    )

/*++

Routine Description:

    This routine creates a RCC_CLIENT instance, and returns a handle (pointer) to it.

Arguments:

    phHandle - A pointer to storage for storing a pointer to internal representation of a remote
        command port client.

Return Value:

    ERROR_SUCCESS if successful, else an appropriate error code.

--*/

{
    WORD Version;
    DWORD Error;
    WSADATA WSAData;
    PRCC_CLIENT Client;

    //
    // See if we can start up WinSock
    //
    Version = WINSOCK_VERSION;

    Error = WSAStartup(Version, &WSAData);

    if (Error != 0) {
        return WSAGetLastError();
    }

    if ((HIBYTE(WSAData.wVersion) != 2) || 
        (LOBYTE(WSAData.wVersion) != 2)) {
        WSACleanup();
        return ERROR_RMODE_APP;
    }

    //
    // Now get space for our internal data
    //
    Client =  LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(RCC_CLIENT));

    if (Client == NULL) {
        WSACleanup();
        return ERROR_OUTOFMEMORY;
    } 

    //
    // Init the data structure
    //
    Client->CommandSequenceNumber = 0;
    Client->MySocket = INVALID_SOCKET;
    Client->RemoteSocket = INVALID_SOCKET;

    *phHandle = (HANDLE)Client;

    return ERROR_SUCCESS;
}


VOID
RCCClntDestroyInstance(
    OUT HANDLE *phHandle
    )

/*++

Routine Description:

    This routine destroys a RCC_CLIENT instance, and NULLs the handle.

Arguments:

    phHandle - A pointer to previously created remote command port instance.

Return Value:

    None.

--*/

{
    PRCC_CLIENT Client = *((PRCC_CLIENT *)phHandle);


    if (Client == NULL) {
        return;
    }

    if (Client->MySocket != INVALID_SOCKET) {
        shutdown(Client->MySocket, SD_BOTH);
        closesocket(Client->MySocket);
    }
    
    if (Client->RemoteSocket != INVALID_SOCKET) {
        shutdown(Client->RemoteSocket, SD_BOTH);
        closesocket(Client->RemoteSocket);
    }

    LocalFree(Client);

    *phHandle = NULL;
}


DWORD
RCCClntConnectToRCCPort(
    IN HANDLE hHandle,
    IN PSTR MachineName
    )

/*++

Routine Description:

    This routine takes a previously created instance, and attempts to make a connection from it to 
    a remote command port on the given machine name.

Arguments:

    hHandle - A handle to a previously created instance.
    
    MachineName - An ASCII string of the machine to attempt to connect to.

Return Value:

    ERROR_SUCCESS if successful, else an appropriate error code.

--*/

{
    char InAddr[4];
    DWORD Error;
    struct sockaddr_in SockAddrIn;
    struct  hostent *HostAddr;
    PRCC_CLIENT Client = (PRCC_CLIENT)hHandle;

    //
    // Check handle
    //
    if (Client == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    HostAddr = gethostbyname(MachineName);

    if (HostAddr == NULL) {
        return WSAGetLastError();
    }

    if (HostAddr->h_addrtype != AF_INET) {
        return WSAGetLastError();
    }

    if (Client->RemoteSocket != INVALID_SOCKET) {
        shutdown(Client->RemoteSocket, SD_BOTH);
        closesocket(Client->RemoteSocket);
        Client->RemoteSocket = INVALID_SOCKET;
    }

    //
    // Make a socket descriptor
    //
    Client->MySocket = socket(PF_INET, SOCK_STREAM, 0);

    if (Client->MySocket == INVALID_SOCKET) {
        return WSAGetLastError();
    }

    //
    // Build the sockaddr_in structure
    //
    memset(&(SockAddrIn), 0, sizeof(SockAddrIn));
    SockAddrIn.sin_family = AF_INET;    

    //
    // Fill in the socket structure
    //
    Error = bind(Client->MySocket, (struct sockaddr *)(&SockAddrIn), sizeof(struct sockaddr_in));

    if (Error != 0) {
        closesocket(Client->MySocket);
        return WSAGetLastError();
    }
    
    //
    // Make a socket descriptor for connecting to client
    //
    Client->RemoteSocket = socket(PF_INET, SOCK_STREAM, 0);

    if (Client->RemoteSocket == INVALID_SOCKET) {
        closesocket(Client->MySocket);
        return WSAGetLastError();
    }

    //
    // Build the sockaddr_in structure for the remote site.
    //
    memset(&(SockAddrIn), 0, sizeof(SockAddrIn));
    memcpy(&(SockAddrIn.sin_addr), HostAddr->h_addr_list[0], HostAddr->h_length);
    SockAddrIn.sin_family = AF_INET;    
    SockAddrIn.sin_port = htons(385);

    //
    // Connect to the remote site
    //
    Error = connect(Client->RemoteSocket, (struct sockaddr *)(&SockAddrIn), sizeof(struct sockaddr_in));

    if (Error != 0) {
        closesocket(Client->MySocket);
        closesocket(Client->RemoteSocket);
        Client->RemoteSocket = INVALID_SOCKET;
        return WSAGetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD
GetResponse(
    IN PRCC_CLIENT Client,
    IN ULONG CommandCode,
    IN PUCHAR Buffer,
    IN ULONG BufferSize
    )

/*++

Routine Description:

    This routine reads from a socket until either (a) a full response is received for the command given,
    (b) a timeout occurs, or (c) too much data arrives (it is tossed out).

Arguments:

    Client - A remote command port client instance.
    
    CommandCode - The command code response to wait for.
    
    Buffer - Storage for the response.
    
    BufferSize - Size of Buffer in bytes.

Return Value:

    ERROR_SUCCESS if successful, else an appropriate error code.

--*/

{ 
    fd_set FdSet;
    struct timeval Timeout;
    int Count;
    DWORD Bytes;
    DWORD Error;
    ULONG TotalBytes;
    PRCC_RESPONSE Response;
    BOOLEAN BufferTooSmall = FALSE;
    char *DataBuffer;
    
    FD_ZERO(&FdSet);
    FD_SET(Client->RemoteSocket, &FdSet);

    while (1) {
        
        Timeout.tv_usec = 0;
        Timeout.tv_sec = 30;

        Count = select(0, &FdSet, NULL, NULL, &Timeout);

        if (Count == 0) {
            return WAIT_TIMEOUT;
        }

        Bytes = recv(Client->RemoteSocket, (char *)Buffer, BufferSize, 0);

        if (Bytes == SOCKET_ERROR) {
            return GetLastError();
        }

        Response = (PRCC_RESPONSE)Buffer;

        TotalBytes = Bytes;

        if ((Response->DataLength + sizeof(RCC_RESPONSE) - 1) > BufferSize) {
            BufferTooSmall = TRUE;
        }

        //
        // Receive the entire response.
        //
        while (TotalBytes < (Response->DataLength + sizeof(RCC_RESPONSE) - 1)) {

            if (BufferTooSmall) {
                DataBuffer = (char *)(Buffer + sizeof(RCC_RESPONSE)); // preserve the response data structure for getting the needed size later.
            } else {
                DataBuffer = (char *)(Buffer + TotalBytes);
            }
            
            Count = select(0, &FdSet, NULL, NULL, &Timeout);

            if (Count == 0) {
                return WAIT_TIMEOUT;
            }

            Bytes = recv(Client->RemoteSocket, 
                         DataBuffer, 
                         (BufferTooSmall ? (BufferSize - sizeof(RCC_RESPONSE)) : (BufferSize - TotalBytes)), 
                         0
                        );

            if (Bytes == SOCKET_ERROR) {
                return GetLastError();
            }

            TotalBytes += Bytes;

        }

        if (TotalBytes > (Response->DataLength + sizeof(RCC_RESPONSE) - 1)) {

            //
            // Something is weird here - we got more data than we expected, skip this message.
            //
            ASSERT(0);
            continue;

        }

        //
        // Check that this is the response we were looking for
        //
        if ((Response->CommandSequenceNumber == Client->CommandSequenceNumber) &&
            (Response->CommandCode == CommandCode)) {
                break;
        }

    }

    if (BufferTooSmall) {
        return SEC_E_BUFFER_TOO_SMALL;
    }

    return ERROR_SUCCESS;
}


DWORD
RCCClntGetTList(
    IN HANDLE hHandle,
    IN ULONG BufferSize,
    OUT PRCC_RSP_TLIST Buffer,
    OUT PULONG ResponseSize
    )

/*++

Routine Description:

    This routine submits a "TLIST" command to a remote machine via the remote command port, and then waits
    for a response.

Arguments:

    hHandle - A previously created instance.
    
    BufferSize - Size of Buffer in bytes.
    
    Buffer - The buffer for holding the response.
    
    ResponseSize - The number of bytes in buffer that were filled.  If BufferSize is too small, then this
       will contain the number of bytes needed.

Return Value:

    ERROR_SUCCESS if successful, else an appropriate error code.

--*/

{
    DWORD Error;
    PRCC_CLIENT Client = (PRCC_CLIENT)hHandle;
    PRCC_REQUEST Request;
    PRCC_RESPONSE Response;

    //
    // Check handle
    //
    if (Client == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Build the request
    //
    Request = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(RCC_REQUEST));
    if (Request == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    Request->CommandSequenceNumber = ++(Client->CommandSequenceNumber);
    Request->CommandCode = RCC_CMD_TLIST;
    Request->OptionLength = 0;
    Request->Options[0] = '\0';

    //
    // Send the request.
    //
    Error = send(Client->RemoteSocket, (char *)Request, sizeof(RCC_REQUEST) - 1 + Request->OptionLength, 0);

    if (Error == SOCKET_ERROR) {
        LocalFree(Request);
        return GetLastError();
    }

    //
    // Get the response.
    //
    Error = GetResponse(Client, RCC_CMD_TLIST, (PUCHAR)Buffer, BufferSize);
    
    Response = (PRCC_RESPONSE)Buffer;

    if (Error != ERROR_SUCCESS) {

        if (ERROR == SEC_E_BUFFER_TOO_SMALL) {
            *ResponseSize = Response->DataLength;
        }
        LocalFree(Request);
        return Error;
    }

    //
    // Extract the data
    //
    Error = Response->Error;
    *ResponseSize = Response->DataLength;
    RtlCopyMemory(Buffer, &(Response->Data[0]), Response->DataLength);

    LocalFree(Request);

    //
    // Return the status.
    //
    return Error;
}


DWORD
RCCClntKillProcess(
    IN HANDLE hHandle,
    IN DWORD ProcessId
    )

/*++

Routine Description:

    This routine submits a "KILL" command to a remote machine via the remote command port, and then waits
    for a response.

Arguments:

    hHandle - A previously created instance.
    
    ProcessId - The process id on the remote machine to kill.
    
Return Value:

    ERROR_SUCCESS if successful, else an appropriate error code.

--*/

{
    DWORD Error;
    PRCC_CLIENT Client = (PRCC_CLIENT)hHandle;
    PRCC_REQUEST Request;
    RCC_RESPONSE Response;

    //
    // Check handle
    //
    if (Client == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Build the request
    //
    Request = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(RCC_REQUEST));
    if (Request == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    Request->CommandSequenceNumber = ++(Client->CommandSequenceNumber);
    Request->CommandCode = RCC_CMD_KILL;
    Request->OptionLength = sizeof(DWORD);
    RtlCopyMemory(&(Request->Options[0]), &ProcessId, sizeof(DWORD));

    //
    // Send the request.
    //
    Error = send(Client->RemoteSocket, (char *)Request, sizeof(RCC_REQUEST) - 1 + Request->OptionLength, 0);

    if (Error == SOCKET_ERROR) {
        LocalFree(Request);
        return GetLastError();
    }

    //
    // Get the response.
    //
    Error = GetResponse(Client, RCC_CMD_KILL, (PUCHAR)&Response, sizeof(Response));
    
    if (Error != ERROR_SUCCESS) {
        LocalFree(Request);
        return Error;
    }

    //
    // Extract the result
    //
    Error = Response.Error;
    LocalFree(Request);

    //
    // Return the status.
    //
    return Error;
}


DWORD
RCCClntReboot(
    IN HANDLE hHandle
    )

/*++

Routine Description:

    This routine submits a "REBOOT" command to a remote machine via the remote command port, and then waits
    for a response.

Arguments:

    hHandle - A previously created instance.
    
    ProcessId - The process id on the remote machine to kill.
    
Return Value:

    ERROR_SUCCESS if successful, else an appropriate error code.

--*/

{
    DWORD Error;
    PRCC_CLIENT Client = (PRCC_CLIENT)hHandle;
    PRCC_REQUEST Request;
    RCC_RESPONSE Response;

    //
    // Check handle
    //
    if (Client == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Build the request
    //
    Request = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(RCC_REQUEST));
    if (Request == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    Request->CommandSequenceNumber = ++(Client->CommandSequenceNumber);
    Request->CommandCode = RCC_CMD_REBOOT;
    Request->OptionLength = 0;

    //
    // Send the request.
    //
    Error = send(Client->RemoteSocket, (char *)Request, sizeof(RCC_REQUEST) - 1 + Request->OptionLength, 0);

    if (Error == SOCKET_ERROR) {
        LocalFree(Request);
        return GetLastError();
    }

    //
    // Get the response.
    //
    Error = GetResponse(Client, RCC_CMD_REBOOT, (PUCHAR)&Response, sizeof(Response));
    
    if (Error != ERROR_SUCCESS) {
        LocalFree(Request);
        return Error;
    }

    //
    // Extract the result
    //
    Error = Response.Error;
    LocalFree(Request);

    //
    // Close the connection if there was no error
    //
    if (Error == ERROR_SUCCESS) {
        shutdown(Client->RemoteSocket, SD_BOTH);
        closesocket(Client->RemoteSocket);
        Client->RemoteSocket = INVALID_SOCKET;
    }

    //
    // Return the status.
    //
    return Error;
}


DWORD
RCCClntLowerProcessPriority(
    IN HANDLE hHandle,
    IN DWORD ProcessId
    )

/*++

Routine Description:

    This routine submits a "LOWER" command to a remote machine via the remote command port, and then waits
    for a response.

Arguments:

    hHandle - A previously created instance.
    
    ProcessId - The process id on the remote machine to reduce the priority of.
    
Return Value:

    ERROR_SUCCESS if successful, else an appropriate error code.

--*/

{
    DWORD Error;
    PRCC_CLIENT Client = (PRCC_CLIENT)hHandle;
    PRCC_REQUEST Request;
    RCC_RESPONSE Response;

    //
    // Check handle
    //
    if (Client == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Build the request
    //
    Request = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(RCC_REQUEST));
    if (Request == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    Request->CommandSequenceNumber = ++(Client->CommandSequenceNumber);
    Request->CommandCode = RCC_CMD_LOWER;
    Request->OptionLength = sizeof(DWORD);
    RtlCopyMemory(&(Request->Options[0]), &ProcessId, sizeof(DWORD));

    //
    // Send the request.
    //
    Error = send(Client->RemoteSocket, (char *)Request, sizeof(RCC_REQUEST) - 1 + Request->OptionLength, 0);

    if (Error == SOCKET_ERROR) {
        LocalFree(Request);
        return GetLastError();
    }

    //
    // Get the response.
    //
    Error = GetResponse(Client, RCC_CMD_LOWER, (PUCHAR)&Response, sizeof(Response));
    
    if (Error != ERROR_SUCCESS) {
        LocalFree(Request);
        return Error;
    }

    //
    // Extract the result
    //
    Error = Response.Error;
    LocalFree(Request);

    //
    // Return the status.
    //
    return Error;
}


DWORD
RCCClntLimitProcessMemory(
    IN HANDLE hHandle,
    IN DWORD ProcessId,
    IN DWORD MemoryLimit
    )

/*++

Routine Description:

    This routine submits a "LIMIT" command to a remote machine via the remote command port, and then waits
    for a response.

Arguments:

    hHandle - A previously created instance.
    
    ProcessId - The process id on the remote machine to limit the memory of.
    
    MemoryLimit - Number of MB to set the limit to.
    
Return Value:

    ERROR_SUCCESS if successful, else an appropriate error code.

--*/

{
    DWORD Error;
    PRCC_CLIENT Client = (PRCC_CLIENT)hHandle;
    PRCC_REQUEST Request;
    RCC_RESPONSE Response;

    //
    // Check handle
    //
    if (Client == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Build the request
    //
    Request = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(RCC_REQUEST) + sizeof(DWORD));
    if (Request == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    Request->CommandSequenceNumber = ++(Client->CommandSequenceNumber);
    Request->CommandCode = RCC_CMD_LIMIT;
    Request->OptionLength = 2 * sizeof(DWORD);
    RtlCopyMemory(&(Request->Options[0]), &ProcessId, sizeof(DWORD));
    RtlCopyMemory(&(Request->Options[sizeof(DWORD)]), &MemoryLimit, sizeof(DWORD));

    //
    // Send the request.
    //
    Error = send(Client->RemoteSocket, (char *)Request, sizeof(RCC_REQUEST) - 1 + Request->OptionLength, 0);

    if (Error == SOCKET_ERROR) {
        LocalFree(Request);
        return GetLastError();
    }

    //
    // Get the response.
    //
    Error = GetResponse(Client, RCC_CMD_LIMIT, (PUCHAR)&Response, sizeof(Response));
    
    if (Error != ERROR_SUCCESS) {
        LocalFree(Request);
        return Error;
    }

    //
    // Extract the result
    //
    Error = Response.Error;
    LocalFree(Request);

    //
    // Return the status.
    //
    return Error;
}


DWORD
RCCClntCrashDump(
    IN HANDLE hHandle
    )

/*++

Routine Description:

    This routine submits a "CRASHDUMP" command to a remote machine via the remote command port,
    and then waits for a response.

Arguments:

    hHandle - A previously created instance.
    
Return Value:

    ERROR_SUCCESS if successful, else an appropriate error code.

--*/

{
    DWORD Error;
    PRCC_CLIENT Client = (PRCC_CLIENT)hHandle;
    PRCC_REQUEST Request;
    RCC_RESPONSE Response;

    //
    // Check handle
    //
    if (Client == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Build the request
    //
    Request = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(RCC_REQUEST) + sizeof(DWORD));
    if (Request == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    Request->CommandSequenceNumber = ++(Client->CommandSequenceNumber);
    Request->CommandCode = RCC_CMD_CRASHDUMP;
    Request->OptionLength = 0;

    //
    // Send the request.
    //
    Error = send(Client->RemoteSocket, (char *)Request, sizeof(RCC_REQUEST) - 1 + Request->OptionLength, 0);

    if (Error == SOCKET_ERROR) {
        LocalFree(Request);
        return GetLastError();
    }

    //
    // Get the response.
    //
    Error = GetResponse(Client, RCC_CMD_LIMIT, (PUCHAR)&Response, sizeof(Response));
    
    if (Error != ERROR_SUCCESS) {
        LocalFree(Request);
        return Error;
    }

    //
    // Extract the result
    //
    Error = Response.Error;
    LocalFree(Request);

    //
    // Return the status.
    //
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\net\server\main.c ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <winsock2.h>
#include <ntexapi.h>
#include <devioctl.h>
#include <stdlib.h>
#include <rccxport.h>
#include "rcclib.h"
#include "error.h"


//
// Defines
//
#define MAX_REQUEST_SIZE (sizeof(RCC_REQUEST) + sizeof(DWORD))

//
// Global variables
//    
ULONG GlobalBufferCurrentSize;
char *GlobalBuffer;


//
// Prototypes
//
DWORD
RCCNetReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );

//
//
// Main routine
//
//
int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    HANDLE RCCHandle;
    DWORD Error;
    DWORD BytesReturned;
    DWORD ProcessId;
    PRCC_REQUEST Request;
    PRCC_RESPONSE Response;
    char *NewBuffer;
    DWORD ThisProcessId;
    DWORD MemoryLimit;


    //
    // Init the library routines
    //
    Error = RCCLibInit(&GlobalBuffer, &GlobalBufferCurrentSize);
    
    if (Error != ERROR_SUCCESS) {
        return -1;
    }

    //
    // Allocate memory for sending responses
    //
    Request = LocalAlloc(LPTR, MAX_REQUEST_SIZE);

    if (Request == NULL) {
        //
        // Log an error!
        //
        RCCLibExit(GlobalBuffer, GlobalBufferCurrentSize);
        RCCNetReportEventA(ERROR_RCCNET_INITIAL_ALLOC_FAILED, EVENTLOG_ERROR_TYPE, 0, 0, NULL, NULL);
        return -1;
    }

    

    //
    // Remember our process ID, so people cannot kill us.
    //
    ThisProcessId = GetCurrentProcessId();

    //
    // Open the Remote Command Console driver
    //
    RCCHandle = CreateFile("\\\\.\\RCC",
                           GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,                    // create disposition.
                           0,
                           0
                          );

    if (RCCHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        RCCNetReportEventA(ERROR_RCCNET_OPEN_RCCDRIVER_FAILED, 
                           EVENTLOG_ERROR_TYPE, 
                           0, 
                           0, 
                           NULL, 
                           NULL
                          );
        LocalFree(GlobalBuffer);
        LocalFree(Request);
        return -1;
    }

    while (1) {
        
        //
        // Send down an IOCTL for receiving data
        //
        if (!DeviceIoControl(RCCHandle,
                             CTL_CODE(FILE_DEVICE_NETWORK, 0x1, METHOD_NEITHER, FILE_ANY_ACCESS),
                             NULL,
                             0,
                             Request,
                             MAX_REQUEST_SIZE,
                             &BytesReturned,
                             NULL
                             )) {
            Error = GetLastError();
            
            //
            // Log an error here!
            //
            RCCNetReportEventA(ERROR_RCCNET_RCV_FAILED, EVENTLOG_ERROR_TYPE, 0, sizeof(DWORD), NULL, &Error);
            continue;
        }

        //
        // It completed, so we have data in the buffer - verify it and process the message.
        //
        Response = (PRCC_RESPONSE)GlobalBuffer;

        Response->CommandSequenceNumber = Request->CommandSequenceNumber;
        Response->CommandCode = Request->CommandCode;

        switch (Request->CommandCode) {

            case RCC_CMD_TLIST:

RetryTList:
                Response->Error = RCCLibGetTListInfo((PRCC_RSP_TLIST)(&(Response->Data[0])),
                                                     GlobalBufferCurrentSize - sizeof(RCC_RESPONSE) + 1,
                                                     &(Response->DataLength)
                                                    );

                //
                // Try to get more memory, if not available, then just fail without out of memory error.
                //
                if (Response->Error == ERROR_OUTOFMEMORY) {

                    Error = RCCLibIncreaseMemory(&GlobalBuffer, &GlobalBufferCurrentSize);

                    if (Error == ERROR_SUCCESS) {
                        goto RetryTList;                            
                    }
                    
                    Response->DataLength = 0;
                }
                break;

            case RCC_CMD_KILL:
                
                RtlCopyMemory(&ProcessId, &(Request->Options[0]), sizeof(DWORD));

                if (ProcessId != ThisProcessId) {
                    Response->Error = RCCLibKillProcess(ProcessId);
                } else {
                    Response->Error = ERROR_INVALID_PARAMETER;
                }

                Response->DataLength = 0;
                break;

            case RCC_CMD_REBOOT:
                
                //
                // Send back an acknowledgement that we got the command before starting the reboot.
                //
                Response->Error = ERROR_SUCCESS;
                Response->DataLength = 0;
                break;


            case RCC_CMD_LOWER:
                
                RtlCopyMemory(&ProcessId, &(Request->Options[0]), sizeof(DWORD));

                if (ProcessId != ThisProcessId) {
                    Response->Error = RCCLibLowerProcessPriority(ProcessId);
                } else {
                    Response->Error = ERROR_INVALID_PARAMETER;
                }

                Response->DataLength = 0;
                break;

            case RCC_CMD_LIMIT:
                
                RtlCopyMemory(&ProcessId, &(Request->Options[0]), sizeof(DWORD));
                RtlCopyMemory(&MemoryLimit, &(Request->Options[sizeof(DWORD)]), sizeof(DWORD));

                if (ProcessId != ThisProcessId) {
                    Response->Error = RCCLibLimitProcessMemory(ProcessId, MemoryLimit);
                } else {
                    Response->Error = ERROR_INVALID_PARAMETER;
                }

                //
                // Send back an acknowledgement that we got the command before starting the reboot.
                //
                Response->Error = ERROR_SUCCESS;
                Response->DataLength = 0;
                break;

            case RCC_CMD_CRASHDUMP:
                Response->DataLength = 0;
                break;
                
            default:
                Response->Error = ERROR_INVALID_PARAMETER;
                Response->DataLength = 0;

        }

        //
        // Send back the response
        //
        if (!DeviceIoControl(RCCHandle,
                             CTL_CODE(FILE_DEVICE_NETWORK, 0x2, METHOD_NEITHER, FILE_ANY_ACCESS),
                             Response,
                             Response->DataLength + sizeof(RCC_RESPONSE) - 1,
                             NULL,
                             0,
                             &BytesReturned,
                             NULL
                             )) {
            Error = GetLastError();
            
            //
            // Log an error here!
            //
            RCCNetReportEventA(ERROR_RCCNET_SEND_FAILED, EVENTLOG_ERROR_TYPE, 0, sizeof(DWORD), NULL, &Error);
        }

        //
        // If it was a reboot command, do that now.
        // 
        if (Request->CommandCode == RCC_CMD_REBOOT) {

            NtShutdownSystem(ShutdownReboot);
            //
            // If we get here, then there was an error of some sort...
            //
        }
        
        //
        // If it was a bugcheck command, do that now.
        //
        if (Request->CommandCode == RCC_CMD_CRASHDUMP) {

            if (!DeviceIoControl(RCCHandle,
                                 CTL_CODE(FILE_DEVICE_NETWORK, 0x3, METHOD_NEITHER, FILE_ANY_ACCESS),
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &BytesReturned,
                                 NULL
                                 )) {
                Error = GetLastError();
            
                //
                // Log an error here!
                //
                RCCNetReportEventA(ERROR_RCCNET_SEND_FAILED, EVENTLOG_ERROR_TYPE, 0, sizeof(DWORD), NULL, &Error);
            }

        }

    }

    LocalFree(Request);
    return 1;
}


DWORD
RCCNetReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //
    EventlogHandle = RegisterEventSourceW(NULL, L"RCCNet");

    if (EventlogHandle == NULL) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //
    if(!ReportEventA(EventlogHandle,
                     (WORD)EventType,
                     0,            // event category
                     EventID,
                     NULL,
                     (WORD)NumStrings,
                     DataLength,
                     Strings,
                     Data
                     )) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = ERROR_SUCCESS;

Cleanup:

    if (EventlogHandle != NULL) {
        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rcc\serial\makefile.inc ===
rcmdmsg.h rcmdmsg.rc msg00001.bin: rcmdmsg.mc
    mc -d -r .\ rcmdmsg.mc

clean::
    -del rcmdmsg.h rcmdmsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\compdata.cpp ===
//
// Microsoft Corporation 1998
//
// COMPDATA.CPP - CComponentData and CComponentDataCF routines
//
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation

CComponentData::CComponentData()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
    m_hwndFrame = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_pGPTInformation = NULL;
}

CComponentData::~CComponentData()
{
    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_pGPTInformation)
    {
        m_pGPTInformation->Release();
    }

    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation (IUnknown)

HRESULT CComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp ))
    {
        *ppv = (ISnapinHelp *) this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation (IComponentData)

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<PLONG_PTR>(bmp16x16),
                      reinterpret_cast<PLONG_PTR>(bmp16x16),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();

    DeleteObject( bmp16x16 );

    return S_OK;
}

STDMETHODIMP CComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::CreateComponent: Failed to create CSnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CDataObject *pDataObject;
    LPGPTDATAOBJECT pGPTDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPTDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pGPTDataObject->SetType(type);
    pGPTDataObject->SetCookie(cookie);
    pGPTDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_EXPAND:
            if (arg == TRUE)

                if (!m_pGPTInformation)
                {
                    lpDataObject->QueryInterface(IID_IGPEInformation, (LPVOID *)&m_pGPTInformation);
                }

                if (m_pGPTInformation)
                {
                    hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        if (g_NameSpace[dwIndex].dwID == (DWORD) pItem->lParam)
            break;
    }

    if (dwIndex == NUM_NAMESPACE_ITEMS)
        pItem->displayname = NULL;
    else
    {
        pItem->displayname = g_NameSpace[dwIndex].szDisplayName;
    }

    return S_OK;
}

STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPTDATAOBJECT pGPTDataObjectA, pGPTDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectB)))
    {
        pGPTDataObjectA->Release();
        return S_FALSE;
    }

    pGPTDataObjectA->GetCookie(&cookie1);
    pGPTDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPTDataObjectA->Release();
    pGPTDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation (IPersistStreamInit)

STDMETHODIMP CComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_POINTER;
    }

    *pClassID = CLSID_GPTRemoteInstall;

    return S_OK;
}

STDMETHODIMP CComponentData::IsDirty(VOID)
{
    return S_FALSE;
}

STDMETHODIMP CComponentData::Load(IStream *pStm)
{
    return S_OK;
}


STDMETHODIMP CComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;
}


STDMETHODIMP CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DWORD dwSize = 0;


    if (!pcbSize)
    {
        return E_POINTER;
    }

    ULISet32(*pcbSize, dwSize);

    return S_OK;
}

STDMETHODIMP CComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation (Internal functions)

HRESULT CComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;


    if (!m_hRoot)
        m_hRoot = hParent;


    if (m_hRoot == hParent)
        dwIndex = 0;
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = (DWORD) item.lParam;
    }

    for (i = 0; i < NUM_NAMESPACE_ITEMS; i++)
    {
        if (g_NameSpace[i].dwParent == dwIndex)
        {
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = 0;
            item.nOpenImage = 0;
            item.nState = 0;
            item.cChildren = g_NameSpace[i].cChildren;
            item.lParam = g_NameSpace[i].dwID;
            item.relativeID =  hParent;

            m_pScope->InsertItem (&item);
        }
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Class factory object implementation

CComponentDataCF::CComponentDataCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CComponentDataCF::~CComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
// Class factory object implementation (IUnknown)

STDMETHODIMP_(ULONG)
CComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
// Class factory object implementation (IClassFactory)


STDMETHODIMP
CComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CComponentData *pComponentData = new CComponentData(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
// Class factory object creation (IClassFactory)

HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (IsEqualCLSID (rclsid, CLSID_GPTRemoteInstall)) {

        CComponentDataCF *pComponentDataCF = new CComponentDataCF();   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}

///////////////////////////////////////////////////////////////////////////////
//
// CComponentData object implementation (ISnapinHelp)
//

STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;

    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\ris.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\debug.h ===
//
// Microsoft Corporation 1998
//
// DEBUG.H - Debugging flags and macros
//
#if DBG

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DebugMsg(x) _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);

#else

#define DebugMsg(x)


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\guids.cpp ===
//
// Microsoft Corporation 1998
//
// GUIDS.CPP - External GUID library
//
#include "main.h"
#include <initguid.h>
#include "guids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\dataobj.cpp ===
//
// Microsoft Corporation 1998
//
// DATAOBJ.H - CDataObject routines
//
#include "main.h"
#include <initguid.h>
#include "dataobj.h"


unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CDataObject::CDataObject(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CDataObject::~CDataObject()
{
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IGPTDataObject))
    {
        *ppv = (LPGPTDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IDataObject)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (Internal functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, ARRAYSIZE( szNodeType ));

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDispName[50];
    WCHAR  szDisplayName[100];

    LoadStringW (g_hInstance, IDS_SNAPIN_NAME, szDisplayName, ARRAYSIZE( szDisplayName ));

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_GPTRemoteInstall, sizeof(CLSID), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\debug.cpp ===
//
// Microsoft Corporation 1998
//
// DEBUG.CPP - Debug library
//
#include "main.h"

#if DBG

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPTDemo[] = TEXT("RIGPSNAP(%x): ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("RIGPSNAP")

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

    dwDebugLevel = DL_NORMAL;


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[30];
    TCHAR szDebugBuffer[2*MAX_PATH+40];
    va_list marker;
    DWORD dwErrCode;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {
        wsprintf (szDebugTitle, c_szGPTDemo, GetCurrentProcessId());
        OutputDebugString(szDebugTitle);

        va_start(marker, pszMsg);
        wvsprintf(szDebugBuffer, pszMsg, marker);
        OutputDebugString(szDebugBuffer);
        OutputDebugString(c_szCRLF);
        va_end(marker);

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;

            hFile = CreateFile(TEXT("c:\\rigpsnap.log"),
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }

        }

    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\compdata.h ===
//
// Microsoft Corporation 1998
//
// COMPDATA.H -  CComponentData class
//

class CComponentData:
    public IComponentData,
    public IPersistStreamInit,
    public ISnapinHelp
{
    friend class CDataObject;
    friend class CSnapIn;

protected:
    ULONG                m_cRef;
    HWND                 m_hwndFrame;
    LPCONSOLENAMESPACE   m_pScope;
    LPCONSOLE            m_pConsole;
    HSCOPEITEM           m_hRoot;
    LPGPEINFORMATION     m_pGPTInformation;

public:
    CComponentData();
    ~CComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Implemented IComponentData methods
    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    // Implemented IPersistStreamInit interface members
    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);

    //
    // ISnapinHelp
    //
    STDMETHODIMP        GetHelpTopic( LPOLESTR * lpCompiledHelpFile );
        
private:
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
};



// ComponentData class factory
class CComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CComponentDataCF();
    ~CComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\guids.h ===
//
// Microsoft Corporation 1998
//
//
// GUIDS.H
//


// {E69275E8-6FAF-11d2-842D-00C04FA372D4}
DEFINE_GUID( NODEID_GPERoot, 
0xe69275e8, 0x6faf, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\dataobj.h ===
//
// Microsoft Corporation 1998
//
// DATAOBJ.H - IGPTDataobject
//

// {C14C50E2-FA21-11d0-8CF9-C64377000000}
DEFINE_GUID(IID_IGPTDataObject,
0xc14c50e2, 0xfa21, 0x11d0, 0x8c, 0xf9, 0xc6, 0x43, 0x77, 0x0, 0x0, 0x0);

#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

//
// This is a private dataobject interface for GPTs.
// When the GPT snapin receives a dataobject and needs to determine
// if it came from the GPT snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IGPTDataObject
DECLARE_INTERFACE_(IGPTDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPTDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IGPTDataObject *LPGPTDATAOBJECT;

// CDataObject class
class CDataObject : public IDataObject,
                    public IGPTDataObject
{
    friend class CSnapIn;

protected:
    ULONG                  m_cRef;
    CComponentData        *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    // Clipboard formats that are required by the console
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;

public:
    CDataObject(CComponentData *pComponent);
    ~CDataObject();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    // Implemented IDataObject methods
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);


    // Unimplemented IDataObject methods
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    // Implemented IGPTDataObject methods
    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\layout.cpp ===
//
// Microsoft Corporation 1998
//
// LAYOUT.CPP - This file contains the tool's namespace and result pane items
//
#include "main.h"

RESULTITEM g_Undefined[] =
{
    { 1, 1, 0, 0, {0} }
};


RESULTITEM g_Samples[] =
{
    { 2, 1, IDS_CHOICEOSC, 0, {0} }
};

// KB: Be sure to update NUM_NAMESPACE_ITEMS define in layout.h if you
// add / remove from this array.

NAMESPACEITEM g_NameSpace[] =
{
    { 0, -1, 0,          0, {0}, 0, g_Undefined, &NODEID_User },   // Root
    { 1, 0, IDS_SAMPLES, 0, {0}, 1, g_Samples,   &NODEID_RemoteInstall }
};

//
// InitNameSpace()
//
BOOL InitNameSpace()
{
    DWORD dwIndex;
	DWORD dw;

    for (dwIndex = 1; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        LoadString (g_hInstance, g_NameSpace[dwIndex].iStringID,
                    g_NameSpace[dwIndex].szDisplayName,
                    ARRAYSIZE( g_NameSpace[dwIndex].szDisplayName ));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\main.h ===
//
// Microsoft Corporation 1998
//
// MAIN.H - Precompiled Header
//

#include <windows.h>
#include <windowsx.h>
#include <lm.h>
#include <ole2.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <prsht.h>
#include <mmc.h>
#include <gpedit.h>

#include "rigpsnap.h"
class CSnapIn;

#include "layout.h"
#include "compdata.h"
#include "snapin.h"
#include "dataobj.h"
#include "debug.h"
#include "util.h"
#include "resource.h"

// Global variables
extern LONG g_cRefThisDll;
extern HINSTANCE g_hInstance;

// Macros
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// Functions to create class factories
HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\rigpsnap.cpp ===
//
// Microsoft Corporation 1998
//
// RIGPSNAP.CPP - DLL entry and registration routines
//
#include "main.h"
#include <initguid.h>
#include <rigpsnap.h>
#include <gpedit.h>

// Globals
LONG g_cRefThisDll = 0;
HINSTANCE g_hInstance;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
       g_hInstance = hInstance;
       DisableThreadLibraryCalls(hInstance);
       InitNameSpace();
#if DBG
       InitDebugSupport();
#endif
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return (CreateComponentDataClassFactory (rclsid, riid, ppv));
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

const TCHAR szSnapInLocation[] = TEXT("%SystemRoot%\\System32\\RIGPSNAP.dll");

STDAPI DllRegisterServer(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szGUID[50];
    DWORD dwDisp, dwIndex;
    LONG lResult;
    HKEY hKey;


    StringFromGUID2 (CLSID_GPTRemoteInstall, szSnapInKey, ARRAYSIZE( szSnapInKey ));

    //
    // Register SnapIn in HKEY_CLASSES_ROOT
    //

    LoadString (g_hInstance, IDS_SNAPIN_NAME, szSnapInName, ARRAYSIZE( szSnapInName ));
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szSnapInLocation,
                   (lstrlen(szSnapInLocation) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register SnapIn with MMC
    //

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    TCHAR szModuleFileName[MAX_PATH];
    ZeroMemory(szModuleFileName, sizeof(szModuleFileName));
    DWORD dwRet = GetModuleFileName(
                            g_hInstance,
                            szModuleFileName,
                            ARRAYSIZE(szModuleFileName));
    if (0 != dwRet) {
        TCHAR strNameIndirect[MAX_PATH];
        wsprintf(strNameIndirect, TEXT("@%s,-%u"), szModuleFileName, IDS_SNAPIN_NAME);
        RegSetValueEx(
                hKey, 
                TEXT("NameStringIndirect"), 
                0, 
                REG_SZ, 
                (LPBYTE)strNameIndirect,
                (lstrlen(strNameIndirect) + 1) * sizeof(TCHAR));

    }


    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));



    RegCloseKey (hKey);


    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, ARRAYSIZE( szGUID ));

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                  szSnapInKey, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }


    //
    // Register in the NodeTypes key
    //

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, ARRAYSIZE( szGUID ));

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }


    //
    // Register as an extension for various nodes
    //

    StringFromGUID2 (NODEID_User, szGUID, 50);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    DWORD dwIndex;
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;

    StringFromGUID2 (CLSID_GPTRemoteInstall, szSnapInKey, ARRAYSIZE( szSnapInKey ));

    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, ARRAYSIZE( szGUID ));
        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }


    StringFromGUID2 (NODEID_User, szGUID, ARRAYSIZE( szGUID ));
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);


    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0,
                              KEY_WRITE, &hKey);


    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\layout.h ===
//
// Microsoft Corporation 1998
//
// LAYOUT.H - Tool layout structures and constants
//
#define NUM_NAMESPACE_ITEMS       2
#define MAX_DISPLAYNAME_SIZE    100

typedef struct _RESULTITEM
{
    DWORD        dwID;
    DWORD        dwNameSpaceItem;
    INT          iStringID;
    INT          iImage;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
} RESULTITEM, *LPRESULTITEM;

typedef struct _NAMESPACEITEM
{
    DWORD        dwID;
    DWORD        dwParent;
    INT          iStringID;
    INT          cChildren;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
    INT          cResultItems;
    LPRESULTITEM pResultItems;
    const GUID   *pNodeID;
} NAMESPACEITEM, *LPNAMESPACEITEM;

extern RESULTITEM g_Root[];
extern RESULTITEM g_Undefined[];
extern NAMESPACEITEM g_NameSpace[];

BOOL InitNameSpace();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rigpsnap.rc
//
#define IDS_SAMPLES                     1
#define IDI_POLICY                      1
#define IDB_16x16                       1
#define IDS_SNAPIN_NAME                 1
#define IDI_README                      2
#define IDB_32x32                       2
#define IDI_NETHOOD                     3
#define IDI_STARTMENU                   4
#define IDI_MYDOCS                      5
#define IDI_PUBDOCS                     6
#define IDI_APPEAR                      7
#define IDS_CHOICEOSC                   8
#define IDS_AUTO                        21
#define IDS_CUSTOM                      22
#define IDS_RESTART                     23
#define IDS_TOOLS                       24
#define IDS_NAME                        25
#define IDD_SCREEN                      100
#define IDD_README                      101
#define IDI_REMOTEINSTAL                101
#define IDC_FIRST_RADIO_BUTTON          1000
#define IDC_R_AUTO_ALLOW                1001
#define IDC_R_AUTO_DONTCARE             1002
#define IDC_R_AUTO_DENY                 1003
#define IDC_R_CUST_ALLOW                1004
#define IDC_R_CUST_DONTCARE             1005
#define IDC_R_CUST_DENY                 1006
#define IDC_R_RESTART_ALLOW             1007
#define IDC_R_RESTART_DONTCARE          1008
#define IDC_R_RESTART_DENY              1009
#define IDC_R_TOOLS_ALLOW               1010
#define IDC_R_TOOLS_DONTCARE            1011
#define IDC_R_TOOLS_DENY                1012
#define IDC_LAST_RADIO_BUTTON           1013
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\rigpsnap.h ===
//
// Microsoft Corporation 1998
//
// RIGPSNAP.H - Tool GUIDs
//

// {3060E8CE-7020-11d2-842D-00C04FA372D4}
DEFINE_GUID(CLSID_GPTRemoteInstall, 
0x3060e8ce, 0x7020, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

// {3060E8CF-7020-11d2-842D-00C04FA372D4}
DEFINE_GUID(NODEID_RemoteInstall, 
0x3060e8cf, 0x7020, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

// {E69275E8-6FAF-11d2-842D-00C04FA30000}
DEFINE_GUID(CLSID_RIClientExtension, 
0x3060e8d0, 0x7020, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\snapin.cpp ===
//
// Microsoft Corporation 1998
//
// SNAPIN.CPP - CSnapin rountines
//
#include "main.h"
#include <shlwapi.h>

#define MAX_INI_SECTION_SIZE 10
#define MAX_OPTION_SIZE 256

#define RIGPSNAP_HELP_TOPIC L"RISconcepts.chm::/sag_RIS_CIW_Policy_and_ACLs.htm"

unsigned int CSnapIn::m_cfNodeType = RegisterClipboardFormat(CCF_NODETYPE);
TCHAR CSnapIn::m_szDefaultIcon[] = TEXT("mydocs.dll,0");


struct {
    DWORD dwCtlIdAllow;     // dialog control IDs
    DWORD dwCtlIdDontCare;  // dialog control IDs
    DWORD dwCtlIdDeny;      // dialog control IDs
    DWORD dwValId;          // string resouce ID for the option's name
} g_ChoiceOptions[] = {
    { IDC_R_AUTO_ALLOW,     IDC_R_AUTO_DONTCARE,    IDC_R_AUTO_DENY,    IDS_AUTO    },
    { IDC_R_CUST_ALLOW,     IDC_R_CUST_DONTCARE,    IDC_R_CUST_DENY,    IDS_CUSTOM  },
    { IDC_R_RESTART_ALLOW,  IDC_R_RESTART_DONTCARE, IDC_R_RESTART_DENY, IDS_RESTART },
    { IDC_R_TOOLS_ALLOW,    IDC_R_TOOLS_DONTCARE,   IDC_R_TOOLS_DENY,   IDS_TOOLS   }
};

///////////////////////////////////////////////////////////////////////////////
//
// CSnapIn object implementation
//
CSnapIn::CSnapIn(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pImageResult = NULL;
    m_pConsoleVerb = NULL;
    m_nColumnSize = 180;
    m_lViewMode = LVS_ICON;

    LoadString(g_hInstance, IDS_NAME, m_column1, sizeof(m_column1));
}

CSnapIn::~CSnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//
// CSnapIn object implementation (IUnknown)
//

HRESULT CSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//
// CSnapIn object implementation (IComponent)
//
STDMETHODIMP CSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);


    return S_OK;
}

STDMETHODIMP CSnapIn::Destroy(MMC_COOKIE cookie)
{

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }
    if (m_pImageResult != NULL)
    {
        m_pImageResult->Release();
        m_pImageResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
    case MMCN_CONTEXTHELP:
        {
            IDisplayHelp * phelp = NULL;
            hr = m_pConsole->QueryInterface( IID_IDisplayHelp,
                                           (void **)&phelp );
            if (SUCCEEDED( hr ))
            {
                phelp->ShowTopic ( RIGPSNAP_HELP_TOPIC );
            }
            if ( phelp != NULL )
            {
                phelp->Release();
            }
        }
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
        hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

        if (hbmp16x16 && hbmp32x32) {        
            // Set the images
            m_pImageResult->ImageListSetStrip(reinterpret_cast<PLONG_PTR>(hbmp16x16),
                                              reinterpret_cast<PLONG_PTR>(hbmp32x32),
                                              0, RGB(255, 0, 255));
        }

        if (hbmp16x16) {
            DeleteObject(hbmp16x16);
        }

        if (hbmp32x32) {
            DeleteObject(hbmp32x32);
        }
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPGPTDATAOBJECT pGPTDataObject;
            MMC_COOKIE cookie;
            INT i;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pGPTDataObject->GetCookie(&cookie);

            pGPTDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;


            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumnSize);
            m_pResult->SetViewMode(m_lViewMode);


            //
            // Add result pane items for this node
            //

            for (i = 0; i < g_NameSpace[cookie].cResultItems; i++)
            {
                resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                resultItem.str = MMC_CALLBACK;
                resultItem.nImage = g_NameSpace[cookie].pResultItems[i].iImage;
                resultItem.lParam = (LPARAM) &g_NameSpace[cookie].pResultItems[i];
                m_pResult->InsertItem(&resultItem);
            }

            //m_pResult->Sort(0, 0, -1);
        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumnSize);
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;


    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPRESULTITEM pItem;
            LPGPTDATAOBJECT pGPTDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE  cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

            if (FAILED(hr))
                break;

            pGPTDataObject->GetType(&type);
            pGPTDataObject->GetCookie(&cookie);

            pGPTDataObject->Release();


            //
            // If this is a result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if ((type == CCT_RESULT) || ((type == CCT_SCOPE) && (cookie == 0)))
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);


                //
                // If this is a result pane item, then change the default
                // verb to Properties.
                //

                if (type == CCT_RESULT)
                    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                    pResult->str = g_NameSpace[pResult->lParam].szDisplayName;
                else
                    pResult->str = L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                pResult->nImage = 0;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    LPRESULTITEM lpResultItem = (LPRESULTITEM)pResult->lParam;

                    if (lpResultItem->szDisplayName[0] == TEXT('\0'))
                    {
                        LoadString (g_hInstance, lpResultItem->iStringID,
                                    lpResultItem->szDisplayName,
                                    MAX_DISPLAYNAME_SIZE);
                    }

                    pResult->str = lpResultItem->szDisplayName;
                }

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CSnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        LONG *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPTDATAOBJECT pGPTDataObjectA, pGPTDataObjectB;
    MMC_COOKIE  cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectB)))
    {
        pGPTDataObjectA->Release();
        return S_FALSE;
    }

    pGPTDataObjectA->GetCookie(&cookie1);
    pGPTDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPTDataObjectA->Release();
    pGPTDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CComponentData object implementation (IExtendPropertySheet)
//
STDMETHODIMP CSnapIn::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage[2];
    LPGPTDATAOBJECT pGPTDataObject;
    LPRESULTITEM pItem;
    MMC_COOKIE cookie;


    //
    // Make sure this is one of our objects
    //

    if (FAILED(lpDataObject->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObject)))
    {
        return S_OK;
    }


    //
    // Get the cookie
    //

    pGPTDataObject->GetCookie(&cookie);
    pGPTDataObject->Release();


    pItem = (LPRESULTITEM)cookie;


    //
    // Initialize the common fields in the property sheet structure
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.lParam = (LPARAM) this;


    //
    // Do the page specific stuff
    //

    switch (pItem->dwID)
    {
        case 2:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCREEN);
            psp.pfnDlgProc = ChoiceDlgProc;

            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;
    }


    return (hr);
}

STDMETHODIMP CSnapIn::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    LPGPTDATAOBJECT pGPTDataObject;
    DATA_OBJECT_TYPES type;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IGPTDataObject,
                                               (LPVOID *)&pGPTDataObject)))
    {
        pGPTDataObject->GetType(&type);
        pGPTDataObject->Release();

        if (type == CCT_RESULT)
            return S_OK;
    }

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// CSnapIn object implementation (Internal functions)
//

INT_PTR CALLBACK CSnapIn::ReadmeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}

INT_PTR CALLBACK CSnapIn::_CreateDirectoryIfNeeded( LPOLESTR pszPath )
{
    BOOL b = FALSE;
    LPOLESTR psz = &pszPath[ wcslen( pszPath ) ];
    DWORD dwErr;

    while ( psz = StrRChr( pszPath, psz, L'\\' ) )
    {
        WCHAR tmp = *psz;           // save
        *psz = L'\0';               // terminate
        b = CreateDirectory( pszPath, NULL );
        *psz = tmp;                 // restore

        if (b)
        { // success in creating directory
            psz++;
            while ( psz = StrChr( psz, L'\\' ) )
            {
                WCHAR tmp = *psz;           // save
                *psz = L'\0';               // terminate
                b = CreateDirectory( pszPath, NULL );
                *psz = tmp;                 // restore

                if ( !b )
                {
                    dwErr = GetLastError();
                    break;
                }
                psz++;
            }
            break;
        }
        // else failed... keep backing up
        dwErr = GetLastError();
        psz--;
    }

    return b;
}

INT_PTR CALLBACK CSnapIn::ChoiceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CSnapIn * pCS = (CSnapIn*) GetWindowLongPtr( hDlg, DWLP_USER );
    static BOOL bDirty;
    BOOL fReturn = FALSE;
    HRESULT hr;
    LPOLESTR pszPath = NULL;


    if ( message == WM_INITDIALOG )
    {
        bDirty = FALSE;
        pCS = (CSnapIn *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCS);
        if (!pCS)
            goto Cleanup;

        pszPath = SysAllocStringByteLen( NULL, MAX_PATH * sizeof(OLECHAR) );
        if (!pszPath)
            goto Cleanup;

        hr = pCS->m_pcd->m_pGPTInformation->GetFileSysPath( GPO_SECTION_USER, pszPath, MAX_PATH );
        if (SUCCEEDED(hr))
        {
            wcscat( pszPath, L"\\Microsoft\\RemoteInstall\\oscfilter.ini");

            for ( INT i = 0; i < ARRAYSIZE(g_ChoiceOptions); i++ )
            {
                WCHAR szValue[MAX_INI_SECTION_SIZE];
                LONG lValue = -1;   // don't care
                DWORD dw;
                WCHAR szOption[ MAX_OPTION_SIZE ];

                dw = LoadString( g_hInstance, g_ChoiceOptions[i].dwValId, szOption, ARRAYSIZE( szOption ));

                dw = GetPrivateProfileString( L"Choice", szOption, L"", szValue, ARRAYSIZE( szValue ), pszPath );

                if ( dw != 0 )
                {
                    lValue = wcstol( szValue, NULL, 10 );
                }

                switch (lValue)
                {
                case 0: // Deny
                    Button_SetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdDeny ), BST_CHECKED );
                    break;

                case 1: // Allow
                    Button_SetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdAllow ), BST_CHECKED );
                    break;

                default: // don't care / unknown value
                    Button_SetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdDontCare ), BST_CHECKED );
                    break;

                }
            }
        }
    }

    if (!pCS)
        goto Cleanup;

    switch (message)
    {
    case WM_HELP:
    case WM_CONTEXTMENU:
        {
            MMCPropertyHelp( RIGPSNAP_HELP_TOPIC );
        }
        break;

    case WM_COMMAND:
        if ( ( LOWORD(wParam) >= IDC_FIRST_RADIO_BUTTON )
          && ( LOWORD(wParam) <= IDC_LAST_RADIO_BUTTON ) )
        {
            if ( !bDirty )
            {
                SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                bDirty = TRUE;
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR*)lParam)->code)
        {
            case PSN_APPLY:
            {
                if (bDirty)
                {
                    pszPath = SysAllocStringByteLen( NULL, MAX_PATH );
                    if (!pszPath)
                        goto Cleanup;

                    hr = pCS->m_pcd->m_pGPTInformation->GetFileSysPath( GPO_SECTION_USER, pszPath, MAX_PATH );
                    if (SUCCEEDED(hr))
                    {
                        wcscat( pszPath, L"\\Microsoft\\RemoteInstall\\oscfilter.ini");
                        pCS->_CreateDirectoryIfNeeded( pszPath );

                        for ( INT i = 0; i < ARRAYSIZE(g_ChoiceOptions); i++ )
                        {
                            DWORD dw;
                            WCHAR szOption[ MAX_OPTION_SIZE ];

                            dw = LoadString( g_hInstance, g_ChoiceOptions[i].dwValId, szOption, ARRAYSIZE( szOption ));

                            if ( Button_GetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdDeny ) ) == BST_CHECKED )
                            {
                                WritePrivateProfileString( L"Choice", szOption, L"0", pszPath );
                            }

                            if ( Button_GetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdAllow ) ) == BST_CHECKED )
                            {
                                WritePrivateProfileString( L"Choice", szOption, L"1", pszPath );
                            }

                            if ( Button_GetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdDontCare ) ) ==  BST_CHECKED )
                            {
                                WritePrivateProfileString( L"Choice", szOption, NULL, pszPath );
                            }
                        }

                        // Notify the GPT manager that policy has changed

                        pCS->m_pcd->m_pGPTInformation->PolicyChanged( FALSE, TRUE, (GUID *)&CLSID_RIClientExtension, (GUID *)&CLSID_GPTRemoteInstall );
                    }
                }
            }
            // fall through...

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                bDirty = FALSE;
                fReturn = TRUE;
                break;

        }
        break;
    }

Cleanup:
    if ( pszPath )
        SysFreeString( pszPath );

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\util.cpp ===
//
// Microsoft Corporation 1998
//
// UTIL.CPP - Utility routines
//
#include "main.h"

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}


//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnodeRecurse (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    LPTSTR lpEnd;
    LONG lResult;
    DWORD dwSize;
    TCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }


    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    dwSize = MAX_PATH;
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            lstrcpy (lpEnd, szName);

            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    TCHAR szDelKey[2 * MAX_PATH];


    lstrcpy (szDelKey, lpSubKey);

    return RegDelnodeRecurse(hKeyRoot, szDelKey);

}

//*************************************************************
//
//  RegCleanUpValue()
//
//  Purpose:    Removes the target value and if no more values / keys
//              are present, removes the key.  This function then
//              works up the parent tree removing keys if they are
//              also empty.  If any parent key has a value / subkey,
//              it won't be removed.
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey
//              lpValueName -   Value to remove
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName)
{
    TCHAR szDelKey[2 * MAX_PATH];
    LPTSTR lpEnd;
    DWORD dwKeys, dwValues;
    LONG lResult;
    HKEY hKey;


    //
    // Make a copy of the subkey so we can write to it.
    //

    lstrcpy (szDelKey, lpSubKey);


    //
    // First delete the value
    //

    lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegDeleteValue (hKey, lpValueName);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult != ERROR_FILE_NOT_FOUND)
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to delete value <%s> with %d."), lpValueName, lResult));
                return FALSE;
            }
        }
    }

    //
    // Now loop through each of the parents.  If the parent is empty
    // eg: no values and no other subkeys, then remove the parent and
    // keep working up.
    //

    lpEnd = szDelKey + lstrlen(szDelKey) - 1;

    while (lpEnd >= szDelKey)
    {

        //
        // Find the parent key
        //

        while ((lpEnd > szDelKey) && (*lpEnd != TEXT('\\')))
            lpEnd--;


        //
        // Open the key
        //

        lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_READ, &hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_FILE_NOT_FOUND)
            {
                goto LoopAgain;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to open key <%s> with %d."), szDelKey, lResult));
                return FALSE;
            }
        }

        //
        // See if there any any values / keys
        //

        lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL,
                         &dwValues, NULL, NULL, NULL, NULL);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to query key <%s> with %d."), szDelKey, lResult));
            return FALSE;
        }


        //
        // Exit now if this key has values or keys
        //

        if ((dwKeys != 0) || (dwValues != 0))
        {
            return TRUE;
        }

        RegDeleteKey (hKeyRoot, szDelKey);

LoopAgain:
        //
        // If we are at the beginning of the subkey, we can leave now.
        //

        if (lpEnd == szDelKey)
        {
            return TRUE;
        }


        //
        // There is a parent key.  Remove the slash and loop again.
        //

        if (*lpEnd == TEXT('\\'))
        {
            *lpEnd = TEXT('\0');
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\appldlg.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: ApplDlg.H


 ***************************************************************************/

#ifndef _APPLDLG_H_
#define _APPLDLG_H_

INT_PTR CALLBACK
ApplicationDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _APPLDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\appldlg.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: ApplDlg.CPP

 ***************************************************************************/

#include "pch.h"
#include <winperf.h>
#include "utils.h"
#include <commctrl.h>

DEFINE_MODULE("RIPREP")

#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         L"software\\microsoft\\windows nt\\currentversion\\perflib"
#define REGSUBKEY_COUNTERS  L"Counters"
#define PROCESS_COUNTER     L"process"


// Globals
LPBYTE g_pBuffer  = NULL;
DWORD  g_cbBuffer = 1;

typedef struct _TASKITEM {
    LPWSTR pszImageName;
    LPWSTR pszServiceName;
    DWORD  dwProcessId;
} TASKITEM, * LPTASKITEM;

//
// GetServiceProcessInfo( )
//
// BORROWED FROM "TLIST"'s common.c
//
DWORD
GetServiceProcessInfo(
    LPENUM_SERVICE_STATUS_PROCESS*  ppInfo
    )

/*++

Routine Description:

    Provides an API for getting a list of process information for Win 32
    services that are running at the time of the API call.

Arguments:

    ppInfo  - address of a pointer to return the information.
              *ppInfo points to memory allocated with malloc.

Return Value:

    Number of ENUM_SERVICE_STATUS_PROCESS structures pointed at by *ppInfo.

--*/

{
    DWORD       dwNumServices = 0;
    SC_HANDLE   hScm;

    TraceFunc( "GetServiceProcessInfo( )\n" );

    // Initialize the output parmeter.
    *ppInfo = NULL;

    // Connect to the service controller.
    //
    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
    if (hScm) {
        LPENUM_SERVICE_STATUS_PROCESS   pInfo    = NULL;
        DWORD                           cbInfo   = 4 * 1024;
        DWORD                           dwErr    = ERROR_SUCCESS;
        DWORD                           dwResume = 0;
        DWORD                           cLoop    = 0;
        const DWORD                     cLoopMax = 2;

        // First pass through the loop allocates from an initial guess. (4K)
        // If that isn't sufficient, we make another pass and allocate
        // what is actually needed.  (We only go through the loop a
        // maximum of two times.)
        //
        do {

            if (pInfo != NULL) {
                TraceFree(pInfo);
            }
            pInfo = (LPENUM_SERVICE_STATUS_PROCESS)TraceAlloc( LMEM_FIXED, cbInfo );
            if (!pInfo) {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }

            dwErr = ERROR_SUCCESS;
            if (!EnumServicesStatusEx(
                    hScm,
                    SC_ENUM_PROCESS_INFO,
                    SERVICE_WIN32,
                    SERVICE_ACTIVE,
                    (LPBYTE)pInfo,
                    cbInfo,
                    &cbInfo,
                    &dwNumServices,
                    &dwResume,
                    NULL)) {
                dwErr = GetLastError();
            }
        }
        while ((ERROR_MORE_DATA == dwErr) && (++cLoop < cLoopMax));

        if ((ERROR_SUCCESS == dwErr) && dwNumServices) {
            *ppInfo = pInfo;
        } else {
            if (pInfo != NULL) {
                TraceFree(pInfo);
                pInfo = NULL;
            }
            dwNumServices = 0;
        }

        CloseServiceHandle(hScm);
    }

    RETURN(dwNumServices);
}

//
// EnumWindowsProc( )
//
BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    LPARAM  lParam
    )
{
    // TraceFunc( "EnumWindowsProc( )\n" );

    LPTASKITEM pTask = (LPTASKITEM) lParam;
    DWORD pid;
    DWORD dwLen;

    if (!GetWindowThreadProcessId( hwnd, &pid ))
    {
        // RETURN(TRUE); // keep enumerating
        return TRUE;
    }

    if ( pTask->dwProcessId != pid )
    {
        // RETURN(TRUE); // keep enumerating
        return TRUE;
    }

    if ( GetWindow( hwnd, GW_OWNER )
      || !(GetWindowLong( hwnd, GWL_STYLE ) & WS_VISIBLE ) )
    {   // not a top level window
        // RETURN(TRUE); // keep enumerating
        return TRUE;
    }

    dwLen = GetWindowTextLength( hwnd ) + 1;
    pTask->pszServiceName = (LPWSTR) TraceAllocString( LMEM_FIXED, dwLen );
    if ( pTask->pszServiceName )
    {
        GetWindowText( hwnd, pTask->pszServiceName, dwLen );
    }

    // RETURN(FALSE);  // hummm ... found it - stop enumeration
    return FALSE;
}

//
// CheckForRunningApplications( )
//
// Returns: TRUE - possibly "unsafe" running applications/services
//          FALSE - Ok to continue.
//
BOOL
CheckForRunningApplications(
    HWND hwndList )
{
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo;
    NTSTATUS    status;
    ULONG       TotalOffset;
    LV_ITEM     lvI;
    LPENUM_SERVICE_STATUS_PROCESS pServiceInfo;
    BOOL        fReturn = FALSE;
    SC_HANDLE   hScm;
    LPTASKITEM  pTask;
    HKEY        hkey;
    LRESULT     lResult;
    DWORD       dwNumServices;

    TraceFunc( "CheckForRunningApplications( )\n" );

    ListView_DeleteAllItems( hwndList );

    lvI.mask        = LVIF_TEXT | LVIF_PARAM;
    lvI.iSubItem    = 0;

    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

    lResult = RegOpenKey( HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services", &hkey );
    Assert( lResult == ERROR_SUCCESS );

    dwNumServices = GetServiceProcessInfo( &pServiceInfo );

    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
retry:

    if ( g_pBuffer == NULL )
    {
        g_pBuffer = (LPBYTE) VirtualAlloc ( NULL, g_cbBuffer, MEM_COMMIT, PAGE_READWRITE);
        if ( g_pBuffer == NULL )
        {
            RRETURN(TRUE); // be paranoid and show page
        }
    }

    status = NtQuerySystemInformation( SystemProcessInformation,
                                       g_pBuffer,
                                       g_cbBuffer,
                                       NULL );

    if ( status == STATUS_INFO_LENGTH_MISMATCH ) {
        g_cbBuffer += 8192;
        VirtualFree ( g_pBuffer, 0, MEM_RELEASE );
        g_pBuffer = NULL;
        goto retry;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) g_pBuffer;
    TotalOffset = 0;
    while ( TRUE )
    {
        LPWSTR pszImageName;
        INT    iCount = 0;

        if ( ProcessInfo->ImageName.Buffer )
        {
            pszImageName = wcsrchr( ProcessInfo->ImageName.Buffer, L'\\' );
            if ( pszImageName ) {
                pszImageName++;
            }
            else {
                pszImageName = ProcessInfo->ImageName.Buffer;
            }
        }
        else {
            goto skiptask;            // system process, skip it
        }

        if (g_hCompatibilityInf != INVALID_HANDLE_VALUE) {
            INFCONTEXT Context;
            if (SetupFindFirstLine( 
                        g_hCompatibilityInf,
                        L"ProcessesToIgnore",
                        pszImageName,
                        &Context )) {
                DebugMsg( "Skipping process %s, it's listed in inf exemption list...\n", pszImageName );
                goto skiptask;
            }
        }

#ifdef DEBUG
        if ( StrStrI( L"MSDEV.EXE", pszImageName ) || StrStrI( L"NTSD.EXE", pszImageName ) )
            goto skiptask; // allowed process
#endif

        //
        // othewize, it is an unknown or not allowed process
        // add it to the listview
        //
        fReturn = TRUE;

        pTask = (LPTASKITEM) TraceAlloc( LMEM_FIXED, sizeof(TASKITEM) );
        if ( !pTask )
            goto skiptask;
        pTask->pszImageName = (LPWSTR) TraceStrDup( pszImageName );
        if ( !pTask->pszImageName )
            goto skiptask;
        pTask->dwProcessId = (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId;
        pTask->pszServiceName = NULL;

        if ( dwNumServices )
        {
            // For each service with this process id, append it's service
            // name to the buffer.  Separate each with a comma.
            //
            DWORD  iSvc;
            WCHAR  szText[ MAX_PATH ];  // random

            for ( iSvc = 0; iSvc < dwNumServices; iSvc++ )
            {
                if ( pTask->dwProcessId == pServiceInfo[iSvc].ServiceStatusProcess.dwProcessId )
                {
                    LPWSTR pszServiceName = pServiceInfo[iSvc].lpServiceName;

                    if (hScm)
                    {
                        ULONG cbSize = ARRAYSIZE(szText);
                        if ( GetServiceDisplayName( hScm, pServiceInfo[iSvc].lpServiceName, szText, &cbSize ) )
                        {
                            pszServiceName = szText;
                        }
                    }

                    size_t cch = wcslen( pszServiceName ) + 1;

                    if ( !pTask->pszServiceName )
                    {
                        pTask->pszServiceName = (LPWSTR) TraceAllocString( LMEM_FIXED, cch);
                        if ( pTask->pszServiceName )
                        {
                            wcscpy( pTask->pszServiceName, pszServiceName );
                        }
                    }
                    else
                    {   // not the most efficent, but it'll work
                        LPWSTR pszNew = (LPWSTR) TraceAllocString( LMEM_FIXED, wcslen(pTask->pszServiceName) + 1 + cch );
                        if ( pszNew )
                        {
                            wcscpy( pszNew, pTask->pszServiceName );
                            wcscat( pszNew, L"," );
                            wcscat( pszNew, pszServiceName );
                            TraceFree( pTask->pszServiceName );
                            pTask->pszServiceName = pszNew;
                        }
                    }
                }
            }
        }

        if ( hkey && !pTask->pszServiceName )
        {
            DWORD  iSvc = 0;
            WCHAR  szService[ MAX_PATH ]; // random

            while ( RegEnumKey( hkey, iSvc, szService, ARRAYSIZE(szService) ) )
            {
                HKEY  hkeyService;
                WCHAR szPath[ MAX_PATH ];
                LONG  cb = ARRAYSIZE(szPath);
                lResult = RegOpenKey( hkey, szService, &hkeyService );
                Assert( lResult );

                lResult = RegQueryValue( hkeyService, L"ImagePath", szPath, &cb );
                Assert( lResult );

                if ( StrStrI( szPath, pTask->pszImageName ) )
                {   // match!
                    WCHAR  szText[ MAX_PATH ];  // random
                    cb = ARRAYSIZE(szText);
                    lResult = RegQueryValue( hkeyService, L"DisplayName", szText, &cb );
                    if ( lResult == ERROR_SUCCESS )
                    {
                        pTask->pszServiceName = (LPWSTR) TraceStrDup( szText );
                        break;
                    }
                }

                RegCloseKey( hkeyService );
                iSvc++;
            }
        }

        if ( !pTask->pszServiceName )
        {
            EnumWindows( &EnumWindowsProc, (LPARAM) pTask );
        }

        lvI.cchTextMax  = wcslen(pTask->pszImageName);
        lvI.lParam      = (LPARAM) pTask;
        lvI.iItem       = iCount;
        lvI.pszText     = pTask->pszImageName;

        iCount = ListView_InsertItem( hwndList, &lvI );
        Assert( iCount != -1 );
        if ( iCount == -1 )
            goto skiptask;

        if ( pTask->pszServiceName )
        {
            ListView_SetItemText( hwndList, iCount, 1, pTask->pszServiceName );
        }

skiptask:
        if ( ProcessInfo->NextEntryOffset == 0 ) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&g_pBuffer[TotalOffset];
    }

    if ( hScm )
    {
        CloseServiceHandle(hScm);
    }

    if ( pServiceInfo )
    {
        TraceFree( pServiceInfo );
    }

    RegCloseKey( hkey );

    RETURN(fReturn);
}

//
// ApplicationDlgProc()
//
INT_PTR CALLBACK
ApplicationDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        {
            LV_COLUMN   lvC;
            WCHAR       szText[ 80 ];
            INT         i;
            HWND        hwndList = GetDlgItem( hDlg, IDC_L_PROCESSES );
            RECT        rect;
            DWORD       dw;

            // Create the columns
            lvC.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt     = LVCFMT_LEFT;
            lvC.pszText = szText;

            // Add first column
            lvC.iSubItem = 0;
            lvC.cx       = 100;
            dw = LoadString( g_hinstance, IDS_PROCESS_NAME_COLUMN, szText, ARRAYSIZE(szText));
            Assert( dw );
            i = ListView_InsertColumn ( hwndList, 0, &lvC );
            Assert( i != -1 );

            // Add second column
            lvC.iSubItem++;
            GetWindowRect( hwndList, &rect );
            lvC.cx       = ( rect.right - rect.left ) - lvC.cx; // autosize - make Tony happy
            dw = LoadString( g_hinstance, IDS_APPL_NAME_COLUMN, szText, ARRAYSIZE(szText));
            Assert( dw );
            i = ListView_InsertColumn ( hwndList, lvC.iSubItem, &lvC );
            Assert( i != -1 );
        }
        return FALSE;

    case WM_DESTROY:
        VirtualFree ( g_pBuffer, 0, MEM_RELEASE );
        g_pBuffer = NULL; // paranoid
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_WIZNEXT:
#if 0
            if ( CheckForRunningApplications( GetDlgItem( hDlg, IDC_L_PROCESSES ) ) )
            {
                MessageBoxFromStrings( hDlg, IDS_NOT_ALL_PROCESSES_KILLED_TITLE, IDS_NOT_ALL_PROCESSES_KILLED_TEXT, MB_OK );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
            }
#endif
            break;

        case PSN_SETACTIVE:
            {
                if ( !CheckForRunningApplications( GetDlgItem( hDlg, IDC_L_PROCESSES ) ) )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                    break;
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                ClearMessageQueue( );
            }
            break;

        case LVN_DELETEALLITEMS:
            TraceMsg( TF_WM, "LVN_DELETEALLITEMS - Deleting all items.\n" );
            break;

        case LVN_DELETEITEM:
            TraceMsg( TF_WM, "LVN_DELETEITEM - Deleting an item.\n" );
            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                HWND   hwndList = GetDlgItem( hDlg, IDC_L_PROCESSES );
                LPTASKITEM pTask;
                LVITEM lvi;
                BOOL   b;

                lvi.iItem    = pnmv->iItem;
                lvi.iSubItem = 0;
                lvi.mask     = LVIF_PARAM;
                b = ListView_GetItem( hwndList, &lvi );
                Assert( b );
                pTask = (LPTASKITEM) lvi.lParam;
                Assert( pTask );
                TraceFree( pTask->pszImageName );
                TraceFree( pTask->pszServiceName );
                TraceFree( pTask );
            }
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\callback.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: CALLBACK.CPP

 ***************************************************************************/

#include "pch.h"
#include "utils.h"
#include "tasks.h"
#include "setup.h"
#include "callback.h"
#include "logging.h"
#include "userenv.h"

// Must have this...
extern "C" {
#include <sysprep_.h>
//
// SYSPREP globals
//
extern BOOL    NoSidGen;
extern BOOL    PnP;
}

DEFINE_MODULE("RIPREP")

DWORD g_WorkerThreadId = 0;
HANDLE g_WorkerThreadHandle = INVALID_HANDLE_VALUE;
HWND g_hMainWindow = NULL;
HWND g_hTasksDialog = NULL;
DWORD g_NeedDlg = NULL;

#define NCOLORSHADES        32

//
// Spin( )
//
DWORD
Spin( )
{
    TraceFunc( "Spin( )\n" );
    DWORD dwResult;
    MSG Msg;

    // We will spin in here until the end
    while ( WAIT_TIMEOUT == (dwResult = WaitForSingleObject( g_WorkerThreadHandle, 50 )) )
    {
        while ( PeekMessage( &Msg, NULL, NULL, NULL, PM_REMOVE ) )
        {
            if (Msg.message == WM_SYSKEYUP)
                continue; // ignore

            if (Msg.message == WM_KEYDOWN)
                continue; // ignore

            if (Msg.message == WM_KEYUP)
                continue; // ignore

            TranslateMessage( &Msg );
            DispatchMessage( &Msg );
        }
    }

    RETURN(dwResult);
}
//
// WorkerThreadProc( )
//
DWORD
WorkerThreadProc(
    LPVOID lParam )
{
    // Place in the log all the gathered information for the wizard
    // as well as system APIs.
    LogMsg( L"Server      : %s\r\n", g_ServerName );
    LogMsg( L"Image Dir   : %s\r\n", g_MirrorDir );
    LogMsg( L"Language    : %s\r\n", g_Language );
    LogMsg( L"Architecture: %s\r\n", g_Architecture );
    LogMsg( L"Description : %s\r\n", g_Description );
    LogMsg( L"HelpText    : %s\r\n", g_HelpText );
    LogMsg( L"SystemRoot  : %s\r\n", g_SystemRoot );
    LogMsg( L"Winnt Dir   : %s\r\n", g_WinntDirectory );

    // Start the IMIRROR task list
    DWORD dw = ProcessToDoItems( );
    DebugMsg( "ProcessToDoItems( ) completed: 0x%08x\n", dw );
    return dw;
}

HWND g_hParent = NULL;

//
// MainWindowProc ( )
//
LRESULT CALLBACK
MainWindowProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    static WCHAR szTitle[ 256 ];
    static DWORD dwTitleLength;
    static HFONT BigBoldFont = NULL;

    switch(uMsg)
    {
    case WM_NCCREATE:
        return TRUE;   // keep going

    case WM_CREATE:
        {
            DWORD dw;
            dw = LoadString( g_hinstance, IDS_APPNAME, szTitle, ARRAYSIZE(szTitle));
            Assert(dw);
            dwTitleLength = wcslen( szTitle );
        }
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            RECT rc;
            LOGBRUSH brush;
            HBRUSH hBrush;
            HBRUSH hOldBrush;
            HFONT  hFont;
            INT    n = 0;

            BeginPaint( hDlg, &ps );
            rc.left = 0;
            rc.right = GetSystemMetrics(SM_CXVIRTUALSCREEN);
            rc.bottom = GetSystemMetrics(SM_CYVIRTUALSCREEN);
            INT yDelta= max(rc.bottom/NCOLORSHADES,1);  // height of one shade band
            rc.top = rc.bottom - yDelta;

            // Shade the background
            while (rc.top >= 0)
            {
                brush.lbColor = RGB(0, 0, (256*n)/NCOLORSHADES);
                brush.lbStyle = BS_SOLID;
                hBrush = (HBRUSH) CreateBrushIndirect( &brush );
                hOldBrush = (HBRUSH) SelectObject(ps.hdc, hBrush);
                FillRect( ps.hdc, &rc, hBrush );
                SelectObject(ps.hdc, hOldBrush);
                DeleteObject(hBrush);
                rc.top -= yDelta;
                rc.bottom -= yDelta;
                n++;
            }

            if ( !BigBoldFont )
            {
                HFONT Font;
                LOGFONT LogFont;
                WCHAR FontSizeString[24];
                INT FontSize;

                Font = (HFONT) GetStockObject( SYSTEM_FONT );
                if ( (Font ) && GetObject( Font, sizeof(LOGFONT), &LogFont) )
                {
                    DWORD dw = LoadString( g_hinstance,
                                           IDS_LARGEFONTNAME,
                                           LogFont.lfFaceName,
                                           LF_FACESIZE);
                    Assert( dw );

                    LogFont.lfWeight = 700;
                    FontSize = yDelta;

                    LogFont.lfHeight = 0 - (GetDeviceCaps(ps.hdc,LOGPIXELSY) * FontSize / 72);
                    LogFont.lfWidth = 0;

                    BigBoldFont = CreateFontIndirect(&LogFont);

                }
            }

            // Redraw the title
            SetBkMode( ps.hdc, TRANSPARENT );
            SelectObject( ps.hdc, BigBoldFont );
            SetTextColor( ps.hdc, RGB( 255, 255, 255 ) );
            TextOut(ps.hdc, yDelta, yDelta, szTitle, dwTitleLength );

            EndPaint( hDlg, &ps );
        }
        break;

    case WM_CHAR:
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_MOUSEACTIVATE:
    case WM_MOUSEMOVE:
    case WM_MOUSEWHEEL:
        break; // ignore

    case WM_DESTROY:
        if ( BigBoldFont )
            DeleteObject( BigBoldFont );
        break;

    case WM_ERASEBKGND:
        // Don't waste time erasing
        return TRUE; // non-zero

    default:
        return DefWindowProc( hDlg, uMsg, wParam, lParam );
    }

    return FALSE;
}


//
// BeginProcess( )
//
HRESULT
BeginProcess(
    HWND hParent)
{
    TraceFunc( "BeginProcess( )\n" );

    MSG Msg;
    WNDCLASSEX wndClass;
    ATOM atom;
    RECT rc;
    HWND hwndDesktop = GetDesktopWindow( );
    DWORD dwExStyle;
    GetWindowRect( hwndDesktop, &rc );

    // Create our window class
    ZeroMemory( &wndClass, sizeof(wndClass) );
    wndClass.cbSize         = sizeof(wndClass);
    wndClass.hbrBackground  = (HBRUSH) COLOR_BACKGROUND;
    wndClass.hInstance      = g_hinstance;
    wndClass.lpfnWndProc    = (WNDPROC) &MainWindowProc;
    wndClass.lpszClassName  = L"MondoWindow";
    wndClass.style          = CS_CLASSDC | CS_NOCLOSE;

    atom = RegisterClassEx( &wndClass );
    Assert( atom );

    g_hParent = hParent;
#ifdef DEBUG
    dwExStyle = ( g_dwTraceFlags ? 0 :  WS_EX_TOPMOST );
#else
    dwExStyle = WS_EX_TOPMOST;
#endif
    g_hMainWindow = CreateWindowEx( dwExStyle,
                                    L"MondoWindow",
                                    L"",
                                    WS_POPUP | WS_VISIBLE,
                                    GetSystemMetrics(SM_XVIRTUALSCREEN), GetSystemMetrics(SM_YVIRTUALSCREEN),
                                    GetSystemMetrics(SM_CXVIRTUALSCREEN), GetSystemMetrics(SM_CYVIRTUALSCREEN),
                                    NULL,
                                    NULL,
                                    g_hinstance,
                                    NULL );
    Assert( g_hMainWindow );
    g_hTasksDialog = CreateDialog(g_hinstance, MAKEINTRESOURCE(IDD_TASKS), g_hMainWindow, TasksDlgProc );

    if ( g_hTasksDialog )
    {
        g_WorkerThreadHandle = CreateThread( NULL, NULL, WorkerThreadProc, NULL, 0, &g_WorkerThreadId );
        Spin( );
        SendMessage( g_hTasksDialog, WM_DESTROY, 0, 0 );
    }

    HRETURN(S_OK);
}


//
// IsFileInExclusionList()
//
BOOLEAN
IsFileInExclusionList(
    IN PCWSTR FileName
    )
/*++

Description:

    This routine searches the exclusion list in our INF file.

Parameters:

    FileName   : File to search the INF for.

Return Value:

    TRUE - The file does exist in the INF
    
    FALSE - The file does not exist in the INF

++*/
{
    #define SKIPFLAG_DIRECTORY       1
    #define SKIPFLAG_FILTEREXTENSION 2
    
    PWSTR           FullPath = NULL;
    PWSTR           DirectoryName = NULL;
    INFCONTEXT      Context;
    INT             Flags = 0;
    WCHAR           FilterExtension[10];
    BOOLEAN         ReturnValue = FALSE;


    //
    // Make sure we have our INF.
    //
    if( g_hCompatibilityInf == INVALID_HANDLE_VALUE ) {

        //
        // Probably hasn't been initialized yet.  Assume the
        // file isn't in the INF.
        //
        return FALSE;
    }


    if( FileName == NULL ) {
        return FALSE;
    }


    //
    // Get a local copy of the filename so we can operate on it
    // without worry of corrupting the caller's data.
    //
    if( wcsncmp(FileName, L"\\\\?\\", 4) == 0 ) {
        FullPath = (PWSTR)TraceStrDup( FileName+4 );    
    } else {
        FullPath = (PWSTR)TraceStrDup( FileName );    
    }

    if( FullPath == NULL ) {
        DebugMsg( "IsFileInExclusionList: Odd pathname %s.\n",
                  FileName );
        return FALSE;
    }


    //
    // See if it's explicitly listed in the INF
    //
    if (SetupFindFirstLine( g_hCompatibilityInf,
                            L"FilesToSkipCopy",
                            FullPath,
                            &Context)) {
        DebugMsg( "IsFileInExclusionList: Found file %s in the INF exclusion list.\n",
                  FullPath );
        ReturnValue = TRUE;
        goto Cleanup;
    }



    //
    // The file isn't specifically listed in the INF.  See if
    // the directory this file is in is listed.
    //
    // Start whacking file/directory names off the end of the
    // path to see if the result is in our exclusion list.
    //

    //
    // Remember the filename.
    //
    FileName = wcsrchr(FullPath, L'\\');

    if( FileName == NULL ) {
        DebugMsg( "IsFileInExclusionList: File isn't in exclusion list and has no directory path.\n" );
        ReturnValue = FALSE;
        goto Cleanup;
    }

    FileName++;


    while( DirectoryName = wcsrchr(FullPath, L'\\') ) {
        *DirectoryName = NULL;

        if( SetupFindFirstLine( g_hCompatibilityInf,
                                L"FilesToSkipCopy",
                                FullPath,
                                &Context)) {

            //
            // The directory name *IS* in there.  See if we need to
            // skip all files in this directory, or only some.
            //
            Flags = 0;
            if( SetupGetIntField( &Context, 1, &Flags)  &&
                ((Flags & SKIPFLAG_FILTEREXTENSION) == 0)) {

                //
                // We don't have the filter flag, so we will just
                // skip all files in this directory.
                //
                DebugMsg( "IsFileInExclusionList: Found file %s in %s in the exclusion list (based on the name of his directory).\n", 
                          FileName,
                          FullPath );

                ReturnValue = TRUE;
                goto Cleanup;
            }

            //
            // See if we should skip files with a specified extension.
            //
            if( SetupGetStringField( &Context,
                                     2,
                                     FilterExtension,
                                     ARRAYSIZE(FilterExtension),
                                     NULL )) {
                PCWSTR q = wcsrchr( FileName, L'.' );
                if (q) {
                    q++;
                    
                    if (_wcsicmp(q, FilterExtension) == 0) {
                        DebugMsg( "IsFileInExclusionList: Found file %s in %s with extension %s in the exclusion list (based on the directory and extension of the file).\n",
                                  FileName,
                                  FullPath,
                                  q );
                        ReturnValue = TRUE;
                        goto Cleanup;
                    }
                }
            }
        }
    }

Cleanup:
    if( FullPath ) {
        DebugMemoryDelete( FullPath );
    }

    return ReturnValue;
}



//
// ConvTestErrorFn()
//
NTSTATUS
ConvTestErrorFn(
    IN PVOID Context,
    IN NTSTATUS Status,
    IN IMIRROR_TODO IMirrorFunctionId
    )
{
    TraceFunc( "ConvTestErrorFn( ... )\n" );

    WCHAR szMessage[ 256 ];
    DWORD dw;

    LBITEMDATA item;

    if ( Status != ERROR_SUCCESS )
    {
        DebugMsg("ERROR REPORTED! : Context 0x%x, Status 0x%x, In Func 0x%x\n", Context, Status, IMirrorFunctionId );

        // Error will be logged in TASKS.CPP
        item.fSeen = FALSE;
        item.pszText = (IMirrorFunctionId == CheckPartitions) ? NULL : (LPWSTR)Context;
        item.uState = Status;   // used as input and output
        item.todo = IMirrorFunctionId;

        BOOL b = (BOOL)SendMessage( g_hTasksDialog, WM_ERROR, 0, (LPARAM) &item );
        if ( !b )
        {
            Status = ERROR_REQUEST_ABORTED;
        }
        else
        {
            Status = item.uState;
        }

        if ( Status == ERROR_SUCCESS )
        {
            dw = LoadString( g_hinstance, IDS_ERROR_IGNORED, szMessage, ARRAYSIZE( szMessage ));
            Assert( dw );
        }
        else if ( Status == STATUS_RETRY )
        {
            dw = LoadString( g_hinstance, IDS_STATUS_RETRY, szMessage, ARRAYSIZE( szMessage ));
            Assert( dw );
        }
        else // other should be abort
        {
            Assert( Status == ERROR_REQUEST_ABORTED );
            dw = LoadString( g_hinstance, IDS_OPERATION_ABORTED, szMessage, ARRAYSIZE( szMessage ));
            Assert( dw );
            ClearAllToDoItems(FALSE);
        }

        Assert( dw );
        LogMsg( szMessage );
    }

    RETURN(Status);
}

NTSTATUS
ConvTestNowDoingFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String
    )
{
    TraceFunc( "ConvTestNowDoingFn( )\n" );
    LPWSTR  pszMessage;
    WCHAR   szMessage[ 256 ];
    LPWSTR  pszString;
    HWND    hwnd = GetDlgItem( g_hTasksDialog, IDC_L_TASKS );
    INT     uCount;
    DWORD   dw;
    LPLBITEMDATA pitem = NULL;
    NTSTATUS Status = ERROR_SUCCESS;

    static  lastToDo = IMirrorNone;

    static BOOL fAlreadyAdjusted = FALSE;

    if ( String ) {
        pszString = (LPWSTR)TraceStrDup( String );
        // DebugMsg( "Received: %s\n", String );
    } else {
        pszString = NULL;
    }

    // if we are onto another task, mark the previous one done
    // and mark this one as started.
    if ( lastToDo != Function )
    {
        uCount = ListBox_GetCount( hwnd );
        while (uCount>=0)
        {
            LRESULT lResult = ListBox_GetItemData( hwnd, uCount );
            uCount--;
            if ( lResult == LB_ERR )
                continue;

            pitem = (LPLBITEMDATA) lResult;
            pitem->fSeen = TRUE;

            if ( pitem->todo == Function )
            {
                if ( pitem->uState == STATE_NOTSTARTED )
                {
                    pitem->uState = STATE_STARTED;
                    InvalidateRect( hwnd, NULL, TRUE );    // force redraw
                }
            }
            else
            {
                if ( pitem->uState == STATE_STARTED )
                {
                    pitem->uState = STATE_DONE;
                    InvalidateRect( hwnd, NULL, TRUE );    // force redraw
                }
            }
        }

        lastToDo = Function;
    }

    switch (Function) {
    case IMirrorInitialize:
        dw = LoadString( g_hinstance, IDS_INITIALIZING, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;
    case VerifySystemIsNt5:
        dw = LoadString( g_hinstance, IDS_VERIFYING_WINDOWS_VERSION, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;
    case CheckPartitions:
        dw = LoadString( g_hinstance, IDS_ANALYZING_PARTITIONS, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;
    case CopyPartitions:
        dw = LoadString( g_hinstance, IDS_COPYING_PARTITIONS, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;
    case CopyFiles:
        if ( pszString == NULL )
        { // Only need to do this once.

            WCHAR           ProfilesDirectory[MAX_PATH];
            OSVERSIONINFO   OsVersion;
            
            //
            // Begin SYSPREP ops
            //
            if( !NoSidGen && !IsSetupClPresent() )
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"SETUPCL.EXE";
                item.uState  = ERROR_FILE_NOT_FOUND;
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
                Status = STATUS_REQUEST_ABORTED;
            }

            //
            // Prepare to run Setupcl.  This will also call into
            // RunExternalUniqueness which gives others a chance to save 
            // any info that needs to be copied to the server.
            //
            if (!NoSidGen && !PrepForSidGen())
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"Preparing SIDs error";
                item.uState  = ERROR_FILE_NOT_FOUND;
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
                Status = STATUS_REQUEST_ABORTED;
            } 
            
            //
            // Syprep cleanup which updates files that are required to be copied
            // over to the server.
            //            
            if (!AdjustFiles())
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"Adjusting files error";
                item.uState  = ERROR_FILE_NOT_FOUND;
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
                Status = STATUS_REQUEST_ABORTED;
            }                    


#ifndef _IA64_

            //
            // Make sure we're on something reasonably current before
            // we attempt to ReArm the license.  The APIs just didn't
            // exist on win2k.
            //

            OsVersion.dwOSVersionInfoSize  = sizeof(OSVERSIONINFO);
            if( (GetVersionEx(&OsVersion)) &&
                (OsVersion.dwMajorVersion >= 5) &&
                (OsVersion.dwMinorVersion >= 1) ) {

                dw = ReArm();
                if( dw != ERROR_SUCCESS ) {
                    LBITEMDATA item;

                    // Error will be logged in TASKS.CPP
                    item.fSeen   = FALSE;
                    item.pszText = L"Rearming";
                    item.uState  = dw;
                    item.todo    = Function;

                    SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
                    Status = STATUS_REQUEST_ABORTED;
                }

            }
#endif


            //
            // We need to assign a DirectoryID to the directory containing
            // the user profiles.  There is no hardcoded DirID for this, so
            // we'll make one up and tell Setupapi about it.
            //
            dw = MAX_PATH;
            if( !GetProfilesDirectory( ProfilesDirectory,
                                       &dw ) ) {

                //
                // We should never get here, but just in case.
                //
                wcscpy( ProfilesDirectory, L"C:\\Documents and Settings" );
            }

            if (g_hCompatibilityInf != INVALID_HANDLE_VALUE) {

                if( !SetupSetDirectoryId( g_hCompatibilityInf,
                                          PROFILES_DIRID,
                                          ProfilesDirectory ) ) {

                    ASSERT( FALSE && L"Unable to SetupSetDirectoryId for user profiles" );
                }
            }


            //
            // End SYSPREP ops
            //
        }
        else // if ( pszString )
        {

            if( IsFileInExclusionList(pszString) ) {

                //
                // It's in the exclusion list.
                //
                DebugMsg( "ConvTestNowDoingFn: Skipping file %s because it's in the INF exclusion list.\n", 
                          pszString );
                RETURN(E_FAIL);
            }
        
        }
        dw = LoadString( g_hinstance, IDS_COPYING_FILES, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;

    case CopyRegistry:
        //
        // Begin SYSPREP ops
        //

        Status = ERROR_SUCCESS;
        if ( IsDomainMember( ) )
        {
RetryUnjoin:
            Status = NetUnjoinDomain( NULL, NULL, NULL, 0 );
            if ( Status != NERR_Success )
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"Remove from Domain Error";
                item.uState  = Status;
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR, 0, (LPARAM) &item );

                if ( Status == ERROR_SUCCESS )
                {
                    dw = LoadString( g_hinstance, IDS_ERROR_IGNORED, szMessage, ARRAYSIZE( szMessage ));
                }
                else if ( Status == STATUS_RETRY )
                {
                    dw = LoadString( g_hinstance, IDS_STATUS_RETRY, szMessage, ARRAYSIZE( szMessage ));
                }
                else // other should be abort
                {
                    Assert( Status == ERROR_REQUEST_ABORTED );
                    dw = LoadString( g_hinstance, IDS_OPERATION_ABORTED, szMessage, ARRAYSIZE( szMessage ));
                }

                Assert( dw );
                LogMsg( szMessage );

                if ( Status == STATUS_RETRY )
                {
                    goto RetryUnjoin;
                }
            }
        }

        if( !fAlreadyAdjusted )
        {
            WCHAR szSrcPath[MAX_PATH];
            fAlreadyAdjusted = TRUE;

            wsprintf( szSrcPath, L"%s\\ristndrd.sif", g_ImageName );

            
            //
            // We are going to munge some system values. Prevent us for bailing
            // without a reboot.
            //
            g_fRebootOnExit = TRUE;
            
            
            if ( Status != ERROR_SUCCESS
                 || !RemoveNetworkSettings(szSrcPath)
                 || !AdjustRegistry( FALSE /* no, do not remove networking*/) )
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"Registry Error";
                item.uState  = GetLastError( );
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
                Status = STATUS_REQUEST_ABORTED;
            }
        }

        if ( Status == ERROR_SUCCESS )
        {
            NukeMruList();
        }
        else
        {
            ClearAllToDoItems(FALSE);
        }

        //
        // End SYSPREP ops
        //

        dw = LoadString( g_hinstance, IDS_COPYING_REGISTRY, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case PatchDSEntries:
        dw = LoadString( g_hinstance, IDS_UPDATING_DS_ENTRIES, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case RebootSystem:
        dw = LoadString( g_hinstance, IDS_REBOOTING_SYSTEM, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    default:
        dw = LoadString( g_hinstance, IDS_DOING_UNKNOWN_TASK, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
    }

    pszMessage = (LPWSTR) TraceStrDup( szMessage );
    if ( !pszMessage )
        RETURN(E_OUTOFMEMORY);

    PostMessage( g_hTasksDialog, WM_UPDATE, (WPARAM)pszMessage, (LPARAM)pszString );
    // These were handed off to another thread. Don't track them anymore in
    // this thread.
    DebugMemoryDelete( pszMessage );
    if (pszString) {
        DebugMemoryDelete( pszString );
    }

    if ( Status != NO_ERROR )
    {
        if( pitem ) {
            pitem->uState = STATE_ERROR;
        }
        InvalidateRect( hwnd, NULL, TRUE );    // force redraw
        ClearAllToDoItems(FALSE);
    }

    RETURN(Status);
}

NTSTATUS
ConvTestGetServerFn(
    IN PVOID Context,
    OUT PWSTR Server,
    IN OUT PULONG Length
    )
{
    TraceFunc( "ConvTestGetServerFn( )\n" );

    StrCpy( Server, g_ServerName );

    *Length = (wcslen(Server) + 1) * sizeof(WCHAR);

    DebugMsg( "Sending: %s\n", Server );

    RETURN((*Length == sizeof(WCHAR)) ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS);
}

NTSTATUS
ConvTestGetMirrorDirFn(
    IN PVOID Context,
    OUT PWSTR Mirror,
    IN OUT PULONG Length
    )
{
    TraceFunc( "ConvTestGetMirrorDirFn( )\n" );
    

    wsprintf( Mirror,
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s",
              g_ServerName,
              g_Language,
              REMOTE_INSTALL_IMAGE_DIR_W,
              g_MirrorDir );
    CreateDirectory( Mirror, NULL );

    wsprintf( Mirror,
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s",
              g_ServerName,
              g_Language,
              REMOTE_INSTALL_IMAGE_DIR_W,
              g_MirrorDir,
              g_Architecture );
    CreateDirectory( Mirror, NULL );

    *Length = (wcslen(Mirror) + 1) * sizeof(WCHAR);

    DebugMsg( "Sending: %s\n", Mirror );

    RETURN((*Length == sizeof(WCHAR)) ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS);
}


NTSTATUS
ConvTestFileCreateFn(
    IN PVOID Context,
    IN PWSTR FileName,
    IN ULONG FileAction,
    IN ULONG Status
    )
{
    TraceFunc( "ConvTestFileCreateFn( )\n" );

    if (Status != 0) {

        if( IsFileInExclusionList( FileName ) ) {
            //
            // It's in the exclusion list.
            //
            DebugMsg( "ConvTestFileCreateFn: Skipping file %s because it's in the INF exclusion list.\n", 
                      FileName );
            Status = 0;
        }

        if (Status != 0) {
            Status = ConvTestErrorFn( FileName, Status, CopyFiles );
        }
    } else {

        DebugMsg("created %ws\n", FileName);
    }

    RETURN(Status);
}

NTSTATUS
ConvTestReinitFn(
    IN PVOID Context
    )
{
    TraceFunc( "ConvTestReinitFn()\n" );
    WCHAR Tmp[256] = L"c";

    if (Tmp[0] != 'c') {
        ClearAllToDoItems(FALSE);
        InitToDo();
    }
    RETURN(STATUS_SUCCESS);
}

NTSTATUS
ConvTestGetSetupFn(
    IN PVOID Context,
    IN PWSTR Server,
    OUT PWSTR SetupPath,
    IN OUT PULONG Length
    )
{
    TraceFunc( "ConvTestGetSetupFn()\n" );

    wcscpy( SetupPath, g_ImageName );
    *Length = wcslen( SetupPath );

    DebugMsg( "Sending: %s\n", SetupPath );

    RETURN(STATUS_SUCCESS);
}

NTSTATUS
ConvTestSetSystemFn(
    IN PVOID Context,
    IN PWSTR SystemPath,
    IN ULONG Length
    )
{
    NTSTATUS err;

    TraceFunc( "ConvTestSetSystemFn()\n" );

    if (Length <= ARRAYSIZE(g_SystemRoot)) {

        wcscpy( g_SystemRoot, SystemPath );
        err = STATUS_SUCCESS;

    } else {

        err = ERROR_BAD_LENGTH;
    }

    RETURN(err);
}

NTSTATUS
ConvAddToDoItemFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    )
{
    LPLBITEMDATA pitem;
    HWND hwnd = GetDlgItem( g_hTasksDialog, IDC_L_TASKS );
    WCHAR szMessage[ 256 ];
    DWORD dw;
    INT  uCount;

    TraceFunc( "ConvAddToDoItemFn()\n" );

    pitem = (LPLBITEMDATA) TraceAlloc( LMEM_FIXED, sizeof(LBITEMDATA));
    if ( !pitem)
        RETURN(E_OUTOFMEMORY);

    switch (Function) {
    case IMirrorInitialize:
        dw = LoadString( g_hinstance, IDS_INITIALIZE, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case VerifySystemIsNt5:
        dw = LoadString( g_hinstance, IDS_VERIFY_WINDOWS_VERSION, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case CheckPartitions:
        dw = LoadString( g_hinstance, IDS_ANALYZE_PARTITIONS, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case CopyPartitions:
        dw = LoadString( g_hinstance, IDS_COPY_PARTITIONS, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case CopyFiles:
        dw = LoadString( g_hinstance, IDS_COPY_FILES, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case CopyRegistry:
        dw = LoadString( g_hinstance, IDS_COPY_REGISTRY, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case PatchDSEntries:
        dw = LoadString( g_hinstance, IDS_PATH_DS_ENTRIES, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case RebootSystem:
        dw = LoadString( g_hinstance, IDS_REBOOT_SYSTEM, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    default:
        dw = LoadString( g_hinstance, IDS_UNKNOWN_TASK, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
    }

    pitem->pszText = (LPWSTR) TraceStrDup( szMessage );
    pitem->uState = STATE_NOTSTARTED;
    pitem->todo = Function;
    pitem->fSeen = FALSE;

    if ( !pitem->pszText )
    {
        TraceFree( pitem );
        RETURN(E_OUTOFMEMORY);
    }

    // skip the "done" items
    uCount = 0;
    while (uCount>=0)
    {
        LRESULT lResult = ListBox_GetItemData( hwnd, uCount );
        if ( lResult == LB_ERR )
            break;

        LPLBITEMDATA panitem = (LPLBITEMDATA) lResult;

        if ( panitem->uState == STATE_STARTED )
        {
            uCount++;
            break;
        }
        if ( panitem->uState != STATE_DONE )
            break;

        uCount++;
    }

    // go to end of the "unseen" items
    while (uCount>=0)
    {
        LRESULT lResult = ListBox_GetItemData( hwnd, uCount );
        if ( lResult == LB_ERR )
            break;

        LPLBITEMDATA panitem = (LPLBITEMDATA) lResult;

        uCount++;

        if ( panitem->fSeen )
        {
            uCount--;
            break;
        }
    }

    ListBox_InsertString( hwnd, uCount, pitem );
    InvalidateRect( hwnd, NULL, TRUE );    // force redraw
    DebugMsg( "Added ToDo Item (%d): %s\n", uCount, pitem->pszText );

    RETURN(STATUS_SUCCESS);
}

NTSTATUS
ConvRemoveToDoItemFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    )
{
    LPLBITEMDATA pitem;
    HWND hwnd = GetDlgItem( g_hTasksDialog, IDC_L_TASKS );
    INT uCount;

    TraceFunc( "ConvRemoveToDoItemFn()\n" );

    uCount = ListBox_GetCount( hwnd );
    while (uCount>=0)
    {
        LRESULT lResult = ListBox_GetItemData( hwnd, uCount );
        uCount--;
        if ( lResult == LB_ERR )
            continue;

        pitem = (LPLBITEMDATA) lResult;

        if ( pitem->todo == Function )
        {
            pitem->uState = STATE_STARTED;
            break;
        }
    }

    RETURN(STATUS_SUCCESS);
}

NTSTATUS
ConvRebootFn(
    IN PVOID Context
    )
{
    DWORD Error;

    // do the last minute things
    EndProcess( g_hTasksDialog );

#ifdef DEBUG
    // if Debugging, don't reboot
    if ( !g_dwTraceFlags )
    {
#endif

    if (!DoShutdown(FALSE)) {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"Shutdown Error";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
        return item.uState;
    }

    //
    // Prevent the error log from being displayed twice. Since
    // we are set to reboot/shutdown now, this flag can be    
    // safely reset.
    //
    g_fRebootOnExit = FALSE;

#ifdef DEBUG
    }
#endif

    return STATUS_SUCCESS;
}

BOOL
DoShutdown(
    IN BOOL Restart
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                 (BOOLEAN)TRUE,
                                 TRUE,
                                 &WasEnabled
                               );

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token
        //

        Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                     (BOOLEAN)TRUE,
                                     FALSE,
                                     &WasEnabled
                                   );
    }

    if (Restart) {
        return ExitWindowsEx( EWX_REBOOT | EWX_FORCEIFHUNG, 0 );
    } else {
        return InitiateSystemShutdown(NULL, NULL, 0, TRUE, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\callback.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: CALLBACK.H

 ***************************************************************************/

#ifndef _CALLBACK_H_
#define _CALLBACK_H_

extern DWORD g_NeedDlg;
extern HWND g_hMainWindow;

HRESULT
BeginProcess(
    HWND hParent );

NTSTATUS
ConvTestErrorFn(
    IN PVOID Context,
    IN NTSTATUS Status,
    IN IMIRROR_TODO IMirrorFunctionId
    );

NTSTATUS
ConvTestNowDoingFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String
    );

NTSTATUS
ConvTestGetServerFn(
    IN PVOID Context,
    OUT PWSTR Server,
    IN OUT PULONG Length
    );

NTSTATUS
ConvTestGetMirrorDirFn(
    IN PVOID Context,
    OUT PWSTR Mirror,
    IN OUT PULONG Length
    );

NTSTATUS
ConvTestFileCreateFn(
    IN PVOID Context,
    IN PWSTR FileName,
    IN ULONG FileAction,
    IN ULONG Status
    );

NTSTATUS
ConvTestReinitFn(
    IN PVOID Context
    );

NTSTATUS
ConvTestGetSetupFn(
    IN PVOID Context,
    IN PWSTR Server,
    OUT PWSTR SetupPath,
    IN OUT PULONG Length
    );

NTSTATUS
ConvTestSetSystemFn(
    IN PVOID Context,
    IN PWSTR SystemPath,
    IN ULONG Length
    );

NTSTATUS
ConvAddToDoItemFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    );

NTSTATUS
ConvRemoveToDoItemFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    );

NTSTATUS
ConvRebootFn(
    IN PVOID Context
    );

BOOL
DoShutdown(
    IN BOOL Restart
    );

#endif // _CALLBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\util.h ===
//
// Microsoft Corporation 1998
//
// UTIL.H - Function proto-types for util.cpp
//

LPTSTR CheckSlash (LPTSTR lpDir);
BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey);
BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rigpsnap\snapin.h ===
//
// Microsoft Corporation 1998
//
// SNAPIN.H - SnapIn class
//

class CSnapIn:
    public IComponent,
    public IExtendPropertySheet
{
protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    CComponentData      *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPIMAGELIST          m_pImageResult; // Result pane's image list interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    WCHAR                m_column1[20];  // Text for column 1
    INT                  m_nColumnSize;  // Size of column 1
    LONG                 m_lViewMode;    // View mode

    static unsigned int  m_cfNodeType;
    static TCHAR m_szDefaultIcon[];

public:
    CSnapIn(CComponentData *pComponent);
    ~CSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, LONG*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);
        
private:
    static INT_PTR CALLBACK ChoiceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK ReadmeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK _CreateDirectoryIfNeeded( LPOLESTR pszPath );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\compchk.cpp ===
#include "pch.h"
#pragma hdrstop

#include "compat.h"


DEFINE_MODULE( "RIPREP" )


BOOL
pIsDomainController(
    IN      PWSTR Server,
    OUT     PBOOL DomainControllerFlag
    )

/*++

Routine Description:

    Queries if the machine is a server or workstation via
    the NetServerGetInfo API.

Arguments:

    Server - The machine to query, or NULL for the local machine

    DomainControllerFlag - Receives TRUE if the machine is a
                           domain controller, or FALSE if the
                           machine is a workstation.

Return value:

    TRUE if the API was successful, or FALSE if not.  GetLastError
    gives failure code.

--*/


{
    PSERVER_INFO_101 si101;
    NET_API_STATUS nas;

    nas = NetServerGetInfo(
        Server,
        101,    // info-level
        (PBYTE *) &si101
        );

    if (nas != NO_ERROR) {
        SetLastError (nas);
        return FALSE;
    }

    if ((si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)) {
        //
        // We are dealing with a DC
        //
        *DomainControllerFlag = TRUE;
    } else {
        *DomainControllerFlag = FALSE;
    }

    NetApiBufferFree (si101);

    return TRUE;
}

BOOL
DCCheck(
    PCOMPATIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )

/*++

Routine Description:

    Check if the machine is a DC.  If so, then we add a compatibility
    entry.  DC's currently cannot be duplicated by RIPREP.

Arguments:

    CompatibilityCallback   - pointer to call back function
    Context     - context pointer

Return Value:

    Returns always TRUE.

--*/


{
    BOOL IsDC;
    
    if (!pIsDomainController(NULL, &IsDC) || (IsDC == TRUE)) {
        RIPREP_COMPATIBILITY_ENTRY CompEntry;
        WCHAR  Text[100];
         
        LoadString(g_hinstance, IDS_CANT_BE_DC_TITLE, Text, ARRAYSIZE(Text));
        ZeroMemory(&CompEntry, sizeof(CompEntry));
        CompEntry.SizeOfStruct= sizeof(RIPREP_COMPATIBILITY_ENTRY);
        CompEntry.Description = Text;
        CompEntry.TextName = L"dummy.txt";
        CompEntry.MsgResourceId = IDS_CANT_BE_DC_TEXT;
        CompatibilityCallback(&CompEntry,Context);

    }

    return(TRUE);

}

BOOL
GetProfileDirectory(
    OUT PWSTR OutputBuffer
    )
/*++

Routine Description:

    Retrieves the local profiles directory.  
    
    We query the registry to retreive this.

Arguments:

    OutputBuffer - buffer to receive the profiles directory.  Assumed to be 
                   MAX_PATH elements large.

Return Value:

    Returns TRUE on success.

--*/
{
    HKEY hKey;
    WCHAR Buffer[MAX_PATH],ProfilePath[MAX_PATH];
    DWORD Type,Size;
    LONG rslt;
    BOOL retval = FALSE;

    *OutputBuffer = NULL;

    rslt = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                    0,
                    KEY_QUERY_VALUE,
                    &hKey);

    if (rslt == NO_ERROR) {
        Size = sizeof(Buffer);
        rslt = RegQueryValueEx(
                        hKey,
                        L"ProfilesDirectory",
                        NULL,
                        &Type,
                        (LPBYTE)Buffer,
                        &Size);

        RegCloseKey(hKey);

        if (rslt == NO_ERROR) {
            if (ExpandEnvironmentStrings(Buffer,ProfilePath,ARRAYSIZE(ProfilePath))) {
                wcscpy( OutputBuffer, ProfilePath );
                retval = TRUE;
            }
        }
    }

    return(retval);

}

BOOL
MultipleProfileCheck(
    PCOMPATIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
/*++

Routine Description:

    Check if the machine has multiple user profiles.  If so, add a
    compatibility entry.
    
    If the machine has multiple user profiles, we want to warn the user as
    there may be sensitive data under the profiles that may make it
    onto a public server.
    

Arguments:

    CompatibilityCallback   - pointer to call back function
    Context     - context pointer

Return Value:

    Returns TRUE.

--*/
{
    WCHAR ProfilePath[MAX_PATH];
    WIN32_FIND_DATA FindData;
    DWORD DirectoryCount = 0;
    BOOL DoWarning = TRUE;
    
    if (GetProfileDirectory( ProfilePath )) {
        HANDLE hFind;

        wcscat( ProfilePath, L"\\*.*" );
        
        hFind =FindFirstFile(ProfilePath,&FindData);
        
        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    DirectoryCount += 1;
                }

            } while ( FindNextFile( hFind, &FindData));

            FindClose( hFind );
        }
    }

    //
    // if there are more than 5 directories, make a warning.  These directories
    // are:
    //          "."
    //          ".."
    //          "Administrator"
    //          "All Users"
    //          "Default User"
    //          "LocalService"
    //          "NetworkService"
    //
    if (DirectoryCount <= 7 && DirectoryCount != 0) {
        DoWarning = FALSE;
    }

    if (DoWarning) {   
        RIPREP_COMPATIBILITY_ENTRY CompEntry;
        WCHAR  Text[100];
    
        LoadString(g_hinstance, IDS_MULTIPLE_PROFILES, Text, ARRAYSIZE(Text));
        ZeroMemory(&CompEntry, sizeof(CompEntry));
        CompEntry.SizeOfStruct= sizeof(RIPREP_COMPATIBILITY_ENTRY);
        CompEntry.Description = Text;
        CompEntry.MsgResourceId = IDS_MULTIPLE_PROFILES_DESC;
        CompEntry.TextName = L"dummy.txt";
        CompatibilityCallback(&CompEntry,Context);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\compat.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    compat.cpp

Abstract:

    compatibility code -- adapted from winnt32u.dll's compatibility code.
    
Author:

    Andrew Ritz (AndrewR) 7-Jul-2000

Revision History:

    Andrew Ritz (andrewr) 7-Jul-2000 : Created It

--*/


#include "pch.h"
#pragma hdrstop

#include <TCHAR.H>
#include <commctrl.h>
#include <setupapi.h>
#include <spapip.h>
#include <stdlib.h>
#include "callback.h"
#include "utils.h"
#include "compat.h"
#include "logging.h"

DEFINE_MODULE( "RIPREP" )

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#define UnHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)|WS_VISIBLE)

#define MALLOC(_sz_) TraceAlloc(LMEM_FIXED,_sz_)
#define FREE(_ptr_)  TraceFree((PVOID)_ptr_)

#define AppTitleStringId  (IDS_APPNAME)

#define WM_MYSTOPSVC WM_APP+3
#define WM_DOSTOPSVC WM_APP+4
#define WM_STOPSVCCOMPLETE WM_APP+5

CRITICAL_SECTION CompatibilityCS;
HINF g_hCompatibilityInf = INVALID_HANDLE_VALUE;
LIST_ENTRY CompatibilityData;
DWORD CompatibilityCount;
DWORD ServicesToStopCount;
DWORD IncompatibilityStopsInstallation = FALSE;
DWORD GlobalCompFlags;
BOOL  UserCancelled;

BOOL AnyNt5CompatDlls = FALSE;

WNDPROC OldEditProc;

BOOL
FileExists(
    IN LPCTSTR FileName
    )
{
    WIN32_FIND_DATA fd;
    HANDLE hFile;

    hFile = FindFirstFile( FileName, &fd);
    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose( hFile );
        return(TRUE);
    }

    return(FALSE);

}

LPTSTR
DupString(
    IN LPCTSTR String
    )

/*++

Routine Description:

    Make a duplicate of a nul-terminated string.

Arguments:

    String - supplies pointer to nul-terminated string to copy.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    LPTSTR p;

    if(p = (LPTSTR)MALLOC((lstrlen(String)+1)*sizeof(TCHAR))) {
        lstrcpy(p,String);
    }

    return(p);
}

DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an entire file for read access. The file must
    not be 0-length or the routine fails.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.  This value is
        undefined if the file being opened is 0 length.

    BaseAddress - receives the address where the file is mapped.  This
        value is undefined if the file being opened is 0 length.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with UnmapFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else {
        //
        // Get the size of the file.
        //
        *FileSize = GetFileSize(*FileHandle,NULL);
        if(*FileSize == (DWORD)(-1)) {
            rc = GetLastError();
        } else {
            //
            // Create file mapping for the whole file.
            //
            *MappingHandle = CreateFileMapping(
                                *FileHandle,
                                NULL,
                                PAGE_READONLY,
                                0,
                                *FileSize,
                                NULL
                                );

            if(*MappingHandle) {

                //
                // Map the whole file.
                //
                *BaseAddress = MapViewOfFile(
                                    *MappingHandle,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    *FileSize
                                    );

                if(*BaseAddress) {
                    return(NO_ERROR);
                }

                rc = GetLastError();
                CloseHandle(*MappingHandle);
            } else {
                rc = GetLastError();
            }
        }

        CloseHandle(*FileHandle);
    }

    return(rc);
}



DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    )

/*++

Routine Description:

    Unmap and close a file.

Arguments:

    MappingHandle - supplies the win32 handle for the open file mapping
        object.

    BaseAddress - supplies the address where the file is mapped.

Return Value:

    NO_ERROR if the file was unmapped successfully.

    Win32 error code if the file was not successfully unmapped.

--*/

{
    DWORD rc;

    rc = UnmapViewOfFile(BaseAddress) ? NO_ERROR : GetLastError();

    if(!CloseHandle(MappingHandle)) {
        if(rc == NO_ERROR) {
            rc = GetLastError();
        }
    }

    return(rc);
}


LRESULT
CALLBACK
TextEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    //
    // For setsel messages, make start and end the same.
    //
    if ((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    return CallWindowProc( OldEditProc, hwnd, msg, wParam, lParam );
}


BOOL
SetTextInDialog(
    HWND hwnd,
    LPTSTR FileName
    )
{
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID BaseAddress;
    LPSTR Text;
    


    OldEditProc = (WNDPROC) GetWindowLongPtr( hwnd, GWLP_WNDPROC );
    SetWindowLongPtr( hwnd, GWLP_WNDPROC, (LONG_PTR)TextEditSubProc );

    if (MapFileForRead( FileName, &FileSize, &FileHandle, &MappingHandle, &BaseAddress )) {
        return FALSE;
    }


    Text = (LPSTR) MALLOC( FileSize + 16 );
    if( Text ) {
        CopyMemory( Text, BaseAddress, FileSize );
        Text[FileSize] = '\0';

    
        SendMessageA( hwnd, WM_SETTEXT, 0, (LPARAM)Text );
    
        FREE( Text );
    }

    UnmapFile( MappingHandle, BaseAddress );
    CloseHandle( FileHandle );

    return TRUE;
}

INT_PTR
CALLBACK
CompatibilityTextDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
   )
{
    switch(uMsg) {
        case WM_INITDIALOG:
            SetTextInDialog( GetDlgItem( hwndDlg, IDC_TEXT ), (LPTSTR) lParam );
            break;

        case WM_COMMAND:
            if (wParam == IDOK) {
                EndDialog( hwndDlg, IDOK );
            }
            break;

        case WM_CTLCOLOREDIT: 
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_BTNFACE));
            return (INT_PTR)GetSysColorBrush(COLOR_WINDOW);
            break;

    }

    return 0;
}

BOOL
LaunchIE4Instance(
    LPWSTR szResourceURL
    );

BOOL
LaunchIE3Instance(
    LPWSTR szResourceURL
    );

INT_PTR
CompatibilityDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
TCHAR           FullPath[MAX_PATH+8], *t;
LPWSTR          Url;
BOOL            UseText = FALSE;
BOOL            b = FALSE;
DWORD           i;
PRIPREP_COMPATIBILITY_DATA CompData;
DWORD           Index;
static int CurrentSelectionIndex=0;
static DWORD    Count = 0;
LV_ITEM         lvi = {0};
HWND            TmpHwnd;
static BOOL     WarningsPresent = FALSE;
static BOOL     ErrorsPresent = FALSE;
static BOOL     CheckUpgradeNoItems = TRUE;
DWORD           dw;

    switch(msg) {

        case WM_INITDIALOG:

            if (CompatibilityCount) {

                HWND hList =    GetDlgItem( hdlg, IDC_ROOT_LIST );
                PLIST_ENTRY     Next;
                HIMAGELIST      himl;
                HICON           hIcon;
                LV_COLUMN       lvc = {0};
                RECT            rc;

                GetClientRect( hList, &rc );
                lvc.mask = LVCF_WIDTH;
                lvc.cx = rc.right - rc.left - 16;
                ListView_InsertColumn( hList, 0, &lvc );

                Next = CompatibilityData.Flink;
                if (Next) {
                    himl = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                                             GetSystemMetrics(SM_CXSMICON),
                                             ILC_COLOR,
                                             2,
                                             0 );
                    ListView_SetImageList( hList, himl, LVSIL_SMALL );
                    hIcon = LoadIcon( NULL, IDI_HAND );
                    ImageList_AddIcon( himl, hIcon );
                    hIcon = LoadIcon( NULL, IDI_EXCLAMATION );
                    ImageList_AddIcon( himl, hIcon );

                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                    lvi.state     = 0;
                    lvi.stateMask = 0;
                    while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                        CompData = CONTAINING_RECORD( Next, RIPREP_COMPATIBILITY_DATA, ListEntry );

                        Next = CompData->ListEntry.Flink;

                        if (OsVersion.dwMajorVersion < 5) {
                            if ( CompData->Flags & COMPFLAG_ALLOWNT5COMPAT ) {
                                AnyNt5CompatDlls = TRUE;
                            } else {
                                goto NextIteration;
                            }
                        }

                        if (((CompData->Flags & COMPFLAG_HIDE) == 0) &&
                            ((CompData->Flags & COMPFLAG_CHANGESTATE) == 0)) {

                            //
                            // Add the icon.
                            //
                            if( himl ) {
                                if( CompData->Flags & COMPFLAG_STOPINSTALL ) {
                                    lvi.iImage = 0;
                                    ErrorsPresent = TRUE;
                                } else {
                                    lvi.iImage = 1;
                                    WarningsPresent = TRUE;
                                }
                            }

                            //
                            // And the text...
                            //
                            lvi.pszText   = (LPTSTR)CompData->Description;
                            lvi.lParam    = (LPARAM)CompData;
                            Index = ListView_InsertItem( hList, &lvi );

                            Count += 1;
                        }

NextIteration:
                    NOTHING;
                    }

                }

                // If we have an item then make it the default selection

                if( ErrorsPresent || WarningsPresent ){
                


                    SetFocus( hList );
                    ListView_SetItemState( hList,
                                           0, 
                                           LVIS_SELECTED | LVIS_FOCUSED, 
                                           LVIS_SELECTED | LVIS_FOCUSED);
                    CurrentSelectionIndex = 0;
    
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = 0;
                    lvi.iSubItem = 0;
                    ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                    CompData = (PRIPREP_COMPATIBILITY_DATA)lvi.lParam;
    
                    
                }
            }
            break;

        case WM_NOTIFY:

            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam; 
                LPNMHDR lpnmhdr = (LPNMHDR) lParam;

                switch (lpnmhdr->code) {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons( 
                                GetParent( hdlg ), 
                                PSWIZB_BACK | 
                                    (ErrorsPresent ? 0 : PSWIZB_NEXT) );
                    ClearMessageQueue( );

                    if (Count) {
                        //
                        // only need this page if there are incompatibities
                        //
                    
                         TCHAR Text[512];
                    
                        //
                        // Customize the look of the page, depending on
                        // what we have to display.  3 cases are possible:
                        // 1. Warnings only (services we'll stop).
                        // 2. Errors only (items that will prevent installation).
                        // 3. combination of 1. and 2.
                        //
                        if( (WarningsPresent == TRUE) && (ErrorsPresent == TRUE) ) {
                            dw = LoadString(g_hinstance,IDS_COMPAT_ERR_WRN,Text,ARRAYSIZE(Text));
                            Assert( dw );
                        } else if( WarningsPresent == TRUE ) {
                            dw = LoadString(g_hinstance,IDS_COMPAT_WRN,Text,ARRAYSIZE(Text));
                            Assert( dw );
                        } else if( ErrorsPresent == TRUE ) {
                            dw = LoadString(g_hinstance,IDS_COMPAT_ERR,Text,ARRAYSIZE(Text));
                            Assert( dw );
                        } else {
                            Assert(FALSE);
                        }
                        SetDlgItemText(hdlg,IDC_INTRO_TEXT,Text);
                    
                        return(TRUE);
                    
                    } else {
                        DebugMsg( "Skipping compatibility page, no incompatibilities...\n" );
                        SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );   // don't show
                    }

                    return(TRUE);
                    break;
                case PSN_QUERYCANCEL:
                    return VerifyCancel( hdlg );
                    break;
                
                }

                if( (pnmv->hdr.code == LVN_ITEMCHANGED) ) {

                    
                    Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                                  (int)-1,
                                                  (UINT) (LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED) );
                    
                    

                    if( (Index != LB_ERR) && (pnmv->iItem != CurrentSelectionIndex)) {
                        
                        // Always set the Details button
                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, TRUE );

                        InvalidateRect( GetParent(hdlg), NULL, FALSE );

                    }else if((Index != LB_ERR) && (pnmv->uNewState == (LVIS_SELECTED|LVIS_FOCUSED))){ 
                        
                        //Transition from nothing selected to previous selection
                    
                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, TRUE );
                        
                    }else if( Index == LB_ERR){
                        
                        // Disable the "Details" button as nothing is selected

                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, FALSE );

                    }
                }
            }
            break;
        case WM_COMMAND:

            if ((LOWORD(wParam) == IDC_DETAILS) && (HIWORD(wParam) == BN_CLICKED)) {
                TCHAR MessageText[300];
                TCHAR FormatText[300];

                Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                              (int)-1,
                                              (UINT) (LVNI_ALL | LVNI_SELECTED) );
                if (Index == LB_ERR) {
                    return FALSE;
                }

                //
                // Select the item, and get the compatibility data for the item
                //
                lvi.mask = LVIF_PARAM;
                lvi.iItem = Index;
                lvi.iSubItem = 0;
                ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                CompData = (PRIPREP_COMPATIBILITY_DATA)lvi.lParam;

                if (CompData->MsgResourceId) {
                    dw = LoadString(g_hinstance,CompData->MsgResourceId,MessageText,ARRAYSIZE(MessageText));
                    Assert( dw );
                } else {
                    LoadString(
                        g_hinstance,
                        ((CompData->Flags & COMPFLAG_STOPINSTALL) 
                         ? IDS_INCOMPAT_STOP_FORMAT
                         : IDS_INCOMPAT_WARN_FORMAT ),
                               FormatText,ARRAYSIZE(FormatText));
                    wsprintf(MessageText, FormatText, CompData->Description );                    

                }

                dw = LoadString(g_hinstance,IDS_INCOMPAT_MSG_TITLE,FormatText,ARRAYSIZE(FormatText));
                Assert( dw );

                MessageBox( 
                    hdlg,
                    MessageText,
                    FormatText,
                    ((CompData->Flags & COMPFLAG_STOPINSTALL) 
                     ? MB_OK | MB_ICONERROR
                     : MB_OK | MB_ICONWARNING ));
                
#if 0
                //
                // We check to see if the pointer as well as its contents are valid. If the contents are Null then we try
                // the txt file before we decide to not do anything.
                //

                if( (CompData->HtmlName) && *(CompData->HtmlName) ) {
                    lstrcpy( FullPath, TEXT("file://") );
                    _tfullpath( FullPath+7, CompData->HtmlName, MAX_PATH );
                    if( !FileExists( FullPath+7 ) ){
                        GetModuleFileName( NULL, (LPTSTR)(FullPath+7), MAX_PATH);

                        t = _tcsrchr( FullPath, TEXT('\\'));
                        t[1] = 0;
                        _tcscat( FullPath, CompData->HtmlName );

                    }

                    i = lstrlen( FullPath );
                    Url = (LPWSTR)SysAllocStringLen( NULL, i );

                    if( Url ) {
#ifdef UNICODE
                        wcscpy( Url, FullPath );
#else
                        MultiByteToWideChar( CP_ACP, 0, FullPath, -1, Url, i );
#endif
                    
                        if (!LaunchIE4Instance(Url)) {
                            if (!LaunchIE3Instance(Url)) {
                                UseText = TRUE;
                            }
                        }

                        SysFreeString( Url );
                    }
                } else {
                    UseText = TRUE;
                }


                if (UseText && (CompData->TextName) && *(CompData->TextName) ) {

                    _tfullpath( FullPath, CompData->TextName, MAX_PATH );
                    if( !FileExists( FullPath ) ){

                        GetModuleFileName( NULL, FullPath, MAX_PATH);

                        t = _tcsrchr( FullPath, TEXT('\\'));
                        t[1] = 0;
                        _tcscat( FullPath, CompData->TextName );
                    }

                    DialogBoxParam(
                        g_hinstance,
                        MAKEINTRESOURCE(IDD_COMPATIBILITY_TEXT),
                        NULL,
                        CompatibilityTextDlgProc,
                        (LPARAM)FullPath
                        );
                } else if( UseText ){


                        TCHAR Heading[512];

                        //
                        // When there is no txt name present, as last resort we put up this message
                        //
                        if(!LoadString(g_hinstance,AppTitleStringId,Heading,ARRAYSIZE(Heading))) {
                            Heading[0] = 0;
                        }


                        MessageBox( hdlg,
                                    TEXT( "No further details are available for this incompatibility. " ),
                                    Heading,
                                    MB_OK | MB_ICONWARNING );

                }
                SetFocus( GetDlgItem( hdlg, IDC_ROOT_LIST ) );
                ListView_SetItemState( GetDlgItem( hdlg, IDC_ROOT_LIST ),Index, LVIS_SELECTED, LVIS_SELECTED);


#endif
            }

            break;

        default:
            break;
    }

    return(b);
}

INT_PTR
StopServiceWrnDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TCHAR           FullPath[MAX_PATH+8], *t;
    LPWSTR          Url;
    BOOL            UseText = FALSE;
    BOOL            b = FALSE;
    DWORD           i;
    PRIPREP_COMPATIBILITY_DATA CompData;
    DWORD           Index;
    static int CurrentSelectionIndex=0;
    static DWORD    Count = 0;
    LV_ITEM         lvi = {0};
    HWND            TmpHwnd;
    static BOOL     TriedStoppingServices = FALSE;
    PLIST_ENTRY     Next;
    HIMAGELIST      himl;
    HICON           hIcon;
    LV_COLUMN       lvc = {0};
    RECT            rc;
    WCHAR       szText[ 80 ];
    HWND hList =    GetDlgItem( hdlg, IDC_ROOT_LIST );
    DWORD dw;

    switch(msg) {

        case WM_INITDIALOG:

            if (ServicesToStopCount) {

                //
                // add a column
                //
                lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvc.fmt     = LVCFMT_LEFT;
                lvc.pszText = szText;
                lvc.iSubItem = 0;
                lvc.cx       = 100;
                LoadString( 
                    g_hinstance, 
                    IDS_SERVICE_NAME_COLUMN, 
                    szText, 
                    sizeof(szText)/sizeof(WCHAR));
                
                i = ListView_InsertColumn( hList, 0, &lvc );
                Assert( i != -1 );

                //
                // add a 2nd column
                //
                GetClientRect( hList, &rc );
                lvc.iSubItem++;
                lvc.cx       = ( rc.right - rc.left ) - lvc.cx;
                dw = LoadString( 
                    g_hinstance, 
                    IDS_SERVICE_DESCRIPTION_COLUMN, 
                    szText, 
                    ARRAYSIZE(szText));
                Assert( dw );
                i = ListView_InsertColumn ( hList, lvc.iSubItem, &lvc );
                Assert( i != -1 );
                
            }
            break;

        case WM_NOTIFY:

            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam; 
                LPNMHDR lpnmhdr = (LPNMHDR) lParam;

                switch (lpnmhdr->code) {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons( 
                                GetParent( hdlg ), 
                                PSWIZB_BACK | PSWIZB_NEXT );
                    ClearMessageQueue( );


                    Next = CompatibilityData.Flink;
                    if (Next && (Count == 0)) {
                        himl = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                                                 GetSystemMetrics(SM_CXSMICON),
                                                 ILC_COLOR,
                                                 2,
                                                 0 );
                        ListView_SetImageList( hList, himl, LVSIL_SMALL );
                        hIcon = LoadIcon( NULL, IDI_HAND );
                        ImageList_AddIcon( himl, hIcon );
                        hIcon = LoadIcon( NULL, IDI_EXCLAMATION );
                        ImageList_AddIcon( himl, hIcon );
    
                        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                        lvi.state     = 0;
                        lvi.stateMask = 0;
                        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                            CompData = CONTAINING_RECORD( Next, RIPREP_COMPATIBILITY_DATA, ListEntry );
    
                            Next = CompData->ListEntry.Flink;
    
                            if (OsVersion.dwMajorVersion < 5) {
                                if ( CompData->Flags & COMPFLAG_ALLOWNT5COMPAT ) {
                                    AnyNt5CompatDlls = TRUE;
                                } else {
                                    goto NextIteration;
                                }
                            }
    
                            if (CompData->Flags & COMPFLAG_CHANGESTATE) {
    
                                //
                                // Add the icon.
                                //
                                if( himl ) {
                                    lvi.iImage = 0;                                
                                }
    
                                //
                                // And the text...
                                //
                                lvi.pszText   = (LPTSTR)CompData->ServiceName;
                                lvi.lParam    = (LPARAM)CompData;
                                Index = ListView_InsertItem( hList, &lvi );
    
                                //
                                // and the description
                                //
                                
                                ListView_SetItemText( 
                                                hList, 
                                                Index, 
                                                1, 
                                                (LPWSTR)CompData->Description );
    
                                Count += 1;
                            }
    
    NextIteration:
                        NOTHING;
                        }
    
                    }
    
                    // If we have an item then make it the default selection
    
                    if( Count && !TriedStoppingServices ){                
                        TCHAR Text[512];

                        SetFocus( hList );
                        ListView_SetItemState( hList,
                                               0, 
                                               LVIS_SELECTED | LVIS_FOCUSED, 
                                               LVIS_SELECTED | LVIS_FOCUSED);
                        CurrentSelectionIndex = 0;
        
                        lvi.mask = LVIF_PARAM;
                        lvi.iItem = 0;
                        lvi.iSubItem = 0;
                        ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                        
                        //
                        // only need this page if there are incompatibities
                        //
                    
                        
                    
                        dw = LoadString(g_hinstance,IDS_STOPSVC_WRN,Text,ARRAYSIZE(Text));
                        Assert( dw );
                        SetDlgItemText(hdlg,IDC_INTRO_TEXT,Text);


                    } else {
                        DebugMsg( "Skipping StopService page, no services to stop...\n" );
                        SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );   // don't show
                    }

                    return(TRUE);
                    break;
                case PSN_QUERYCANCEL:
                    return VerifyCancel( hdlg );
                    break;

                case PSN_WIZNEXT:

                    if (!TriedStoppingServices) {
                        TriedStoppingServices = TRUE;
                    }
                
                }
                
            }
            break;
        
        default:
            break;
    }

    return(b);
}

BOOL
MyStopService(
    IN LPCTSTR ServiceName
    )
{
    SC_HANDLE hSC;
    SC_HANDLE hService;
    SERVICE_STATUS ServiceStatus;
    BOOL Status = FALSE;
    
    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC != NULL) {
        hService = OpenService( hSC, ServiceName, SERVICE_STOP | SERVICE_QUERY_STATUS);

        if (hService != NULL) {
            if (QueryServiceStatus(
                            hService,
                            &ServiceStatus) &&
                ServiceStatus.dwCurrentState == SERVICE_STOPPED)  {
                Status = TRUE;
            } else {

                ULONG   StartTime = GetTickCount();
                
                while( ((GetTickCount() - StartTime) <= (30 * 1000)) &&         // Did we run over 30 seconds?
                       (!UserCancelled) ) {                                     // Did the user cancel via the UI?

                    if (ControlService( hService, 
                                        SERVICE_CONTROL_STOP,
                                        &ServiceStatus ) &&
                        (ServiceStatus.dwCurrentState == SERVICE_STOPPED)) {

                        Status = TRUE;
                        break;
                    }

                    if (QueryServiceStatus( hService,
                                            &ServiceStatus) &&
                        (ServiceStatus.dwCurrentState == SERVICE_STOPPED))  {

                        Status = TRUE;
                        break;
                    }

                    //
                    // Make sure we didn't wrap over 32-bits in our counter.
                    //
                    if( GetTickCount() < StartTime ) {

                        // he wrapped.  Reset StartTime.
                        StartTime = GetTickCount();
                    }


                    //
                    // It hasn't stopped yet.  Sleep and try again.
                    //
                    Sleep(1000);
                }
            }

            CloseServiceHandle( hService );
        }

        CloseServiceHandle( hSC );
    }

    return(Status);

}

DWORD
StopServiceThreadProc(
    LPVOID lParam 
    )
{
    PLIST_ENTRY     Next;
    BOOL RetVal = FALSE;
    PRIPREP_COMPATIBILITY_DATA CompData;
    DWORD StoppedServicesCount = 0;
    HWND hDlg = (HWND)lParam;
    CWaitCursor Cursor;
    
    EnterCriticalSection(&CompatibilityCS);
    Next = CompatibilityData.Flink;
    if (Next) {
    
        while (((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) && !UserCancelled) {
        
            CompData = CONTAINING_RECORD( Next, RIPREP_COMPATIBILITY_DATA, ListEntry );
    
            Next = CompData->ListEntry.Flink;
    
            if (CompData->Flags & COMPFLAG_CHANGESTATE) {
    
                DebugMsg( "Stopping %s...\n", CompData->ServiceName );
                SetDlgItemText( hDlg, IDC_STOP_SERVICE, CompData->Description );
                
                if (MyStopService(CompData->ServiceName)) {
                    StoppedServicesCount += 1;
                } else {
                    LogMsg( L"Failed to stop service: %s\r\n", CompData->ServiceName );
                }
            }
        }
        
    }

    LeaveCriticalSection(&CompatibilityCS);
    
    if (!RetVal) {
        PostMessage( 
            hDlg, 
            WM_STOPSVCCOMPLETE, 
            (StoppedServicesCount == ServicesToStopCount),
            0);
    }
    
    return(0);
    
}


INT_PTR
DoStopServiceDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static DWORD StoppedServicesCount = 0;
    static BOOL TriedStoppingServices = FALSE;
    static BOOL AlreadyPostedMessage = FALSE;
    BOOL b = FALSE;
    
    switch(msg) {    

        case WM_NOTIFY:

            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam; 
                LPNMHDR lpnmhdr = (LPNMHDR) lParam;

                switch (lpnmhdr->code) {
                    case PSN_SETACTIVE:
                        PropSheet_SetWizButtons( 
                                    GetParent( hdlg ), 0 );                                
                        
                        ClearMessageQueue( );
    
                        if (TriedStoppingServices || ServicesToStopCount == 0) {
                            DebugMsg( "Skipping DoStopService page, already tried to stop services...\n" );
                            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );   // don't show
                        }
    
                        if (!AlreadyPostedMessage && ServicesToStopCount) {
                            PostMessage( hdlg, WM_MYSTOPSVC, 0, 0 );
                            AlreadyPostedMessage = TRUE;
    
                        } 
    
                        return(TRUE);
                        break;

                    case PSN_QUERYCANCEL:
                        b = VerifyCancel( hdlg );
                        if (!b) {
                            UserCancelled = TRUE;
                        }
                        return(b);
                        break;

                }                            
            }
            break;
        case WM_MYSTOPSVC:
            {
                HANDLE hThread;
                DWORD dontcare;    
                
                DebugMsg( "received WM_MYSTOPSVC...\n" );
                hThread = CreateThread( NULL, 0, StopServiceThreadProc, hdlg, 0, &dontcare);
                if (hThread) {
                    CloseHandle(hThread);
                } else {
                    PostMessage( hdlg, WM_STOPSVCCOMPLETE, 0, 0);
                }
            }
            
            break;

        case WM_STOPSVCCOMPLETE:
            DebugMsg( "received WM_STOPSVCCOMPLETE...\n" );           
            TriedStoppingServices = TRUE;
            if (wParam == (WPARAM)FALSE) {
                MessageBoxFromStrings( hdlg, IDS_STOPSVC_FAIL_TITLE, IDS_STOPSVC_FAIL_TEXT, MB_OK );
            }
            PropSheet_SetWizButtons(
                        GetParent( hdlg ), PSWIZB_BACK | PSWIZB_NEXT );
            PropSheet_PressButton( GetParent( hdlg ), PSBTN_NEXT );        
            break;
                
        default:
            break;
    }

    return(b);
}



BOOLEAN
CheckForFileVersion(
    LPCTSTR FileName,
    LPCTSTR FileVer
    )
/*
    Arguments -
    
        FileName - Full path to the file to check
        Filever  - Version value to check against of the for x.x.x.x
        
    Function will check the actual file against the version specified. The depth of the check 
    is as deep as specified in "x.x.x.x" i..e if FileVer = 3.5.1 and actual version on the file
    is 3.5.1.4 we only compare upto 3.5.1.
    
    Return values - 
    
    TRUE - If the version of the file is <= FileVer which means that the file is an incompatible one
        
    else we return FALSE            
  
*/

{
    TCHAR Buffer[MAX_PATH];
    DWORD dwLength, dwTemp;
    TCHAR Datum[2];
    UINT DataLength;
    LPVOID lpData;
    VS_FIXEDFILEINFO *VsInfo;
    LPTSTR s,e;
    DWORD Vers[5],File_Vers[5];//MajVer, MinVer;
    int i=0, Depth=0;


    if (!ExpandEnvironmentStrings( FileName, Buffer, ARRAYSIZE(Buffer) )) {
        return FALSE;
    }


    if(!FileExists(Buffer))
        return FALSE;
    
    if( !FileVer || !(*FileVer) ){ // Since no version info is provided this boils down to a 
        return TRUE;               // presence check which was already done above
    }


    //
    // NT3.51 VerQueryValue writes into the buffer, can't use
    // a string constant.
    //
    lstrcpy( Datum, TEXT("\\") );

    if(dwLength = GetFileVersionInfoSize( Buffer, &dwTemp )) {
        if(lpData = LocalAlloc( LPTR, dwLength )) {
            if(GetFileVersionInfo( Buffer, 0, dwLength, lpData )) { 
                if (VerQueryValue( 
                            lpData, 
                            Datum, 
                            (LPVOID *)&VsInfo, 
                            &DataLength )) {

                    File_Vers[0] = (HIWORD(VsInfo->dwFileVersionMS));
                    File_Vers[1] = (LOWORD(VsInfo->dwFileVersionMS));
                    File_Vers[2] = (HIWORD(VsInfo->dwFileVersionLS));
                    File_Vers[3] = (LOWORD(VsInfo->dwFileVersionLS));


                    lstrcpy( Buffer, FileVer );

                    //Parse and get the depth of versioning we look for

                    s = e = Buffer;
                    while( e  ){

                        if ( ((*e < TEXT('0')) || (*e > TEXT('9'))) && ((*e != TEXT('.')) && (*e != TEXT('\0'))) )
                            return FALSE;


                        if(*e == TEXT('\0')){
                            *e = 0;
                            Vers[i] = (DWORD)_ttoi(s);
                            break;
                        }


                        if( *e == TEXT('.') ){
                            *e = 0;
                            Vers[i++] = (DWORD)_ttoi(s);
                            s = e+1;
                        }

                        e++;

                    }// while

                    Depth = i+1;
                    if (Depth > 4)
                        Depth = 4;


                    for( i=0; i < Depth; i++ ){

                        if( File_Vers[i] > Vers[i] ){
                            LocalFree( lpData );
                            return FALSE;
                        }
                        else if( File_Vers[i] ==  Vers[i] )
                            continue;
                        else
                            break;


                    }




                }
            }

            LocalFree( lpData );

        }
    }
    return TRUE;

}



DWORD
ProcessRegistryLine(
    PINFCONTEXT InfContext
    )
{
    LONG Error;
    HKEY hKey;
    DWORD Size, Reg_Type;
    LPBYTE Buffer;
    PRIPREP_COMPATIBILITY_DATA CompData;
    TCHAR RegKey[100];
    TCHAR RegValue[100];
    TCHAR RegValueExpect[100];
    TCHAR Path[MAX_PATH];
    TCHAR Value[20];
    INT Flags = 0;

    RegKey[0] = NULL;
    RegValue[0] = NULL;
    RegValueExpect[0] = NULL;

    SetupGetStringField( InfContext, 2, RegKey, ARRAYSIZE( RegKey ), NULL);
    SetupGetStringField( InfContext, 3, RegValue, ARRAYSIZE( RegValue ), NULL);
    SetupGetStringField( InfContext, 4, RegValueExpect, ARRAYSIZE( RegValueExpect ), NULL);

    //
    // open the reg key
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegKey,
        0,
        KEY_READ,
        &hKey
        );
    if( Error != ERROR_SUCCESS ) {
        //
        // bogus reg key
        //
        return 0;
    }


    if(  *RegValue ){


        //
        // find out how much data there is
        //

        Error = RegQueryValueEx(
            hKey,
            RegValue,
            NULL,
            &Reg_Type,
            NULL,
            &Size
            );
        if( Error != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return 0;
        }

        //
        // allocate the buffer
        //

        Buffer = (LPBYTE) MALLOC( Size );
        if (Buffer == NULL) {
            RegCloseKey( hKey );
            return 0;
        }

        //
        // read the data
        //

        Error = RegQueryValueEx(
            hKey,
            RegValue,
            NULL,
            NULL,
            Buffer,
            &Size
            );
        if( Error != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            FREE( Buffer );
            return 0;
        }

        RegCloseKey( hKey );


        if( Reg_Type == REG_DWORD ){
            _itot( (DWORD)*Buffer, Value, 10 );
            FREE( Buffer );
            Buffer = (LPBYTE) DupString(Value);
            if (!Buffer) {
                return(0);
            }
        }

        if ( *RegValueExpect && lstrcmp( RegValueExpect, (LPTSTR)Buffer ) != 0) {
            FREE( Buffer );
            return 0;
        }

        FREE( Buffer );

    }

    CompData = (PRIPREP_COMPATIBILITY_DATA) MALLOC( sizeof(RIPREP_COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        return 0;
    }

    ZeroMemory(CompData,sizeof(RIPREP_COMPATIBILITY_DATA));

    CompData->RegKey         = DupString(RegKey);
    CompData->RegValue       = DupString(RegValue);
    CompData->RegValueExpect = DupString(RegValueExpect);

    SetupGetStringField( InfContext, 5, Path, ARRAYSIZE( Path ), NULL);
    CompData->HtmlName       = DupString(Path);
    SetupGetStringField( InfContext, 6, Path, ARRAYSIZE( Path ), NULL);
    CompData->TextName       = DupString(Path);
    SetupGetStringField( InfContext, 7, Path, ARRAYSIZE( Path ), NULL);
    CompData->Description    = DupString(Path);   
    
    SetupGetIntField( InfContext,10,&Flags);
    CompData->Flags |= (GlobalCompFlags | Flags);


    EnterCriticalSection(&CompatibilityCS);
    InsertTailList( &CompatibilityData, &CompData->ListEntry );
    LeaveCriticalSection(&CompatibilityCS);

    return 1;
}



BOOL
MyGetServiceDescription(
    IN LPCTSTR ServiceName,
    IN OUT LPTSTR Buffer,
    IN DWORD BufferSizeInChars
    )
{
    SC_HANDLE hSC;
    SC_HANDLE hService;
    LPQUERY_SERVICE_CONFIG pServiceConfig;
    DWORD SizeNeeded;
    BOOL Status = FALSE;

    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC != NULL) {
        hService = OpenService( hSC, ServiceName, SERVICE_QUERY_CONFIG);

        if (hService != NULL) {
            if (!QueryServiceConfig(
                            hService, 
                            NULL, 
                            0, 
                            &SizeNeeded) &&
                GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                (pServiceConfig = (LPQUERY_SERVICE_CONFIG)MALLOC(SizeNeeded)) &&
                QueryServiceConfig(
                            hService,
                            pServiceConfig, 
                            SizeNeeded, 
                            &SizeNeeded) &&
                wcslen(pServiceConfig->lpDisplayName)+1 <= BufferSizeInChars) {
                wcscpy(Buffer,pServiceConfig->lpDisplayName);
                FREE(pServiceConfig);
                Status = TRUE;
            }

            CloseServiceHandle( hService );
        }

        CloseServiceHandle( hSC );
    }

    return(Status);

}

BOOL
IsServiceStopped(
    IN LPCTSTR ServiceName
    )
{
    SC_HANDLE hSC;
    SC_HANDLE hService;
    BOOL Status = FALSE;
    SERVICE_STATUS ServiceStatus;

    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC != NULL) {
        hService = OpenService( hSC, ServiceName, SERVICE_QUERY_STATUS);

        if (hService != NULL) {
            if (QueryServiceStatus( 
                            hService,
                            &ServiceStatus) &&
                ServiceStatus.dwCurrentState == SERVICE_STOPPED ) {

                Status = TRUE;

            }

            CloseServiceHandle( hService );
        } else if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {
            Status = TRUE;
        }

        CloseServiceHandle( hSC );
    }

    return(Status);

}




DWORD
ProcessServiceLine(
    PINFCONTEXT InfContext,
    BOOL SetCheckedFlag
    )
{
    TCHAR Buffer[100],Buffer2[64],Buffer3[MAX_PATH];
    LONG Error;
    HKEY hKey;
    INT Flags = 0;
    PRIPREP_COMPATIBILITY_DATA CompData;
    LPDWORD RegData;
    DWORD Value;
    DWORD ValueSize;
    TCHAR FileVersion[20];
    LPTSTR KeyName = Buffer2;
    LPTSTR FileName = Buffer3;
    DWORD dw;


    SetupGetStringField( InfContext, 2, Buffer, ARRAYSIZE( Buffer ), NULL);

    lstrcpy( KeyName, TEXT("SYSTEM\\CurrentControlSet\\Services\\") );
    lstrcat( KeyName, Buffer );
    //
    // get an open key to the services database
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        KeyName,
        0,
        KEY_READ | KEY_WRITE,
        &hKey
        );
    if( Error != ERROR_SUCCESS ) {
        return 0;
    }

    //
    // We'll ceate a key here so that others will know that we've
    // already checked this service.  We'll remove it later.  We
    // don't care about error codes here because this is only used
    // as a safety net for checks that may come after us.
    //
    if( SetCheckedFlag ) {
        Value = 1;
        RegSetValueEx( hKey,
                       TEXT("SetupChecked"),
                       0,
                       REG_DWORD,
                       (CONST BYTE *)&Value,
                       sizeof(DWORD) );
    } else {
        //
        // The user has asked us to simply remove these 'checked' flags
        // from the services that we've examined.
        //
        RegDeleteValue( hKey,
                        TEXT("SetupChecked") );
        RegCloseKey( hKey );
        return 0;
    }

    //
    // Check the start value of our target service.  If it's disabled,
    // then we don't have an incompatibility.
    //
    ValueSize = sizeof(Value);

    Error = RegQueryValueEx(
        hKey,
        TEXT("Start"),
        NULL,
        NULL,
        (LPBYTE)&Value,
        &ValueSize
        );

    if( (Error == ERROR_SUCCESS) && (Value == SERVICE_DISABLED) ){
        RegCloseKey( hKey );
        return 0;
    }

    RegCloseKey( hKey );

    //
    // Check the version of a file for the service.  If only some
    // versions are bad, then we may or may not have an incompatibility.
    //
    FileName[0] = NULL;
    FileVersion[0] = NULL;
    SetupGetStringField( InfContext, 6, FileName, ARRAYSIZE( Buffer3 ), NULL);
    SetupGetStringField( InfContext, 7, FileVersion, ARRAYSIZE( FileVersion ), NULL);
    SetupGetIntField( InfContext, 8 , &Flags);

    Flags |= GlobalCompFlags;

    if( *FileName && *FileVersion ){

        if( !CheckForFileVersion( FileName, FileVersion ) )
            return 0;

    }

    //
    // if we're only incompatible if the service is actually running at the
    // moment, then check that.  Note that we check for the service being 
    // stopped instead of running, as we don't want to the service to be in
    // some pending state when we continue on.
    //
    if (Flags & COMPFLAG_SERVICERUNNING) {
        if (IsServiceStopped(Buffer)) {
            return 0;
        }
    }


    RegData = (LPDWORD)MALLOC( sizeof(DWORD) );
    if (RegData == NULL) {
        return 0;
    }

    CompData = (PRIPREP_COMPATIBILITY_DATA) MALLOC( sizeof(RIPREP_COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        FREE(RegData);
        return 0;
    }

    ZeroMemory(CompData,sizeof(RIPREP_COMPATIBILITY_DATA));

    CompData->ServiceName           = DupString(Buffer);
    SetupGetStringField( InfContext, 3, Buffer, ARRAYSIZE( Buffer ), NULL);
    CompData->HtmlName              = DupString(Buffer);
    SetupGetStringField( InfContext, 4, Buffer, ARRAYSIZE( Buffer ), NULL);
    CompData->TextName              = DupString(Buffer);
    Buffer[0] = UNICODE_NULL;
    SetupGetStringField( InfContext, 5, Buffer, ARRAYSIZE( Buffer ), NULL);
    if (Buffer[0] == UNICODE_NULL) {
        if (!MyGetServiceDescription(CompData->ServiceName,Buffer,ARRAYSIZE(Buffer))) {
            LPVOID Args[2];
            dw = LoadString(g_hinstance,IDS_SERVICE_DESC_UNKNOWN,Buffer2,ARRAYSIZE(Buffer2));
            Assert( dw );
            dw = LoadString(g_hinstance,IDS_SERVICE_DESC_FORMAT,Buffer3,ARRAYSIZE(Buffer3));
            Assert( dw );
            Args[0] = (LPVOID)CompData->ServiceName;
            Args[1] = (LPVOID)Buffer2;
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                Buffer3,
                0,
                0,
                Buffer,
                ARRAYSIZE(Buffer),   // size of buffer
                (va_list*) &Args );           // arguments

        }
    }
    CompData->Description           = DupString(Buffer);
    CompData->RegKeyName            = DupString( KeyName );
    CompData->RegValName            = DupString( TEXT("Start") );
    RegData[0]                      = 4;
    CompData->RegValData            = RegData;
    CompData->RegValDataSize        = sizeof(DWORD);
    CompData->Flags                |= Flags ;
    
    EnterCriticalSection(&CompatibilityCS);
    InsertTailList( &CompatibilityData, &CompData->ListEntry );
    LeaveCriticalSection(&CompatibilityCS);

    return 1;
}


DWORD
ProcessFileLine(
    PINFCONTEXT InfContext
    )
{

    PRIPREP_COMPATIBILITY_DATA CompData;
    TCHAR FileName[MAX_PATH];
    TCHAR FileVer[100];
    INT Flags;


    FileVer[0] = NULL;
    FileName[0] = NULL;

    SetupGetStringField( InfContext, 2, FileName, ARRAYSIZE( FileName ), NULL);
    SetupGetStringField( InfContext, 3, FileVer, ARRAYSIZE( FileVer ), NULL);
    
    if( *FileName ){

        if( !CheckForFileVersion( FileName, FileVer ) )
            return 0;
    } else{
        return 0;
    }


    CompData = (PRIPREP_COMPATIBILITY_DATA) MALLOC( sizeof(RIPREP_COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        return 0;
    }

    ZeroMemory(CompData,sizeof(RIPREP_COMPATIBILITY_DATA));

    CompData->FileName       = DupString( FileName );
    CompData->FileVer        = DupString( FileVer );

    SetupGetStringField( InfContext, 4, FileName, ARRAYSIZE( FileName ), NULL);
    CompData->HtmlName       = DupString( FileName );
    SetupGetStringField( InfContext, 5, FileName, ARRAYSIZE( FileName ), NULL);
    CompData->TextName       = DupString( FileName );
    SetupGetStringField( InfContext, 6, FileName, ARRAYSIZE( FileName ), NULL);
    CompData->Description       = DupString( FileName );
    Flags = 0;
    SetupGetIntField( InfContext, 7 , &Flags);

    CompData->Flags |= (GlobalCompFlags | Flags);

    EnterCriticalSection(&CompatibilityCS);
    InsertTailList( &CompatibilityData, &CompData->ListEntry );
    LeaveCriticalSection(&CompatibilityCS);

    return 1;
}

BOOL
CompatibilityCallback(
    PRIPREP_COMPATIBILITY_ENTRY CompEntry,
    PRIPREP_COMPATIBILITY_CONTEXT CompContext
    )
{
    PRIPREP_COMPATIBILITY_DATA CompData;

    //
    // parameter validation
    //

    if (CompEntry->Description == NULL || CompEntry->Description[0] == 0) {
        SetLastError( COMP_ERR_DESC_MISSING );
        return FALSE;
    }

    if (CompEntry->TextName == NULL || CompEntry->TextName[0] ==0) {
        SetLastError( COMP_ERR_TEXTNAME_MISSING );
        return FALSE;
    }

    if (CompEntry->RegKeyName) {
        if (CompEntry->RegValName == NULL) {
            SetLastError( COMP_ERR_REGVALNAME_MISSING );
            return FALSE;
        }
        if (CompEntry->RegValData == NULL) {
            SetLastError( COMP_ERR_REGVALDATA_MISSING );
            return FALSE;
        }
    }


#ifdef UNICODE
    if (IsTextUnicode( CompEntry->Description, wcslen(CompEntry->Description)*sizeof(WCHAR), NULL ) == 0) {
        SetLastError( COMP_ERR_DESC_NOT_UNICODE );
        return FALSE;
    }
    if (IsTextUnicode( CompEntry->TextName, wcslen(CompEntry->TextName)*sizeof(WCHAR), NULL ) == 0) {
        SetLastError( COMP_ERR_TEXTNAME_NOT_UNICODE );
        return FALSE;
    }
    if (CompEntry->HtmlName) {
        if (IsTextUnicode( CompEntry->HtmlName, wcslen(CompEntry->HtmlName)*sizeof(WCHAR), NULL ) == 0) {
            SetLastError( COMP_ERR_HTMLNAME_NOT_UNICODE );
            return FALSE;
        }
    }
    if (CompEntry->RegKeyName) {
        if (IsTextUnicode( CompEntry->RegKeyName, wcslen(CompEntry->RegKeyName)*sizeof(WCHAR), NULL ) == 0) {
            SetLastError( COMP_ERR_REGKEYNAME_NOT_UNICODE );
            return FALSE;
        }
        if (IsTextUnicode( CompEntry->RegValName, wcslen(CompEntry->RegValName)*sizeof(WCHAR), NULL ) == 0) {
            SetLastError( COMP_ERR_REGVALNAME_NOT_UNICODE );
            return FALSE;
        }
    }


#endif

    //
    // allocate the compatibility structure
    //

    CompData = (PRIPREP_COMPATIBILITY_DATA) MALLOC( sizeof(RIPREP_COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    ZeroMemory(CompData, sizeof(RIPREP_COMPATIBILITY_DATA));

    //
    // save the sata
    //

    CompData->Description     = DupString( CompEntry->Description );
    CompData->HtmlName        = CompEntry->HtmlName ? DupString( CompEntry->HtmlName ) : NULL;
    CompData->TextName        = DupString( CompEntry->TextName );    
    CompData->Flags           = CompEntry->Flags;
    CompData->Flags          |= CompContext->Flags;
    CompData->Flags          |= GlobalCompFlags;
    CompData->hModDll         = CompContext->hModDll;
    CompData->MsgResourceId   = CompEntry->MsgResourceId;
    if (CompEntry->RegKeyName) {
        CompData->RegKeyName      = DupString( CompEntry->RegKeyName );
        CompData->RegValName      = DupString( CompEntry->RegValName );
        CompData->RegValDataSize  = CompEntry->RegValDataSize;
        CompData->RegValData      = MALLOC(CompEntry->RegValDataSize);
        if (CompData->RegValData) {
            CopyMemory( CompData->RegValData, CompEntry->RegValData, CompEntry->RegValDataSize );
        }
    }

    EnterCriticalSection(&CompatibilityCS);
    InsertTailList( &CompatibilityData, &CompData->ListEntry );
    LeaveCriticalSection(&CompatibilityCS);

    CompContext->Count += 1;

    return TRUE;

}


DWORD
ProcessDLLLine(
    PINFCONTEXT InfContext
    )
{
    TCHAR Buffer[MAX_PATH];
    HMODULE hMod;
    CHAR CompCheckEntryPoint[MAX_PATH];
    PCOMPATIBILITYCHECK CompCheck;
    TCHAR DllName[100];
    TCHAR CompCheckEntryPointW[100];
    LPTSTR ProcessOnCleanInstall;
    INT AllowCompatibilityErrorOnNT5;
    RIPREP_COMPATIBILITY_CONTEXT CompContext;
    BOOL Rslt;
    DWORD Status;


    SetupGetStringField( InfContext, 2, DllName, ARRAYSIZE( DllName ), NULL);
    SetupGetStringField( InfContext, 3, CompCheckEntryPointW, ARRAYSIZE( CompCheckEntryPointW ), NULL);
    
    SetupGetIntField( InfContext, 6, &AllowCompatibilityErrorOnNT5);
    
    if (!ExpandEnvironmentStrings( DllName, Buffer, ARRAYSIZE(Buffer) )) {
        return 0;
    }

    hMod = LoadLibrary( Buffer );
    if (hMod == NULL) {
        return 0;
    }

#ifdef UNICODE
    WideCharToMultiByte(
        CP_ACP,
        0,
        CompCheckEntryPointW,
        -1,
        CompCheckEntryPoint,
        sizeof(CompCheckEntryPoint),
        NULL,
        NULL
        );
#else
    lstrcpy( CompCheckEntryPoint, CompCheckEntryPointW );
#endif

    CompCheck = (PCOMPATIBILITYCHECK) GetProcAddress( hMod, CompCheckEntryPoint );
    if (CompCheck == NULL) {
        FreeLibrary( hMod );
        return 0;
    }

    CompContext.SizeOfStruct = sizeof(CompContext);
    CompContext.Count = 0;
    CompContext.hModDll = hMod;
    CompContext.Flags = (AllowCompatibilityErrorOnNT5) ? COMPFLAG_ALLOWNT5COMPAT : 0;

    if ((OsVersion.dwMajorVersion < 5 )
        && ((CompContext.Flags & COMPFLAG_ALLOWNT5COMPAT)==0)) {
        Rslt = FALSE;
    } else {
        __try {
            Rslt = CompCheck( (PCOMPATIBILITYCALLBACK)CompatibilityCallback, (LPVOID)&CompContext );
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            Rslt = FALSE;
        }
    }

    if (!Rslt) {
        FreeLibrary( hMod );
        return 0;
    }

    if (CompContext.Count == 0) {
        FreeLibrary( hMod );
    }

    return CompContext.Count;
}


DWORD
ProcessCompatibilitySection(
    HINF hInf,
    LPTSTR SectionName
    )
{
    DWORD LineCount;
    DWORD Count;
    DWORD i;
    TCHAR Type[20];
    DWORD Good;
    INFCONTEXT InfContext;


    //
    // get the section count, zero means bail out
    //

    LineCount = SetupGetLineCount( hInf, SectionName );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return 0;
    }

    for (i=0,Count=0; i<LineCount; i++) {

        if (SetupGetLineByIndex( hInf , SectionName, i, &InfContext ) && 
            SetupGetStringField( &InfContext, 1, Type, ARRAYSIZE( Type ), NULL)) {

            switch (_totlower(Type[0])) {
                case TEXT('r'):
                    //
                    // registry value
                    //
                    Count += ProcessRegistryLine( &InfContext );
                    break;
    
                case TEXT('s'):
                    //
                    // service or driver
                    //
                    Count += ProcessServiceLine( &InfContext, TRUE );
                    break;
    
                case TEXT('f'):
                    //
                    // presence of a file
                    //
                    Count += ProcessFileLine( &InfContext );
                    break;
    
                case TEXT('d'):
                    //
                    // run an external dll
                    //
                    Count += ProcessDLLLine( &InfContext );
                    break;
    
                default:
                    break;
            }
        }
    }

    return Count;
}


VOID
RemoveCompatibilityServiceEntries(
    HINF   hInf,
    LPTSTR SectionName
    )
{
    DWORD LineCount;
    DWORD Count;
    DWORD i;
    TCHAR Type[20];
    DWORD Good;
    INFCONTEXT InfContext;

    //
    // get the section count, zero means bail out
    //

    LineCount = SetupGetLineCount( hInf , SectionName );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return;
    }

    for (i=0,Count=0; i<LineCount; i++) {

        if (SetupGetLineByIndex( hInf , SectionName, i, &InfContext ) && 
            SetupGetStringField( &InfContext, 1, Type, ARRAYSIZE( Type ), NULL)) {
                
                switch (_totlower(Type[0])) {
                    case TEXT('s'):
                        //
                        // service or driver
                        //
                        Count += ProcessServiceLine( &InfContext, FALSE );
                        break;
        
                    default:
                        break;
                }
        }
    }
}


BOOL
ProcessCompatibilityData(
    VOID
    )
{
    HINF hInf;
    TCHAR Path[MAX_PATH], *p;

    if( !CompatibilityData.Flink ) {
        InitializeListHead( &CompatibilityData );
        InitializeCriticalSection( &CompatibilityCS );
    } else {
        Assert(FALSE);
        return (CompatibilityCount != 0);
    }

    GetModuleFileName( NULL, Path, ARRAYSIZE( Path ));
    if (p = _tcsrchr(Path, TEXT('\\'))) {
        *p = NULL;
        lstrcat(Path, TEXT("\\riprep.inf"));

        hInf = SetupOpenInfFile( 
                               Path, 
                               NULL, 
                               INF_STYLE_WIN4,
                               NULL );
        if (hInf == INVALID_HANDLE_VALUE) {
            return(TRUE);
        }
    }

    g_hCompatibilityInf = hInf;

    GlobalCompFlags = COMPFLAG_STOPINSTALL;
    CompatibilityCount = 0;
    
    CompatibilityCount += ProcessCompatibilitySection(hInf, TEXT("ServicesToStopInstallation") );
    if (CompatibilityCount) {
        IncompatibilityStopsInstallation = TRUE;
    }

    GlobalCompFlags = 0;
    CompatibilityCount += ProcessCompatibilitySection(hInf, TEXT("ServicesToWarn") );

    GlobalCompFlags = COMPFLAG_SERVICERUNNING | COMPFLAG_CHANGESTATE;
    ServicesToStopCount = ProcessCompatibilitySection(hInf, TEXT("ServicesToStop") );

    //
    // Now cleanup any turds we left in the registry on the services we checked.
    //
    RemoveCompatibilityServiceEntries(hInf, TEXT("ServicesToStopInstallation") );
    RemoveCompatibilityServiceEntries(hInf, TEXT("ServicesToWarn") );
    RemoveCompatibilityServiceEntries(hInf, TEXT("ServicesToStop") );

    if( CompatibilityCount ) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL CleanupCompatibilityData(
    VOID
    )
{
    PLIST_ENTRY Next = CompatibilityData.Flink;
    PRIPREP_COMPATIBILITY_DATA CompData;
    
    if (CompatibilityData.Flink) {
        EnterCriticalSection(&CompatibilityCS);

        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
            CompData = CONTAINING_RECORD( Next, RIPREP_COMPATIBILITY_DATA, ListEntry );
            
            RemoveEntryList( &CompData->ListEntry );
            
            Next = CompData->ListEntry.Flink;
    
            if (CompData->ServiceName) {
                FREE(CompData->ServiceName);
            }
            
            if (CompData->RegKey) {
                FREE(CompData->RegKey);
            }
    
            if (CompData->RegValue) {
                FREE(CompData->RegValue);
            }
    
            if (CompData->RegValueExpect) {
                FREE(CompData->RegValueExpect);
            }
    
            if (CompData->FileName) {
                FREE(CompData->FileName);
            }
            
            if (CompData->FileVer) {
                FREE(CompData->FileVer);
            }
    
            if (CompData->Description) {
                FREE(CompData->Description);
            }
            
            if (CompData->HtmlName) {
                FREE(CompData->HtmlName);
            }
            
            if (CompData->TextName) {
                FREE(CompData->TextName);
            }
            
            if (CompData->RegKeyName) {
                FREE(CompData->RegKeyName);
            }
            
            if (CompData->RegValName) {
                FREE(CompData->RegValName);
            }
            
            if (CompData->RegValData) {
                FREE(CompData->RegValData);
            }
            
            FREE(CompData);
        }
    
        LeaveCriticalSection(&CompatibilityCS);

    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\complete.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"

//
// CompleteDlgProc()
//
INT_PTR CALLBACK
CompleteDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetDialogFont( hDlg, IDC_TITLE, DlgFontTitle );
        break;

    default:
        return FALSE;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            PropSheet_PressButton( GetParent( hDlg ), PSBTN_FINISH );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\compat.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 2000
   All rights reserved

  File: COMPAT.H


 ***************************************************************************/

#ifndef _COMPAT_H_
#define _COMPAT_H_

INT_PTR CALLBACK
CompatibilityDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
StopServiceWrnDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
DoStopServiceDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


BOOL
ProcessCompatibilityData(
    VOID
    );

BOOL
CleanupCompatibilityData(
    VOID
    );


#define COMPFLAG_HIDE           0x00000001
#define COMPFLAG_STOPINSTALL    0x00000002
#define COMPFLAG_ALLOWNT5COMPAT 0x00000004
#define COMPFLAG_SERVICERUNNING 0x00000008
#define COMPFLAG_CHANGESTATE    0x00000010
#define COMPFLAG_ALREADYSTOPPED 0x10000000

#define COMP_ERR_DESC_NOT_UNICODE           (ULONG)0xc00000001
#define COMP_ERR_TEXTNAME_NOT_UNICODE       (ULONG)0xc00000002
#define COMP_ERR_HTMLNAME_NOT_UNICODE       (ULONG)0xc00000003
#define COMP_ERR_REGKEYNAME_NOT_UNICODE     (ULONG)0xc00000004
#define COMP_ERR_REGVALNAME_NOT_UNICODE     (ULONG)0xc00000005
#define COMP_ERR_REGVALNAME_MISSING         (ULONG)0xc00000006
#define COMP_ERR_REGVALDATA_MISSING         (ULONG)0xc00000007
#define COMP_ERR_TEXTNAME_MISSING           (ULONG)0xc00000008
#define COMP_ERR_DESC_MISSING               (ULONG)0xc00000009
#define COMP_ERR_INFNAME_NOT_UNICODE        (ULONG)0xc0000000A
#define COMP_ERR_INFSECTION_NOT_UNICODE     (ULONG)0xc0000000B
#define COMP_ERR_INFSECTION_MISSING         (ULONG)0xc0000000C


typedef struct _RIPREP_COMPATIBILITY_ENTRY {
    DWORD   SizeOfStruct;
    LPTSTR  Description;
    LPTSTR  HtmlName;
    LPTSTR  TextName;
    LPTSTR  RegKeyName;
    LPTSTR  RegValName;
    DWORD   RegValDataSize;
    LPVOID  RegValData;    
    DWORD   Flags;
    DWORD   MsgResourceId;
} RIPREP_COMPATIBILITY_ENTRY, *PRIPREP_COMPATIBILITY_ENTRY;

typedef struct _RIPREP_COMPATIBILITY_DATA {
    //
    // general
    //
    LIST_ENTRY ListEntry;
    //
    // what type of entry
    //
    TCHAR    Type;
    //
    // service-driver data
    //
    LPCTSTR  ServiceName;
    //
    // registry data
    //
    LPCTSTR  RegKey;
    LPCTSTR  RegValue;
    LPCTSTR  RegValueExpect;
    //
    // file data
    //
    LPCTSTR  FileName;
    LPCTSTR  FileVer;
    //
    // common
    //
    LPCTSTR  Description;
    LPCTSTR  HtmlName;
    LPCTSTR  TextName;
    LPTSTR   RegKeyName;
    LPTSTR   RegValName;
    LPVOID   RegValData;
    DWORD    RegValDataSize;
    DWORD    Flags;
    LPCTSTR  InfName;
    LPCTSTR  InfSection;

    DWORD MsgResourceId;

    HMODULE                 hModDll;
    
} RIPREP_COMPATIBILITY_DATA, *PRIPREP_COMPATIBILITY_DATA;

typedef struct _RIPREP_COMPATIBILITY_CONTEXT {
    DWORD                   SizeOfStruct;
    DWORD                   Count;
    HMODULE                 hModDll;
    DWORD                   Flags;
} RIPREP_COMPATIBILITY_CONTEXT, *PRIPREP_COMPATIBILITY_CONTEXT;

typedef BOOL
(CALLBACK *PCOMPATIBILITYCALLBACK)(
    PRIPREP_COMPATIBILITY_ENTRY CompEntry,
    LPVOID Context
    );

typedef BOOL
(WINAPI *PCOMPATIBILITYCHECK)(
    PCOMPATIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    );



#endif // _COMPAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\complete.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: COMPLETE.H


 ***************************************************************************/

#ifndef _COMPLETE_H_
#define _COMPLETE_H_

INT_PTR CALLBACK
CompleteDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _COMPLETE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\debug.cpp ===
/****************************************************************************

  Copyright (c) Microsoft Corporation 1997
  All rights reserved

  File: DEBUG.CPP

  Debugging utilities

 ***************************************************************************/

#include "pch.h"
#include <shlwapi.h>

DEFINE_MODULE("RIPREP")

#ifdef DEBUG

// Constants
#define DEBUG_OUTPUT_BUFFER_SIZE  512

// Globals
DWORD g_TraceMemoryIndex = 0;
DWORD g_dwCounter        = 0;
DWORD g_dwTraceFlags     = 0;
CRITICAL_SECTION g_DebugCS;
BOOL  g_fDebugInitialized = FALSE;

// Statics
static const TCHAR g_szNULL[]    = TEXT("");
static const TCHAR g_szTrue[]    = TEXT("True");
static const TCHAR g_szFalse[]   = TEXT("False");
static const TCHAR g_szFormat[]  = TEXT("%-50s  %-10.10s ");
static const TCHAR g_szUnknown[] = TEXT("<unknown>");

//
// Debugging strrchr( )
//
LPCTSTR
dbgstrrchr( LPCTSTR lpsz, char ch )
{
    LPCTSTR psz = lpsz;

    while ( *psz )
        ++psz;

    while ( psz >= lpsz && *psz != ch )
        --psz;

    return psz;

}

//
// Adds 'g_dwCounter' spaces to debug spew
//
void
dbgspace( void )
{
    for( DWORD dw = 1; dw < g_dwCounter; dw++ )
        OutputDebugStringA( "| " );
}

//
// Makes sure multiple threads don't trample debugging output.
//
void
dbgEnterCS( void )
{
    if ( !g_fDebugInitialized )
    {
        //
        // There is NO matching DeleteCriticalSection( ) since
        // this is only used for debugging purposes.
        //
        InitializeCriticalSection( &g_DebugCS );
        g_fDebugInitialized = TRUE;
    }

    EnterCriticalSection( &g_DebugCS );
}

void
dbgExitCS( void )
{
    LeaveCriticalSection( &g_DebugCS );
}

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPTSTR
dbgmakefilelinestring(
    LPTSTR  pszBuf,
    LPCTSTR pszFile,
    const int uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = IntToPtr(uLine);

    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        TEXT("%1(%2!u!):"),
        0,                          // error code
        0,                          // default language
        (LPTSTR) pszBuf,            // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (va_list*) &args );           // arguments

    return pszBuf;
}



//
// TraceMsg() - ascii
//
void
TraceMsg(
    DWORD dwCheckFlags,
    LPCSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifdef UNICODE
        TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
        mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, szFormat, valist );
        va_end( valist );
#else
        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );
#endif // UNICODE

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );
    }
}

//
// TraceMsg() - unicode
//
void
TraceMsg(
    DWORD dwCheckFlags,
    LPCWSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifndef UNICODE
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormat, lstrlenW( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

        dbgEnterCS( );

        OutputDebugStringW( szBuf );

        dbgExitCS( );
    }
}

//
// TraceMessage()
//
void
TraceMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgspace( );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );

        dbgExitCS( );
    }

}

//
// TraceMessageDo()
//
void
TraceMessageDo(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR   szVar[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPCTSTR psz = pszFunc;

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgspace( );

        while ( *psz && *psz != TEXT('='))
            psz++;

        lstrcpyn( szVar, pszFunc, (size_t)(1 + psz - pszFunc) );

        wsprintf( szBuf, TEXT("V %s= "), szVar );
        OutputDebugString( szBuf );

        va_start( valist, pszFunc );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );
        OutputDebugString( TEXT("\n") );

        dbgExitCS( );
    }

}

//
// DebugMessage()
//
void
DebugMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

    if ( !pszModule )
    {
        pszModule = g_szUnknown;
    }

    if ( !pszFile )
    {
        wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
    }
    else
    {
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgmakefilelinestring( szFileLine, pszFile, uLine );
        wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
    }

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgspace( );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );

    OutputDebugString( szBuf );

    dbgExitCS( );
}

//
// DebugMessageDo()
//
void
DebugMessageDo(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
    TCHAR   szVar[ DEBUG_OUTPUT_BUFFER_SIZE ];
    LPCTSTR psz = pszFunc;

    if ( !pszModule )
    {
        pszModule = g_szUnknown;
    }

    if ( !pszFile )
    {
        wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
    }
    else
    {
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgmakefilelinestring( szFileLine, pszFile, uLine );
        wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
    }

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgspace( );

    while ( *psz && *psz != TEXT('='))
        psz++;

    lstrcpyn( szVar, pszFunc, (size_t)(1 + psz - pszFunc) );

    wsprintf( szBuf, TEXT("V %s= "), szVar );
    OutputDebugString( szBuf );

    va_start( valist, pszFunc );
    wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );

    OutputDebugString( szBuf );
    OutputDebugString( TEXT("\n") );

    dbgExitCS( );
}

//
// DebugMsg()
//
void
DebugMsg(
    LPCSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifdef UNICODE
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgExitCS( );
}

//
// DebugMsg()
//
void
DebugMsg(
    LPCWSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifndef UNICODE
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormat, lstrlenW( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE


    dbgEnterCS( );

    OutputDebugStringW( szBuf );

    dbgExitCS( );
}


//
// Displays a dialog box with the failed assertion. User has the option of
// breaking.
//
BOOL
AssertMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    BOOL    fTrue )
{
    if ( !fTrue )
    {
        TCHAR szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszFile == NULL )
        {
            pszFile = g_szNULL;
        }

        if ( pszModule == NULL )
        {
            pszModule = g_szNULL;
        }

        if ( pszfn == NULL )
        {
            pszfn = g_szNULL;
        }

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s ASSERT: %s\n"),
            szFileLine, pszModule, pszfn );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn );

        if ( IDNO == MessageBox( NULL, szBuf, TEXT("Assertion Failed!"),
                MB_YESNO|MB_ICONWARNING ) )
            fTrue = !FALSE;   // don't break

    }

    return !fTrue;

}

//
// Traces HRESULT errors. A dialog will appear is there is an error
// in the hr.
//
HRESULT
TraceHR(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    HRESULT hr )
{
    if ( hr )
    {
        TCHAR  szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR pszMsgBuf;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = TEXT("S_FALSE\n");
            break;

        default:
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR)&pszMsgBuf,
                0,
                NULL
            );
        }

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszMsgBuf == NULL )
        {
            pszMsgBuf = TEXT("<unknown error code returned>\n");
        }
        Assert( pszFile != NULL );
        Assert( pszModule != NULL );
        Assert( pszfn != NULL );

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s HRESULT: hr = 0x%08x - %s"),
            szFileLine, pszModule, hr, pszMsgBuf );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x - %s\t\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn, hr, pszMsgBuf );

        if ( IDYES == MessageBox( NULL, szBuf, TEXT("Trace HRESULT"),
                MB_YESNO|MB_ICONWARNING ) )
            DEBUG_BREAK;

        if ( hr != S_OK && hr != S_FALSE )
        {
            LocalFree( pszMsgBuf );
        }
    }

    return hr;

}


//
// Memory allocation and tracking
//

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCTSTR pszFile;
    int     uLine;
    LPCTSTR pszModule;
    LPCTSTR pszComment;
    _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                    GMEM_FIXED,
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );
        TraceMessage( pmb->pszFile,
                      pmb->uLine,
                      pmb->pszModule,
                      TF_MEMORYALLOCS,
                      L"Alloced %s - %u bytes at 0x%08x (pmb=0x%08x)\n",
                      pszComment,
                      dwBytes,
                      pmb->hglobal,
                      pmb );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmbLast = NULL;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );
            }

            TraceMessage( pmbHead->pszFile,
                          pmbHead->uLine,
                          pmbHead->pszModule,
                          TF_MEMORYALLOCS,
                          L"Freeing %s - %u bytes from 0x%08x (pmb=0x%08x)\n",
                          pmbHead->pszComment,
                          pmbHead->dwBytes,
                          pmbHead->hglobal,
                          pmbHead );
            memset( pmbHead->hglobal, 0xFA, pmbHead->dwBytes );
            memset( pmbHead, 0xFE, sizeof(*pmbHead) );
            GlobalFree( pmbHead );
        }
        else
        {
#if 0
            DebugMsg( "\n**** Attempted to free memory at 0x%08x (ThreadID = 0x%08x) ****\n\n",
                hglobal, GetCurrentThreadId( ) );
#endif
        }
    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    HGLOBAL       hglobal = GlobalAlloc( uFlags, dwBytes );

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );

    dbgEnterCS( );

    while ( pmb )
    {
        LPVOID args[ 5 ];
        TCHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            DebugMsg("\n******** Memory leak detected ******** ThreadID = 0x%08x ******** \n\n", GetCurrentThreadId( ) );
               //OutputDebugString("12345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            OutputDebugString(TEXT("Filename(Line Number):                              Module     Addr/HGLOBAL  Size   String\n"));
            fFoundLeak = TRUE;
        }

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = UlongToPtr(pmb->dwBytes);
        args[4] = (LPVOID) pmb->pszModule;

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }
        else
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }

        OutputDebugString( szOutput );

        pmb = pmb->pNext;
    }

    if ( fFoundLeak == TRUE )
    {
        OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
    }

    dbgExitCS( );

    Assert( !fFoundLeak );

}

//
// Global Management Functions -
//
// These are in debug and retail but internally they change
// depending on the build.
//

#undef new
void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule )
{
    return DebugAlloc( pszFile, iLine, pszModule, GPTR, nSize, TEXT("new()") );
}

void * __cdecl operator new(size_t t_size )
{
    AssertMsg( 0, "Macro failure" );
    return NULL;
}

void __cdecl operator delete(void *pv)
{
    TraceFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#else // ! DEBUG -- It's retail

//
// Global Management Functions -
//
// These are in debug and retail but are internally they change
// depending on the build.
//

void * __cdecl operator new(size_t t_size )
{
    return LocalAlloc( GPTR, t_size );
}

void __cdecl operator delete(void *pv)
{
    LocalFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\directory.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include <remboot.h>
#include "callback.h"
#include "utils.h"

DEFINE_MODULE( "RIPREP" );

//
// VerifyDirectoryName( )
//
// Make sure that the directory name entered conforms to the
// restrictions that OSChooser has. Directory names also
// can not contain spaces.
//
// Returns: S_OK if it does
//          E_FAIL if it does not
//
HRESULT
VerifyDirectoryName(
    )
{
    HRESULT hr = S_OK;

    TraceFunc( "VerifyDirectoryName()\n" );

    LPWSTR pszDir = g_MirrorDir;

    while ( *pszDir > 32 && *pszDir <= 127 )
    {
        pszDir++;
    }

    if ( *pszDir != L'\0' )
    {
        hr = E_FAIL;
    }

    HRETURN(hr);
}

//
// CheckDirectory( )
//
// Make sure the directory doesn't exist on the server already.
// If it does, ask the user what to do next.
//
// Returns: S_OK if the directory does NOT exist or if the user
//               said it was alright to overwrite.
//          E_FAIL if the directory existed and the user said
//                 it was NOT ok to overwrite
//
HRESULT
CheckDirectory(
    HWND hDlg )
{
    TraceFunc( "CheckDirectory( ... )\n" );

    HRESULT hr = E_FAIL;
    WCHAR szPath[ MAX_PATH ];

    wsprintf( szPath,
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s",
              g_ServerName,
              g_Language,
              REMOTE_INSTALL_IMAGE_DIR_W,
              g_MirrorDir );

    DWORD dwAttrib = GetFileAttributes( szPath );

    if ( dwAttrib != 0xFFFFffff )
    {
        INT iResult =  MessageBoxFromStrings( hDlg,
                                              IDS_DIRECTORY_EXISTS_TITLE,
                                              IDS_DIRECTORY_EXISTS_TEXT,
                                              MB_YESNO );
        if ( iResult == IDNO )
            goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN(hr);
}

//
// DirectoryDlgCheckNextButtonActivation( )
//
VOID
DirectoryDlgCheckNextButtonActivation(
    HWND hDlg )
{
    TraceFunc( "DirectoryDlgCheckNextButtonActivation( )\n" );
    GetDlgItemText( hDlg, IDC_E_OSDIRECTORY, g_MirrorDir, ARRAYSIZE(g_MirrorDir));
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | (wcslen(g_MirrorDir) ? PSWIZB_NEXT : 0 ) );
    TraceFuncExit( );
}


//
// DirectoryDlgProc()
//
INT_PTR CALLBACK
DirectoryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        // Per bug 208881 - limit directory name to 67 chars
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_OSDIRECTORY ), REMOTE_INSTALL_MAX_DIRECTORY_CHAR_COUNT - 1 );
        return FALSE;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_OSDIRECTORY:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                DirectoryDlgCheckNextButtonActivation( hDlg );
            }
            break;
        }
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            GetDlgItemText( hDlg, IDC_E_OSDIRECTORY, g_MirrorDir, ARRAYSIZE(g_MirrorDir) );
            Assert( wcslen( g_MirrorDir ) );
            if ( FAILED( VerifyDirectoryName( ) ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_RESTRICTION_TITLE, IDS_OSCHOOSER_RESTRICTION_TEXT, MB_OK );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                break;
            }
            if ( FAILED( CheckDirectory( hDlg ) ) )
            {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                break;
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            DirectoryDlgCheckNextButtonActivation( hDlg );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\debug.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: DEBUG.H

  Debugging utilities header
 
 ***************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_

// Trace Flags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_QUERYINTERFACE   0x00000001   // Query Interface details
#define TF_FUNC             0x00000002   // Functions entrances w/parameters
#define TF_CALLS            0x00000004   // Function calls
#define TF_MEMORYALLOCS     0x00000008   // Memory Allocations
#define TF_DLL              0x00000010   // DLL specific
#define TF_WM               0x00000020   // Window Messages
#define TF_SCP              0x00000030    // SCP objects

#ifdef DEBUG

#pragma message("BUILD: DEBUG macros being built")

// Globals
extern DWORD g_TraceMemoryIndex;
extern DWORD g_dwCounter;
extern DWORD g_dwTraceFlags;

extern const TCHAR g_szTrue[];
extern const TCHAR g_szFalse[];


// Macros
#define DEFINE_MODULE( _module ) static const TCHAR g_szModule[] = TEXT(_module);
#define __MODULE__ g_szModule
#define DEFINE_THISCLASS( _class ) static const TCHAR g_szClass[] = TEXT(_class); 
#define __THISCLASS__ g_szClass
#define DEFINE_SUPER( _super ) static const TCHAR g_szSuper[] = TEXT(_super);
#define __SUPER__ g_szSuper

#if defined(_X86_)
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK         DebugBreak( );
#endif

#define INITIALIZE_TRACE_MEMORY_PROCESS     \
    g_TraceMemoryIndex = TlsAlloc( );       \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define INITIALIZE_TRACE_MEMORY_THREAD      \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define UNINITIALIZE_TRACE_MEMORY           \
    DebugMemoryCheck( );                    \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Memory tracing terminated.\n") )

#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), !!(_fn) ) ) DEBUG_BREAK

#define TraceAlloc( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, _size, TEXT(#_size) )
#define TraceAllocString( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, (_size) * sizeof(TCHAR), TEXT(#_size) )
#define TraceFree( _hmem )          DebugFree( _hmem )

//
// Tracing Macros
//
// All functions that begin with "Trace" are in both DEBUG and RETAIL, but
// in RETAIL they do not spew output.
//

// Displays file, line number, module and "_msg" only if the TF_FUNC is set
// in g_dwTraceFlags.
#define TraceFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ ") TEXT(_msg) );

// Displays file, line number, module, class name and "_msg" only if the 
// TF_FUNC is set in g_dwTraceFlags.
#define TraceClsFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ %s::%s"), g_szClass, TEXT(_msg) );

// Return macro for TraceFunc() and TraceClsFunc()
#define TraceFuncExit() { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V*\n") ); \
    InterlockDecrement(g_dwCounter); \
    return; \
}
#define RETURN( _rval ) { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _rval; \
}

// If the value is not S_OK, it will display it.
#define HRETURN( _hr ) { \
    if ( _hr ) \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V hr = 0x%08x\n"), _hr ); \
    else \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _hr; \
}

// Displays the file, line number, module and function call and return from the
// function call (no return value displayed) for "_fn" only if the TF_CALLS is 
// set in g_dwTraceFlags. 
#define TraceDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}

// Displays the file, line number, module and function call and return value
// which is formatted in "_msg" for "_fn" only if the TF_CALLS is set in 
// g_dwTraceFlags. 
#define TraceMsgDo( _fn, _msg ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    TraceMessageDo( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT(_msg), TEXT(#_fn), _fn ); \
    InterlockDecrement(g_dwCounter); \
}

// This functions only asserts if the result is ZERO.
#define TraceAssertIfZero( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#define TraceMsgGUID( _flag, _guid ) \
    TraceMsg( _flag, TEXT("{%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"), \
        _guid.Data1, _guid.Data2, _guid.Data3,  \
        _guid.Data4[0], _guid.Data4[1], _guid.Data4[2], _guid.Data4[3], \
        _guid.Data4[4], _guid.Data4[5], _guid.Data4[6], _guid.Data4[7] )

#define ErrorMsg( _fmt, _arg ) \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_ALWAYS, TEXT(_fmt), _arg );

//
// Debug Macros
//
// These calls are only compiled in DEBUG. They are a NOP in RETAIL (not even
// compiled in.
//

// Same as TraceDo() but only compiled in DEBUG.
#define DebugDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}

// Same as TraceMsgDo() but only compiled in DEBUG.
#define DebugMsgDo( _fn, _msg ) {\
    InterlockIncrement(g_dwCounter); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    DebugMessageDo( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), TEXT(#_fn), _fn); \
    InterlockDecrement(g_dwCounter); \
}

//
// HRESULT testing macros
//
// These functions check HRESULT return values and display UI if conditions
// warrant only in DEBUG.
//

// Warning is display if HRESULT is anything but S_OK (0).
#define THR( _fn ) \
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

// Warning is display if HRESULT is anything but S_OK (0).
#define RRETURN( _fn ) { \
    RETURN( TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn ) ); \
    }

// Warning is display if HRESULT is anything but S_OK (0) only if 
// TF_QUERYINTERFACE is set in g_dwTraceFlags, otherwise only a debug message
// will be printed.
#define QIRETURN( _fn, _riid ) { \
    if ( !!( TF_QUERYINTERFACE & g_dwTraceFlags ) ) { \
        RETURN(TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )); \
    } else if ( hr ) \
        DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("HRESULT: QueryInterface({%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}) failed()\n"),  _riid.Data1, _riid.Data2, _riid.Data3,  _riid.Data4[0], _riid.Data4[1], _riid.Data4[2], _riid.Data4[3], _riid.Data4[4], _riid.Data4[5], _riid.Data4[6], _riid.Data4[7] ); \
    RETURN(_fn); \
    }

// Warning is display if HRESULT is not S_OK (0) or "_ok".
#define RRETURN1( _hr, _ok ) {\
    RETURN(TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_hr), \
                    ( ( _hr == _ok ) ? S_OK : _hr ) ) ); \
    }

//
// Other
//
#define BOOLTOSTRING( _fBool ) ( !!(_fBool) ? g_szTrue : g_szFalse )

//
// Trace/Debug Functions - these do not exist in RETAIL.
//
void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCSTR pszFormat,
    ... );

void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCWSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCWSTR pszFormat,
    ... );

void
TraceMessage( 
    LPCTSTR pszFile, 
    const int uLine,
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void
TraceMessageDo( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... );

void 
DebugMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    ... );

void 
DebugMessageDo( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... );

BOOL
AssertMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue );

HRESULT
TraceHR( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr );

//
// Memory tracing functions - these are remapped to the "Global" memory 
// functions when in RETAIL.
//
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

HGLOBAL
DebugFree( 
    HGLOBAL hMem );

// The memory functions don't exist in RETAIL.
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

#define DebugMemoryAddHandle( _handle ) \
    DebugMemoryAdd( _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT(#_handle) );

#define DebugMemoryAddAddress( _pv ) \
    DebugMemoryAdd( _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT(#_pv) );

#define TraceStrDup( _sz ) \
    DebugMemoryAdd( StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("StrDup(") TEXT(#_sz) TEXT(")") );

void
DebugMemoryDelete( 
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

#ifdef __cplusplus
extern void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule );
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )

#endif

//
//
#else // it's RETAIL    ******************************************************
//
//

// Debugging -> NOPs
#define Assert( _fn )           
#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define DEFINE_MODULE( _module )
#define DEFINE_THISCLASS( _class )
#define DEFINE_SUPER( _super )
#define BOOLTOSTRING( _fBool )  NULL
#define AssertMsg                   1 ? (void)0 : (void) 
#define TraceMsg                    1 ? (void)0 : (void) 
#define TraceMsgGUID( _f, _g )      
#define DebugMsg                    1 ? (void)0 : (void) 
#define ErrorMsg                    1 ? (void)0 : (void) 
#define TraceMessage                1 ? (void)0 : (void) 
#define DebugMessage                1 ? (void)0 : (void) 
#define AssertMessage               1 ? (void)0 : (void) 
#define TraceHR                     1 ? (void)0 : (void) 
#define TraceFunc                   1 ? (void)0 : (void) 
#define TraceClsFunc                1 ? (void)0 : (void) 
#define TraceFuncExit()
#define DebugMemoryAddHandle( _handle )
#define DebugMemoryAddAddress( _pv )
#define INITIALIZE_TRACE_MEMORY_PROCESS
#define INITIALIZE_TRACE_MEMORY_THREAD
#define UNINITIALIZE_TRACE_MEMORY
#define DebugMemoryDelete( _h )

// Tracing -> just do operation
#define TraceDo( _fn )              _fn
#define TraceMsgDo( _fn, _msg )     _fn
#define TraceAssertIfZero( _fn )    _fn

// RETURN testing -> do retail
#define THR
#define RETURN( _fn )               return _fn
#define RRETURN( _fn )              return _fn
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi

// Memory Functions -> do retail
#define TraceAlloc( _flags, _size )     GlobalAlloc( _flags, _size )
#define TraceAllocString( _flags, _size ) GlobalAlloc( _flags, (_size) * sizeof(TCHAR) )
#define TraceFree( _pv )                GlobalFree( _pv )
#define TraceStrDup( _sz )              StrDup( _sz )

#endif // DBG==1

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\errorlog.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: ERRORLOG.H


 ***************************************************************************/

#ifndef _ERRORLOG_H_
#define _ERRORLOG_H_


INT_PTR CALLBACK
ErrorsDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _ERRORLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\directory.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.H


 ***************************************************************************/

#ifndef _DIRECTORY_H_
#define _DIRECTORY_H_

INT_PTR CALLBACK
DirectoryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _DIRECTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\finish.h ===
// file renamed summary.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\finish.cpp ===
// file renamed summary.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\logging.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

 ***************************************************************************/

#ifndef _LOGGING_H_
#define _LOGGING_H_

HRESULT
LogOpen( );

HRESULT
LogClose( );

void
LogMsg( 
    LPCSTR pszFormat,
    ... );

void
LogMsg( 
    LPCWSTR pszFormat,
    ... );

#endif // _LOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\errorlog.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: ERRORLOG.CPP


 ***************************************************************************/

#include "pch.h"
#include "utils.h"
#include "logging.h"
#include <richedit.h>

DEFINE_MODULE("RIPREP");

//
// EditStreamCallback( )
//
// Callback routine used by the rich edit control to read in the log file.
//
// Returns: 0 - to continue.
//          Otherwize, Win32 error code.
//
DWORD CALLBACK
EditStreamCallback (
    HANDLE   hLogFile,
    LPBYTE   Buffer,
    LONG     cb,
    PULONG   pcb
    )
{
    DWORD error;

    TraceFunc( "EditStreamCallback( )\n" );

    if ( !ReadFile ( g_hLogFile, Buffer, cb, pcb, NULL ) ) {
        error = GetLastError( );
        DebugMsg( "Error - EditStreamCallback: GetLastError() => 0x%08x \n", error );
        RETURN(error);
    }

    RETURN(0);
}
//
// ErrorsDlgProc()
//
INT_PTR CALLBACK
ErrorsDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    default:
        return FALSE;
        
    case WM_INITDIALOG:
        {
            HRESULT     hr;
            HWND        hWndRichEdit = GetDlgItem( hDlg, IDC_E_ERRORS );
            EDITSTREAM  eStream;        // structure used by EM_STREAMIN message

            Assert( hWndRichEdit );
            ZeroMemory( &eStream, sizeof(eStream) );

            hr = THR( LogOpen( ) );
            if ( FAILED( hr ) )
            {
                HWND hParent = GetParent( hDlg );
                DestroyWindow( hDlg );
                SetFocus( hParent );
                return FALSE;
            }

            // move to the beginning of the newest log
            SetFilePointer( g_hLogFile, g_dwLogFileStartLow, (LONG*)&g_dwLogFileStartHigh, FILE_BEGIN );

            eStream.pfnCallback = (EDITSTREAMCALLBACK) EditStreamCallback;
            SendMessage ( hWndRichEdit, EM_STREAMIN, SF_TEXT, (LPARAM) &eStream );
            SendMessage ( hWndRichEdit, EM_SETMODIFY, TRUE, 0 );

            CloseHandle( g_hLogFile );
            g_hLogFile = INVALID_HANDLE_VALUE;
            LogClose( );

            CenterDialog( hDlg );

            PostMessage( hDlg, WM_USER, 0, 0 );
        }
        break;

    case WM_COMMAND:
        switch ( wParam ) 
        {
        case IDCANCEL:
            EndDialog ( hDlg, 0 );
            break;

        default:
            return FALSE;
        }

    case WM_USER:
        {
            HWND        hWndRichEdit = GetDlgItem( hDlg, IDC_E_ERRORS );
            // These have to be delayed or the Edit control will
            // highlight all the text.
            SendMessage(hWndRichEdit,EM_SETSEL,0,0);
            SendMessage(hWndRichEdit,EM_SCROLLCARET,0,0);
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\pch.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: PCH.H

  Precompiled header file.
 
 ***************************************************************************/

#if DBG == 1
#define DEBUG
#endif

#define SECURITY_WIN32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <shlwapi.h>
#include <lm.h>
#include <remboot.h>
#include <setupapi.h>
extern "C" {
#include "..\imirror\imirror.h"
}

#include "debug.h"
#include "resource.h"
#include "msg.h"

// Globals
extern HINSTANCE g_hinstance;
extern HWND g_hCurrentWindow;
extern WCHAR g_ServerName[ MAX_PATH ];
extern WCHAR g_MirrorDir[ MAX_PATH ];
extern WCHAR g_Language[ MAX_PATH ];
extern WCHAR g_ImageName[ MAX_PATH ];
extern WCHAR g_Architecture[ 16 ];
extern WCHAR g_Description[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT ];
extern WCHAR g_HelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ];
extern WCHAR g_SystemRoot[ MAX_PATH ];
extern WCHAR g_WinntDirectory[ MAX_PATH ];
extern DWORD g_dwWinntDirLength;
extern BOOLEAN g_fQuietFlag;
extern BOOLEAN g_fErrorOccurred;
extern BOOLEAN g_fRebootOnExit;
extern DWORD g_dwLogFileStartLow;
extern DWORD g_dwLogFileStartHigh;
extern PCRITICAL_SECTION g_pLogCritSect;
extern HANDLE g_hLogFile;
extern OSVERSIONINFO OsVersion;
extern HINF g_hCompatibilityInf;
extern WCHAR g_HalName[32];
extern WCHAR g_ProductId[4];

//
// Inc/decrements macros.
//
#define InterlockDecrement( _var ) --_var;
#define InterlockIncrement( _var ) ++_var;

// Macros
#define ARRAYSIZE( _x ) ((UINT) ( sizeof( _x ) / sizeof( _x[ 0 ] ) ))

// Private Messages
#define WM_ERROR            WM_USER
#define WM_UPDATE           WM_USER + 1
#define WM_CONTINUE         WM_USER + 2
#define WM_ERROR_OK         WM_USER + 3

//
// Made-up DirID for the UserProfiles directory.
//
// If you change this value, you *must* also change
// the corresponding value in riprep.inf
//
#define PROFILES_DIRID      (0x8001)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by riprep.rc
//
#define IDS_APPNAME                     1
#define IDS_ALREADY_RUNNING_TITLE       2
#define IDS_ALREADY_RUNNING_MESSAGE     3
#define IDS_ERROR                       4
#define IDS_LARGEFONTNAME               5
#define IDS_CANCELCAPTION               6
#define IDS_CANCELTEXT                  7
#define IDS_SERVER_TITLE                8
#define IDS_SERVER_SUBTITLE             9
#define IDS_DIRECTORY_TITLE             10
#define IDS_DIRECTORY_SUBTITLE          11
#define IDS_SIF_TITLE                   12
#define IDS_SIF_SUBTITLE                13
#define IDS_FINISH_TITLE                14
#define IDS_FINISH_SUBTITLE             15
#define IDS_SETUPPATH_TITLE             16
#define IDS_SETUPPATH_SUBTITLE          17
#define IDS_INITIALIZE                  18
#define IDS_VERIFY_WINDOWS_VERSION      19
#define IDS_ANALYZE_PARTITIONS          20
#define IDS_COPY_PARTITIONS             21
#define IDS_COPY_FILES                  22
#define IDS_COPY_REGISTRY               23
#define IDS_PATH_DS_ENTRIES             24
#define IDS_UNKNOWN_TASK                25
#define IDS_INITIALIZING                26
#define IDS_VERIFYING_WINDOWS_VERSION   27
#define IDS_ANALYZING_PARTITIONS        28
#define IDS_COPYING_PARTITIONS          29
#define IDS_COPYING_FILES               30
#define IDS_COPYING_REGISTRY            31
#define IDS_UPDATING_DS_ENTRIES         32
#define IDS_DOING_UNKNOWN_TASK          33
#define IDS_REBOOT_SYSTEM               34
#define IDS_REBOOTING_SYSTEM            35
#define IDS_APPLICATION_TITLE           37
#define IDS_APPLICATION_SUBTITLE        38
#define IDS_OSCHOOSER_RESTRICTION_TITLE 42
#define IDS_OSCHOOSER_RESTRICTION_TEXT  43
#define IDS_DIRECTORY_EXISTS_TITLE      44
#define IDS_DIRECTORY_EXISTS_TEXT       45
#define IDS_FAILED_TO_CONTACT_SERVER_TITLE 46
#define IDS_NOT_A_BINL_SERVER_TITLE     47
#define IDS_NOT_A_BINL_SERVER_TEXT      48
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE 49
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT 50
#define IDS_DEFAULT_LANGUAGE            51
#define IDS_UNKNOWN                     52
#define IDS_PROCESS_NAME_COLUMN         53
#define IDS_APPL_NAME_COLUMN            54
#define IDS_DISK_FULL_TITLE             55
#define IDS_DISK_FULL_TEXT              56
#define IDS_ENCRYPTED_FILE_TITLE        57
#define IDS_ENCRYPTED_FILE_TEXT         58
#define IDS_MUST_BE_ADMINISTRATOR_TITLE 59
#define IDS_MUST_BE_ADMINISTRATOR_TEXT  60
#define IDS_MUST_BE_WORKSTATION_TITLE   61
#define IDS_MUST_BE_WORKSTATION_TEXT    62
#define IDS_SHARING_VIOLATION_TITLE     64
#define IDS_SHARING_VIOLATION_TEXT      65
#define IDS_ACCESS_DENIED_TITLE         66
#define IDS_ACCESS_DENIED_TEXT          67
#define IDS_MULTIPLE_DISK_TITLE         68
#define IDS_MULTIPLE_DISK_TEXT          69
#define IDS_BOOT_PARTITION_TITLE        70
#define IDS_BOOT_PARTITION_TEXT         71
#define IDS_NOT_COPYING_REPARSE_POINT_TITLE 72
#define IDS_NOT_COPYING_REPARSE_POINT_TEXT 73
#define IDS_INVALID_ARCHITECTURE_TITLE  74
#define IDS_INVALID_ARCHITECTURE_TEXT   75
#define IDS_MISSING_BACKING_FLAT_IMAGE_TITLE 76
#define IDS_MISSING_BACKING_FLAT_IMAGE_TEXT 77
#define IDS_QUIET                       78
#define IDS_ACCESS_DENIED_LOG           79
#define IDS_SHARING_VIOLATION_LOG       80
#define IDS_NOT_COPYING_REPARSE_POINT_LOG 81
#define IDS_ENCRYPTED_FILE_LOG          82
#define IDS_BOOT_PARTITION_LOG          83
#define IDS_MULTIPLE_DISK_LOG           84
#define IDS_DISK_FULL_LOG               85
#define IDS_END_LOG                     86
#define IDS_ERROR_IGNORED               87
#define IDS_OPERATION_ABORTED           88
#define IDS_DYNAMIC_DISK_TITLE          89
#define IDS_DYNAMIC_DISK_TEXT           90
#define IDS_RETRY_ABORT_IGNORE_TEXT     91
#define IDS_STATUS_RETRY                92
#define IDS_UNKNOWN_OPTION_FORMAT       93
#define IDS_CANT_BE_DC_TITLE            94
#define IDS_CANT_BE_DC_TEXT             95
#define IDS_COMPAT_TITLE                96
#define IDS_COMPAT_SUBTITLE             97
#define IDS_COMPAT_ERR                  98
#define IDS_COMPAT_WRN                  99
#define IDS_COMPAT_ERR_WRN              100
#define IDD_SERVER                      101
#define IDD_WELCOME                     102
#define IDD_OSDIRECTORY                 103
#define IDI_SETUP                       104
#define IDD_SUMMARY                     104
#define IDB_X                           105
#define IDB_HEADER                      108
#define IDB_TITLEPAGE                   109
#define IDD_DEFAULTSIF                  110
#define IDB_ARROW                       110
#define IDD_TASKS                       111
#define IDB_CHECK                       111
#define IDD_SETUPPATH                   113
#define IDD_APPLICATIONS_RUNNING        114
#define IDD_COMPLETE                    115
#define IDD_VIEWERRORS                  116
#define IDD_COMPAT                      117
#define IDD_COMPATIBILITY_TEXT          118
#define IDS_STOPSVC_TITLE               119
#define IDS_STOPSVC_SUBTITLE            120
#define IDS_STOPSVC_WRN                 121
#define IDD_STOPSVCWRN                  122
#define IDS_SERVICE_DESCRIPTION_COLUMN  123
#define IDS_SERVICE_NAME_COLUMN         124
#define IDD_STOPSVC                     125
#define IDC_STOP_SERVICE                126
#define IDS_INCOMPAT_STOP_FORMAT        127
#define IDS_INCOMPAT_WARN_FORMAT        128
#define IDS_INCOMPAT_MSG_TITLE          129
#define IDS_STOPSVC_FAIL_TITLE          130
#define IDS_STOPSVC_FAIL_TEXT           131
#define IDS_SERVICE_DESC_UNKNOWN        200
#define IDS_SERVICE_DESC_FORMAT         201
#define IDS_MULTIPLE_PROFILES           202
#define IDS_MULTIPLE_PROFILES_DESC      203
#define IDS_SERVER_ACCESS               204
#define IDS_SERVER_ACCESS_DESC          205
#define IDS_ACTIVIATION_COUNT_EXCEEDED  206
#define IDS_ADMINISTRATOR1              207
#define IDS_OWNER1                      208
#define IDS_TEMP_DIR                    209
#define IDS_TEMP_INTERNET_DIR           210
#define IDS_SID_DIR1                    211
#define IDS_SID_DIR2                    212
#define IDS_SID_DIR3                    213 
#define IDS_HISTORY_DIR                 214
#define IDS_HISTORY_DIR_IE5             215
#define IDC_E_SERVER                    1000
#define IDC_E_OSDIRECTORY               1001
#define IDC_L_TASKS                     1005
#define IDC_L_IMAGES                    1005
#define IDC_L_PROCESSES                 1005
#define IDC_S_OPERATION                 1006
#define IDC_TITLE                       1008
#define IDC_S_SERVERNAME                1009
#define IDC_S_DIRECTORY                 1010
#define IDC_E_ERRORS                    1013
#define IDC_E_HELPTEXT                  1030
#define IDC_E_DESCRIPTION               1042
#define IDC_INTRO_TEXT                  1050
#define IDC_ROOT_LIST                   1051
#define IDC_DETAILS                     1052
#define IDT_DETAIL_TEXT                 1053
#define IDC_TEXT                        1054

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\serverdlg.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"
#include <winver.h>
#include <sputils.h>

DEFINE_MODULE( "RIPREP" )


BOOLEAN
GetInstalledProductType(
    OUT PDWORD  ProductType,
    OUT PDWORD  ProductSuite
    ) 
/*++

Routine Description:

    retrieves the product type and suite from a running system

Arguments:

    ProductType - receives a VER_NT_* constant.
    ProductSuite - receives a VER_SUITE_* mask for the system.
    
Return Value:

    TRUE indicates success

--*/
{
    OSVERSIONINFOEX VersionInfo;

    VersionInfo.dwOSVersionInfoSize  = sizeof(VersionInfo);

    if (GetVersionEx((OSVERSIONINFO *)&VersionInfo)) {
        //
        // make domain controllers and servers look the same
        //
        *ProductType = (VersionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER)
                         ? VER_NT_SERVER 
                         : VersionInfo.wProductType;
        //
        // we only care about suites that have a SKU associated with them.
        //
        *ProductSuite = (VersionInfo.wSuiteMask   
            & (VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER | VER_SUITE_PERSONAL)) ;

        

        return(TRUE);
    }

    return(FALSE);

}

BOOL
pSetupEnablePrivilegeW(
    IN PCWSTR PrivilegeName,
    IN BOOL   Enable
    )

/*++

Routine Description:

    Enable or disable a given named privilege.

Arguments:

    PrivilegeName - supplies the name of a system privilege.

    Enable - flag indicating whether to enable or disable the privilege.

Return Value:

    Boolean value indicating whether the operation was successful.

--*/

{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}


GetSuiteMaskFromPath(
    IN PCWSTR PathToSearch,
    OUT PDWORD SuiteMask
    )
{
    #define HIVENAME L"riprepsetupreg"
    TCHAR lpszSetupReg[MAX_PATH] = HIVENAME L"\\ControlSet001\\Services\\setupdd";

    WCHAR Path[MAX_PATH];
    WCHAR DestPath[MAX_PATH];
    LONG rslt;
    HKEY hKey;
    DWORD Type;
    DWORD Buffer[4];
    DWORD BufferSize = sizeof(Buffer);
    DWORD i;
    BOOLEAN RetVal = FALSE;

    GetTempPath(ARRAYSIZE(Path),Path);
    GetTempFileName( Path, L"ripr", 0, DestPath);

    wcscpy(Path, PathToSearch);
    wcscat(Path, L"\\setupreg.hiv");

    if (!CopyFile(Path,DestPath,FALSE)) {
        goto e0;
    }

    SetFileAttributes(DestPath,FILE_ATTRIBUTE_NORMAL);

    //
    // need SE_RESTORE_NAME priviledge to call this API!
    //
    pSetupEnablePrivilegeW( SE_RESTORE_NAME, TRUE );

    //
    // try to unload this first in case we faulted or something and the key is still loaded
    //
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HIVENAME );

    rslt = RegLoadKey( HKEY_LOCAL_MACHINE, HIVENAME, DestPath );
    if (rslt != ERROR_SUCCESS) {
        goto e1;
    }
          
    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszSetupReg,&hKey);
    if (rslt != ERROR_SUCCESS) {
        goto e2;
    }

    rslt = RegQueryValueEx(hKey, NULL, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != ERROR_SUCCESS || Type != REG_BINARY) {
        goto e3;
    }
    
    *SuiteMask=Buffer[3];
    
    RetVal = TRUE;

e3:
    RegCloseKey( hKey );
e2:
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HIVENAME );

e1:
    if (GetFileAttributes(DestPath) != 0xFFFFFFFF) {
        SetFileAttributes(DestPath,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(DestPath);
        wcscat(DestPath, L".LOG");
        SetFileAttributes(DestPath,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(DestPath);
    }

    pSetupEnablePrivilegeW( SE_RESTORE_NAME, FALSE );
e0:
    return(RetVal);
}

BOOLEAN
GetProductTypeFromPath(
    OUT PDWORD ProductType, 
    OUT PDWORD ProductSuite,
    IN  PCWSTR PathToSearch )
/*++

Routine Description:

    retrieves the product type and suite by looking in txtsetup.sif

Arguments:

    ProductType - receives a VER_NT_* constant.
    ProductSuite - receives a VER_SUITE_* mask for the system.
    PathToSearch - specifies the path to the txtsetup.sif to be searched
    
Return Value:

    TRUE indicates success

--*/
{
    WCHAR Path[MAX_PATH];
    UINT DontCare;
    HINF hInf;
    WCHAR Type[20];
    BOOLEAN RetVal = TRUE;
    INFCONTEXT Context;

    wcscpy(Path, PathToSearch);
    wcscat(Path, L"\\txtsetup.sif");

    hInf = SetupOpenInfFile( Path, NULL, INF_STYLE_WIN4, &DontCare );
    if (hInf != INVALID_HANDLE_VALUE) {
        if (SetupFindFirstLine( hInf, L"SetupData", L"ProductType", &Context) &&
        SetupGetStringField( &Context, 1, Type, ARRAYSIZE(Type), NULL)) {
            switch (Type[0]) {
            case L'0':
                *ProductType = VER_NT_WORKSTATION;
                *ProductSuite = 0;
                break;
            case L'1':
                *ProductType = VER_NT_SERVER;
                //
                // HACK alert: we have to call this API because txtsetup.sif 
                // didn't have the correct product type in it in win2k.  
                // So we do it the hard way.
                //
                if (!GetSuiteMaskFromPath( PathToSearch, ProductSuite)) {
                    *ProductSuite = 0;
                }
                break;
            case L'2':
                *ProductType = VER_NT_SERVER;
                *ProductSuite = VER_SUITE_ENTERPRISE;
                break;
            case L'3':
                *ProductType = VER_NT_SERVER;
                *ProductSuite = VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER;
                break;
            case L'4':
                *ProductType = VER_NT_WORKSTATION;
                *ProductSuite = VER_SUITE_PERSONAL;
                break;
            default:
                ASSERT( FALSE && L"Unknown type in txtsetup.sif ProductType" );
                RetVal = FALSE;
                break;
            }

        }

        SetupCloseInfFile(hInf);        
    } else {
        RetVal = FALSE;
    }


    return(RetVal);

}

//
// GetNtVersionInfo( )
//
// Retrieves the build version from the kernel
//
BOOLEAN
GetNtVersionInfo(
    PULONGLONG Version,
    PWCHAR SearchDir
    )
{
    DWORD Error = ERROR_SUCCESS;
    DWORD FileVersionInfoSize;
    DWORD VersionHandle;
    ULARGE_INTEGER TmpVersion;
    PVOID VersionInfo;
    VS_FIXEDFILEINFO * FixedFileInfo;
    UINT FixedFileInfoLength;
    WCHAR Path[MAX_PATH];
    BOOLEAN fResult = FALSE;

    TraceFunc("GetNtVersionInfo( )\n");

    // Resulting string should be something like:
    //      "\\server\reminst\Setup\English\Images\nt50.wks\i386\ntoskrnl.exe"

    if (!SearchDir) {
        goto e0;
    }
    wcscpy(Path, SearchDir);
    wcscat(Path, L"\\ntoskrnl.exe");

    FileVersionInfoSize = GetFileVersionInfoSize(Path, &VersionHandle);
    if (FileVersionInfoSize == 0)
        goto e0;

    VersionInfo = LocalAlloc( LPTR, FileVersionInfoSize );
    if (VersionInfo == NULL)
        goto e0;

    if (!GetFileVersionInfo(
             Path,
             VersionHandle,
             FileVersionInfoSize,
             VersionInfo))
        goto e1;

    if (!VerQueryValue(
             VersionInfo,
             L"\\",
             (LPVOID*)&FixedFileInfo,
             &FixedFileInfoLength))
        goto e1;

    TmpVersion.HighPart = FixedFileInfo->dwFileVersionMS;
    TmpVersion.LowPart = FixedFileInfo->dwFileVersionLS;
    *Version = TmpVersion.QuadPart;

    fResult = TRUE;

e1:
    LocalFree( VersionInfo );
e0:
    RETURN(fResult);
}

//
// VerifyMatchingFlatImage( )
//
BOOLEAN
VerifyMatchingFlatImage( 
    PULONGLONG VersionNeeded  OPTIONAL
    )
{
    TraceFunc( "VerifyMatchingFlatImage( )\n" );

    BOOLEAN fResult = FALSE;   // assume failure
    DWORD dwLen;
    WCHAR szPath[ MAX_PATH ];
    WIN32_FIND_DATA fd;    
    HANDLE hFind;
    ULONGLONG OurVersion;
    DWORD OurProductType = 0, OurProductSuiteMask = 0;

    GetSystemDirectory( szPath, ARRAYSIZE( szPath ));
    GetNtVersionInfo( &OurVersion, szPath );

    GetInstalledProductType( &OurProductType, &OurProductSuiteMask );

    if (VersionNeeded) {
        *VersionNeeded = OurVersion;
    }

    DebugMsg( 
        "Our NTOSKRNL verion: %u.%u:%u.%u Type: %d Suite: %d\n", 
        HIWORD(((PULARGE_INTEGER)&OurVersion)->HighPart),
        LOWORD(((PULARGE_INTEGER)&OurVersion)->HighPart),
        HIWORD(((PULARGE_INTEGER)&OurVersion)->LowPart),
        LOWORD(((PULARGE_INTEGER)&OurVersion)->LowPart),
        OurProductType,
        OurProductSuiteMask);

    wsprintf( szPath,
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\",
              g_ServerName,
              g_Language,
              REMOTE_INSTALL_IMAGE_DIR_W );

    dwLen = wcslen( szPath );

    wcscat( szPath, L"*" );

    hFind = FindFirstFile( szPath, &fd );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do {
            if ( (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
              && StrCmp( fd.cFileName, L"." ) != 0 
              && StrCmp( fd.cFileName, L".." ) != 0 )
            {
                ULONGLONG Version;
                DWORD ProductType = 0, ProductSuiteMask = 0;
                wsprintf( &szPath[dwLen], 
                          L"%s\\%s",
                          fd.cFileName,
                          g_Architecture );
                
                if ( GetNtVersionInfo( &Version, szPath ) &&
                     GetProductTypeFromPath( 
                                    &ProductType, 
                                    &ProductSuiteMask, 
                                    szPath ))
                {
                    DebugMsg( 
                        "%s's verion: %u.%u:%u.%u Type: %d Suite: %d\n",
                        fd.cFileName, 
                        HIWORD(((PULARGE_INTEGER)&Version)->HighPart),
                        LOWORD(((PULARGE_INTEGER)&Version)->HighPart),
                        HIWORD(((PULARGE_INTEGER)&Version)->LowPart),
                        LOWORD(((PULARGE_INTEGER)&Version)->LowPart),
                        ProductType,
                        ProductSuiteMask);
                                                      
                    if ( OurVersion == Version &&
                         OurProductType == ProductType &&
                         OurProductSuiteMask == ProductSuiteMask )
                    {
                        wcscpy( g_ImageName, szPath );
                        fResult = TRUE;
                        break;
                    }
                }                          
            }
        } while ( FindNextFile( hFind, &fd ) );
    }

    FindClose( hFind );

    RETURN(fResult);
}

//
// VerifyServerName( )
//
// Check to see if the server is a Remote Installation Server by
// checking for the existance of the "REMINST" share.
//
DWORD
VerifyServerName( )
{
    TraceFunc( "VerifyServerName( )\n" );

    NET_API_STATUS netStatus;
    SHARE_INFO_0 * psi;

    HCURSOR oldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

    netStatus = NetShareGetInfo( g_ServerName, L"REMINST", 0, (LPBYTE *) &psi );
    if ( netStatus == NERR_Success )
    {
        NetApiBufferFree( psi );
    }

    SetCursor( oldCursor );

    RETURN(netStatus);
}

BOOL
VerifyServerAccess(
    PCWSTR  ServerShareName,
    PCWSTR  ServerLanguage
    )
/*++

Routine Description:

    Checks permissions on the RIPREP server machine by trying to create a file on the
    server.  The temp file is then deleted.

Arguments:

    ServerShareName - path that we want to check permissions on.
    ServerLanguage  - indicates the language subdirectory to check for access in.
        

Return value:

    TRUE if the user has access to the server, FALSE otherwise.    

--*/
{
    TraceFunc( "VerifyServerAccess( )\n" );

    WCHAR FileName[MAX_PATH];
    WCHAR FilePath[MAX_PATH];
    BOOL RetVal;
    
    HCURSOR oldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

    wsprintf(FilePath, 
             L"\\\\%s\\reminst\\Setup\\%s\\Images",
             ServerShareName, 
             ServerLanguage );

    RetVal = GetTempFileName( FilePath , L"ACC", 0, FileName );
    if (RetVal) {
        //
        // delete the file, we don't want to leave turds on the server
        //
        DeleteFile(FileName);
        RetVal = TRUE;
    } else if (GetLastError() == ERROR_ACCESS_DENIED) {
        RetVal = FALSE;
    } else {
        //
        // GetTempFileName failed, but not because of an access problem, so
        // return success
        //
        RetVal = TRUE;
    }
    
    SetCursor( oldCursor );

    RETURN(RetVal);
}




//
// ServerDlgCheckNextButtonActivation( )
//
VOID
ServerDlgCheckNextButtonActivation(
    HWND hDlg )
{
    TraceFunc( "ServerDlgCheckNextButtonActivation( )\n" );
    WCHAR szName[ MAX_PATH ];
    GetDlgItemText( hDlg, IDC_E_SERVER, szName, ARRAYSIZE(szName));
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | (wcslen(szName) ? PSWIZB_NEXT : 0 ) );
    TraceFuncExit( );
}

//
// ServerDlgProc()
//
INT_PTR CALLBACK
ServerDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    ULARGE_INTEGER ImageVersion;
    WCHAR szTemp[ 1024 ];
    WCHAR szCaption[ 1024 ];
    WCHAR ErrorText[ 1024 ];
    DWORD dw;

    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        CenterDialog( GetParent( hDlg ) );
        return FALSE;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_SERVER:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                ServerDlgCheckNextButtonActivation( hDlg );
            }
            break;
        }
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            {
                GetDlgItemText( hDlg, IDC_E_SERVER, g_ServerName, ARRAYSIZE(g_ServerName) );

                //remove the wackwack if found
                if ( g_ServerName[0] == L'\\' && g_ServerName[1] == L'\\' )
                {
                    wcscpy( g_ServerName, &g_ServerName[2] );
                }

                Assert( wcslen( g_ServerName ) );
                DWORD dwErr = VerifyServerName( );
                if ( dwErr != ERROR_SUCCESS )
                {
                    switch (dwErr)
                    {
                    case NERR_NetNameNotFound:
                        MessageBoxFromStrings( hDlg, IDS_NOT_A_BINL_SERVER_TITLE, IDS_NOT_A_BINL_SERVER_TEXT, MB_OK );
                        break;

                    default:
                        dw = LoadString( g_hinstance, IDS_FAILED_TO_CONTACT_SERVER_TITLE, szTemp, ARRAYSIZE(szTemp) );
						Assert( dw );
                        MessageBoxFromError( hDlg, szTemp, dwErr, NULL, MB_OK );
                        break;
                    }
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                    break;
                }

                BOOL fFoundMatchingFlatImage = VerifyMatchingFlatImage( (PULONGLONG)&ImageVersion );
                if ( !fFoundMatchingFlatImage )
                {
                    dw = LoadString( g_hinstance, IDS_MISSING_BACKING_FLAT_IMAGE_TEXT, szTemp, ARRAYSIZE(szTemp) );
                    ASSERT(dw);

                    dw = LoadString( g_hinstance, IDS_MISSING_BACKING_FLAT_IMAGE_TITLE, szCaption, ARRAYSIZE(szCaption) );
                    ASSERT(dw);

                    wsprintf(
                        ErrorText, 
                        szTemp, 
                        HIWORD(ImageVersion.HighPart),
                        LOWORD(ImageVersion.HighPart),
                        HIWORD(ImageVersion.LowPart),
                        g_Language );

                    MessageBox( hDlg, ErrorText, szCaption, MB_OK );
                    
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                    break;
                }

                if (!VerifyServerAccess(g_ServerName,g_Language)) {
                    dw = LoadString( g_hinstance, IDS_SERVER_ACCESS_DESC, ErrorText, ARRAYSIZE(ErrorText) );
                    ASSERT(dw);

                    dw = LoadString( g_hinstance, IDS_SERVER_ACCESS, szCaption, ARRAYSIZE(szCaption) );
                    ASSERT(dw);

                    MessageBox( hDlg, ErrorText, szCaption, MB_OK );
                    
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                    break;
                }
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            SetDlgItemText( hDlg, IDC_E_SERVER, g_ServerName );
            ServerDlgCheckNextButtonActivation( hDlg );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\logging.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

 ***************************************************************************/

#include "pch.h"
DEFINE_MODULE("RIPREP")
#define LOG_OUTPUT_BUFFER_SIZE 256

//
// CreateDirectoryPath( )
//
// Creates the directory tree.
//
HRESULT
CreateDirectoryPath(
    LPWSTR DirectoryPath )
{
    PWCHAR p;
    BOOL f;
    DWORD attributes;
    HRESULT hr = S_OK;

    //
    // Find the \ that indicates the root directory. There should be at least
    // one \, but if there isn't, we just fall through.
    //

    // skip \\server\reminst\ part
    p = wcschr( DirectoryPath, L'\\' );
    Assert(p);
    p = wcschr( p + 1, L'\\' );
    Assert(p);
    p = wcschr( p + 1, L'\\' );
    Assert(p);
    p = wcschr( p + 1, L'\\' );
    Assert(p);
    p = wcschr( p + 1, L'\\' );
    if ( p != NULL ) {

        //
        // Find the \ that indicates the end of the first level directory. It's
        // probable that there won't be another \, in which case we just fall
        // through to creating the entire path.
        //

        p = wcschr( p + 1, L'\\' );
        while ( p != NULL ) {

            //
            // Terminate the directory path at the current level.
            //

            *p = 0;

            //
            // Create a directory at the current level.
            //

            attributes = GetFileAttributes( DirectoryPath );
            if ( 0xFFFFffff == attributes ) {
                DebugMsg( "Creating %s\n", DirectoryPath );
                f = CreateDirectory( DirectoryPath, NULL );
                if ( !f ) {
                    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                    goto Error;
                }
            } else if ( (attributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
                hr = THR(E_FAIL);
                goto Error;
            }

            //
            // Restore the \ and find the next one.
            //

            *p = L'\\';
            p = wcschr( p + 1, L'\\' );
        }
    }

    //
    // Create the target directory.
    //

    attributes = GetFileAttributes( DirectoryPath );
    if ( 0xFFFFffff == attributes ) {
        f = CreateDirectory( DirectoryPath, NULL );
        if ( !f ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }
    }

Error:
    return hr;
}

//
// LogOpen( )
//
// This function:
//  - initializes the log critical section
//  - enters the log critical section assuring only one thread is
//    writing to the log at a time
//  - creates the directory tree to the log file (if needed)
//  - initializes the log file by:
//     - creating a new log file if one doesn't exist.
//     - opens an existing log file (for append)
//     - appends a time/date stamp that the log was (re)openned.
//
// Use LogClose() to exit the log critical section.
//
// If there is a failure inside this function, the log critical
// section will be released before returning.
//
// Returns: S_OK - log critical section held and log open successfully
//          Otherwize HRESULT error code.
//
HRESULT
LogOpen( )
{
    TCHAR   szFilePath[ MAX_PATH ];
    CHAR    szBuffer[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HANDLE  hTemp;
    HRESULT hr;
    SYSTEMTIME SystemTime;
    BOOL    CloseLog = FALSE;

    if ( !g_pLogCritSect ) {
        PCRITICAL_SECTION pNewCritSect =
            (PCRITICAL_SECTION) LocalAlloc( LPTR, sizeof(CRITICAL_SECTION) );
        if ( !pNewCritSect ) {
            DebugMsg( "Out of Memory. Logging disabled.\n " );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        InitializeCriticalSection( pNewCritSect );

        // Make sure we only have one log critical section
        InterlockedCompareExchangePointer( (PVOID *)&g_pLogCritSect, pNewCritSect, 0 );
        if ( g_pLogCritSect != pNewCritSect ) {
            DebugMsg( "Another thread already created the CS. Deleting this one.\n ");
            DeleteCriticalSection( pNewCritSect );
            LocalFree( pNewCritSect );
        }
    }

    Assert( g_pLogCritSect );
    EnterCriticalSection( g_pLogCritSect );

    // Make sure the log file is open
    if ( g_hLogFile == INVALID_HANDLE_VALUE ) {

        if (!*g_ServerName) {
            wsprintf( 
                szFilePath, 
                L"%s\\%s", 
                g_WinntDirectory, 
                L"riprep.log");
            CloseLog = TRUE;
        } else {
        
            // Place
            wsprintf( szFilePath,
                      TEXT("\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s"),
                      g_ServerName,
                      g_Language,
                      REMOTE_INSTALL_IMAGE_DIR_W,
                      g_MirrorDir,
                      g_Architecture );
    
            // Create the directory tree
            DebugMsg( "Creating log at %s\n", szFilePath );
            hr = CreateDirectoryPath( szFilePath );
            if (FAILED( hr )) goto Error;
    
            wcscat( szFilePath, L"\\riprep.log" );

        }

        g_hLogFile = CreateFile( szFilePath,
                                 GENERIC_WRITE | GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_ALWAYS,
                                 NULL,
                                 NULL );
        if ( g_hLogFile == INVALID_HANDLE_VALUE ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            goto Error;
        }

        // Seek to the end
        SetFilePointer( g_hLogFile, 0, NULL, FILE_END );
        g_dwLogFileStartLow = GetFileSize( g_hLogFile, &g_dwLogFileStartHigh );

        // Write the time/date the log was (re)openned.
        GetLocalTime( &SystemTime );
        wsprintfA( szBuffer,
                   "*\r\n* %02u/%02u/%04u %02u:%02u:%02u\r\n*\r\n",
                   SystemTime.wMonth,
                   SystemTime.wDay,
                   SystemTime.wYear,
                   SystemTime.wHour,
                   SystemTime.wMinute,
                   SystemTime.wSecond );

        if ( !WriteFile( g_hLogFile, szBuffer, lstrlenA(szBuffer), &dwWritten, NULL ) ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            goto Error;
        }
    }

    hr = S_OK;

Cleanup:
    if (CloseLog) {
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
    return hr;
Error:
    DebugMsg( "LogOpen: Failed hr = 0x%08x\n", hr );
    if ( g_hLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
    LeaveCriticalSection( g_pLogCritSect );
    goto Cleanup;
}

//
// LogClose( )
//
// This actually just leaves the log critical section.
//
HRESULT
LogClose( )
{
    Assert( g_pLogCritSect );
    LeaveCriticalSection( g_pLogCritSect );
    return S_OK;
}


//
// LogMsg()
//
void
LogMsg(
    LPCSTR pszFormat,
    ... )
{
    va_list valist;
    CHAR   szBuf[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD  dwWritten;

#ifdef UNICODE
    WCHAR  szFormat[ LOG_OUTPUT_BUFFER_SIZE ];
    WCHAR  szTmpBuf[ LOG_OUTPUT_BUFFER_SIZE ];

    mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, szFormat, valist);
    va_end( valist );

    wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

    if ( LogOpen( ) ) {
        return;
    }

    WriteFile( g_hLogFile, szBuf, lstrlenA(szBuf), &dwWritten, NULL );

    LogClose( );
}

//
// LogMsg()
//
void
LogMsg(
    LPCWSTR pszFormat,
    ... )
{
    va_list valist;
    CHAR   szBuf[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD  dwWritten;

#ifdef UNICODE
    WCHAR  szTmpBuf[ LOG_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, pszFormat, valist);
    va_end( valist );

    wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
#else
    CHAR szFormat[ LOG_OUTPUT_BUFFER_SIZE ];

    wcstombs( szFormat, pszFormat, wcslen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );

#endif // UNICODE

    if ( LogOpen( ) ) {
        return;
    }

    WriteFile( g_hLogFile, szBuf, lstrlenA(szBuf), &dwWritten, NULL );

    LogClose( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\serverdlg.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.H


 ***************************************************************************/

#ifndef _SERVERDLG_H_
#define _SERVERDLG_H_

INT_PTR CALLBACK
ServerDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _SERVERDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\main.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

 ***************************************************************************/

#include "pch.h"
#include "utils.h"
#include "callback.h"
#include "welcome.h"
#include "compat.h"
#include "serverdlg.h"
#include "directory.h"
#include "sif.h"
#include "complete.h"
#include "summary.h"
#include "tasks.h"
#include "setupdlg.h"
#include "appldlg.h"
#include "setup.h"
#include "errorlog.h"

// Must have this...
extern "C" {
#include <sysprep_.h>
#include <spapip.h>
//
// SYSPREP globals
//
BOOL    NoSidGen = FALSE;   // always generate new SID
BOOL    PnP      = FALSE;   // always PNP the system
BOOL    FactoryPreinstall = FALSE;  // NOT a Factory Pre-Install case
BOOL    bMiniSetup = TRUE;    // Run Mini-Setup, not MSOOBE
HINSTANCE ghInstance = NULL;     // Global instance handle
}

DEFINE_MODULE("RIPREP");

// Globals
HINSTANCE g_hinstance = NULL;
WCHAR g_ServerName[ MAX_PATH ];
WCHAR g_MirrorDir[ MAX_PATH ];
WCHAR g_Language[ MAX_PATH ];
WCHAR g_ImageName[ MAX_PATH ];
WCHAR g_Architecture[ 16 ];
WCHAR g_Description[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT  ];
WCHAR g_HelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ];
WCHAR g_SystemRoot[ MAX_PATH ] = L"Mirror1\\userdata\\winnt";
WCHAR g_WinntDirectory[ MAX_PATH ];
WCHAR g_HalName[32];
WCHAR g_ProductId[4];
DWORD g_dwWinntDirLength;
BOOLEAN g_fQuietFlag = FALSE;
BOOLEAN g_fErrorOccurred = FALSE;
BOOLEAN g_fRebootOnExit = FALSE;
DWORD g_dwLogFileStartLow;
DWORD g_dwLogFileStartHigh;
PCRITICAL_SECTION g_pLogCritSect = NULL;
HANDLE g_hLogFile = INVALID_HANDLE_VALUE;
OSVERSIONINFO OsVersion;
BOOLEAN g_CommandLineArgsValid = TRUE;
BOOLEAN g_OEMDesktop = FALSE;


// Constants
#define NUMBER_OF_PAGES     15
#define SMALL_BUFFER_SIZE   256
#define OPTION_UNKNOWN      0
#define OPTION_DEBUG        1
#define OPTION_FUNC         2
#define OPTION_QUIET        3
#define OPTION_PNP          4
#define OPTION_OEMDESKTOP   5

//
// Adds a page to the dialog.
//
void
AddPage(
    LPPROPSHEETHEADER ppsh,
    UINT id,
    DLGPROC pfn,
    UINT idTitle,
    UINT idSubtitle )
{
    PROPSHEETPAGE psp;
    TCHAR szTitle[ SMALL_BUFFER_SIZE ];
    TCHAR szSubTitle[ SMALL_BUFFER_SIZE ];

    ZeroMemory( &psp, sizeof(psp) );
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
    if ( id == IDD_WELCOME || id == IDD_COMPLETE )
    {
        psp.dwFlags |= PSP_HIDEHEADER;
    }
    else
    {
        psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

        if ( idTitle )
        {
            DWORD dw;

            dw = LoadString( g_hinstance, idTitle, szTitle, ARRAYSIZE(szTitle) );
            Assert( dw );
            psp.pszHeaderTitle = szTitle;
        }
        else
        {
            psp.pszHeaderTitle = NULL;
        }

        if ( idSubtitle )
        {
            DWORD dw;

            dw = LoadString( g_hinstance, idSubtitle , szSubTitle, ARRAYSIZE(szSubTitle) );
            Assert( dw );
            psp.pszHeaderSubTitle = szSubTitle;
        }
        else
        {
            psp.pszHeaderSubTitle = NULL;
        }
    }
    psp.pszTitle    = MAKEINTRESOURCE( IDS_APPNAME );
    psp.hInstance   = ppsh->hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(id);
    psp.pfnDlgProc  = pfn;

    ppsh->phpage[ ppsh->nPages ] = CreatePropertySheetPage( &psp );
    if ( ppsh->phpage[ ppsh->nPages ] )
        ppsh->nPages++;
}

//
// Creates the UI pages and kicks off the property sheet.
//
HRESULT
WizardPages( )
{
    TraceFunc( "WizardPages( )\n" );

    HRESULT         hr;
    HPROPSHEETPAGE  rPages[ NUMBER_OF_PAGES ];
    PROPSHEETHEADER pshead;
    INT_PTR iResult;

    ZeroMemory( &pshead, sizeof(pshead) );
    pshead.dwSize       = sizeof(pshead);
    pshead.dwFlags      = PSH_WIZARD97 | PSH_PROPTITLE | PSH_USEHICON
                        | PSH_WATERMARK | PSH_HEADER;
    pshead.hInstance    = g_hinstance;
    pshead.pszCaption   = MAKEINTRESOURCE( IDS_APPNAME );
    pshead.phpage       = rPages;
    pshead.pszbmWatermark = MAKEINTRESOURCE( IDB_TITLEPAGE );
    pshead.pszbmHeader  = MAKEINTRESOURCE( IDB_HEADER );


    AddPage( &pshead, IDD_WELCOME,          WelcomeDlgProc,   0, 0 );
    AddPage( &pshead, IDD_SERVER,           ServerDlgProc,    IDS_SERVER_TITLE,    IDS_SERVER_SUBTITLE );
    AddPage( &pshead, IDD_OSDIRECTORY,      DirectoryDlgProc, IDS_DIRECTORY_TITLE, IDS_DIRECTORY_SUBTITLE );
    AddPage( &pshead, IDD_DEFAULTSIF,       SIFDlgProc,       IDS_SIF_TITLE,       IDS_SIF_SUBTITLE );
    AddPage( &pshead, IDD_COMPAT,           CompatibilityDlgProc,    IDS_COMPAT_TITLE,    IDS_COMPAT_SUBTITLE );
    AddPage( &pshead, IDD_STOPSVCWRN,       StopServiceWrnDlgProc,  IDS_STOPSVC_TITLE, IDS_STOPSVC_SUBTITLE );
    AddPage( &pshead, IDD_STOPSVC,          DoStopServiceDlgProc,  IDS_STOPSVC_TITLE, IDS_STOPSVC_SUBTITLE );
    AddPage( &pshead, IDD_APPLICATIONS_RUNNING, ApplicationDlgProc,    IDS_APPLICATION_TITLE,    IDS_APPLICATION_SUBTITLE );
    AddPage( &pshead, IDD_SUMMARY,          SummaryDlgProc,    IDS_FINISH_TITLE,    IDS_FINISH_SUBTITLE );
    AddPage( &pshead, IDD_COMPLETE,         CompleteDlgProc,    0,    0 );

    iResult = PropertySheet( &pshead );
    switch(iResult)
    {
    case 0:
        hr = E_FAIL;
        break;

    default:
        hr = S_OK;
        break;
    }

    RETURN(hr);
}

//
// IsWhiteSpace()
//
BOOL
IsWhiteSpace( WCHAR ch )
{
    if ( ch <=32 )
        return TRUE;

    return FALSE;
}

//
// CheckWhichOption()
DWORD
CheckWhichOption(
    LPWSTR pszOption )
{
    WCHAR szOptions[ 32 ];
    DWORD dw;

#ifdef DEBUG
    if ( StrCmpNI( pszOption, L"debug", 5 ) == 0 )
        return OPTION_DEBUG;
    if ( StrCmpNI( pszOption, L"func", 4 ) == 0 )
        return OPTION_FUNC;
#endif

    // Check for quiet flag
    dw = LoadString( g_hinstance, IDS_QUIET, szOptions, ARRAYSIZE( szOptions ) );
    Assert( dw );
    if ( StrCmpNI( pszOption, szOptions, wcslen(szOptions) ) == 0 )
        return OPTION_QUIET;

    if ( StrCmpNI( pszOption, L"PNP", 3 ) == 0 )
        return OPTION_PNP;

    //
    // By default, the Setup guys are going to remove all the desktop icons
    // during MiniSetup.  We'd like to keep those around for riprep installs,
    // so by default, we're going to set some registry keys to keep the
    // user's desktop around.  However, if the user gives us a -OEMDesktop flag,
    // then don't set these flags and allow the desktop to be cleaned up.
    //
    if( StrCmpNI( pszOption, L"OEMDesktop", 10 ) == 0 ) {
        return OPTION_OEMDESKTOP;
    }

    return OPTION_UNKNOWN;
}

//
// ParseCommandLine()
//
void
ParseCommandLine( LPWSTR lpCmdLine )
{
    WCHAR szPath[ MAX_PATH ];
    LPWSTR psz = NULL;
    BOOL endOfCommandLine;

    //
    // Check to see if the command line has the servername on it.
    //
    g_ServerName[0] = L'\0';
    if ( lpCmdLine[0] == L'\\' && lpCmdLine[1] == L'\\' )
    {
        psz = StrChr( &lpCmdLine[2], L'\\' );
        if ( psz && psz != &lpCmdLine[2] )
        {
            ZeroMemory( g_ServerName, sizeof(g_ServerName) );
            wcsncpy( g_ServerName, &lpCmdLine[2], (DWORD)(psz - &lpCmdLine[2]) );
        }
    }
    // See if it is a quoted path as well
    if ( lpCmdLine[0] == L'\"' && lpCmdLine[1] == L'\\' && lpCmdLine[2] == L'\\' )
    {
        psz = StrChr( &lpCmdLine[3], L'\\' );
        if ( psz && psz != &lpCmdLine[3] )
        {
            ZeroMemory( g_ServerName, sizeof(g_ServerName) );
            wcsncpy( g_ServerName, &lpCmdLine[3], (DWORD)(psz - &lpCmdLine[3]) );
        }
    }

    // See if there is a whitespace break
    psz = StrChr( lpCmdLine, L' ' );
    if ( psz )
    { // yes... search backwards from the whitespace for a slash.
        psz = StrRChr( lpCmdLine, psz, L'\\' );
    }
    else
    { // no... search backwards from the end of the command line for a slash.
        psz = StrRChr( lpCmdLine, &lpCmdLine[ wcslen( lpCmdLine ) ], L'\\' );
    }

    // Found the starting path, now try to set the current directory
    // to this.
    if ( psz )
    {
        ZeroMemory( szPath, sizeof(szPath) );
        wcsncpy( szPath, lpCmdLine, (DWORD)(psz - lpCmdLine) );

        // If quoted, add a trailing quote to the path
        if ( lpCmdLine[0] == L'\"' ) {
            wcscat( szPath, L"\"" );
        }

        DebugMsg( "Set CD to %s\n", szPath );
        SetCurrentDirectory( szPath );
    }

    // Parse for command line arguments
    if (!psz) {
        psz = lpCmdLine;
    }
    endOfCommandLine = FALSE;
    while (!endOfCommandLine && (*psz != L'\0'))
    {
        if ( *psz == '/' || *psz == '-' )
        {
            LPWSTR pszStartOption = ++psz;

            while (*psz && !IsWhiteSpace( *psz ) )
                psz++;

            if (*psz == L'\0') {
                endOfCommandLine = TRUE;
            } else {
                *psz = '\0';    // terminate
            }

            switch ( CheckWhichOption( pszStartOption ) )
            {
#ifdef DEBUG
            case OPTION_DEBUG:
                g_dwTraceFlags |= 0x80000000;    // not defined, but not zero either
                break;
            case OPTION_FUNC:
                g_dwTraceFlags |= TF_FUNC;
                break;
#endif
            case OPTION_QUIET:
                g_fQuietFlag = TRUE;
                break;

            case OPTION_PNP:
                PnP = !PnP; // toggle
                break;

            case OPTION_OEMDESKTOP:
                g_OEMDesktop = TRUE;  // The user want to clean the desktop.
                break;

            case OPTION_UNKNOWN:
                
                MessageBoxFromMessage( 
                            NULL, 
                            MSG_USAGE, 
                            FALSE, 
                            MAKEINTRESOURCE(IDS_APPNAME),
                            MB_OK );

                g_CommandLineArgsValid = FALSE;

            }
        }

        psz++;
    }
}

//
// GetWorkstationLanguage( )
//
DWORD
GetWorkstationLanguage( )
{
    TraceFunc( "GetWorkstationLanguage( )\n" );

    DWORD dwErr = ERROR_SUCCESS;
    LANGID langID = GetSystemDefaultLangID( );
    UINT uResult = GetLocaleInfo( langID, LOCALE_SENGLANGUAGE, g_Language, ARRAYSIZE(g_Language) );
    if ( uResult == 0 )
    {
        DWORD dw;
        dwErr = GetLastError( );
        dw = LoadString( g_hinstance, IDS_DEFAULT_LANGUAGE, g_Language, ARRAYSIZE(g_Language));
        Assert( dw );
    }

    RETURN(dwErr);
}


BOOLEAN
GetInstalledProductType( 
    PDWORD Type, 
    PDWORD Mask );

//
// GetProductSKUNumber
//
DWORD
GetProductSKUNumber(
    VOID
    )
/*++

Routine Description:

    Determine SKU number of installation, which should match the
    producttype value in txtsetup.sif
    
Arguments:

    none.

Return value:

    product sku number.  if it fails, we set the return value to 0, which
    is the sku code for professional.

--*/
{
    TraceFunc( "GetProductSKUNumber( )\n" );

    DWORD ProductType, ProductSuiteMask;

    if (!GetInstalledProductType( &ProductType, &ProductSuiteMask )) {
        return 0;
    }

    if (ProductType == VER_NT_SERVER) {
        if (ProductSuiteMask & VER_SUITE_DATACENTER) {
            return 3;
        }

        if (ProductSuiteMask & VER_SUITE_ENTERPRISE) {
            return 2;
        }

        return 1;
    }

    if (ProductSuiteMask & VER_SUITE_PERSONAL) {
        return 4;
    }

    return 0;
    
}



//
// GetHalName( )
//
DWORD
GetHalName(
    VOID
    )
/*++

Routine Description:

    Determine the actual name of the HAL running on the system.
    
    The actual name of the hal is stored in the originalfilename 
    in the version resource. 

Arguments:

    none.

Return value:

    Win32 error code indicating outcome.    

--*/
{
    TraceFunc( "GetHalName( )\n" );

    DWORD dwErr = ERROR_GEN_FAILURE;
    WCHAR HalPath[MAX_PATH];
    DWORD VersionHandle;
    DWORD FileVersionInfoSize;
    PVOID VersionInfo = NULL;
    DWORD *Language,LanguageSize;
    WCHAR OriginalFileNameString[64];
    PWSTR ActualHalName;    


    //
    // the hal is in system32 directory, build a path to it.
    //
    if (!GetSystemDirectory(HalPath,ARRAYSIZE(HalPath))) {
        dwErr = GetLastError();
        goto exit;
    }
        
    wcscat(HalPath, L"\\hal.dll" );

    //
    // you must call GetFileVersionInfoSize,GetFileVersionInfo before
    // you can call VerQueryValue()
    //
    FileVersionInfoSize = GetFileVersionInfoSize(HalPath, &VersionHandle);
    if (FileVersionInfoSize == 0) {
        goto exit;
    }
    
    VersionInfo = LocalAlloc( LPTR, FileVersionInfoSize );
    if (VersionInfo == NULL) {
        goto exit;
    }

    if (!GetFileVersionInfo(
                        HalPath,
                        0, //ignored
                        FileVersionInfoSize,
                        VersionInfo)) {
        goto exit;
    }

    //
    // ok, get the language of the file so we can look in the correct
    // StringFileInfo section for the file name
    //
    if (!VerQueryValue(
            VersionInfo, 
            L"\\VarFileInfo\\Translation",
            (LPVOID*)&Language,
            (PUINT)&LanguageSize)) {
        goto exit;
    }

    wsprintf( 
        OriginalFileNameString,
        L"\\StringFileInfo\\%04x%04x\\OriginalFilename",
        LOWORD(*Language),
        HIWORD(*Language));

    //
    // now retreive the actual OriginalFilename.
    //
    if (!VerQueryValue(
             VersionInfo,
             OriginalFileNameString,
             (LPVOID*)&ActualHalName,
             (PUINT)&LanguageSize)) {
        goto exit;
    }

    //
    // store this off in a global so we can use it later on
    //
    wcscpy(g_HalName ,ActualHalName);

    dwErr = ERROR_SUCCESS;
    
exit:
    if (VersionInfo) {
        LocalFree( VersionInfo );
    }
    RETURN(dwErr);
}

//
// VerifyWorkstation( )
//
BOOL
VerifyWorkstation( )
{
    TraceFunc( "VerifyWorkstation( )\n" );

    HKEY  hkey;
    LONG  lResult;
    WCHAR szProductType[50] = { 0 };
    DWORD dwType;
    DWORD dwSize  = ARRAYSIZE(szProductType);
    BOOL  fReturn = TRUE; // assume that we are not on NTServer.

    // Query the registry for the product type.
    lResult = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                             L"System\\CurrentControlSet\\Control\\ProductOptions",
                             0,
                             KEY_READ,
                             &hkey);
    Assert( lResult == ERROR_SUCCESS );
    if ( lResult != ERROR_SUCCESS )
        goto Error;

    lResult = RegQueryValueEx ( hkey,
                                L"ProductType",
                                NULL,
                                &dwType,
                                (LPBYTE) szProductType,
                                &dwSize);
    Assert( lResult == ERROR_SUCCESS );
    RegCloseKey (hkey);
    if (lResult != ERROR_SUCCESS)
        goto Error;

    if ( StrCmpI( szProductType, L"ServerNT" ) == 0 )
    {
        fReturn = FALSE; // NT Server
    }

    if ( StrCmpI( szProductType, L"LanmanNT" ) == 0 )
    {
        fReturn = FALSE; // NT Server
    }

Error:
    RETURN(fReturn);
}


//
// CheckUserPermissions( )
//
BOOL
CheckUserPermissions( )
{
    TraceFunc( "CheckUserPermissions( )\n" );
    if( !pSetupIsUserAdmin()
     || !pSetupDoesUserHavePrivilege(SE_SHUTDOWN_NAME)
     || !pSetupDoesUserHavePrivilege(SE_BACKUP_NAME)
     || !pSetupDoesUserHavePrivilege(SE_RESTORE_NAME)
     || !pSetupDoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME)) {
        RETURN(FALSE);
    }
    RETURN(TRUE);
}


//
// GetProcessorType( )
//
DWORD
GetProcessorType( )
{
    TraceFunc( "GetProcessorType( )\n" );

    DWORD dwErr = ERROR_INVALID_PARAMETER;
    SYSTEM_INFO si;

    GetSystemInfo( &si );
    switch (si.wProcessorArchitecture)
    {
        case PROCESSOR_ARCHITECTURE_ALPHA:
            wcscpy( g_Architecture, L"Alpha" );
            break;

        case PROCESSOR_ARCHITECTURE_INTEL:
            dwErr = ERROR_SUCCESS;
            wcscpy( g_Architecture, L"i386" );
            break;
        case PROCESSOR_ARCHITECTURE_IA64:
            //dwErr = ERROR_SUCCESS;
            wcscpy( g_Architecture, L"ia64" );
            break;
        case PROCESSOR_ARCHITECTURE_UNKNOWN:
        default:
            break;
    }

    RETURN(dwErr);
}

//
// WinMain()
//
int APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    TraceFunc( "WinMain( ... )\n" );

    HANDLE  hMutex;
    HRESULT hr = E_FAIL;
    IMIRROR_CALLBACK Callbacks;
    HWND hwndTasks = NULL;
    LPWSTR pszCommandLine = GetCommandLine( );
    BOOL fDC = FALSE;

    g_hinstance = hInstance;
    ghInstance  = hInstance;

    INITIALIZE_TRACE_MEMORY_PROCESS;

    pSetupInitializeUtils();

    // allow only one instance running at a time
    hMutex = CreateMutex( NULL, TRUE, L"RIPREP.Mutext");
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        MessageBoxFromStrings( NULL,
                               IDS_ALREADY_RUNNING_TITLE,
                               IDS_ALREADY_RUNNING_MESSAGE,
                               MB_OK | MB_ICONSTOP );
        goto Cleanup;
    }

    // parse command line arguments
    ParseCommandLine( pszCommandLine );
    if (!g_CommandLineArgsValid) {
        goto Cleanup;
    }

    //
    // Gather os version info.
    //
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersion);

    // determine the language of the workstation
    GetWorkstationLanguage( );

    if (ERROR_SUCCESS != GetHalName()) {
        MessageBoxFromStrings( NULL, IDS_INVALID_ARCHITECTURE_TITLE, IDS_INVALID_ARCHITECTURE_TEXT, MB_OK );
        goto Cleanup;
    }

    wsprintf( g_ProductId, L"%d", GetProductSKUNumber() );

    ProcessCompatibilityData();

    // determine the processor type
    if ( GetProcessorType( ) != ERROR_SUCCESS )
    {
        MessageBoxFromStrings( NULL, IDS_INVALID_ARCHITECTURE_TITLE, IDS_INVALID_ARCHITECTURE_TEXT, MB_OK );
        goto Cleanup;
    }

    if ( !CheckUserPermissions( ) )
    {
        MessageBoxFromStrings( NULL, IDS_MUST_BE_ADMINISTRATOR_TITLE, IDS_MUST_BE_ADMINISTRATOR_TEXT, MB_OK );
        goto Cleanup;
    }

#if 0
    //
    // No longer limited to only workstation - adamba 4/6/00
    //
    if ( !VerifyWorkstation( ) )
    {
        MessageBoxFromStrings( NULL, IDS_MUST_BE_WORKSTATION_TITLE, IDS_MUST_BE_WORKSTATION_TEXT, MB_OK );
        goto Cleanup;
    }


#endif
    // get the name of the "Winnt" directory
    GetEnvironmentVariable( L"windir", g_WinntDirectory, ARRAYSIZE(g_WinntDirectory));
    g_dwWinntDirLength = wcslen( g_WinntDirectory );

    // setup IMIRROR.DLL callbacks
    Callbacks.Context           = 0;
    Callbacks.ErrorFn           = &ConvTestErrorFn;
    Callbacks.GetSetupFn        = &ConvTestGetSetupFn;
    Callbacks.NowDoingFn        = &ConvTestNowDoingFn;
    Callbacks.FileCreateFn      = &ConvTestFileCreateFn;
    Callbacks.RegSaveErrorFn    = NULL;
    Callbacks.ReinitFn          = &ConvTestReinitFn;
    Callbacks.GetMirrorDirFn    = &ConvTestGetMirrorDirFn;
    Callbacks.SetSystemDirFn    = &ConvTestSetSystemFn;
    Callbacks.AddToDoFn         = &ConvAddToDoItemFn;
    Callbacks.RemoveToDoFn      = &ConvRemoveToDoItemFn;
    Callbacks.RebootFn          = &ConvRebootFn;
    IMirrorInitCallback(&Callbacks);

    // show property pages
    hr = WizardPages( );

    if ( hr != S_OK )
        goto Cleanup;

    // complete tasks... ignore the return code, not important
    BeginProcess( hwndTasks );

    // Display any errors recorded in the log, unless we are supposed
    // to reboot now.
    if ( g_fErrorOccurred && !g_fRebootOnExit )
    {
        HINSTANCE hRichedDLL;

        // Make sure the RichEdit control has been initialized.
        // Simply LoadLibbing it does this for us.
        hRichedDLL = LoadLibrary( L"RICHED32.DLL" );
        if ( hRichedDLL != NULL )
        {
            DialogBox( g_hinstance, MAKEINTRESOURCE( IDD_VIEWERRORS ), g_hMainWindow, ErrorsDlgProc );
            FreeLibrary (hRichedDLL);
        }
    }

Cleanup:
    
    if (g_hCompatibilityInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile( g_hCompatibilityInf );
    }

    CleanupCompatibilityData();

    if ( hMutex )
        CloseHandle( hMutex );

    pSetupUninitializeUtils();

    UNINITIALIZE_TRACE_MEMORY;

    if ( g_fRebootOnExit ) {
        (VOID)DoShutdown(TRUE);   // TRUE tells it to restart
    }

    RETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\rsrcutil.cpp ===
#include "pch.h"
#pragma hdrstop

#include "utils.h"

DEFINE_MODULE( "RIPREP" )

INT
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN LPCTSTR  CaptionString,
    IN UINT     Style,
    IN va_list *Args
    )
{
    TCHAR Caption[512];
    TCHAR Buffer[5000];

    if((DWORD_PTR)CaptionString > 0xffff) {
        //
        // It's a string already.
        //
        lstrcpyn(Caption,CaptionString, ARRAYSIZE(Caption));
    } else {
        //
        // It's a string id
        //
        if(!LoadString(g_hinstance,PtrToUlong(CaptionString),Caption, ARRAYSIZE(Caption))) {
            Caption[0] = 0;
        }
    }

    FormatMessage(
        SystemMessage ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MessageId,
        0,
        Buffer,
        ARRAYSIZE(Buffer),
        Args
        );

    return(MessageBox(Window,Buffer,Caption,Style));
}


INT
MessageBoxFromMessage(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN BOOL    SystemMessage,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    )
{
    va_list arglist;
    INT i;

    va_start(arglist,Style);

    i = MessageBoxFromMessageV(Window,MessageId,SystemMessage,CaptionString,Style,&arglist);

    va_end(arglist);

    return(i);
}


INT
MessageBoxFromMessageAndSystemError(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN DWORD   SystemMessageId,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    )
{
    va_list arglist;
    TCHAR Caption[512];
    TCHAR Buffer1[1024];
    TCHAR Buffer2[1024];
    INT i;

    //
    // Fetch the non-system part. The arguments are for that part of the
    // message -- the system part has no inserts.
    //
    va_start(arglist,Style);

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MessageId,
        0,
        Buffer1,
        ARRAYSIZE(Buffer1),
        &arglist
        );

    va_end(arglist);

    //
    // Now fetch the system part.
    //
    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        MessageId,
        0,
        Buffer2,
        ARRAYSIZE(Buffer2),
        &arglist
        );

    //
    // Now display the message, which is made up of two parts that get
    // inserted into MSG_ERROR_WITH_SYSTEM_ERROR.
    //
    i = MessageBoxFromMessage(
            Window,
            MSG_ERROR_WITH_SYSTEM_ERROR,
            FALSE,
            CaptionString,
            Style,
            Buffer1,
            Buffer2
            );

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\setup.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SETUP.CPP

 ***************************************************************************/

#include "pch.h"
#include "utils.h"
#include "logging.h"
#include "errorlog.h"
#include "tasks.h"

DEFINE_MODULE("RIPREP")

//
// EndProcess( )
//
HRESULT
EndProcess( 
    HWND hDlg )
{
    TraceFunc( "EndProcess( )\n" );
    HRESULT hr = S_OK;
    WCHAR szSrcPath[ MAX_PATH ];
    WCHAR szDestPath[ MAX_PATH ];
    WCHAR szMajor[ 10 ];
    WCHAR szMinor[ 10 ];
    WCHAR szBuild[ 10 ];
    OSVERSIONINFO osver;
    BOOL b;
    DWORD dw;

    wsprintf( szDestPath, 
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates", 
              g_ServerName, 
              g_Language, 
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );
    CreateDirectory( szDestPath, NULL );

    wsprintf( szSrcPath, L"%s\\templates\\startrom.com", g_ImageName );
    wsprintf( szDestPath, 
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates\\startrom.com", 
              g_ServerName, 
              g_Language, 
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );
    b = CopyFile( szSrcPath, szDestPath, FALSE );
    if ( !b )
    {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"STARTROM.COM";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( hDlg, WM_ERROR_OK, 0, (LPARAM) &item );
    }

    wsprintf( szSrcPath, L"%s\\templates\\ntdetect.com", g_ImageName );
    wsprintf( szDestPath, 
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates\\ntdetect.com", 
              g_ServerName, 
              g_Language, 
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );
    b = CopyFile( szSrcPath, szDestPath, FALSE );
    if ( !b )
    {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"NTDETECT.COM";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( hDlg, WM_ERROR_OK, 0, (LPARAM) &item );
    }

    wsprintf( szSrcPath, L"%s\\templates\\ntldr", g_ImageName );
    wsprintf( szDestPath, 
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates\\ntldr", 
              g_ServerName, 
              g_Language,
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );
    b = CopyFile( szSrcPath, szDestPath, FALSE );
    if ( !b )
    {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"NTLDR";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( hDlg, WM_ERROR_OK, 0, (LPARAM) &item );
    }

    wsprintf( szMajor, L"%u", OsVersion.dwMajorVersion );
    wsprintf( szMinor, L"%u", OsVersion.dwMinorVersion );
    wsprintf( szBuild, L"%u", OsVersion.dwBuildNumber  );    

    //
    // Need to add "Quotes" around the text
    //
    WCHAR szDescription[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT  + 2 ];
    WCHAR szHelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT  + 2 ];
    WCHAR szOSVersion[ 30 ];
    WCHAR szSystemRoot[ MAX_PATH ];

    wsprintf( szDescription, L"\"%s\"", g_Description );
    wsprintf( szHelpText, L"\"%s\"", g_HelpText );
    wsprintf( szOSVersion, L"\"%s.%s (%s)\"", szMajor, szMinor, szBuild );
    wsprintf( szSystemRoot, L"\"%s\"", g_SystemRoot );
    wsprintf( szDestPath, 
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates\\riprep.sif", 
              g_ServerName, 
              g_Language,
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );

    wsprintf( szSrcPath, L"%s\\ristndrd.sif", g_ImageName );
    b = CopyFile( szSrcPath, szDestPath, FALSE );
    if ( !b )
    {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"RISTNDRD.SIF";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( hDlg, WM_ERROR_OK, 0, (LPARAM) &item );
    }

    WritePrivateProfileString( L"OSChooser",
                               L"Description",
                               szDescription,
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"Help",
                               szHelpText,
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"ImageType",
                               L"SYSPREP",
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"Version",
                               szOSVersion,
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"SysPrepSystemRoot",
                               szSystemRoot,
                               szDestPath );

    WritePrivateProfileString( L"SetupData",
                               L"SysPrepDevice",
                               L"\"\\Device\\LanmanRedirector\\%SERVERNAME%\\RemInst\\%SYSPREPPATH%\"",
                               szDestPath );

    WritePrivateProfileString( L"SetupData",
                               L"SysPrepDriversDevice",
                               L"\"\\Device\\LanmanRedirector\\%SERVERNAME%\\RemInst\\%SYSPREPDRIVERS%\"",
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"LaunchFile",
                               L"\"%INSTALLPATH%\\%MACHINETYPE%\\templates\\startrom.com\"",
                               szDestPath );

//  WritePrivateProfileString( L"SetupData",
//                             L"OsLoadOptions",
//                             L"\"/noguiboot /fastdetect\"",
//                             szDestPath );

    WritePrivateProfileString( L"SetupData",
                               L"SetupSourceDevice",
                               L"\"\\Device\\LanmanRedirector\\%SERVERNAME%\\RemInst\\%INSTALLPATH%\"",
                               szDestPath );

    WritePrivateProfileString( L"UserData",
                               L"ComputerName",
                               L"\"%MACHINENAME%\"",
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"HalName",
                               g_HalName,
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"ProductType",
                               g_ProductId,
                               szDestPath );


    // End the log
    dw = LoadString( g_hinstance, IDS_END_LOG, szSrcPath, ARRAYSIZE( szSrcPath ));
    Assert( dw );
    LogMsg( szSrcPath );
    
    // Display any errors recorded in the log
    if ( g_fErrorOccurred ) 
    {
        HINSTANCE hRichedDLL;

        // Make sure the RichEdit control has been initialized.
        // Simply LoadLibbing it does this for us.
        hRichedDLL = LoadLibrary( L"RICHED32.DLL" );
        if ( hRichedDLL != NULL )
        {
            DialogBox( g_hinstance, MAKEINTRESOURCE( IDD_VIEWERRORS ), hDlg, ErrorsDlgProc );
            FreeLibrary (hRichedDLL);
        }
    }

    RETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\setup.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SETUP.H

 ***************************************************************************/

#ifndef _SETUP_H_
#define _SETUP_H_

HRESULT
EndProcess( 
    HWND hDlg );

#endif // _SETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\sif.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.H


 ***************************************************************************/

#ifndef _SIF_H_
#define _SIF_H_

INT_PTR CALLBACK
SIFDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _SIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\summary.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SUMMARY.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"

//
// SummaryDlgProc()
//
INT_PTR CALLBACK
SummaryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetDialogFont( hDlg, IDC_TITLE, DlgFontTitle );
        break;

    default:
        return FALSE;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            SetDlgItemText( hDlg, IDC_S_SERVERNAME, g_ServerName );
            SetDlgItemText( hDlg, IDC_S_DIRECTORY, g_MirrorDir );
            SetDlgItemText( hDlg, IDC_E_DESCRIPTION, g_Description );
            SetDlgItemText( hDlg, IDC_E_HELPTEXT, g_HelpText );
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\sysprep.c ===
/*++

File Description:

    This file contains all the functions required to add a registry entry
    to force execution of the system clone worker upon reboot.

--*/

#include <sysprep_.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\setupdlg.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SETUPDLG.H


 ***************************************************************************/

#ifndef _SETUPDLG_H_
#define _SETUPDLG_H_

INT_PTR CALLBACK
SetupPathDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _SETUPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\sif.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include <remboot.h>
#include "callback.h"
#include "utils.h"

DEFINE_MODULE( "RIPREP" )

WNDPROC g_pOldEditWndProc;

//
// VerifySIFField( )
//
// Make sure that the directory name entered conforms to the
// restrictions that OSChooser has.
//
// Returns: S_OK if it does
//          E_FAIL if it does not
//
HRESULT
VerifySIFField(
    LPWSTR pszField
    )
{
    HRESULT hr = S_OK;

    TraceFunc( "VerifySIFField()\n" );

    while ( *pszField >= 32 && *pszField <= 127 )
    {
        pszField++;
    }

    if ( *pszField != L'\0' )
    {
        hr = E_FAIL;
    }

    HRETURN(hr);
}

//
// SIFDlgCheckNextButtonActivation( )
//
VOID
SIFDlgCheckNextButtonActivation(
    HWND hDlg )
{
    TraceFunc( "SIFDlgCheckNextButtonActivation( )\n" );
    GetDlgItemText( hDlg, IDC_E_DESCRIPTION, g_Description, ARRAYSIZE(g_Description));
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | (wcslen(g_Description) ? PSWIZB_NEXT : 0 ) );
    TraceFuncExit( );
}

//
// HelpTextEditWndProc( )
//
LRESULT CALLBACK
HelpTextEditWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch ( uMsg )
    {
    case WM_KEYDOWN:
        // fake button presses
        if ( LOWORD( wParam ) == VK_RETURN ) {
            PropSheet_PressButton( GetParent( GetParent( hWnd ) ), PSBTN_NEXT );
            return FALSE;
        } else if ( LOWORD( wParam ) == VK_ESCAPE ) {
            PropSheet_PressButton( GetParent( GetParent( hWnd ) ), PSBTN_CANCEL );
            return FALSE;
        }
        break;
    }

    return CallWindowProc(g_pOldEditWndProc, hWnd, uMsg, wParam, lParam);
}

//
// SIFDlgProc()
//
INT_PTR CALLBACK
SIFDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_DESCRIPTION ), ARRAYSIZE(g_Description) - 1 );
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_HELPTEXT ), ARRAYSIZE(g_HelpText) - 1 );
        g_pOldEditWndProc = (WNDPROC) SetWindowLongPtr( GetDlgItem( hDlg, IDC_E_HELPTEXT), GWLP_WNDPROC, (LONG_PTR)&HelpTextEditWndProc);
        SetWindowLongPtr( GetDlgItem( hDlg, IDC_E_HELPTEXT), GWLP_WNDPROC, (LONG_PTR)&HelpTextEditWndProc);
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_DESCRIPTION:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                SIFDlgCheckNextButtonActivation( hDlg );
            }
            break;
        }
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            GetDlgItemText( hDlg, IDC_E_DESCRIPTION, g_Description, ARRAYSIZE(g_Description) );
            Assert( wcslen( g_Description ) );
            GetDlgItemText( hDlg, IDC_E_HELPTEXT, g_HelpText, ARRAYSIZE(g_HelpText) );
            if ( FAILED( VerifySIFField( g_Description ) ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE, IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT, MB_OK );
                SetFocus( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                break;
            }
            if ( FAILED( VerifySIFField( g_HelpText ) ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE, IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT, MB_OK );
                SetFocus( GetDlgItem( hDlg, IDC_E_HELPTEXT ) );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                break;
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            SIFDlgCheckNextButtonActivation( hDlg );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\summary.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SUMMARY.H


 ***************************************************************************/

#ifndef _SUMMARY_H_
#define _SUMMARY_H_

INT_PTR CALLBACK
SummaryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _SUMMARY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\setupdlg.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SETUPDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"

DEFINE_MODULE( "RIPREP" )

//
// DetermineSetupPath( )
//
// Try to figure out if the server selected is the same server
// that this client computer was installed from. If so, make the
// assumption that he'll choose the same image that installed it.
// We'll bypass the screen and auto-fill the g_ImageName.
//
// Returns: TRUE if we were able to that the system was installed
//               from the save server that we are posting to.
//          otherwize FALSE
//
BOOLEAN
DetermineSetupPath( )
{
    HKEY hkeySetup = (HKEY) INVALID_HANDLE_VALUE;
    LONG lResult;
    WCHAR szServerPath[ MAX_PATH ];
    WCHAR szPath[ MAX_PATH ];
    DWORD cbPath;
    BOOLEAN fMatch = FALSE;

    TraceFunc( "DetermineSetupPath( )\n" );

    wsprintf( szServerPath, L"\\\\%s", g_ServerName );

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup",
                            0, // reserved
                            KEY_READ,
                            &hkeySetup );
    if ( lResult != ERROR_SUCCESS )
        goto Error;

    cbPath = sizeof(szPath );
    lResult = RegQueryValueEx( hkeySetup,
                               L"SourcePath",
                               0, // reserved
                               NULL,
                               (LPBYTE) &szPath,
                               &cbPath );
    if ( lResult != ERROR_SUCCESS )
        goto Error;

    if ( StrCmpNI( szPath, szServerPath, wcslen( szServerPath ) ) == 0 )
    {
        wsprintf( g_ImageName, L"%s\\%s", szPath, g_Architecture );
        DebugMsg( "Found Match! Using %s for SetupPath\n", g_ImageName );
        fMatch = TRUE;
    }

Error:
    if ( hkeySetup != INVALID_HANDLE_VALUE )
        RegCloseKey( hkeySetup );

    RETURN(fMatch);
}

void
PopulateImagesListbox2(
    HWND hwndList,
    LPWSTR pszDirName,
    LPWSTR pszOSPath )
{
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    WCHAR szPath[ MAX_PATH ];

    TraceFunc( "PopulateImagesListbox2( )\n" );

    wsprintf( szPath, L"%s\\%s\\%s\\templates\\*.sif", pszOSPath, pszDirName, g_Architecture );

    hFind = FindFirstFile( szPath, &fd );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do
        {
            if (( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 )
            {
                WCHAR szType[ 64 ];
                DWORD dwCount;
                wsprintf( szPath, L"%s\\%s\\%s\\templates\\%s", pszOSPath, pszDirName, g_Architecture, fd.cFileName );
                dwCount = GetPrivateProfileString( L"OSChooser",
                                                   L"ImageType",
                                                   L"",
                                                   szType,
                                                   ARRAYSIZE(szType),
                                                   szPath );
                if ( dwCount
                  && StrCmpIW( szType, L"flat" ) == 0 )
                {
                    ListBox_AddString( hwndList, pszDirName );
                    break; // list only once!
                }
            }
        } while ( FindNextFile( hFind, &fd ) );

        FindClose( hFind );
    }

    TraceFuncExit( );
}

void
PopulateImagesListbox(
    HWND hwndList )
{
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    WCHAR szPath[ MAX_PATH ];

    TraceFunc( "PopulateImagesListbox( )\n" );

    ListBox_ResetContent( hwndList );

    wsprintf( szPath, L"\\\\%s\\REMINST\\Setup\\%s\\%s\\*", g_ServerName, g_Language, REMOTE_INSTALL_IMAGE_DIR_W );

    hFind = FindFirstFile( szPath, &fd );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        szPath[wcslen(szPath) - 2] = L'\0';
        do
        {
            if ( ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
              && StrCmp( fd.cFileName, L"." ) !=0
              && StrCmp( fd.cFileName, L".." ) !=0 )
            {
                PopulateImagesListbox2( hwndList, fd.cFileName, szPath );
            }
        } while ( FindNextFile( hFind, &fd ) );

        FindClose( hFind );
    }

    TraceFuncExit( );
}

//
// SetupPathCheckNextButtonActivation( )
//
VOID
SetupPathCheckNextButtonActivation(
    HWND hDlg )
{
    TraceFunc( "SetupPathCheckNextButtonActivation( )\n" );
    LRESULT lResult = ListBox_GetCurSel( GetDlgItem( hDlg, IDC_L_IMAGES ) );
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK  | ( lResult == LB_ERR ? 0 : PSWIZB_NEXT ));
    TraceFuncExit( );
}

//
// SetupPathDlgProc()
//
INT_PTR CALLBACK
SetupPathDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    default:
        return FALSE;
    case WM_INITDIALOG:
        CenterDialog( GetParent( hDlg ) );
        return FALSE;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDC_L_IMAGES:
            if ( HIWORD( wParam ) == LBN_SELCHANGE )
            {
                SetupPathCheckNextButtonActivation( hDlg );
            }
        }
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            {
                HWND hwndList = GetDlgItem( hDlg, IDC_L_IMAGES );
                UINT sel = ListBox_GetCurSel( hwndList );
                if ( sel == -1 )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                }
                else
                {
                    WCHAR szPath[ MAX_PATH ];
                    ListBox_GetText( hwndList, sel, szPath );
                    wsprintf( g_ImageName,
                              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s",
                              g_ServerName,
                              g_Language,
                              REMOTE_INSTALL_IMAGE_DIR_W,
                              szPath,
                              g_Architecture );
                }
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( DetermineSetupPath( ) )
            {
                DebugMsg( "Skipping SetupPath...\n" );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
            }
            else
            {
                PopulateImagesListbox( GetDlgItem( hDlg, IDC_L_IMAGES ) );
                SetupPathCheckNextButtonActivation( hDlg );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\tasks.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: TASKS.H


 ***************************************************************************/

#ifndef _TASKS_H_
#define _TASKS_H_

#define STATE_NOTSTARTED    ODS_DEFAULT
#define STATE_STARTED       ODS_SELECTED
#define STATE_DONE          ODS_CHECKED
#define STATE_ERROR         ODS_DISABLED

typedef struct {
    LPWSTR          pszText;
    UINT            uState;
    IMIRROR_TODO    todo;
    BOOLEAN         fSeen;
} LBITEMDATA, *LPLBITEMDATA;

INT_PTR CALLBACK
TasksDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _TASKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\tasks.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: TASKS.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"
#include "tasks.h"
#include "logging.h"

DEFINE_MODULE("RIPREP")
extern HWND g_hTasksDialog;

typedef struct {
    HANDLE hChecked;
    HANDLE hError;
    HANDLE hArrow;
    HANDLE hFontNormal;
    HANDLE hFontBold;
    int    dwWidth;
    int    dwHeight;
} SETUPDLGDATA, *LPSETUPDLGDATA;


//
// TasksDlgProc()
//
INT_PTR CALLBACK
TasksDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    static HBRUSH hBrush = NULL;
    LPSETUPDLGDATA psdd = (LPSETUPDLGDATA) GetWindowLongPtr( hDlg, GWLP_USERDATA );
    INT_PTR result;

    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        {
            BITMAP bm;

            // grab the bitmaps
            psdd =
                (LPSETUPDLGDATA) TraceAlloc( GMEM_FIXED, sizeof(SETUPDLGDATA) );

            if ( psdd == NULL ) {
                // This returns FALSE at successful completion
                // So returning opposite 
                return TRUE;
            }

            psdd->hChecked = LoadImage( g_hinstance,
                                        MAKEINTRESOURCE( IDB_CHECK ),
                                        IMAGE_BITMAP,
                                        0, 0,
                                        LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
            DebugMemoryAddHandle( psdd->hChecked );
            GetObject( psdd->hChecked, sizeof(bm), &bm );
            psdd->dwWidth = bm.bmWidth;

            psdd->hError   = LoadImage( g_hinstance,
                                        MAKEINTRESOURCE( IDB_X ),
                                        IMAGE_BITMAP,
                                        0, 0,
                                        LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
            DebugMemoryAddHandle( psdd->hError );
            GetObject( psdd->hError, sizeof(bm), &bm );
            psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ? psdd->dwWidth : bm.bmWidth );

            psdd->hArrow   = LoadImage( g_hinstance,
                                        MAKEINTRESOURCE( IDB_ARROW ),
                                        IMAGE_BITMAP,
                                        0, 0,
                                        LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
            DebugMemoryAddHandle( psdd->hArrow );
            GetObject( psdd->hArrow, sizeof(bm), &bm );
            psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ?
                              psdd->dwWidth :
                              bm.bmWidth );

            HWND    hwnd = GetDlgItem( hDlg, IDC_L_TASKS );

            HFONT hFontOld = (HFONT) SendMessage( hwnd, WM_GETFONT, 0, 0);
            if(hFontOld != NULL)
            {
                LOGFONT lf;
                if ( GetObject( hFontOld, sizeof(LOGFONT), (LPSTR) &lf ) )
                {
                    DWORD dw = LoadString( g_hinstance,
                                           IDS_LARGEFONTNAME,
                                           lf.lfFaceName,
                                           LF_FACESIZE);
                    Assert( dw );

                    lf.lfWidth = 0;
                    lf.lfWeight = 400;
                    lf.lfHeight -= 4;
                    psdd->hFontNormal = CreateFontIndirect(&lf);
                    DebugMemoryAddHandle( psdd->hFontNormal );

                    lf.lfWeight = 700;
                    psdd->hFontBold = CreateFontIndirect(&lf);
                    DebugMemoryAddHandle( psdd->hFontBold );
                }
            }

            HDC hDC = GetDC( NULL );
            SelectObject( hDC, psdd->hFontBold );
            TEXTMETRIC tm;
            GetTextMetrics( hDC, &tm );
            psdd->dwHeight = tm.tmHeight;
            ReleaseDC( NULL, hDC );

            SetWindowLongPtr( hDlg, GWLP_USERDATA, (LONG_PTR) psdd );
            WCHAR szTitle[ 256 ];
            DWORD dw;
            dw = LoadString( g_hinstance, IDS_APPNAME, szTitle, ARRAYSIZE(szTitle));
            Assert( dw );
            SetWindowText( hDlg, szTitle );
            SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );

            CenterDialog( hDlg );
            return FALSE;
        }
        break;

    case WM_MEASUREITEM:
        {
            LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam;
            RECT    rc;
            if ( lpmis == NULL ) {
                // Breaks and returns TRUE at successful completion
                // So returning opposite
                return FALSE;
            }
            HWND    hwnd = GetDlgItem( hDlg, IDC_L_TASKS );

            GetClientRect( hwnd, &rc );

            lpmis->itemWidth = rc.right - rc.left;
            lpmis->itemHeight = psdd->dwHeight;
        }
        break;

    case WM_DRAWITEM:
        {
            Assert( psdd );

            LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;
            if ( !lpdis ) {
                // Below, another null pointer in the same
                // data field is taken care of. We are 
                // duplicating the result here.
                break; // ignore
            }
            LPLBITEMDATA plbid = (LPLBITEMDATA)lpdis->itemData;
            RECT rc = lpdis->rcItem;
            HANDLE hOldFont = INVALID_HANDLE_VALUE;
            WCHAR szText[MAX_PATH];

            if ( !plbid )
                break; // ignore

            ListBox_GetText(lpdis->hwndItem, lpdis->itemID, szText);
            rc.right = rc.bottom = psdd->dwWidth;

            switch ( plbid->uState )
            {
            case STATE_NOTSTARTED:
                hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                break;

            case STATE_STARTED:
                DrawBitmap( psdd->hArrow, lpdis, &rc );
                hOldFont = SelectObject( lpdis->hDC, psdd->hFontBold );
                break;

            case STATE_DONE:
                DrawBitmap( psdd->hChecked, lpdis, &rc );
                hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                break;

            case STATE_ERROR:
                DrawBitmap( psdd->hError, lpdis, &rc );
                hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                break;
            }

            rc = lpdis->rcItem;
            rc.left += psdd->dwHeight;

            DrawText( lpdis->hDC, plbid->pszText, -1, &rc, DT_LEFT | DT_VCENTER );

            if ( hOldFont != INVALID_HANDLE_VALUE )
            {
                SelectObject( lpdis->hDC, hOldFont );
            }
        }
        break;

    case WM_CTLCOLORLISTBOX:
        if ( hBrush == NULL )
        {
            LOGBRUSH brush;
            brush.lbColor = GetSysColor( COLOR_3DFACE );
            brush.lbStyle = BS_SOLID;
            hBrush = (HBRUSH) CreateBrushIndirect( &brush );
            DebugMemoryAddHandle( hBrush );
        }
        SetBkMode( (HDC) wParam, OPAQUE );
        SetBkColor( (HDC) wParam, GetSysColor( COLOR_3DFACE ) );
        return (INT_PTR)hBrush;

    case WM_DESTROY:
        if ( hBrush != NULL )
        {
            DebugMemoryDelete( hBrush );
            DeleteObject(hBrush);
            hBrush = NULL;
        }
        Assert( psdd );
        DeleteObject( psdd->hChecked );
        DebugMemoryDelete( psdd->hChecked );
        DeleteObject( psdd->hError );
        DebugMemoryDelete( psdd->hError );
        DeleteObject( psdd->hArrow );
        DebugMemoryDelete( psdd->hArrow );
        DeleteObject( psdd->hFontNormal );
        DebugMemoryDelete( psdd->hFontNormal );
        DeleteObject( psdd->hFontBold );
        DebugMemoryDelete( psdd->hFontBold );
        TraceFree( psdd );
        SetWindowLongPtr( hDlg, GWLP_USERDATA, NULL );
        EndDialog( g_hTasksDialog, 0 );
        break;

    case WM_SETTINGCHANGE:
        if ( hBrush != NULL )
        {
            DebugMemoryDelete( hBrush );
            DeleteObject(hBrush);
            hBrush = NULL;
        }
        break;

    case WM_UPDATE:
        {
            RECT rc;

            LPWSTR pszOperation = (LPWSTR) wParam;
            LPWSTR pszObject = (LPWSTR) lParam;
            LPWSTR pszTemp = NULL;
            LPWSTR psz;

            if ( lParam && wParam ) {
                RECT rect;
                SIZE size;
                HDC hdc = GetDC( hDlg );
                INT iLength = wcslen( pszOperation );
                psz = pszObject;
                if ( psz && StrCmpN( psz, L"\\\\?\\", 4) == 0 )
                {
                    psz += 4;
                }
                GetWindowRect( GetDlgItem( hDlg, IDC_S_OPERATION ), &rect );
                if (hdc != NULL) {
                    GetTextExtentPoint( hdc, pszOperation, iLength, &size );
                    PathCompactPath( hdc, psz, rect.right - rect.left - size.cx );
                    ReleaseDC( hDlg, hdc );
                }

                pszTemp = (LPWSTR) TraceAlloc( LMEM_FIXED, (iLength + wcslen(psz) + 2) * sizeof(WCHAR)); // +1 space +1 NULL
                if (!pszTemp )
                    goto Update_Cleanup;
                wsprintf( pszTemp, pszOperation, psz );
                psz = pszTemp;
            } else if ( pszObject ) {
                psz = pszObject;
            } else if ( wParam ) {
                psz = pszOperation;
            } else {
                psz = L"";
            }

            Assert( psz );
            SetDlgItemText( hDlg, IDC_S_OPERATION, psz );

Update_Cleanup:
            if ( pszTemp )
                TraceFree( pszTemp );
            if ( pszObject )
                TraceFree( pszObject );
            if ( pszOperation )
                TraceFree( pszOperation );
        }
        break;

    case WM_ERROR:
    case WM_ERROR_OK:
        //
        // Close the log file to prevent the "write-behind / data-loss" popups.
        //
        if ( g_hLogFile != INVALID_HANDLE_VALUE ) {
            CloseHandle( g_hLogFile );
            g_hLogFile = INVALID_HANDLE_VALUE;
        }

        // Signal that the error log should be displayed.
        g_fErrorOccurred = TRUE;

        result = TRUE;  // message processed

        if ( lParam != NULL )
        {
            LBITEMDATA * pitem = (LBITEMDATA *) lParam;
            LPWSTR     pszFile = pitem->pszText;
            DWORD      Error   = pitem->uState;

            // Remove the "\\?\" from the beginning of the line
            if ( pszFile != NULL 
              && StrCmpN( pszFile, L"\\\\?\\", 4 ) == 0 ) 
            {
                pszFile = &pszFile[4];
            }

            switch (Error)
            {
            case ERROR_DISK_FULL:
                {
                    WCHAR szTemplate[ 1024 ];
                    INT i = MessageBoxFromStrings( hDlg, IDS_DISK_FULL_TITLE, IDS_DISK_FULL_TEXT, MB_ABORTRETRYIGNORE );
                    DWORD dw = LoadString( g_hinstance, IDS_DISK_FULL_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate );
                    if ( i == IDABORT )
                    {
                        pitem->uState = ERROR_REQUEST_ABORTED;
                    } 
                    else if ( i == IDRETRY )
                    {
                        pitem->uState = STATUS_RETRY;
                    }
                    else // ignore the error
                    {
                        pitem->uState = ERROR_SUCCESS;
                    }
                }
                break;

            case ERROR_FILE_ENCRYPTED:
                {
                    INT i = IDOK;
                    WCHAR szTemplate[ 1024 ];   // random
                    WCHAR szText[ ARRAYSIZE(szTemplate) + MAX_PATH ];
                    WCHAR szTitle[ MAX_PATH ];  // random
                    DWORD dw;
                    dw = LoadString( g_hinstance, IDS_ENCRYPTED_FILE_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    dw = LoadString( g_hinstance, IDS_ENCRYPTED_FILE_TITLE, szTitle, ARRAYSIZE(szTitle) );
                    Assert( dw );
                    wsprintf( szText, szTemplate, pszFile );
                    if ( !g_fQuietFlag ) {
                        i = MessageBox( hDlg, szText, szTitle, MB_OKCANCEL );
                    }
                    dw = LoadString( g_hinstance, IDS_ENCRYPTED_FILE_LOG, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate, pszFile );
                    pitem->uState = ( i == IDOK ? ERROR_SUCCESS : ERROR_REQUEST_ABORTED );
                }
                break;

            case ERROR_SHARING_VIOLATION:
                {
                    BOOL SkipCheck = FALSE;
                    WCHAR szTemplate[ 1024 ];   // random
                    WCHAR szText[ ARRAYSIZE(szTemplate) + MAX_PATH ];
                    WCHAR szTitle[ MAX_PATH ];  // random
                    DWORD dw;

                    if (g_hCompatibilityInf != INVALID_HANDLE_VALUE) {
                        INFCONTEXT Context;
                        if (SetupFindFirstLine(
                                    g_hCompatibilityInf,
                                    L"FilesToIgnoreCopyErrors",
                                    pszFile,
                                    &Context)) {
                            pitem->uState = ERROR_SUCCESS;
                            SkipCheck = TRUE;
                        }
                    } 

                    if (!SkipCheck) {                                        
                        dw = LoadString( g_hinstance, IDS_SHARING_VIOLATION_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                        Assert( dw );
                        dw = LoadString( g_hinstance, IDS_SHARING_VIOLATION_TITLE, szTitle, ARRAYSIZE(szTitle) );
                        Assert( dw );
                        wsprintf( szText, szTemplate, pszFile );
                        if ( !g_fQuietFlag ) 
                        {
                            INT i = MessageBox( hDlg, szText, szTitle, MB_ABORTRETRYIGNORE );
                            if ( i == IDABORT )
                            {
                                pitem->uState = ERROR_REQUEST_ABORTED;
                            } 
                            else if ( i == IDRETRY )
                            {
                                pitem->uState = STATUS_RETRY;
                            }
                            else // ignore the error
                            {
                                pitem->uState = ERROR_SUCCESS;
                            }
                        }
                        else // ignore the error - it will be logged
                        {
                            pitem->uState = ERROR_SUCCESS;
                        }
                    }

                    dw = LoadString( g_hinstance, IDS_SHARING_VIOLATION_LOG, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate, pszFile );
                }
                break;

            case ERROR_ACCESS_DENIED:
                {
                    INT i = IDOK;
                    WCHAR szTemplate[ 1024 ];   // random
                    WCHAR szText[ ARRAYSIZE(szTemplate) + MAX_PATH ];
                    WCHAR szTitle[ MAX_PATH ];  // random
                    DWORD dw;
                    dw = LoadString( g_hinstance, IDS_ACCESS_DENIED_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    dw = LoadString( g_hinstance, IDS_ACCESS_DENIED_TITLE, szTitle, ARRAYSIZE(szTitle) );
                    Assert( dw );
                    wsprintf( szText, szTemplate, pszFile );
                    if ( !g_fQuietFlag ) {
                        i = MessageBox( hDlg, szText, szTitle, MB_OKCANCEL );
                    }
                    dw = LoadString( g_hinstance, IDS_ACCESS_DENIED_LOG, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate, pszFile );
                    pitem->uState = ( i == IDOK ? ERROR_SUCCESS : ERROR_REQUEST_ABORTED );
                }
                break;

            case ERROR_INVALID_DRIVE:   // special meaning multi-disk detected
                {
                    INT i = IDOK;
                    i = MessageBoxFromStrings( hDlg, IDS_MULTIPLE_DISK_TITLE, IDS_MULTIPLE_DISK_TEXT, MB_OKCANCEL );
                    pitem->uState = ( i == IDOK ? ERROR_SUCCESS : ERROR_REQUEST_ABORTED );
                }
                break;

            case ERROR_REPARSE_ATTRIBUTE_CONFLICT:
                {
                    INT i = IDOK;
                    WCHAR szTemplate[ 1024 ];   // random
                    WCHAR szText[ ARRAYSIZE(szTemplate) + MAX_PATH ];
                    WCHAR szTitle[ MAX_PATH ];  // random
                    DWORD dw;
                    dw = LoadString( g_hinstance, IDS_NOT_COPYING_REPARSE_POINT_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    dw = LoadString( g_hinstance, IDS_NOT_COPYING_REPARSE_POINT_TITLE, szTitle, ARRAYSIZE(szTitle) );
                    Assert( dw );
                    wsprintf( szText, szTemplate, pszFile );
                    if ( !g_fQuietFlag ) {
                        i = MessageBox( hDlg, szText, szTitle, MB_OKCANCEL );
                    }
                    dw = LoadString( g_hinstance, IDS_NOT_COPYING_REPARSE_POINT_LOG, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate, pszFile );
                    pitem->uState = ( i == IDOK ? ERROR_SUCCESS : ERROR_REQUEST_ABORTED );
                }
                break;

            case STATUS_MISSING_SYSTEMFILE:
                MessageBoxFromStrings( hDlg, IDS_BOOT_PARTITION_TITLE, IDS_BOOT_PARTITION_TEXT, MB_OK );
                pitem->uState = ERROR_REQUEST_ABORTED;    // stop copying
                break;

            case STATUS_OBJECT_TYPE_MISMATCH:
                MessageBoxFromStrings( hDlg, IDS_DYNAMIC_DISK_TITLE, IDS_DYNAMIC_DISK_TEXT, MB_OK );
                pitem->uState = ERROR_REQUEST_ABORTED;    // stop copying
                break;

            case ERROR_OLD_WIN_VERSION:
            default:
                if ( Error != ERROR_SUCCESS )
                {
                    if ( uMsg == WM_ERROR_OK || Error == ERROR_OLD_WIN_VERSION ) 
                    {
                        MessageBoxFromError( hDlg, (LPWSTR) pszFile, (DWORD) Error, NULL, MB_OK );
                        pitem->uState = ERROR_REQUEST_ABORTED;
                    } 
                    else // uMsg == WM_ERROR
                    { 
                        WCHAR szTemplate[ 1024 ]; // random
                        DWORD dw = LoadString( g_hinstance, IDS_RETRY_ABORT_IGNORE_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                        if ( !g_fQuietFlag ) 
                        {
                            INT i = MessageBoxFromError( 
                                            hDlg, 
                                            (LPWSTR) pszFile, 
                                            (DWORD) RtlNtStatusToDosError(Error), 
                                            szTemplate, 
                                            MB_ABORTRETRYIGNORE );

                            if ( i == IDABORT )
                            {
                                pitem->uState = ERROR_REQUEST_ABORTED;
                            } 
                            else if ( i == IDRETRY )
                            {
                                pitem->uState = STATUS_RETRY;
                            }
                            else // ignore the error
                            {
                                pitem->uState = ERROR_SUCCESS;
                            }
                        } 
                        else // ignore the error - it will be logged.
                        {
                            pitem->uState = ERROR_SUCCESS;
                        }
                    }

                    LogMsg( L"Error 0x%08x: %s\r\n", Error, pszFile );
                }
                break;
            }
        }

        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, result );
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\welcome.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: WELCOME.H

 ***************************************************************************/

#ifndef _WELCOME_H_
#define _WELCOME_H_

INT_PTR CALLBACK
WelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _WELCOME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\utils.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _UTILS_H_
#define _UTILS_H_

void 
CenterDialog( 
    HWND hwndDlg );

void 
ClearMessageQueue( void );

INT
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType );

INT
MessageBoxFromError(
    HWND hParent,
    LPTSTR pszTitle,
    DWORD dwErr,
    LPTSTR pszAdditionalText OPTIONAL,
    UINT uType );

INT
MessageBoxFromMessage(
    HWND Window,
    DWORD MessageId,
    BOOL SystemMessage,
    LPCTSTR CaptionString,
    UINT Style,
    ...
    );


//
// Enum for SetDialogFont().
//
typedef enum {
    DlgFontTitle,
    DlgFontBold
} MyDlgFont;


VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    );

void 
DrawBitmap( 
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis,
    LPRECT prc );

BOOL 
VerifyCancel( 
    HWND hParent );

class CWaitCursor
{
private:
    HCURSOR _hOldCursor;

public:
    CWaitCursor( ) { _hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) ); };
    ~CWaitCursor( ) { SetCursor( _hOldCursor ); };
};

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\web.cpp ===
#include "pch.h"
#pragma hdrstop

#include <windows.h>
#include <ole2.h>
#include <exdisp.h>
#include <htiframe.h>

#define INITGUID

#include <initguid.h>
#include <shlguid.h>
#include <mshtml.h>

DEFINE_MODULE( "RIPREP" )

const VARIANT c_vaEmpty = {0};
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)



BOOL
IsIE3Installed(
    VOID
)
{
HRESULT         hr;
IWebBrowserApp  *pwb;

    hr = CoCreateInstance( CLSID_InternetExplorer,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IWebBrowserApp,
                           (void **)&pwb );
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
IsIE4Installed(
    VOID
)
{
HRESULT         hr;
IWebBrowserApp  *pwb;

    hr = CoCreateInstance( CLSID_InternetExplorer,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IWebBrowser2,
                           (void **)&pwb );

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
LaunchIE3Instance(
    LPWSTR szResourceURL
    )
{
    HRESULT hr;
    int dx, dy;
    IWebBrowserApp *pwb;


    hr = CoCreateInstance(
        CLSID_InternetExplorer,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWebBrowserApp,
        (void **)&pwb
        );

    if (SUCCEEDED(hr)) {

        // turn off chrome
        hr = pwb->put_MenuBar(FALSE);
        hr = pwb->put_StatusBar(FALSE);
//        hr = pwb->put_ToolBar(FALSE);

        // set client area size
        int iWidth = 466L;
        int iHeight = 286L;

        pwb->ClientToWindow(&iWidth, &iHeight);

        if (iWidth > 0)
            pwb->put_Width(iWidth);

        if (iHeight > 0)
            pwb->put_Height(iHeight);

        if ((dx = ((GetSystemMetrics(SM_CXSCREEN) - iWidth) / 2)) > 0)     // center the on screen window
            pwb->put_Left(dx);

        if ((dy = ((GetSystemMetrics(SM_CYSCREEN) - iHeight) / 2)) > 0)
            pwb->put_Top(dy);

        pwb->put_Visible(TRUE);

        hr = pwb->Navigate(szResourceURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);

        pwb->Release();

        return(TRUE);
    }

    return(FALSE);
}


BOOL
LaunchIE4Instance(
    LPWSTR szResourceURL
    )
{
    HRESULT hr;
    int dx, dy;
    IWebBrowser2 *pwb;


    hr = CoCreateInstance(
        CLSID_InternetExplorer,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWebBrowser2,
        (void **)&pwb
        );

    if (SUCCEEDED(hr)) {
        DWORD dwFlags;
        ITargetFrame2* ptgf;

        //
        //  this marks this window as a third party window,
        //  so that the window is not reused.
        //
        pwb->put_RegisterAsBrowser(VARIANT_TRUE);

        IHTMLWindow2 *phw;
        IServiceProvider *psp;

        if (SUCCEEDED(pwb->QueryInterface(IID_IServiceProvider, (void**) &psp)) && psp) {
            if (SUCCEEDED(psp->QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void**)&phw))) {
                VARIANT var;
                var.vt = VT_BOOL;
                var.boolVal = 666;
                phw->put_opener(var);
                phw->Release();
            } else
                MessageBox(NULL, TEXT("QueryInterface of IID_IHTMLWindow2 FAILED!!!!!"), NULL, MB_ICONERROR);
            psp->Release();
        }

        // turn off chrome
        pwb->put_MenuBar(FALSE);
        pwb->put_StatusBar(FALSE);
//        pwb->put_ToolBar(FALSE);
        pwb->put_AddressBar(FALSE);
//      pwb->put_Resizable(FALSE);


        // set client area size
        int iWidth = 466L;
        int iHeight = 286L;

        pwb->ClientToWindow(&iWidth, &iHeight);

        if (iWidth > 0)
            pwb->put_Width(iWidth);

        if (iHeight > 0)
            pwb->put_Height(iHeight);

        if ((dx = ((GetSystemMetrics(SM_CXSCREEN) - iWidth) / 2)) > 0)     // center the on screen window
            pwb->put_Left(dx);

        if ((dy = ((GetSystemMetrics(SM_CYSCREEN) - iHeight) / 2)) > 0)
            pwb->put_Top(dy);

        pwb->put_Visible(TRUE);

        hr = pwb->Navigate(szResourceURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);

        pwb->Release();

        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\utils.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#include "pch.h"
#include "utils.h"

DEFINE_MODULE("RIPREP")

#define SMALL_BUFFER_SIZE   1024

//
// Centers a dialog.
//
void
CenterDialog(
    HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen;
    int     cyScreen;

    SystemParametersInfo( SPI_GETWORKAREA, 0, &rcScreen, 0 );

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect( hwndDlg, &rc );

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ( ( cyScreen - cyDlg ) / 2 );
    x = rcScreen.left + ( ( cxScreen - cxDlg ) / 2 );

    SetWindowPos( hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE );
}

//
// Eats all mouse and keyboard messages.
//
void
ClearMessageQueue( void )
{
    MSG   msg;

    while ( PeekMessage( (LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST,
                PM_NOYIELD | PM_REMOVE ) );
}

//
// Create a message box from resource strings.
//
INT
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType )
{
    TCHAR szText[ SMALL_BUFFER_SIZE ];
    TCHAR szCaption[ SMALL_BUFFER_SIZE ];
    DWORD dw;

    dw = LoadString( g_hinstance, idsCaption, szCaption, ARRAYSIZE( szCaption ));
    Assert( dw );
    dw = LoadString( g_hinstance, idsText, szText, ARRAYSIZE( szText ));
    Assert( dw );

    return MessageBox( hParent, szText, szCaption, uType );
}

//
// Creates a error message box
//
INT
MessageBoxFromError(
    HWND hParent,
    LPTSTR pszTitle,
    DWORD dwErr,
    LPTSTR pszAdditionalText,
    UINT uType )
{
    WCHAR szText[ SMALL_BUFFER_SIZE ];
    LPTSTR lpMsgBuf;
    LPTSTR lpMsgBuf2;
    int retval;

    if ( dwErr == ERROR_SUCCESS ) {
        AssertMsg( dwErr, "Why was MessageBoxFromError() called when the dwErr == ERROR_SUCCES?" );
        return IDOK;
    }

    if ( !pszTitle ) {
        DWORD dw;
        dw = LoadString( g_hinstance, IDS_ERROR, szText, ARRAYSIZE( szText ));
        Assert( dw );
        pszTitle = szText;
    }

    if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf2,
            0,
            NULL )) {
    

        //
        // If additional text was given, allocate a buffer large enough for both
        // strings. If the allocation fails, just show the error text.
        //
    
        if ( pszAdditionalText != NULL ) {
            DWORD len = (wcslen(lpMsgBuf2) + wcslen(pszAdditionalText) + 1) * sizeof(WCHAR);
            lpMsgBuf = (LPTSTR)LocalAlloc( LPTR, len );
            if ( lpMsgBuf != NULL ) {
                wcscpy( lpMsgBuf, lpMsgBuf2 );
                wcscat( lpMsgBuf, pszAdditionalText );
            } else {
                lpMsgBuf = lpMsgBuf2;
            }
        } else {
            lpMsgBuf = lpMsgBuf2;
        }
    
        retval = MessageBox( hParent, lpMsgBuf, pszTitle, uType | MB_TASKMODAL | MB_ICONERROR );
    
        SetFocus( hParent );
    
        if (lpMsgBuf != NULL) {
            LocalFree( lpMsgBuf );
        }
    
        if ( lpMsgBuf2 != lpMsgBuf ) {
            LocalFree( lpMsgBuf2 );
        }
    
        return retval;

    } else {
        Assert(FALSE);
        return 0;
    }
}

VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    )
{
    static HFONT BigBoldFont = NULL;
    static HFONT BoldFont    = NULL;
    static HFONT NormalFont  = NULL;
    HFONT Font;
    LOGFONT LogFont;
    WCHAR FontSizeString[24];
    int FontSize;
    HDC hdc;

    switch(WhichFont) {

    case DlgFontTitle:

        if(!BigBoldFont) {

            if ( Font =
                (HFONT) SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0) )
            {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont) )
                {
                    DWORD dw = LoadString( g_hinstance,
                                           IDS_LARGEFONTNAME,
                                           LogFont.lfFaceName,
                                           LF_FACESIZE);
                    Assert( dw );

                    // LogFont.lfWeight = 700;
                    FontSize = 14;

                    if ( hdc = GetDC(hdlg) )
                    {
                        LogFont.lfHeight =
                            0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                        BigBoldFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BigBoldFont;
        break;

    case DlgFontBold:

        if ( !BoldFont )
        {
            if ( Font =
                (HFONT) SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0 ))
            {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont ) )
                {

                    LogFont.lfWeight = FW_BOLD;

                    if ( hdc = GetDC( hdlg ) )
                    {
                        BoldFont = CreateFontIndirect( &LogFont );
                        ReleaseDC( hdlg, hdc );
                    }
                }
            }
        }
        Font = BoldFont;
        break;

    default:
        //
        // Nothing to do here.
        //
        Font = NULL;
        break;
    }

    if( Font )
    {
        SendDlgItemMessage( hdlg, ControlId, WM_SETFONT, (WPARAM) Font, 0 );
    }
}


//
// Adjusts and draws a bitmap transparently in the RECT prc.
//
void
DrawBitmap(
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis,
    LPRECT prc )
{
    TraceFunc( "DrawBitmap( ... )\n" );

    BITMAP  bm;
    HDC     hDCBitmap;
    int     dy;

    if (GetObject( hBitmap, sizeof(bm), &bm ) &&
        (hDCBitmap = CreateCompatibleDC( NULL ))) {
    
        SelectObject( hDCBitmap, hBitmap );
    
        // center the image
        dy = 4 + prc->bottom - bm.bmHeight;
    
        StretchBlt( lpdis->hDC, prc->left, prc->top + dy, prc->right, prc->bottom,
              hDCBitmap, 0, 0, bm.bmWidth, bm.bmHeight, SRCAND );
    
        DeleteDC( hDCBitmap );

    }

    TraceFuncExit( );
}

//
// Verifies that the user wanted to cancel setup.
//
BOOL
VerifyCancel( HWND hParent )
{
    TraceFunc( "VerifyCancel( ... )\n" );

    INT iReturn;
    BOOL fAbort = FALSE;

    iReturn = MessageBoxFromStrings( hParent,
                                     IDS_CANCELCAPTION,
                                     IDS_CANCELTEXT,
                                     MB_YESNO | MB_ICONQUESTION );
    if ( iReturn == IDYES ) {
        fAbort = TRUE;
    }

    SetWindowLongPtr( hParent, DWLP_MSGRESULT, ( fAbort ? 0 : -1 ));

    RETURN(!fAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\screens\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

osc.cab: *.osc
   makecab.exe /F osc.ddf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\riprep\welcome.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: WELCOME.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"

//
// WelcomeDlgProc()
//
INT_PTR CALLBACK
WelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        SetDialogFont( hDlg, IDC_TITLE, DlgFontTitle );
        CenterDialog( GetParent( hDlg ) );
        return FALSE;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\showacl\showacl.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>


VOID
DumpSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    PISECURITY_DESCRIPTOR sd = (PISECURITY_DESCRIPTOR)SecurityDescriptor;
    ULONG sdLength = RtlLengthSecurityDescriptor(sd);
    PACL dacl;
    PACCESS_ALLOWED_ACE ace;
    ULONG i, j;
    PUCHAR p;
    PISID sid;
    BOOLEAN selfRelative;

    selfRelative = (BOOLEAN)((sd->Control & SE_SELF_RELATIVE) != 0);
    printf( "  SD:\n" );
    printf( "  Revision = %x, Control = %x\n", sd->Revision, sd->Control );
    printf( "  Owner = %x, Group = %x\n", sd->Owner, sd->Group );
    printf( "  Sacl = %x, Dacl = %x\n", sd->Sacl, sd->Dacl );
    if ( (sd->Control & SE_DACL_PRESENT) != 0 ) {
        dacl = sd->Dacl;
        if ( selfRelative ) {
            dacl = (PACL)((PUCHAR)sd + (ULONG)dacl);
        }
        printf( "  DACL:\n" );
        printf( "    AclRevision = %x, AclSize = %x, AceCount = %x\n",
                    dacl->AclRevision, dacl->AclSize, dacl->AceCount );
        ace = (PACCESS_ALLOWED_ACE)(dacl + 1);
        for ( i = 0; i < dacl->AceCount; i++ ) {
            printf( "    ACE %d:\n", i );
            printf( "      AceType = %x, AceFlags = %x, AceSize = %x\n",
                        ace->Header.AceType, ace->Header.AceFlags, ace->Header.AceSize );
            if ( ace->Header.AceType < ACCESS_MAX_MS_V2_ACE_TYPE ) {
                printf("      Mask = %08x, Sid = ", ace->Mask );
                for ( j = FIELD_OFFSET(ACCESS_ALLOWED_ACE,SidStart), p = (PUCHAR)&ace->SidStart;
                      j < ace->Header.AceSize;
                      j++, p++ ) {
                    printf( "%02x ", *p );
                }
                printf( "\n" );
            }
            ace = (PACCESS_ALLOWED_ACE)((PUCHAR)ace + ace->Header.AceSize );
        }
    }
    if ( sd->Owner != 0 ) {
        sid = sd->Owner;
        if ( selfRelative ) {
            sid = (PISID)((PUCHAR)sd + (ULONG)sid);
        }
        printf( "  Owner SID:\n" );
        printf( "    Revision = %x, SubAuthorityCount = %x\n",
                    sid->Revision, sid->SubAuthorityCount );
        printf( "    IdentifierAuthority = " );
        for ( j = 0; j < 6; j++ ) {
            printf( "%02x ", sid->IdentifierAuthority.Value[j] );
        }
        printf( "\n" );
        for ( i = 0; i < sid->SubAuthorityCount; i++ ) {
            printf("      SubAuthority %d = ", i );
            for ( j = 0, p = (PUCHAR)&sid->SubAuthority[i]; j < 4; j++, p++ ) {
                printf( "%02x ", *p );
            }
            printf( "\n" );
        }
    }
}
int _cdecl
main(int argc, char * argv[])
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    WCHAR unicodeName[MAX_PATH];
    UCHAR SecurityDescriptorBuffer[512];
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG lengthNeeded;
    HANDLE fileHandle;

    if (argc < 2) {
        printf("usage: %s file\n", argv[0]);
        return -1;
    }

    mbstowcs(unicodeName, argv[1], strlen(argv[1]) + 1);

    RtlDosPathNameToNtPathName_U(
        unicodeName,
        &nameString,
        NULL,
        NULL);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtOpenFile(
                 &fileHandle,
                 READ_CONTROL,
                 &objectAttributes,
                 &ioStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 0);

    if (!NT_SUCCESS(status) || !NT_SUCCESS(ioStatusBlock.Status)) {
        printf("%s: NtOpenFile on %wZ failed %lx %lx\n", argv[0], &nameString, status, ioStatusBlock.Status);
        return -1;
    }

    //
    // Now read the DACL from the server file.
    //

    status = NtQuerySecurityObject(
                 fileHandle,
                 DACL_SECURITY_INFORMATION,
                 (PSECURITY_DESCRIPTOR)SecurityDescriptorBuffer,
                 sizeof(SecurityDescriptorBuffer),
                 &lengthNeeded);

    if (!NT_SUCCESS(status)) {
        printf("%s: NtQuerySecurityObject on %wZ failed %lx %lx\n", argv[0], &nameString, status, lengthNeeded);
        return -1;
    }

    DumpSecurityDescriptor((PSECURITY_DESCRIPTOR)SecurityDescriptorBuffer);

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\udplogin\udplogin.c ===
//
// QUICK AND DIRTY SERVER FOR TESTING UDP LOGIN - Adam Barr 5/16/97
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>
#include <winsock.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <security.h>   // General definition of a Security Support Provider
#include <ntlmsp.h>
#include <spseal.h>

#include <stdio.h>

//
// Define this to seal messages, otherwise they are signed.
//

#define SEAL_MESSAGES 1

//
// Packet structure definitions
//

#include "oscpkt.h"


//
// Definitions.
//

#define SOCKET_NUMBER  0x3412
#define BUFFER_SIZE 3072

//
// Global variables.
//

SOCKET g_Socket;
DWORD g_IpAddress;
CHAR g_MyName[80];
CHAR g_Message[BUFFER_SIZE];
DWORD g_MessageLength;
struct sockaddr g_RemoteName;
BOOL g_FailNegotiateResponse = FALSE;
BOOLEAN g_FailAuthenticateResponse = FALSE;
BOOLEAN g_DropLastFragment = FALSE;

BOOLEAN QuietMode = FALSE;

ULONG CorruptionCounter = 1;

LOGIN_PACKET UNALIGNED * g_LoginMessage = (LOGIN_PACKET UNALIGNED *)g_Message;
SIGNED_PACKET UNALIGNED * g_SignedMessage = (SIGNED_PACKET UNALIGNED *)g_Message;

//
// Structure that defines the state of a client.
//

typedef struct _CLIENT_STATE {
    CtxtHandle ServerContextHandle;
    ULONG ContextAttributes;
    BOOL NegotiateProcessed;    // if TRUE, then NegotiateResponse[Length] is valid
    BOOL AuthenticateProcessed; // if TRUE, then AuthenticateResponse[Length] is valid
    PVOID AuthenticateResponse;
    ULONG AuthenticateResponseLength;
    SECURITY_STATUS AuthenticateStatus;
    ULONG LastSequenceNumber;
    PVOID LastResponse;
    ULONG LastResponseLength;
} CLIENT_STATE, *PCLIENT_STATE;

//
// Holds a screen that we can send down to the client
//

typedef struct _SCREEN {
    PCHAR Buffer;
    ULONG BufferLength;
    CHAR Name[20];
} SCREEN, *PSCREEN;

//
// Note the first one in this array is the default.
//

#define SCREEN_COUNT 5
PCHAR ScreenNames[SCREEN_COUNT] = { "SCREEN2", "AUTOSETUP", "MANSETUP", "REPLACE", "REPLACEHELP" };
SCREEN g_Screens[SCREEN_COUNT];

//
// Error screen.
//

CHAR ErrorScreen[] =
"NAME ERROR\n"
"TYPE NONE\n"
"F3 REBOOT\n"
"TEXT 10 10 ;0m Invalid screen - hit F3 to reboot\n";

//
// At the moment, just have one global one.
//

CLIENT_STATE g_ClientState;


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    SECURITY_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

#if 0
    case SEC_I_CALLBACK_NEEDED:
        printf( " SEC_I_CALLBACK_NEEDED" ); break;
#endif

    }

    printf( "\n" );
}

//
// Open our socket.
//

DWORD
CreateSocket(
    )
{

    DWORD Error;

    struct sockaddr_in SocketName;
    WSADATA wsaData;

    //
    // Initialize winsock.
    //

    // Error = WSAStartup( MAKEWORD(1,1), &wsaData);
    Error = WSAStartup( 0x202, &wsaData);
    if ( Error != ERROR_SUCCESS ) {
        printf("WSAStartup failed, %ld.\n", Error );
        return(Error);
    }

    //
    // Create a socket
    //

    g_Socket = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( g_Socket == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    SocketName.sin_family = PF_INET;
    SocketName.sin_port = htons( (unsigned short)SOCKET_NUMBER );
    SocketName.sin_addr.s_addr = INADDR_ANY;
    RtlZeroMemory( SocketName.sin_zero, 8);

    //
    // Bind this socket to the DHCP server port
    //

    Error = bind(
               g_Socket,
               (struct sockaddr FAR *)&SocketName,
               sizeof( SocketName )
               );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    if (gethostname(g_MyName, sizeof(g_MyName)) != SOCKET_ERROR ){
        PHOSTENT Host;
        Host = gethostbyname(g_MyName);
        if (Host) {
            g_IpAddress = (DWORD)Host->h_addr;
        }
    }

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, close the socket if it is opened.
        //

        if( g_Socket != INVALID_SOCKET ) {
            closesocket( g_Socket );
        }

        printf("BinlInitializeEndpoint failed, %ld.\n", Error );
    }

#if 0
    {
        ULONG optval;
        int optlen;

        if (getsockopt(g_Socket, SOL_SOCKET, SO_MAXDG, (CHAR *)&optval, &optlen) != SOCKET_ERROR) {
            printf("Maximum DG length is %d\n", optval);
        }

        optval = 3000;

        setsockopt(g_Socket, SOL_SOCKET, SO_MAXDG, (CHAR *)&optval, sizeof(ULONG));
    }
#endif

    return( Error );
}



//
// Wait for a packet on our socket into g_Message.
//

DWORD
WaitForMessage(
    )
{
    DWORD error;
    DWORD length;
    int nameLength = sizeof(struct sockaddr);

    //
    //  Loop until we get a packet or an error
    //

    while (1) {

        //
        // clean the receive buffer before receiving data in it.
        //

        RtlZeroMemory( g_Message, BUFFER_SIZE);
        g_MessageLength = BUFFER_SIZE;

        length = recvfrom(
                     g_Socket,
                     g_Message,
                     g_MessageLength,
                     0,
                     &g_RemoteName,
                     &nameLength
                     );

        if ( length == SOCKET_ERROR ) {

            error = WSAGetLastError();
            printf("Recv failed, error = %ld\n", error );

        } else {

            error = ERROR_SUCCESS;
            break;
        }

    }

    return error;
}


//
// Send a message on our socket. If the message is too long, then it
// splits it into fragments of MAXIMUM_FRAGMENT_LENGTH bytes.
//

#define MAXIMUM_FRAGMENT_LENGTH 1400
UCHAR TempMessage[1500];

DWORD
SendUdpMessage(
    BOOL bFragment
    )
{
    DWORD error;
    FRAGMENT_PACKET UNALIGNED * pFragmentPacket =
                        (FRAGMENT_PACKET UNALIGNED *)TempMessage;
    FRAGMENT_PACKET FragmentHeader;
    USHORT FragmentNumber;
    USHORT FragmentTotal;
    ULONG MessageLengthWithoutHeader;
    ULONG BytesSent;
    ULONG BytesThisSend;

    //
    // The message starts with a signature, a length, a sequence number (all
    // four bytes), then two ushorts for fragment count and total. If
    // we have to split it we preserve this header in each packet, with
    // fragment count modified for each one.
    //

    MessageLengthWithoutHeader = g_MessageLength - FRAGMENT_PACKET_DATA_OFFSET;

    if (!bFragment ||
        ((FragmentTotal = (USHORT)((MessageLengthWithoutHeader + MAXIMUM_FRAGMENT_LENGTH - 1) / MAXIMUM_FRAGMENT_LENGTH)) <= 1)) {

        error = sendto(
                    g_Socket,
                    g_Message,
                    g_MessageLength,
                    0,
                    &g_RemoteName,
                    sizeof(struct sockaddr)
                    );

    } else {

        FragmentHeader = *((PFRAGMENT_PACKET)g_Message);  // save the header
        BytesSent = 0;

        for (FragmentNumber = 0; FragmentNumber < FragmentTotal; FragmentNumber++) {

            if (FragmentNumber == (FragmentTotal - 1)) {
                BytesThisSend = MessageLengthWithoutHeader - BytesSent;
            } else {
                BytesThisSend = MAXIMUM_FRAGMENT_LENGTH;
            }

            memcpy(
                TempMessage + FRAGMENT_PACKET_DATA_OFFSET,
                g_Message + FRAGMENT_PACKET_DATA_OFFSET + (FragmentNumber * MAXIMUM_FRAGMENT_LENGTH),
                BytesThisSend);

            memcpy(pFragmentPacket, &FragmentHeader, FRAGMENT_PACKET_DATA_OFFSET);
            pFragmentPacket->Length = BytesThisSend + FRAGMENT_PACKET_EMPTY_LENGTH;
            pFragmentPacket->FragmentNumber = FragmentNumber + 1;
            pFragmentPacket->FragmentTotal = FragmentTotal;

            if ((g_DropLastFragment) &&
                (BytesThisSend != MAXIMUM_FRAGMENT_LENGTH)) {

                g_DropLastFragment = FALSE;
                error = ERROR_SUCCESS;

            } else {

                error = sendto(
                            g_Socket,
                            TempMessage,
                            BytesThisSend + FRAGMENT_PACKET_DATA_OFFSET,
                            0,
                            &g_RemoteName,
                            sizeof(struct sockaddr)
                            );

            }

            if (error == SOCKET_ERROR) {
                break;
            }

            BytesSent += BytesThisSend;
    
        }

    }
    
    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        printf("Send failed, error = %ld\n", error );
    } else {
        error = ERROR_SUCCESS;
    }

    return( error );
}


//
// HACK: Store the last response to the client in this.
//

CHAR LastResponseBuffer[3072];


int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    DWORD Error;
    ULONG i;

    SECURITY_STATUS SecStatus;
    CredHandle CredentialHandle;
    TimeStamp Lifetime;
    ULONG PackageCount;
    PSecPkgInfo PackageInfo = NULL;
    PCLIENT_STATE clientState;

    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;
    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;
    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    ULONG MessageLength, SignLength, SequenceNumber;
    ULONG ScreenCount = 0;


    printf("UDPLOGIN running\n");

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Initialize our global client state.
    //

    g_ClientState.NegotiateProcessed = FALSE;
    g_ClientState.AuthenticateProcessed = FALSE;
    g_ClientState.LastSequenceNumber = 0;
    g_ClientState.LastResponse = LastResponseBuffer;
    g_ClientState.LastResponseLength = 0;

    //
    // Create the socket
    //

    Error = CreateSocket();

    if (Error != ERROR_SUCCESS) {
        printf("Could not create socket %d\n", Error);
        return -1;
    }


    //
    // Load the screens
    //

    for (i = 0; i < SCREEN_COUNT; i++) {
        CHAR ScreenName[30];
        HANDLE hFile;
        DWORD fileSize, bytesRead;

        sprintf(ScreenName, "d:\\screens\\%s", ScreenNames[i]);

        hFile = CreateFileA(ScreenName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

        if (hFile == NULL) {
            printf("Could not open %s!\n", ScreenName);
            continue;
        }

        fileSize = GetFileSize(hFile, NULL);

        printf("File %s is %d bytes\n", ScreenName, fileSize);

        g_Screens[ScreenCount].Buffer = LocalAlloc(0, fileSize);
        if (g_Screens[ScreenCount].Buffer == NULL) {
            printf("Allocate failed!\n");
            continue;
        }

        if (!ReadFile(hFile, g_Screens[ScreenCount].Buffer, fileSize, &bytesRead, NULL)) {
            printf("Read failed\n");
            continue;
        }

        if (bytesRead != fileSize) {
            printf("Too few bytes read\n");
            continue;
        }

        //
        // Find the name.
        //

        if (memcmp(g_Screens[ScreenCount].Buffer, "NAME", 4) == 0) {

            PCHAR NameLoc = g_Screens[ScreenCount].Buffer + 5;
            PCHAR CurLoc = NameLoc;
            while ((*CurLoc != '\n') && (*CurLoc != '\r')) {
                ++CurLoc;
            }
            memcpy(g_Screens[ScreenCount].Name, NameLoc, CurLoc - NameLoc);
            NameLoc[CurLoc-NameLoc] = '\0';

        } else {

            printf("Could not find NAME\n");
            continue;

        }

        printf("Read file %s OK\n", g_Screens[ScreenCount].Name);

        g_Screens[ScreenCount].BufferLength = fileSize;

        ++ScreenCount;

        CloseHandle(hFile);

    }


    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return -1;
    }

    if ( !QuietMode ) {
        printf( "PackageCount: %ld\n", PackageCount );
        for (i = 0; i < PackageCount; i++) {
            printf( "Name: %ws Comment: %ws\n", PackageInfo[i].Name, PackageInfo[i].Comment );
            printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                    PackageInfo[i].fCapabilities,
                    PackageInfo[i].wVersion,
                    PackageInfo[i].wRPCID,
                    PackageInfo[i].cbMaxToken );
        }
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( NTLMSP_NAME, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return -1;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }

    //
    // Allocate some buffers we use.
    //

    ChallengeBuffer.pvBuffer = LocalAlloc( 0, PackageInfo->cbMaxToken );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return -1;
    }

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: ");
        PrintStatus( SecStatus );
        return -1;
    }

    if ( !QuietMode ) {
        printf( "CredentialHandle: 0x%lx 0x%lx   ",
                CredentialHandle.dwLower, CredentialHandle.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    //
    // Loop processing messages.
    //

    while (1) {

        Error = WaitForMessage();

        if (Error != ERROR_SUCCESS) {
            printf("Could not receive message %d\n", Error);
            return -1;
        }

        printf("Received message, length %d, data %.4s\n",
                g_MessageLength,
                g_Message);

        //
        // Normally we would look up the client here, but for the moment
        // we only have one.
        //

        clientState = &g_ClientState;


        if (memcmp(g_Message, NegotiateSignature, 4) == 0) {

            //
            // This is an initial negotiate request.
            //

            //
            // First free anything we have allocated for this client. We
            // assume that each negotiate is a new request since the client
            // may have rebooted, so we don't resend the last response.
            //

            if (clientState->NegotiateProcessed) {

                printf("Got negotiate from client, reinitializing negotiate\n");

                SecStatus = DeleteSecurityContext( &clientState->ServerContextHandle );

                if ( SecStatus != STATUS_SUCCESS ) {
                    printf( "DeleteSecurityContext failed: " );
                    PrintStatus( SecStatus );
                    return -1;
                }

                clientState->NegotiateProcessed = FALSE;

            }

            if (clientState->AuthenticateProcessed) {

                printf("Got negotiate from client, reinitializing authenticate\n");

                LocalFree(clientState->AuthenticateResponse);

                clientState->AuthenticateProcessed = FALSE;
                clientState->LastSequenceNumber = 0;
                clientState->LastResponse = LastResponseBuffer;
                clientState->LastResponseLength = 0;

            }

            //
            // Get the ChallengeMessage (ServerSide)
            //

            ChallengeDesc.ulVersion = 0;
            ChallengeDesc.cBuffers = 1;
            ChallengeDesc.pBuffers = &ChallengeBuffer;

            ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
            ChallengeBuffer.BufferType = SECBUFFER_TOKEN;

            NegotiateDesc.ulVersion = 0;
            NegotiateDesc.cBuffers = 1;
            NegotiateDesc.pBuffers = &NegotiateBuffer;

            NegotiateBuffer.cbBuffer = g_LoginMessage->Length;
            NegotiateBuffer.BufferType = SECBUFFER_TOKEN | SECBUFFER_READONLY;
            NegotiateBuffer.pvBuffer = g_LoginMessage->Data;

            printf("Negotiate message is %d bytes\n", NegotiateBuffer.cbBuffer);

            SecStatus = AcceptSecurityContext(
                            &CredentialHandle,
                            NULL,               // No Server context yet
                            &NegotiateDesc,
                            ISC_REQ_SEQUENCE_DETECT,
                            SECURITY_NATIVE_DREP,
                            &clientState->ServerContextHandle,
                            &ChallengeDesc,
                            &clientState->ContextAttributes,
                            &Lifetime );

            if ( SecStatus != STATUS_SUCCESS ) {
                if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
                    printf( "AcceptSecurityContext (Challenge): " );
                    PrintStatus( SecStatus );
                }
                if ( !NT_SUCCESS(SecStatus) ) {
                    return -1;
                }
            }

            if ( !QuietMode ) {
                printf( "\n\nChallenge Message:\n" );

                printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                        clientState->ServerContextHandle.dwLower, clientState->ServerContextHandle.dwUpper,
                        clientState->ContextAttributes );
                PrintTime( "Lifetime: ", Lifetime );

                DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
            }

            //
            // Send the challenge message back to the client.
            //

            memcpy(g_LoginMessage->Signature, ChallengeSignature, 4);
            g_LoginMessage->Length = ChallengeBuffer.cbBuffer;
            memcpy(g_LoginMessage->Data, ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer);

            g_MessageLength = ChallengeBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET;

            if (g_FailNegotiateResponse) {

                printf(">>> NOT Sending CHAL, %d bytes\n", g_MessageLength);
                g_FailNegotiateResponse = FALSE;

            } else {

                printf("Sending CHAL, %d bytes\n", g_MessageLength);

                Error = SendUdpMessage(FALSE);

                if (Error != ERROR_SUCCESS) {
                    printf("Could not send CHAL message %d\n", Error);
                    return -1;
                }

            }

            clientState->NegotiateProcessed = TRUE;

        } else if (memcmp(g_Message, AuthenticateSignature, 4) == 0) {

            //
            // This has the authenticate message.
            //

            printf("AUTH message is %d bytes of data\n", g_LoginMessage->Length);

            //
            // Make sure we have gotten a negotiate.
            //

            if (!clientState->NegotiateProcessed) {

                printf("Received AUTH without NEG?\n");
                continue;

            }

            //
            // If we have already responsed to this, just resend.
            //

            if (clientState->AuthenticateProcessed) {

                memcpy(g_Message, clientState->AuthenticateResponse, clientState->AuthenticateResponseLength);
                g_MessageLength = clientState->AuthenticateResponseLength;
                SecStatus = clientState->AuthenticateStatus;

                printf("Got authenticate from client, resending\n");

            } else {

                //
                // Finally authenticate the user (ServerSide)
                //

                AuthenticateDesc.ulVersion = 0;
                AuthenticateDesc.cBuffers = 1;
                AuthenticateDesc.pBuffers = &AuthenticateBuffer;

                AuthenticateBuffer.cbBuffer = g_LoginMessage->Length;
                AuthenticateBuffer.BufferType = SECBUFFER_TOKEN | SECBUFFER_READONLY;
                AuthenticateBuffer.pvBuffer = g_LoginMessage->Data;

                SecStatus = AcceptSecurityContext(
                                NULL,
                                &clientState->ServerContextHandle,
                                &AuthenticateDesc,
                                0,
                                SECURITY_NATIVE_DREP,
                                &clientState->ServerContextHandle,
                                NULL,
                                &clientState->ContextAttributes,
                                &Lifetime );


                if ( SecStatus != STATUS_SUCCESS ) {

                    printf( "AcceptSecurityContext (Challenge): " );
                    PrintStatus( SecStatus );

                } else {

                    if ( !QuietMode ) {
                        printf( "\n\nFinal Authentication:\n" );

                        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                                clientState->ServerContextHandle.dwLower, clientState->ServerContextHandle.dwUpper,
                                clientState->ContextAttributes );
                        PrintTime( "Lifetime: ", Lifetime );
                        printf(" \n" );
                    }

                }


                //
                // Send the result back to the client.
                //

                memcpy(g_LoginMessage->Signature, ResultSignature, 4);
                g_LoginMessage->Length = 4;
                g_LoginMessage->Status = SecStatus;

                g_MessageLength = LOGIN_PACKET_DATA_OFFSET + sizeof(ULONG);

                clientState->AuthenticateResponse = LocalAlloc(0, g_MessageLength);
                if (clientState->AuthenticateResponse == NULL) {
                    printf( "Allocate AuthenticateResponse failed: 0x%ld\n", GetLastError() );
                    return -1;
                }
                memcpy(clientState->AuthenticateResponse, g_Message, g_MessageLength);
                clientState->AuthenticateResponseLength = g_MessageLength;

                clientState->AuthenticateProcessed = TRUE;
                clientState->AuthenticateStatus = SecStatus;

            }

            if (g_FailAuthenticateResponse) {

                printf(">>> NOT sending authenticate response\n");
                g_FailAuthenticateResponse = FALSE;

            } else {

                Error = SendUdpMessage(FALSE);

                if (Error != ERROR_SUCCESS) {
                    printf("Could not send OK message %d\n", Error);
                    return -1;
                }

            }

            if ( NT_SUCCESS(SecStatus) ) {

                //
                // Impersonate the client (ServerSide)
                //

                SecStatus = ImpersonateSecurityContext( &clientState->ServerContextHandle );

                if ( SecStatus != STATUS_SUCCESS ) {
                    printf( "ImpersonateSecurityContext: " );
                    PrintStatus( SecStatus );
                    if ( !NT_SUCCESS(SecStatus) ) {
                        return -1;
                    }
                }

                printf ("Impersonated OK\n");

                //
                // RevertToSelf (ServerSide)
                //

                SecStatus = RevertSecurityContext( &clientState->ServerContextHandle );

                if ( SecStatus != STATUS_SUCCESS ) {
                    printf( "RevertSecurityContext: " );
                    PrintStatus( SecStatus );
                    if ( !NT_SUCCESS(SecStatus) ) {
                        return -1;
                    }
                }

                printf ("Reverted OK\n");

            }


#if 0
        } else if (memcmp(g_Message, "SIGN", 4) == 0) {

            //
            // This is a signed message.
            //

            if (!clientState->AuthenticateProcessed) {
                printf("Got SIGN but not authenticated\n");
                continue;
            }

            MessageLength = ((ULONG UNALIGNED *)g_Message)[1];
            SignLength = ((ULONG UNALIGNED *)g_Message)[2];

            printf("SIGN message is %d bytes of data, sign length %d\n", MessageLength, SignLength);

            //
            // Verify the signature
            //

            SigBuffers[0].pvBuffer = g_Message + 12 + SignLength;
            SigBuffers[0].cbBuffer = MessageLength - (SignLength + 4);
            SigBuffers[0].BufferType = SECBUFFER_DATA;

            SigBuffers[1].pvBuffer = g_Message + 12;
            SigBuffers[1].cbBuffer = SignLength;
            SigBuffers[1].BufferType = SECBUFFER_TOKEN;

            SignMessage.pBuffers = SigBuffers;
            SignMessage.cBuffers = 2;
            SignMessage.ulVersion = 0;

            SecStatus = VerifySignature(
                                &clientState->ServerContextHandle,
                                &SignMessage,
                                0,
                                0 );

            printf( "VerifySignature: " );
            PrintStatus( SecStatus );

        } else if (memcmp(g_Message, "SEAL", 4) == 0) {

            //
            // This is a sealed message.
            //

            if (!clientState->AuthenticateProcessed) {
                printf("Got SIGN but not authenticated\n");
                continue;
            }


            MessageLength = ((ULONG UNALIGNED *)g_Message)[1];
            SignLength = ((ULONG UNALIGNED *)g_Message)[2];

            printf("SEAL message is %d bytes of data, sign length %d\n", MessageLength, SignLength);

            //
            // Verify the signature
            //

            SigBuffers[0].pvBuffer = g_Message + 12 + SignLength;
            SigBuffers[0].cbBuffer = MessageLength - (SignLength + 4);
            SigBuffers[0].BufferType = SECBUFFER_DATA;

            SigBuffers[1].pvBuffer = g_Message + 12;
            SigBuffers[1].cbBuffer = SignLength;
            SigBuffers[1].BufferType = SECBUFFER_TOKEN;

            SignMessage.pBuffers = SigBuffers;
            SignMessage.cBuffers = 2;
            SignMessage.ulVersion = 0;

            SecStatus = UnsealMessage(
                                &clientState->ServerContextHandle,
                                &SignMessage,
                                0,
                                0 );

            printf( "UnsealMessage: " );
            PrintStatus( SecStatus );

            DumpBuffer(SigBuffers[0].pvBuffer, SigBuffers[0].cbBuffer);
#endif

        } else if (memcmp(g_Message, "EXIT", 4) == 0) {

            SecStatus = DeleteSecurityContext( &clientState->ServerContextHandle );

            if ( SecStatus != STATUS_SUCCESS ) {
                printf( "DeleteSecurityContext failed: " );
                PrintStatus( SecStatus );
                return -1;
            }

#if 0
        } else if (memcmp(g_Message, RequestSignature, 4) == 0) {

            //
            // A request for a screen.
            //

            PCHAR RspMessage = NULL;
            ULONG RspMessageLength = 0;
            ULONG k;

            if (((ULONG UNALIGNED *)g_Message)[1] == 0) {

                //
                // Empty, give him the first one.
                //

                RspMessage = g_Screens[0].Buffer;
                RspMessageLength = g_Screens[0].BufferLength;

            } else {

                PCHAR NameLoc;
                ULONG NameLength = 0;

                NameLoc = g_Message+8;
                while ((NameLoc[NameLength] != '\n') &&
                       (NameLength < ((ULONG UNALIGNED *)g_Message)[1])) {
                    ++NameLength;
                }

                for (k = 0; k < SCREEN_COUNT; k++) {

                    if ((strlen(g_Screens[k].Name) == NameLength) &&
                        (memcmp(NameLoc, g_Screens[k].Name, NameLength) == 0)) {

                        RspMessage = g_Screens[k].Buffer;
                        RspMessageLength = g_Screens[k].BufferLength;
                        printf("Found match for %s screen\n", g_Screens[k].Name);
                        break;
                    }

                }

                if (k == SCREEN_COUNT) {
                    printf("Could not match %.*s screen\n", NameLength, NameLoc);
                }
            }

            if (RspMessage) {

                memcpy(g_Message, ResponseSignature, 4);
                ((ULONG UNALIGNED *)g_Message)[1] = RspMessageLength;
                memcpy(g_Message+8, RspMessage, RspMessageLength);

                g_MessageLength = RspMessageLength + 8;

                printf("Sending RSP+, %d bytes\n", g_MessageLength);

                Error = SendUdpMessage();

                if (Error != ERROR_SUCCESS) {
                    printf("Could not send RSP+ message %d\n", Error);
                    return -1;
                }

            }
#endif

        } else if (memcmp(g_Message, RequestSignedSignature, 4) == 0) {

            //
            // This is a signed request.
            //
            // Format is:
            //
            // "REQS"
            // length (not including "REQS" and this)
            // sequence number
            // fragment count/total
            // sign length
            // sign
            // data
            //

            if (!clientState->AuthenticateProcessed) {

                //
                // This may happen if we reboot the server -- send an ERRS
                // and the client should reconnect OK.
                //

                printf("Got REQS but not authenticated, sending ERRS\n");

                memcpy(g_SignedMessage->Signature, ErrorSignedSignature, 4);
                g_SignedMessage->Length = 4;
                // g_SignedMessage->SequenceNumber just stays where it is.
                g_MessageLength = SIGNED_PACKET_ERROR_LENGTH;

            } else {
    
                SequenceNumber = g_SignedMessage->SequenceNumber;
    
                if (SequenceNumber == clientState->LastSequenceNumber) {
    
                    //
                    // Is the signature the same as the last one we sent out? If so,
                    // then just resend.
                    //
        
                    memcpy(g_Message, clientState->LastResponse, clientState->LastResponseLength);
                    g_MessageLength = clientState->LastResponseLength;
    
                    printf("Resending last message\n");
    
                } else if (SequenceNumber != ((clientState->LastSequenceNumber % 10000) + 1)) {
    
                    //
                    // It's not the next message - ignore it.
                    //
    
                    printf("got bogus sequence number\n");
                    continue;
    
                } else {
    
                    MessageLength = g_SignedMessage->Length;
                    SignLength = g_SignedMessage->SignLength;
        
                    printf("REQS message is %d bytes of data, sign length %d\n", MessageLength, SignLength);
    
                    clientState->LastSequenceNumber = (clientState->LastSequenceNumber % 10000) + 1;
        
                    //
                    // Verify the signature
                    //
        
                    SigBuffers[0].pvBuffer = g_SignedMessage->Data;
                    SigBuffers[0].cbBuffer = MessageLength - SIGNED_PACKET_EMPTY_LENGTH;
                    SigBuffers[0].BufferType = SECBUFFER_DATA;
        
                    SigBuffers[1].pvBuffer = g_SignedMessage->Sign;
                    SigBuffers[1].cbBuffer = SignLength;
                    SigBuffers[1].BufferType = SECBUFFER_TOKEN;
        
                    SignMessage.pBuffers = SigBuffers;
                    SignMessage.cBuffers = 2;
                    SignMessage.ulVersion = 0;
        
#if SEAL_MESSAGES
                    SecStatus = UnsealMessage(
                                        &clientState->ServerContextHandle,
                                        &SignMessage,
                                        0,
                                        0 );
#else
                    SecStatus = VerifySignature(
                                        &clientState->ServerContextHandle,
                                        &SignMessage,
                                        0,
                                        0 );
#endif
        
                    if (SecStatus != STATUS_SUCCESS) {
    
                        printf("Sending ERRS packet from Verify/Unseal!!\n");
    
                        memcpy(g_SignedMessage->Signature, ErrorSignedSignature, 4);
                        g_SignedMessage->Length = 4;
                        g_SignedMessage->SequenceNumber = clientState->LastSequenceNumber;
                        g_MessageLength = SIGNED_PACKET_ERROR_LENGTH;
    
                    } else {
    
                        //
                        // A valid request for a screen.
                        //
            
                        PCHAR RspMessage = NULL;
                        ULONG RspMessageLength = 0;
                        ULONG k;
            
                        if (MessageLength == (SIGNED_PACKET_EMPTY_LENGTH)) {
            
                            //
                            // Empty (i.e. just headers), give him the first one.
                            //
            
                            RspMessage = g_Screens[0].Buffer;
                            RspMessageLength = g_Screens[0].BufferLength;
            
                        } else {
            
                            PCHAR NameLoc;
                            ULONG NameLength = 0;
            
                            NameLoc = g_SignedMessage->Data;
                            while ((NameLoc[NameLength] != '\n') &&
                                   (NameLength < (MessageLength - SIGNED_PACKET_EMPTY_LENGTH))) {
                                ++NameLength;
                            }
            
                            for (k = 0; k < SCREEN_COUNT; k++) {
            
                                if ((strlen(g_Screens[k].Name) == NameLength) &&
                                    (memcmp(NameLoc, g_Screens[k].Name, NameLength) == 0)) {
            
                                    RspMessage = g_Screens[k].Buffer;
                                    RspMessageLength = g_Screens[k].BufferLength;
                                    printf("Found match for %s screen\n", g_Screens[k].Name);
                                    break;
                                }
            
                            }
    
                            if (k == SCREEN_COUNT) {
                                printf("Could not match %.*s screen\n", NameLength, NameLoc);
                                RspMessage = ErrorScreen;
                                RspMessageLength = strlen(ErrorScreen);
                            }
            
                        }
            
                        memcpy(g_SignedMessage->Signature, ResponseSignedSignature, 4);
                        g_SignedMessage->Length = RspMessageLength + SIGNED_PACKET_EMPTY_LENGTH;
                        g_SignedMessage->SequenceNumber = clientState->LastSequenceNumber;
                        g_SignedMessage->FragmentNumber = 1;  // fragment count
                        g_SignedMessage->FragmentTotal = 1;  // fragment total
                        g_SignedMessage->SignLength = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
    
                        memcpy(g_SignedMessage->Data, RspMessage, RspMessageLength);
                        g_MessageLength = RspMessageLength + SIGNED_PACKET_DATA_OFFSET;
    
                        SigBuffers[0].pvBuffer = g_SignedMessage->Data;
                        SigBuffers[0].cbBuffer = RspMessageLength;
                        SigBuffers[0].BufferType = SECBUFFER_DATA;
            
                        SigBuffers[1].pvBuffer = g_SignedMessage->Sign;
                        SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
                        SigBuffers[1].BufferType = SECBUFFER_TOKEN;
            
                        SignMessage.pBuffers = SigBuffers;
                        SignMessage.cBuffers = 2;
                        SignMessage.ulVersion = 0;
    
#if SEAL_MESSAGES
                        SecStatus = SealMessage(
                                            &clientState->ServerContextHandle,
                                            0,
                                            &SignMessage,
                                            0 );
#else
                        SecStatus = MakeSignature(
                                            &clientState->ServerContextHandle,
                                            0,
                                            &SignMessage,
                                            0 );
#endif
            
                        if (SecStatus != STATUS_SUCCESS) {
        
                            printf("Sending ERRS packet from Make/Seal!!\n");
        
                            memcpy(g_SignedMessage->Signature, ErrorSignedSignature, 4);
                            g_SignedMessage->Length = 4;
                            g_SignedMessage->SequenceNumber = clientState->LastSequenceNumber;
                            g_MessageLength = SIGNED_PACKET_ERROR_LENGTH;
    
                        } else {
                
                            printf("Sending RSPS, %d bytes\n", g_MessageLength);
    
                        }
    
#if 0
                        // corrupt a packet every once in a while!
    
                        if ((CorruptionCounter % 7) == 0) {
    
                            g_SignedMessage->Data[0] = '\0';
                            printf("INTENTIONALLY CORRUPTING MESSAGE!!\n");
    
                        }
                        ++CorruptionCounter;
#endif
        
                    }   // verify succeeded
    
                    //
                    // Save the message in case we have to resend.
                    //
    
                    memcpy(clientState->LastResponse, g_Message, g_MessageLength);
                    clientState->LastResponseLength = g_MessageLength;
    
                }   // signature OK

            }   // AuthenticateProcessed was TRUE

            Error = SendUdpMessage(TRUE);

            if (Error != ERROR_SUCCESS) {
                printf("Could not send RSPS message %d\n", Error);
                return -1;
            }

        } else {

            printf("Received unknown message!\n");

        }

    }


    SecStatus = FreeCredentialsHandle( &CredentialHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return -1;
    }

    LocalFree(ChallengeBuffer.pvBuffer);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\bootvrfy\bootvrfy.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bootvrfy.c

Abstract:

    This is a small service that simply calls NotifyBootConfigStatus to
    indicate that the boot is acceptable.  This service is to go at the
    end of the service dependency list.

    The assumption is that if we got far enough to start this service, the
    the boot must be ok.


Author:

    Dan Lafferty (danl)     06 May-1991

Environment:

    User Mode -Win32


Revision History:

--*/

//
// Includes
//

#include <nt.h>      // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <windef.h>
#include <nturtl.h>     // needed for winbase.h
#include <winbase.h>

#include <winsvc.h>

#include <tstr.h>       // Unicode string macros

//
// Defines
//

#define SERVICE_WAIT_TIME  0xffffffff     // infinite

#define BV_SERVICE_NAME L"BootVerification"

//
// DEBUG MACROS
//
//
// The following allow debug print syntax to look like:
//
//   BV_LOG(DEBUG_TRACE, "An error occured %x\n",status)
//

#if DBG

#define STATIC
#define BV_LOG0(level, string)                  \
    KdPrintEx((DPFLTR_BOOTVRFY_ID,              \
               DEBUG_##level,                   \
               "[BootVrfy]" string))

#define BV_LOG1(level, string, var1)            \
    KdPrintEx((DPFLTR_BOOTVRFY_ID,              \
               DEBUG_##level,                   \
               "[BootVrfy]" string,             \
               var1))

#define BV_LOG2(level, string, var1, var2)      \
    KdPrintEx((DPFLTR_BOOTVRFY_ID,              \
               DEBUG_##level,                   \
               "[BootVrfy]" string,             \
               var1,                            \
               var2))

#else

#define STATIC static
#define BV_LOG0(level, string)
#define BV_LOG1(level, string, var)
#define BV_LOG2(level, string, var1, var2)

#endif

//
// Debug output is filtered at two levels: A global level and a component
// specific level.
//
// Each debug output request specifies a component id and a filter level
// or mask. These variables are used to access the debug print filter
// database maintained by the system. The component id selects a 32-bit
// mask value and the level either specified a bit within that mask or is
// as mask value itself.
//
// If any of the bits specified by the level or mask are set in either the
// component mask or the global mask, then the debug output is permitted.
// Otherwise, the debug output is filtered and not printed.
//
// The component mask for filtering the debug output of this component is
// Kd_BOOTVRFY_Mask and may be set via the registry or the kernel debugger.
//
// The global mask for filtering the debug output of all components is
// Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.
//
// The registry key for setting the mask value for this component is:
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\
//     Session Manager\Debug Print Filter\BOOTVRFY
//
// The key "Debug Print Filter" may have to be created in order to create
// the component key.
//
// The following levels are used to filter debug output.
//

#define DEBUG_ERROR     (0x00000001 | DPFLTR_MASK)
#define DEBUG_TRACE     (0x00000004 | DPFLTR_MASK)

#define DEBUG_ALL       (0xffffffff | DPFLTR_MASK)

//
// Globals
//

    SERVICE_STATUS  BootVerificationStatus;

    HANDLE          BootVerificationDoneEvent;

    SERVICE_STATUS_HANDLE   BootVerificationStatusHandle;

//
// Function Prototypes
//

STATIC VOID
BootVerificationStart (
    DWORD   argc,
    LPWSTR  *argv
    );

STATIC VOID
BootVerificationCtrlHandler (
    IN  DWORD   opcode
    );


/****************************************************************************/
VOID __cdecl
main(void)
{
    DWORD      status;

    SERVICE_TABLE_ENTRYW   DispatchTable[] = {
        { BV_SERVICE_NAME,      BootVerificationStart     },
        { NULL,                 NULL                      }
    };

    status = StartServiceCtrlDispatcherW( DispatchTable);

    BV_LOG0(TRACE,"The Service Process is Terminating....\n");

    ExitProcess(0);

}


/****************************************************************************/

//
// BootVerification will take a long time to respond to pause
//
//

VOID
BootVerificationStart (
    DWORD   argc,
    LPWSTR  *argv
    )
{
    DWORD           status;
    SC_HANDLE       hScManager;
    SC_HANDLE       hService;
    SERVICE_STATUS  ServiceStatus;


    BV_LOG0(TRACE,"Inside the BootVerification Service Thread\n");

    BootVerificationDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    BootVerificationStatus.dwServiceType        = SERVICE_WIN32;
    BootVerificationStatus.dwCurrentState       = SERVICE_RUNNING;
    BootVerificationStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP;
    BootVerificationStatus.dwWin32ExitCode      = 0;
    BootVerificationStatus.dwServiceSpecificExitCode = 0;
    BootVerificationStatus.dwCheckPoint         = 0;
    BootVerificationStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    BV_LOG0(TRACE,"Getting Ready to call RegisterServiceCtrlHandler\n");

    BootVerificationStatusHandle = RegisterServiceCtrlHandlerW(
                                    BV_SERVICE_NAME,
                                    BootVerificationCtrlHandler);

    if (BootVerificationStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        BV_LOG1(ERROR,"RegisterServiceCtrlHandlerW failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (BootVerificationStatusHandle, &BootVerificationStatus)) {
        status = GetLastError();
        BV_LOG1(ERROR,"SetServiceStatus error %ld\n",status);
    }

    //
    // Tell Service Controller that the Boot is OK.
    //

    BV_LOG0(TRACE,"Tell Service Controller that the boot is ok\n");
    if (!NotifyBootConfigStatus(TRUE)) {
        BV_LOG0(ERROR,"NotifyBootConfigStatus Failed\n");
    }

    ////////////////////////////////////////////////////////////////////////
    //
    // Tell the Service Controller that we want to shut down now.
    //
    // If anything fails along the way, just exit process, and allow
    // the service controller to clean up.
    //

    BV_LOG0(TRACE,"Send Control to Service Controller to shut down BOOTVFY\n");


    hScManager = OpenSCManagerW(
                    NULL,
                    NULL,
                    SC_MANAGER_CONNECT);

    if (hScManager == NULL) {
        status = GetLastError();
        BV_LOG1(ERROR,"OpenSCManager failed %d\n",status);
        BootVerificationStatus.dwWin32ExitCode = status;
        SetServiceStatus (BootVerificationStatusHandle,  &BootVerificationStatus);
        ExitProcess(0);
    }

    hService = OpenServiceW(
                    hScManager,
                    BV_SERVICE_NAME,
                    SERVICE_STOP);

    if (hService == NULL) {
        status = GetLastError();
        BV_LOG1(ERROR,"OpenService failed %d\n",status);
        BootVerificationStatus.dwWin32ExitCode = status;
        SetServiceStatus (BootVerificationStatusHandle,  &BootVerificationStatus);
        ExitProcess(0);
    }

    if (!ControlService (hService,SERVICE_CONTROL_STOP,&ServiceStatus)) {
        status = GetLastError();
        BV_LOG1(ERROR,"OpenService failed %d\n",status);
        BootVerificationStatus.dwWin32ExitCode = status;
        SetServiceStatus (BootVerificationStatusHandle,  &BootVerificationStatus);
        ExitProcess(0);
    }


    ////////////////////////////////////////////////////////////////////////
    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                BootVerificationDoneEvent,
                SERVICE_WAIT_TIME);


    BV_LOG0(TRACE,"Leaving the BootVerification service\n");


        BootVerificationStatus.dwWin32ExitCode = 0;
        BootVerificationStatus.dwCurrentState = SERVICE_STOPPED;
    if (!SetServiceStatus (BootVerificationStatusHandle,  &BootVerificationStatus)) {
        status = GetLastError();
        BV_LOG1(ERROR,"SetServiceStatus error %ld\n",status);
    }

    ExitThread(NO_ERROR);
    return;
}


/****************************************************************************/
VOID
BootVerificationCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    BV_LOG1(TRACE,"opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:
        break;

    case SERVICE_CONTROL_CONTINUE:
        break;

    case SERVICE_CONTROL_STOP:

        BootVerificationStatus.dwWin32ExitCode = 0;
        BootVerificationStatus.dwCurrentState = SERVICE_STOP_PENDING;

        SetEvent(BootVerificationDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:

        break;

    default:
        BV_LOG1(ERROR,"Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (BootVerificationStatusHandle,  &BootVerificationStatus)) {
        status = GetLastError();
        BV_LOG1(ERROR,"SetServiceStatus error %ld\n",status);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\client\scbind.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    scbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the Service Controller.

Author:

    Dan Lafferty (danl)     19-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    19-Mar-1991     danl
        created

--*/

//
// INCLUDES
//

extern "C"
{
#include <nt.h>         // DbgPrint prototype
}
#include <rpc.h>        // DataTypes and runtime APIs
#include <svcctl.h>     // generated by the MIDL compiler
#include <ntrpcp.h>     // RpcUtils for binding

#include <sclib.h>      // ansi to unicode conversion functions.
#include <scdebug.h>    // SCC_LOG
#include <sclib.h>      // ScConvertToUnicode

//
// GLOBALS      -   This handle maintains a static binding for status
//                  messages between the service process and the service
//                  controller.
//
    static handle_t StatusBindHandle;


RPC_STATUS
InitializeStatusBinding( VOID)

/*++

Routine Description:

    This routine initializes the global StatusBindHandle that is used for
    the status connection to the service controller.  This routine is called
    by the Service Process (NetServiceStartCtrlDispatcher) when it starts up.


Arguments:

    none

Return Value:

    NERR_Success - (or 0) if the operation was successful.

    Otherwise, it returns any RPC failure status that can be returned
    from RpcBindToInterface.


--*/
{
    RPC_STATUS      status;

    status = RpcpBindRpc (
                NULL,
                L"svcctl",
                0,
                &StatusBindHandle);

    SCC_LOG(TRACE,"InitializeStatusBinding:RpcpBindRpc status=%d\n", status);

    SCC_LOG(TRACE,"InitializeStatusBinding: handle=%d\n",StatusBindHandle);

    return(status);
}



/****************************************************************************/
handle_t
SVCCTL_HANDLEW_bind (
    SVCCTL_HANDLEW   ServerName
    )

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the service controller client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle;
    RPC_STATUS  status;

    status = RpcpBindRpc (
                ServerName,
                L"svcctl",
                L"Security=Impersonation Dynamic False",
                &bindingHandle);

    SCC_LOG(TRACE,"SVCCTL_HANDLEW_bind:RpcpBindRpc status=%d\n",status);
    SCC_LOG(TRACE,"SVCCTL_HANDLEW_bind: handle=%d\n",bindingHandle);

    return( bindingHandle);
}



/****************************************************************************/
void
SVCCTL_HANDLEW_unbind (
    SVCCTL_HANDLEW   ServerName,
    handle_t         BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the Service Controller client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);     // This parameter is not used

    SCC_LOG(TRACE,"SVCCTL_HANDLEW_unbind: handle=%d\n",BindingHandle);

    RpcpUnbindRpc ( BindingHandle);
    return;
}

/****************************************************************************/
handle_t
SVCCTL_HANDLEA_bind (
    SVCCTL_HANDLEA   ServerName
    )

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the service controller client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle;
    RPC_STATUS  status;
    LPWSTR      pServerNameW = NULL;

    if (ServerName != NULL) {
        if (!ScConvertToUnicode(&pServerNameW, ServerName)) {
            SCC_LOG(ERROR,"SVCCTL_HANDLEA_bind:ScConvertToUnicode failed\n",0);
            return(NULL);
        }
    }

    status = RpcpBindRpc (
                pServerNameW,
                L"svcctl",
                L"Security=Impersonation Dynamic False",
                &bindingHandle);

    (void) LocalFree(pServerNameW);

    SCC_LOG(TRACE,"SVCCTL_HANDLEA_bind:RpcpBindRpc status=%d\n",status);
    SCC_LOG(TRACE,"SVCCTL_HANDLEA_bind: handle=%d\n",bindingHandle);

    return( bindingHandle);
}



/****************************************************************************/
void
SVCCTL_HANDLEA_unbind (
    SVCCTL_HANDLEA   ServerName,
    handle_t         BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the Service Controller client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);     // This parameter is not used

    SCC_LOG(TRACE,"SVCCTL_HANDLEA_unbind: handle=%d\n",BindingHandle);

    RpcpUnbindRpc ( BindingHandle);
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\client\scbind.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

   scbind.h

Abstract:

    Function prototypes for functions in scbind.c that are used externally.
    NOTE:  The RPC bind and unbind functions do not appear here because
    the RPC stubs are the only functions that call these functions.  The RPC
    stubs already have a prototype for those functions.

Author:

    Dan Lafferty (danl)     06-Jun-1991

Environment:

    User Mode -Win32

Revision History:


--*/

RPC_STATUS
InitializeStatusBinding( VOID);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\bootok\bootok.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bootok.c

Abstract:

    This program will send a NotifyBootConfigStatus to the service controller
    to tell it that the boot is acceptable and should become the next
    "LastKnownGood".

Author:

    Dan Lafferty (danl)     17 Jul-1992

Environment:

    User Mode -Win32


Revision History:

--*/

//
// Includes
//

#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>
#include <tstr.h>       // Unicode string macros
#include <stdio.h>      //  printf

//
// Defines
//

//
// DEBUG MACROS
//
#if DBG

#define DEBUG_STATE 1
#define STATIC

#else

#define DEBUG_STATE 0
#define STATIC static

#endif

//
// The following allow debug print syntax to look like:
//
//   BV_LOG(DEBUG_TRACE, "An error occured %x\n",status)
//

#define BV_LOG0(level, string)                      \
    KdPrintEx((DPFLTR_BOOTVRFY_ID,                  \
               DEBUG_##level,                       \
               "[BootVrfy]" string))

#define BV_LOG1(level, string, var1)                \
    KdPrintEx((DPFLTR_BOOTVRFY_ID,                  \
               DEBUG_##level,                       \
               "[BootVrfy]" string,                 \
               var1))

#define BV_LOG2(level, string, var1, var2)          \
    KdPrintEx((DPFLTR_BOOTVRFY_ID,                  \
               DEBUG_##level,                       \
               "[BootVrfy]" string,                 \
               var1,                                \
               var2))

//
// Debug output is filtered at two levels: A global level and a component
// specific level.
//
// Each debug output request specifies a component id and a filter level
// or mask. These variables are used to access the debug print filter
// database maintained by the system. The component id selects a 32-bit
// mask value and the level either specified a bit within that mask or is
// as mask value itself.
//
// If any of the bits specified by the level or mask are set in either the
// component mask or the global mask, then the debug output is permitted.
// Otherwise, the debug output is filtered and not printed.
//
// The component mask for filtering the debug output of this component is
// Kd_BOOTOK_Mask and may be set via the registry or the kernel debugger.
//
// The global mask for filtering the debug output of all components is
// Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.
//
// The registry key for setting the mask value for this component is:
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\
//     Session Manager\Debug Print Filter\BOOTOK
//
// The key "Debug Print Filter" may have to be created in order to create
// the component key.
//
// The following levels are used to filter debug output.
//

#define DEBUG_ERROR     (0x00000001 | DPFLTR_MASK)
#define DEBUG_TRACE     (0x00000004 | DPFLTR_MASK)

#define DEBUG_ALL       (0xffffffff | DPFLTR_MASK)

VOID __cdecl
main(void)
{
    BOOL    success;

#ifdef SC_CAP       // (For Performance Testing)
    StartCAP();
#endif // SC_CAP

    success = NotifyBootConfigStatus( TRUE);

#ifdef SC_CAP
    StopCAP();
    DumpCAP();
#endif // SC_CAP

    if ( success == FALSE) {
        DWORD       error = GetLastError();
        BV_LOG1( TRACE, "NotifyBootConfigStatus failed, error = %d\n", error);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\client\scwrap.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    scwrap.c

Abstract:

    These are the Service Controller API RPC client wrapper routines.
    These are the entry points that are exported by the dll.
        ControlService
        EnumServicesStatusW
        EnumServicesStatusA
        EnumServicesStatusExW
        EnumServicesStatusExA
        EnumServiceGroupW
        OpenServiceW
        CloseServiceHandle
        OpenSCManagerW
        QueryServiceStatus
        QueryServiceStatusEx
        StartServiceW
        SetServiceStatus
        I_ScSetServiceBitsW
        I_ScSetServiceBitsA
        I_ScGetCurrentGroupStateW
        I_ScSendTSMessage
        SetServiceBits

        OpenSCManagerA
        OpenServiceA
        StartServiceA

        QueryServiceObjectSecurity
        SetServiceObjectSecurity
        ScConvertOffsetsW
        ScConvertOffsetsA
        ScConvertOffsetsExW
        ScConvertOffsetsExA
        ScConvertOffsets64

        ChangeServiceConfigA
        ChangeServiceConfigW
        ChangeServiceConfig2A
        ChangeServiceConfig2W
        CreateServiceA
        CreateServiceW
        DeleteService
        EnumDependentServicesA
        EnumDependentServicesW
        GetServiceDisplayNameA
        GetServiceDisplayNameW
        GetServiceKeyNameA
        GetServiceKeyNameW
        LockServiceDatabase
        QueryServiceConfigA
        QueryServiceConfigW
        QueryServiceConfig2A
        QueryServiceConfig2W
        QueryServiceLockStatusA
        QueryServiceLockStatusW
        UnlockServiceDatabase
        NotifyBootConfigStatus

Author:

    Dan Lafferty    (danl)  03-Feb-1992

Environment:

    User Mode - Win32

Revision History:

    07-May-1998 jschwart
        Added QueryServiceStatusEx and EnumServicesStatusEx
    11-Oct-1996 AnirudhS
        Added ChangeServiceConfig2 and QueryServiceConfig2.
    14-Feb-1996 AnirudhS
        Added EnumServiceGroupW.
    22-Sep-1995 AnirudhS
        ScWaitForStart: Fixed race condition - OpenEvent needs to be tried
        a second time after CreateEvent.
    15-Aug-1995 AnirudhS
        Added I_ScGetCurrentGroupStateW.
    05-Nov-1992 Danl
        Added display name changes (CreateService, ChangeServiceConfig) and
        new api (GetServiceDisplayName, GetServiceKeyName).
    13-Oct-1992 Danl
        Allow 0 length buffers to be passed into EnumServicesStatus and
        EnumDependentServices.
    04-Aug-1992 Danl
        Allow 0 length buffers to be passed into QueryServiceConfig and
        QueryServiceLockStatus.
    28-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.
    14-Apr-1992 JohnRo
        Enable Lock and Unlock APIs.
    03-Feb-1992     Danl
        Created

--*/

//
// INCLUDES
//

extern "C"
{
#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed when we include windows.h
}
#include <rpc.h>        // DataTypes and runtime APIs

#include <windows.h>    // NO_ERROR
#include <svcctl.h>     // generated by the MIDL compiler
#include <lmcons.h>     // for lmserver.h
#include <srvann.h>     // MS-internal functions
#include <winsvcp.h>    // MS-internal functions
#include <rpcasync.h>   // I_RpcExceptionFilter

#include <string.h>     // needed by strarray.h
#include <scdebug.h>    // SCC_LOG
#include <sccrypt.h>    // ScEncryptPassword
#include <sclib.h>      // ScConvertToUnicode
#include <strarray.h>   // ScWStrArraySize
#include <lmerr.h>      // for lmserver.h
#include <lmserver.h>   // SV_TYPE_WORKSTATION ...
#include <scseclib.h>   // ScCreateStartEventSD
#include <scwow.h>      // 32/64-bit interop structures

//
// DEFINES
//
#define SC_START_TIMEOUT    180000      // 3 minute timeout

#define RESERVED_BITS  (SV_TYPE_WORKSTATION         |   \
                        SV_TYPE_SERVER              |   \
                        SV_TYPE_DOMAIN_CTRL         |   \
                        SV_TYPE_DOMAIN_BAKCTRL      |   \
                        SV_TYPE_TIME_SOURCE         |   \
                        SV_TYPE_AFP                 |   \
                        SV_TYPE_DOMAIN_MEMBER       |   \
                        SV_TYPE_PRINTQ_SERVER       |   \
                        SV_TYPE_DIALIN_SERVER       |   \
                        SV_TYPE_XENIX_SERVER        |   \
                        SV_TYPE_SERVER_UNIX         |   \
                        SV_TYPE_NT                  |   \
                        SV_TYPE_WFW                 |   \
                        SV_TYPE_POTENTIAL_BROWSER   |   \
                        SV_TYPE_BACKUP_BROWSER      |   \
                        SV_TYPE_MASTER_BROWSER      |   \
                        SV_TYPE_DOMAIN_MASTER       |   \
                        SV_TYPE_LOCAL_LIST_ONLY     |   \
                        SV_TYPE_DOMAIN_ENUM)



//
// LOCAL FUNCTIONS
//

VOID
ScConvertOffsetsW(
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   NumStructs
    );

VOID
ScConvertOffsetsA(
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   NumStructs
    );

VOID
ScConvertOffsetsExW(
    LPENUM_SERVICE_STATUS_PROCESSW  lpServices,
    DWORD                           NumStructs
    );

VOID
ScConvertOffsetsExA(
    LPENUM_SERVICE_STATUS_PROCESSA  lpServices,
    DWORD                           NumStructs
    );


#ifdef _WIN64

//
// API numbers for ScConvertOffsets64
//

typedef enum
{
    SC_API_ENUM_W = 0,
    SC_API_ENUM_A,
    SC_API_ENUM_GROUP,
    SC_API_ENUM_DEPEND_W,
    SC_API_ENUM_DEPEND_A,
    SC_API_ENUM_PROCESS_W,
    SC_API_ENUM_PROCESS_A,
    SC_API_QUERY_DESCRIPTION_W,
    SC_API_QUERY_DESCRIPTION_A,
    SC_API_QUERY_FAILURE_ACTIONS_W,
    SC_API_QUERY_FAILURE_ACTIONS_A,
    SC_API_MAX
}
SC_API_NUMBER;


BOOL
ScConvertOffsets64(
    SC_API_NUMBER  scApi,
    SC_HANDLE      hSCManager,
    DWORD          dwServiceType,
    DWORD          dwServiceState,
    LPBYTE         lpServices,
    DWORD          cbBufSize,
    LPDWORD        pcbBytesNeeded,
    LPDWORD        lpServicesReturned,
    LPDWORD        lpResumeIndex,
    LPVOID         pszGroupName,
    LPDWORD        lpdwError
    );

#endif // _WIN64


DWORD
ScMapRpcError(
    IN DWORD RpcError,
    IN DWORD BadContextError
    );

DWORD
ScWaitForStart(
    VOID
    );

//
// Globals
//

extern "C"
{

void
SccInit(
	DWORD dwReason
    )
{

    return;
}

}


BOOL
WINAPI
ControlService(
    IN  SC_HANDLE           hService,
    IN  DWORD               dwControl,
    OUT LPSERVICE_STATUS    lpServiceStatus
    )

/*++

Routine Description:

    This is the DLL entrypoint for Control Service

Arguments:


Return Value:



--*/
{
    DWORD      status;


    RpcTryExcept {

        status = RControlService (
                    (SC_RPC_HANDLE)hService,
                    dwControl,
                    lpServiceStatus);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
EnumServicesStatusW(
    IN      SC_HANDLE               hSCManager,
    IN      DWORD                   dwServiceType,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSW  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned,
    IN OUT  LPDWORD                 lpResumeIndex
    )
/*++

Routine Description:

    This is the DLL entrypoint for EnumServicesStatusW

Arguments:


Return Value:


Note:


--*/
{
    return EnumServiceGroupW(
                hSCManager,
                dwServiceType,
                dwServiceState,
                lpServices,
                cbBufSize,
                pcbBytesNeeded,
                lpServicesReturned,
                lpResumeIndex,
                NULL);
}


BOOL
WINAPI
EnumServicesStatusExW(
    IN      SC_HANDLE                  hSCManager,
    IN      SC_ENUM_TYPE               InfoLevel,
    IN      DWORD                      dwServiceType,
    IN      DWORD                      dwServiceState,
    OUT     LPBYTE                     lpServices,
    IN      DWORD                      cbBufSize,
    OUT     LPDWORD                    pcbBytesNeeded,
    OUT     LPDWORD                    lpServicesReturned,
    IN OUT  LPDWORD                    lpResumeIndex,
    IN      LPCWSTR                    pszGroupName
    )
/*++

Routine Description:

    This is the DLL entrypoint for EnumServicesStatusExW

Arguments:


Return Value:


Note:


--*/
{
    DWORD                           status;
    LPENUM_SERVICE_STATUS_PROCESSW  pEnumBuf;
    ENUM_SERVICE_STATUS_PROCESSW    enumBuf;
    DWORD                           tempBufSize;

#ifdef _WIN64

    DWORD                           dwOldResumeIndex = 0;

    if (lpResumeIndex != NULL)
    {
        dwOldResumeIndex = *lpResumeIndex;
    }

#endif // _WIN64

    //
    // Make sure we were passed a valid InfoLevel
    //
    if (InfoLevel != SC_ENUM_PROCESS_INFO)
    {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUS_PROCESSW) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUS_PROCESSW);
    }
    else {
        pEnumBuf = (LPENUM_SERVICE_STATUS_PROCESSW)lpServices;
    }


    RpcTryExcept {

        status = REnumServicesStatusExW (
                        hSCManager,
                        InfoLevel,
                        dwServiceType,
                        dwServiceState,
                        (LPBYTE)pEnumBuf,
                        tempBufSize,
                        pcbBytesNeeded,
                        lpServicesReturned,
                        lpResumeIndex,
                        pszGroupName);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_PROCESS_W,
                                    hSCManager,
                                    dwServiceType,
                                    dwServiceState,
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    &dwOldResumeIndex,
                                    (LPVOID) pszGroupName,
                                    &dwError))
            {
                status = dwError;

                if (lpResumeIndex != NULL)
                {
                    *lpResumeIndex = dwOldResumeIndex;
                }
            }

#else  // ndef _WIN64

            ScConvertOffsetsExW((LPENUM_SERVICE_STATUS_PROCESSW) lpServices,
                                *lpServicesReturned);

#endif // _WIN64

        }

#ifdef _WIN64

        //
        // The byte count returned is the size needed to hold all of
        // the 32-bit structures rather than the 64-bit ones.  Assume
        // a buffer full of fixed-length structures (i.e., no variable-
        // length data) and scale from 32- to 64-bit sizes to get the
        // minimum guaranteed size for all the 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUS_PROCESSW)
                              / sizeof(ENUM_SERVICE_STATUS_PROCESS_WOW64);

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
EnumServiceGroupW(
    IN      SC_HANDLE               hSCManager,
    IN      DWORD                   dwServiceType,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSW  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned,
    IN OUT  LPDWORD                 lpResumeIndex,
    IN      LPCWSTR                 pszGroupName
    )
/*++

Routine Description:

    This is the DLL entrypoint for EnumServiceGroupW

Arguments:


Return Value:


Note:

--*/
{
    DWORD                   status;
    LPENUM_SERVICE_STATUSW  pEnumBuf;
    ENUM_SERVICE_STATUSW    enumBuf;
    DWORD                   tempBufSize;

#ifdef _WIN64

    DWORD                   dwOldResumeIndex = 0;

    if (lpResumeIndex != NULL)
    {
        dwOldResumeIndex = *lpResumeIndex;
    }

#endif // _WIN64


    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUSW) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUSW);
    }
    else {
        pEnumBuf = lpServices;
    }


    RpcTryExcept {

        if (pszGroupName == NULL) {
            //
            // Call the downlevel API, so that the call will work on targeted
            // machines running Windows NT 3.51 or earlier
            //
            status = REnumServicesStatusW (
                        (SC_RPC_HANDLE)hSCManager,
                        dwServiceType,
                        dwServiceState,
                        (LPBYTE)pEnumBuf,
                        tempBufSize,
                        pcbBytesNeeded,
                        lpServicesReturned,
                        lpResumeIndex);
        }
        else {
            status = REnumServiceGroupW (
                        (SC_RPC_HANDLE)hSCManager,
                        dwServiceType,
                        dwServiceState,
                        (LPBYTE)pEnumBuf,
                        tempBufSize,
                        pcbBytesNeeded,
                        lpServicesReturned,
                        lpResumeIndex,
                        pszGroupName);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(pszGroupName ? SC_API_ENUM_GROUP :
                                                   SC_API_ENUM_W,
                                    hSCManager,
                                    dwServiceType,
                                    dwServiceState,
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    &dwOldResumeIndex,
                                    (LPVOID) pszGroupName,
                                    &dwError))
            {
                status = dwError;

                if (lpResumeIndex != NULL)
                {
                    *lpResumeIndex = dwOldResumeIndex;
                }
            }

#else  // ndef _WIN64

            ScConvertOffsetsW(lpServices, *lpServicesReturned);

#endif // _WIN64

        }

#ifdef _WIN64

        //
        // The byte count returned is the size needed to hold all of
        // the 32-bit structures rather than the 64-bit ones.  Assume
        // a buffer full of fixed-length structures (i.e., no variable-
        // length data) and scale from 32- to 64-bit sizes to get the
        // minimum guaranteed size for all the 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUSW)
                              / sizeof(ENUM_SERVICE_STATUS_WOW64);

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


SC_HANDLE
WINAPI
OpenServiceW(
    IN  SC_HANDLE   hSCManager,
    IN  LPCWSTR     lpServiceName,
    IN  DWORD       dwDesiredAccess
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/

{
    DWORD           status;
    SC_RPC_HANDLE   hService=NULL;


    RpcTryExcept {

        status = ROpenServiceW (
                    (SC_RPC_HANDLE)hSCManager,
                    (LPWSTR) lpServiceName,
                    dwDesiredAccess,
                    &hService);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)hService;
}

BOOL
WINAPI
CloseServiceHandle(
    IN  SC_HANDLE   hSCObject
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/

{
    DWORD      status;


    RpcTryExcept {

        status = RCloseServiceHandle((LPSC_RPC_HANDLE)&hSCObject);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


SC_HANDLE
WINAPI
OpenSCManagerW(
    IN  LPCWSTR lpMachineName,
    IN  LPCWSTR lpDatabaseName OPTIONAL,
    IN  DWORD   dwDesiredAccess
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD           status;
    SC_RPC_HANDLE   ScHandle=NULL;


    //
    // Check to see if the local Service Controller is started yet.
    // If not, then wait for it to start (or timeout).
    //

    status = ScWaitForStart();

    if (status != NO_ERROR) {
        SetLastError(status);
        return(NULL);
    }

    RpcTryExcept {

        status = ROpenSCManagerW (
                    (LPWSTR) lpMachineName,
                    (LPWSTR) lpDatabaseName,
                    dwDesiredAccess,
                    &ScHandle);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)ScHandle;
}

BOOL
WINAPI
QueryServiceStatus(
    IN  SC_HANDLE           hService,
    OUT LPSERVICE_STATUS    lpServiceStatus
    )
/*++

Routine Description:

    This is the DLL entrypoint for QueryServiceStatus.

Arguments:


Return Value:


--*/

{
    DWORD          status;

    RpcTryExcept {

        status = RQueryServiceStatus (
            (SC_RPC_HANDLE)hService,
            lpServiceStatus);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
QueryServiceStatusEx(
    IN      SC_HANDLE       hService,
    IN      SC_STATUS_TYPE  InfoLevel,
    OUT     LPBYTE          lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded
    )
/*++

Routine Description:

    This is the DLL entrypoint for QueryServiceStatusEx.

Arguments:


Return Value:


Note:

--*/
{
    DWORD                        status;

    switch (InfoLevel) {

        case SC_STATUS_PROCESS_INFO:

            if (cbBufSize < sizeof(SERVICE_STATUS_PROCESS)) {

                //
                // The buffer is too small -- since the structure is a fixed
                // size, we can handle this error on the client side
                //
                *pcbBytesNeeded = sizeof(SERVICE_STATUS_PROCESS);

                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }

            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }

    RpcTryExcept {

        status = RQueryServiceStatusEx (
            (SC_RPC_HANDLE)hService,
            InfoLevel,
            lpBuffer,
            cbBufSize,
            pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
StartServiceW(
    IN SC_HANDLE            hService,
    IN DWORD                dwNumServiceArgs,
    IN LPCWSTR              *lpServiceArgVectors
    )
/*++

Routine Description:

    This is the DLL entrypoint for StartServiceW

Arguments:

    servername - Points to a string containing the name of the computer
        that is to execute the API function.

    service- Points to a string containing the name of the service
        that is to be started.

    argc - Indicates the number or argument vectors in argv.

    argv - A pointer to an array of pointers to strings.  These
        are command line arguments that are to be passed to the service.

    bufptr - This is the address where a pointer to the service's
        information buffer (SERVICE_INFO_2) is to be placed.

Return Value:



--*/

{
    DWORD          status;



    RpcTryExcept {

        status = RStartServiceW (
                    (SC_RPC_HANDLE)hService,
                    dwNumServiceArgs,
                    (LPSTRING_PTRSW)lpServiceArgVectors);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
SetServiceStatus(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN LPSERVICE_STATUS         lpServiceStatus
    )
/*++

Routine Description:

    This is the DLL entrypoint for SetServiceStatus.  It is called from
    a service when that service changes its state or receives a control.
    The status is maintained by the service controller.

Arguments:

    hServiceStatus - This is a handle that was obtained from calling
        the RegisterControlHandler function.

    lpServiceStatus - This is a pointer to a service status structure.

Return Value:


--*/
{
    DWORD      status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {
        status = RSetServiceStatus (
                    (SC_HANDLE)hServiceStatus,
                    lpServiceStatus);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED) {

        //
        // Service is stopping -- close the handle we opened
        // in StartServiceCtrlDispatcher when the service started
        //
        CloseServiceHandle((SC_HANDLE)hServiceStatus);
    }

    return(TRUE);
}

BOOL
I_ScSetServiceBitsA(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately,
    IN LPSTR                    pszTransportName
    )

/*++

Routine Description:

    This is an internal routine that sets the Server Announcement bits
    in the service controller.

Arguments:

    hServiceStatus -

    dwServiceBits -

Return Value:


Note:


--*/
{
    DWORD   status;
    DWORD   setBitsOnFlag=0;
    DWORD   updateImmediatelyFlag=0;

    if(bSetBitsOn) {
        setBitsOnFlag = 1;
    }

    if(bUpdateImmediately) {
        updateImmediatelyFlag = 1;
    }
    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {
        status = RI_ScSetServiceBitsA (
                    (SC_HANDLE)hServiceStatus,
                    dwServiceBits,
                    setBitsOnFlag,
                    updateImmediatelyFlag,
                    pszTransportName);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}

BOOL
I_ScSetServiceBitsW(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately,
    IN LPWSTR                   pszTransportName
    )

/*++

Routine Description:

    This is an internal routine that sets the Server Announcement bits
    in the service controller.

Arguments:

    hServiceStatus -

    dwServiceBits -

Return Value:


Note:


--*/
{
    DWORD   status;
    DWORD   setBitsOnFlag=0;
    DWORD   updateImmediatelyFlag=0;

    if(bSetBitsOn) {
        setBitsOnFlag = 1;
    }

    if(bUpdateImmediately) {
        updateImmediatelyFlag = 1;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {
        status = RI_ScSetServiceBitsW (
                    (SC_HANDLE)hServiceStatus,
                    dwServiceBits,
                    setBitsOnFlag,
                    updateImmediatelyFlag,
                    pszTransportName);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


DWORD
I_ScGetCurrentGroupStateW(
    IN  SC_HANDLE               hSCManager,
    IN  LPWSTR                  pszGroupName,
    OUT LPDWORD                 pdwCurrentState
    )
/*++

Routine Description:

    This is obsolete but some (MS) apps still statically link to it.

--*/
{
    return ERROR_NOT_SUPPORTED;
}


extern "C" {

DWORD
I_ScSendTSMessage(
    DWORD        OpCode,
    DWORD        dwEvent,
    DWORD        cbData,
    LPBYTE       lpData
    )

/*++

Routine Description:

    Private entrypoint for Terminal Server to tell the SCM to send
    console switch notification to services that are interested.

--*/

{
    DWORD     status;
    SC_HANDLE hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCManager == NULL)
    {
        return GetLastError();
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept
    {
        status = RI_ScSendTSMessage(hSCManager,
                                    OpCode,
                                    dwEvent,
                                    cbData,
                                    lpData);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    CloseServiceHandle(hSCManager);

    return status;
}

}  // extern "C"


BOOL
SetServiceBits(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately
    )

/*++

Routine Description:

    This is an internal routine that sets the Server Announcement bits
    in the service controller.

Arguments:

    hServiceStatus -

    dwServiceBits -

Return Value:


Note:


--*/
{
    if (dwServiceBits & RESERVED_BITS) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }
    return(I_ScSetServiceBitsW(
            hServiceStatus,
            dwServiceBits,
            bSetBitsOn,
            bUpdateImmediately,
            (LPWSTR)NULL));
}


SC_HANDLE
WINAPI
OpenSCManagerA(
    IN  LPCSTR  lpMachineName,
    IN  LPCSTR  lpDatabaseName OPTIONAL,
    IN  DWORD   dwDesiredAccess
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD           status;
    SC_RPC_HANDLE   ScHandle=NULL;


    //
    // Check to see if the local Service Controller is started yet.
    // If not, then wait for it to start (or timeout).
    //

    status = ScWaitForStart();

    if (status != NO_ERROR) {
        SetLastError(status);
        return(NULL);
    };


    RpcTryExcept {

        status = ROpenSCManagerA (
                    (LPSTR) lpMachineName,
                    (LPSTR) lpDatabaseName,
                    dwDesiredAccess,
                    &ScHandle);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)ScHandle;
}



SC_HANDLE
WINAPI
OpenServiceA(
    IN  SC_HANDLE   hSCManager,
    IN  LPCSTR      lpServiceName,
    IN  DWORD       dwDesiredAccess
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    DWORD           status;
    SC_RPC_HANDLE   hService=NULL;


    RpcTryExcept {

        status = ROpenServiceA (
                    (SC_RPC_HANDLE)hSCManager,
                    (LPSTR) lpServiceName,
                    dwDesiredAccess,
                    &hService);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)hService;
}



BOOL
WINAPI
StartServiceA(
    IN SC_HANDLE            hService,
    IN DWORD                dwNumServiceArgs,
    IN LPCSTR               *lpServiceArgVectors
    )
/*++

Routine Description:



Arguments:

    servername - Points to a string containing the name of the computer
        that is to execute the API function.

    service- Points to a string containing the name of the service
        that is to be started.

    argc - Indicates the number or argument vectors in argv.

    argv - A pointer to an array of pointers to strings.  These
        are command line arguments that are to be passed to the service.

    bufptr - This is the address where a pointer to the service's
        information buffer (SERVICE_INFO_2) is to be placed.

Return Value:



--*/
{
    DWORD          status;

    RpcTryExcept {

        status = RStartServiceA (
                    (SC_RPC_HANDLE)hService,
                    dwNumServiceArgs,
                    (LPSTRING_PTRSA)lpServiceArgVectors);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}



BOOL
WINAPI
EnumServicesStatusA(
    IN      SC_HANDLE               hSCManager,
    IN      DWORD                   dwServiceType,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSA  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned,
    IN OUT  LPDWORD                 lpResumeIndex
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    DWORD                   status;
    LPENUM_SERVICE_STATUSA  pEnumBuf;
    ENUM_SERVICE_STATUSA    enumBuf;
    DWORD                   tempBufSize;

#ifdef _WIN64

    DWORD                   dwOldResumeIndex = 0;

    if (lpResumeIndex != NULL)
    {
        dwOldResumeIndex = *lpResumeIndex;
    }

#endif // _WIN64


    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUSA) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUSA);
    }
    else {
        pEnumBuf = lpServices;
    }

    RpcTryExcept {

        status = REnumServicesStatusA (
                    (SC_RPC_HANDLE)hSCManager,
                    dwServiceType,
                    dwServiceState,
                    (LPBYTE)pEnumBuf,
                    tempBufSize,
                    pcbBytesNeeded,
                    lpServicesReturned,
                    lpResumeIndex);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_A,
                                    hSCManager,
                                    dwServiceType,
                                    dwServiceState,
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    &dwOldResumeIndex,
                                    NULL,
                                    &dwError))
            {
                status = dwError;

                if (lpResumeIndex != NULL)
                {
                    *lpResumeIndex = dwOldResumeIndex;
                }
            }

#else  // ndef _WIN64

            ScConvertOffsetsA(lpServices, *lpServicesReturned);

#endif // _WIN64

        }

#ifdef _WIN64

        //
        // The byte count returned is the size needed to hold all of
        // the 32-bit structures rather than the 64-bit ones.  Assume
        // a buffer full of fixed-length structures (i.e., no variable-
        // length data) and scale from 32- to 64-bit sizes to get the
        // minimum guaranteed size for all the 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUSA)
                              / sizeof(ENUM_SERVICE_STATUS_WOW64);

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
EnumServicesStatusExA(
    IN      SC_HANDLE                  hSCManager,
    IN      SC_ENUM_TYPE               InfoLevel,
    IN      DWORD                      dwServiceType,
    IN      DWORD                      dwServiceState,
    OUT     LPBYTE                     lpServices,
    IN      DWORD                      cbBufSize,
    OUT     LPDWORD                    pcbBytesNeeded,
    OUT     LPDWORD                    lpServicesReturned,
    IN OUT  LPDWORD                    lpResumeIndex,
    IN      LPCTSTR                    pszGroupName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    DWORD                           status;
    LPENUM_SERVICE_STATUS_PROCESSA  pEnumBuf;
    ENUM_SERVICE_STATUS_PROCESSA    enumBuf;
    DWORD                           tempBufSize;

#ifdef _WIN64

    DWORD                           dwOldResumeIndex = 0;

    if (lpResumeIndex != NULL)
    {
        dwOldResumeIndex = *lpResumeIndex;
    }

#endif // _WIN64


    //
    // Make sure we were passed a valid InfoLevel
    //
    if (InfoLevel != SC_ENUM_PROCESS_INFO)
    {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUS_PROCESSA) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUS_PROCESSA);
    }
    else {
        pEnumBuf = (LPENUM_SERVICE_STATUS_PROCESSA) lpServices;
    }

    RpcTryExcept {

        status = REnumServicesStatusExA (
                    (SC_RPC_HANDLE)hSCManager,
                    InfoLevel,
                    dwServiceType,
                    dwServiceState,
                    (LPBYTE)pEnumBuf,
                    tempBufSize,
                    pcbBytesNeeded,
                    lpServicesReturned,
                    lpResumeIndex,
                    pszGroupName);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_PROCESS_A,
                                    hSCManager,
                                    dwServiceType,
                                    dwServiceState,
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    &dwOldResumeIndex,
                                    (LPVOID) pszGroupName,
                                    &dwError))
            {
                status = dwError;

                if (lpResumeIndex != NULL)
                {
                    *lpResumeIndex = dwOldResumeIndex;
                }
            }

#else  // ndef _WIN64

            ScConvertOffsetsExA((LPENUM_SERVICE_STATUS_PROCESSA) lpServices,
                                *lpServicesReturned);

#endif // _WIN64

        }

#ifdef _WIN64

        //
        // The byte count returned is the size needed to hold all of
        // the 32-bit structures rather than the 64-bit ones.  Assume
        // a buffer full of fixed-length structures (i.e., no variable-
        // length data) and scale from 32- to 64-bit sizes to get the
        // minimum guaranteed size for all the 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUS_PROCESSA)
                              / sizeof(ENUM_SERVICE_STATUS_PROCESS_WOW64);

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
QueryServiceObjectSecurity(
    IN  SC_HANDLE hService,
    IN  SECURITY_INFORMATION dwSecurityInformation,
    OUT PSECURITY_DESCRIPTOR lpSecurityDescriptor,
    IN  DWORD cbBufSize,
    OUT LPDWORD pcbBytesNeeded
    )
/*++

Routine Description:

    This is the DLL entrypoint for the QueryServiceObjectSecurity API.

    This function returns to the caller requested security information
    currently assigned to an object.

    Based on the caller's access rights this procedure
    will return a security descriptor containing any or all of the
    object's owner ID, group ID, discretionary ACL or system ACL.  To
    read the owner ID, group ID, or the discretionary ACL the caller
    must be granted READ_CONTROL access to the object.  To read the
    system ACL the caller must be granted ACCESS_SYSTEM_SECURITY
    access.

Arguments:

    hService - Supplies a handle to an existing service object.

    dwSecurityInformation - Supplies a value describing which pieces of
        security information are being queried.

    lpSecurityInformation - Supplies the output buffer from the user
        which security descriptor information will be written to on
        return.

    cbBufSize - Supplies the size of lpSecurityInformation buffer.

    pcbBytesNeeded - Returns the number of bytes needed of the
        lpSecurityInformation buffer to get all the requested
        information.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened for
        either READ_CONTROL or ACCESS_SYSTEM_SECURITY
        access.

    ERROR_INVALID_PARAMETER - The dwSecurityInformation parameter is
        invalid.

    ERROR_INSUFFICIENT_BUFFER - The specified output buffer is smaller
        than the required size returned in pcbBytesNeeded.  None of
        the security descriptor is returned.

--*/
{
    DWORD status;

    RpcTryExcept {

        status = RQueryServiceObjectSecurity(
                     (SC_RPC_HANDLE) hService,
                     (DWORD) dwSecurityInformation,
                     (LPBYTE) lpSecurityDescriptor,
                     cbBufSize,
                     pcbBytesNeeded
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
SetServiceObjectSecurity(
    IN SC_HANDLE hService,
    IN SECURITY_INFORMATION dwSecurityInformation,
    IN PSECURITY_DESCRIPTOR lpSecurityDescriptor
    )
/*++

Routine Description:

    This is the DLL entrypoint for the SetServiceObjectSecurity API.

    This function takes a well-formed Security Descriptor provided by the
    caller and assigns specified portions of it to an existing service
    object.  Based on the flags set in the SecurityInformation
    parameter and the caller's access rights, this procedure will
    replace any or all of the security information associated with an
    object.

    This is the only function available to users and applications for
    changing security information, including the owner ID, group ID, and
    the discretionary and system ACLs of an object.  The caller must
    have WRITE_OWNER access to the object to change the owner or primary
    group of the object.  The caller must have WRITE_DAC access to the
    object to change the discretionary ACL.  The caller must have
    ACCESS_SYSTEM_SECURITY access to an object to assign a system ACL
    to the object.

Parameters:

    hService - Supplies a handle to an existing service object.

    dwSecurityInformation - Supplies a value describing which pieces of
        security information are being set.

    lpSecurityInformation - Supplies a pointer to a well-formed security
        descriptor.


Return Values:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened for
        either WRITE_OWNER, WRITE_DAC, or ACCESS_SYSTEM_SECURITY
        access.

    ERROR_INVALID_PARAMETER - The lpSecurityDescriptor or dwSecurityInformation
        parameter is invalid.

    ERROR_NOT_ENOUGH_MEMORY - Not enough memory to complete the API call.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    DWORD UserSdSize = 0;
    PSECURITY_DESCRIPTOR SelfRelativeSd;


    //
    // Find out the length of the user supplied security descriptor
    //
    ntstatus = RtlMakeSelfRelativeSD(
                   lpSecurityDescriptor,
                   NULL,
                   &UserSdSize
                   );

    if (ntstatus != STATUS_BUFFER_TOO_SMALL) {

        //
        // lpSecurityDescriptor is invalid
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SelfRelativeSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_ZEROINIT, (UINT) UserSdSize);

    if (SelfRelativeSd == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Make a self-relative security descriptor for the RPC call
    //
    ntstatus = RtlMakeSelfRelativeSD(
                   lpSecurityDescriptor,
                   SelfRelativeSd,
                   &UserSdSize
                   );

    if (! NT_SUCCESS(ntstatus)) {
        LocalFree(SelfRelativeSd);
        SetLastError(RtlNtStatusToDosError(ntstatus));
        return(FALSE);
    }


    //
    // Call the server
    //
    RpcTryExcept {

        status = RSetServiceObjectSecurity(
                     (SC_RPC_HANDLE) hService,
                     (DWORD) dwSecurityInformation,
                     (LPBYTE) SelfRelativeSd,
                     UserSdSize
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    (void) LocalFree(SelfRelativeSd);

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


VOID
ScConvertOffsetsW(
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   NumStructs
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPBYTE  pBuffer;
    DWORD   i;

    pBuffer = (LPBYTE)lpServices;

    for (i=0; i<NumStructs; i++ ) {
        lpServices[i].lpServiceName = (LPWSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpServiceName));
        lpServices[i].lpDisplayName = (LPWSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpDisplayName));
    }
}

VOID
ScConvertOffsetsA(
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   NumStructs
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPBYTE  pBuffer;
    DWORD   i;

    pBuffer = (LPBYTE)lpServices;

    for (i=0; i<NumStructs; i++ ) {
        lpServices[i].lpServiceName = (LPSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpServiceName));
        lpServices[i].lpDisplayName = (LPSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpDisplayName));
    }
}

VOID
ScConvertOffsetsExW(
    LPENUM_SERVICE_STATUS_PROCESSW  lpServices,
    DWORD                      NumStructs
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPBYTE  pBuffer;
    DWORD   i;

    pBuffer = (LPBYTE)lpServices;

    for (i=0; i<NumStructs; i++ ) {
        lpServices[i].lpServiceName = (LPWSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpServiceName));
        lpServices[i].lpDisplayName = (LPWSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpDisplayName));
    }
}

VOID
ScConvertOffsetsExA(
    LPENUM_SERVICE_STATUS_PROCESSA  lpServices,
    DWORD                      NumStructs
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPBYTE  pBuffer;
    DWORD   i;

    pBuffer = (LPBYTE)lpServices;

    for (i=0; i<NumStructs; i++ ) {
        lpServices[i].lpServiceName = (LPSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpServiceName));
        lpServices[i].lpDisplayName = (LPSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpDisplayName));
    }
}


#ifdef _WIN64

BOOL
ScConvertOffsets64(
    SC_API_NUMBER  scApi,
    SC_HANDLE      hSCManager,
    DWORD          dwServiceType,
    DWORD          dwServiceState,
    LPBYTE         lpServices,
    DWORD          cbBufSize,
    LPDWORD        pcbBytesNeeded,
    LPDWORD        lpServicesReturned,
    LPDWORD        lpResumeIndex,
    LPVOID         pszGroupName,
    LPDWORD        lpdwError
    )
/*++

Routine Description:

    Perform API-specific offset-to-pointer conversions for the
    client side of the SCM APIs on 64-bit clients.

Arguments:



Return Value:

    TRUE if the conversion succeeded, FALSE otherwise (with lpdwError
    holding the true error).

--*/
{
    switch (scApi)
    {
        case SC_API_ENUM_W:
        case SC_API_ENUM_A:
        case SC_API_ENUM_GROUP:
        case SC_API_ENUM_PROCESS_W:
        case SC_API_ENUM_PROCESS_A:
        case SC_API_ENUM_DEPEND_W:
        case SC_API_ENUM_DEPEND_A:
        {
            //
            // Convert buffer returned by EnumServicesStatusW
            //

            LPBYTE  lpIter = lpServices;
            LPBYTE  lpConverted;
            DWORD   dwCount64;
            DWORD   dwTotalVarData = 0;
            DWORD   dwSize64 = 0;
            DWORD   dwStatusSize;
            DWORD   dwStrucSize64;
            DWORD   dwStrucSizeWOW;

            if (scApi == SC_API_ENUM_PROCESS_W || scApi == SC_API_ENUM_PROCESS_A)
            {
                dwStrucSize64  = sizeof(ENUM_SERVICE_STATUS_PROCESSW);
                dwStrucSizeWOW = sizeof(ENUM_SERVICE_STATUS_PROCESS_WOW64);
                dwStatusSize   = sizeof(SERVICE_STATUS_PROCESS);
            }
            else
            {
                dwStrucSize64  = sizeof(ENUM_SERVICE_STATUSW);
                dwStrucSizeWOW = sizeof(ENUM_SERVICE_STATUS_WOW64);
                dwStatusSize   = sizeof(SERVICE_STATUS);
            }

            for (dwCount64 = 0;
                 dwCount64 < *lpServicesReturned;
                 dwCount64++, lpIter += dwStrucSizeWOW)
            {
                DWORD  dwCurrentVarData;
                DWORD  dwOffset;

                //
                // Compute size of this record's variable-length data
                //

                dwOffset = ((LPENUM_SERVICE_STATUS_WOW64) lpIter)->dwDisplayNameOffset;

                dwCurrentVarData = cbBufSize - dwOffset - dwTotalVarData;


                //
                // Is there room to expand the current record to 64-bit pointers?
                //

                if (dwSize64 + dwStrucSize64 + dwCurrentVarData > cbBufSize)
                {
                    //
                    // Nope.
                    //

                    break;
                }

                //
                // Update the total number of variable-length data bytes
                // in the post-conversion buffer
                //

                dwTotalVarData += dwCurrentVarData;

                dwSize64 += dwStrucSize64 + dwCurrentVarData;
            }


            //
            // Set up the pointer to the last soon-to-be-converted structure.
            // Cast to INT to sign-extend the offset to 64 bits (required
            // when (dwCount64 == 0) or else the sum gets bizarre).
            //


            lpIter      = lpServices + (INT) (dwStrucSizeWOW * (dwCount64 - 1));
            lpConverted = lpServices + (INT) (dwStrucSize64 * (dwCount64 - 1));


            for ( ;
                  lpIter >= lpServices;
                  lpIter -= dwStrucSizeWOW, lpConverted -= dwStrucSize64)
            {
                LPENUM_SERVICE_STATUSW      lpEnum = (LPENUM_SERVICE_STATUSW) lpConverted;
                LPENUM_SERVICE_STATUS_WOW64 lpEnumWOW = (LPENUM_SERVICE_STATUS_WOW64) lpIter;

                //
                // Copy fields individually in reverse order in case there's overlap
                //

                RtlMoveMemory(&lpEnum->ServiceStatus,
                              &lpEnumWOW->ServiceStatus,
                              dwStatusSize);

                //
                // Do the offset-to-pointer conversion.  Can do straight addition
                // since we didn't move the variable length data.
                //

                lpEnum->lpDisplayName = (LPWSTR) (lpServices + lpEnumWOW->dwDisplayNameOffset);
                lpEnum->lpServiceName = (LPWSTR) (lpServices + lpEnumWOW->dwServiceNameOffset);
            }

            ASSERT(lpIter < lpServices && lpConverted < lpServices);

            if (*lpServicesReturned != dwCount64)
            {
                //
                // Not enough room to fit all the records returned.  Update
                // all the OUT parameters.  Add on the size of the overwritten
                // records' variable-length data first.
                //

                *pcbBytesNeeded += (cbBufSize
                                     - dwTotalVarData
                                     - *lpServicesReturned * dwStrucSizeWOW);

                //
                // And now do the fixed-length data.  Use the 32-bit structures
                // and the caller will multiply it up to 64-bit lengths.
                //

                *pcbBytesNeeded += (*lpServicesReturned - dwCount64)
                                       * dwStrucSizeWOW;

                //
                // Update the count of services returned
                //

                *lpServicesReturned = dwCount64;

                if (scApi == SC_API_ENUM_DEPEND_W || scApi == SC_API_ENUM_DEPEND_A)
                {
                    *lpdwError = ERROR_MORE_DATA;
                    return FALSE;
                }


                //
                // And now things get ugly.  We need to update the resume index
                // since we removed some services from the buffer.  However,
                // there's no easy way to get the resume index of a particular
                // service from the server side.  So we have to build up an
                // enum buffer that's just small enough to hold only the records
                // we're going to return and enum again just to get the RI.
                //

                LPBYTE  lpTemp;
                DWORD   status;
                DWORD   dwTempBytes;
                DWORD   dwTempCount;
                DWORD   dwTempSize = dwCount64 * dwStrucSizeWOW + dwTotalVarData;

                lpTemp = (LPBYTE) LocalAlloc(LMEM_FIXED, dwTempSize);

                if (lpTemp == NULL)
                {
                    *lpdwError = ERROR_NOT_ENOUGH_MEMORY;
                    return FALSE;
                }

                RpcTryExcept
                {
                    switch (scApi)
                    {
                        case SC_API_ENUM_W:

                            status = REnumServicesStatusW (
                                        (SC_RPC_HANDLE) hSCManager,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex);

                             break;

                        case SC_API_ENUM_A:

                            status = REnumServicesStatusA (
                                        (SC_RPC_HANDLE) hSCManager,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex);

                             break;

                        case SC_API_ENUM_GROUP:

                            status = REnumServiceGroupW (
                                        (SC_RPC_HANDLE) hSCManager,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex,
                                        (LPCWSTR) pszGroupName);

                            break;

                        case SC_API_ENUM_PROCESS_W:

                            status = REnumServicesStatusExW (
                                        hSCManager,
                                        SC_ENUM_PROCESS_INFO,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex,
                                        (LPCWSTR) pszGroupName);

                             break;

                        case SC_API_ENUM_PROCESS_A:

                            status = REnumServicesStatusExA (
                                        hSCManager,
                                        SC_ENUM_PROCESS_INFO,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex,
                                        (LPCSTR) pszGroupName);

                             break;

                        default:

                            ASSERT(FALSE && "Unsupported API in ScConvertOffsets64 enum path");
                            status = ERROR_NOT_SUPPORTED;
                    }
                }
                RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                {
                    status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
                }
                RpcEndExcept

                LocalFree(lpTemp);

                //
                // We had to overwrite at least one structure so we need
                // to return some form of error, even if it's ERROR_MORE_DATA.
                //

                *lpdwError = status;
                return FALSE;
            }

            return TRUE;
            break;
        }

        case SC_API_QUERY_DESCRIPTION_W:
        case SC_API_QUERY_DESCRIPTION_A:
        {
            DWORD  dwBytesNeeded = *pcbBytesNeeded;
            DWORD  dwSizeDiff    = sizeof(SERVICE_DESCRIPTIONW) - sizeof(SERVICE_DESCRIPTION_WOW64);

            LPSERVICE_DESCRIPTION_WOW64  psdWOW = (LPSERVICE_DESCRIPTION_WOW64) lpServices;
            LPSERVICE_DESCRIPTIONW       psd    = (LPSERVICE_DESCRIPTIONW) lpServices;

            //
            // *pcbBytesNeeded is filled in on success or "buffer too small"
            // failure, so update it with the 64-bit size.
            //

            *pcbBytesNeeded += dwSizeDiff;

            if (*pcbBytesNeeded > cbBufSize)
            {
                return FALSE;
            }

            //
            // We have room -- move the variable-length data
            //

            RtlMoveMemory(psd + 1,
                          psdWOW + 1,
                          dwBytesNeeded - sizeof(SERVICE_DESCRIPTION_WOW64));

            //
            // Resize the offset from 4 to 8 bytes.
            //

            if (psdWOW->dwDescriptionOffset == 0)
            {
                psd->lpDescription = NULL;
            }
            else
            {
                psd->lpDescription = (LPWSTR) UlongToPtr(psdWOW->dwDescriptionOffset + dwSizeDiff);
            }

            return TRUE;
        }

        case SC_API_QUERY_FAILURE_ACTIONS_W:                          
        case SC_API_QUERY_FAILURE_ACTIONS_A:
        {
            DWORD dwBytesNeeded = *pcbBytesNeeded;
            DWORD dwSizeDiff    = sizeof(SERVICE_FAILURE_ACTIONSW) - sizeof(SERVICE_FAILURE_ACTIONS_WOW64);

            LPSERVICE_FAILURE_ACTIONS_WOW64 psfaWOW = (LPSERVICE_FAILURE_ACTIONS_WOW64) lpServices;
            LPSERVICE_FAILURE_ACTIONSW      psfa    = (LPSERVICE_FAILURE_ACTIONSW) lpServices;

            //
            // *pcbBytesNeeded is filled in on success or "buffer too small"
            // failure, so update it with the 64-bit size.
            //

            *pcbBytesNeeded += dwSizeDiff;

            if (*pcbBytesNeeded > cbBufSize)
            {
                return FALSE;
            }

            //
            // We have room -- move the variable-length data
            //

            RtlMoveMemory(psfa + 1,
                          psfaWOW + 1,
                          dwBytesNeeded - sizeof(SERVICE_FAILURE_ACTIONS_WOW64));

            //
            // Resize the offsets from 4 to 8 bytes.  Do this in reverse field order
            // to avoid trampling over any still-to-be-converted offsets.
            //

            if (psfaWOW->dwsaActionsOffset == 0)
            {
                psfa->lpsaActions = NULL;
            }
            else
            {
                psfa->lpsaActions = (SC_ACTION *) UlongToPtr(psfaWOW->dwsaActionsOffset + dwSizeDiff);
            }

            psfa->cActions = psfaWOW->cActions;

            if (psfaWOW->dwCommandOffset == 0)
            {
                psfa->lpCommand = NULL;
            }
            else
            {
                psfa->lpCommand = (LPWSTR) UlongToPtr(psfaWOW->dwCommandOffset + dwSizeDiff);
            }

            if (psfaWOW->dwRebootMsgOffset == 0)
            {
                psfa->lpRebootMsg = NULL;
            }
            else
            {
                psfa->lpRebootMsg = (LPWSTR) UlongToPtr(psfaWOW->dwRebootMsgOffset + dwSizeDiff);
            }

            psfa->dwResetPeriod = psfaWOW->dwResetPeriod;

            return TRUE;
        }

        default:
            ASSERT(FALSE && "Unsupported API passed to ScConvertOffsets64");
            *lpdwError = ERROR_NOT_SUPPORTED;
            return FALSE;
    }
}

#endif  // _WIN64    


BOOL
WINAPI
ChangeServiceConfigA(
    IN  SC_HANDLE    hService,
    IN  DWORD        dwServiceType,
    IN  DWORD        dwStartType,
    IN  DWORD        dwErrorControl,
    IN  LPCSTR       lpBinaryPathName,
    IN  LPCSTR       lpLoadOrderGroup,
    OUT LPDWORD      lpdwTagId,
    IN  LPCSTR       lpDependencies,
    IN  LPCSTR       lpServiceStartName,
    IN  LPCSTR       lpPassword,
    IN  LPCSTR       lpDisplayName
    )

/*++

Routine Description:

    This is the DLL entry point for the ChangeServiceConfig function.
    ChangeServiceConfig changes the service configuration kept in the
    Service Control Manager database.  This configuration information
    was first set in the database via the CreateService API, and can
    be queried (exept for the password parameter) using the
    QueryServiceConfig API.

Arguments:

    hService - Handle obtained from a previous OpenService call.

    dwServiceType - Value to indicate the type of service this is.

    dwStartType - Value to specify when to start the service.

    dwErrorControl - Value to specify the severity of the error if this
        service fails to start during boot so that the appropriate action
        can be taken.

    lpBinaryPathName - Fully-qualified path name to the service binary file.

    lpLoadOrderGroup - Name of the load ordering group which this service
        is a member of.  Groups of services are started based on the group
        order list specified in the registry at
        HKEY_LOCAL_SYSTEM\Control\Service_Group_Order.

    lpdwTagId - On output this pointer receives a unique tag identification
        number within the group.  If this parameter is specified (non-NULL)
        but lpLoadOrderGroup is not specified, ERROR_INVALID_PARAMETER
        will be returned.

    lpDependencies - NULL-separated names of services which must be
        running before this service can run.  An empty string means that
        this service has no dependencies.

    lpServiceStartName - If service type is SERVICE_WIN32, this name is
        the account name in the form of "DomainName\Username" which the
        service process will be logged on as when it runs.  If service
        type is SERVICE_DRIVER, this name must be the NT driver object
        name (e.g. \FileSystem\LanManRedirector or \Driver\Xns) which
        the I/O system uses to load the device driver.

    lpPassword - Password to the account name specified by
        lpServiceStartName if service type is SERVICE_WIN32.  This
        password will be changed periodically by the Service Control
        Manager so that it will not expire. If service type is
        SERVICE_DRIVER, this parameter is ignored.

    lpDisplayName - This is the internationalized name that is used for
        display purposes only.


Return Value:


Note:


--*/
{
    DWORD          status;

    LPWSTR lpPasswordW;
    LPBYTE EncryptedPassword = NULL;
    DWORD PasswordSize = 0;

    LPSTR Ptr;
    LPWSTR DependBuffer = NULL;
    DWORD DependSize = 0;


    RpcTryExcept {

        //
        // Create a unicode version of lpPassword, and then encrypt it.
        //
        if (ARGUMENT_PRESENT(lpPassword)) {

            if (! ScConvertToUnicode(&lpPasswordW, lpPassword)) {
                SCC_LOG0(ERROR,"ChangeServiceConfigA: convert password to Unicode failed\n");
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(FALSE);
            }

            status = ScEncryptPassword(
                         (SC_RPC_HANDLE)hService,
                         lpPasswordW,
                         &EncryptedPassword,
                         &PasswordSize
                         );

            (void) LocalFree(lpPasswordW);

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"ChangeServiceConfigA: ScEncryptPassword failed\n");
                SetLastError(status);
                return(FALSE);
            }
        }

        if (ARGUMENT_PRESENT(lpDependencies)) {

            DependSize = ScAStrArraySize((LPSTR) lpDependencies) / sizeof(CHAR) * sizeof(WCHAR);

            if ((DependBuffer = (LPWSTR)LocalAlloc(
                                            LMEM_ZEROINIT,
                                            (UINT) DependSize)) == NULL) {
                SCC_LOG1(ERROR,
                         "ChangeServiceConfigA: LocalAlloc of DependBuffer failed "
                         FORMAT_DWORD "\n", GetLastError());
                status = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (DependSize > sizeof(WCHAR)) {

                //
                // There is at least one dependency entry.
                //

                Ptr = (LPSTR) lpDependencies;

                //
                // Convert each dependency into Unicode, and append it to the
                // DependBuffer.
                //
                while (*Ptr != 0) {

                    LPWSTR ConvertedDependency = NULL;


                    if (! ScConvertToUnicode(&ConvertedDependency, Ptr)) {
                        SCC_LOG0(ERROR,
                                 "ChangeServiceConfigA: convert dependency to Unicode failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        goto CleanExit;
                    }

                    ScAddWStrToWStrArray(DependBuffer, ConvertedDependency);

                    (void) LocalFree(ConvertedDependency);

                    Ptr = ScNextAStrArrayEntry(Ptr);
                }
            }
        }

        status = RChangeServiceConfigA(
                    (SC_RPC_HANDLE)hService,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    (LPSTR) lpBinaryPathName,
                    (LPSTR) lpLoadOrderGroup,
                    lpdwTagId,
                    (LPBYTE) DependBuffer,
                    DependSize,
                    (LPSTR) lpServiceStartName,
                    EncryptedPassword,
                    PasswordSize,
                    (LPSTR)lpDisplayName);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

CleanExit:

    if (EncryptedPassword != NULL) {
        (void) LocalFree(EncryptedPassword);
    }

    if (DependBuffer != NULL) {
        (void) LocalFree(DependBuffer);
    }

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}

BOOL
WINAPI
ChangeServiceConfigW(
    IN  SC_HANDLE    hService,
    IN  DWORD        dwServiceType,
    IN  DWORD        dwStartType,
    IN  DWORD        dwErrorControl,
    IN  LPCWSTR      lpBinaryPathName,
    IN  LPCWSTR      lpLoadOrderGroup,
    OUT LPDWORD      lpdwTagId,
    IN  LPCWSTR      lpDependencies,
    IN  LPCWSTR      lpServiceStartName,
    IN  LPCWSTR      lpPassword,
    IN  LPCWSTR      lpDisplayName
    )

/*++

Routine Description:

    see ChangeServiceConfigA

Arguments:


Return Value:


Note:


--*/
{
    DWORD          status;

    LPBYTE EncryptedPassword = NULL;
    DWORD PasswordSize = 0;

    DWORD DependSize = 0;


    RpcTryExcept {

        //
        // Create a unicode version of lpPassword, and then encrypt it.
        //
        if (ARGUMENT_PRESENT(lpPassword)) {

            status = ScEncryptPassword(
                         (SC_RPC_HANDLE)hService,
                         (LPWSTR) lpPassword,
                         &EncryptedPassword,
                         &PasswordSize
                         );

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"ChangeServiceConfigW: ScEncryptPassword failed\n");
                SetLastError(status);
                return(FALSE);
            }
        }

        if (ARGUMENT_PRESENT(lpDependencies)) {
            DependSize = ScWStrArraySize((LPWSTR) lpDependencies);
        }

        status = RChangeServiceConfigW(
                    (SC_RPC_HANDLE)hService,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    (LPWSTR) lpBinaryPathName,
                    (LPWSTR) lpLoadOrderGroup,
                    lpdwTagId,
                    (LPBYTE) lpDependencies,
                    DependSize,
                    (LPWSTR) lpServiceStartName,
                    EncryptedPassword,
                    PasswordSize,
                    (LPWSTR)lpDisplayName);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (EncryptedPassword != NULL) {
        (void) LocalFree(EncryptedPassword);
    }
    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}

BOOL
WINAPI
ChangeServiceConfig2A(
    IN  SC_HANDLE    hService,
    IN  DWORD        dwInfoLevel,
    IN  LPVOID       lpInfo
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

--*/
{
    DWORD status;

    // Transform the parameters into a union that RPC likes
    SC_RPC_CONFIG_INFOA RpcInfo = { dwInfoLevel,
                                    (LPSERVICE_DESCRIPTIONA) lpInfo };

    RpcTryExcept
    {
        status = RChangeServiceConfig2A(
                        (SC_RPC_HANDLE) hService,
                        RpcInfo
                        );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status == RPC_S_INVALID_TAG)
    {
        status = ERROR_INVALID_LEVEL;
    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
ChangeServiceConfig2W(
    IN  SC_HANDLE    hService,
    IN  DWORD        dwInfoLevel,
    IN  LPVOID       lpInfo
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

--*/
{
    DWORD status;

    // Transform the parameters into a union that RPC likes
    SC_RPC_CONFIG_INFOW RpcInfo = { dwInfoLevel,
                                    (LPSERVICE_DESCRIPTIONW) lpInfo };

    RpcTryExcept
    {
        status = RChangeServiceConfig2W(
                        (SC_RPC_HANDLE) hService,
                        RpcInfo
                        );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status == RPC_S_INVALID_TAG)
    {
        status = ERROR_INVALID_LEVEL;
    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}

SC_HANDLE
WINAPI
CreateServiceA(
    IN  SC_HANDLE    hSCManager,
    IN  LPCSTR       lpServiceName,
    IN  LPCSTR       lpDisplayName,
    IN  DWORD        dwDesiredAccess,
    IN  DWORD        dwServiceType,
    IN  DWORD        dwStartType,
    IN  DWORD        dwErrorControl,
    IN  LPCSTR       lpBinaryPathName,
    IN  LPCSTR       lpLoadOrderGroup,
    OUT LPDWORD      lpdwTagId,
    IN  LPCSTR       lpDependencies,
    IN  LPCSTR       lpServiceStartName,
    IN  LPCSTR       lpPassword
    )

/*++

Routine Description:

    This function is the DLL entry point for the ansi version
    of CreateService.  On the server side, this function will create
    a service object and add it to the Service Control Manager database.

Arguments:

    hSCManager - Handle obtained from a previous OpenSCManager call.

    lpServiceName - Name of the service to install.

    lpDisplayName - This is the internationalized name that is used for
        display purposes only.

    dwDesiredAccess - Access types desired to access the service.

    dwServiceType - Value to indicate the type of service this is.

    dwStartType - Value to specify when to start the service.

    dwErrorControl - Value to specify the severity of the error if this
        service fails to start during boot so that the appropriate action
        can be taken.

    lpBinaryPathName - Fully-qualified path name to the service binary file.

    lpLoadOrderGroup - Name of the load ordering group which this service
        is a member of.  Groups of services are started based on the group
        order list specified in the registry at
        HKEY_LOCAL_SYSTEM\Control\Service_Group_Order.

    lpdwTagId - On output this pointer receives a unique tag identification
        number within the group.  If this parameter is specified (non-NULL)
        but lpLoadOrderGroup is not specified, ERROR_INVALID_PARAMETER
        will be returned.

    lpDependencies - Space-separated names of services which must be
        running before this service can run.  An empty string means that
        this service has no dependencies.

    lpServiceStartName - If service type is SERVICE_WIN32, this name is
        the account name in the form of "DomainName\Username" which the
        service process will be logged on as when it runs.  If service
        type is SERVICE_DRIVER, this name must be the NT driver object
        name (e.g. \FileSystem\LanManRedirector or \Driver\Xns) which
        the I/O system uses to load the device driver.

    lpPassword - Password to the account name specified by
        lpServiceStartName if service type is SERVICE_WIN32.  This
        password will be changed periodically by the Service Control
        Manager so that it will not expire. If service type is
        SERVICE_DRIVER, this parameter is ignored.

Return Value:


Note:


--*/
{
    DWORD           status;
    SC_RPC_HANDLE   hService=NULL;

    LPWSTR lpPasswordW;
    LPBYTE EncryptedPassword = NULL;
    DWORD PasswordSize = 0;

    LPSTR Ptr;
    LPWSTR DependBuffer = NULL;
    DWORD DependSize = 0;


    RpcTryExcept {

        //
        // Create a unicode version of lpPassword, and then encrypt it.
        //
        if (ARGUMENT_PRESENT(lpPassword)) {

            if (! ScConvertToUnicode(&lpPasswordW, lpPassword)) {
                SCC_LOG0(ERROR,"CreateServiceA: convert password to Unicode failed\n");
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(NULL);
            }

            status = ScEncryptPassword(
                         (SC_RPC_HANDLE)hSCManager,
                         lpPasswordW,
                         &EncryptedPassword,
                         &PasswordSize
                         );

            (void) LocalFree(lpPasswordW);

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"CreateServiceA: ScEncryptPassword failed\n");
                SetLastError(status);
                return(NULL);
            }
        }

        if (ARGUMENT_PRESENT(lpDependencies)) {

            DependSize = ScAStrArraySize((LPSTR) lpDependencies) / sizeof(CHAR) * sizeof(WCHAR);

            if ((DependBuffer = (LPWSTR)LocalAlloc(
                                            LMEM_ZEROINIT,
                                            (UINT) DependSize)) == NULL) {
                SCC_LOG1(ERROR,
                         "CreateServiceA: LocalAlloc of DependBuffer failed "
                         FORMAT_DWORD "\n", GetLastError());
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }

            if (DependSize > sizeof(WCHAR)) {

                //
                // There is at least one dependency entry.
                //

                Ptr = (LPSTR) lpDependencies;

                //
                // Convert each dependency into Unicode, and append it to the
                // DependBuffer.
                //
                while (*Ptr != 0) {

                    LPWSTR ConvertedDependency = NULL;


                    if (! ScConvertToUnicode(&ConvertedDependency, Ptr)) {
                        SCC_LOG0(ERROR,
                                 "CreateServiceA: convert dependency to Unicode failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        goto CleanExit;
                    }

                    ScAddWStrToWStrArray(DependBuffer, ConvertedDependency);

                    (void) LocalFree(ConvertedDependency);

                    Ptr = ScNextAStrArrayEntry(Ptr);
                }
            }
        }

        status = RCreateServiceA (
                    (SC_RPC_HANDLE)hSCManager,
                    (LPSTR) lpServiceName,
                    (LPSTR) lpDisplayName,
                    dwDesiredAccess,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    (LPSTR) lpBinaryPathName,
                    (LPSTR) lpLoadOrderGroup,
                    lpdwTagId,
                    (LPBYTE) DependBuffer,
                    DependSize,
                    (LPSTR) lpServiceStartName,
                    EncryptedPassword,
                    PasswordSize,
                    &hService);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

CleanExit:
    if (DependBuffer != NULL) {
        (void) LocalFree(DependBuffer);
    }

    if (EncryptedPassword != NULL) {
        (void) LocalFree(EncryptedPassword);
    }

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)hService;
}

SC_HANDLE
WINAPI
CreateServiceW(
    IN  SC_HANDLE    hSCManager,
    IN  LPCWSTR      lpServiceName,
    IN  LPCWSTR      lpDisplayName,
    IN  DWORD        dwDesiredAccess,
    IN  DWORD        dwServiceType,
    IN  DWORD        dwStartType,
    IN  DWORD        dwErrorControl,
    IN  LPCWSTR      lpBinaryPathName,
    IN  LPCWSTR      lpLoadOrderGroup,
    OUT LPDWORD      lpdwTagId,
    IN  LPCWSTR      lpDependencies,
    IN  LPCWSTR      lpServiceStartName,
    IN  LPCWSTR      lpPassword
    )

/*++

Routine Description:

    see CreateServiceA

Arguments:


Return Value:


Note:


--*/
{
    DWORD           status;
    SC_RPC_HANDLE   hService = NULL;

    LPBYTE EncryptedPassword = NULL;
    DWORD PasswordSize = 0;

    DWORD DependSize = 0;


    RpcTryExcept {

        if (ARGUMENT_PRESENT(lpPassword)) {

            status = ScEncryptPassword(
                         (SC_RPC_HANDLE)hSCManager,
                         (LPWSTR) lpPassword,
                         &EncryptedPassword,
                         &PasswordSize
                         );

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"CreateServiceW: ScEncryptPassword failed\n");
                SetLastError(status);
                return NULL;
            }
        }

        if (ARGUMENT_PRESENT(lpDependencies)) {
            DependSize = ScWStrArraySize((LPWSTR) lpDependencies);
        }

        status = RCreateServiceW (
                    (SC_RPC_HANDLE)hSCManager,
                    (LPWSTR) lpServiceName,
                    (LPWSTR) lpDisplayName,
                    dwDesiredAccess,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    (LPWSTR) lpBinaryPathName,
                    (LPWSTR) lpLoadOrderGroup,
                    lpdwTagId,
                    (LPBYTE) lpDependencies,
                    DependSize,
                    (LPWSTR) lpServiceStartName,
                    EncryptedPassword,
                    PasswordSize,
                    &hService);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (EncryptedPassword != NULL) {
        LocalFree(EncryptedPassword);
    }

    if (status != NO_ERROR){
        SetLastError(status);
        return NULL;
    }

    return (SC_HANDLE)hService;
}

BOOL
WINAPI
DeleteService(
    IN  SC_HANDLE   hService
    )

/*++

Routine Description:

    This is the DLL entry point for the DeleteService function.
    DeleteService removes the service from the Service Control
    Manager's database.

Arguments:

    hService - Handle obtained from a previous CreateService or
        OpenService call.

Return Value:


Note:


--*/
{
    DWORD          status;


    SCC_LOG1(TRACE,
             "---------DeleteService called (%ws)\n",
             GetCommandLineW());

    RpcTryExcept {

        status = RDeleteService ((SC_RPC_HANDLE)hService);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){

        SCC_LOG2(TRACE,
                 "---------DeleteService FAILED, %ld (%ws)\n",
                 status,
                 GetCommandLineW());

        SetLastError(status);
        return(FALSE);
    }

    SCC_LOG1(TRACE,
             "---------DeleteService SUCCESS (%ws)\n",
             GetCommandLineW());


    return TRUE;
}

BOOL
WINAPI
EnumDependentServicesA(
    IN      SC_HANDLE               hService,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSA  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned
    )


/*++

Routine Description:

    This function lists the services which depend on the specified
    service to be running before they can run.  The returned
    services entries are ordered in the reverse order of start
    dependencies with group order taken into account.  Services can
    be stopped in the proper order based on the order of entries
    written to the output buffer.

Arguments:

    hService - Handle obtained from a previous OpenService call.

    dwServiceState - Value to select the services to enumerate based on
        the running state.

    lpServices - A pointer to a buffer to receive an array of service
        entries; each entry is the ENUM_SERVICE_STATUS information
        structure.  The services returned in the buffer is ordered by
        the reverse dependency order.

    cbBufSize - Size of the buffer in bytes pointed to by lpServices.

    pcbBytesNeeded - A pointer to a variable to receive the number of
        bytes needed to fit the remaining service entries.

    lpServicesReturned - A pointer to a variable to receive the number
        of service entries returned.


Return Value:

    TRUE - if all Services are successfully written into the supplied
        output buffer.

    FALSE - If an error has occured - Use GetLastError to determine the
        cause of the failure.


--*/
{
    DWORD                   status;
    LPENUM_SERVICE_STATUSA  pEnumBuf;
    ENUM_SERVICE_STATUSA    enumBuf;
    DWORD                   tempBufSize;

    tempBufSize = cbBufSize;
    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUSA) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUSA);
    }
    else {
        pEnumBuf = lpServices;
    }


    RpcTryExcept {

        status = REnumDependentServicesA(
                    (SC_RPC_HANDLE)hService,
                    dwServiceState,
                    (LPBYTE)pEnumBuf,
                    tempBufSize,
                    pcbBytesNeeded,
                    lpServicesReturned);


    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_DEPEND_A,
                                    NULL,                  // no hSCManager
                                    0,                     // no service type
                                    0,                     // no service state
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    NULL,                  // no old resume index
                                    NULL,                  // no group name
                                    &dwError))
            {
                status = dwError;
            }
        }

        //
        // Scale required size up to the minimum size guaranteed to
        // succeed with 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUSA)
                              / sizeof(ENUM_SERVICE_STATUS_WOW64);


#else  // ndef _WIN64

            ScConvertOffsetsA(lpServices, *lpServicesReturned);
        }

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
EnumDependentServicesW(
    IN      SC_HANDLE               hService,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSW  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned
    )


/*++

Routine Description:

    This function lists the services which depend on the specified
    service to be running before they can run.  The returned
    services entries are ordered in the reverse order of start
    dependencies with group order taken into account.  Services can
    be stopped in the proper order based on the order of entries
    written to the output buffer.

Arguments:

    hService - Handle obtained from a previous OpenService call.

    dwServiceState - Value to select the services to enumerate based on
        the running state.

    lpServices - A pointer to a buffer to receive an array of service
        entries; each entry is the ENUM_SERVICE_STATUS information
        structure.  The services returned in the buffer is ordered by
        the reverse dependency order.

    cbBufSize - Size of the buffer in bytes pointed to by lpServices.

    pcbBytesNeeded - A pointer to a variable to receive the number of
        bytes needed to fit the remaining service entries.

    lpServicesReturned - A pointer to a variable to receive the number
        of service entries returned.


Return Value:

    TRUE - if all Services are successfully written into the supplied
        output buffer.

    FALSE - If an error has occured - Use GetLastError to determine the
        cause of the failure.


--*/
{
    DWORD                   status;
    LPENUM_SERVICE_STATUSW  pEnumBuf;
    ENUM_SERVICE_STATUSW    enumBuf;
    DWORD                   tempBufSize;

    tempBufSize = cbBufSize;
    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUSW) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUSW);
    }
    else {
        pEnumBuf = lpServices;
    }

    RpcTryExcept {

        status = REnumDependentServicesW(
                    (SC_RPC_HANDLE)hService,
                    dwServiceState,
                    (LPBYTE)pEnumBuf,
                    tempBufSize,
                    pcbBytesNeeded,
                    lpServicesReturned);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //

    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_DEPEND_W,
                                    NULL,                  // no hSCManager
                                    0,                     // no service type
                                    0,                     // no service state
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    NULL,                  // no old resume index
                                    NULL,                  // no group name
                                    &dwError))
            {
                status = dwError;
            }
        }

        //
        // Scale required size up to the minimum size guaranteed to
        // succeed with 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUSA)
                              / sizeof(ENUM_SERVICE_STATUS_WOW64);

#else  // ndef _WIN64

            ScConvertOffsetsW(lpServices, *lpServicesReturned);
        }

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
GetServiceDisplayNameA(
    SC_HANDLE       hSCManager,
    LPCSTR          lpServiceName,
    LPSTR           lpDisplayName,
    LPDWORD         lpcchBuffer
    )
/*++

Routine Description:

    This function returns the display name for a service that is identified
    by its key name (ServiceName).

Arguments:

    hSCManager - This is the handle to the Service Controller Manager that
        is expected to return the display name.

    lpServiceName -  This is the ServiceName (which is actually a key
        name) that identifies the service.

    lpDisplayName - This is a pointer to a buffer that is to receive the
        DisplayName string.

    lpcchBuffer - This is a pointer to the size (in characters) of the
        buffer that is to receive the DisplayName string.  If the buffer
        is not large enough to receive the entire string, then the required
        buffer size is returned in this location.  (NOTE:  Ansi Characters,
        including DBCS, are assumed to be 8 bits).

Return Value:



--*/
{
    DWORD   status;
    LPSTR   bufPtr;
    CHAR    tempString[] = "";

    //
    // Create a dummy buffer that is at least the size of a CHAR.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    RpcTryExcept {

        if ((*lpcchBuffer < sizeof(CHAR)) || (lpDisplayName == NULL)){
            bufPtr = tempString;
            *lpcchBuffer = sizeof(CHAR);
        }
        else {
            bufPtr = (LPSTR)lpDisplayName;
        }

        status = RGetServiceDisplayNameA(
                    (SC_RPC_HANDLE)hSCManager,
                    (LPSTR)lpServiceName,
                    bufPtr,
                    lpcchBuffer);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }
    return(TRUE);
}

BOOL
WINAPI
GetServiceDisplayNameW(
    SC_HANDLE       hSCManager,
    LPCWSTR         lpServiceName,
    LPWSTR          lpDisplayName,
    LPDWORD         lpcchBuffer
    )


/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD   status;
    LPWSTR  bufPtr;
    WCHAR   tempString[]=L"";

    //
    // Create a dummy buffer that is at least the size of a WCHAR.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    RpcTryExcept {

        if ((*lpcchBuffer < sizeof(WCHAR)) || (lpDisplayName == NULL)) {
            bufPtr = tempString;
            *lpcchBuffer = sizeof(WCHAR);
        }
        else {
            bufPtr = (LPWSTR)lpDisplayName;
        }

        status = RGetServiceDisplayNameW(
                    (SC_RPC_HANDLE)hSCManager,
                    (LPWSTR)lpServiceName,
                    bufPtr,
                    lpcchBuffer);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }
    return(TRUE);
}

BOOL
WINAPI
GetServiceKeyNameA(
    SC_HANDLE   hSCManager,
    LPCSTR      lpDisplayName,
    LPSTR       lpServiceName,
    LPDWORD     lpcchBuffer
    )

/*++

Routine Description:



Arguments:

    hSCManager - This is the handle to the Service Controller Manager that
        is expected to return the service name (key name).

    lpServiceName -  This is the Service Display Name that identifies
        the service.

    lpServiceName - This is a pointer to a buffer that is to receive the
        Service Key Name string.

    lpcchBuffer - This is a pointer to the size of the buffer that is
        to receive the Service Key Name string.  If the buffer is not large
        enough to receive the entire string, then the required buffer size
        is returned in this location.


Return Value:



--*/
{
    DWORD   status;
    LPSTR   bufPtr;
    CHAR    tempString[]="";

    //
    // Create a dummy buffer that is at least the size of a CHAR.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    RpcTryExcept {

        if ((*lpcchBuffer < sizeof(CHAR)) || (lpServiceName == NULL)) {
            bufPtr = tempString;
            *lpcchBuffer = sizeof(CHAR);
        }
        else {
            bufPtr = (LPSTR)lpServiceName;
        }

        status = RGetServiceKeyNameA(
                    (SC_RPC_HANDLE)hSCManager,
                    (LPSTR)lpDisplayName,
                    bufPtr,
                    lpcchBuffer);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }
    return(TRUE);
}

BOOL
WINAPI
GetServiceKeyNameW(
    SC_HANDLE   hSCManager,
    LPCWSTR     lpDisplayName,
    LPWSTR      lpServiceName,
    LPDWORD     lpcchBuffer
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD   status = NO_ERROR;
    LPWSTR  bufPtr;
    WCHAR   tempString[]=L"";

    //
    // Create a dummy buffer that is at least the size of a WCHAR.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    RpcTryExcept {

        if ((*lpcchBuffer < sizeof(WCHAR)) || (lpServiceName == NULL)) {
            bufPtr = tempString;
            *lpcchBuffer = sizeof(WCHAR);
        }
        else {
            bufPtr = (LPWSTR)lpServiceName;
        }

        status = RGetServiceKeyNameW(
                    (SC_RPC_HANDLE)hSCManager,
                    (LPWSTR)lpDisplayName,
                    bufPtr,
                    lpcchBuffer);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }
    return(TRUE);
}


SC_LOCK
WINAPI
LockServiceDatabase(
    IN  SC_HANDLE   hSCManager
    )

/*++

Routine Description:

    This is the DLL entry point for the LockServiceDatabase function.
    This function acquires a lock on the database that was opened from
    a previous OpenSCManager call.  There can only be one lock
    outstanding on a database for a given time.

Arguments:

    hSCManager - Handle obtained from a previous OpenSCManager call
        which specifies the database to lock.

Return Value:



--*/
{
    DWORD           status;
    SC_RPC_LOCK     lock = NULL;


    RpcTryExcept {

        status = RLockServiceDatabase(
                    (SC_RPC_HANDLE)hSCManager,
                    &lock);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return((SC_LOCK)lock);
}


BOOL
WINAPI
QueryServiceConfigA(
    IN  SC_HANDLE               hService,
    OUT LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    IN  DWORD                   cbBufSize,
    OUT LPDWORD                 pcbBytesNeeded
    )

/*++

Routine Description:

    This is the DLL entry point for the QueryServiceConfig function.
    QueryServiceConfig obtains the service configuration information
    stored in the Service Control Manager database.  This configuration
    information was first set in the database via the CreateService API,
    and may have been updated via the ChangeServiceConfig API.

Arguments:

    hService - Handle obtained from a previous CreateService or
        OpenService call.

    lpServiceConfig - A pointer to a buffer to receive a
        QUERY_SERVICE_CONFIG information structure.

    cbBufSize - Size of the buffer in bytes pointed to by lpServiceConfig.

    pcbBytesNeeded - A pointer to a variable to receive the number of
        bytes needed to fit the entire QUERY_SERVICE_CONFIG information
        structure.

Return Value:


Note:


--*/
{
    DWORD                   status;
    LPSTR                   pDepend;
    LPQUERY_SERVICE_CONFIGA pConfigBuf;
    QUERY_SERVICE_CONFIGA   configBuf;
    DWORD                   tempBufSize;

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(QUERY_SERVICE_CONFIGA))
    {
        pConfigBuf = &configBuf;
        tempBufSize = sizeof(QUERY_SERVICE_CONFIGA);
    }
    else
    {
        pConfigBuf = lpServiceConfig;
    }

    RpcTryExcept
    {
        status = RQueryServiceConfigA(
                    (SC_RPC_HANDLE)hService,
                    pConfigBuf,
                    tempBufSize,
                    pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {

#ifdef _WIN64

        //
        // pcbBytesNeeded isn't filled in if the byte count is too
        // small (returned when the buffer size is large enough to
        // hold the 32-bit structure but too small to hold the
        // 64-bit structure.  Get the necessary (32-bit) size.
        //

        if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            RpcTryExcept
            {
                status = RQueryServiceConfigA(
                            (SC_RPC_HANDLE)hService,
                            pConfigBuf,
                            sizeof(QUERY_SERVICE_CONFIGA),
                            pcbBytesNeeded);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
            }
            RpcEndExcept
        }

        //
        // Since the ACF file specifies byte_count for this API, we're
        // responsible for managing the count of bytes needed by the
        // caller.  For 64-bit clients calling 32-bit servers, the
        // returned buffer size is too small because of differing
        // pointer sizes.  Add on the minimum number of bytes that
        // will guarantee enough space in the buffer for the next
        // call.
        //

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // 5 embedded pointers in the structure and max
            // space required for alignment.
            //
            *pcbBytesNeeded += 5 * (sizeof(PVOID) - sizeof(ULONG) + sizeof(PVOID));
        }

#endif  // _WIN64

        SetLastError(status);
        return(FALSE);
    }
    else
    {
        //
        // Replace the '/' separator characters by NULLs.  We used
        // separator characters in the double NULL terminated set of
        // strings so that RPC could treat it as a single string.
        //
        if ((pDepend = lpServiceConfig->lpDependencies) != NULL) {
            while (*pDepend != '\0') {
                if (*pDepend == '/') {
                    *pDepend = '\0';
                }
                pDepend++;
            }
        }
    }

    return(TRUE);
}


BOOL
WINAPI
QueryServiceConfigW(
    IN  SC_HANDLE               hService,
    OUT LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    IN  DWORD                   cbBufSize,
    OUT LPDWORD                 pcbBytesNeeded
    )

/*++

Routine Description:

    see QueryServiceConfigA

Arguments:


Return Value:


Note:


--*/
{
    DWORD                   status;
    LPWSTR                  pDepend;
    LPQUERY_SERVICE_CONFIGW pConfigBuf;
    QUERY_SERVICE_CONFIGW   configBuf;
    DWORD                   tempBufSize;

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(QUERY_SERVICE_CONFIGW))
    {
        pConfigBuf = &configBuf;
        tempBufSize = sizeof(QUERY_SERVICE_CONFIGW);
    }
    else
    {
        pConfigBuf = lpServiceConfig;
    }

    RpcTryExcept
    {
        status = RQueryServiceConfigW(
                    (SC_RPC_HANDLE)hService,
                    pConfigBuf,
                    tempBufSize,
                    pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {

#ifdef _WIN64

        //
        // pcbBytesNeeded isn't filled in if the byte count is too
        // small (returned when the buffer size is large enough to
        // hold the 32-bit structure but too small to hold the
        // 64-bit structure.  Get the necessary (32-bit) size.
        //

        if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            RpcTryExcept
            {
                status = RQueryServiceConfigW(
                            (SC_RPC_HANDLE)hService,
                            pConfigBuf,
                            sizeof(QUERY_SERVICE_CONFIGW),
                            pcbBytesNeeded);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
            }
            RpcEndExcept
        }

        //
        // Since the ACF file specifies byte_count for this API, we're
        // responsible for managing the count of bytes needed by the
        // caller.  For 64-bit clients calling 32-bit servers, the
        // returned buffer size is too small because of differing
        // pointer sizes.  Add on the minimum number of bytes that
        // will guarantee enough space in the buffer for the next
        // call.
        //

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // 5 embedded pointers in the structure and max
            // space required for alignment.
            //
            *pcbBytesNeeded += 5 * (sizeof(PVOID) - sizeof(ULONG) + sizeof(PVOID));
        }

#endif  // _WIN64

        SetLastError(status);
        return(FALSE);
    }
    else
    {
        //
        // Replace the '/' separator characters by NULLs.  We used
        // separator characters in the double NULL terminated set of
        // strings so that RPC could treat it as a single string.
        //
        if ((pDepend = lpServiceConfig->lpDependencies) != NULL) {
            while (*pDepend != L'\0') {
                if (*pDepend == L'/') {
                    *pDepend = L'\0';
                }
                pDepend++;
            }
        }
    }

    return(TRUE);
}


BOOL
WINAPI
QueryServiceConfig2A(
    IN  SC_HANDLE   hService,
    IN  DWORD       dwInfoLevel,
    OUT LPBYTE      lpBuffer,
    IN  DWORD       cbBufSize,
    OUT LPDWORD     pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                        status;
    LPBYTE                       lpTempBuffer;
    SERVICE_DESCRIPTIONA         sdDescription;
    SERVICE_FAILURE_ACTIONSA     sfaActions;
    DWORD                        tempBufSize;
    BOOL                         fDummyBuffer = FALSE;

    tempBufSize  = cbBufSize;
    lpTempBuffer = lpBuffer;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, put the correct size in the BytesNeeded parameter, and
    // fail the call.
    //
    switch(dwInfoLevel) {

    case SERVICE_CONFIG_DESCRIPTION:

        if (cbBufSize < sizeof(SERVICE_DESCRIPTION_WOW64)) {
            lpTempBuffer = (LPBYTE) &sdDescription;
            tempBufSize  = sizeof(SERVICE_DESCRIPTION_WOW64);
            fDummyBuffer = TRUE;
        }

        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:

        if (cbBufSize < sizeof(SERVICE_FAILURE_ACTIONS_WOW64)) {
            lpTempBuffer = (LPBYTE) &sfaActions;
            tempBufSize  = sizeof(SERVICE_FAILURE_ACTIONS_WOW64);
            fDummyBuffer = TRUE;
        }

        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept
    {
        status = RQueryServiceConfig2A(
                    (SC_RPC_HANDLE) hService,
                    dwInfoLevel,
                    lpTempBuffer,
                    tempBufSize,
                    pcbBytesNeeded);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept


#ifdef _WIN64

    //
    // 64-bit needs more space than the 32-bit-oriented structure
    // coming from the server.  Make sure we have it.  Do this
    // even if fDummyBuffer is TRUE since ScConvertOffsets64 will
    // update *pcbBytesNeeded appropriately.
    //

    if (status == NO_ERROR || status == ERROR_INSUFFICIENT_BUFFER)
    {
        if (!ScConvertOffsets64(dwInfoLevel == SERVICE_CONFIG_DESCRIPTION ?
                                    SC_API_QUERY_DESCRIPTION_A :
                                    SC_API_QUERY_FAILURE_ACTIONS_A,
                                NULL,
                                0,
                                0,
                                lpTempBuffer,
                                tempBufSize,
                                pcbBytesNeeded,
                                NULL,
                                NULL,
                                NULL,
                                NULL))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
    }

#endif // _WIN64


    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    //
    // Catch the case where the RPC call succeeded even though we used
    // a dummy buffer (e.g., SERVICE_FAILURE_ACTIONS on a service with
    // no command line or reboot message).  Note that the server side
    // of this API fills in pcbBytesNeeded even on success
    //
    if (fDummyBuffer)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Convert offsets to pointers in the returned structure
    //
    switch (dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        {
            LPSERVICE_DESCRIPTIONA psd =
                    (LPSERVICE_DESCRIPTIONA) lpBuffer;
            if (psd->lpDescription != NULL)
            {
                psd->lpDescription = (LPSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR)psd->lpDescription);
            }
        }
        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        {
            LPSERVICE_FAILURE_ACTIONSA psfa =
                    (LPSERVICE_FAILURE_ACTIONSA) lpBuffer;
            if (psfa->lpRebootMsg != NULL)
            {
                psfa->lpRebootMsg = (LPSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR)psfa->lpRebootMsg);
            }
            if (psfa->lpCommand != NULL)
            {
                psfa->lpCommand = (LPSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR)psfa->lpCommand);
            }
            if (psfa->lpsaActions != NULL)
            {
                psfa->lpsaActions = (SC_ACTION *)
                        (lpBuffer + (DWORD)(ULONG_PTR)psfa->lpsaActions);
            }
        }
        break;
    }

    return TRUE;
}


BOOL
WINAPI
QueryServiceConfig2W(
    IN  SC_HANDLE   hService,
    IN  DWORD       dwInfoLevel,
    OUT LPBYTE      lpBuffer,
    IN  DWORD       cbBufSize,
    OUT LPDWORD     pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                        status;
    LPBYTE                       lpTempBuffer;
    SERVICE_DESCRIPTIONW         sdDescription;
    SERVICE_FAILURE_ACTIONSW     sfaActions;
    DWORD                        tempBufSize;
    BOOL                         fDummyBuffer = FALSE;

    tempBufSize  = cbBufSize;
    lpTempBuffer = lpBuffer;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, put the correct size in the BytesNeeded parameter, and
    // fail the call.
    //
    switch(dwInfoLevel) {

    case SERVICE_CONFIG_DESCRIPTION:

        if (cbBufSize < sizeof(SERVICE_DESCRIPTIONW)) {
            lpTempBuffer = (LPBYTE) &sdDescription;
            tempBufSize  = sizeof(SERVICE_DESCRIPTIONW);
            fDummyBuffer = TRUE;
        }

        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:

        if (cbBufSize < sizeof(SERVICE_FAILURE_ACTIONSW)) {
            lpTempBuffer = (LPBYTE) &sfaActions;
            tempBufSize  = sizeof(SERVICE_FAILURE_ACTIONSW);
            fDummyBuffer = TRUE;
        }

        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept
    {
        status = RQueryServiceConfig2W(
                    (SC_RPC_HANDLE) hService,
                    dwInfoLevel,
                    lpTempBuffer,
                    tempBufSize,
                    pcbBytesNeeded);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept


#ifdef _WIN64

    //
    // 64-bit needs more space than the 32-bit-oriented structure
    // coming from the server.  Make sure we have it.  Do this
    // even if fDummyBuffer is TRUE since ScConvertOffsets64 will
    // update *pcbBytesNeeded appropriately.
    //

    if (status == NO_ERROR || status == ERROR_INSUFFICIENT_BUFFER)
    {
        if (!ScConvertOffsets64(dwInfoLevel == SERVICE_CONFIG_DESCRIPTION ?
                                    SC_API_QUERY_DESCRIPTION_W :
                                    SC_API_QUERY_FAILURE_ACTIONS_W,
                                NULL,
                                0,
                                0,
                                lpTempBuffer,
                                tempBufSize,
                                pcbBytesNeeded,
                                NULL,
                                NULL,
                                NULL,
                                NULL))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
    }

#endif // _WIN64


    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    //
    // Catch the case where the RPC call succeeded even though we used
    // a dummy buffer (e.g., SERVICE_FAILURE_ACTIONS on a service with
    // no command line or reboot message).  Note that the server side
    // of this API fills in pcbBytesNeeded even on success
    //
    if (fDummyBuffer)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Convert offsets to pointers in the returned structure
    //
    switch (dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        {
            LPSERVICE_DESCRIPTIONW psd =
                    (LPSERVICE_DESCRIPTIONW) lpBuffer;
            if (psd->lpDescription != NULL)
            {
                psd->lpDescription = (LPWSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR) psd->lpDescription);
            }
        }
        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        {
            LPSERVICE_FAILURE_ACTIONSW psfa =
                    (LPSERVICE_FAILURE_ACTIONSW) lpBuffer;
            if (psfa->lpRebootMsg != NULL)
            {
                psfa->lpRebootMsg = (LPWSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR) psfa->lpRebootMsg);
            }
            if (psfa->lpCommand != NULL)
            {
                psfa->lpCommand = (LPWSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR) psfa->lpCommand);
            }
            if (psfa->lpsaActions != NULL)
            {
                psfa->lpsaActions = (SC_ACTION *)
                        (lpBuffer + (DWORD)(ULONG_PTR) psfa->lpsaActions);
            }
        }
        break;
    }

    return TRUE;
}


BOOL
WINAPI
QueryServiceLockStatusA(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    )

/*++

Routine Description:

    This is the DLL entry point for the QueryServiceLockStatus function.
    This function returns lock status information on a Service Control
    Manager database.


Arguments:

    hSCManager - Handled obtained from a previous call to OpenSCManager
        call.

    lpLockStatus - A pointer to a buffer to receive a
        QUERY_SERVICE_LOCK_STATUS information structure.

Return Value:


Note:


--*/
{
    DWORD                           status;
    LPQUERY_SERVICE_LOCK_STATUSA    pStatusBuf;
    QUERY_SERVICE_LOCK_STATUSA      statusBuf;
    DWORD                           tempBufSize;

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(QUERY_SERVICE_LOCK_STATUSA))
    {
        pStatusBuf = &statusBuf;
        tempBufSize = sizeof(QUERY_SERVICE_LOCK_STATUSA);
    }
    else
    {
        pStatusBuf = lpLockStatus;
    }

    RpcTryExcept
    {
        status = RQueryServiceLockStatusA(
                    (SC_RPC_HANDLE)hSCManager,
                    pStatusBuf,
                    tempBufSize,
                    pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {

#ifdef _WIN64

        //
        // pcbBytesNeeded isn't filled in if the byte count is too
        // small (returned when the buffer size is large enough to
        // hold the 32-bit structure but too small to hold the
        // 64-bit structure.  Get the necessary (32-bit) size.
        //

        if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            RpcTryExcept
            {
                status = RQueryServiceLockStatusA(
                            (SC_RPC_HANDLE)hSCManager,
                            pStatusBuf,
                            sizeof(QUERY_SERVICE_LOCK_STATUSA),
                            pcbBytesNeeded);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
            }
            RpcEndExcept
        }


        //
        // Since the ACF file specifies byte_count for this API, we're
        // responsible for managing the count of bytes needed by the
        // caller.  For 64-bit clients calling 32-bit servers, the
        // returned buffer size is too small because of differing
        // pointer sizes.  Add on the minimum number of bytes that
        // will guarantee enough space in the buffer for the next
        // call.
        //

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // 1 embedded pointer in the structure and max
            // space required for alignment.
            //
            *pcbBytesNeeded += (sizeof(PVOID) - sizeof(ULONG) + sizeof(PVOID));
        }
        else if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            //
            // We get here if we called a 32-bit server where the lock
            // was unowned and we used a buffer size smaller than
            // sizeof(QUERY_SERVICE_LOCK_STATUSA).
            //

            *pcbBytesNeeded = sizeof(QUERY_SERVICE_LOCK_STATUSA) + sizeof(WCHAR);
            status = ERROR_INSUFFICIENT_BUFFER;
        }

#endif  // _WIN64

        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
QueryServiceLockStatusW(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    )

/*++

Routine Description:

    see QueryServiceLockStatusA

Arguments:


Return Value:


Note:


--*/
{
    DWORD                           status;
    LPQUERY_SERVICE_LOCK_STATUSW    pStatusBuf;
    QUERY_SERVICE_LOCK_STATUSW      statusBuf;
    DWORD                           tempBufSize;

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(QUERY_SERVICE_LOCK_STATUSW))
    {
        pStatusBuf = &statusBuf;
        tempBufSize = sizeof(QUERY_SERVICE_LOCK_STATUSW);
    }
    else
    {
        pStatusBuf = lpLockStatus;
    }

    RpcTryExcept
    {
        status = RQueryServiceLockStatusW(
                    (SC_RPC_HANDLE)hSCManager,
                    pStatusBuf,
                    tempBufSize,
                    pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {

#ifdef _WIN64

        //
        // pcbBytesNeeded isn't filled in if the byte count is too
        // small (returned when the buffer size is large enough to
        // hold the 32-bit structure but too small to hold the
        // 64-bit structure.  Get the necessary (32-bit) size.
        //

        if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            RpcTryExcept
            {
                status = RQueryServiceLockStatusW(
                            (SC_RPC_HANDLE)hSCManager,
                            pStatusBuf,
                            sizeof(QUERY_SERVICE_LOCK_STATUSW),
                            pcbBytesNeeded);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
            }
            RpcEndExcept
        }

        //
        // Since the ACF file specifies byte_count for this API, we're
        // responsible for managing the count of bytes needed by the
        // caller.  For 64-bit clients calling 32-bit servers, the
        // returned buffer size is too small because of differing
        // pointer sizes.  Add on the minimum number of bytes that
        // will guarantee enough space in the buffer for the next
        // call.
        //

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // 1 embedded pointer in the structure and max
            // space required for alignment.
            //
            *pcbBytesNeeded += (sizeof(PVOID) - sizeof(ULONG) + sizeof(PVOID));
        }
        else if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            //
            // We get here if we called a 32-bit server where the lock
            // was unowned and we used a buffer size smaller than
            // sizeof(QUERY_SERVICE_LOCK_STATUSW).
            //

            *pcbBytesNeeded = sizeof(QUERY_SERVICE_LOCK_STATUSW) + sizeof(WCHAR);
            status = ERROR_INSUFFICIENT_BUFFER;
        }

#endif  // _WIN64

        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
UnlockServiceDatabase(
    IN  SC_LOCK     ScLock
    )

/*++

Routine Description:

    This is the DLL entry point for the UnlockServiceDatabase function.
    This function releases a lock on a Service Control Manager database.


Arguments:

    ScLock - Lock obtained from a previous LockServiceDatabase call.

Return Value:



--*/
{
    DWORD          status;


    UNREFERENCED_PARAMETER(ScLock);

    RpcTryExcept {

        status = RUnlockServiceDatabase((LPSC_RPC_LOCK)&ScLock);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_SERVICE_LOCK);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}

BOOL
WINAPI
NotifyBootConfigStatus(
    IN BOOL     BootAcceptable
    )

/*++

Routine Description:

    If we are not currently booted with Last Known Good, this function
    will revert to Last Known Good if the boot is not acceptable.  Or it
    will save the boot configuration that we last booted from as the
    Last Known Good.  This is the configuration that we will fall back
    to if a future boot fails.

Arguments:

    BootAcceptable - This indicates whether or not the boot was acceptable.

Return Value:

    TRUE - This is only returned if the boot is acceptable, and we
        successfully replaced Last Known Good with the current boot
        configuration.

    FALSE - This is returned if an error occured when attempting to replace
        Last Known Good or if the system is currently booted from Last
        Known Good.


--*/
{
    DWORD          status;


    RpcTryExcept {

        status = RNotifyBootConfigStatus(
                    NULL,                   // A Local Call Only.
                    (DWORD)BootAcceptable);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}

DWORD
ScWaitForStart(
    VOID
    )

/*++

Routine Description:

    This routine waits until the SC_INTERNAL_START_EVENT is set or until
    a timeout occurs.  Then it returns.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD                   status;
    HANDLE                  ScStartEvent = NULL;

    //
    // Try opening the event first because it will work most of the
    // time.
    //
    ScStartEvent = OpenEventW(
                    SYNCHRONIZE,
                    FALSE,
                    SC_INTERNAL_START_EVENT );

    if (ScStartEvent == NULL) {

        status = GetLastError();

        if (status == ERROR_FILE_NOT_FOUND) {
            //
            // Only if we can't find the event do we attempt to create
            // it here.
            //

            SCC_LOG0(ERROR,
                     "ScWaitForStart: Event does not exist -- attempting to create it\n");

            //
            // Create the event that the OpenSCManager will use to wait on the
            // service controller with.
            //
            SECURITY_ATTRIBUTES     SecurityAttributes;
            PSECURITY_DESCRIPTOR    SecurityDescriptor=NULL;

            status = ScCreateStartEventSD(&SecurityDescriptor);

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"ScGetStartEvent: Couldn't allocate for SecurityDesc\n");
                return status;
            }

            SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
            SecurityAttributes.bInheritHandle = FALSE;
            SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;

            ScStartEvent = CreateEventW(
                        &SecurityAttributes,
                        TRUE,                   // Must be manually reset
                        FALSE,                  // The event is initially not signalled
                        SC_INTERNAL_START_EVENT );

            status = GetLastError();    // must do this before LocalFree

            LocalFree(SecurityDescriptor);

            if (ScStartEvent == NULL) {
                //
                // Failed to create StartEvent.
                //
                // If we failed to create it because someone else created
                // it between our calls to OpenEvent and CreateEvent, try
                // to open it once more.
                //
                if (status == ERROR_ALREADY_EXISTS) {

                    ScStartEvent = OpenEventW(
                                    SYNCHRONIZE,
                                    FALSE,
                                    SC_INTERNAL_START_EVENT );

                    if (ScStartEvent == NULL) {

                        status = GetLastError();

                        SCC_LOG1(ERROR,"ScWaitForStart: OpenEvent (StartEvent) failed "
                                FORMAT_DWORD " on second attempt\n", status);
                        return status;
                    }
                }
                else {
                    SCC_LOG1(ERROR,"ScWaitForStart: CreateEvent (StartEvent) Failed "
                            FORMAT_DWORD "\n", status);
                    return status;
                }
            }
        }
        else {
            //
            // Could not open the event for some unknown reason.  Give up.
            //
            SCC_LOG1(ERROR,"ScWaitForStart: OpenEvent (StartEvent) Failed "
                    FORMAT_DWORD "\n", status);
            return status;
        }
    }

    SCC_LOG0(TRACE,"Beginning wait for ScStartEvent\n");

    status = WaitForSingleObject(ScStartEvent, SC_START_TIMEOUT);

    CloseHandle(ScStartEvent);

    if (status == WAIT_TIMEOUT) {
        SCC_LOG0(ERROR,"ScWaitForStart: TIMEOUT waiting for StartEvent\n");
        return ERROR_TIMEOUT;
    }

    return NO_ERROR;
}


DWORD
ScMapRpcError(
    IN DWORD RpcError,
    IN DWORD BadContextError
    )
/*++

Routine Description:

    This routine maps the RPC error into a more meaningful error
    for the caller.

Arguments:

    RpcError - Supplies the exception error raised by RPC

    BadContextError - Supplies the error code to return whenever an error
        which indicates invalid context is received.  In some cases, this
        value is ERROR_INVALID_HANDLE; in others, it is ERROR_INVALID_SERVICE_LOCK.

Return Value:

    Returns the mapped error.

--*/
{
    switch (RpcError)
    {
        case RPC_S_INVALID_BINDING:
        case RPC_X_SS_IN_NULL_CONTEXT:
        case RPC_X_SS_CONTEXT_DAMAGED:
        case RPC_X_SS_HANDLES_MISMATCH:
        case ERROR_INVALID_HANDLE:
            return BadContextError;

        case RPC_X_NULL_REF_POINTER:
        case EXCEPTION_ACCESS_VIOLATION:
            return ERROR_INVALID_ADDRESS;

        case RPC_S_INVALID_TAG:
            return ERROR_INVALID_LEVEL;

        case RPC_S_PROCNUM_OUT_OF_RANGE:
            return ERROR_CALL_NOT_IMPLEMENTED;

        default:
            return RpcError;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\client\scapi.cxx ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    scapi.c

Abstract:

    Contains the Service-related API that are implemented solely in
    DLL form.  These include:
        StartServiceCtrlDispatcherA
        StartServiceCtrlDispatcherW
        RegisterServiceCtrlHandlerW
        RegisterServiceCtrlHandlerA
        RegisterServiceCtrlHandlerExW
        RegisterServiceCtrlHandlerExA

    This file also contains the following local support routines:
        ScDispatcherLoop
        ScCreateDispatchTableW
        ScCreateDispatchTableA
        ScReadServiceParms
        ScConnectServiceController
        ScExpungeMessage
        ScGetPipeInput
        ScGetDispatchEntry
        ScNormalizeCmdLineArgs
        ScSendResponse
        ScSvcctrlThreadW
        ScSvcctrlThreadA
        RegisterServiceCtrlHandlerHelp

Author:

    Dan Lafferty (danl)     09 Apr-1991

Environment:

    User Mode -Win32

Revision History:

    12-May-1999 jschwart
        Convert SERVICE_STATUS_HANDLE to a context handle to fix security
        hole (any service can call SetServiceStatus with another service's
        handle and succeed)

    10-May-1999 jschwart
        Create a separate named pipe per service to fix security hole (any
        process could flood the pipe since the name was well-known -- pipe
        access is now limited to the service account and LocalSystem)

    10-Mar-1998 jschwart
        Add code to allow services to receive Plug-and-Play control messages
        and unpack the message arguments from the pipe

    30-Sep-1997 jschwart
        StartServiceCtrlDispatcher:  If this function [A or W] has already been
        called from within this process, return ERROR_SERVICE_ALREADY_RUNNING.
        Otherwise, can be destructive (e.g., overwrite AnsiFlag, etc.)

    06-Aug-1997 jschwart
        ScDispatcherLoop:  If the service is processing a shutdown command from
        the SCM, it no longer writes the status back to the SCM since the SCM is
        now using WriteFile on system shutdown (see control.cxx for more info).

    03-Jun-1996 AnirudhS
        ScGetPipeInput: If the message received from the service controller
        is not a SERVICE_CONTROL_START message, don't allocate space for the
        arguments, since there are none, and since that space never gets freed.

    22-Sep-1995 AnirudhS
        Return codes from InitializeStatusBinding were not being handled
        correctly; success was sometimes reported on failure.  Fixed this.

    12-Aug-1993 Danl
        ScGetDispatchEntry:  When the first entry in the table is marked as
        OwnProcess, then this function should just return the pointer to the
        top of the table.  It should ignore the ServiceName.  In all cases,
        when the service is started as an OWN_PROCESS, only the first entry
        in the dispath table should be used.

    04-Aug-1992 Danl
        When starting a service, always pass the service name as the
        first parameter in the argument list.

    27-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.

    09 Apr-1991     danl
        created

--*/

//
// INCLUDES
//

#include <scpragma.h>

extern "C"
{
#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h
}
#include <rpc.h>        // DataTypes and runtime APIs
#include <windef.h>     // windows types needed for winbase.h
#include <winbase.h>    // CreateFile
#include <winuser.h>    // wsprintf()
#include <winreg.h>     // RegOpenKeyEx / RegQueryValueEx

#include <string.h>     // strcmp
#include <stdlib.h>     // wide character c runtimes.
#include <tstr.h>       // WCSSIZE().

#include <winsvc.h>     // public Service Controller Interface.

#include "scbind.h"     // InitializeStatusBinding
#include <valid.h>      // MAX_SERVICE_NAME_LENGTH
#include <control.h>    // CONTROL_PIPE_NAME
#include <scdebug.h>    // STATIC
#include <sclib.h>      // ScConvertToUnicode

//
// Internal Dispatch Table.
//

//
// Bit flags for the dispatch table's dwFlags field
//
#define SERVICE_OWN_PROCESS     0x00000001
#define SERVICE_EX_HANDLER      0x00000002

typedef union  _START_ROUTINE_TYPE {
    LPSERVICE_MAIN_FUNCTIONW    U;      // unicode type
    LPSERVICE_MAIN_FUNCTIONA    A;      // ansi type
} START_ROUTINE_TYPE, *LPSTART_ROUTINE_TYPE;

typedef union  _HANDLER_FUNCTION_TYPE {
    LPHANDLER_FUNCTION          Regular;    // Regular version
    LPHANDLER_FUNCTION_EX       Ex;         // Extended version
} HANDLER_FUNCTION_TYPE, *LPHANDLER_FUNCTION_TYPE;

typedef struct _INTERNAL_DISPATCH_ENTRY {
    LPWSTR                      ServiceName;
    LPWSTR                      ServiceRealName;    // In case the names are different
    START_ROUTINE_TYPE          ServiceStartRoutine;
    HANDLER_FUNCTION_TYPE       ControlHandler;
    SC_HANDLE                   StatusHandle;
    DWORD                       dwFlags;
    PVOID                       pContext;
} INTERNAL_DISPATCH_ENTRY, *LPINTERNAL_DISPATCH_ENTRY;


//
//  This structure is passed to the internal
//  startup thread which calls the real user
//  startup routine with argv, argc parameters.
//

typedef struct _THREAD_STARTUP_PARMSW {
    DWORD                       NumArgs;
    LPSERVICE_MAIN_FUNCTIONW    ServiceStartRoutine;
    LPWSTR                      VectorTable;
} THREAD_STARTUP_PARMSW, *LPTHREAD_STARTUP_PARMSW;

typedef struct _THREAD_STARTUP_PARMSA {
    DWORD                       NumArgs;
    LPSERVICE_MAIN_FUNCTIONA    ServiceStartRoutine;
    LPSTR                       VectorTable;
} THREAD_STARTUP_PARMSA, *LPTHREAD_STARTUP_PARMSA;

//
// This structure contains the arguments passed
// to a service's extended control handler
//
typedef struct _HANDLEREX_PARMS {
    DWORD    dwEventType;
    LPVOID   lpEventData;
} HANDLEREX_PARMS, *LPHANDLEREX_PARMS;

//
// This union contains the arguments to the service
// passed from the server via named pipe
//

typedef union _SERVICE_PARAMS {
    THREAD_STARTUP_PARMSW   ThreadStartupParms;
    HANDLEREX_PARMS         HandlerExParms;
} SERVICE_PARAMS, *LPSERVICE_PARAMS;

//
// The following is the amount of time we will wait for the named pipe
// to become available from the Service Controller.
//
#ifdef DEBUG
#define CONTROL_WAIT_PERIOD     NMPWAIT_WAIT_FOREVER
#else
#define CONTROL_WAIT_PERIOD     15000       // 15 seconds
#endif

//
// This is the number of times we will continue to loop when pipe read
// failures occur.  After this many tries, we cease to read the pipe.
//
#define MAX_RETRY_COUNT         30

//
// Globals
//

    LPINTERNAL_DISPATCH_ENTRY   DispatchTable=NULL;  // table head.

    //
    // This flag is set to TRUE if the control dispatcher is to support
    // ANSI calls.  Otherwise the flag is set to FALSE.
    //
    BOOL     AnsiFlag = FALSE;

    //
    // This variable makes sure StartServiceCtrlDispatcher[A,W] doesn't
    // get called twice by the same process, since this is destructive.
    // It is initialized to 0 by the linker
    //
    LONG     g_fCalledBefore;

    //
    // Are we running in the security process?
    //
    BOOL    g_fIsSecProc;

#if defined(_X86_)    
    //
    // Are we running inside a Wow64 process (on Win64)
    //
    BOOL g_fWow64Process = FALSE;
#endif

//
// Internal Functions
//

DWORD
ScCreateDispatchTableW(
    IN  CONST SERVICE_TABLE_ENTRYW  *UserDispatchTable,
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchTablePtr
    );

DWORD
ScCreateDispatchTableA(
    IN  CONST SERVICE_TABLE_ENTRYA  *UserDispatchTable,
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchTablePtr
    );

DWORD
ScReadServiceParms(
    IN  LPCTRL_MSG_HEADER   Msg,
    IN  DWORD               dwNumBytesRead,
    OUT LPBYTE              *ppServiceParams,
    OUT LPBYTE              *ppTempArgPtr,
    OUT LPDWORD             lpdwRemainingArgBytes
    );

VOID
ScDispatcherLoop(
    IN  HANDLE              PipeHandle,
    IN  LPCTRL_MSG_HEADER   Msg,
    IN  DWORD               dwBufferSize
    );

DWORD
ScConnectServiceController (
    OUT LPHANDLE    pipeHandle
    );

VOID
ScExpungeMessage(
    IN  HANDLE  PipeHandle
    );

DWORD
ScGetPipeInput (
    IN      HANDLE              PipeHandle,
    IN OUT  LPCTRL_MSG_HEADER   Msg,
    IN      DWORD               dwBufferSize,
    OUT     LPSERVICE_PARAMS    *ppServiceParams
    );

DWORD
ScGetDispatchEntry (
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchEntry,
    IN  LPWSTR                      ServiceName
    );

VOID
ScNormalizeCmdLineArgs(
    IN OUT  LPCTRL_MSG_HEADER       Msg,
    IN OUT  LPTHREAD_STARTUP_PARMSW ThreadStartupParms
    );

VOID
ScSendResponse (
    IN  HANDLE  pipeHandle,
    IN  DWORD   Response,
    IN  DWORD   dwHandlerRetVal
    );

DWORD
ScSvcctrlThreadW(
    IN LPTHREAD_STARTUP_PARMSW  lpThreadStartupParms
    );

DWORD
ScSvcctrlThreadA(
    IN LPTHREAD_STARTUP_PARMSA  lpThreadStartupParms
    );

SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerHelp (
    IN  LPCWSTR                  ServiceName,
    IN  HANDLER_FUNCTION_TYPE    ControlHandler,
    IN  PVOID                    pContext,
    IN  DWORD                    dwFlags
    );


#if defined(_X86_)
//
// Detect if the current process is a 32-bit process running on Win64.
//
VOID DetectWow64Process()
{
    NTSTATUS NtStatus;
    PVOID Peb32;

    NtStatus = NtQueryInformationProcess(NtCurrentProcess(),
                                         ProcessWow64Information,
                                         &Peb32,
                                         sizeof(Peb32),
                                         NULL);

    if (NT_SUCCESS(NtStatus) && (Peb32 != NULL))
    {
        g_fWow64Process = TRUE;
    }
}
#endif


extern "C" {

//
// Private function for lsass.exe that tells us we're running
// in the security process
//

VOID
I_ScIsSecurityProcess(
    VOID
    )
{
    g_fIsSecProc = TRUE;
}


//
// Private function for PnP that looks up a service's REAL
// name given its context handle
//

DWORD
I_ScPnPGetServiceName(
    IN  SERVICE_STATUS_HANDLE  hServiceStatus,
    OUT LPWSTR                 lpServiceName,
    IN  DWORD                  cchBufSize
    )
{
    DWORD  dwError = ERROR_SERVICE_NOT_IN_EXE;

    ASSERT(cchBufSize >= MAX_SERVICE_NAME_LENGTH);

    //
    // Search the dispatch table.
    //

    if (DispatchTable != NULL)
    {
        LPINTERNAL_DISPATCH_ENTRY   dispatchEntry;

        for (dispatchEntry = DispatchTable;
             dispatchEntry->ServiceName != NULL;
             dispatchEntry++)
        {
            //
            // Note:  SC_HANDLE and SERVICE_STATUS_HANDLE were originally
            //        different handle types -- they are now the same as
            //        per the fix for bug #120359 (SERVICE_STATUS_HANDLE
            //        fix outlined in the file comments above), so this
            //        cast is OK.
            //
            if (dispatchEntry->StatusHandle == (SC_HANDLE)hServiceStatus)
            {
                ASSERT(dispatchEntry->ServiceRealName != NULL);
                ASSERT(wcslen(dispatchEntry->ServiceRealName) < cchBufSize);
                wcscpy(lpServiceName, dispatchEntry->ServiceRealName);
                dwError = NO_ERROR;
                break;
            }
        }
    }

    return dwError;
}    

}    // extern "C"


BOOL
WINAPI
StartServiceCtrlDispatcherA (
    IN  CONST SERVICE_TABLE_ENTRYA * lpServiceStartTable
    )


/*++

Routine Description:

    This function provides the ANSI interface for the
    StartServiceCtrlDispatcher function.

Arguments:



Return Value:



--*/
{
    DWORD                       status;
    NTSTATUS                    ntstatus;
    HANDLE                      pipeHandle;

    //
    // Make sure this is the only time the control dispatcher is being called
    //
    if (InterlockedExchange(&g_fCalledBefore, 1) == 1) {

       //
       // Problem -- the control dispatcher was already called from this process
       //
       SetLastError(ERROR_SERVICE_ALREADY_RUNNING);
       return(FALSE);
    }


    //
    // Set the AnsiFlag to indicate that the control dispatcher must support
    // ansi function calls only.
    //
    AnsiFlag = TRUE;

    //
    // Create an internal DispatchTable.
    //
    status = ScCreateDispatchTableA(
                (LPSERVICE_TABLE_ENTRYA)lpServiceStartTable,
                (LPINTERNAL_DISPATCH_ENTRY *)&DispatchTable);

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }

    //
    // Allocate a buffer big enough to contain at least the control message
    // header and a service name.  This ensures that if the message is not
    // a message with arguments, it can be read in a single ReadFile.
    //
    BYTE  bPipeMessageHeader[sizeof(CTRL_MSG_HEADER) +
                                (MAX_SERVICE_NAME_LENGTH+1) * sizeof(WCHAR)];

    //
    // Connect to the Service Controller
    //

    status = ScConnectServiceController (&pipeHandle);

    if (status != NO_ERROR) {
        goto CleanExit;
    }

    //
    // Initialize the binding for the status interface (NetServiceStatus).
    //

    SCC_LOG(TRACE,"Initialize the Status binding\n",0);

    ntstatus = InitializeStatusBinding();
    if (ntstatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntstatus);
        CloseHandle(pipeHandle);
        goto CleanExit;
    }

    //
    // Enter the dispatcher loop where we service control requests until
    // all services in the service table have terminated.
    //

    ScDispatcherLoop(pipeHandle,
                     (LPCTRL_MSG_HEADER)&bPipeMessageHeader,
                     sizeof(bPipeMessageHeader));

    CloseHandle(pipeHandle);

CleanExit:

    //
    // Clean up the dispatch table.  Since we created unicode versions
    // of all the service names, in ScCreateDispatchTableA, we now need to
    // free them.
    //

    if (DispatchTable != NULL) {

        LPINTERNAL_DISPATCH_ENTRY   dispatchEntry;

        //
        // If they're different, it's because we allocated the real name.
        // Only check the first entry since this can only happen in the
        // SERVICE_OWN_PROCESS case
        //
        if (DispatchTable->ServiceName != DispatchTable->ServiceRealName) {
            LocalFree(DispatchTable->ServiceRealName);
        }

        for (dispatchEntry = DispatchTable;
             dispatchEntry->ServiceName != NULL;
             dispatchEntry++) {

            LocalFree(dispatchEntry->ServiceName);
        }

        LocalFree(DispatchTable);
    }

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
StartServiceCtrlDispatcherW (
    IN  CONST SERVICE_TABLE_ENTRYW * lpServiceStartTable
    )
/*++

Routine Description:

    This is the Control Dispatcher thread.  We do not return from this
    function call until the Control Dispatcher is told to shut down.
    The Control Dispatcher is responsible for connecting to the Service
    Controller's control pipe, and receiving messages from that pipe.
    The Control Dispatcher then dispatches the control messages to the
    correct control handling routine.

Arguments:

    lpServiceStartTable - This is a pointer to the top of a service dispatch
        table that the service main process passes in.  Each table entry
        contains pointers to the ServiceName, and the ServiceStartRotuine.

Return Value:

    NO_ERROR - The Control Dispatcher successfully terminated.

    ERROR_INVALID_DATA - The specified dispatch table does not contain
        entries in the proper format.

    ERROR_FAILED_SERVICE_CONTROLLER_CONNECT - The Control Dispatcher
        could not connect with the Service Controller.

    ERROR_SERVICE_ALREADY_RUNNING - The function has already been called
        from within the current process
--*/
{
    DWORD                       status;
    NTSTATUS                    ntStatus;
    HANDLE                      pipeHandle;

    //
    // Make sure this is the only time the control dispatcher is being called
    //
    if (InterlockedExchange(&g_fCalledBefore, 1) == 1) {

       //
       // Problem -- the control dispatcher was already called from this process
       //
       SetLastError(ERROR_SERVICE_ALREADY_RUNNING);
       return(FALSE);
    }

    //
    // Create the Real Dispatch Table
    //

    __try {
        status = ScCreateDispatchTableW((LPSERVICE_TABLE_ENTRYW)lpServiceStartTable, &DispatchTable);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            SCC_LOG(ERROR,"StartServiceCtrlDispatcherW:Unexpected Exception 0x%lx\n",status);
        }
    }
    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }

    //
    // Allocate a buffer big enough to contain at least the control message
    // header and a service name.  This ensures that if the message is not
    // a message with arguments, it can be read in a single ReadFile.
    //
    BYTE  bPipeMessageHeader[sizeof(CTRL_MSG_HEADER) +
                                (MAX_SERVICE_NAME_LENGTH+1) * sizeof(WCHAR)];

    //
    // Connect to the Service Controller
    //

    status = ScConnectServiceController(&pipeHandle);
    if (status != NO_ERROR) {

        //
        // If they're different, it's because we allocated the real name.
        // Only check the first entry since this can only happen in the
        // SERVICE_OWN_PROCESS case
        //
        if (DispatchTable->ServiceName != DispatchTable->ServiceRealName) {
            LocalFree(DispatchTable->ServiceRealName);
        }

        LocalFree(DispatchTable);
        SetLastError(status);
        return(FALSE);
    }

    //
    // Initialize the binding for the status interface (NetServiceStatus).
    //

    SCC_LOG(TRACE,"Initialize the Status binding\n",0);

    ntStatus = InitializeStatusBinding();

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        CloseHandle(pipeHandle);

        //
        // If they're different, it's because we allocated the real name.
        // Only check the first entry since this can only happen in the
        // SERVICE_OWN_PROCESS case
        //
        if (DispatchTable->ServiceName != DispatchTable->ServiceRealName) {
            LocalFree(DispatchTable->ServiceRealName);
        }

        LocalFree(DispatchTable);
        SetLastError(status);
        return(FALSE);
    }

    //
    // Enter the dispatcher loop where we service control requests until
    // all services in the service table have terminated.
    //
    ScDispatcherLoop(pipeHandle,
                     (LPCTRL_MSG_HEADER)&bPipeMessageHeader,
                     sizeof(bPipeMessageHeader));

    CloseHandle(pipeHandle);

    //
    // If they're different, it's because we allocated the real name.
    // Only check the first entry since this can only happen in the
    // SERVICE_OWN_PROCESS case
    //
    if (DispatchTable->ServiceName != DispatchTable->ServiceRealName) {
        LocalFree(DispatchTable->ServiceRealName);
    }

    return(TRUE);
}



VOID
ScDispatcherLoop(
    IN  HANDLE              PipeHandle,
    IN  LPCTRL_MSG_HEADER   Msg,
    IN  DWORD               dwBufferSize
    )

/*++

Routine Description:

    This is the input loop that the Control Dispatcher stays in through-out
    its life.  Only two types of events will cause us to leave this loop:

        1) The service controller instructed the dispatcher to exit.
        2) The dispatcher can no longer communicate with the the
           service controller.

Arguments:

    PipeHandle:  This is a handle to the pipe over which control
        requests are received.

Return Value:

    none


--*/
{
    DWORD                       status;
    DWORD                       controlStatus;
    BOOL                        continueDispatch;
    LPWSTR                      serviceName   = NULL;
    LPSERVICE_PARAMS            lpServiceParams;
    LPTHREAD_START_ROUTINE      threadAddress = NULL;
    LPVOID                      threadParms   = NULL;
    LPTHREAD_STARTUP_PARMSA     lpspAnsiParms;
    LPINTERNAL_DISPATCH_ENTRY   dispatchEntry = NULL;
    DWORD                       threadId;
    HANDLE                      threadHandle;
    DWORD                       i;
    DWORD                       errorCount      = 0;
    DWORD                       dwHandlerRetVal = NO_ERROR;

    //
    // Input Loop
    //

    continueDispatch = TRUE;

#if defined(_X86_)
    //
    // Detect if this is a Wow64 Process ?
    //
    DetectWow64Process();
#endif

    do {
        //
        // Wait for input
        //
        controlStatus = ScGetPipeInput(PipeHandle,
                                       Msg,
                                       dwBufferSize,
                                       &lpServiceParams);

        //
        // If we received good input, check to see if we are to shut down
        // the ControlDispatcher.  If not, then obtain the dispatchEntry
        // from the dispatch table.
        //

        if (controlStatus == NO_ERROR) {

            //
            // Clear the error count
            //
            errorCount = 0;

            serviceName = (LPWSTR) ((LPBYTE)Msg + Msg->ServiceNameOffset);

            SCC_LOG(TRACE, "Read from pipe succeeded for service %ws\n", serviceName);

            if ((serviceName[0] == L'\0') &&
                (Msg->OpCode == SERVICE_STOP)) {

                //
                // The Dispatcher is being asked to shut down.
                //    (security check not required for this operation)
                //    although perhaps it would be a good idea to verify
                //    that the request came from the Service Controller.
                //
                controlStatus    = NO_ERROR;
                continueDispatch = FALSE;
            }
            else {
                dispatchEntry = DispatchTable;

                if (Msg->OpCode == SERVICE_CONTROL_START_OWN) {
                    dispatchEntry->dwFlags |= SERVICE_OWN_PROCESS;
                }

                //
                // Search the dispatch table to find the service's entry
                //
                if (!(dispatchEntry->dwFlags & SERVICE_OWN_PROCESS)) {
                    controlStatus = ScGetDispatchEntry(&dispatchEntry, serviceName);
                }

                if (controlStatus != NO_ERROR) {
                    SCC_LOG(TRACE,"Service Name not in Dispatch Table\n",0);
                }
            }
        }
        else {
            if (controlStatus != ERROR_NOT_ENOUGH_MEMORY) {

                //
                // If an error occured and it is not an out-of-memory error,
                // then the pipe read must have failed.
                // In this case we Increment the error count.
                // When this count reaches the MAX_RETRY_COUNT, then
                // the service controller must be gone.  We want to log an
                // error and notify an administrator.  Then go to sleep forever.
                // Only a re-boot will solve this problem.
                //
                // We should be able to report out-of-memory errors back to
                // the caller.  It should be noted that out-of-memory errors
                // do not clear the error count.  But they don't add to it
                // either.
                //

                errorCount++;
                if (errorCount > MAX_RETRY_COUNT) {

                    Sleep(0xffffffff);
                }
            }
        }

        //
        // Dispatch the request
        //
        if ((continueDispatch == TRUE) && (controlStatus == NO_ERROR)) {

            status = NO_ERROR;

            switch(Msg->OpCode) {

            case SERVICE_CONTROL_START_SHARE:
            case SERVICE_CONTROL_START_OWN:
            {
                SC_HANDLE  hScManager = OpenSCManagerW(NULL,
                                                       NULL,
                                                       SC_MANAGER_CONNECT);

                if (hScManager == NULL) {

                    status = GetLastError();

                    SCC_LOG1(ERROR,
                             "ScDispatcherLoop: OpenSCManagerW FAILED %d\n",
                             status);
                }
                else {

                    //
                    // Update the StatusHandle in the dispatch entry table
                    //

                    dispatchEntry->StatusHandle = OpenServiceW(hScManager,
                                                               serviceName,
                                                               SERVICE_SET_STATUS);

                    if (dispatchEntry->StatusHandle == NULL) {

                        status = GetLastError();

                        SCC_LOG1(ERROR,
                                 "ScDispatcherLoop: OpenServiceW FAILED %d\n",
                                 status);
                    }

                    CloseServiceHandle(hScManager);
                }

                if (status == NO_ERROR
                     &&
                    (dispatchEntry->dwFlags & SERVICE_OWN_PROCESS)
                     &&
                    (_wcsicmp(dispatchEntry->ServiceName, serviceName) != 0))
                {
                    //
                    // Since we don't look up the dispatch record in the OWN_PROCESS
                    // case (and can't since it will break existing services), there's
                    // no guarantee that the name in the dispatch table (acquired from
                    // the RegisterServiceCtrlHandler call) is the real key name of
                    // the service.  Since the SCM passes across the real name when
                    // the service is started, save it away here if necessary.
                    //

                    dispatchEntry->ServiceRealName = (LPWSTR)LocalAlloc(
                                                                 LMEM_FIXED,
                                                                 WCSSIZE(serviceName)
                                                                 );

                    if (dispatchEntry->ServiceRealName == NULL) {

                        //
                        // In case somebody comes searching for the handle (though
                        // they shouldn't), it's nicer to return an incorrect name
                        // than to AV trying to copy a NULL pointer.
                        //
                        SCC_LOG1(ERROR,
                                 "ScDispatcherLoop: Could not duplicate name for service %ws\n",
                                 serviceName);

                        dispatchEntry->ServiceRealName = dispatchEntry->ServiceName;
                        status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else {
                        wcscpy(dispatchEntry->ServiceRealName, serviceName);
                    }
                }

                if (status == NO_ERROR) {

                    //
                    // The Control Dispatcher is to start a service.
                    // start the new thread.
                    //
                    lpServiceParams->ThreadStartupParms.ServiceStartRoutine =
                        dispatchEntry->ServiceStartRoutine.U;

                    threadAddress = (LPTHREAD_START_ROUTINE)ScSvcctrlThreadW;
                    threadParms   = (LPVOID)&lpServiceParams->ThreadStartupParms;

                    //
                    // If the service needs to be called with ansi parameters,
                    // then do the conversion here.
                    //
                    if (AnsiFlag) {

                        lpspAnsiParms = (LPTHREAD_STARTUP_PARMSA)
                                            &lpServiceParams->ThreadStartupParms;

                        for (i = 0;
                             i < lpServiceParams->ThreadStartupParms.NumArgs;
                             i++) {

                            if (!ScConvertToAnsi(
                                 *(&lpspAnsiParms->VectorTable + i),
                                 *(&lpServiceParams->ThreadStartupParms.VectorTable + i))) {

                                //
                                // Conversion error occured.
                                //
                                SCC_LOG0(ERROR,
                                         "ScDispatcherLoop: Could not convert "
                                             "args to ANSI\n");

                                status = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        threadAddress = (LPTHREAD_START_ROUTINE)ScSvcctrlThreadA;
                        threadParms   = lpspAnsiParms;
                    }
                }

                if (status == NO_ERROR){

                    //
                    // Create the new thread
                    //
                    threadHandle = CreateThread (
                        NULL,                       // Thread Attributes.
                        0L,                         // Stack Size
                        threadAddress,              // lpStartAddress
                        threadParms,                // lpParameter
                        0L,                         // Creation Flags
                        &threadId);                 // lpThreadId

                    if (threadHandle == NULL) {

                        SCC_LOG(ERROR,
                                "ScDispatcherLoop: CreateThread failed %d\n",
                                GetLastError());

                        status = ERROR_SERVICE_NO_THREAD;
                    }
                    else {
                        CloseHandle(threadHandle);
                    }
                }
                break;
            }

            default:

                if (dispatchEntry->ControlHandler.Ex != NULL) {

                    __try {

                        //
                        // Call the proper ControlHandler routine.
                        //
                        if (dispatchEntry->dwFlags & SERVICE_EX_HANDLER)
                        {
                            SCC_LOG2(TRACE,
                                     "Calling extended ControlHandler routine %x "
                                     "for service %ws\n",
                                     Msg->OpCode,
                                     serviceName);

                            if (lpServiceParams)
                            {
                                dwHandlerRetVal = dispatchEntry->ControlHandler.Ex(
                                                      Msg->OpCode,
                                                      lpServiceParams->HandlerExParms.dwEventType,
                                                      lpServiceParams->HandlerExParms.lpEventData,
                                                      dispatchEntry->pContext);
                            }
                            else
                            {
                                dwHandlerRetVal = dispatchEntry->ControlHandler.Ex(
                                                      Msg->OpCode,
                                                      0,
                                                      NULL,
                                                      dispatchEntry->pContext);
                            }

                            SCC_LOG3(TRACE,
                                     "Extended ControlHandler routine %x "
                                     "returned %d from call to service %ws\n",
                                     Msg->OpCode,
                                     dwHandlerRetVal,
                                     serviceName);
                        }
                        else if (IS_NON_EX_CONTROL(Msg->OpCode))
                        {
                            SCC_LOG2(TRACE,
                                     "Calling ControlHandler routine %x "
                                     "for service %ws\n",
                                     Msg->OpCode,
                                     serviceName);


#if defined(_X86_)
                            //
                            // Hack for __CDECL callbacks.  The Windows NT 3.1
                            // SDK didn't prototype control handler functions
                            // as WINAPI, so a number of existing 3rd-party
                            // services have their control handler functions
                            // built as __cdecl instead.  This is a workaround.
                            // Note that the call to the control handler must
                            // be the only code between the _asm statements
                            //
                            DWORD SaveEdi;
                            _asm mov SaveEdi, edi;
                            _asm mov edi, esp;      // Both __cdecl and WINAPI
                                                    // functions preserve EDI
#endif
                            //
                            // Do not add code here
                            //
                            dispatchEntry->ControlHandler.Regular(Msg->OpCode);
                            //
                            // Do not add code here
                            //
#if defined(_X86_)
                            _asm mov esp, edi;
                            _asm mov edi, SaveEdi;
#endif

                            SCC_LOG2(TRACE,
                                     "ControlHandler routine %x returned from "
                                     "call to service %ws\n",
                                     Msg->OpCode,
                                     serviceName);
                        }
                        else
                        {
                            //
                            // Service registered for an extended control without
                            // registering an extended handler.  The call into the
                            // service process succeeded, so keep status as NO_ERROR.
                            // Return an error from the "handler" to notify anybody
                            // watching for the return code (especially PnP).
                            //

                            dwHandlerRetVal = ERROR_CALL_NOT_IMPLEMENTED;
                        }
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        SCC_LOG2(ERROR,
                                 "ScDispatcherLoop: Exception 0x%lx "
                                 "occurred in service %ws\n",
                                 GetExceptionCode(),
                                 serviceName);

                        status = ERROR_EXCEPTION_IN_SERVICE;
                    }
                }
                else
                {
                    //
                    // There is no control handling routine
                    // registered for this service
                    //
                    status = ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
                }

                LocalFree(lpServiceParams);
                lpServiceParams = NULL;

                // If status is not good here, then an exception occured
                // either because the pointer to the control handling
                // routine was bad, or because an exception occured
                // inside the control handling routine.
                //
                // ??EVENTLOG??
                //

                break;

            } // end switch.

            //
            // Send the status back to the sevice controller.
            //
            if (Msg->OpCode != SERVICE_CONTROL_SHUTDOWN)
            {
                SCC_LOG(TRACE, "Service %ws about to send response\n", serviceName);
                ScSendResponse (PipeHandle, status, dwHandlerRetVal);
                SCC_LOG(TRACE, "Service %ws returned from sending response\n", serviceName);
            }
        }
        else {

            //
            // The controlStatus indicates failure, we always want to try
            // to send the status back to the Service Controller.
            //

            SCC_LOG2(TRACE,
                     "Service %ws about to send response on error %lu\n",
                     serviceName,
                     controlStatus);

            ScSendResponse(PipeHandle, controlStatus, dwHandlerRetVal);

            SCC_LOG2(TRACE,
                     "Service %ws returned from sending response on error %lu\n",
                     serviceName,
                     controlStatus);

            switch (controlStatus) {

            case ERROR_SERVICE_NOT_IN_EXE:
            case ERROR_SERVICE_NO_THREAD:

                //
                // The Service Name is not in this .exe's dispatch table.
                // Or a thread for a new service couldn't be created.
                // ignore it.  The Service Controller will tell us to
                // shut down if necessary.
                //
                controlStatus = NO_ERROR;
                break;

            default:

                //
                // If the error is not specifically recognized, continue.
                //
                controlStatus = NO_ERROR;
                break;
            }
        }
    }
    while (continueDispatch == TRUE);

    return;
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerHelp (
    IN  LPCWSTR                  ServiceName,
    IN  HANDLER_FUNCTION_TYPE    ControlHandler,
    IN  PVOID                    pContext,
    IN  DWORD                    dwFlags
    )

/*++

Routine Description:

    This helper function enters a pointer to a control handling routine
    and a pointer to a security descriptor into the Control Dispatcher's
    dispatch table.  It does the work for the RegisterServiceCtrlHandler*
    family of APIs

Arguments:

    ServiceName - This is a pointer to the Service Name string.

    ControlHandler - This is a pointer to the service's control handling
        routine.

    pContext - This is a pointer to context data supplied by the user.

    dwFlags - This is a set of flags that give information about the
        control handling routine (currently only discerns between extended
        and non-extended handlers)

Return Value:

    This function returns a handle to the service that is to be used in
    subsequent calls to SetServiceStatus.  If the return value is NULL,
    an error has occured, and GetLastError can be used to obtain the
    error value.  Possible values for error are:

    NO_ERROR - If the operation was successful.

    ERROR_INVALID_PARAMETER - The pointer to the control handler function
        is NULL.

    ERROR_INVALID_DATA -

    ERROR_SERVICE_NOT_IN_EXE - The serviceName could not be found in
        the dispatch table.  This indicates that the configuration database
        says the serice is in this process, but the service name doesn't
        exist in the dispatch table.

--*/
{

    DWORD                       status;
    LPINTERNAL_DISPATCH_ENTRY   dispatchEntry;

    //
    // Find the service in the dispatch table.
    //
    dispatchEntry = DispatchTable;
    __try {
        status = ScGetDispatchEntry(&dispatchEntry, (LPWSTR) ServiceName);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            SCC_LOG(ERROR,
                    "RegisterServiceCtrlHandlerHelp: Unexpected Exception 0x%lx\n",
                    status);
        }
    }

    if(status != NO_ERROR) {
        SCC_LOG(ERROR,
            "RegisterServiceCtrlHandlerHelp: can't find dispatch entry\n",0);

        SetLastError(status);
        return(0L);
    }

    //
    // Insert the ControlHandler pointer
    //
    if (ControlHandler.Ex == NULL) {
        SCC_LOG(ERROR,
                "RegisterServiceCtrlHandlerHelp: Ptr to ctrlhandler is NULL\n",
                0);

        SetLastError(ERROR_INVALID_PARAMETER);
        return(0L);
    }

    //
    // Insert the entries into the table
    //
    if (dwFlags & SERVICE_EX_HANDLER) {
        dispatchEntry->dwFlags          |= SERVICE_EX_HANDLER;
        dispatchEntry->ControlHandler.Ex = ControlHandler.Ex;
        dispatchEntry->pContext          = pContext;
    }
    else {
        dispatchEntry->dwFlags               &= ~(SERVICE_EX_HANDLER);
        dispatchEntry->ControlHandler.Regular = ControlHandler.Regular;
    }

    //
    // This cast is OK -- see comment in I_ScPnPGetServiceName
    //
    return( (SERVICE_STATUS_HANDLE) dispatchEntry->StatusHandle );
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerW (
    IN  LPCWSTR               ServiceName,
    IN  LPHANDLER_FUNCTION    ControlHandler
    )
/*++

Routine Description:

    This function enters a pointer to a control handling
    routine into the Control Dispatcher's dispatch table.

Arguments:

    ServiceName     -- The service's name
    ControlHandler  -- Pointer to the control handling routine

Return Value:

    Anything returned by RegisterServiceCtrlHandlerHelp

--*/
{
    HANDLER_FUNCTION_TYPE   Handler;

    Handler.Regular = ControlHandler;

    return RegisterServiceCtrlHandlerHelp(ServiceName,
                                          Handler,
                                          NULL,
                                          0);
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerA (
    IN  LPCSTR                ServiceName,
    IN  LPHANDLER_FUNCTION    ControlHandler
    )
/*++

Routine Description:

    This is the ansi entry point for RegisterServiceCtrlHandler.

Arguments:



Return Value:



--*/
{
    LPWSTR                  ServiceNameW;
    SERVICE_STATUS_HANDLE   statusHandle;

    if (!ScConvertToUnicode(&ServiceNameW, ServiceName)) {

        //
        // This can only fail because of a failed LocalAlloc call
        // or else the ansi string is garbage.
        //
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(0L);
    }
    statusHandle = RegisterServiceCtrlHandlerW(ServiceNameW, ControlHandler);

    LocalFree(ServiceNameW);

    return(statusHandle);
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerExW (
    IN  LPCWSTR                  ServiceName,
    IN  LPHANDLER_FUNCTION_EX    ControlHandler,
    IN  PVOID                    pContext
    )

/*++

Routine Description:

    This function enters a pointer to an extended control handling
    routine into the Control Dispatcher's dispatch table.  It is
    analogous to RegisterServiceCtrlHandlerW.

Arguments:

    ServiceName     -- The service's name
    ControlHandler  -- A pointer to an extended control handling routine
    pContext        -- User-supplied data that is passed to the control handler

Return Value:

    Anything returned by RegisterServiceCtrlHandlerHelp

--*/
{
    HANDLER_FUNCTION_TYPE   Handler;

    Handler.Ex = ControlHandler;

    return RegisterServiceCtrlHandlerHelp(ServiceName,
                                          Handler,
                                          pContext,
                                          SERVICE_EX_HANDLER);
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerExA (
    IN  LPCSTR                 ServiceName,
    IN  LPHANDLER_FUNCTION_EX  ControlHandler,
    IN  PVOID                  pContext
    )
/*++

Routine Description:

    This is the ansi entry point for RegisterServiceCtrlHandlerEx.

Arguments:



Return Value:



--*/
{
    LPWSTR                  ServiceNameW;
    SERVICE_STATUS_HANDLE   statusHandle;

    if(!ScConvertToUnicode(&ServiceNameW, ServiceName)) {

        //
        // This can only fail because of a failed LocalAlloc call
        // or else the ansi string is garbage.
        //
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(0L);
    }
    statusHandle = RegisterServiceCtrlHandlerExW(ServiceNameW,
                                                 ControlHandler,
                                                 pContext);

    LocalFree(ServiceNameW);

    return(statusHandle);
}


DWORD
ScCreateDispatchTableW(
    IN  CONST SERVICE_TABLE_ENTRYW  *lpServiceStartTable,
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchTablePtr
    )

/*++

Routine Description:

    This routine allocates space for the Control Dispatchers Dispatch Table.
    It also initializes the table with the data that the service main
    routine passed in with the lpServiceStartTable parameter.

    This routine expects that pointers in the user's dispatch table point
    to valid information.  And that that information will stay valid and
    fixed through out the life of the Control Dispatcher.  In otherwords,
    the ServiceName string better not move or get cleared.

Arguments:

    lpServiceStartTable - This is a pointer to the first entry in the
        dispatch table that the service's main routine passed in .

    DispatchTablePtr - This is a pointer to the location where the
        Service Controller's dispatch table is to be stored.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation failed.

    ERROR_INVALID_PARAMETER - There are no entries in the dispatch table.

--*/
{
    DWORD                       numEntries;
    LPINTERNAL_DISPATCH_ENTRY   dispatchTable;
    const SERVICE_TABLE_ENTRYW * entryPtr;

    //
    // Count the number of entries in the user dispatch table
    //

    numEntries = 0;
    entryPtr = lpServiceStartTable;

    while (entryPtr->lpServiceName != NULL) {
        numEntries++;
        entryPtr++;
    }

    if (numEntries == 0) {
        SCC_LOG(ERROR,"ScCreateDispatchTable:No entries in Dispatch table!\n",0);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Allocate space for the Control Dispatcher's Dispatch Table
    //

    dispatchTable = (LPINTERNAL_DISPATCH_ENTRY)LocalAlloc(LMEM_ZEROINIT,
                        sizeof(INTERNAL_DISPATCH_ENTRY) * (numEntries + 1));

    if (dispatchTable == NULL) {
        SCC_LOG(ERROR,"ScCreateDispatchTable: Local Alloc failed rc = %d\n",
            GetLastError());
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Move user dispatch info into the Control Dispatcher's table.
    //

    *DispatchTablePtr = dispatchTable;
    entryPtr = lpServiceStartTable;

    while (entryPtr->lpServiceName != NULL) {
        dispatchTable->ServiceName          = entryPtr->lpServiceName;
        dispatchTable->ServiceRealName      = entryPtr->lpServiceName;
        dispatchTable->ServiceStartRoutine.U= entryPtr->lpServiceProc;
        dispatchTable->ControlHandler.Ex    = NULL;
        dispatchTable->StatusHandle         = NULL;
        dispatchTable->dwFlags              = 0;
        entryPtr++;
        dispatchTable++;
    }

    return (NO_ERROR);
}

DWORD
ScCreateDispatchTableA(
    IN  CONST SERVICE_TABLE_ENTRYA  *lpServiceStartTable,
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchTablePtr
    )

/*++

Routine Description:

    This routine allocates space for the Control Dispatchers Dispatch Table.
    It also initializes the table with the data that the service main
    routine passed in with the lpServiceStartTable parameter.

    This routine expects that pointers in the user's dispatch table point
    to valid information.  And that that information will stay valid and
    fixed through out the life of the Control Dispatcher.  In otherwords,
    the ServiceName string better not move or get cleared.

Arguments:

    lpServiceStartTable - This is a pointer to the first entry in the
        dispatch table that the service's main routine passed in .

    DispatchTablePtr - This is a pointer to the location where the
        Service Controller's dispatch table is to be stored.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation failed.

    ERROR_INVALID_PARAMETER - There are no entries in the dispatch table.

--*/
{
    DWORD                       numEntries;
    DWORD                       status = NO_ERROR;
    LPINTERNAL_DISPATCH_ENTRY   dispatchTable;
    const SERVICE_TABLE_ENTRYA * entryPtr;

    //
    // Count the number of entries in the user dispatch table
    //

    numEntries = 0;
    entryPtr = lpServiceStartTable;

    while (entryPtr->lpServiceName != NULL) {
        numEntries++;
        entryPtr++;
    }

    if (numEntries == 0) {
        SCC_LOG(ERROR,"ScCreateDispatchTable:No entries in Dispatch table!\n",0);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Allocate space for the Control Dispatcher's Dispatch Table
    //

    dispatchTable = (LPINTERNAL_DISPATCH_ENTRY)LocalAlloc(LMEM_ZEROINIT,
                        sizeof(INTERNAL_DISPATCH_ENTRY) * (numEntries + 1));

    if (dispatchTable == NULL) {
        SCC_LOG(ERROR,"ScCreateDispatchTableA: Local Alloc failed rc = %d\n",
            GetLastError());
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Move user dispatch info into the Control Dispatcher's table.
    //

    *DispatchTablePtr = dispatchTable;
    entryPtr = lpServiceStartTable;

    while (entryPtr->lpServiceName != NULL) {

        //
        // Convert the service name to unicode
        //

        __try {
            if (!ScConvertToUnicode(
                    &(dispatchTable->ServiceName),
                    entryPtr->lpServiceName)) {

                //
                // The convert failed.
                //
                SCC_LOG(ERROR,"ScCreateDispatcherTableA:ScConvertToUnicode failed\n",0);

                //
                // This is the only reason for failure that I can think of.
                //
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
            if (status != EXCEPTION_ACCESS_VIOLATION) {
                SCC_LOG(ERROR,
                    "ScCreateDispatchTableA: Unexpected Exception 0x%lx\n",status);
            }
        }
        if (status != NO_ERROR) {
            //
            // If an error occured, free up the allocated resources.
            //
            dispatchTable = *DispatchTablePtr;

            while (dispatchTable->ServiceName != NULL) {
                LocalFree(dispatchTable->ServiceName);
                dispatchTable++;
            }
            LocalFree(*DispatchTablePtr);
            return(status);
        }

        //
        // Fill in the rest of the dispatch entry.
        //
        dispatchTable->ServiceRealName      = dispatchTable->ServiceName;
        dispatchTable->ServiceStartRoutine.A= entryPtr->lpServiceProc;
        dispatchTable->ControlHandler.Ex    = NULL;
        dispatchTable->StatusHandle         = NULL;
        dispatchTable->dwFlags              = 0;
        entryPtr++;
        dispatchTable++;
    }

    return (NO_ERROR);
}


DWORD
ScReadServiceParms(
    IN  LPCTRL_MSG_HEADER       Msg,
    IN  DWORD                   dwNumBytesRead,
    OUT LPBYTE                  *ppServiceParams,
    OUT LPBYTE                  *ppTempArgPtr,
    OUT LPDWORD                 lpdwRemainingArgBytes
    )

/*++

Routine Description:

    This routine calculates the number of bytes needed for the service's
    control parameters by using the arg count information in the
    message header.  The parameter structure is allocated and
    as many bytes of argument information as have been captured so far
    are placed into the buffer.  A second read of the pipe may be necessary
    to obtain the remaining bytes of argument information.

    NOTE:  This function allocates enough space in the startup parameter
    buffer for the service name and pointer as well as the rest of the
    arguments.  However, it does not put the service name into the argument
    list.  This is because it may take two calls to this routine to
    get all the argument information.  We can't insert the service name
    string until we have all the rest of the argument data.

    [serviceNamePtr][argv1][argv2]...[argv1Str][argv2Str]...[serviceNameStr]

    or

    [serviceNamePtr][dwEventType][EventData][serviceNameStr]


Arguments:

    Msg - A pointer to the pipe message header.

    dwNumBytesRead - The number of bytes read in the first pipe read.

    ppServiceParams - A pointer to a location where the pointer to the
        thread startup parameter structure is to be placed.

    ppTempArgPtr - A location that will contain the pointer to where
        more argument data can be placed by a second read of the pipe.

    lpdwRemainingArgBytes - Returns with a count of the number of argument
        bytes that remain to be read from the pipe.

Return Value:

    NO_ERROR - If the operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - If the memory allocation was unsuccessful.

Note:


--*/
{
    DWORD            dwNameSize;         // num bytes in ServiceName.
    DWORD            dwBufferSize;       // num bytes for parameter buffer
    LONG             lArgBytesRead;      // number of arg bytes in first read.
    LPSERVICE_PARAMS lpTempParams;

    //
    // Set out pointer to no arguments unless we discover otherwise
    //
    *ppTempArgPtr = NULL;

    SCC_LOG(TRACE,"ScReadServiceParms: Get service parameters from pipe\n",0);

    //
    // Note: Here we assume that the service name was read into the buffer
    // in its entirety.
    //
    dwNameSize = (DWORD) WCSSIZE((LPWSTR) ((LPBYTE) Msg + Msg->ServiceNameOffset));

    //
    // Calculate the size of buffer needed.  This will consist of a
    // SERVICE_PARAMS structure, plus the service name and a pointer
    // for it, plus the rest of the arg info sent in the message
    // (We are wasting 4 bytes here since the first pointer in
    // the vector table is accounted for twice - but what the heck!).
    //

    dwBufferSize = Msg->Count -
                   sizeof(CTRL_MSG_HEADER) +
                   sizeof(SERVICE_PARAMS) +
                   sizeof(LPWSTR);

    //
    // Allocate the memory for the service parameters
    //
    lpTempParams = (LPSERVICE_PARAMS)LocalAlloc (LMEM_ZEROINIT, dwBufferSize);

    if (lpTempParams == NULL)
    {
        SCC_LOG1(ERROR,
                "ScReadServiceParms: LocalAlloc failed rc = %d\n",
                GetLastError());

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lArgBytesRead          = dwNumBytesRead - sizeof(CTRL_MSG_HEADER) - dwNameSize;
    *lpdwRemainingArgBytes = Msg->Count - dwNumBytesRead;

    //
    // Unpack message-specific arguments
    //
    switch (Msg->OpCode) {

        case SERVICE_CONTROL_START_OWN:
        case SERVICE_CONTROL_START_SHARE:

            SCC_LOG(TRACE,"ScReadServiceParms: Starting a service\n", 0);

            if (Msg->NumCmdArgs != 0) {

                //
                // There's only a vector table and ThreadStartupParms
                // when the service starts up
                //
                *ppTempArgPtr = (LPBYTE)&lpTempParams->ThreadStartupParms.VectorTable;

                //
                // Leave the first vector location blank for the service name
                // pointer.
                //
                (*ppTempArgPtr) += sizeof(LPWSTR);

                //
                // adjust lArgBytesRead to remove any extra bytes that are
                // there for alignment.  If a name that is not in the dispatch
                // table is passed in, it could be larger than our buffer.
                // This could cause lArgBytesRead to become negative.
                // However it should fail safe anyway since the name simply
                // won't be recognized and an error will be returned.
                //
                lArgBytesRead -= (Msg->ArgvOffset - Msg->ServiceNameOffset - dwNameSize);

                //
                // Copy any portion of the command arg info from the first read
                // into the buffer that is to be used for the second read.
                //

                if (lArgBytesRead > 0) {

                    RtlCopyMemory(*ppTempArgPtr,
                                  (LPBYTE)Msg + Msg->ArgvOffset,
                                  lArgBytesRead);

                    *ppTempArgPtr += lArgBytesRead;
                }
            }
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
        case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
        case SERVICE_CONTROL_POWEREVENT:
        case SERVICE_CONTROL_SESSIONCHANGE:
        {
            //
            // This is a PnP, power, or TS message
            //
            SCC_LOG1(TRACE,
                     "ScReadServiceParms: Receiving PnP/power/TS event %x\n",
                     Msg->OpCode);

            //
            // adjust lArgBytesRead to remove any extra bytes that are
            // there for alignment.  If a name that is not in the dispatch
            // table is passed in, it could be larger than our buffer.
            // This could cause lArgBytesRead to become negative.
            // However it should fail safe anyway since the name simply
            // won't be recognized and an error will be returned.
            //
            lArgBytesRead -= (Msg->ArgvOffset - Msg->ServiceNameOffset - dwNameSize);

            *ppTempArgPtr = (LPBYTE) &lpTempParams->HandlerExParms.dwEventType;

            if (lArgBytesRead > 0)
            {
                LPBYTE             lpArgs;
                LPHANDLEREX_PARMS  lpHandlerExParms = (LPHANDLEREX_PARMS) (*ppTempArgPtr);

                lpArgs = (LPBYTE) Msg + Msg->ArgvOffset;
                lpHandlerExParms->dwEventType = *(LPDWORD) lpArgs;

                lpArgs += sizeof(DWORD);
                lArgBytesRead -= sizeof(DWORD);

                RtlCopyMemory(lpHandlerExParms + 1,
                              lpArgs,
                              lArgBytesRead);

                lpHandlerExParms->lpEventData = lpHandlerExParms + 1;

                *ppTempArgPtr = (LPBYTE) (lpHandlerExParms + 1) + lArgBytesRead;
            }

            break;
        }
    }

    *ppServiceParams = (LPBYTE) lpTempParams;

    return NO_ERROR;
}


DWORD
ScConnectServiceController(
    OUT LPHANDLE    PipeHandle
    )

/*++

Routine Description:

    This function connects to the Service Controller Pipe.

Arguments:

    PipeHandle - This is a pointer to the location where the PipeHandle
        is to be placed.

Return Value:

    NO_ERROR - if the operation was successful.

    ERROR_FAILED_SERVICE_CONTROLLER_CONNECT - if we failed to connect.


--*/

{
    BOOL    status;
    DWORD   apiStatus;
    DWORD   response;
    DWORD   pipeMode;
    DWORD   numBytesWritten;

    WCHAR wszPipeName[sizeof(CONTROL_PIPE_NAME) / sizeof(WCHAR) + PID_LEN] = CONTROL_PIPE_NAME;

    //
    // Generate the pipe name -- Security process uses PID 0 since the
    // SCM doesn't have the PID at connect-time (it gets it from the
    // pipe transaction with the LSA)
    //

    if (g_fIsSecProc) {
        response = 0;
    }
    else {

        //
        // Read this process's pipe ID from the registry.
        //
        HKEY    hCurrentValueKey;

        status = RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     "System\\CurrentControlSet\\Control\\ServiceCurrent",
                     0,
                     KEY_QUERY_VALUE,
                     &hCurrentValueKey);

        if (status == ERROR_SUCCESS)
        {
            DWORD   ValueType;
            DWORD   cbData = sizeof(response);

            status = RegQueryValueEx(
                        hCurrentValueKey,
                        NULL,                // Use key's unnamed value
                        0,
                        &ValueType,
                        (LPBYTE) &response,
                        &cbData);

            RegCloseKey(hCurrentValueKey);

            if (status != ERROR_SUCCESS || ValueType != REG_DWORD)
            {
                SCC_LOG(ERROR,
                        "ScConnectServiceController:  RegQueryValueEx FAILED %d\n",
                        status);

                return(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT);
            }
        }
        else
        {
            SCC_LOG(ERROR,
                    "ScConnectServiceController:  RegOpenKeyEx FAILED %d\n",
                    status);

            return(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT);
        }
    }

    _itow(response, wszPipeName + sizeof(CONTROL_PIPE_NAME) / sizeof(WCHAR) - 1, 10);

    status = WaitNamedPipeW (
                wszPipeName,
                CONTROL_WAIT_PERIOD);

    if (status != TRUE) {
        SCC_LOG(ERROR,"ScConnectServiceController:WaitNamedPipe failed rc = %d\n",
            GetLastError());
    }

    SCC_LOG(TRACE,"ScConnectServiceController:WaitNamedPipe success\n",0);


    *PipeHandle = CreateFileW(
                    wszPipeName,                        // lpFileName
                    GENERIC_READ | GENERIC_WRITE,       // dwDesiredAccess
                    FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
                    NULL,                               // lpSecurityAttributes
                    OPEN_EXISTING,                      // dwCreationDisposition
                    FILE_ATTRIBUTE_NORMAL,              // dwFileAttributes
                    0L);                                // hTemplateFile

    if (*PipeHandle == INVALID_HANDLE_VALUE) {
        SCC_LOG(ERROR,"ScConnectServiceController:CreateFile failed rc = %d\n",
            GetLastError());
        return(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT);
    }

    SCC_LOG(TRACE,"ScConnectServiceController:CreateFile success\n",0);


    //
    // Set pipe mode
    //

    pipeMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;
    status = SetNamedPipeHandleState (
                *PipeHandle,
                &pipeMode,
                NULL,
                NULL);

    if (status != TRUE) {
        SCC_LOG(ERROR,"ScConnectServiceController:SetNamedPipeHandleState failed rc = %d\n",
            GetLastError());
        return(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT);
    }
    else {
        SCC_LOG(TRACE,
            "ScConnectServiceController SetNamedPipeHandleState Success\n",0);
    }

    //
    // Send initial status - This is the process Id for the service process.
    //
    response = GetCurrentProcessId();

    apiStatus = WriteFile (
                *PipeHandle,
                &response,
                sizeof(response),
                &numBytesWritten,
                NULL);

    if (apiStatus != TRUE) {
        //
        // If this fails, there is a chance that the pipe is still in good
        // shape.  So we just go on.
        //
        // ??EVENTLOG??
        //
        SCC_LOG(ERROR,"ScConnectServiceController: WriteFile failed, rc= %d\n", GetLastError());
    }
    else {
        SCC_LOG(TRACE,
            "ScConnectServiceController: WriteFile success, bytes Written= %d\n",
            numBytesWritten);
    }

    return(NO_ERROR);
}


VOID
ScExpungeMessage(
    IN  HANDLE  PipeHandle
    )

/*++

Routine Description:

    This routine cleans the remaining portion of a message out of the pipe.
    It is called in response to an unsuccessful attempt to allocate the
    correct buffer size from the heap.  In this routine a small buffer is
    allocated on the stack, and successive reads are made until a status
    other than ERROR_MORE_DATA is received.

Arguments:

    PipeHandle - This is a handle to the pipe in which the message resides.

Return Value:

    none - If this operation fails, there is not much I can do about
           the data in the pipe.

--*/
{
#define EXPUNGE_BUF_SIZE    100

    DWORD      status;
    DWORD      dwNumBytesRead = 0;
    BYTE       msg[EXPUNGE_BUF_SIZE];


    do {
        status = ReadFile (
                    PipeHandle,
                    msg,
                    EXPUNGE_BUF_SIZE,
                    &dwNumBytesRead,
                    NULL);
    }
    while( status == ERROR_MORE_DATA);

}


DWORD
ScGetPipeInput (
    IN      HANDLE                  PipeHandle,
    IN OUT  LPCTRL_MSG_HEADER       Msg,
    IN      DWORD                   dwBufferSize,
    OUT     LPSERVICE_PARAMS        *ppServiceParams
    )

/*++

Routine Description:

    This routine reads a control message from the pipe and places it into
    a message buffer.  This routine also allocates a structure for
    the service thread information.  This structure will eventually
    contain everything that is needed to invoke the service startup
    routine in the context of a new thread.  Items contained in the
    structure are:
        1) The pointer to the startup routine,
        2) The number of arguments, and
        3) The table of vectors to the arguments.
    Since this routine has knowledge about the buffer size needed for
    the arguments, the allocation is done here.

Arguments:

    PipeHandle - This is the handle for the pipe that is to be read.

    Msg - This is a pointer to a buffer where the data is to be placed.

    dwBufferSize - This is the size (in bytes) of the buffer that data is to
        be placed in.

    ppServiceParams - This is the location where the command args will
        be placed

Return Value:

    NO_ERROR - if the operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to create a large
        enough buffer for the command line arguments.

    ERROR_INVALID_DATA - This is returned if we did not receive a complete
        CTRL_MESSAGE_HEADER on the first read.


    Any error that ReadFile might return could be returned by this function.
    (We may want to return something more specific like ERROR_READ_FAULT)

--*/
{
    DWORD       status;
    BOOL        readStatus;
    DWORD       dwNumBytesRead = 0;
    DWORD       dwRemainingArgBytes;
    LPBYTE      pTempArgPtr;

    *ppServiceParams = NULL;

    //
    // Read the header and name string from the pipe.
    // NOTE:  The number of bytes for the name string is determined by
    //   the longest service name in the service process.  If the actual
    //   string read is shorter, then the beginning of the command arg
    //   data may be read with this read.
    // Also note:  The buffer is large enough to accommodate the longest
    //   permissible service name.
    //

    readStatus = ReadFile(PipeHandle,
                          Msg,
                          dwBufferSize,
                          &dwNumBytesRead,
                          NULL);

    SCC_LOG(TRACE,"ScGetPipeInput:ReadFile buffer size = %ld\n",dwBufferSize);
    SCC_LOG(TRACE,"ScGetPipeInput:ReadFile dwNumBytesRead = %ld\n",dwNumBytesRead);


    if ((readStatus == TRUE) && (dwNumBytesRead > sizeof(CTRL_MSG_HEADER))) {

        //
        // The Read File read the complete message in one read.  So we
        // can return with the data.
        //

        SCC_LOG(TRACE,"ScGetPipeInput: Success!\n",0);

        switch (Msg->OpCode) {

            case SERVICE_CONTROL_START_OWN:
            case SERVICE_CONTROL_START_SHARE:

                //
                // Read in any start arguments for the service
                //
                status = ScReadServiceParms(Msg,
                                            dwNumBytesRead,
                                            (LPBYTE *)ppServiceParams,
                                            &pTempArgPtr,
                                            &dwRemainingArgBytes);

                if (status != NO_ERROR) {
                    return status;
                }

                //
                // Change the offsets back into pointers.
                //
                ScNormalizeCmdLineArgs(Msg,
                                       &(*ppServiceParams)->ThreadStartupParms);

                break;

            case SERVICE_CONTROL_DEVICEEVENT:
            case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
            case SERVICE_CONTROL_POWEREVENT:
            case SERVICE_CONTROL_SESSIONCHANGE:

                //
                // Read in the service's PnP/power arguments
                //
                status = ScReadServiceParms(Msg,
                                            dwNumBytesRead,
                                            (LPBYTE *)ppServiceParams,
                                            &pTempArgPtr,
                                            &dwRemainingArgBytes);

                if (status != NO_ERROR) {
                    return status;
                }

                break;

            default:
                ASSERT(Msg->NumCmdArgs == 0);
                break;
        }

        return NO_ERROR;
    }
    else {
        //
        // An error was returned from ReadFile.  ERROR_MORE_DATA
        // means that we need to read some arguments from the buffer.
        // Any other error is unexpected, and generates an internal error.
        //

        if (readStatus != TRUE) {
            status = GetLastError();
            if (status != ERROR_MORE_DATA) {

                SCC_LOG(ERROR,"ScGetPipeInput:Unexpected return code, rc= %ld\n",
                    status);

                return status;
            }
        }
        else {
            //
            // The read was successful, but we didn't get a complete
            // CTRL_MESSAGE_HEADER.
            //
            return ERROR_INVALID_DATA;
        }
    }

    //
    // We must have received an ERROR_MORE_DATA to go down this
    // path.  This means that the message contains more data.  Namely,
    // service arguments must be present. Therefore, the pipe must
    // be read again.  Since the header indicates how many bytes are
    // needed, we will allocate a buffer large enough to hold all the
    // service arguments.
    //
    // If a portion of the arguments was read in the first read,
    // they will be put in this new buffer.  That is so that all the
    // command line arg info is in one place.
    //
    status = ScReadServiceParms(Msg,
                                dwNumBytesRead,
                                (LPBYTE *)ppServiceParams,
                                &pTempArgPtr,
                                &dwRemainingArgBytes);


    if (status != NO_ERROR) {
        ScExpungeMessage(PipeHandle);
        return status;
    }

    readStatus = ReadFile(PipeHandle,
                          pTempArgPtr,
                          dwRemainingArgBytes,
                          &dwNumBytesRead,
                          NULL);

    if ((readStatus != TRUE) || (dwNumBytesRead < dwRemainingArgBytes)) {

        if (readStatus != TRUE) {
            status = GetLastError();
            SCC_LOG1(ERROR,
                    "ScGetPipeInput: ReadFile error (2nd read), rc = %ld\n",
                    status);
        }
        else {
            status = ERROR_BAD_LENGTH;
        }

        SCC_LOG2(ERROR,
                "ScGetPipeInput: ReadFile read: %d, expected: %d\n",
                dwNumBytesRead,
                dwRemainingArgBytes);

        LocalFree(*ppServiceParams);
        return status;
    }

    if (Msg->OpCode == SERVICE_CONTROL_START_OWN ||
        Msg->OpCode == SERVICE_CONTROL_START_SHARE) {

        //
        // Change the offsets back into pointers.
        //
        ScNormalizeCmdLineArgs(Msg, &(*ppServiceParams)->ThreadStartupParms);
    }

    return NO_ERROR;
}



DWORD
ScGetDispatchEntry (
    IN OUT  LPINTERNAL_DISPATCH_ENTRY   *DispatchEntryPtr,
    IN      LPWSTR                      ServiceName
    )

/*++

Routine Description:

    Finds an entry in the Dispatch Table for a particular service which
    is identified by a service name string.

Arguments:

    DispatchEntryPtr - As an input, the is a location where a pointer to
        the top of the DispatchTable is placed.  On return, this is the
        location where the pointer to the specific dispatch entry is to
        be placed.  This is an opaque pointer because it could be either
        ansi or unicode depending on the operational state of the dispatcher.

    ServiceName - This is a pointer to the service name string that was
        supplied by the service.  Note that it may not be the service's
        real name since we never check services that run in their own
        process (bug that can never be fixed since it will break existing
        services).  We must check for this name instead of the real
        one.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_SERVICE_NOT_IN_EXE - The serviceName could not be found in
        the dispatch table.  This indicates that the configuration database
        says the serice is in this process, but the service name doesn't
        exist in the dispatch table.

--*/
{
    LPINTERNAL_DISPATCH_ENTRY   entryPtr;
    DWORD                       found = FALSE;

    entryPtr = *DispatchEntryPtr;

    if (entryPtr->dwFlags & SERVICE_OWN_PROCESS) {
        return (NO_ERROR);
    }

    while (entryPtr->ServiceName != NULL) {
        if (_wcsicmp(entryPtr->ServiceName, ServiceName) == 0) {
            found = TRUE;
            break;
        }
        entryPtr++;
    }
    if (found) {
        *DispatchEntryPtr = entryPtr;
    }
    else {
        SCC_LOG(ERROR,"ScGetDispatchEntry: DispatchEntry not found\n"
        "    Configuration error - the %ws service is not in this .exe file!\n"
        "    Check the table passed to StartServiceCtrlDispatcher.\n", ServiceName);
        return(ERROR_SERVICE_NOT_IN_EXE);
    }

    return(NO_ERROR);
}



VOID
ScNormalizeCmdLineArgs(
    IN OUT  LPCTRL_MSG_HEADER       Msg,
    IN OUT  LPTHREAD_STARTUP_PARMSW ThreadStartupParms
    )

/*++

Routine Description:

    Normalizes the command line argument information that came across in
    the pipe.  The argument information is stored in a buffer that consists
    of an array of string pointers followed by the strings themselves.
    However, in the pipe, the pointers are replaced with offsets.  This
    routine transforms the offsets into real pointers.

    This routine also puts the service name into the array of argument
    vectors, and adds the service name string to the end of the
    buffer (space has already been allocated for it).

Arguments:

    Msg - This is a pointer to the Message.  Useful information from this
        includes the NumCmdArgs and the service name.

    ThreadStartupParms - A pointer to the thread startup parameter structure.

Return Value:

    none.

--*/
{
    DWORD   i;
    LPWSTR  *argv;
    DWORD   numCmdArgs;
    LPWSTR  *serviceNameVector;
    LPWSTR  serviceNamePtr;
#if defined(_X86_)
    PULONG64 argv64 = NULL;
#endif

    numCmdArgs = Msg->NumCmdArgs;

    argv = &(ThreadStartupParms->VectorTable);

    //
    // Save the first argv for the service name.
    //
    serviceNameVector = argv;
    argv++;

    //
    // Normalize the Command Line Argument information by replacing
    // offsets in buffer with pointers.
    //
    // NOTE:  The elaborate casting that takes place here is because we
    //   are taking some (pointer sized) offsets, and turning them back
    //   into pointers to strings.  The offsets are in bytes, and are
    //   relative to the beginning of the vector table which contains
    //   pointers to the various command line arg strings.
    //

#if defined(_X86_)
    if (g_fWow64Process) {
        //
        // Pointers on the 64-bit land are 64-bit so make argv
        // point to the 1st arg after the service name offset
        //
        argv64 = (PULONG64)argv;

    }
#endif

    for (i = 0; i < numCmdArgs; i++) {
#if defined(_X86_)
        if (g_fWow64Process)
            argv[i] = (LPWSTR)((LPBYTE)argv + PtrToUlong(argv64[i]));
        else
#endif
            argv[i] = (LPWSTR)((LPBYTE)argv + PtrToUlong(argv[i]));
    }


    //
    // If we are starting a service, then we need to add the service name
    // to the argument vectors.
    //
    if ((Msg->OpCode == SERVICE_CONTROL_START_SHARE) ||
        (Msg->OpCode == SERVICE_CONTROL_START_OWN))  {

        numCmdArgs++;

        if (numCmdArgs > 1) {
            //
            // Find the location for the service name string by finding
            // the pointer to the last argument adding its string length
            // to it.
            //
            serviceNamePtr = argv[i-1];
            serviceNamePtr += (wcslen(serviceNamePtr) + 1);
        }
        else {
            serviceNamePtr = (LPWSTR)argv;
        }
        wcscpy(serviceNamePtr, (LPWSTR) ((LPBYTE)Msg + Msg->ServiceNameOffset));
        *serviceNameVector = serviceNamePtr;
    }

    ThreadStartupParms->NumArgs = numCmdArgs;
}


VOID
ScSendResponse (
    IN  HANDLE  PipeHandle,
    IN  DWORD   Response,
    IN  DWORD   dwHandlerRetVal
    )

/*++

Routine Description:

    This routine sends a status response to the Service Controller's pipe.

Arguments:

    Response - This is the status message that is to be sent.

    dwHandlerRetVal - This is the return value from the service's control
                      handler function (NO_ERROR for non-Ex handlers)

Return Value:

    none.

--*/
{
    DWORD  numBytesWritten;

    PIPE_RESPONSE_MSG  prmResponse;

    prmResponse.dwDispatcherStatus = Response;
    prmResponse.dwHandlerRetVal    = dwHandlerRetVal;

    if (!WriteFile(PipeHandle,
                   &prmResponse,
                   sizeof(PIPE_RESPONSE_MSG),
                   &numBytesWritten,
                   NULL))
    {
        SCC_LOG1(ERROR,
                 "ScSendResponse: WriteFile failed, rc= %d\n",
                 GetLastError());
    }
}


DWORD
ScSvcctrlThreadW(
    IN LPTHREAD_STARTUP_PARMSW  lpThreadStartupParms
    )

/*++

Routine Description:

    This is the thread for the newly started service.  This code
    calls the service's main thread with parameters from the
    ThreadStartupParms structure.

    NOTE:  The first item in the argument vector table is the pointer to
           the service registry path string.

Arguments:

    lpThreadStartupParms - This is a pointer to the ThreadStartupParms
        structure. (This is a unicode structure);

Return Value:



--*/
{

    //
    // Call the Service's Main Routine.
    //
    ((LPSERVICE_MAIN_FUNCTIONW)lpThreadStartupParms->ServiceStartRoutine) (
        lpThreadStartupParms->NumArgs,
        &lpThreadStartupParms->VectorTable);

    LocalFree(lpThreadStartupParms);

    return(0);
}


DWORD
ScSvcctrlThreadA(
    IN LPTHREAD_STARTUP_PARMSA  lpThreadStartupParms
    )

/*++

Routine Description:

    This is the thread for the newly started service.  This code
    calls the service's main thread with parameters from the
    ThreadStartupParms structure.

    NOTE:  The first item in the argument vector table is the pointer to
           the service registry path string.

Arguments:

    lpThreadStartupParms - This is a pointer to the ThreadStartupParms
        structure. (This is a unicode structure);

Return Value:



--*/
{
    //
    // Call the Service's Main Routine.
    //
    // NOTE:  The first item in the argument vector table is the pointer to
    //  the service registry path string.
    //
    ((LPSERVICE_MAIN_FUNCTIONA)lpThreadStartupParms->ServiceStartRoutine) (
        lpThreadStartupParms->NumArgs,
        &lpThreadStartupParms->VectorTable);

    LocalFree(lpThreadStartupParms);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\client\template.c ===
/*++
Module Name:

    template.c

Abstract:

    This is a template for a service.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

//
// Includes
//

#include <windows.h>
#include <stdio.h>

//
// Globals
//

    SERVICE_STATUS          MyServiceStatus;
    SERVICE_STATUS_HANDLE   MyServiceStatusHandle;

//
// Function Prototypes
//

VOID
MyServiceStart (
    DWORD   argc,
    LPTSTR  *argv
    );

VOID
MyServiceCtrlHandler (
    IN  DWORD   opcode
    );

DWORD
MyServiceInitialization(
    DWORD   argc,
    LPTSTR  *argv,
    DWORD   *specificError
    );

VOID
SvcDebugOut(
    LPSTR   String,
    DWORD   Status
    );

/****************************************************************************/
VOID __cdecl
main(void)

/*++

Routine Description:

    This is the main routine for the service process.  If serveral services
    share the same process, then the names of those services are
    simply added to the DispatchTable.

    This thread calls StartServiceCtrlDispatcher which connects to the
    service controller and then waits in a loop for control requests.
    When all the services in the service process have terminated, the
    service controller will send a control request to the dispatcher
    telling it to shut down.  This thread with then return from the
    StartServiceCtrlDispatcher call so that the process can terminate.

Arguments:



Return Value:



--*/
{
    SERVICE_TABLE_ENTRY   DispatchTable[] = {
        { TEXT("MyService"),    MyServiceStart      },
        { NULL,                 NULL                }
    };

    if (!StartServiceCtrlDispatcher( DispatchTable)) {
        SvcDebugOut(" [MY_SERVICE] StartServiceCtrlDispatcher error = %d\n",
            GetLastError());
    }

}


/****************************************************************************/
void
MyServiceStart (
    DWORD   argc,
    LPTSTR  *argv
    )
/*++

Routine Description:

    This is the entry point for the service.  When the control dispatcher
    is told to start a service, it creates a thread that will begin
    executing at this point.  The function has access to command line
    arguments in the same manner as a main() routine.

Arguments:

    argc - Number of arguments being passed to the service.  This count will
        always be at least one.

    argv - A pointer to an array of string pointers.  The first string pointer
        (argv[0]) always points to the service name.

Return Value:



--*/
{
    DWORD   status;
    DWORD   specificError;

    //
    // Fill in this service's status structure.
    // Note, this service says it accepts PAUSE_CONTINUE.
    // However, it doesn't do anything interesting when told to
    // pause except return the SERVICE_PAUSED status.  This is here
    // only for the sake of filling out the template.  Pause is
    // meaningless for many services.  If it doesn't add value,
    // don't attempt to support PAUSE_CONTINUE.
    //

    MyServiceStatus.dwServiceType        = SERVICE_WIN32;
    MyServiceStatus.dwCurrentState       = SERVICE_START_PENDING;
    MyServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                           SERVICE_ACCEPT_PAUSE_CONTINUE;
    MyServiceStatus.dwWin32ExitCode      = 0;
    MyServiceStatus.dwServiceSpecificExitCode = 0;
    MyServiceStatus.dwCheckPoint         = 0;
    MyServiceStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    MyServiceStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("MyService"),
                            MyServiceCtrlHandler);

    if (MyServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        SvcDebugOut(" [MY_SERVICE] RegisterServiceCtrlHandler failed %d\n",
            GetLastError());
        return;
    }

    ////////////////////////////////////////////////////////////////
    //
    // This is where the service initialization code goes.
    // If initialization takes a long time, the code is expected to
    // call SetServiceStatus periodically in order to send out
    // wait hints indicating that progress is being made.
    //
    //

    status = MyServiceInitialization(argc,argv, &specificError);

    if (status != NO_ERROR) {
        MyServiceStatus.dwCurrentState       = SERVICE_STOPPED;
        MyServiceStatus.dwCheckPoint         = 0;
        MyServiceStatus.dwWaitHint           = 0;
        MyServiceStatus.dwWin32ExitCode      = status;
        MyServiceStatus.dwServiceSpecificExitCode = specificError;

        SetServiceStatus (MyServiceStatusHandle, &MyServiceStatus);
        return;
    }
    //
    //
    ////////////////////////////////////////////////////////////////

    //
    // Return the status to indicate we are done with intialization.
    //

    MyServiceStatus.dwCurrentState       = SERVICE_RUNNING;
    MyServiceStatus.dwCheckPoint         = 0;
    MyServiceStatus.dwWaitHint           = 0;

    if (!SetServiceStatus (MyServiceStatusHandle, &MyServiceStatus)) {
        status = GetLastError();
        SvcDebugOut(" [MY_SERVICE] SetServiceStatus error %ld\n",status);
    }

    //===============================================================
    // This is where the service does its work.  Since this service
    // doesn't do anything, this function will return.
    //
    // A real service should use this thread to do whatever work it
    // was designed to do.  If it doesn't require a thread to do
    // any work, then it should return to the caller.  It's
    // important to return, rather than call ExitThread.  Returning
    // allows for cleanup of the memory allocated for the arguments.
    // A service that only services RPC requests doesn't need this
    // thread.
    //
    //
    //===============================================================


    SvcDebugOut(" [MY_SERVICE] Returning the Main Thread \n",0);

    return;
}


/****************************************************************************/
VOID
MyServiceCtrlHandler (
    IN  DWORD   Opcode
    )

/*++

Routine Description:

    This function executes in the context of the Control Dispatcher's
    thread.  Therefore, it it not desirable to perform time-consuming
    operations in this function.

    If an operation such as a stop is going to take a long time, then
    this routine should send the STOP_PENDING status, and then
    signal the other service thread(s) that a stop is in progress.
    Then it should return so that the Control Dispatcher can service
    more requests.  One of the other service threads is then responsible
    for sending further wait hints, and the final SERVICE_STOPPED.


Arguments:

    Opcode - This is the control opcode that indicates what action the service
        should take.

Return Value:

    none

--*/
{

    DWORD   status;

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        //==========================================================
        //
        // Do whatever it takes to pause here.  Then set the status.
        // NOTE : Many services don't support pause.  If Pause isn't
        // supported, then this opcode should never be received.
        // However, in case it is, it is appropriate to fall out of
        // this switch and return status.
        //
        //==========================================================
        MyServiceStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        //=============================================================
        //
        // Do whatever it takes to continue here.  Then set the status.
        // (See note for PAUSE).
        //
        //=============================================================
        MyServiceStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        //=============================================================
        //
        // Do whatever it takes to stop here.  Then set the status.
        //
        // If stopping takes a long time and a SERVICE_STOP_PENDING
        // status is necessary, then this thread should notify or
        // create another thread to handle the shutdown.  In that case
        // this thread should send a SERVICE_STOP_PENDING and
        // then return.
        //
        //=============================================================
        MyServiceStatus.dwWin32ExitCode = 0;
        MyServiceStatus.dwCurrentState  = SERVICE_STOPPED;
        MyServiceStatus.dwCheckPoint    = 0;
        MyServiceStatus.dwWaitHint      = 0;

        if (!SetServiceStatus (MyServiceStatusHandle,  &MyServiceStatus)) {
            status = GetLastError();
            SvcDebugOut(" [MY_SERVICE] SetServiceStatus error %ld\n",status);
        }

        SvcDebugOut(" [MY_SERVICE] Leaving MyService \n",0);

        return;

    case SERVICE_CONTROL_INTERROGATE:

        //=============================================================
        //
        // All that needs to be done in this case is to send the
        // current status.
        //
        //=============================================================

        break;

    default:
        SvcDebugOut(" [MY_SERVICE] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (MyServiceStatusHandle,  &MyServiceStatus)) {
        status = GetLastError();
        SvcDebugOut(" [MY_SERVICE] SetServiceStatus error %ld\n",status);
    }
    return;
}

DWORD
MyServiceInitialization(
    DWORD   argc,
    LPTSTR  *argv,
    DWORD   *specificError
    )
{
    argv;
    argc;
    specificError;
    return(0);
}

VOID
SvcDebugOut(
    LPSTR   String,
    DWORD   Status
    )

/*++

Routine Description:

    Prints debug information to the debugger.


Arguments:

    String - A single string that can contain one formatted output character.

    Status - a value that will be used as the formatted character.

Return Value:

    none.

--*/
{
    CHAR  Buffer[1024];
    if (strlen(String) < 1000) {
        sprintf(Buffer,String,Status);
        OutputDebugStringA(Buffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\client\testserv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    testserv.c

Abstract:

    This is a test program for exercising the service controller.  This
    program acts like a service and exercises the Service Controller API
    that can be called from a service:
        NetServiceStartCtrlDispatcher
        NetServiceRegisterCtrlHandler
        NetServiceStatus

Author:

    Dan Lafferty (danl)     12 Apr-1991

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

--*/

//
// Includes
//

#define UNICODE 1
#include <nt.h>      // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <windef.h>
#include <nturtl.h>     // needed for winbase.h
#include <winbase.h>

#include <winsvc.h>

#include <winuser.h>    // MessageBox
#include <tstr.h>       // Unicode string macros
#include <lmcons.h>     // NET_API_STATUS for srvann.h
//#include <srvann.h>     // I_ScSetServiceBits
#include <lmserver.h>   // SV_TYPE_WORKSTATION, SetServiceBits

//
// Defines
//

#define PRIVILEGE_BUF_SIZE  512

#define INFINITE_WAIT_TIME  0xffffffff

#define NULL_STRING     TEXT("");


//
// Macros
//

#define SET_LKG_ENV_VAR(pString)                        \
    {                                                   \
    NTSTATUS        NtStatus;                           \
    UNICODE_STRING  Name,Value;                         \
                                                        \
    RtlInitUnicodeString(&Name, L"LastKnownGood");      \
    RtlInitUnicodeString(&Value,pString);               \
                                                        \
    NtStatus = NtSetSystemEnvironmentValue(&Name,&Value); \
    if (!NT_SUCCESS(NtStatus)) { \
        DbgPrint("Failed to set LKG environment variable 0x%lx\n",NtStatus); \
    } \
    status = RtlNtStatusToDosError(NtStatus); \
    }

//
// Globals
//

    SERVICE_STATUS  MsgrStatus;
    SERVICE_STATUS  SmfStaStatus;
    SERVICE_STATUS  LogonStatus;

    HANDLE          MessingerDoneEvent;
    HANDLE          WorkstationDoneEvent;
    HANDLE          LogonDoneEvent;

    SERVICE_STATUS_HANDLE   MsgrStatusHandle;
    SERVICE_STATUS_HANDLE   SmfStaStatusHandle;
    SERVICE_STATUS_HANDLE   LogonStatusHandle;


//
// Function Prototypes
//

DWORD
MessingerStart (
    DWORD   argc,
    LPTSTR  *argv
    );

DWORD
SmerfStationStart (
    DWORD   argc,
    LPTSTR  *argv
    );

DWORD
LogonStart (
    DWORD   argc,
    LPTSTR  *argv
    );

VOID
MsgrCtrlHandler (
    IN  DWORD   opcode
    );

VOID
SmfStaCtrlHandler (
    IN  DWORD   opcode
    );

VOID
LogonCtrlHandler (
    IN  DWORD   opcode
    );
DWORD
ScReleasePrivilege(
    VOID
    );

DWORD
ScGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    );

/****************************************************************************/
VOID __cdecl
main(VOID)
{
    DWORD      status;

    SERVICE_TABLE_ENTRY   DispatchTable[] = {
        { TEXT("messinger"),    MessingerStart      },
        { TEXT("smerfstation"), SmerfStationStart   },
        { TEXT("logon"),        LogonStart          },
        { NULL,                 NULL                }
    };

    status = StartServiceCtrlDispatcher( DispatchTable);

    DbgPrint("The Service Process is Terminating....\n");

    ExitProcess(0);

}


/****************************************************************************/
DWORD
MessingerStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD           status;
    DWORD           i;


    DbgPrint(" [MESSINGER] Inside the Messinger Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [MESSINGER] CommandArg%d = %s\n", i,argv[i]);
    }


    MessingerDoneEvent = CreateEvent (NULL, TRUE, FALSE, NULL);


    //
    // Fill in this services status structure
    //

    MsgrStatus.dwServiceType             = SERVICE_WIN32;
    MsgrStatus.dwCurrentState            = SERVICE_RUNNING;
    MsgrStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP;
    MsgrStatus.dwWin32ExitCode           = 0;
    MsgrStatus.dwServiceSpecificExitCode = 0;
    MsgrStatus.dwCheckPoint              = 0;
    MsgrStatus.dwWaitHint                = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [MESSINGER] Getting Ready to call NetServiceRegisterControlHandler\n");

    MsgrStatusHandle = RegisterServiceCtrlHandler(
                        TEXT("messinger"),
                        MsgrCtrlHandler);

    if (MsgrStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [MESSINGER] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (MsgrStatusHandle, &MsgrStatus)) {
        status = GetLastError();
        DbgPrint(" [MESSINGER] SetServiceStatus error %ld\n",status);
    }

    //
    // SERVER ANNOUNCEMENT LOOP
    //
    do {
        //
        // Ask the user if we should clear the server announcement bits.
        //
        status = MessageBox(
                    NULL,
                    L"Press YES    to Set   Server Announcement Bits\n"
                    L"Press NO     to Clear Server Announcement Bits\n"
                    L"Press CANCEL to sleep until shutdown",
                    L"MESSINGER SERVICE",
                    MB_YESNOCANCEL);

        DbgPrint("MessageBox return status = %d\n",status);

        switch(status){
        case IDNO:
            //
            // Register Server Announcement bits
            //
            DbgPrint(" [MESSINGER] clearing server announcement bits SV_TYPE_WORKSTATION\n");

            if (!SetServiceBits(MsgrStatusHandle, SV_TYPE_WORKSTATION, FALSE, FALSE)) {
                DbgPrint(" [MESSINGER] SetServiceBits FAILED %d\n", GetLastError());
            }
            else {
                DbgPrint(" [MESSINGER] SetServiceBits SUCCESS\n");
            }

            DbgPrint(" [MESSINGER] clearing server announcement bits SV_TYPE_SQLSERVER\n");

            if (!SetServiceBits(MsgrStatusHandle, SV_TYPE_SQLSERVER, FALSE, FALSE)) {
                DbgPrint(" [MESSINGER] SetServiceBits FAILED %d\n", GetLastError());
            }
            else {
                DbgPrint(" [MESSINGER] SetServiceBits SUCCESS\n");
            }

            break;
        case IDYES:
            //
            // Register Server Announcement bits
            //
            DbgPrint(" [MESSINGER] setting server announcement bits SV_TYPE_WORKSTATION\n");

            if (!SetServiceBits(MsgrStatusHandle, SV_TYPE_WORKSTATION, TRUE, TRUE)) {
                DbgPrint(" [MESSINGER] SetServiceBits FAILED %d\n", GetLastError());
            }
            else {
                DbgPrint(" [MESSINGER] SetServiceBits SUCCESS\n");
            }

            DbgPrint(" [MESSINGER] setting server announcement bits SV_TYPE_SQLSERVER\n");

            if (!SetServiceBits(MsgrStatusHandle, SV_TYPE_SQLSERVER, TRUE, TRUE)) {
                DbgPrint(" [MESSINGER] SetServiceBits FAILED %d\n", GetLastError());
            }
            else {
                DbgPrint(" [MESSINGER] SetServiceBits SUCCESS\n");
            }

            break;
        case IDCANCEL:
            break;
        }

    } while (status != IDCANCEL);

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                MessingerDoneEvent,
                INFINITE_WAIT_TIME);


    DbgPrint(" [MESSINGER] Leaving the messinger service\n");

    ExitThread(NO_ERROR);
    return(NO_ERROR);
}


/****************************************************************************/
VOID
MsgrCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD  status;

    DbgPrint(" [MESSINGER] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        MsgrStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        MsgrStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        MsgrStatus.dwWin32ExitCode = 0;
        MsgrStatus.dwCurrentState = SERVICE_STOPPED;

        SetEvent(MessingerDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [MESSINGER] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (MsgrStatusHandle, &MsgrStatus)) {
        status = GetLastError();
        DbgPrint(" [MESSINGER] SetServiceStatus error %ld\n",status);
    }
    return;
}


/****************************************************************************/
DWORD
SmerfStationStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD           status;
    DWORD           i;
    ULONG           privileges[1];

    UNICODE_STRING  valueString;
    NTSTATUS        ntStatus;
    WCHAR           VariableValue[64];
    USHORT          ValueLength = 60;
    USHORT          ReturnLength;



    DbgPrint(" [SMERFSTATION] Inside the Workstation Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [SMERFSTATION] CommandArg%d = %s\n", i,argv[i]);
    }


    WorkstationDoneEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

    //
    // Fill in this services status structure
    //

    SmfStaStatus.dwServiceType        = SERVICE_WIN32;
    SmfStaStatus.dwCurrentState       = SERVICE_RUNNING;
    SmfStaStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                        SERVICE_ACCEPT_PAUSE_CONTINUE;
    SmfStaStatus.dwWin32ExitCode           = 0;
    SmfStaStatus.dwServiceSpecificExitCode = 0;
    SmfStaStatus.dwCheckPoint         = 0;
    SmfStaStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [SMERFSTATION] Getting Ready to call NetServiceRegisterControlHandler\n");

    SmfStaStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("smerfstation"),
                            SmfStaCtrlHandler);

    if (SmfStaStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [SMERFSTATION] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (SmfStaStatusHandle, &SmfStaStatus)) {
        status = GetLastError();
        DbgPrint(" [SMERFSTATION] SetServiceStatus error %ld\n",status);
    }

    //
    // This gets SE_SECURITY_PRIVILEGE for copying security
    // descriptors and deleting keys.
    //
    privileges[0] = SE_SYSTEM_ENVIRONMENT_PRIVILEGE;
    
    status = ScGetPrivilege( 1, privileges);
    if (status != NO_ERROR) {
        DbgPrint("ScGetPrivilege Failed %d\n",status);
    }
    //
    // 
    //
    do {

        RtlInitUnicodeString(&valueString, L"LastKnownGood");
        ValueLength = 60;
        ntStatus = NtQuerySystemEnvironmentValue(
                    &valueString,
                    (PWSTR)&VariableValue,
                    ValueLength,
                    &ReturnLength);

        if (!NT_SUCCESS(ntStatus)) {
            DbgPrint("NtQuerySystemEnvironmentValue Failure %x\n",
            ntStatus);
        }
        else {
            DbgPrint("LKG ENV VALUE = %ws\n",VariableValue);
        }

        status = MessageBox(
                    NULL,
                    L"Press YES    to set   LastKnownGood Environment Variable\n"
                    L"Press NO     to clear LastKnownGood Environment Variable\n"
                    L"Press CANCEL to leave this loop",
                    L"SMERFSTATION SERVICE",
                    MB_YESNOCANCEL);
    
        DbgPrint("MessageBox return status = %d\n",status);
    
        switch (status) {
        case IDNO:
            //
            // Set the LKG environment variable to FALSE - so Phase 2
            // does not automatically revert again.
            //
            SET_LKG_ENV_VAR(L"False");
            break;
        case IDYES:
            //
            // Set the LKG environment variable to True - so Phase 2
            // will automatically revert, or put up the screen asking if the
            // user wants to revert.
            //
            SET_LKG_ENV_VAR(L"True");
            break;
        case IDCANCEL:
            break;
        }
    } while (status != IDCANCEL);

    //
    // Wait for the user to tell us to terminate the process.
    //
    status = MessageBox(
                NULL,
                L"Terminate testserve.exe (smerfstation, Messinger,Logon)?",
                L"SMERFSTATION SERVICE",
                MB_OK);

    DbgPrint("MessageBox return status = %d\n",status);

    if (status == IDOK) {
        ExitProcess(0);
    }

    status = WaitForSingleObject (
                WorkstationDoneEvent,
                INFINITE_WAIT_TIME);


    DbgPrint(" [SMERFSTATION] Leaving the smerfstation service\n");

    ExitThread(NO_ERROR);
    return(NO_ERROR);
}


/****************************************************************************/
VOID
SmfStaCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD  status;

    DbgPrint(" [SMERFSTATION] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        SmfStaStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        SmfStaStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        SmfStaStatus.dwWin32ExitCode = 0;
        SmfStaStatus.dwCurrentState = SERVICE_STOPPED;

        SetEvent(WorkstationDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [SMERFSTATION] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (SmfStaStatusHandle, &SmfStaStatus)) {
        status = GetLastError();
        DbgPrint(" [SMERFSTATION] SetServiceStatus error %ld\n",status);
    }
    return;
}


/****************************************************************************/
DWORD
LogonStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD  status;
    DWORD           i;


    DbgPrint(" [LOGON] Inside the Logon Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [LOGON] CommandArg%d = %s\n", i,argv[i]);
    }


    LogonDoneEvent = CreateEvent (NULL, TRUE, FALSE, NULL);


    //
    // Fill in this services status structure
    //

    LogonStatus.dwServiceType        = SERVICE_WIN32;
    LogonStatus.dwCurrentState       = SERVICE_RUNNING;
    LogonStatus.dwControlsAccepted   = SERVICE_ACCEPT_PAUSE_CONTINUE;
    LogonStatus.dwWin32ExitCode      = 0;
    LogonStatus.dwServiceSpecificExitCode = 0;
    LogonStatus.dwCheckPoint         = 0;
    LogonStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [LOGON] Getting Ready to call NetServiceRegisterControlHandler\n");

    LogonStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("logon"),
                            LogonCtrlHandler);

    if (LogonStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [LOGON] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }


    //
    // Return the status
    //

    if (!SetServiceStatus (LogonStatusHandle, &LogonStatus)) {
        status = GetLastError();
        DbgPrint(" [LOGON] SetServiceStatus error %ld\n",status);
    }

    //
    // SERVER ANNOUNCEMENT LOOP
    //
    do {
        //
        // Ask the user if we should clear the server announcement bits.
        //
        status = MessageBox(
                    NULL,
                    L"Press YES    to Set   Server Announcement Bits\n"
                    L"Press NO     to Clear Server Announcement Bits\n"
                    L"Press CANCEL to sleep until shutdown",
                    L"LOGON SERVICE",
                    MB_YESNOCANCEL);

        DbgPrint("MessageBox return status = %d\n",status);

        switch(status){
        case IDNO:
            //
            // Register Server Announcement bits
            //
            DbgPrint(" [LOGON] clearing server announcement bits 0x20000000\n");

            if (!SetServiceBits(LogonStatusHandle, 0x20000000, FALSE, TRUE)) {
                DbgPrint(" [LOGON] SetServiceBits FAILED\n", GetLastError());
            }
            else {
                DbgPrint(" [LOGON] SetServiceBits SUCCESS\n");
            }

            break;
        case IDYES:
            //
            // Register Server Announcement bits
            //
            DbgPrint(" [LOGON] setting server announcement bits 0x20000000\n");

            if (!SetServiceBits(LogonStatusHandle, 0x20000000, TRUE, TRUE)) {
                DbgPrint(" [LOGON] SetServiceBits FAILED\n", GetLastError());
            }
            else {
                DbgPrint(" [LOGON] SetServiceBits SUCCESS\n");
            }

            break;
        case IDCANCEL:
            break;
        }

    } while (status != IDCANCEL);

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                LogonDoneEvent,
                INFINITE_WAIT_TIME);


    DbgPrint(" [LOGON] Leaving the logon service\n");

    ExitThread(NO_ERROR);
    return(NO_ERROR);
}

/****************************************************************************/
VOID
LogonCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD  status;

    DbgPrint(" [LOGON] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        LogonStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        LogonStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        LogonStatus.dwWin32ExitCode = 0;
        LogonStatus.dwCurrentState = SERVICE_STOPPED;

        SetEvent(LogonDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [LOGON] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (LogonStatusHandle, &LogonStatus)) {
        status = GetLastError();
        DbgPrint(" [LOGON] SetServiceStatus error %ld\n",status);
    }
    return;
}

DWORD
ScGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    )
/*++

Routine Description:

    This function alters the privilege level for the current thread.

    It does this by duplicating the token for the current thread, and then
    applying the new privileges to that new token, then the current thread
    impersonates with that new token.

    Privileges can be relinquished by calling ScReleasePrivilege().

Arguments:

    numPrivileges - This is a count of the number of privileges in the
        array of privileges.

    pulPrivileges - This is a pointer to the array of privileges that are
        desired.  This is an array of ULONGs.

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.

--*/
{
    DWORD                       status;
    NTSTATUS                    ntStatus;
    HANDLE                      ourToken;
    HANDLE                      newToken;
    OBJECT_ATTRIBUTES           Obja;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;
    ULONG                       bufLen;
    ULONG                       returnLen;
    PTOKEN_PRIVILEGES           pPreviousState;
    PTOKEN_PRIVILEGES           pTokenPrivilege = NULL;
    DWORD                       i;

    //
    // Initialize the Privileges Structure
    //
    pTokenPrivilege = (PTOKEN_PRIVILEGES) LocalAlloc(
                                              LMEM_FIXED,
                                              sizeof(TOKEN_PRIVILEGES) +
                                                  (sizeof(LUID_AND_ATTRIBUTES) *
                                                   numPrivileges)
                                              );

    if (pTokenPrivilege == NULL) {
        status = GetLastError();
        DbgPrint("ScGetPrivilege:LocalAlloc Failed %d\n", status);
        return(status);
    }
    pTokenPrivilege->PrivilegeCount  = numPrivileges;
    for (i=0; i<numPrivileges ;i++ ) {
        pTokenPrivilege->Privileges[i].Luid = RtlConvertLongToLargeInteger(
                                                pulPrivileges[i]);
        pTokenPrivilege->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;

    }

    //
    // Initialize Object Attribute Structure.
    //
    InitializeObjectAttributes(&Obja,NULL,0L,NULL,NULL);

    //
    // Initialize Security Quality Of Service Structure
    //
    SecurityQofS.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQofS.ImpersonationLevel = SecurityImpersonation;
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly = FALSE;

    Obja.SecurityQualityOfService = &SecurityQofS;

    //
    // Allocate storage for the structure that will hold the Previous State
    // information.
    //
    pPreviousState = (PTOKEN_PRIVILEGES) LocalAlloc(
                                             LMEM_FIXED,
                                             PRIVILEGE_BUF_SIZE
                                             );
    if (pPreviousState == NULL) {

        status = GetLastError();

        DbgPrint("ScGetPrivilege: LocalAlloc Failed %d\n",
            status);

        LocalFree((HLOCAL)pTokenPrivilege);
        return(status);

    }

    //
    // Open our own Token
    //
    ntStatus = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_DUPLICATE,
                &ourToken);

    if (!NT_SUCCESS(ntStatus)) {
        DbgPrint( "ScGetPrivilege: NtOpenThreadToken Failed "
            "%x \n", ntStatus);

        LocalFree((HLOCAL)pPreviousState);
        LocalFree((HLOCAL)pTokenPrivilege);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Duplicate that Token
    //
    ntStatus = NtDuplicateToken(
                ourToken,
                TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &Obja,
                FALSE,                  // Duplicate the entire token
                TokenImpersonation,     // TokenType
                &newToken);             // Duplicate token

    if (!NT_SUCCESS(ntStatus)) {
        DbgPrint( "ScGetPrivilege: NtDuplicateToken Failed "
            "%x\n", ntStatus);

        LocalFree((HLOCAL)pPreviousState);
        LocalFree((HLOCAL)pTokenPrivilege);
        NtClose(ourToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Add new privileges
    //
    bufLen = PRIVILEGE_BUF_SIZE;
    ntStatus = NtAdjustPrivilegesToken(
                newToken,                   // TokenHandle
                FALSE,                      // DisableAllPrivileges
                pTokenPrivilege,            // NewState
                bufLen,                     // bufferSize for previous state
                pPreviousState,             // pointer to previous state info
                &returnLen);                // numBytes required for buffer.

    if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

        LocalFree((HLOCAL)pPreviousState);

        bufLen = returnLen;

        pPreviousState = (PTOKEN_PRIVILEGES) LocalAlloc(
                                                 LMEM_FIXED,
                                                 (UINT) bufLen
                                                 );

        ntStatus = NtAdjustPrivilegesToken(
                    newToken,               // TokenHandle
                    FALSE,                  // DisableAllPrivileges
                    pTokenPrivilege,        // NewState
                    bufLen,                 // bufferSize for previous state
                    pPreviousState,         // pointer to previous state info
                    &returnLen);            // numBytes required for buffer.

    }
    if (!NT_SUCCESS(ntStatus)) {
        DbgPrint( "ScGetPrivilege: NtAdjustPrivilegesToken Failed "
            "%x\n", ntStatus);

        LocalFree((HLOCAL)pPreviousState);
        LocalFree((HLOCAL)pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Begin impersonating with the new token
    //
    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&newToken,
                (ULONG)sizeof(HANDLE));

    if (!NT_SUCCESS(ntStatus)) {
        DbgPrint( "ScGetPrivilege: NtAdjustPrivilegesToken Failed "
            "%x\n", ntStatus);

        LocalFree((HLOCAL)pPreviousState);
        LocalFree((HLOCAL)pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    LocalFree(pPreviousState);
    LocalFree(pTokenPrivilege);
    NtClose(ourToken);
    NtClose(newToken);

    return(NO_ERROR);
}

DWORD
ScReleasePrivilege(
    VOID
    )
/*++

Routine Description:

    This function relinquishes privileges obtained by calling ScGetPrivilege().

Arguments:

    none

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.


--*/
{
    NTSTATUS    ntStatus;
    HANDLE      NewToken;


    //
    // Revert To Self.
    //
    NewToken = NULL;

    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&NewToken,
                (ULONG)sizeof(HANDLE));

    if ( !NT_SUCCESS(ntStatus) ) {
        return(RtlNtStatusToDosError(ntStatus));
    }


    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\client\tsec.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    tsec.c

Abstract:

    Test for the security functionality in service controller.

Author:

    Rita Wong (ritaw) 16-Mar-1992

Environment:

    User Mode - Win32

Revision History:

--*/

#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>             // IN, BOOL, LPTSTR, etc.
#include <winbase.h>

#ifndef UNICODE
#define UNICODE
#endif

#include <winsvc.h>             // Win32 service control APIs


DWORD
TestOpenService(
    IN  SC_HANDLE hScManager,
    OUT LPSC_HANDLE hService,
    IN  LPWSTR ServiceName,
    IN  DWORD DesiredAccess,
    IN  DWORD ExpectedError
    );

DWORD
TestOpenSCManager(
    OUT LPSC_HANDLE hScManager,
    IN  LPWSTR DatabaseName,
    IN  DWORD DesiredAccess,
    IN  DWORD ExpectedError
    );

DWORD
TestEnumServicesStatus(
    IN SC_HANDLE hSCManager,
    IN DWORD ExpectedError
    );

DWORD
TestQueryServiceStatus(
    IN  SC_HANDLE hService,
    IN  DWORD ExpectedError
    );

DWORD
TestControlService(
    IN  SC_HANDLE hService,
    IN  DWORD ControlCode,
    IN  DWORD ExpectedError
    );

DWORD
TestStartService(
    IN  SC_HANDLE hService,
    IN  DWORD ExpectedError
    );

VOID
DisplayStatus(
    IN  LPWSTR ServiceName OPTIONAL,
    IN  LPSERVICE_STATUS ServiceStatus
    );


BYTE WorkBuffer[1024];

VOID __cdecl
main(
    void
    )
{
    DWORD status;
    SC_HANDLE hScManager;
    SC_HANDLE hService;

    PSECURITY_DESCRIPTOR lpSecurity = (PSECURITY_DESCRIPTOR) WorkBuffer;
    DWORD BytesRequired;


    //
    // Bad database name
    //
    (void) TestOpenSCManager(
               &hScManager,
               L"Bogus",
               0,
               ERROR_INVALID_NAME
               );

    //
    // Failed database name
    //
    (void) TestOpenSCManager(
               &hScManager,
               L"SERVICESFAILED",
               0,
               ERROR_DATABASE_DOES_NOT_EXIST
               );

    //
    // Active database name
    //
    if (TestOpenSCManager(
               &hScManager,
               L"SERVICESactive",
               0,
               NO_ERROR
               ) == NO_ERROR) {

        (void) CloseServiceHandle(hScManager);
    }

    //
    // Invalid desired access
    //
    (void) TestOpenSCManager(
               &hScManager,
               NULL,
               0xff00,
               ERROR_ACCESS_DENIED
               );

    //
    // Valid desired access
    //
    if (TestOpenSCManager(
               &hScManager,
               NULL,
               SC_MANAGER_CONNECT,
               NO_ERROR
               ) == NO_ERROR) {

        //
        // Invalid operation follows
        //
        (void) TestEnumServicesStatus(
                   hScManager,
                   ERROR_ACCESS_DENIED
                   );

        (void) TestOpenService(
                   hScManager,
                   &hService,
                   L"Lumpy",
                   0xf000,
                   ERROR_ACCESS_DENIED
                   );

        (void) TestOpenService(
                   hScManager,
                   &hService,
                   L"Lu mpy",
                   SERVICE_QUERY_STATUS,
                   ERROR_INVALID_NAME
                   );

        (void) TestOpenService(
                   hScManager,
                   &hService,
                   L"\\Lumpy",
                   SERVICE_QUERY_STATUS,
                   ERROR_INVALID_NAME
                   );

        (void) TestOpenService(
                   hScManager,
                   &hService,
                   L"Lum/py",
                   SERVICE_QUERY_STATUS,
                   ERROR_INVALID_NAME
                   );

        (void) TestOpenService(
                   hScManager,
                   &hService,
                   L"Lump",
                   SERVICE_QUERY_STATUS,
                   ERROR_SERVICE_DOES_NOT_EXIST
                   );


        //
        // Service handle opened with only query access
        //
        status = TestOpenService(
                   hScManager,
                   &hService,
                   L"Lumpy",
                   SERVICE_QUERY_STATUS,
                   NO_ERROR
                   );

        if (status == NO_ERROR) {


            (void) TestControlService(
                       hService,
                       SERVICE_CONTROL_PAUSE,
                       ERROR_ACCESS_DENIED
                       );

            (void) TestStartService(
                       hService,
                       ERROR_ACCESS_DENIED
                       );

            (void) TestQueryServiceStatus(
                       hService,
                       NO_ERROR
                       );

            (void) CloseServiceHandle(hService);
        }

        //
        // Test QueryServiceObjectSecurity and SetServiceObjectSecurity
        //
        status = TestOpenService(
                   hScManager,
                   &hService,
                   L"Lumpy",
                   READ_CONTROL | WRITE_DAC,
                   NO_ERROR
                   );

        if (status == NO_ERROR) {

            if (QueryServiceObjectSecurity(
                    hService,
                    DACL_SECURITY_INFORMATION,
                    lpSecurity,
                    sizeof(WorkBuffer),
                    &BytesRequired
                    )) {

                printf("QueryServiceObjectSecurity: OK.  BytesRequired=%lu\n",
                       BytesRequired);

                if (SetServiceObjectSecurity(
                        hService,
                        DACL_SECURITY_INFORMATION,
                        lpSecurity
                        )) {

                    printf("SetServiceObjectSecurity: OK.\n");
                }
                else {
                    printf("SetServiceObjectSecurity: Failed=%lu\n", GetLastError());
                }

            }
            else {
                printf("QueryServiceObjectSecurity: Failed=%lu\n", GetLastError());
            }

            (void) CloseServiceHandle(hService);
        }


        (void) CloseServiceHandle(hScManager);
    }

    //
    // Try MAXIMUM_ALLOWED desired access
    //
    status = TestOpenSCManager(
                 &hScManager,
                 NULL,
                 MAXIMUM_ALLOWED,
                 NO_ERROR
                 );

    if (status == NO_ERROR) {
        (void) TestEnumServicesStatus(
                   hScManager,
                   NO_ERROR
                   );

        (void) CloseServiceHandle(hScManager);
    }


}


DWORD
TestOpenSCManager(
    OUT LPSC_HANDLE hScManager,
    IN  LPWSTR DatabaseName,
    IN  DWORD DesiredAccess,
    IN  DWORD ExpectedError
    )
{
    DWORD status = NO_ERROR;


    if (DatabaseName != NULL) {
        printf("OpenSCManager: DatabaseName=%ws, DesiredAccess=%08lx\n",
               DatabaseName, DesiredAccess);
    }
    else {
        printf("OpenSCManager: DatabaseName=(null), DesiredAccess=%08lx\n",
               DesiredAccess);
    }

    *hScManager = OpenSCManager(
                      NULL,
                      DatabaseName,
                      DesiredAccess
                      );

    if (*hScManager == (SC_HANDLE) NULL) {

        status = GetLastError();

        if (ExpectedError != status) {
            printf("    FAILED.  Expected %lu, got %lu\n",
                   ExpectedError, status);
            return status;
        }
    }
    else {
        if (ExpectedError != NO_ERROR) {
            printf("    FAILED.  Expected %lu, got NO_ERROR\n",
                   ExpectedError);
            return NO_ERROR;
        }
    }

    printf("    Got %lu as expected\n", status);

    return status;

}


DWORD
TestOpenService(
    IN  SC_HANDLE hScManager,
    OUT LPSC_HANDLE hService,
    IN  LPWSTR ServiceName,
    IN  DWORD DesiredAccess,
    IN  DWORD ExpectedError
    )
{
    DWORD status = NO_ERROR;


    printf("OpenService: ServiceName=%ws, DesiredAccess=%08lx\n",
           ServiceName, DesiredAccess);

    *hService = OpenService(
                    hScManager,
                    ServiceName,
                    DesiredAccess
                    );

    if (*hService == (SC_HANDLE) NULL) {

        status = GetLastError();

        if (ExpectedError != status) {
            printf("    FAILED.  Expected %lu, got %lu\n",
                   ExpectedError, status);
            return status;
        }
    }
    else {
        if (ExpectedError != NO_ERROR) {
            printf("    FAILED.  Expected %lu, got NO_ERROR\n",
                   ExpectedError);
            return NO_ERROR;
        }
    }

    printf("    Got %lu as expected\n", status);

    return status;
}

DWORD
TestEnumServicesStatus(
    IN SC_HANDLE hSCManager,
    IN DWORD ExpectedError
    )
{
    DWORD status = NO_ERROR;
    BYTE OutputBuffer[1024];
    LPENUM_SERVICE_STATUS EnumBuffer = (LPENUM_SERVICE_STATUS) OutputBuffer;

    DWORD BytesNeeded;
    DWORD EntriesRead;
    DWORD i;


    if (! EnumServicesStatus(
                hSCManager,
                SERVICE_TYPE_ALL,
                SERVICE_STATE_ALL,
                EnumBuffer,
                1024,
                &BytesNeeded,
                &EntriesRead,
                NULL
                )) {

        status = GetLastError();
    }

    if (ExpectedError != status) {
        printf("    FAILED.  Expected %lu, got %lu\n",
               ExpectedError, status);
        return status;
    }
    else {
        printf("    Got %lu as expected\n", status);
    }

    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA)) {

        for (i = 0; i < EntriesRead; i++) {
            for (i = 0; i < EntriesRead; i++) {

                DisplayStatus(
                    EnumBuffer->lpServiceName,
                    &(EnumBuffer->ServiceStatus));
                EnumBuffer++;
            }
        }
    }

    return status;
}


DWORD
TestQueryServiceStatus(
    IN  SC_HANDLE hService,
    IN  DWORD ExpectedError
    )
{
    DWORD status = NO_ERROR;
    SERVICE_STATUS ServiceStatus;


    printf("QueryService: \n");

    if (! QueryServiceStatus(
              hService,
              &ServiceStatus
              )) {

        status = GetLastError();
    }

    if (ExpectedError != status) {
        printf("    FAILED.  Expected %lu, got %lu\n",
               ExpectedError, status);
        return status;
    }

    if (status == NO_ERROR) {
        DisplayStatus(NULL, &ServiceStatus);
    }

    printf("    Got %lu as expected\n", status);

    return status;
}

DWORD
TestControlService(
    IN  SC_HANDLE hService,
    IN  DWORD ControlCode,
    IN  DWORD ExpectedError
    )
{
    DWORD status = NO_ERROR;
    SERVICE_STATUS ServiceStatus;


    printf("ControlService: Control=%08lx\n", ControlCode);

    if (! ControlService(
              hService,
              ControlCode,
              &ServiceStatus
              )) {

        status = GetLastError();
    }

    if (ExpectedError != status) {
        printf("    FAILED.  Expected %lu, got %lu\n",
               ExpectedError, status);
        return status;
    }

    if (status == NO_ERROR) {
        DisplayStatus(NULL, &ServiceStatus);
    }

    printf("    Got %lu as expected\n", status);

    return status;
}


DWORD
TestStartService(
    IN  SC_HANDLE hService,
    IN  DWORD ExpectedError
    )
{
    DWORD status = NO_ERROR;

    printf("StartService: \n");

    if (! StartService(
              hService,
              0,
              NULL
              )) {

        status = GetLastError();
    }

    if (ExpectedError != status) {
        printf("    FAILED.  Expected %lu, got %lu\n",
               ExpectedError, status);
        return status;
    }

    printf("    Got %lu as expected\n", status);

    return status;
}


VOID
DisplayStatus(
    IN  LPWSTR ServiceName OPTIONAL,
    IN  LPSERVICE_STATUS ServiceStatus
    )

/*++

Routine Description:

    Displays the service name and  the service status.

    |
    |SERVICE_NAME: messenger
    |        TYPE       : WIN32
    |        STATE      : ACTIVE SERVICE_STOPPABLE SERVICE_PAUSABLE
    |        EXIT_CODE  : 0xC002001
    |        CHECKPOINT : 0x00000001
    |        WAIT_HINT  : 0x00003f21
    |

Arguments:

    ServiceName - This is a pointer to a string containing the name of
        the service.

    ServiceStatus - This is a pointer to a SERVICE_STATUS structure from 
        which information is to be displayed.
        
Return Value:

    none.
    
--*/
{
    if (ARGUMENT_PRESENT(ServiceName)) {
        printf("\nSERVICE_NAME: %ws\n", ServiceName);
    }

    printf("        TYPE       : %lx  ", ServiceStatus->dwServiceType);
    
    switch(ServiceStatus->dwServiceType){
        case SERVICE_WIN32:
            printf("WIN32 \n");
            break;
        case SERVICE_DRIVER:
            printf("DRIVER \n");
            break;
        default:
            printf(" ERROR \n");
    }

    printf("        STATE      : %lx  ", ServiceStatus->dwCurrentState);
    
    switch(ServiceStatus->dwCurrentState){
        case SERVICE_STOPPED:
            printf("STOPPED ");
            break;
        case SERVICE_START_PENDING:
            printf("START_PENDING ");
            break;
        case SERVICE_STOP_PENDING:
            printf("STOP_PENDING ");
            break;
        case SERVICE_RUNNING:
            printf("RUNNING ");
            break;
        case SERVICE_CONTINUE_PENDING:
            printf("CONTINUE_PENDING ");
            break;
        case SERVICE_PAUSE_PENDING:
            printf("PAUSE_PENDING ");
            break;
        case SERVICE_PAUSED:
            printf("PAUSED ");
            break;
        default:
            printf(" ERROR ");
    }

    //
    // Print Controls Accepted Information
    //

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_STOP) {
        printf("  (STOPPABLE,");
    }
    else {
        printf("  (NOT_STOPPABLE,");
    }

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE) {
        printf("PAUSABLE )\n");
    }
    else {
        printf("NOT_PAUSABLE )\n");
    }

    //
    // Print Exit Code
    //
    printf("        WIN32_EXIT_CODE  : 0x%lx\n", ServiceStatus->dwWin32ExitCode  );
    printf("        SERVICE_EXIT_CODE  : 0x%lx\n",
           ServiceStatus->dwServiceSpecificExitCode  );

    //
    // Print CheckPoint & WaitHint Information
    //

    printf("        CHECKPOINT : 0x%lx\n", ServiceStatus->dwCheckPoint);
    printf("        WAIT_HINT  : 0x%lx\n", ServiceStatus->dwWaitHint  );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\client\ts2.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ts2.c

Abstract:

    This is a test program for exercising the service controller.  This
    program acts like a service and exercises the Service Controller API
    that can be called from a service:
        NetServiceStartCtrlDispatcher
        NetServiceRegisterCtrlHandler
        NetServiceStatus

    Contents:
        Grumpy
        Lumpy
        Dumpy
        Sleepy
        Dead
        SlowStop - Takes a long time to stop based on Message Box.
        Terminate - Starts normally, After 20 seconds, it sends a STOPPED
            status, and does an ExitProcess.
        Bad1 - Never calls RegisterServiceCtrlHandler.
        Bad2 - Stays in START_PENDING forever.
        Bad3 - Start= Sends 1 START_PENDING, then doesn't send any further
            status messages.  Otherwise operates normally.
        Bad4 - Normal Start; On Stop it sends 1 stop pending status then
            terminates itself.
        HangOnStop - Doesn't return from CtrlHandl routine on Stop
            requests until 40 seconds has passed. (pipe timeout is 30 sec).
            Sends a RUNNING status after the 40 second wait, then it sleeps
            for 20 seconds before sending STOPPED status.
        StartAndDie - Takes 40 seconds to start, then it terminates
            right after saying it was started.


Author:

    Dan Lafferty (danl)     12 Apr-1991

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

--*/

//
// Includes
//

#include <nt.h>      // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <windef.h>
#include <nturtl.h>     // needed for winbase.h
#include <winbase.h>
#include <wingdi.h>     // for winuserp.h
#include <winuser.h>    // MessageBox
#include <winuserp.h>   // STARTF_DESKTOPINHERIT
#include <wincon.h>     // CONSOLE_SCREEN_BUFFER_INFO

#include <winsvc.h>

#include <tstr.h>       // Unicode string macros
#include <stdio.h>      // printf

//
// Defines
//

#define INFINITE_WAIT_TIME  0xffffffff

#define NULL_STRING     TEXT("");

    LPWSTR               pszInteractiveDesktop=L"WinSta0\\Default";

//
// Globals
//
    HANDLE	DbgLogFileHandle = INVALID_HANDLE_VALUE;

    SERVICE_STATUS  GrumpyStatus;
    SERVICE_STATUS  LumpyStatus;
    SERVICE_STATUS  DumpyStatus;
    SERVICE_STATUS  SleepyStatus;
    SERVICE_STATUS  DeadStatus;
    SERVICE_STATUS  SlowStopStatus;
    SERVICE_STATUS  TerminateStatus;
    SERVICE_STATUS  Bad1Status;
    SERVICE_STATUS  Bad2Status;
    SERVICE_STATUS  Bad3Status;
    SERVICE_STATUS  Bad4Status;
    SERVICE_STATUS  HangOnStopStatus;
    SERVICE_STATUS  StartProcStatus;
    SERVICE_STATUS  StartAndDieStatus;

    HANDLE          GrumpyDoneEvent;
    HANDLE          LumpyDoneEvent;
    HANDLE          DumpyDoneEvent;
    HANDLE          SleepyDoneEvent;
    HANDLE          DeadDoneEvent;
    HANDLE          SlowStopDoneEvent;
    HANDLE          TerminateDoneEvent;
    HANDLE          Bad1DoneEvent;
    HANDLE          Bad2DoneEvent;
    HANDLE          Bad3DoneEvent;
    HANDLE          Bad4DoneEvent;
    HANDLE          HangOnStopDoneEvent;
    HANDLE          StartProcDoneEvent;
    HANDLE          StartAndDieDoneEvent;

    SERVICE_STATUS_HANDLE   GrumpyStatusHandle;
    SERVICE_STATUS_HANDLE   LumpyStatusHandle;
    SERVICE_STATUS_HANDLE   DumpyStatusHandle;
    SERVICE_STATUS_HANDLE   SleepyStatusHandle;
    SERVICE_STATUS_HANDLE   DeadStatusHandle;
    SERVICE_STATUS_HANDLE   SlowStopStatusHandle;
    SERVICE_STATUS_HANDLE   TerminateStatusHandle;
    SERVICE_STATUS_HANDLE   Bad1StatusHandle;
    SERVICE_STATUS_HANDLE   Bad2StatusHandle;
    SERVICE_STATUS_HANDLE   Bad3StatusHandle;
    SERVICE_STATUS_HANDLE   Bad4StatusHandle;
    SERVICE_STATUS_HANDLE   HangOnStopStatusHandle;
    SERVICE_STATUS_HANDLE   StartProcStatusHandle;
    SERVICE_STATUS_HANDLE   StartAndDieStatusHandle;

//
// Function Prototypes
//

DWORD
GrumpyStart (
    DWORD   argc,
    LPTSTR  *argv
    );

DWORD
LumpyStart (
    DWORD   argc,
    LPTSTR  *argv
    );

DWORD
DumpyStart (
    DWORD   argc,
    LPTSTR  *argv
    );

DWORD
SleepyStart (
    DWORD   argc,
    LPTSTR  *argv
    );

DWORD
DeadStart (
    DWORD   argc,
    LPTSTR  *argv
    );

DWORD
SlowStopStart (
    DWORD   argc,
    LPTSTR  *argv
    );

DWORD
TerminateStart (
    DWORD   argc,
    LPTSTR  *argv
    );

DWORD
Bad1Start (DWORD   argc,LPTSTR  *argv);

DWORD
Bad2Start (DWORD   argc,LPTSTR  *argv);

DWORD
Bad3Start (DWORD   argc,LPTSTR  *argv);

DWORD
Bad4Start (DWORD argc,LPTSTR  *argv);

DWORD
HangOnStopStart (DWORD argc,LPTSTR  *argv);

DWORD
StartProcStart (DWORD argc,LPTSTR  *argv);

DWORD
StartAndDieStart (DWORD argc,LPTSTR  *argv);

VOID
GrumpyCtrlHandler (
    IN  DWORD   opcode
    );

VOID
LumpyCtrlHandler (
    IN  DWORD   opcode
    );

VOID
DumpyCtrlHandler (
    IN  DWORD   opcode
    );

VOID
SleepyCtrlHandler (
    IN  DWORD   opcode
    );

VOID
DeadCtrlHandler (
    IN  DWORD   opcode
    );

VOID
SlowStopCtrlHandler (
    IN  DWORD   opcode
    );

VOID
TerminateCtrlHandler (
    IN  DWORD   opcode
    );

VOID
Bad1CtrlHandler (IN  DWORD   opcode);

VOID
Bad2CtrlHandler (IN  DWORD   opcode);

VOID
Bad3CtrlHandler (IN  DWORD   opcode);

VOID
Bad4CtrlHandler (IN  DWORD   opcode);

VOID
HangOnStopCtrlHandler (IN  DWORD   opcode);

VOID
StartProcCtrlHandler (IN  DWORD   opcode);

VOID
StartAndDieCtrlHandler (IN  DWORD   opcode);

VOID
SvcPrintf (char *Format, ...);

VOID
SetUpConsole();



/****************************************************************************/
VOID __cdecl
main (
    DWORD           argc,
    PCHAR           argv[]
    )
{
    DWORD       i;

    SERVICE_TABLE_ENTRY   DispatchTable[] = {
        { TEXT("StartProc"),    StartProcStart  },
        { TEXT("grumpy"),       GrumpyStart     },
        { TEXT("lumpy"),        LumpyStart      },
        { TEXT("dumpy"),        DumpyStart      },
        { TEXT("sleepy"),       SleepyStart     },
        { TEXT("dead"),         DeadStart       },
        { TEXT("slowstop"),     SlowStopStart   },
        { TEXT("terminate"),    TerminateStart  },
        { TEXT("Bad1"),         Bad1Start       },
        { TEXT("Bad2"),         Bad2Start       },
        { TEXT("Bad3"),         Bad3Start       },
        { TEXT("Bad4"),         Bad4Start       },
        { TEXT("HangOnStop"),   HangOnStopStart },
        { TEXT("StartAndDie"),  StartAndDieStart },
        { NULL,                 NULL            }
    };

    DbgPrint("[ts2]Args passed to .exe main() function:\n");
    for (i=0; i<argc; i++) {
        DbgPrint(" [TS2] CommandArg%d = %s\n", i,argv[i]);
    }

    //SetUpConsole();

    if (!StartServiceCtrlDispatcher( DispatchTable)) {
        DbgPrint("[ts2]StartServiceCtrlDispatcher returned error %d\n",GetLastError);
    }

    DbgPrint("[ts2]The Service Process is Terminating....\n");

    ExitProcess(0);

}


/****************************************************************************/

//
// Grumpy will take a long time to respond to pause
//
//

DWORD
GrumpyStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;
    //---------------------------------------------------------------------
    SC_HANDLE   SCHandle;
    SC_HANDLE   ServiceHandle;
    //---------------------------------------------------------------------



    DbgPrint(" [GRUMPY] Inside the Grumpy Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [GRUMPY] CommandArg%d = %s\n", i,argv[i]);
    }


    GrumpyDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    GrumpyStatus.dwServiceType        = SERVICE_WIN32;
    GrumpyStatus.dwCurrentState       = SERVICE_RUNNING;
    GrumpyStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                        SERVICE_ACCEPT_PAUSE_CONTINUE;

    //
    // Set up bogus values for status.
    //
    GrumpyStatus.dwWin32ExitCode      = 14;
    GrumpyStatus.dwServiceSpecificExitCode = 55;
    GrumpyStatus.dwCheckPoint         = 53;
    GrumpyStatus.dwWaitHint           = 22;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [GRUMPY] Getting Ready to call RegisterServiceCtrlHandler\n");

    GrumpyStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("grumpy"),
                            GrumpyCtrlHandler);

    if (GrumpyStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [GRUMPY] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (GrumpyStatusHandle, &GrumpyStatus)) {
        status = GetLastError();
        DbgPrint(" [GRUMPY] SetServiceStatus error %ld\n",status);
    }

#define START_SERVICE
#ifdef START_SERVICE
    //---------------------------------------------------------------------
    //
    //  TEMP CODE - Start another service
    //
    DbgPrint("[GRUMPY] Attempt to start Messinger");
    if ((SCHandle = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT))!= NULL) {
        if ((ServiceHandle = OpenService(
                SCHandle,
                TEXT("Messinger"),
                SERVICE_START)) != NULL) {

            if (!StartService(ServiceHandle,0,NULL)) {
                DbgPrint("[GRUMPY] StartService Failed, rc = %d",
                GetLastError());
            }
        }
        else {
            DbgPrint("GRUMPY] OpenService failed %d\n",GetLastError());
        }
    }
    else {
        DbgPrint("GRUMPY] OpenSCManager failed %d\n",GetLastError());
    }
    //
    //
    //
    //---------------------------------------------------------------------
#endif

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                GrumpyDoneEvent,
                INFINITE_WAIT_TIME);


    DbgPrint(" [GRUMPY] Leaving the grumpy service\n");

    CloseHandle(GrumpyDoneEvent);
    
    return(NO_ERROR);
}


/****************************************************************************/
VOID
GrumpyCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [GRUMPY] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

       Sleep(60000);    // 1 minute

        GrumpyStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        GrumpyStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        GrumpyStatus.dwWin32ExitCode = 0;
        GrumpyStatus.dwServiceSpecificExitCode = 0;
        GrumpyStatus.dwCurrentState = SERVICE_STOPPED;
        GrumpyStatus.dwWaitHint = 0;
        GrumpyStatus.dwCheckPoint = 0;

        SetEvent(GrumpyDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        //
        // Send a BAD Status Response
        //

        DbgPrint(" [GRUMPY] Sending bogus status (0x00000000)\n");
        if (!SetServiceStatus (0L,  &GrumpyStatus)) {
            status = GetLastError();
            DbgPrint(" [GRUMPY] SetServiceStatus error %ld "
                     " - - Expect %d\n",status,ERROR_INVALID_HANDLE);
        }

        DbgPrint(" [GRUMPY] Sending bogus status (0xefefefef)\n");
        if (!SetServiceStatus (0xefefefef,  &GrumpyStatus)) {
            status = GetLastError();
            DbgPrint(" [GRUMPY] SetServiceStatus error %ld "
                     " - - Expect %d\n",status,ERROR_INVALID_HANDLE);
        }
        break;

    default:
        DbgPrint(" [GRUMPY] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (GrumpyStatusHandle,  &GrumpyStatus)) {
        status = GetLastError();
        DbgPrint(" [GRUMPY] SetServiceStatus error %ld\n",status);
    }
    return;
}


/****************************************************************************/
DWORD
LumpyStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;


    DbgPrint(" [LUMPY] Inside the Lumpy Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [LUMPY] CommandArg%d = %s\n", i,argv[i]);
    }


    LumpyDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    LumpyStatus.dwServiceType        = SERVICE_WIN32|SERVICE_INTERACTIVE_PROCESS;
    LumpyStatus.dwCurrentState       = SERVICE_RUNNING;
    LumpyStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                       SERVICE_ACCEPT_PAUSE_CONTINUE |
                                       SERVICE_ACCEPT_SHUTDOWN;
    LumpyStatus.dwWin32ExitCode      = 0;
    LumpyStatus.dwServiceSpecificExitCode = 0;
    LumpyStatus.dwCheckPoint         = 0;
    LumpyStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [LUMPY] Getting Ready to call RegisterServiceCtrlHandler\n");

    LumpyStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("lumpy"),
                            LumpyCtrlHandler);

    if (LumpyStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [LUMPY] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (LumpyStatusHandle,  &LumpyStatus)) {
        status = GetLastError();
        DbgPrint(" [LUMPY] SetServiceStatus error %ld\n",status);
    }

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                LumpyDoneEvent,
                INFINITE_WAIT_TIME);


    if (status == WAIT_FAILED) {
        DbgPrint(" [LUMPY] WaitLastError = %d\n",GetLastError());
    }

    DbgPrint(" [LUMPY] Leaving the lumpy service\n");

    CloseHandle(LumpyDoneEvent);
    
    return(NO_ERROR);
}


/****************************************************************************/
VOID
LumpyCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [LUMPY] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:
        SvcPrintf("Lumpy received a PAUSE\n");
        LumpyStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:
        SvcPrintf("Lumpy received a CONTINUE\n");
        LumpyStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:
        SvcPrintf("Lumpy received a STOP\n");

        LumpyStatus.dwWin32ExitCode = 0;
        LumpyStatus.dwCurrentState = SERVICE_STOPPED;

        if (!SetEvent(LumpyDoneEvent)) {
            DbgPrint(" [LUMPY] SetEvent Failed %d\n",GetLastError());
        }
        break;

    case SERVICE_CONTROL_INTERROGATE:
        SvcPrintf("Lumpy received an INTERROGATE\n");
        break;

    default:
        DbgPrint(" [LUMPY] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (LumpyStatusHandle,  &LumpyStatus)) {
        status = GetLastError();
        DbgPrint(" [LUMPY] SetServiceStatus error %ld\n",status);
    }
    return;
}


/****************************************************************************/
DWORD
DumpyStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;


    DbgPrint(" [DUMPY] Inside the Dumpy Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [DUMPY] CommandArg%d = %s\n", i,argv[i]);
    }


    DumpyDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    DumpyStatus.dwServiceType        = SERVICE_WIN32;
    DumpyStatus.dwCurrentState       = SERVICE_RUNNING;
    DumpyStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                       SERVICE_ACCEPT_PAUSE_CONTINUE;
    DumpyStatus.dwWin32ExitCode      = 0;
    DumpyStatus.dwServiceSpecificExitCode = 0;
    DumpyStatus.dwCheckPoint         = 0;
    DumpyStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [DUMPY] Getting Ready to call RegisterServiceCtrlHandler\n");

    DumpyStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("dumpy"),
                            DumpyCtrlHandler);

    if (DumpyStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [DUMPY] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (DumpyStatusHandle,  &DumpyStatus)) {
        status = GetLastError();
        DbgPrint(" [DUMPY] SetServiceStatus error %ld\n",status);
    }

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                DumpyDoneEvent,
                INFINITE_WAIT_TIME);


    DbgPrint(" [DUMPY] Leaving the dumpy service\n");

    CloseHandle(DumpyDoneEvent);
    
    return(NO_ERROR);
}

/****************************************************************************/
VOID
DumpyCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [DUMPY] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        DumpyStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        DumpyStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        DumpyStatus.dwWin32ExitCode = 0;
        DumpyStatus.dwCurrentState = SERVICE_STOPPED;

        SetEvent(DumpyDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [DUMPY] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (DumpyStatusHandle,  &DumpyStatus)) {
        status = GetLastError();
        DbgPrint(" [DUMPY] SetServiceStatus error %ld\n",status);
    }
    return;
}

/****************************************************************************/
DWORD
SleepyStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;
    DWORD   checkpoint=1;


    DbgPrint(" [SLEEPY] Inside the Sleepy Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [SLEEPY] CommandArg%d = %s\n", i,argv[i]);
    }


    SleepyDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    SleepyStatus.dwServiceType        = SERVICE_WIN32;
    SleepyStatus.dwCurrentState       = SERVICE_START_PENDING;
    SleepyStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                        SERVICE_ACCEPT_PAUSE_CONTINUE;
    SleepyStatus.dwWin32ExitCode      = 0;
    SleepyStatus.dwServiceSpecificExitCode = 0;
    SleepyStatus.dwCheckPoint         = checkpoint++;
    SleepyStatus.dwWaitHint          = 40000;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [SLEEPY] Getting Ready to call RegisterServiceCtrlHandler\n");

    SleepyStatusHandle = RegisterServiceCtrlHandler(
                TEXT("sleepy"),
                SleepyCtrlHandler);

    if (SleepyStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [SLEEPY] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // This service tests the install pending system in the service
    // controller.  Therefore, it loops and sleeps 4 times prior to
    // indicating that installation is complete.
    //

    for (i=0; i<5; i++) {
        //
        // Return the status
        //

        DbgPrint(" [SLEEPY] sending install status #%d\n",i);
        if (!SetServiceStatus (SleepyStatusHandle,  &SleepyStatus)) {
            status = GetLastError();
            DbgPrint(" [SLEEPY] SetServiceStatus error %ld\n",status);
        }

        Sleep(20000);           // Sleep for 20 seconds
        status = WaitForSingleObject (
                    SleepyDoneEvent,
                    0);
        if (status == 0) {
            DbgPrint(" [SLEEPY] terminated while installing\n");
            return(NO_ERROR);
        }

        //
        // Increment the checkpoint value in status. (20 seconds)
        //
        SleepyStatus.dwCheckPoint = checkpoint++;
        SleepyStatus.dwWaitHint = 40000;
       
        DbgPrint(" [SLEEPY] checkpoint = 0x%lx\n",SleepyStatus.dwCheckPoint);

#ifdef SpecialTest
        //
        //******************************************************************
        // TEST out the condition where we have an unsolicited uninstall
        // after sending the first status message.
        //

        SleepyStatus.dwWin32ExitCode = 0;
        SleepyStatus.dwCurrentState = SERVICE_STOPPED;

        if (!SetServiceStatus (SleepyStatusHandle,  &SleepyStatus)) {
            status = GetLastError();
            DbgPrint("[SLEEPY] Error From SetServiceStatus %d\n",status);
        }
        DbgPrint(" [SLEEPY] Leaving the Sleepy service\n");

        return(NO_ERROR);

        //
        //******************************************************************
#endif  //SpecialTest
    }

    DbgPrint(" [SLEEPY] setting up installed status\n");

    SleepyStatus.dwCurrentState     = SERVICE_RUNNING;
    SleepyStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                      SERVICE_ACCEPT_PAUSE_CONTINUE;
    SleepyStatus.dwWin32ExitCode   = 0;
    SleepyStatus.dwServiceSpecificExitCode = 0;
    SleepyStatus.dwCheckPoint = 0;
    SleepyStatus.dwWaitHint   = 0;

    DbgPrint(" [SLEEPY] sending install status #%d\n",i);

    if (!SetServiceStatus (SleepyStatusHandle,  &SleepyStatus)) {
        status = GetLastError();
        DbgPrint(" [SLEEPY] SetServiceStatus error %ld\n",status);
    }

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                SleepyDoneEvent,
                INFINITE_WAIT_TIME);


    DbgPrint(" [SLEEPY] Leaving the Sleepy service\n");

    CloseHandle(SleepyDoneEvent);
    
    return(NO_ERROR);
}

/****************************************************************************/
VOID
SleepyCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [SLEEPY] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        SleepyStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        SleepyStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        SleepyStatus.dwWin32ExitCode = 0;
        SleepyStatus.dwCheckPoint = 0;
        SleepyStatus.dwWaitHint   = 0;
        SleepyStatus.dwCurrentState = SERVICE_STOPPED;

        SetEvent(SleepyDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [SLEEPY] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (SleepyStatusHandle,  &SleepyStatus)) {
        status = GetLastError();
        DbgPrint(" [SLEEPY] SetServiceStatus error %ld\n",status);
    }
    return;
}



/****************************************************************************/
DWORD
DeadStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;


    DbgPrint(" [DEAD] Inside the Dead Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [DEAD] CommandArg%d = %s\n", i,argv[i]);
    }


    DeadDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    DeadStatus.dwServiceType        = SERVICE_WIN32;
    DeadStatus.dwCurrentState       = SERVICE_STOPPED;
    DeadStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                      SERVICE_ACCEPT_PAUSE_CONTINUE;
    DeadStatus.dwWin32ExitCode      = 0x00020002;
    DeadStatus.dwServiceSpecificExitCode = 0;
    DeadStatus.dwCheckPoint         = 0;
    DeadStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [DEAD] Getting Ready to call RegisterServiceCtrlHandler\n");

    DeadStatusHandle = RegisterServiceCtrlHandler(
                TEXT("dead"),
                DeadCtrlHandler);

    if (DeadStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [DEAD] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // The Dead Service will now exit process prior to sending its first
    // status.
    //
    DbgPrint(" [DEAD] Terminating the Dead Service Process\n");
    ExitProcess(0);

    //
    // Return the status
    //

    if (!SetServiceStatus (DeadStatusHandle,  &DeadStatus)) {
        status = GetLastError();
        DbgPrint(" [DEAD] SetServiceStatus error %ld\n",status);
    }

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                DeadDoneEvent,
                INFINITE_WAIT_TIME);


    DbgPrint(" [DEAD] Leaving the dead service\n");

    CloseHandle(DeadDoneEvent);
    
    return(NO_ERROR);
}

/****************************************************************************/
VOID
DeadCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [DEAD] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        DeadStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        DeadStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        DeadStatus.dwWin32ExitCode = 0;
        DeadStatus.dwCurrentState = SERVICE_STOPPED;

        SetEvent(DeadDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [DEAD] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (DeadStatusHandle,  &DeadStatus)) {
        status = GetLastError();
        DbgPrint(" [DEAD] SetServiceStatus error %ld\n",status);
    }
    return;
}

/****************************************************************************/

//
// SlowStop will take a long time to stop.
//
//

DWORD
SlowStopStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;
    DWORD   LoopCount;


    DbgPrint(" [SLOW_STOP] Inside the SlowStop Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [SLOW_STOP] CommandArg%d = %s\n", i,argv[i]);
    }


    SlowStopDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    SlowStopStatus.dwServiceType        = SERVICE_WIN32;
    SlowStopStatus.dwCurrentState       = SERVICE_RUNNING;
    SlowStopStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_PAUSE_CONTINUE |
                                          SERVICE_ACCEPT_SHUTDOWN;

    SlowStopStatus.dwWin32ExitCode      = 0;
    SlowStopStatus.dwServiceSpecificExitCode = 0;
    SlowStopStatus.dwCheckPoint         = 0;
    SlowStopStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [SLOW_STOP] Getting Ready to call RegisterServiceCtrlHandler\n");

    SlowStopStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("slowstop"),
                            SlowStopCtrlHandler);

    if (SlowStopStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [SLOW_STOP] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (SlowStopStatusHandle, &SlowStopStatus)) {
        status = GetLastError();
        DbgPrint(" [SLOW_STOP] SetServiceStatus error %ld\n",status);
    }

    //
    // Put up a message box to get information on how long it should take
    // this service to stop.  The choices are to stop within the WaitHint
    // time period - and to stop outside of the WaitHint time period
    //

        //
        // Ask the user how long to take in stopping
        //
        status = MessageBox(
                    NULL,
                    "Press YES    Stop occurs within WaitHint Period\n"
                    "Press NO     Stop takes longer than the WaitHint Period\n"
                    "Press CANCEL Stop occurs within WaitHint Period",
                    "SlowStopStart",
                    MB_YESNOCANCEL | MB_SERVICE_NOTIFICATION);

        DbgPrint("MessageBox return status = %d\n",status);
        SvcPrintf("I got the status\n");
        switch(status){
        case IDNO:
                LoopCount = 30;
                break;
        case IDYES:
                LoopCount = 6;
                break;
        case IDCANCEL:
                LoopCount = 6;
                break;
        }



    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                SlowStopDoneEvent,
                INFINITE_WAIT_TIME);

    //===============================================
    //
    // When shutting down, send the STOP_PENDING
    // status for 8 seconds then STOP.
    // The WaitHint indicates it takes 10 seconds
    // to stop.
    //
    //===============================================
    for (i=0; i<LoopCount ; i++ ) {

        Sleep(1000);

        SlowStopStatus.dwCheckPoint++;

        if (!SetServiceStatus (SlowStopStatusHandle, &SlowStopStatus)) {
            status = GetLastError();
            DbgPrint(" [SLOW_STOP] SetServiceStatus error %ld\n",status);
        }

    }

    SlowStopStatus.dwCurrentState = SERVICE_STOPPED;
    SlowStopStatus.dwCheckPoint=0;
    SlowStopStatus.dwWaitHint=0;

    if (!SetServiceStatus (SlowStopStatusHandle, &SlowStopStatus)) {
        status = GetLastError();
        DbgPrint(" [SLOW_STOP] SetServiceStatus error %ld\n",status);
    }

    DbgPrint(" [SLOW_STOP] Leaving the slowstop service\n");

    CloseHandle(SlowStopDoneEvent);
    
    return(NO_ERROR);
}


/****************************************************************************/
VOID
SlowStopCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [SLOW_STOP] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        SlowStopStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        SlowStopStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        SlowStopStatus.dwWin32ExitCode = 0;
        SlowStopStatus.dwServiceSpecificExitCode = 0;
        SlowStopStatus.dwCurrentState = SERVICE_STOP_PENDING;
        SlowStopStatus.dwWaitHint = 10000;       // 10 seconds to stop
//        SlowStopStatus.dwWaitHint = 0;       // 10 seconds to stop
        SlowStopStatus.dwCheckPoint = 1;

        SetEvent(SlowStopDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [SLOW_STOP] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (SlowStopStatusHandle,  &SlowStopStatus)) {
        status = GetLastError();
        DbgPrint(" [SLOW_STOP] SetServiceStatus error %ld\n",status);
    }
    return;
}


/****************************************************************************/

//
// Terminate will die unexpectedly.
//
//

DWORD
TerminateStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;


    DbgPrint(" [TERMINATE] Inside the Terminate Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [TERMINATE] CommandArg%d = %s\n", i,argv[i]);
    }


    TerminateDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    TerminateStatus.dwServiceType        = SERVICE_WIN32;
    TerminateStatus.dwCurrentState       = SERVICE_RUNNING;
    TerminateStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_PAUSE_CONTINUE;

    TerminateStatus.dwWin32ExitCode      = 0;
    TerminateStatus.dwServiceSpecificExitCode = 0;
    TerminateStatus.dwCheckPoint         = 0;
    TerminateStatus.dwWaitHint           = 0;
    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [TERMINATE] Getting Ready to call RegisterServiceCtrlHandler\n");

    TerminateStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("terminate"),
                            TerminateCtrlHandler);

    if (TerminateStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [TERMINATE] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (TerminateStatusHandle, &TerminateStatus)) {
        status = GetLastError();
        DbgPrint(" [TERMINATE] SetServiceStatus error %ld\n",status);
    }


    //=======================================================================
    //
    // Sleep for 20 seconds, then send out an error status, and ExitProcess.
    // NOTE:  It would be more proper for a service to ExitThread here
    // instead.  But who says test services need to be proper?
    //
    //=======================================================================

    Sleep(20000);

    TerminateStatus.dwCurrentState = SERVICE_STOPPED;
    TerminateStatus.dwWin32ExitCode = ERROR_INVALID_ENVIRONMENT;
    TerminateStatus.dwCheckPoint=0;
    TerminateStatus.dwWaitHint=0;

    if (!SetServiceStatus (TerminateStatusHandle, &TerminateStatus)) {
        status = GetLastError();
        DbgPrint(" [TERMINATE] SetServiceStatus error %ld\n",status);
    }

    ExitProcess(NO_ERROR);
    return(NO_ERROR);

}


/****************************************************************************/
VOID
TerminateCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [TERMINATE] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        TerminateStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        TerminateStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        TerminateStatus.dwWin32ExitCode = 0;
        TerminateStatus.dwServiceSpecificExitCode = 0;
        TerminateStatus.dwCurrentState = SERVICE_STOP_PENDING;
        TerminateStatus.dwCheckPoint = 1;
        TerminateStatus.dwWaitHint = 20000;

        SetEvent(TerminateDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [TERMINATE] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (TerminateStatusHandle,  &TerminateStatus)) {
        status = GetLastError();
        DbgPrint(" [TERMINATE] SetServiceStatus error %ld\n",status);
    }

    CloseHandle(TerminateDoneEvent);
    return;
}


/****************************************************************************/

//
// Bad1 will never call RegisterServiceCtrlHandler.
//
//

DWORD
Bad1Start (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;


    DbgPrint(" [BAD1] Inside the Bad1 Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [BAD1] CommandArg%d = %s\n", i,argv[i]);
    }


    Bad1DoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    Bad1Status.dwServiceType        = SERVICE_WIN32;
    Bad1Status.dwCurrentState       = SERVICE_START_PENDING;
    Bad1Status.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_PAUSE_CONTINUE;

    Bad1Status.dwWin32ExitCode      = 0;
    Bad1Status.dwServiceSpecificExitCode = 0;
    Bad1Status.dwCheckPoint         = 1;
    Bad1Status.dwWaitHint           = 5000;
    //
    // Register the Control Handler routine.
    //

    /////////////////////////////////
    // Sleep for a real long time
    // without calling RegisterServiceCtrlHandler.

    DbgPrint(" [BAD1] Getting Ready to sleep\n");
    Sleep(9999999);

    ////////////////////////////////////////////////
    //
    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                Bad1DoneEvent,
                INFINITE_WAIT_TIME);

    DbgPrint(" [BAD1] Leaving the Bad1 service\n");
    CloseHandle(Bad1DoneEvent);
    
    return(NO_ERROR);
}


/****************************************************************************/
VOID
Bad1CtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [BAD1] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        Bad1Status.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        Bad1Status.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        Bad1Status.dwWin32ExitCode = 0;
        Bad1Status.dwServiceSpecificExitCode = 0;
        Bad1Status.dwCurrentState = SERVICE_STOP_PENDING;
        Bad1Status.dwCheckPoint = 1;
        Bad1Status.dwWaitHint = 20000;

        SetEvent(Bad1DoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [BAD1] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (Bad1StatusHandle,  &Bad1Status)) {
        status = GetLastError();
        DbgPrint(" [BAD1] SetServiceStatus error %ld\n",status);
    }

    CloseHandle(Bad1DoneEvent);
    return;
}


/****************************************************************************/

//
// Bad2 will never complete initialization (stuck in START_PENDING forever).
// The control handler is functioning and STOP is functioning.
//
//

DWORD
Bad2Start (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;


    DbgPrint(" [BAD2] Inside the Bad2 Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [BAD2] CommandArg%d = %s\n", i,argv[i]);
    }


    Bad2DoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    Bad2Status.dwServiceType        = SERVICE_WIN32;
    Bad2Status.dwCurrentState       = SERVICE_START_PENDING;
    Bad2Status.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_PAUSE_CONTINUE;

    Bad2Status.dwWin32ExitCode      = 0;
    Bad2Status.dwServiceSpecificExitCode = 0;
    Bad2Status.dwCheckPoint         = 1;
    Bad2Status.dwWaitHint           = 5000;
    //
    // Register the Control Handler routine.
    //


    DbgPrint(" [BAD2] Getting Ready to call RegisterServiceCtrlHandler\n");

    Bad2StatusHandle = RegisterServiceCtrlHandler(
                            TEXT("Bad2"),
                            Bad2CtrlHandler);

    if (Bad2StatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [BAD2] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (Bad2StatusHandle, &Bad2Status)) {
        status = GetLastError();
        DbgPrint(" [BAD2] SetServiceStatus error %ld\n",status);
    }
#ifdef remove
    /////////////////////////////////
    // Sleep for a real long time
    // without sending status.

    DbgPrint(" [BAD2] Getting Ready to sleep\n");
    Sleep(9999999);
#endif

    /////////////////////////////////
    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                Bad2DoneEvent,
                INFINITE_WAIT_TIME);

    DbgPrint(" [BAD2] Leaving the Bad2 service\n");
    CloseHandle(Bad2DoneEvent);
    
    return(NO_ERROR);

}


/****************************************************************************/
VOID
Bad2CtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [BAD2] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        Bad2Status.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        Bad2Status.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        Bad2Status.dwWin32ExitCode = 0;
        Bad2Status.dwServiceSpecificExitCode = 0;
        Bad2Status.dwCurrentState = SERVICE_STOPPED;
        Bad2Status.dwCheckPoint = 1;
        Bad2Status.dwWaitHint = 5000;

        SetEvent(Bad2DoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [BAD2] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //
    if (!SetServiceStatus (Bad2StatusHandle,  &Bad2Status)) {
        status = GetLastError();
        DbgPrint(" [BAD2] SetServiceStatus error %ld\n",status);
    }

    CloseHandle(Bad2DoneEvent);
    return;
}


/****************************************************************************/
//
// Bad3 will send only its first START_PENDING status, and then it won't send
// any further status messages for any reason.  Aside from not sending any
// status messages, the service operates normally.
//

DWORD
Bad3Start (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;


    DbgPrint(" [BAD3] Inside the Bad3 Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [BAD3] CommandArg%d = %s\n", i,argv[i]);
    }


    Bad3DoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    Bad3Status.dwServiceType        = SERVICE_WIN32;
    Bad3Status.dwCurrentState       = SERVICE_START_PENDING;
    Bad3Status.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_PAUSE_CONTINUE;

    Bad3Status.dwWin32ExitCode      = 0;
    Bad3Status.dwServiceSpecificExitCode = 0;
    Bad3Status.dwCheckPoint         = 1;
    Bad3Status.dwWaitHint           = 5000;
    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [BAD3] Getting Ready to call RegisterServiceCtrlHandler\n");

    Bad3StatusHandle = RegisterServiceCtrlHandler(
                            TEXT("Bad3"),
                            Bad3CtrlHandler);

    if (Bad3StatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [BAD3] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (Bad3StatusHandle, &Bad3Status)) {
        status = GetLastError();
        DbgPrint(" [BAD3] SetServiceStatus error %ld\n",status);
    }

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                Bad3DoneEvent,
                INFINITE_WAIT_TIME);

    DbgPrint(" [BAD3] Leaving the Bad3 service\n");
    CloseHandle(Bad3DoneEvent);
    
    return(NO_ERROR);

}


/****************************************************************************/
VOID
Bad3CtrlHandler (
    IN  DWORD   Opcode
    )
{
    DbgPrint(" [BAD3] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        Bad3Status.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        Bad3Status.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        Bad3Status.dwWin32ExitCode = 0;
        Bad3Status.dwServiceSpecificExitCode = 0;
        Bad3Status.dwCurrentState = SERVICE_STOPPED;
        Bad3Status.dwCheckPoint = 1;
        Bad3Status.dwWaitHint = 20000;

        SetEvent(Bad3DoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [BAD3] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Don't send a status response.
    //
#ifdef REMOVE
    if (!SetServiceStatus (Bad3StatusHandle,  &Bad3Status)) {
        status = GetLastError();
        DbgPrint(" [BAD3] SetServiceStatus error %ld\n",status);
    }
#endif


    CloseHandle(Bad3DoneEvent);
    return;
}


/****************************************************************************/

//
// Bad4 will start normally, but on stop it only sends one stop pending
// status before it terminates itself without further notification.
//

DWORD
Bad4Start (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;


    DbgPrint(" [BAD4] Inside the Bad4 Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [BAD4] CommandArg%d = %s\n", i,argv[i]);
    }


    Bad4DoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    Bad4Status.dwServiceType        = SERVICE_WIN32;
    Bad4Status.dwCurrentState       = SERVICE_RUNNING;
    Bad4Status.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_PAUSE_CONTINUE;

    Bad4Status.dwWin32ExitCode      = 0;
    Bad4Status.dwServiceSpecificExitCode = 0;
    Bad4Status.dwCheckPoint         = 0;
    Bad4Status.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [BAD4] Getting Ready to call RegisterServiceCtrlHandler\n");

    Bad4StatusHandle = RegisterServiceCtrlHandler(
                            TEXT("Bad4"),
                            Bad4CtrlHandler);

    if (Bad4StatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [BAD4] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (Bad4StatusHandle, &Bad4Status)) {
        status = GetLastError();
        DbgPrint(" [BAD4] SetServiceStatus error %ld\n",status);
    }

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                Bad4DoneEvent,
                INFINITE_WAIT_TIME);

    DbgPrint(" [BAD4] Leaving the Bad4 service\n");
    CloseHandle(Bad4DoneEvent);
    
    return(NO_ERROR);
}


/****************************************************************************/
VOID
Bad4CtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [BAD4] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        Bad4Status.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        Bad4Status.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        Bad4Status.dwWin32ExitCode = 0;
        Bad4Status.dwServiceSpecificExitCode = 0;
        Bad4Status.dwCurrentState = SERVICE_STOP_PENDING;
        Bad4Status.dwCheckPoint = 1;
        Bad4Status.dwWaitHint = 20000;

        SetEvent(Bad4DoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [BAD4] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //
    if (!SetServiceStatus (Bad4StatusHandle,  &Bad4Status)) {
        status = GetLastError();
        DbgPrint(" [BAD4] SetServiceStatus error %ld\n",status);
    }

    CloseHandle(Bad4DoneEvent);
    return;
}

/****************************************************************************/

//
// HangOnStop Service doesn't return from the control handling routine
// on STOP requests until after the pipe timeout period (30 seconds).
// After 40 seconds, it sends a STOP_PENDING status.
//
// Just to confuse things, after the timeout, this service sends a
// RUNNING status (after an additional 30msec delay).  Then it sleeps for
// 20 seconds before sending a STOPPED status.
//

DWORD
HangOnStopStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;


    DbgPrint(" [HangOnStop] Inside the HangOnStop Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [HangOnStop] CommandArg%d = %s\n", i,argv[i]);
    }


    HangOnStopDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    HangOnStopStatus.dwServiceType        = SERVICE_WIN32;
    HangOnStopStatus.dwCurrentState       = SERVICE_RUNNING;
    HangOnStopStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_PAUSE_CONTINUE;

    HangOnStopStatus.dwWin32ExitCode      = 0;
    HangOnStopStatus.dwServiceSpecificExitCode = 0;
    HangOnStopStatus.dwCheckPoint         = 0;
    HangOnStopStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [HangOnStop] Getting Ready to call RegisterServiceCtrlHandler\n");

    HangOnStopStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("HangOnStop"),
                            HangOnStopCtrlHandler);

    if (HangOnStopStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [HangOnStop] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (HangOnStopStatusHandle, &HangOnStopStatus)) {
        status = GetLastError();
        DbgPrint(" [HangOnStop] SetServiceStatus error %ld\n",status);
    }

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                HangOnStopDoneEvent,
                INFINITE_WAIT_TIME);

    Sleep(30);

    HangOnStopStatus.dwCurrentState = SERVICE_RUNNING;
    if (!SetServiceStatus (HangOnStopStatusHandle, &HangOnStopStatus)) {
        status = GetLastError();
        DbgPrint(" [HangOnStop] SetServiceStatus error %ld\n",status);
    }

    Sleep(20000);

    HangOnStopStatus.dwCurrentState = SERVICE_STOPPED;
    if (!SetServiceStatus (HangOnStopStatusHandle, &HangOnStopStatus)) {
        status = GetLastError();
        DbgPrint(" [HangOnStop] SetServiceStatus error %ld\n",status);
    }

    DbgPrint(" [HangOnStop] Leaving the HangOnStop service\n");
    CloseHandle(HangOnStopDoneEvent);
    
    return(NO_ERROR);
}


/****************************************************************************/
VOID
HangOnStopCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [HangOnStop] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        HangOnStopStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        HangOnStopStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        HangOnStopStatus.dwWin32ExitCode = 0;
        HangOnStopStatus.dwServiceSpecificExitCode = 0;
        HangOnStopStatus.dwCurrentState = SERVICE_STOP_PENDING;
        HangOnStopStatus.dwCheckPoint = 1;
        HangOnStopStatus.dwWaitHint = 20000;

        Sleep(40000);

        SetEvent(HangOnStopDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [HangOnStop] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //
    if (!SetServiceStatus (HangOnStopStatusHandle,  &HangOnStopStatus)) {
        status = GetLastError();
        DbgPrint(" [HangOnStop] SetServiceStatus error %ld\n",status);
    }

    CloseHandle(HangOnStopDoneEvent);
    return;
}

/****************************************************************************/
DWORD
StartProcStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;
    STARTUPINFOW         ScStartupInfo;
    PROCESS_INFORMATION     processInfo;
    LPWSTR  ImageName;
    HWND    hWnd= NULL;


    DbgPrint(" [START_PROC] Inside the StartProc Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [START_PROC] CommandArg%d = %s\n", i,argv[i]);
    }

    //
    // This call to a GDI function causes a connection to the Win
    // User Server.  It doesn't matter which GDI function is called, this
    // one happens to be easiest.  This allows us to create a child process
    // that is interactive with the user (like cmd.exe).
    //

    hWnd = GetDesktopWindow();
    if (hWnd == NULL) {
        DbgPrint(" [START_PROC] GetDesktopWindow call failed %d\n", GetLastError());
    }

    //
    // Create an event to wait on.
    //

    StartProcDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    StartProcStatus.dwServiceType        = SERVICE_WIN32;
    StartProcStatus.dwCurrentState       = SERVICE_RUNNING;
    StartProcStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                       SERVICE_ACCEPT_PAUSE_CONTINUE |
                                       SERVICE_ACCEPT_SHUTDOWN;
    StartProcStatus.dwWin32ExitCode      = 0;
    StartProcStatus.dwServiceSpecificExitCode = 0;
    StartProcStatus.dwCheckPoint         = 0;
    StartProcStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [START_PROC] Getting Ready to call RegisterServiceCtrlHandler\n");

    StartProcStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("StartProc"),
                            StartProcCtrlHandler);

    if (StartProcStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [START_PROC] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (StartProcStatusHandle,  &StartProcStatus)) {
        status = GetLastError();
        DbgPrint(" [START_PROC] SetServiceStatus error %ld\n",status);
    }

    //*******************************************************************
    //  Start a Child Process
    //
    ScStartupInfo.cb              = sizeof(STARTUPINFOW); // size
    ScStartupInfo.lpReserved      = NULL;                 // lpReserved
    ScStartupInfo.lpDesktop       = NULL;                 // DeskTop
    ScStartupInfo.lpTitle         = L"Local System Window"; // Title
    ScStartupInfo.dwX             = 0;                    // X (position)
    ScStartupInfo.dwY             = 0;                    // Y (position)
    ScStartupInfo.dwXSize         = 0;                    // XSize (dimension)
    ScStartupInfo.dwYSize         = 0;                    // YSize (dimension)
    ScStartupInfo.dwXCountChars   = 0;                    // XCountChars
    ScStartupInfo.dwYCountChars   = 0;                    // YCountChars
    ScStartupInfo.dwFillAttribute = 0;                    // FillAttributes
    ScStartupInfo.dwFlags         = STARTF_FORCEOFFFEEDBACK;
                                                          // Flags - should be STARTF_TASKNOTCLOSABLE
    ScStartupInfo.wShowWindow     = SW_SHOWNORMAL;        // ShowWindow
    ScStartupInfo.cbReserved2     = 0L;                   // cbReserved
    ScStartupInfo.lpReserved2     = NULL;                 // lpReserved


//    ScStartupInfo.dwFlags |= STARTF_DESKTOPINHERIT;
//    ScStartupInfo.lpDesktop = pszInteractiveDesktop;

    ImageName = L"cmd.exe";

    if (!CreateProcessW (
            NULL,           // Fully qualified image name
            ImageName,      // Command Line
            NULL,           // Process Attributes
            NULL,           // Thread Attributes
            TRUE,           // Inherit Handles
            CREATE_NEW_CONSOLE, // Creation Flags
            NULL,           // Pointer to Environment block
            NULL,           // Pointer to Current Directory
            &ScStartupInfo, // Startup Info
            &processInfo)   // ProcessInformation
        ) {

        status = GetLastError();
        DbgPrint(" [START_PROC] CreateProcess %ws failed %d \n",
                ImageName,
                status);
    }
    else {
        DbgPrint(" [START_PROC]CreateProcess Success \n");
    }

    //
    //
    //*******************************************************************

    //
    // Wait forever until we are told to terminate.
    //

    status = WaitForSingleObject (
                StartProcDoneEvent,
                INFINITE_WAIT_TIME);


    DbgPrint(" [START_PROC] Leaving the StartProc service\n");

    CloseHandle(StartProcDoneEvent);
    CloseHandle(hWnd);
    
    return(NO_ERROR);
}


/****************************************************************************/
VOID
StartProcCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [START_PROC] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        StartProcStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        StartProcStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:

        StartProcStatus.dwWin32ExitCode = 0;
        StartProcStatus.dwCurrentState = SERVICE_STOPPED;

        SetEvent(StartProcDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        DbgPrint(" [START_PROC] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (StartProcStatusHandle,  &StartProcStatus)) {
        status = GetLastError();
        DbgPrint(" [START_PROC] SetServiceStatus error %ld\n",status);
    }
    return;
}


/****************************************************************************/
DWORD
StartAndDieStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;
    DWORD   checkpoint=1;


    DbgPrint(" [StartAndDie] Inside the StartAndDie Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [START&DIE] CommandArg%d = %s\n", i,argv[i]);
    }


    StartAndDieDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //

    StartAndDieStatus.dwServiceType        = SERVICE_WIN32;
    StartAndDieStatus.dwCurrentState       = SERVICE_START_PENDING;
    StartAndDieStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                       SERVICE_ACCEPT_PAUSE_CONTINUE |
                                       SERVICE_ACCEPT_SHUTDOWN;
    StartAndDieStatus.dwWin32ExitCode      = 0;
    StartAndDieStatus.dwServiceSpecificExitCode = 0;
    StartAndDieStatus.dwCheckPoint         = checkpoint++;
    StartAndDieStatus.dwWaitHint           = 40000;

    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [START&DIE] Getting Ready to call RegisterServiceCtrlHandler\n");

    StartAndDieStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("StartAndDie"),
                            StartAndDieCtrlHandler);

    if (StartAndDieStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [START&DIE] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }

    //
    // Return the status
    //

    if (!SetServiceStatus (StartAndDieStatusHandle,  &StartAndDieStatus)) {
        status = GetLastError();
        DbgPrint(" [START&DIE] SetServiceStatus error %ld\n",status);
    }

    //
    // Sleep for a bit, the say we are running, then say we are stopped.
    //
    Sleep(30000);


    StartAndDieStatus.dwCurrentState    = SERVICE_RUNNING;
    StartAndDieStatus.dwCheckPoint      = 0;
    StartAndDieStatus.dwWaitHint        = 0;

    if (!SetServiceStatus (StartAndDieStatusHandle, &StartAndDieStatus)) {
        status = GetLastError();
        DbgPrint("[START&DIE] SetServiceStatus error %ld\n",status);
    }

    StartAndDieStatus.dwCurrentState    = SERVICE_STOPPED;
    StartAndDieStatus.dwCheckPoint      = 0;
    StartAndDieStatus.dwWaitHint        = 0;
    StartAndDieStatus.dwWin32ExitCode      = ERROR_INVALID_ENVIRONMENT;

    if (!SetServiceStatus (StartAndDieStatusHandle, &StartAndDieStatus)) {
        status = GetLastError();
        DbgPrint("[START&DIE] SetServiceStatus error %ld\n",status);
    }

    DbgPrint(" [START&DIE] Leaving the start&die service\n");

    CloseHandle(StartAndDieDoneEvent);
    
    return(NO_ERROR);
}


/****************************************************************************/
VOID
StartAndDieCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;

    DbgPrint(" [START&DIE] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:
        SvcPrintf("StartAndDie received a PAUSE\n");
        StartAndDieStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:
        SvcPrintf("StartAndDie received a CONTINUE\n");
        StartAndDieStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:
        SvcPrintf("StartAndDie received a STOP\n");

        StartAndDieStatus.dwWin32ExitCode = 0;
        StartAndDieStatus.dwCurrentState = SERVICE_STOPPED;

        SetEvent(StartAndDieDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        SvcPrintf("StartAndDie received an INTERROGATE\n");
        break;

    default:
        DbgPrint(" [START&DIE] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (StartAndDieStatusHandle,  &StartAndDieStatus)) {
        status = GetLastError();
        DbgPrint(" [START&DIE] SetServiceStatus error %ld\n",status);
    }
    return;
}

VOID
SetUpConsole()
{

//#ifdef NOT_NECESSARY

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    COORD coord;
    HANDLE consoleHandle=NULL;

    if (!AllocConsole()) {
        DbgPrint("[TS2]AllocConsole failed %d\n",GetLastError());
    }

    consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    if (consoleHandle == NULL) {
        DbgPrint("[TS2]GetStdHandle failed %d\n",GetLastError());
    }

    if (!GetConsoleScreenBufferInfo(
            GetStdHandle(STD_OUTPUT_HANDLE),
            &csbi)) {
        DbgPrint("[TS2]GetConsoleScreenBufferInfo failed %d\n",GetLastError());
    }
    coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
    coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
    if (!SetConsoleScreenBufferSize(
            GetStdHandle(STD_OUTPUT_HANDLE),
            coord)) {

        DbgPrint("[TS2]SetConsoleScreenBufferSize failed %d\n",GetLastError());
    }

//#endif //NOT_NECESSARY

	DbgLogFileHandle = CreateFile("\\trace.log",
					 GENERIC_READ | GENERIC_WRITE,
					 FILE_SHARE_READ,
					 NULL,
					 CREATE_ALWAYS,
					 0,
					 NULL);
}

VOID
SvcPrintf (
    char *Format,
    ...
    )

/*++

Routine Description:

    This routine provides printf functionality when the service is run with
    REMOTE.EXE.

        sc config LUMPY binpath= "remote /s \"ts2\" LUMPY"

    NOTE:  It is not necessary to allocate a console in this case because
    remote already provides one.  So the only portion of SetupConsole() that
    is used is the portion the opens the debug dump file.

Arguments:

    Same as printf

Return Value:


--*/
{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;

    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    length = strlen( OutputBuffer );

    if (!WriteFile(
            GetStdHandle(STD_OUTPUT_HANDLE),
            (LPVOID )OutputBuffer,
            length,
            &length,
            NULL )) {

        DbgPrint("[TS2]WriteFile Failed %d \n",GetLastError());
    }

    if(DbgLogFileHandle != INVALID_HANDLE_VALUE) {

	    if (!WriteFile(
                DbgLogFileHandle,
                (LPVOID )OutputBuffer,
                length,
                &length,
                NULL )) {

            DbgPrint("[TS2]WriteFile Failed %d \n",GetLastError());
        }
    }

} // SsPrintf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\client\ts3.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ts3.c

Abstract:

    This is a test program for exercising the service controller.  This
    program acts like a service and exercises the Service Controller API
    that can be called from a service:
        SetServiceStatus
        StartServiceCtrlDispatcher   
        RegisterServiceCtrlHandler

Author:

    Dan Lafferty (danl)      2 Apr-1992

Environment:

    User Mode -Win32

Revision History:

--*/

//
// Includes
//

#include <nt.h>      // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>

#include <winsvc.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>      // OpenFile
#include <sys\types.h>  // OpenFile
#include <sys\stat.h>   // OpenFile
#include <io.h>         // OpenFile

#include <tstr.h>       // Unicode string macros
#include <rpc.h>

//
// Defines
//

#define INFINITE_WAIT_TIME  0xffffffff

#define NULL_STRING     TEXT("");


//
// Globals
//

    SERVICE_STATUS  SingleStatus;

    HANDLE          SingleDoneEvent;

    SERVICE_STATUS_HANDLE   SingleStatusHandle;

//
// Function Prototypes
//

VOID
SingleStart (
    DWORD   argc,
    LPTSTR  *argv
    );


VOID
SingleCtrlHandler (
    IN  DWORD   opcode
    );

DWORD
GetIntlFormat(
    LPWSTR  type,
    LPWSTR  string,
    DWORD   numChars);

VOID
GetTime(
    LPWSTR  *time
    );


/****************************************************************************/
VOID __cdecl
main(void)
{
    DWORD   status;

    SERVICE_TABLE_ENTRY   DispatchTable[] = {
        { TEXT("single"),   SingleStart     },
        { TEXT("single1"),  SingleStart     },   // this entry should be ignored.
        { NULL,             NULL            }
    };
    
    if (!StartServiceCtrlDispatcher( DispatchTable)) {
        status = GetLastError();
        DbgPrint("[ts3]StartServiceCtrlDispatcher failed %d \n",status);
        if (status = ERROR_FAILED_SERVICE_CONTROLLER_CONNECT) {
            printf("Failed to connect to service controller, this "
            "program should be started with the Services Control Panel Applet, "
            "or at the command line with Net Start <ServiceName>");
        }
    }

    DbgPrint("[ts3]The Service Process is Terminating....)\n");

    ExitProcess(0);

}


/****************************************************************************/

//
// Single will take a long time to respond to pause
//
//

VOID
SingleStart (
    DWORD   argc,
    LPTSTR  *argv
    )
{
    DWORD   status;
    DWORD   i;
    NETRESOURCEW netResource;

    DbgPrint(" [SINGLE] Inside the Single Service Thread\n");

    for (i=0; i<argc; i++) {
        DbgPrint(" [SINGLE] CommandArg%d = %s\n", i,argv[i]);
    }


    SingleDoneEvent = CreateEvent (NULL, TRUE, FALSE,NULL);

    //
    // Fill in this services status structure
    //
    DbgPrint(" [SINGLE] Send status with ServiceType = SERVICE_WIN32\n"
             "          This should not overwrite the copy that SC maintains\n"
             "          which should be SERVICE_WIN32_OWN_PROCESS\n");

    SingleStatus.dwServiceType        = SERVICE_WIN32;
    SingleStatus.dwCurrentState       = SERVICE_RUNNING;
    SingleStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                        SERVICE_ACCEPT_PAUSE_CONTINUE;
    SingleStatus.dwWin32ExitCode      = 0;
    SingleStatus.dwServiceSpecificExitCode = 0;
    SingleStatus.dwCheckPoint         = 0;
    SingleStatus.dwWaitHint           = 0;
    
    //
    // Register the Control Handler routine.
    //

    DbgPrint(" [SINGLE] Getting Ready to call RegisterServiceCtrlHandler\n");

    SingleStatusHandle = RegisterServiceCtrlHandler(
                            TEXT("single"),
                            SingleCtrlHandler);

    if (SingleStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint(" [SINGLE] RegisterServiceCtrlHandler failed %d\n", GetLastError());
    }
    
    //
    // Return the status
    //

    if (!SetServiceStatus (SingleStatusHandle, &SingleStatus)) {
        status = GetLastError();
        DbgPrint(" [SINGLE] SetServiceStatus error %ld\n",status);
    }

    //================================
    // SPECIAL TEST GOES HERE.
    //================================

#define TEST_USE_ADD
#ifdef TEST_USE_ADD

    netResource.lpRemoteName = L"\\\\Kernel\\scratch";
    netResource.lpLocalName  = L"z:";
    netResource.lpProvider = NULL;
    netResource.dwType = RESOURCETYPE_DISK;

    status = WNetAddConnection2W(&netResource, NULL, NULL, 0L);
    if (status != NO_ERROR) {
        DbgPrint("WNetAddConnection (z:) Failed %d\n",status);
    }

    netResource.lpRemoteName = L"\\\\popcorn\\public";
    netResource.lpLocalName  = L"p:";
    netResource.lpProvider = NULL;
    netResource.dwType = RESOURCETYPE_DISK;

    status = WNetAddConnection2W(&netResource, NULL, NULL, 0L);
    if (status != NO_ERROR) {
        DbgPrint("WNetAddConnection (p:) Failed %d\n",status);
    }
#endif

    {
        UUID        Uuid;
        RPC_STATUS  rpcstatus;

        rpcstatus = UuidCreate(&Uuid);
        if (rpcstatus != NO_ERROR) {
            DbgPrint("UuidCreate Failed %d \n",rpcstatus);
        }
    }

    //
    // Wait forever until we are told to terminate.
    //
    {

        //
        // This portion of the code determines that the working directory
        // is the system32 directory.
        //
        LPSTR   String = GetEnvironmentStrings();
        DWORD   rc;

        Sleep(1000);
        while (*String != 0) {
            DbgPrint("%s\n",String);
            String += (strlen(String) + 1);
        }
        rc = _open("DansFile.txt",O_CREAT | O_BINARY,S_IREAD | S_IWRITE);
        if (rc == -1) {
            DbgPrint("OpenFile Failed\n");
        }
            
    }

    status = WaitForSingleObject (
                SingleDoneEvent,
                INFINITE_WAIT_TIME);

    status = WNetCancelConnectionW(L"z:",FALSE);
    if (status != NO_ERROR) {
        DbgPrint("WNetCancelConnection (z:) Failed %d\n",status);
    }
    status = WNetCancelConnectionW(L"p:",FALSE);
    if (status != NO_ERROR) {
        DbgPrint("WNetCancelConnection (p:) Failed %d\n",status);
    }

    DbgPrint(" [SINGLE] Leaving the single service\n");

    ExitThread(NO_ERROR);
    return;
}


/****************************************************************************/
VOID
SingleCtrlHandler (
    IN  DWORD   Opcode
    )
{

    DWORD   status;
    LPWSTR  time;

    HANDLE          enumHandle;
    DWORD           numElements;
    DWORD           bufferSize;
    LPNETRESOURCE   pNetResource;
    DWORD           i;

    DbgPrint(" [SINGLE] opcode = %ld\n", Opcode);

    //
    // Find and operate on the request.
    //

    switch(Opcode) {
    case SERVICE_CONTROL_PAUSE:

        DbgPrint("[SINGLE] Sleep 1 minute before responding to pause request\n");
        Sleep(60000);    // 1 minute

        SingleStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        SingleStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_STOP:

        SingleStatus.dwWin32ExitCode = 0;
        SingleStatus.dwCurrentState = SERVICE_STOPPED;

        SetEvent(SingleDoneEvent);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        status = WNetOpenEnumW(
                    RESOURCE_CONNECTED,
                    RESOURCETYPE_DISK,
                    0,
                    NULL,
                    &enumHandle);

        if (status != WN_SUCCESS) {
            DbgPrint("WNetOpenEnum failed %d\n",status);
        }
        else {
            //
            // Attempt to allow for 10 connections
            //
            bufferSize = (10*sizeof(NETRESOURCE))+1024;
        
            pNetResource = (LPNETRESOURCE) LocalAlloc(LPTR, bufferSize);

            if (pNetResource == NULL) {
                DbgPrint("TestEnum:LocalAlloc Failed %d\n",GetLastError);
                break;
            }
            numElements = 0xffffffff;
            status = WNetEnumResourceW(
                            enumHandle,
                            &numElements,
                            pNetResource,
                            &bufferSize);

            if ( status != WN_SUCCESS) {
                DbgPrint("WNetEnumResource failed %d\n",status);
        
                //
                // If there is an extended error, display it.
                //
                if (status == WN_EXTENDED_ERROR) {
                    DbgPrint("Extended Error\n");
                }
                WNetCloseEnum(enumHandle);
                LocalFree(pNetResource);
            }
            else {
                if (numElements == 0) {
                    DbgPrint("No Connections to Enumerate\n");
                }
                for (i=0; i < numElements ;i++ ) {
                    DbgPrint("%ws is connected to %ws\n",
                    pNetResource[i].lpLocalName,
                    pNetResource[i].lpRemoteName);

                }
                WNetCloseEnum(enumHandle);
                LocalFree(pNetResource);
            }
        }
        GetTime(&time);
        DbgPrint(" [SINGLE] time = %ws\n",time);
        break;

    default:
        DbgPrint(" [SINGLE] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (SingleStatusHandle,  &SingleStatus)) {
        status = GetLastError();
        DbgPrint(" [SINGLE] SetServiceStatus error %ld\n",status);
    }
    return;    
}

//************************************************************************
//
// TEST CODE
//
//************************************************************************
#define PARSE_SIZE      80
#define TIME_SEP_SIZE    2

VOID
GetTime(
    LPWSTR  *time
    )
{
    WCHAR       czParseString[PARSE_SIZE];
    WCHAR       czTimeString[PARSE_SIZE];
    LPWSTR      pCurLoc;
    LPWSTR      pTime;
    DWORD       numChars;
    SYSTEMTIME  SysTime;
    LPWSTR      AMPMString=L"";
    WCHAR       TimeSep[TIME_SEP_SIZE];
    BOOL        TwelveHour=TRUE;
    BOOL        LeadingZero=FALSE;
    DWORD       i,dateType;
    DWORD       numSame;

    //-----------------------------------------
    // Get the Current Time and Date.
    //-----------------------------------------
    GetLocalTime(&SysTime);

#ifdef CL_DEBUG
    printf("Year=%d,Month=%d,Day=%d,Hour=%d,Minute=%d\n",
        SysTime.wYear,
        SysTime.wMonth,
        SysTime.wDay,
        SysTime.wHour,
        SysTime.wMinute);
#endif
    //-----------------------------------------
    // Get the Date Format  (M/d/yy)
    //-----------------------------------------
    numChars = GetIntlFormat(L"sShortDate",czParseString,PARSE_SIZE);
    if (numChars == 0) {
        //
        // No data, use the default.
        //
        wcscpy(czParseString, L"M/d/yy");
    }

    //-----------------------------------------
    // Fill in the date string
    //-----------------------------------------
    pCurLoc = czTimeString;

    for (i=0; i<numChars; i++ ) {

        dateType = i;
        numSame  = 1;

        //
        // Find out how many characters are the same.
        // (MM or M, dd or d, yy or yyyy)
        //
        while (czParseString[i] == czParseString[i+1]) {
            numSame++;
            i++;
        }

        //
        // i is the offset to the last character in the date type.
        //

        switch (czParseString[dateType]) {
        case L'M':
        case L'm':
            //
            // If we have a single digit month, but require 2 digits,
            // then add a leading zero.
            //
            if ((numSame == 2) && (SysTime.wMonth < 10)) {
                *pCurLoc = L'0';
                pCurLoc++;
            }
            ultow(SysTime.wMonth, pCurLoc, 10);
            pCurLoc += wcslen(pCurLoc);
            break;

        case L'D':
        case L'd':

            //
            // If we have a single digit day, but require 2 digits,
            // then add a leading zero.
            //
            if ((numSame == 2) && (SysTime.wDay < 10)) {
                *pCurLoc = L'0';
                pCurLoc++;
            }
            ultow(SysTime.wDay, pCurLoc, 10);
            pCurLoc += wcslen(pCurLoc);
            break;

        case L'Y':
        case L'y':

            ultow(SysTime.wYear, pCurLoc, 10);
            //
            // If we are only to show 2 digits, take the
            // 3rd and 4th, and move them into the first two
            // locations.
            //
            if (numSame == 2) {
                pCurLoc[0] = pCurLoc[2];
                pCurLoc[1] = pCurLoc[3];
                pCurLoc[2] = L'\0';
            }
            pCurLoc += wcslen(pCurLoc);
            break;

        default:
            printf("Default case: Unrecognized time character - "
            "We Should never get here\n");
            break;
        }
        //
        // Increment the index beyond the last character in the data type.
        // If not at the end of the buffer, add the separator character.
        // Otherwise, add the trailing NUL.
        //
        i++;
        if ( i<numChars ) {
            *pCurLoc = czParseString[i];
            pCurLoc++;
        }
        else {
            *pCurLoc='\0';
        }
    }

    //-----------------------------------------
    // 12 or 24 hour format?
    //-----------------------------------------
    numChars = GetIntlFormat(L"iTime",czParseString,PARSE_SIZE);
    if (numChars > 0) {
        if (*czParseString == L'1'){
            TwelveHour = FALSE;
        }
    }

    //-----------------------------------------
    // Is there a Leading Zero?
    //-----------------------------------------
    if (GetProfileIntW(L"intl",L"iTLZero",0) == 1) {
        LeadingZero = TRUE;
    }

    //-----------------------------------------
    // Get the Time Separator character.
    //-----------------------------------------
    numChars = GetIntlFormat(L"sTime",TimeSep,TIME_SEP_SIZE);
    if (numChars == 0) {
        //
        // No data, use the default.
        //
        TimeSep[0] = L':';
        TimeSep[1] = L'\0';
    }

    //-------------------------------------------------
    // If running a 12 hour clock, Get the AMPM string.
    //-------------------------------------------------
    if (TwelveHour) {
        if (SysTime.wHour > 11) {
            numChars = GetIntlFormat(L"s2359",czParseString,PARSE_SIZE);
        }
        else {
            numChars = GetIntlFormat(L"s1159",czParseString,PARSE_SIZE);
        }
        if (numChars > 0) {
            AMPMString = LocalAlloc(LMEM_FIXED,wcslen(czParseString)+sizeof(WCHAR));
            if (AMPMString != NULL) {
                wcscpy(AMPMString,czParseString);
            }
        }
    }

    //
    // Build the time string
    //
    pTime = czTimeString + (wcslen(czTimeString) + 1);

    if ((TwelveHour) && (SysTime.wHour > 12)) {
        SysTime.wHour -= 12;
    }
    //
    // If the time is a single digit, and we need a leading zero,
    // than add the leading zero.
    //
    if ((SysTime.wHour < 10) && (LeadingZero)) {
        *pTime = L'0';
        pTime++;
    }
    ultow(SysTime.wHour, pTime, 10);
    pTime += wcslen(pTime);
    *pTime = *TimeSep;
    pTime++;
    if (SysTime.wMinute < 10) {
        *pTime = L'0';
        pTime++;
    }
    ultow(SysTime.wMinute, pTime, 10);
    wcscat(pTime,AMPMString);

    pTime = czTimeString + (wcslen(czTimeString) + 1);

#ifdef CL_DEBUG
    printf("Time = %ws,  Date = %ws\n",pTime,czTimeString);
#endif

    *(--pTime) = L' ';
    printf("\n  %ws\n", czTimeString);
    *time = czTimeString;
}

DWORD
GetIntlFormat(
    LPWSTR  type,
    LPWSTR  string,
    DWORD   numChars)
{
    DWORD num;

    num = GetProfileStringW(L"intl",type,L"",string,numChars);

#ifdef CL_DEBUG
    if (num > 0) {
        printf("%ws string from ini file = %ws\n",type, string);
    }
    else {
        printf("%ws string from ini file = (empty)\n",type);
    }
#endif
    return(num);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\imports.h ===
#include "scpragma.h"

#include <windef.h>

#ifdef MIDL_PASS
#define LPSTR  [string] LPSTR
#define LPTSTR [string] LPTSTR
#define LPWSTR [string] wchar_t *
#define enum   [v1_enum] enum
#endif

#include <winsvc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\sccrypt.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    sccrypt.h

Abstract:

    Password ncryption and decription routines.

Author:

    Rita Wong (ritaw)     27-Apr-1992

Revision History:

--*/

#ifndef _SCCRYPT_INCLUDED_
#define _SCCRYPT_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif


DWORD
ScEncryptPassword(
    IN  SC_RPC_HANDLE ContextHandle,
    IN  LPWSTR Password,
    OUT LPBYTE *EncryptedPassword,
    OUT LPDWORD EncryptedPasswordSize
    );

DWORD
ScDecryptPassword(
    IN  SC_RPC_HANDLE ContextHandle,
    IN  LPBYTE EncryptedPassword,
    IN  DWORD EncryptedPasswordSize,
    OUT LPWSTR *Password
    );

#ifdef __cplusplus
}
#endif

#endif // _SCCRYPT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\scdebug.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    scdebug.h

Abstract:

    Contains debug macros used by the Service Controller.

Author:

    Dan Lafferty (danl)     22-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    10-Apr-1992 JohnRo
        Added SC_ASSERT() and SCC_ASSERT() macros.
    16-Apr-1992 JohnRo
        Added debug flags for config APIs and database lock APIs.
        Include <debugfmt.h> to get FORMAT_ equates.
        Made changes suggested by PC-LINT.
    21-Apr-1992 JohnRo
        Added SC_LOG0(), etc.
    12-Nov-1995 AnirudhS
        Make SC_LOG macros use one DbgPrint instead of two.
    15-May-1996 AnirudhS
        Have SC_LOG macros print the thread id.

--*/


#ifndef SCDEBUG_H
#define SCDEBUG_H


#include <debugfmt.h>   // FORMAT_ equates.


#ifdef __cplusplus
extern "C" {
#endif

//
// Debug macros and constants.
//

#if !DBG || defined(lint) || defined(_lint)

#define DEBUG_STATE 0
#define STATIC static

#else // just DBG

#define DEBUG_STATE 1
#define STATIC

#endif // just DBG

//
// The following macros allow debug print syntax to look like:
//
//   SC_LOG1(TRACE, "An error occured: " FORMAT_DWORD "\n",status)
//

#if DBG

//
// Server-side debugging macros.
//

#define SC_LOG0(level, string)                      \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId()))

#define SC_LOG1(level, string, var)                 \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var))

#define SC_LOG2(level, string, var1, var2)          \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var1,                                \
               var2))

#define SC_LOG3(level, string, var1, var2, var3)    \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var1,                                \
               var2,                                \
               var3))

#define SC_LOG4(level, string, var1, var2, var3, var4) \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var1,                                \
               var2,                                \
               var3,                                \
               var4))

#define SC_LOG(level, string, var)                  \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var))

#define SC_ASSERT(boolExpr) ASSERT(boolExpr)


#define SVCHOST_LOG0(level, string)                 \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId()))

#define SVCHOST_LOG1(level, string, var)            \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var))

#define SVCHOST_LOG2(level, string, var1, var2)     \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var1,                                \
               var2))

#define SVCHOST_LOG3(level, string, var1, var2, var3) \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var1,                                \
               var2,                                \
               var3))

#define SVCHOST_LOG4(level, string, var1, var2, var3, var4) \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var1,                                \
               var2,                                \
               var3,                                \
               var4))

#define SVCHOST_LOG(level, string, var)             \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var))


//
// Client-side debugging macros.
//

#define SCC_LOG0(level, string)                     \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId()))

#define SCC_LOG1(level, string, var)                \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId(),               \
               var))

#define SCC_LOG2(level, string, var1, var2)         \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId(),               \
               var1,                                \
               var2))

#define SCC_LOG3(level, string, var1, var2, var3)   \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId(),               \
               var1,                                \
               var2,                                \
               var3))

#define SCC_LOG(level, string, var)                 \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId(),               \
               var))

#define SCC_ASSERT(boolExpr) ASSERT(boolExpr)

#else

#define SC_ASSERT(boolExpr)

#define SC_LOG0(level, string)
#define SC_LOG1(level, string, var)
#define SC_LOG2(level, string, var1, var2)
#define SC_LOG3(level, string, var1, var2, var3)
#define SC_LOG4(level, string, var1, var2, var3, var4)
#define SC_LOG(level, string, var)

#define SVCHOST_LOG0(level, string)
#define SVCHOST_LOG1(level, string, var)
#define SVCHOST_LOG2(level, string, var1, var2)
#define SVCHOST_LOG3(level, string, var1, var2, var3)
#define SVCHOST_LOG4(level, string, var1, var2, var3, var4)
#define SVCHOST_LOG(level, string, var)


#define SCC_ASSERT(boolExpr)

#define SCC_LOG0(level, string)
#define SCC_LOG1(level, string, var)
#define SCC_LOG2(level, string, var1, var2)
#define SCC_LOG3(level, string, var1, var2, var3)
#define SCC_LOG(level, string, var)

#endif

//
// Debug output is filtered at two levels: A global level and a component
// specific level.
//
// Each debug output request specifies a component id and a filter level
// or mask. These variables are used to access the debug print filter
// database maintained by the system. The component id selects a 32-bit
// mask value and the level either specified a bit within that mask or is
// as mask value itself.
//
// If any of the bits specified by the level or mask are set in either the
// component mask or the global mask, then the debug output is permitted.
// Otherwise, the debug output is filtered and not printed.
//
// The component mask for filtering the debug output of this component is
// Kd_SCSERVER_Mask or Kd_SCCLIENT_Mask and may be set via the registry or
// the kernel debugger.
//
// The global mask for filtering the debug output of all components is
// Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.
//
// The registry key for setting the mask value for this component is:
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\
//     Session Manager\Debug Print Filter\SCSERVER or SCCLIENT
//
// The key "Debug Print Filter" may have to be created in order to create
// the component key.
//

#define DEBUG_ERROR       (0x00000001 | DPFLTR_MASK)
#define DEBUG_WARNING     (0x00000002 | DPFLTR_MASK)
#define DEBUG_TRACE       (0x00000004 | DPFLTR_MASK)
#define DEBUG_INFO        (0x00000008 | DPFLTR_MASK)
#define DEBUG_SECURITY    (0x00000010 | DPFLTR_MASK)
#define DEBUG_CONFIG      (0x00000020 | DPFLTR_MASK)
#define DEBUG_DEPEND      (0x00000040 | DPFLTR_MASK)
#define DEBUG_DEPEND_DUMP (0x00000080 | DPFLTR_MASK)
#define DEBUG_CONFIG_API  (0x00000100 | DPFLTR_MASK)
#define DEBUG_LOCK_API    (0x00000200 | DPFLTR_MASK)
#define DEBUG_ACCOUNT     (0x00000400 | DPFLTR_MASK)
#define DEBUG_USECOUNT    (0x00000800 | DPFLTR_MASK)
#define DEBUG_NETBIOS     (0x00001000 | DPFLTR_MASK)
#define DEBUG_THREADS     (0x00002000 | DPFLTR_MASK)
#define DEBUG_BSM         (0x00004000 | DPFLTR_MASK)
#define DEBUG_SHUTDOWN    (0x00008000 | DPFLTR_MASK)
#define DEBUG_WHY         (0x00010000 | DPFLTR_MASK)
#define DEBUG_BOOT        (0x00020000 | DPFLTR_MASK)
#define DEBUG_HANDLE      (0x00040000 | DPFLTR_MASK)
#define DEBUG_LOCKS       (0x10000000 | DPFLTR_MASK)

#define DEBUG_ALL         (0xffffffff | DPFLTR_MASK)

#ifdef __cplusplus
}
#endif

#endif // def SCDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\control.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    control.h

Abstract:

    This file contains data structures and function prototypes for the
    Service Controller Control Interface.

Author:

    Dan Lafferty (danl)     28-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    28-Mar-1991     danl
        created

--*/

#ifdef __cplusplus
extern "C" {
#endif

//
// Internal controls.
// These must not be in the range or public controls ( 1-10)
// or in the range of user-defined controls (0x00000080 - 0x000000ff)
//

//
// Range for OEM defined control opcodes
//
#define OEM_LOWER_LIMIT     128
#define OEM_UPPER_LIMIT     255

//
// Used to start a service that shares a process with other services.
//
#define SERVICE_CONTROL_START_SHARE    0x00000050    // INTERNAL

//
// Used to start a service that has its own process.
//
#define SERVICE_CONTROL_START_OWN      0x00000051    // INTERNAL

//
// Private access level for OpenService to get a context handle for SetServiceStatus.
// This MUST NOT CONFLICT with the access levels in winsvc.h.
//
#define SERVICE_SET_STATUS             0x8000        // INTERNAL

//
// Service controls that can be passed to a non-EX control handler.  Relies
// on ordering/values of SERVICE_CONTROL_* constants in winsvc.h.
//
#define IS_NON_EX_CONTROL(dwControl)                                                            \
            ((dwControl >= SERVICE_CONTROL_STOP && dwControl <= SERVICE_CONTROL_NETBINDDISABLE) \
               ||                                                                               \
             (dwControl >= OEM_LOWER_LIMIT && dwControl <= OEM_UPPER_LIMIT))

//
// Data Structures
//

//
// The control message has the following format:
//      [MessageHeader][ServiceNameString][CmdArg1Ptr][CmdArg2Ptr]
//      [...][CmdArgnPtr][CmdArg1String][CmdArg2String][...][CmdArgnString]
//
//  Where CmdArg pointers are replaced with offsets that are relative to
//  the location of the 1st command arg pointer (the top of the argv list).
//
//  In the header, the NumCmdArgs, StatusHandle, and ArgvOffset parameters
//  are only used when the SERVICE_START OpCode is passed in.  They are
//  expected to be 0 at all other times.  The ServiceNameOffset and the
//  ArgvOffset are relative to the top of the buffer containing the
//  message (ie. the header Count field).  The Count field in the header
//  contains the number of bytes in the entire message (including the
//  header).
//
//

typedef struct _CTRL_MSG_HEADER
{
    DWORD                   Count;              // num bytes in buffer.
    DWORD                   OpCode;             // control opcode.
    DWORD                   NumCmdArgs;         // number of command Args.
    DWORD                   ServiceNameOffset;  // pointer to ServiceNameString
    DWORD                   ArgvOffset;         // pointer to Argument Vectors.
}
CTRL_MSG_HEADER, *PCTRL_MSG_HEADER, *LPCTRL_MSG_HEADER;

typedef struct _PIPE_RESPONSE_MSG
{
    DWORD       dwDispatcherStatus;
    DWORD       dwHandlerRetVal;
}
PIPE_RESPONSE_MSG, *PPIPE_RESPONSE_MSG, *LPPIPE_RESPONSE_MSG;

typedef struct _PNP_ARGUMENTS
{
    DWORD       dwEventType;
    DWORD       dwEventDataSize;
    PVOID       EventData;
}
PNP_ARGUMENTS, *PPNP_ARGUMENTS, *LPPNP_ARGUMENTS;


//
// Union to hold arguments to ScSendControl
//
typedef union _CONTROL_ARGS {
    LPWSTR          *CmdArgs;
    PNP_ARGUMENTS   PnPArgs;
} CONTROL_ARGS, *PCONTROL_ARGS, *LPCONTROL_ARGS;


//
// Defines and Typedefs
//

#define CONTROL_PIPE_NAME           L"\\\\.\\pipe\\net\\NtControlPipe"

#define PID_LEN                     10      // Max PID (DWORD_MAX) is 10 digits

#define CONTROL_TIMEOUT             30000   // timeout for waiting for pipe.

#define RESPONSE_WAIT_TIME          5000   // wait until service response.

//
// Function Prototypes
//

DWORD
ScCreateControlInstance (
    OUT LPHANDLE    PipeHandlePtr,
    IN  DWORD       dwProcessId,
    IN  PSID        pAccountSid
    );

VOID
ScDeleteControlInstance (
    IN  HANDLE      PipeHandle
    );

DWORD
ScWaitForConnect (
    IN  HANDLE    PipeHandle,
    IN  HANDLE    hProcess       OPTIONAL,
    IN  LPWSTR    lpDisplayName,
    OUT LPDWORD   ProcessIdPtr
    );

DWORD
ScSendControl (
    IN  LPWSTR                  ServiceName,
    IN  LPWSTR                  DisplayName,
    IN  HANDLE                  PipeHandle,
    IN  DWORD                   OpCode,
    IN  LPCONTROL_ARGS          lpControlArgs OPTIONAL,
    IN  DWORD                   NumArgs,
    OUT LPDWORD                 lpdwHandlerRetVal OPTIONAL
    );

VOID
ScShutdownAllServices(
    VOID
    );

DWORD
ScSendPnPMessage(
    IN  SERVICE_STATUS_HANDLE   hServiceStatus,
    IN  DWORD                   OpCode,
    IN  DWORD                   dwEventType,
    IN  LPARAM                  EventData,
    OUT LPDWORD                 lpdwHandlerRetVal
    );

DWORD
ScValidatePnPService(
    IN  LPWSTR                   lpServiceName,
    OUT SERVICE_STATUS_HANDLE    *lphServiceStatus
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\scwow.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    scwow.h

Abstract:

    Structure definitions for 32/64-bit interop

Author:

    Jonathan Schwartz (jschwart)   18-Sep-2000

Revision History:

--*/

#ifndef SCWOW_INCLUDED
#define SCWOW_INCLUDED


//
// Internal structures for the enum functions for 64/32-bit interop
// since the ENUM_SERVICE_STATUS* structures contain two pointers
// and we don't want to pass back structures of an indeterminate
// size.  Since the pointer fields are used as offsets only across
// the wire, use these structures to force those fields to be a
// known length (32 bits for compatibility with older clients).
//

typedef struct _ENUM_SERVICE_STATUS_WOW64
{
    DWORD          dwServiceNameOffset;
    DWORD          dwDisplayNameOffset;
    SERVICE_STATUS ServiceStatus;
}
ENUM_SERVICE_STATUS_WOW64, *LPENUM_SERVICE_STATUS_WOW64;

typedef struct _ENUM_SERVICE_STATUS_PROCESS_WOW64
{
    DWORD                  dwServiceNameOffset;
    DWORD                  dwDisplayNameOffset;
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
}
ENUM_SERVICE_STATUS_PROCESS_WOW64, *LPENUM_SERVICE_STATUS_PROCESS_WOW64;


//
// Internal structures for QueryServiceConfig2 for 64/32-bit interop
//

typedef struct _SERVICE_DESCRIPTION_WOW64
{
    DWORD    dwDescriptionOffset;
}
SERVICE_DESCRIPTION_WOW64, *LPSERVICE_DESCRIPTION_WOW64;

typedef struct _SERVICE_FAILURE_ACTIONS_WOW64
{
    DWORD    dwResetPeriod;
    DWORD    dwRebootMsgOffset;
    DWORD    dwCommandOffset;
    DWORD    cActions;
    DWORD    dwsaActionsOffset;
}
SERVICE_FAILURE_ACTIONS_WOW64, *LPSERVICE_FAILURE_ACTIONS_WOW64;


#endif // #ifndef SCWOW_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\scseclib.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    scseclib.h

Abstract:

    This header file defines the structures and function prototypes of
    routines which simplify the creation of security descriptors for
    user-mode objects.

Author:

    Rita Wong (ritaw) 27-Feb-1991

Revision History:

--*/

#ifndef _SCSECLIB_INCLUDED_
#define _SCSECLIB_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

//
// Global declarations
//

//
// NT well-known SIDs
//

extern PSID NullSid;                   // No members SID
extern PSID WorldSid;                  // All users SID
extern PSID LocalSid;                  // NT local users SID
extern PSID NetworkSid;                // NT remote users SID
extern PSID LocalSystemSid;            // NT system processes SID
extern PSID LocalServiceSid;           // NT LocalService SID
extern PSID NetworkServiceSid;         // NT NetworkService SID
extern PSID BuiltinDomainSid;          // Domain Id of the Builtin Domain
extern PSID AuthenticatedUserSid;      // NT authenticated users SID
extern PSID AnonymousLogonSid;         // Anonymous Logon SID

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

extern PSID AliasAdminsSid;            // Administrator Sid
extern PSID AliasUsersSid;             // User Sid
extern PSID AliasGuestsSid;            // Guest Sid
extern PSID AliasPowerUsersSid;        // Power User Sid
extern PSID AliasAccountOpsSid;        // Account Operator Sid
extern PSID AliasSystemOpsSid;         // System Operator Sid
extern PSID AliasPrintOpsSid;          // Print Operator Sid
extern PSID AliasBackupOpsSid;         // Backup Operator Sid

//
// Structure to hold information about an ACE to be created
//

typedef struct {
    UCHAR AceType;
    UCHAR InheritFlags;
    UCHAR AceFlags;
    ACCESS_MASK Mask;
    PSID *Sid;
} SC_ACE_DATA, *PSC_ACE_DATA;


NTSTATUS
ScCreateWellKnownSids(
    VOID
    );

NTSTATUS
ScAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    );

NTSTATUS
ScDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    );

NTSTATUS
ScCreateAndSetSD(
    IN  PSC_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

NTSTATUS
ScCreateUserSecurityObject(
    IN  PSECURITY_DESCRIPTOR ParentSD,
    IN  PSC_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  BOOLEAN IsDirectoryObject,
    IN  BOOLEAN UseImpersonationToken,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

DWORD
ScCreateStartEventSD(
    PSECURITY_DESCRIPTOR    *pEventSD
    );

#ifdef __cplusplus
}
#endif

#endif // ifdef _SCSECLIB_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\scpragma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    scpragma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let the Service Controller compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\svcslib.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    svcslib.h

Abstract:

    Contains information for connecting services to the controller process.

Author:

    Dan Lafferty (danl)     26-Oct-1993

Environment:

    User Mode -Win32

Revision History:

    26-Oct-1993     danl
        created
    04-Dec-1996     anirudhs
        Added CWorkItemContext

--*/

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//
DWORD
SvcStartLocalDispatcher(
    VOID
    );

BOOL
SetupInProgress(
    HKEY    SystemKey,
    PBOOL   pfIsOOBESetup    OPTIONAL
    );

#ifdef __cplusplus

//===================
// CWorkItemContext
//===================
// Higher-level wrapper for Rtl thread pool functions
//
// An instance of this class is a callback context for the Rtl thread pool functions
//
class CWorkItemContext
{
public:

    NTSTATUS            AddWorkItem(
                            IN  DWORD    dwFlags
                            )
                        {
                            return RtlQueueWorkItem(CallBack,
                                                    this,     // pContext
                                                    dwFlags);
                        }

    NTSTATUS            AddDelayedWorkItem(
                            IN  DWORD    dwTimeout,
                            IN  DWORD    dwFlags
                            );

    VOID             RemoveDelayedWorkItem(
                         VOID
                         )
                     {
                         ASSERT(m_hWorkItem != NULL);
                         RtlDeregisterWait(m_hWorkItem);
                         m_hWorkItem = NULL;
                     }

    static BOOL         Init();
    static void         UnInit();

protected:

    virtual VOID        Perform(
                            IN BOOLEAN   fWaitStatus
                            ) = 0;

    HANDLE              m_hWorkItem;

private:
    static VOID         CallBack(
                            IN PVOID     pContext
                            );

    static VOID         DelayCallBack(
                            IN PVOID     pContext,
                            IN BOOLEAN   fWaitStatus
                            );

    static HANDLE       s_hNeverSignaled;
};

#define DECLARE_CWorkItemContext                        \
protected:                                              \
    VOID                Perform(                        \
                            IN BOOLEAN   fWaitStatus    \
                            );

} // extern "C"

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\strarray.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    StrArray.h

Abstract:

    This is the a header file of handy functions and macros for TCHAR
    string arrays.

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

Author:

    John Rogers (JohnRo) 03-Jan-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-Jan-1992 JohnRo
        Created this file from bits and pieces in RxCommon and NetLib.

--*/

#ifndef _STRARRAY_
#define _STRARRAY_


// These must be included first:

#include <windef.h>             // IN, LPTSTR, LPVOID, etc.

// These may be included in any order:

// (none)



#ifdef __cplusplus
extern "C" {
#endif

VOID
ScAddWStrToWStrArray (
    IN OUT LPWSTR Dest,
    IN LPWSTR Src
    );

// BOOL
// ScIsWStrArrayEmpty (
//     IN LPWSTR Array
//     );
#define ScIsWStrArrayEmpty( Array )  \
    ( ( (*(Array)) == 0) ? TRUE : FALSE )



#if DBG

VOID
ScDisplayWStrArray (
    IN LPWSTR Array
    );

#else // not DBG

#define ScDisplayWStrArray(Array)     /* nothing */

#endif // not DBG


// LPWSTR
// ScNextWStrArrayEntry (
//     IN LPWSTR Array
//     );
#define ScNextWStrArrayEntry(Array) \
    ( ((LPWSTR)(Array)) + (wcslen(Array) + 1) )


// LPSTR
// ScNextAStrArrayEntry (
//     IN LPSTR Array
//     );
#define ScNextAStrArrayEntry(Array) \
    ( ((LPSTR)(Array)) + (strlen(Array) + 1) )

//
// Return number of bytes to allocate for this string array.
// This includes the "extra" trailing null char.
//
DWORD
ScWStrArraySize(
    IN LPWSTR Array
    );

DWORD
ScAStrArraySize(
    IN LPSTR Array
    );

#ifdef __cplusplus
}
#endif

#endif // ndef _STRARRAY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\sclib.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ScLib.h

Abstract:

    Prototypes routines which may be shared between Client (DLL) and
    Server (EXE) halves of service controller.

Author:

    Dan Lafferty (danl)     04-Feb-1992

Environment:

    User Mode -Win32

Revision History:

    04-Feb-1992     danl
        created
    10-Apr-1992 JohnRo
        Added ScIsValidImagePath() and ScImagePathsMatch().
    14-Apr-1992 JohnRo
        Added ScCheckServiceConfigParms(), ScIsValid{Account,Driver,Start}Name.
    27-May-1992 JohnRo
        Use CONST where possible.
        Fixed a UNICODE bug.

--*/


#ifndef SCLIB_H
#define SCLIB_H

////////////////////////////////////////////////////////////////////////////
// DEFINES
//

//
// Used by the client side of OpenSCManager to wait until the Service
// Controller has been started.
//
#define SC_INTERNAL_START_EVENT L"Global\\SvcctrlStartEvent_A3752DX"


////////////////////////////////////////////////////////////////////////////
// FUNCTION PROTOTYPES
//

//
// From acctname.cxx
//
BOOL
ScIsValidAccountName(
    IN  LPCWSTR lpAccountName
    );

//
// From confparm.cxx
//
DWORD
ScCheckServiceConfigParms(
    IN  BOOL            Change,
    IN  LPCWSTR         lpServiceName,
    IN  DWORD           dwActualServiceType,
    IN  DWORD           dwNewServiceType,
    IN  DWORD           dwStartType,
    IN  DWORD           dwErrorControl,
    IN  LPCWSTR         lpBinaryPathName OPTIONAL,
    IN  LPCWSTR         lpLoadOrderGroup OPTIONAL,
    IN  LPCWSTR         lpDependencies   OPTIONAL,
    IN  DWORD           dwDependSize
    );

//
// From convert.cxx
//
BOOL
ScConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPCSTR  AnsiIn
    );

BOOL
ScConvertToAnsi(
    OUT LPSTR    AnsiOut,
    IN  LPCWSTR  UnicodeIn
    );

//
// From packstr.cxx
//
BOOL
ScCopyStringToBufferW (
    IN      LPCWSTR  String OPTIONAL,
    IN      DWORD   CharacterCount,
    IN      LPCWSTR  FixedDataEnd,
    IN OUT  LPWSTR  *EndOfVariableData,
    OUT     LPWSTR  *VariableDataPointer,
    IN      const LPBYTE lpBufferStart    OPTIONAL
    );

//
// From path.cxx
//
BOOL
ScImagePathsMatch(
    IN  LPCWSTR OnePath,
    IN  LPCWSTR TheOtherPath
    );

BOOL
ScIsValidImagePath(
    IN  LPCWSTR ImagePathName,
    IN  DWORD ServiceType
    );

//
// From startnam.cxx
//
BOOL
ScIsValidStartName(
    IN  LPCWSTR lpStartName,
    IN  DWORD dwServiceType
    );

//
// From util.cxx
//
BOOL
ScIsValidServiceName(
    IN  LPCWSTR ServiceName
    );

#endif // SCLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\acctname.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    AcctName.c

Abstract:

    Contains miscellaneous utility functions used by the Service
    Controller:

        ScIsValidAccountName

Author:

    John Rogers (JohnRo) 14-Apr-1992

Environment:

    User Mode -Win32

Revision History:

    14-Apr-1992 JohnRo
        Created.
    20-May-1992 JohnRo
        Use CONST where possible.

--*/

#include <nt.h>
#include <ntrtl.h>
//#include <nturtl.h>
#include <windef.h>

#include <scdebug.h>    // SC_ASSERT().
#include <sclib.h>      // My prototype.
#include <stdlib.h>      // wcschr().



BOOL
ScIsValidAccountName(
    IN  LPCWSTR lpAccountName
    )

/*++

Routine Description:

    This function validates a given service Account name.

Arguments:

    lpAccountName - Supplies the Account name to be validated.

Return Value:

    TRUE - The name is valid.

    FALSE - The name is invalid.

--*/

{

    if (lpAccountName == NULL) {
        return (FALSE);          // Missing name isn't valid.
    } else if ( (*lpAccountName) == L'\0' ) {
        return (FALSE);          // Missing name isn't valid.
    }

    //
    // name is account name ("domain\user" or ".\user" or LocalSystem).
    //
    if (lpAccountName[0] == L'\\') {
        return (FALSE);
    }

    //
    // The account name is canonicalized and validated later.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\inc\valid.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    valid.h

Abstract:

    Contains validation macros and function prototypes for service
    controller parameters.

Author:

    Dan Lafferty (danl) 29-Mar-1992

Environment:

    User Mode - Win32

Revision History:

    29-Mar-1992 danl
        Created
    10-Apr-1992 JohnRo
        Added START_TYPE_INVALID().
        Changed SERVICE_TYPE_INVALID() into SERVICE_TYPE_MASK_INVALID() and
        added a stricter SERVICE_TYPE_INVALID() which checks for one type.
        Made other macros less likely to be evaluated wrong.

--*/


#ifndef VALID_H
#define VALID_H

#ifdef __cplusplus
extern "C" {
#endif

//
// INCLUDES
//

//
// DEFINITIONS
//
#define MAX_SERVICE_NAME_LENGTH   256


//
// MACROS
//

#define CONTROLS_ACCEPTED_INVALID(cA)  \
           (((cA) & ~(SERVICE_ACCEPT_STOP |             \
                      SERVICE_ACCEPT_PAUSE_CONTINUE |   \
                      SERVICE_ACCEPT_SHUTDOWN |         \
                      SERVICE_ACCEPT_PARAMCHANGE |      \
                      SERVICE_ACCEPT_HARDWAREPROFILECHANGE |      \
                      SERVICE_ACCEPT_NETBINDCHANGE |    \
                      SERVICE_ACCEPT_POWEREVENT |       \
                      SERVICE_ACCEPT_SESSIONCHANGE)) !=0)

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define ERROR_CONTROL_INVALID( eC ) \
    ( \
        ( (eC) != SERVICE_ERROR_NORMAL ) && \
        ( (eC) != SERVICE_ERROR_SEVERE ) && \
        ( (eC) != SERVICE_ERROR_IGNORE ) && \
        ( (eC) != SERVICE_ERROR_CRITICAL ) \
    )

#define SERVICE_STATUS_TYPE_INVALID(sT) \
    ( \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32_OWN_PROCESS ) && \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32_SHARE_PROCESS ) && \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32 ) && \
        ( (sT) != SERVICE_DRIVER ) \
    )

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define SERVICE_TYPE_INVALID(sT) \
    ( \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32_OWN_PROCESS ) && \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32_SHARE_PROCESS ) && \
        ( (sT) != SERVICE_KERNEL_DRIVER ) && \
        ( (sT) != SERVICE_FILE_SYSTEM_DRIVER ) \
    )

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define SERVICE_TYPE_MASK_INVALID(sT)                \
            ((((sT) &  SERVICE_TYPE_ALL) == 0 )  ||  \
             (((sT) & ~SERVICE_TYPE_ALL) != 0 ))

#define ENUM_STATE_MASK_INVALID(sS)                   \
            ((((sS) &  SERVICE_STATE_ALL) == 0 )  || \
             (((sS) & ~SERVICE_STATE_ALL) != 0 ))

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define START_TYPE_INVALID(sT)                \
    ( \
        ( (sT) != SERVICE_BOOT_START ) && \
        ( (sT) != SERVICE_SYSTEM_START ) && \
        ( (sT) != SERVICE_AUTO_START ) && \
        ( (sT) != SERVICE_DEMAND_START ) && \
        ( (sT) != SERVICE_DISABLED ) \
    )

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define ACTION_TYPE_INVALID(aT)           \
    ( \
        ( (aT) != SC_ACTION_NONE ) && \
        ( (aT) != SC_ACTION_RESTART ) && \
        ( (aT) != SC_ACTION_REBOOT ) && \
        ( (aT) != SC_ACTION_RUN_COMMAND ) \
    )

//
// FUNCTION PROTOTYPES
//

BOOL
ScCurrentStateInvalid(
    DWORD   dwCurrentState
    );

DWORD
ScValidateMultiSZ(
    LPCWSTR lpStrings,
    DWORD   cbStrings
    );

#ifdef __cplusplus
}
#endif

#endif // VALID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\confparm.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfParm.c

Abstract:

    This file contains:
        ScCheckServiceConfigParms


Author:

    John Rogers (JohnRo) 14-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    14-Apr-1992 JohnRo
        Created.
    20-May-1992 JohnRo
        Use CONST where possible.
    09-Dec-1996     AnirudhS
        Added SC_LOG printouts to help diagnose the annoying
        ERROR_INVALID_PARAMETER and ERROR_INVALID_SERVICE_ACCOUNT return codes.

--*/


//
// INCLUDES
//

#include <scpragma.h>

#include <nt.h>
#include <ntrtl.h>      // Needed by <scdebug.h>
#include <nturtl.h>
#include <stdlib.h>      // wcsicmp

#include <windef.h>
#include <winbase.h>    // GetCurrentThreadId, for SC_LOG

#include <scdebug.h>    // SC_ASSERT().
#include <sclib.h>      // My prototype.
#include <valid.h>      // ERROR_CONTROL_INVALID(), SERVICE_TYPE_INVALID(), etc.
#include <winerror.h>   // NO_ERROR and ERROR_ equates.
#include <winsvc.h>     // SERVICE_ equates.



DWORD
ScCheckServiceConfigParms(
    IN  BOOL            Change,
    IN  LPCWSTR         lpServiceName,
    IN  DWORD           dwActualServiceType,
    IN  DWORD           dwNewServiceType,
    IN  DWORD           dwStartType,
    IN  DWORD           dwErrorControl,
    IN  LPCWSTR         lpBinaryPathName OPTIONAL,
    IN  LPCWSTR         lpLoadOrderGroup OPTIONAL,
    IN  LPCWSTR         lpDependencies   OPTIONAL,
    IN  DWORD           dwDependSize
    )

/*++

Routine Description:

    This routine checks parameters for a CreateService() or a
    ChangeServiceConfig() API.

Arguments:

    Change - TRUE if this is the result of a ChangeServiceConfig API.
        (This flag is used to determine whether other parameters may be
        SERVICE_NO_CHANGE or NULL pointers.)

    dwActualServiceType - For ChangeServiceConfig, contains the current
        service type associated with this service.  Otherwise, this is
        the same value as dwNewServiceType.

    dwNewServiceType - SERVICE_NO_CHANGE or the service type given by app.

    (Other parameters same as CreateService and ChangeServiceConfig APIs.)

Return Value:

    NO_ERROR or error code.

--*/

{
    DWORD dwFinalServiceType;

#define PARM_MISSING( ws )   ( ((ws)==NULL) || ((*(ws)) == L'\0') )

    if ( !Change ) {

        //
        // Almost all fields must be present for creating a service.
        // (Exceptions are dependencies and password.)
        //
        if ( (dwNewServiceType  == SERVICE_NO_CHANGE) ||
             (dwStartType       == SERVICE_NO_CHANGE) ||
             (dwErrorControl    == SERVICE_NO_CHANGE) ||
             PARM_MISSING(lpBinaryPathName) ) {

            SC_LOG0(ERROR, "ServiceType, StartType, ErrorControl or BinPath missing\n");
            return (ERROR_INVALID_PARAMETER);

        }
    }

    //
    // Validate actual and desired service types.
    //
    if (dwNewServiceType != SERVICE_NO_CHANGE) {
        if ( SERVICE_TYPE_INVALID( dwNewServiceType ) ) {
            SC_LOG0(ERROR, "ServiceType invalid\n");
            return (ERROR_INVALID_PARAMETER);
        }

        //
        // Not allowed to change the service type from Win32 to Driver
        // or Driver to Win32.
        //
        if ( ((dwNewServiceType & SERVICE_DRIVER) &&
              (dwActualServiceType & SERVICE_WIN32)) ||
             ((dwNewServiceType & SERVICE_WIN32) &&
              (dwActualServiceType & SERVICE_DRIVER)) ) {
            SC_LOG0(ERROR, "Can't change service type between Win32 and Driver\n");
            return (ERROR_INVALID_PARAMETER);
        }
    }
    if (dwActualServiceType == SERVICE_NO_CHANGE) {
        SC_LOG0(ERROR, "Current ServiceType missing\n");
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate start type (if that was given).
    //
    if (dwStartType != SERVICE_NO_CHANGE) {

        if ( START_TYPE_INVALID( dwStartType ) ) {
            SC_LOG0(ERROR, "StartType invalid\n");
            return (ERROR_INVALID_PARAMETER);
        }

        //
        // A boot-start or system-start service must be a driver
        //
        if (dwStartType == SERVICE_BOOT_START ||
            dwStartType == SERVICE_SYSTEM_START) {

            if (dwNewServiceType == SERVICE_NO_CHANGE) {

                if (dwActualServiceType != SERVICE_KERNEL_DRIVER &&
                    dwActualServiceType != SERVICE_FILE_SYSTEM_DRIVER) {

                    SC_LOG0(ERROR, "StartType is boot or system but service is not a driver\n");
                    return (ERROR_INVALID_PARAMETER);
                }
            }
            else {
                if (dwNewServiceType != SERVICE_KERNEL_DRIVER &&
                    dwNewServiceType != SERVICE_FILE_SYSTEM_DRIVER) {

                    SC_LOG0(ERROR, "StartType is boot or system but ServiceType is not driver\n");
                    return (ERROR_INVALID_PARAMETER);
                }
            }
        }
    }

    //
    // Validate error control...
    //
    if (dwErrorControl != SERVICE_NO_CHANGE) {
        if ( ERROR_CONTROL_INVALID( dwErrorControl ) ) {
            SC_LOG0(ERROR, "ErrorControl invalid\n");
            return (ERROR_INVALID_PARAMETER);
        }
    }

    //
    // Path type depends on final service type.
    //
    if (dwNewServiceType == SERVICE_NO_CHANGE) {
        dwFinalServiceType = dwActualServiceType;
    } else {
        dwFinalServiceType = dwNewServiceType;
    }
    SC_ASSERT( dwFinalServiceType != SERVICE_NO_CHANGE );

    //
    // Validate binary path name.
    //
    if (lpBinaryPathName != NULL) {

        // Check path name syntax and make sure it matches service type.
        // Path type depends on final service type.
        if ( !ScIsValidImagePath( lpBinaryPathName, dwFinalServiceType ) ) {
            SC_LOG0(ERROR, "ImagePath invalid for this service type\n");
            return (ERROR_INVALID_PARAMETER);
        }
    }

    //
    // Check for trivial cases of circular dependencies:
    //    1) Service is dependent on itself
    //    2) Service is dependent on a group it is a member of
    //
    LPWSTR DependPtr = (LPWSTR) lpDependencies;

    if (DependPtr != NULL && (*DependPtr != L'\0'))
    {
        DWORD  dwError = ScValidateMultiSZ(DependPtr, dwDependSize);

        if (dwError != NO_ERROR)
        {
            SC_LOG(ERROR,
                   "ScCheckServiceConfigParms: Invalid dependencies %d\n",
                   dwError);

            return dwError;
        }

        while (*DependPtr != 0) {

            if (*DependPtr == SC_GROUP_IDENTIFIERW) {

                if ((lpLoadOrderGroup != NULL) && (*lpLoadOrderGroup != 0)) {

                    if (_wcsicmp(DependPtr + 1, lpLoadOrderGroup) == 0) {

                        //
                        // Service depends on the group it is in
                        //
                        SC_LOG0(ERROR, "Service depends on the group it is in\n");
                        return (ERROR_CIRCULAR_DEPENDENCY);
                    }
                }
            }
            else {

                if (_wcsicmp(DependPtr, lpServiceName) == 0) {

                    //
                    // Service depends on itself
                    //
                    SC_LOG0(ERROR, "Service depends on itself\n");
                    return (ERROR_CIRCULAR_DEPENDENCY);
                }
            }

            DependPtr += (wcslen(DependPtr) + 1);
        }
    }

    //
    // Start name is checked and canonicalized in ScValidateAndSaveAccount
    // if service type is Win32.  If service type is driver, it's up to
    // the I/O system to validate the driver name (it can be NULL and the
    // I/O system will use the default driver name).
    //

    return (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\packstr.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    packstr.c

Abstract:

    Contains functions for packing strings into buffers that also contain
    structures.

Author:

    Dan Lafferty (danl)     13-Jan-1992

Environment:

    User Mode -Win32

Revision History:

    13-Jan-1992     danl
        stole from netlib.
    27-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.
        Fixed a UNICODE-related bug.

--*/

#include <scpragma.h>

#include <windef.h>     // IN, OUT, etc.
#include <sclib.h>      // My prototypes.
#include <string.h>     // strncpy
#include <stdlib.h>      // wcsncpy


BOOL
ScCopyStringToBufferW (
    IN      LPCWSTR String OPTIONAL,
    IN      DWORD   CharacterCount,
    IN      LPCWSTR FixedDataEnd,
    IN OUT  LPWSTR  *EndOfVariableData,
    OUT     LPWSTR  *VariableDataPointer,
    IN      const LPBYTE lpBufferStart    OPTIONAL
    )

/*++

Routine Description:

    This routine puts a single variable-length string into an output buffer.
    The string is not written if it would overwrite the last fixed structure
    in the buffer.

    The code is swiped from svcsupp.c written by DavidTr.

    Sample usage:

            LPBYTE FixedDataEnd = OutputBuffer + sizeof(WKSTA_INFO_202);
            LPWSTR EndOfVariableData = OutputBuffer + OutputBufferSize;

            //
            // Copy user name
            //

            ScCopyStringToBuffer(
                UserInfo->UserName.Buffer;
                UserInfo->UserName.Length;
                FixedDataEnd,
                &EndOfVariableData,
                &WkstaInfo->wki202_username,
                NULL
                );

Arguments:

    String - Supplies a pointer to the source string to copy into the
        output buffer.  If String is null then a pointer to a zero terminator
        is inserted into output buffer.

    CharacterCount - Supplies the length of String, not including zero
        terminator.  (This in units of characters - not bytes).

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer or offset to the
        variable data should be written.  Pointer vs. offset is decided
        based on the presence of lpBufferStart

    lpBufferStart - If NULL, VariableDataPointer should be filled with
        a pointer to the string written into the buffer.  If non-NULL,
        VariableDataPointer should be filled with an offset to the
        string written into the buffer.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{
    DWORD CharsNeeded = (CharacterCount + 1);

    //
    // Determine if string will fit, allowing for a zero terminator.  If no,
    // just set the pointer to NULL.
    //

    if ((*EndOfVariableData - CharsNeeded) >= FixedDataEnd) {

        //
        // It fits.  Move EndOfVariableData pointer up to the location where
        // we will write the string.
        //

        *EndOfVariableData -= CharsNeeded;

        //
        // Copy the string to the buffer if it is not null.
        //

        if (CharacterCount > 0 && String != NULL) {

            wcsncpy(*EndOfVariableData, String, CharacterCount);
        }

        //
        // Set the zero terminator.
        //

        *(*EndOfVariableData + CharacterCount) = L'\0';

        //
        // Set up the pointer in the fixed data portion to point to where the
        // string is written.
        //

        if (lpBufferStart != NULL)
        {
            *(LPDWORD) VariableDataPointer =
                           (DWORD) ((LPBYTE) *EndOfVariableData - lpBufferStart);
        }
        else
        {
            *VariableDataPointer = *EndOfVariableData;
        }

        return TRUE;

    }
    else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        if (lpBufferStart != NULL)
        {
            *(LPDWORD) VariableDataPointer = 0;
        }
        else
        {
            *VariableDataPointer = NULL;
        }

        return FALSE;
    }
} // ScCopyStringToBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\util.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Contains miscellaneous utility functions used by the Service
    Controller:

        ScIsValidServiceName

Author:

    Rita Wong (ritaw)     15-Mar-1992

Environment:

    User Mode -Win32

Revision History:

    11-Apr-1992 JohnRo
        Added an assertion check.
        Include <sclib.h> so compiler checks prototypes.
    20-May-1992 JohnRo
        winsvc.h and related file cleanup.

--*/

#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <scdebug.h>    // SC_ASSERT().
#include <sclib.h>      // My prototype.
#include <valid.h>      // MAX_SERVICE_NAME_LENGTH



BOOL
ScIsValidServiceName(
    IN  LPCWSTR ServiceName
    )
/*++

Routine Description:

    This function validates a given service name.  The name length
    cannot be greater than 256 characters, and must not contain any
    forward-slash, or back-slash.

Arguments:

    ServiceName - Supplies the service name to be validated.

Return Value:

    TRUE - The name is valid.

    FALSE - The name is invalid.

--*/
{
    LPCWSTR IllegalChars = L"\\/";
    DWORD NameLength;

    SC_ASSERT( ServiceName != NULL );  // Avoid memory access fault in wcslen().

    if (*ServiceName == 0) {
        return FALSE;
    }

    if ((NameLength = (DWORD) wcslen(ServiceName)) > MAX_SERVICE_NAME_LENGTH) {
        return FALSE;
    }

    if (wcscspn(ServiceName, IllegalChars) < NameLength) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\strarray.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    StrArray.c

Abstract:

    This is the a header file of handy functions and macros for TCHAR
    string arrays.

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

    These functions are useful for the NetServerDiskEnum and NetConfigGetAll
    APIs, and possibly others.

Author:

    John Rogers (JohnRo) 24-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Note:

    This function assumes that the machine's default codepage is the same
    as the LAN's default codepage.

Revision History:

    24-Oct-1991 JohnRo
        Created.
    02-Jan-1992 JohnRo
        Moved my RxpCopyStrArrayToTStrArray() from RxCommon to NetLib,
        and renamed it.  Added some other random functions.
    30-Jan-1992 JohnRo
        Fixed off-by-one bug in NetpAddTStrToTStrArray().
        Enhanced handling of "empty" TCHAR string arrays.
        Use TCHAR_EOS equate.
    29-Apr-1992 RitaW
        Changed for service controller use.

--*/

#include <scpragma.h>

#include <stdlib.h>
#include <string.h>             // strlen() for codepage strings.

#include <nt.h>
#include <ntrtl.h>              // Needed by <scdebug.h>

// These must be included first:

#include <windef.h>             // IN, VOID, LPWSTR, etc.

// These can be in any order:

#include <strarray.h>           // Exported function prototypes
#include <tstr.h>               // WCSSIZE

#include <scdebug.h>            // SC_ASSERT


VOID
ScAddWStrToWStrArray (
    IN OUT LPWSTR DestArray,
    IN LPWSTR Src
    )
{
    DWORD AddSize;  // byte count (including null char) of string being added
    LPWSTR DestStringStart;
    DWORD NewArraySize;
    DWORD OldArraySize;

    SC_ASSERT( DestArray != NULL );
    SC_ASSERT( Src != NULL );
    if ((DestArray == NULL) || (Src == NULL)) {
        return;
    }

    OldArraySize = ScWStrArraySize( DestArray );  // May be 2 bytes.

    SC_ASSERT( wcslen(Src) > 0 );  // We couldn't tell from end of array.

    AddSize = (DWORD) WCSSIZE( Src );

    NewArraySize = OldArraySize + AddSize;

    SC_ASSERT( NewArraySize > 0 );  // We couldn't tell from end of array.

    //
    // Figure-out where new string would start.  Note that OldArraySize
    // includes the null char which was the end of the array, so we have
    // to subtract a character to start the new one where that null char is.
    //
    DestStringStart = (LPWSTR) ((DWORD_PTR) DestArray + OldArraySize-sizeof(WCHAR));
    SC_ASSERT( DestStringStart != NULL );

    (void) wcscpy(
            DestStringStart,            // dest
            Src);                       // src

    // Mark end of array.
    DestArray[NewArraySize / sizeof(WCHAR) - 1] = 0;

    SC_ASSERT( ! ScIsWStrArrayEmpty( DestArray ) );

} // ScAddWStrToWStrArray


#if DBG

VOID
ScDisplayWStrArray (
    IN LPWSTR Array
    )
{
    LPWSTR CurrentEntry = Array;

    if (Array == NULL) {
        return;
    }

    if (*CurrentEntry == 0) {
        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP | DEBUG_WARNING | DEBUG_CONFIG,
                   "   (empty)\n"));
    } else {
        while (*CurrentEntry != 0) {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_DEPEND_DUMP | DEBUG_WARNING | DEBUG_CONFIG,
                       "   "  FORMAT_LPWSTR "\n",
                       (LPWSTR)CurrentEntry));

            CurrentEntry += ( wcslen( CurrentEntry ) + 1 );
        }
    }

} // ScDisplayWStrArray

#endif // DBG


DWORD
ScWStrArraySize(
    IN LPWSTR Array
    )
{
    DWORD ArrayByteCount = 0;
    LPWSTR Entry = Array;

    if (Array == NULL) {
        return(0);
    }

    //
    // Loop for each string in the array.
    //
    while ( (*Entry) != 0 ) {

        DWORD EntryByteCount = (DWORD) WCSSIZE(Entry);  // This entry and its null.

        ArrayByteCount += EntryByteCount;

        Entry = (LPWSTR) ((DWORD_PTR) Entry + EntryByteCount);
    }

    ArrayByteCount += sizeof(WCHAR);    // Indicate end of array.

    return (ArrayByteCount);

} // ScWStrArraySize


DWORD
ScAStrArraySize(
    IN LPSTR Array
    )
{
    DWORD ArrayByteCount = 0;
    LPSTR Entry = Array;


    if (Array == NULL) {
        return(0);
    }

    //
    // Loop for each string in the array.
    //
    while ( (*Entry) != 0 ) {

        DWORD EntryByteCount = (DWORD) strlen(Entry) + sizeof(CHAR);

        ArrayByteCount += EntryByteCount;

        Entry = (LPSTR) ((DWORD_PTR) Entry + EntryByteCount);
    }

    ArrayByteCount += sizeof(CHAR);    // Indicate end of array.

    return (ArrayByteCount);

} // ScAStrArraySize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\scseclib.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    scseclib.c

Abstract:

    This module provides support routines to simplify the creation of
    security descriptors.

Author:

    Rita Wong      (ritaw)  27-Feb-1991
    Cliff Van Dyke (cliffv)
    Richard Ward   (richardw) 8-April-92  Modified for Cairo

Environment:

    Contains NT specific code.

Revision History:

    13-Apr-1992 JohnRo
        Made changes suggested by PC-LINT.
--*/

#include <scpragma.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windef.h>     // DWORD (needed by scdebug.h).
#include <winbase.h>
#include <stdlib.h>        // max()
#include <scdebug.h>    // STATIC.
#include <scseclib.h>


//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

NTSTATUS
ScInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    );

NTSTATUS
ScInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    );

NTSTATUS
ScInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//


//
// NT well-known SIDs
//

PSID NullSid              = NULL;     // No members SID
PSID WorldSid             = NULL;     // All users SID
PSID LocalSid             = NULL;     // NT local users SID
PSID NetworkSid           = NULL;     // NT remote users SID
PSID LocalSystemSid       = NULL;     // NT system processes SID
PSID LocalServiceSid      = NULL;     // NT LocalService SID
PSID NetworkServiceSid    = NULL;     // NT NetworkService SID
PSID BuiltinDomainSid     = NULL;     // Domain Id of the Builtin Domain
PSID AuthenticatedUserSid = NULL;     // NT authenticated users SID
PSID AnonymousLogonSid    = NULL;     // Anonymous Logon SID

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//
PSID AliasAdminsSid       = NULL;
PSID AliasUsersSid        = NULL;
PSID AliasGuestsSid       = NULL;
PSID AliasPowerUsersSid   = NULL;
PSID AliasAccountOpsSid   = NULL;
PSID AliasSystemOpsSid    = NULL;
PSID AliasPrintOpsSid     = NULL;
PSID AliasBackupOpsSid    = NULL;

#if DBG

//
// Debug flag
//
ULONG RtlSeDebugFlag = 0;

#define RTL_SE_DUMP_ACLS       0x00000001

typedef struct _STANDARD_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    PSID Sid;
} STANDARD_ACE;
typedef STANDARD_ACE *PSTANDARD_ACE;

//
//  The following macros used by DumpAcl(), these macros and DumpAcl() are
//  stolen from private\ntos\se\ctaccess.c (written by robertre) for
//  debugging purposes.
//

//
//  Returns a pointer to the first Ace in an Acl (even if the Acl is empty).
//

#define FirstAce(Acl) ((PSTANDARD_ACE)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Returns a pointer to the next Ace in a sequence (even if the input
//  Ace is the one in the sequence).
//

#define NextAce(Ace) \
        ((PSTANDARD_ACE)((PUCHAR)(Ace) + ((PACE_HEADER)(PVOID)(Ace))->AceSize))

VOID
DumpAcl(
    IN PACL Acl
    );

#endif //ifdef DBG

//
// Data describing the well-known SIDs created by ScCreateWellKnownSids.
//

struct _SID_DATA {
    PSID *Sid;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    ULONG SubAuthority;
} SidData[] = {
 {&NullSid,              SECURITY_NULL_SID_AUTHORITY,  SECURITY_NULL_RID},
 {&WorldSid,             SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID},
 {&LocalSid,             SECURITY_LOCAL_SID_AUTHORITY, SECURITY_LOCAL_RID},
 {&NetworkSid,           SECURITY_NT_AUTHORITY,        SECURITY_NETWORK_RID},
 {&LocalSystemSid,       SECURITY_NT_AUTHORITY,        SECURITY_LOCAL_SYSTEM_RID},
 {&LocalServiceSid,      SECURITY_NT_AUTHORITY,        SECURITY_LOCAL_SERVICE_RID},
 {&NetworkServiceSid,    SECURITY_NT_AUTHORITY,        SECURITY_NETWORK_SERVICE_RID},
 {&BuiltinDomainSid,     SECURITY_NT_AUTHORITY,        SECURITY_BUILTIN_DOMAIN_RID},
 {&AuthenticatedUserSid, SECURITY_NT_AUTHORITY,        SECURITY_AUTHENTICATED_USER_RID},
 {&AnonymousLogonSid,    SECURITY_NT_AUTHORITY,        SECURITY_ANONYMOUS_LOGON_RID}
};


struct _BUILTIN_DOMAIN_SID_DATA {
    PSID *Sid;
    ULONG RelativeId;
} BuiltinDomainSidData[] = {
    { &AliasAdminsSid,      DOMAIN_ALIAS_RID_ADMINS },
    { &AliasUsersSid,       DOMAIN_ALIAS_RID_USERS },
    { &AliasGuestsSid,      DOMAIN_ALIAS_RID_GUESTS },
    { &AliasPowerUsersSid,  DOMAIN_ALIAS_RID_POWER_USERS },
    { &AliasAccountOpsSid,  DOMAIN_ALIAS_RID_ACCOUNT_OPS },
    { &AliasSystemOpsSid,   DOMAIN_ALIAS_RID_SYSTEM_OPS },
    { &AliasPrintOpsSid,    DOMAIN_ALIAS_RID_PRINT_OPS },
    { &AliasBackupOpsSid,   DOMAIN_ALIAS_RID_BACKUP_OPS }
};



NTSTATUS
ScCreateWellKnownSids(
    VOID
    )
/*++

Routine Description:

    This function creates some well-known SIDs and store them in global
    variables:

        //
        // NT well-known SIDs
        //

        PSID NullSid;                     // No members SID
        PSID WorldSid;                    // All users SID
        PSID LocalSid;                    // NT local users SID
        PSID NetworkSid;                  // NT remote users SID
        PSID LocalSystemSid;              // NT system processes SID
        PSID LocalServiceSid;             // NT LocalService SID
        PSID NetworkServiceSid;           // NT NetworkService SID
        PSID BuiltinDomainSid;            // Domain Id of the Builtin Domain
        PSID AuthenticatedUserSid;        // NT authenticated users SID
        PSID AnonymousLogonSid;           // NT anonymous logon

        //
        // Well Known Aliases.
        //
        // These are aliases that are relative to the built-in domain.
        //

        PSID AliasAdminsSid;
        PSID AliasUsersSid;
        PSID AliasGuestsSid;
        PSID AliasPowerUsersSid;
        PSID AliasAccountOpsSid;
        PSID AliasSystemOpsSid;
        PSID AliasPrintOpsSid;
        PSID AliasBackupOpsSid;

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for SID

--*/
{
    NTSTATUS ntstatus;
    ULONG i;


    //
    // Allocate and initialize well-known SIDs which aren't relative to
    // the domain Id.
    //

    for (i = 0; i < (sizeof(SidData) / sizeof(SidData[0])) ; i++) {

        ntstatus = ScAllocateAndInitializeSid(
                       SidData[i].Sid,
                       &(SidData[i].IdentifierAuthority),
                       1);

        if (! NT_SUCCESS(ntstatus)) {
            return STATUS_NO_MEMORY;
        }

        *(RtlSubAuthoritySid(*(SidData[i].Sid), 0)) = SidData[i].SubAuthority;
    }

    //
    // Build each SID which is relative to the Builtin Domain Id.
    //

    for ( i = 0;
          i < (sizeof(BuiltinDomainSidData) / sizeof(BuiltinDomainSidData[0]));
          i++) {

        ntstatus = ScDomainIdToSid(
                       BuiltinDomainSid,
                       BuiltinDomainSidData[i].RelativeId,
                       BuiltinDomainSidData[i].Sid );

        if (! NT_SUCCESS(ntstatus)) {
            return STATUS_NO_MEMORY;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ScAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    )
/*++

Routine Description:

    This function allocates memory for a SID and initializes it.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for SID

--*/
{
    *Sid = (PSID) RtlAllocateHeap(
                      RtlProcessHeap(), 0,
                      RtlLengthRequiredSid(SubAuthorityCount)
                      );

    if (*Sid == NULL) {
        return STATUS_NO_MEMORY;
    }

    (VOID) RtlInitializeSid(
            *Sid,
            IdentifierAuthority,
            (UCHAR)SubAuthorityCount );

    return STATUS_SUCCESS;
}


NTSTATUS
ScDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    )
/*++

Routine Description:

    Given a domain Id and a relative ID create a SID.

Arguments:

    DomainId - The template SID to use.

    RelativeId - The relative Id to append to the DomainId.

    Sid - Returns a pointer to an allocated buffer containing the resultant
            Sid.  Free this buffer using RtlFreeHeap.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for SID

    Any error status from RtlCopySid

--*/
{
    NTSTATUS ntstatus;
    UCHAR DomainIdSubAuthorityCount; // Number of sub authorities in domain ID
    ULONG SidLength;    // Length of newly allocated SID

    PVOID HeapHandle = RtlProcessHeap();


    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    SidLength = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((*Sid = (PSID) RtlAllocateHeap(
                           HeapHandle, 0,
                           SidLength
                           )) == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //
    ntstatus = RtlCopySid(SidLength, *Sid, DomainId);

    if (! NT_SUCCESS(ntstatus)) {
        (void) RtlFreeHeap(HeapHandle, 0, *Sid);
        return ntstatus;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( *Sid ))) ++;
    *RtlSubAuthoritySid( *Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return STATUS_SUCCESS;
}


NTSTATUS
ScCreateAndSetSD(
    IN  PSC_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates an absolute security descriptor containing
    the supplied ACE information.

    A sample usage of this function:

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        SE_ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &AliasAdminsSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        PSECURITY_DESCRIPTOR WkstaSecurityDescriptor;


        return SeCreateAndSetSD(
                   AceData,
                   4,
                   LocalSystemSid,
                   LocalSystemSid,
                   &WkstaSecurityDescriptor
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.  If not specified, a security descriptor with no owner
        will be created.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.  If not specified, a security descriptor with no primary
        group will be created.

    NewDescriptor - Returns a pointer to the absolute security descriptor
        allocated using RtlAllocateHeap.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

    NOTE : the user security object created by calling this function may be
                freed up by calling RtlDeleteSecurityObject().

--*/
{

    NTSTATUS ntstatus;
    ULONG i;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //
    // +---------------------------------------------------------------+
    // |                     Security Descriptor                       |
    // +-------------------------------+-------+---------------+-------+
    // |          DACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    // |          SACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    //

    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PACL Dacl = NULL;   // Pointer to the DACL portion of above buffer
    PACL Sacl = NULL;   // Pointer to the SACL portion of above buffer

    ULONG DaclSize = sizeof(ACL);
    ULONG SaclSize = sizeof(ACL);
    ULONG MaxAceSize = 0;
    PACCESS_ALLOWED_ACE MaxAce = NULL;

    PCHAR CurrentAvailable;
    ULONG Size;

    PVOID HeapHandle = RtlProcessHeap();


    ASSERT( AceCount > 0 );

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //

    for (i = 0; i < AceCount; i++) {
        ULONG AceSize;

        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            AceSize += sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG);
            DaclSize += AceSize;
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE) - sizeof(ULONG);
            DaclSize += AceSize;
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE) - sizeof(ULONG);
            SaclSize += AceSize;
            break;

        default:
            return STATUS_INVALID_PARAMETER;
        }

        MaxAceSize = max( MaxAceSize, AceSize );
    }

    //
    // Allocate a chunk of memory large enough the security descriptor
    // the DACL, the SACL and all ACEs.
    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    Size = SECURITY_DESCRIPTOR_MIN_LENGTH;
    if ( DaclSize != sizeof(ACL) ) {
        Size += DaclSize;
    }
    if ( SaclSize != sizeof(ACL) ) {
        Size += SaclSize;
    }

    if ((AbsoluteSd = RtlAllocateHeap(
                          HeapHandle, 0,
                          Size
                          )) == NULL) {
        KdPrint(("SeCreateAndSetSD: No memory to create absolute SD\n"));
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the Dacl and Sacl
    //

    CurrentAvailable = (PCHAR)AbsoluteSd + SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( DaclSize != sizeof(ACL) ) {
        Dacl = (PACL)CurrentAvailable;
        CurrentAvailable += DaclSize;

        ntstatus = RtlCreateAcl( Dacl, DaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            KdPrint(("ScCreateAndSetSD: Fail DACL Create %08lx\n",
                     ntstatus));
            goto Cleanup;
        }
    }

    if ( SaclSize != sizeof(ACL) ) {
        Sacl = (PACL)CurrentAvailable;
        CurrentAvailable += SaclSize;

        ntstatus = RtlCreateAcl( Sacl, SaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            KdPrint(("ScCreateAndSetSD: Fail SACL Create %08lx\n",
                     ntstatus));
            goto Cleanup;
        }
    }

    //
    // Allocate a temporary buffer big enough for the biggest ACE.
    //

    if ((MaxAce = (PACCESS_ALLOWED_ACE) RtlAllocateHeap(
                      HeapHandle, 0,
                      MaxAceSize
                      )) == NULL ) {
        KdPrint(("ScCreateAndSetSD: No memory to create max ace\n"));
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize each ACE, and append it into the end of the DACL or SACL.
    //

    for (i = 0; i < AceCount; i++) {
        ULONG AceSize;
        PACL CurrentAcl;

        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:

            AceSize += sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG);
            CurrentAcl = Dacl;
            ntstatus = ScInitializeAllowedAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE) - sizeof(ULONG);
            CurrentAcl = Dacl;
            ntstatus = ScInitializeDeniedAce(
                           (PACCESS_DENIED_ACE) MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE) - sizeof(ULONG);
            CurrentAcl = Sacl;
            ntstatus = ScInitializeAuditAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        default:
            SC_LOG2(ERROR,
                    "ScCreateAndSetSD: Invalid AceType %d in ACE %d\n",
                    AceData[i].AceType,
                    i);

            ASSERT(FALSE);
            CurrentAcl = NULL;
            ntstatus = STATUS_UNSUCCESSFUL;
        }

        if ( !NT_SUCCESS( ntstatus ) ) {
            KdPrint((
                    "ScCreateAndSetSD: Fail InitAce i: %d ntstatus: %08lx\n",
                     i, ntstatus));
            goto Cleanup;
        }

        //
        // Append the initialized ACE to the end of DACL or SACL
        //

        if (! NT_SUCCESS (ntstatus = RtlAddAce(
                                         CurrentAcl,
                                         ACL_REVISION,
                                         MAXULONG,
                                         MaxAce,
                                         AceSize
                                         ))) {
            KdPrint((
                    "ScCreateAndSetSD: Fail add ace i: %d ntstatus: %08lx\n",
                    i, ntstatus));
            goto Cleanup;
        }
    }

#if DBG
    DumpAcl(Dacl);
    if (Sacl) {
        DumpAcl(Sacl);
    }
#endif

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = OwnerSid
    // Group = GroupSid
    // Dacl  = Dacl
    // Sacl  = Sacl
    //

    if (! NT_SUCCESS(ntstatus = RtlCreateSecurityDescriptor(
                                    AbsoluteSd,
                                    SECURITY_DESCRIPTOR_REVISION
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetOwnerSecurityDescriptor(
                                    AbsoluteSd,
                                    OwnerSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetGroupSecurityDescriptor(
                                    AbsoluteSd,
                                    GroupSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetDaclSecurityDescriptor(
                                    AbsoluteSd,
                                    (BOOLEAN)(Dacl ? TRUE : FALSE),
                                    Dacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetSaclSecurityDescriptor(
                                    AbsoluteSd,
                                    (BOOLEAN)(Sacl ? TRUE : FALSE),
                                    Sacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    //
    // Done
    //

    ntstatus = STATUS_SUCCESS;

    //
    // Clean up
    //

Cleanup:
    //
    // Either return the security descriptor to the caller or delete it
    //

    if ( NT_SUCCESS( ntstatus ) ) {
        *NewDescriptor = AbsoluteSd;
    } else if ( AbsoluteSd != NULL ) {
        RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
    }

    //
    // Delete the temporary ACE
    //

    if ( MaxAce != NULL ) {
        RtlFreeHeap(HeapHandle, 0, MaxAce);
    }

    return ntstatus;
}


NTSTATUS
ScCreateUserSecurityObject(
    IN  PSECURITY_DESCRIPTOR ParentSD,
    IN  PSC_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  BOOLEAN IsDirectoryObject,
    IN  BOOLEAN UseImpersonationToken,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates the DACL for the security descriptor based on
    on the ACE information specified, and creates the security descriptor
    which becomes the user-mode security object.

    A sample usage of this function:

        //
        // Structure that describes the mapping of Generic access rights to
        // object specific access rights for the ConfigurationInfo object.
        //

        GENERIC_MAPPING WsConfigInfoMapping = {
            STANDARD_RIGHTS_READ            |      // Generic read
                WKSTA_CONFIG_GUEST_INFO_GET |
                WKSTA_CONFIG_USER_INFO_GET  |
                WKSTA_CONFIG_ADMIN_INFO_GET,
            STANDARD_RIGHTS_WRITE |                // Generic write
                WKSTA_CONFIG_INFO_SET,
            STANDARD_RIGHTS_EXECUTE,               // Generic execute
            WKSTA_CONFIG_ALL_ACCESS                // Generic all
            };

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        SE_ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &AliasAdminsSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        PSECURITY_DESCRIPTOR WkstaSecurityObject;


        return ScCreateUserSecurityObject(
                   AceData,
                   4,
                   LocalSystemSid,
                   LocalSystemSid,
                   FALSE,
                   &WsConfigInfoMapping,
                   &WkstaSecurityObject
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.

    IsDirectoryObject - Supplies the flag which indicates whether the
        user-mode object is a directory object.

    GenericMapping - Supplies the pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

    NewDescriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

    NOTE : the user security object created by calling this function may be
                freed up by calling RtlDeleteSecurityObject().

--*/
{

    NTSTATUS ntstatus;
    PSECURITY_DESCRIPTOR AbsoluteSd;
    HANDLE TokenHandle;
    PVOID HeapHandle = RtlProcessHeap();

    ntstatus = ScCreateAndSetSD(
                   AceData,
                   AceCount,
                   OwnerSid,
                   GroupSid,
                   &AbsoluteSd
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint((
                "ScCreateUserSecurityObject: ScCreateAndSetSD returned "
                "%08lx\n", ntstatus));
        return ntstatus;
    }

    if (UseImpersonationToken) {
        ntstatus = NtOpenThreadToken(
                       NtCurrentThread(),
                       TOKEN_QUERY,
                       FALSE,
                       &TokenHandle
                       );
    }
    else {
        ntstatus = NtOpenProcessToken(
                       NtCurrentProcess(),
                       TOKEN_QUERY,
                       &TokenHandle
                       );
    }

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint((
                "ScCreateUserSecurityObject: NtOpen...Token returned "
                "%08lx\n", ntstatus));
        (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
        return ntstatus;
    }

    //
    // Create the security object (a user-mode object is really a pseudo-
    // object represented by a security descriptor that have relative
    // pointers to SIDs and ACLs).  This routine allocates the memory to
    // hold the relative security descriptor so the memory allocated for the
    // DACL, ACEs, and the absolute descriptor can be freed.
    //
    ntstatus = RtlNewSecurityObject(
                   ParentSD,               // Parent descriptor
                   AbsoluteSd,             // Creator descriptor
                   NewDescriptor,          // Pointer to new descriptor
                   IsDirectoryObject,      // Is directory object
                   TokenHandle,            // Token
                   GenericMapping          // Generic mapping
                   );

    (void) NtClose(TokenHandle);

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint((
                "RtlCreateUserSecurityObject: RtlNewSecurityObject returned "
                "%08lx\n", ntstatus));
    }

    //
    // Free dynamic memory before returning
    //
    (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
    return ntstatus;
}


NTSTATUS
ScInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an allowed type ACE.

Arguments:

    AllowedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is allowed
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AllowedAce->Header.AceSize = AceSize;
    AllowedAce->Header.AceFlags = AceFlags | InheritFlags;

    AllowedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AllowedSid),
               &(AllowedAce->SidStart),
               AllowedSid
               );
}


NTSTATUS
ScInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into a denied type ACE.

Arguments:

    DeniedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the denied access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is denied
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    DeniedAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    DeniedAce->Header.AceSize = AceSize;
    DeniedAce->Header.AceFlags = AceFlags | InheritFlags;

    DeniedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(DeniedSid),
               &(DeniedAce->SidStart),
               DeniedSid
               );
}


NTSTATUS
ScInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an audit type ACE.

Arguments:

    AuditAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AuditSid - Supplies the pointer to the SID of user/group which is to be
        audited.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AuditAce->Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    AuditAce->Header.AceSize = AceSize;
    AuditAce->Header.AceFlags = AceFlags | InheritFlags;

    AuditAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AuditSid),
               &(AuditAce->SidStart),
               AuditSid
               );
}

DWORD
ScCreateStartEventSD(
    PSECURITY_DESCRIPTOR    *pEventSD
    )

/*++

Routine Description:

    This routine creates a security descriptor for the
    SC_INTERNAL_START_EVENT.  This function may be called from
    either the client or server side.

    NOTE:  it is up to the caller to free the memory for the
    security descriptor.

Arguments:

    pEventSD - Pointer to a location where the pointer to
        the newly created security descriptor can be placed.

Return Value:

    NO_ERROR - indicates success.

    all other values indicate failure.

--*/
{
    NTSTATUS                ntstatus;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;

    SID_IDENTIFIER_AUTHORITY    WorldSidAuth[1] = {
            SECURITY_WORLD_SID_AUTHORITY};
    SID_IDENTIFIER_AUTHORITY    LocalSystemSidAuth[1] = {
            SECURITY_NT_AUTHORITY};

    SC_ACE_DATA AceData[2] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
            SYNCHRONIZE,    &WorldSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
            GENERIC_ALL,    &LocalSystemSid}
        };

    if (WorldSid == NULL) {
        if (!AllocateAndInitializeSid(
                    WorldSidAuth,
                    1,
                    SECURITY_WORLD_RID,
                    0,0,0,0,0,0,0,
                    &WorldSid))  {

            SC_LOG1(ERROR, "AllocateAndInitWorldSid failed %d\n",GetLastError());
            return(GetLastError());
        }
    }

    if (LocalSystemSid == NULL) {
        if (!AllocateAndInitializeSid(
                    LocalSystemSidAuth,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0,0,0,0,0,0,0,
                    &LocalSystemSid)) {

            SC_LOG1(ERROR, "AllocateAndInitLocalSysSid failed %d\n",GetLastError());
            return(GetLastError());
        }
    }

    ntstatus = ScCreateAndSetSD(
                AceData,
                2,
                LocalSystemSid,
                LocalSystemSid,
                &SecurityDescriptor);

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR, "ScCreateAndSetSD failed %0x%lx\n",ntstatus);
        return(RtlNtStatusToDosError(ntstatus));
    }
    *pEventSD = SecurityDescriptor;
    return(NO_ERROR);
}

#if DBG

VOID
DumpAcl(
    IN PACL Acl
    )
/*++

Routine Description:

    This routine dumps via (DbgPrint) an Acl for debug purposes.  It is
    specialized to dump standard aces.

Arguments:

    Acl - Supplies the Acl to dump

Return Value:

    None

--*/
{
    ULONG i;
    PSTANDARD_ACE Ace;

    if (RtlSeDebugFlag & RTL_SE_DUMP_ACLS) {

        (VOID) DbgPrint("DumpAcl @%08lx\n", Acl);

        //
        //  Check if the Acl is null
        //

        if (Acl == NULL) {
            return;
        }

        //
        //  Dump the Acl header
        //

        (VOID) DbgPrint("    Revision: %02x", Acl->AclRevision);
        (VOID) DbgPrint("    Size: %04x", Acl->AclSize);
        (VOID) DbgPrint("    AceCount: %04x\n", Acl->AceCount);

        //
        //  Now for each Ace we want do dump it
        //

        for (i = 0, Ace = FirstAce(Acl);
             i < Acl->AceCount;
             i++, Ace = NextAce(Ace) ) {

            //
            //  print out the ace header
            //

            (VOID) DbgPrint(" AceHeader: %08lx ", *(PULONG)Ace);

            //
            //  special case on the standard ace types
            //

            if ((Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
                (Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) ||
                (Ace->Header.AceType == SYSTEM_AUDIT_ACE_TYPE) ||
                (Ace->Header.AceType == SYSTEM_ALARM_ACE_TYPE)) {

                //
                //  The following array is indexed by ace types and must
                //  follow the allowed, denied, audit, alarm seqeuence
                //

                static PCHAR AceTypes[] = { "Access Allowed",
                                            "Access Denied ",
                                            "System Audit  ",
                                            "System Alarm  "
                                          };

                (VOID) DbgPrint(AceTypes[Ace->Header.AceType]);
                (VOID) DbgPrint("\nAccess Mask: %08lx ", Ace->Mask);

            } else {

                (VOID) DbgPrint("Unknown Ace Type\n");

            }

            (VOID) DbgPrint("\n");

            (VOID) DbgPrint("AceSize = %d\n",Ace->Header.AceSize);
            (VOID) DbgPrint("Ace Flags = ");

            if (Ace->Header.AceFlags & OBJECT_INHERIT_ACE) {
                (VOID) DbgPrint("OBJECT_INHERIT_ACE\n");
                (VOID) DbgPrint("                   ");
            }
            if (Ace->Header.AceFlags & CONTAINER_INHERIT_ACE) {
                (VOID) DbgPrint("CONTAINER_INHERIT_ACE\n");
                (VOID) DbgPrint("                   ");
            }

            if (Ace->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE) {
                (VOID) DbgPrint("NO_PROPAGATE_INHERIT_ACE\n");
                (VOID) DbgPrint("                   ");
            }

            if (Ace->Header.AceFlags & INHERIT_ONLY_ACE) {
                (VOID) DbgPrint("INHERIT_ONLY_ACE\n");
                (VOID) DbgPrint("                   ");
            }

            if (Ace->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) {
                (VOID) DbgPrint("SUCCESSFUL_ACCESS_ACE_FLAG\n");
                (VOID) DbgPrint("            ");
            }

            if (Ace->Header.AceFlags & FAILED_ACCESS_ACE_FLAG) {
                (VOID) DbgPrint("FAILED_ACCESS_ACE_FLAG\n");
                (VOID) DbgPrint("            ");
            }

            (VOID) DbgPrint("\n");

        }
    }

}

#endif // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\path.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Path.c

Abstract:

    Contains image path functions:

        ScIsValidImagePath
        ScImagePathsMatch

Author:

    John Rogers (JohnRo) 10-Apr-1992

Environment:

    User Mode -Win32

Revision History:

    10-Apr-1992 JohnRo
        Created.
    20-May-1992 JohnRo
        Use CONST where possible.

--*/

#include <scpragma.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <scdebug.h>    // SC_ASSERT().
#include <sclib.h>      // My prototypes.
#include <valid.h>      // SERVICE_TYPE_INVALID().
#include <stdlib.h>      // _wcsicmp().
#include <winsvc.h>     // SERVICE_ equates.



BOOL
ScIsValidImagePath(
    IN  LPCWSTR ImagePathName,
    IN  DWORD ServiceType
    )
/*++

Routine Description:

    This function validates a given image path name.
    It makes sure the path name is consistent with the service type.
    For instance, a file name of .SYS is used for SERVICE_DRIVER only.

Arguments:

    ImagePathName - Supplies the image path name to be validated.

    ServiceType - Tells which kind of service the path name must be
        consistent with.  ServiceType must be valid.

Return Value:

    TRUE - The name is valid.

    FALSE - The name is invalid.

--*/
{
    if (ImagePathName == NULL) {
        return (FALSE);   // Not valid.
    } else if ( (*ImagePathName) == L'\0' ) {
        return (FALSE);   // Not valid.
    }

    SC_ASSERT( !SERVICE_TYPE_INVALID( ServiceType ) );

    return TRUE;

} // ScIsValidImagePath


BOOL
ScImagePathsMatch(
    IN  LPCWSTR OnePath,
    IN  LPCWSTR TheOtherPath
    )
{
    SC_ASSERT( OnePath != NULL );
    SC_ASSERT( TheOtherPath != NULL );

    SC_ASSERT( (*OnePath) != L'\0' );
    SC_ASSERT( (*TheOtherPath) != L'\0' );

    if ( _wcsicmp( OnePath, TheOtherPath ) == 0 ) {

        return (TRUE);  // They match.

    } else {

        return (FALSE);  // They don't match.

    }

} // ScImagePathsMatch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\convert.cxx ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    convert.c

Abstract:

    Contains functions for converting unicode and ansi strings.

Author:

    Dan Lafferty (danl)     04-Jan-1992

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

    04-Jan-1992     danl
        created
    20-May-1992 JohnRo
        Use CONST where possible.

--*/

#include <scpragma.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>    // LocalAlloc

#include <string.h>
#include <scdebug.h>    // SC_LOG
#include <sclib.h>      // My prototype.

BOOL
ScConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPCSTR  AnsiIn
    )

/*++

Routine Description:

    This function translates an AnsiString into a Unicode string.
    A new string buffer is created by this function.  If the call to
    this function is successful, the caller must take responsibility for
    the unicode string buffer that was allocated by this function.
    The allocated buffer should be free'd with a call to LocalFree.

    NOTE:  This function allocates memory for the Unicode String.

Arguments:

    AnsiIn - This is a pointer to an ansi string that is to be converted.

    UnicodeOut - This is a pointer to a location where the pointer to the
        unicode string is to be placed.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{

    NTSTATUS        ntStatus;
    DWORD           bufSize;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Allocate a buffer for the unicode string.
    //

    bufSize = ((DWORD) strlen(AnsiIn) + 1) * sizeof(WCHAR);

    *UnicodeOut = (LPWSTR) LocalAlloc(LMEM_ZEROINIT, bufSize);

    if (*UnicodeOut == NULL) {
        SC_LOG(ERROR,"ScConvertToUnicode:LocalAlloc Failure %ld\n",GetLastError());
        return(FALSE);
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString( &ansiString, AnsiIn);

    unicodeString.Buffer = *UnicodeOut;
    unicodeString.MaximumLength = (USHORT)bufSize;
    unicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlAnsiStringToUnicodeString (
                &unicodeString,     // Destination
                &ansiString,        // Source
                (BOOLEAN) FALSE);   // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {

        SC_LOG(ERROR,
               "ScConvertToUnicode:RtlAnsiStringToUnicodeString Failure %lx\n",
               ntStatus);

        LocalFree(*UnicodeOut);
        *UnicodeOut = NULL;
        return(FALSE);
    }

    return(TRUE);
}


BOOL
ScConvertToAnsi(
    OUT LPSTR    AnsiOut,
    IN  LPCWSTR  UnicodeIn
    )

/*++

Routine Description:

    This function translates a UnicodeString into an Ansi string.

    BEWARE!
        It is assumped that the buffer pointed to by AnsiOut is large
        enough to hold the Unicode String.  Check sizes first.

    If it is desired, UnicodeIn and AnsiIn can point to the same
    location.  Since the ansi string will always be smaller than the
    unicode string, translation can take place in the same buffer.

Arguments:

    UnicodeIn - This is a pointer to a unicode that is to be converted.

    AnsiOut - This is a pointer to a buffer that will contain the
        ansi string on return from this function call.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.

--*/
{

    NTSTATUS        ntStatus;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Initialize the string structures
    //
    RtlInitUnicodeString( &unicodeString, UnicodeIn);

    ansiString.Buffer = AnsiOut;
    ansiString.MaximumLength = unicodeString.MaximumLength;
    ansiString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlUnicodeStringToAnsiString (
                &ansiString,        // Destination
                &unicodeString,     // Source
                (BOOLEAN) FALSE);   // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {


    SC_LOG(ERROR,"ScConvertToAnsi:RtlUnicodeStrintToAnsiString Failure %lx\n",
        ntStatus);

        return(FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\sccrypt.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    sccrypt.c

Abstract:

    This module provides support routines to encrypt and decrypt
    a password.

Author:

    Rita Wong      (ritaw)  27-Apr-1992

Environment:

    Contains NT specific code.

Revision History:

--*/

#include <scpragma.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <crypt.h>

#include <windef.h>     // DWORD (needed by scdebug.h).
#include <winerror.h>   // NO_ERROR
#include <winbase.h>    // LocalAlloc

#include <stdlib.h>

#include <scdebug.h>    // STATIC.
#include <svcctl.h>     // SC_RPC_HANDLE
#include <sccrypt.h>    // Exported function prototypes


DWORD
ScEncryptPassword(
    IN  SC_RPC_HANDLE ContextHandle,
    IN  LPWSTR Password,
    OUT LPBYTE *EncryptedPassword,
    OUT LPDWORD EncryptedPasswordSize
    )
/*++

Routine Description:

    This function encrypts a user specified clear text password with
    the user session key gotten from the RPC context handle.

    This is called by the RPC client.

Arguments:

    ContextHandle - Supplies the RPC context handle.

    Password - Supplies the user specified password.

    EncryptedPassword - Receives a pointer to memory which contains
        the encrypted password.  This memory must be freed with LocalFree
        when done.

    EncryptedPasswordSize - Receives the number of bytes of encrypted
        password returned.

Return Value:

    NO_ERROR - Successful encryption.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate the EncryptedPassword
        buffer.

    ERROR_GEN_FAILURE - Any other failures encountered by this function.

--*/
{
    NTSTATUS ntstatus;
    USER_SESSION_KEY SessionKey;

    CLEAR_DATA ClearTextPW;
    DATA_KEY DataKey;
    CYPHER_DATA EncryptPW;


    ntstatus = RtlGetUserSessionKeyClient(
                   (PVOID) ContextHandle,
                   &SessionKey
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SCC_LOG1(ERROR,
                 "ScEncryptPassword: RtlGetUserSessionKeyClient returned "
                 FORMAT_NTSTATUS "\n", ntstatus);
        return ERROR_GEN_FAILURE;
    }

    //
    // Encryption includes the NULL terminator.
    //
    ClearTextPW.Length = ((DWORD) wcslen(Password) + 1) * sizeof(WCHAR);
    ClearTextPW.MaximumLength = ClearTextPW.Length;
    ClearTextPW.Buffer = (PVOID) Password;

    DataKey.Length = USER_SESSION_KEY_LENGTH;
    DataKey.MaximumLength = USER_SESSION_KEY_LENGTH;
    DataKey.Buffer = (PVOID) &SessionKey;

    EncryptPW.Length = 0;
    EncryptPW.MaximumLength = 0;
    EncryptPW.Buffer = NULL;

    //
    // Call RtlEncryptData with 0 length so that it will return the
    // required length.
    //
    ntstatus = RtlEncryptData(
                   &ClearTextPW,
                   &DataKey,
                   &EncryptPW
                   );

    if (ntstatus != STATUS_BUFFER_TOO_SMALL) {
        SCC_LOG1(ERROR,
                 "ScEncryptPassword: RtlEncryptData returned "
                 FORMAT_NTSTATUS "\n", ntstatus);
        return ERROR_GEN_FAILURE;
    }

    if ((EncryptPW.Buffer = (PVOID) LocalAlloc(
                                        0,
                                        EncryptPW.Length
                                        )) == NULL) {
        SCC_LOG1(ERROR,
                 "ScEncryptPassword: LocalAlloc failed "
                 FORMAT_DWORD "\n", GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    EncryptPW.MaximumLength = EncryptPW.Length;

    ntstatus = RtlEncryptData(
                   &ClearTextPW,
                   &DataKey,
                   &EncryptPW
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SCC_LOG1(ERROR,
                 "ScEncryptPassword: RtlEncryptData returned "
                 FORMAT_NTSTATUS "\n", ntstatus);

        LocalFree(EncryptPW.Buffer);
        return ERROR_GEN_FAILURE;
    }

    *EncryptedPassword = (LPBYTE) EncryptPW.Buffer;
    *EncryptedPasswordSize = EncryptPW.Length;

    return NO_ERROR;
}


DWORD
ScDecryptPassword(
    IN  SC_RPC_HANDLE ContextHandle,
    IN  LPBYTE EncryptedPassword,
    IN  DWORD EncryptedPasswordSize,
    OUT LPWSTR *Password
    )
/*++

Routine Description:

    This function decrypts a given encrypted password back to clear
    text with the user session key gotten from the RPC context handle.

    This is called by the RPC server.

Arguments:

    ContextHandle - Supplies the RPC context handle.


    EncryptedPassword - Supplies a buffer which contains the encrypted
        password.

    EncryptedPasswordSize - Supplies the number of bytes in
        EncryptedPassword.

    Password - Receives a pointer to the memory which contains the
        clear text password.  This memory must be freed with LocalFree
        when done.

Return Value:

    NO_ERROR - Successful encryption.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate the Password buffer.

    ERROR_GEN_FAILURE - Any other failures encountered by this function.

--*/
{
    NTSTATUS ntstatus;
    USER_SESSION_KEY SessionKey;

    CYPHER_DATA EncryptPW;
    DATA_KEY DataKey;
    CLEAR_DATA ClearTextPW;


    ntstatus = RtlGetUserSessionKeyServer(
                   (PVOID) ContextHandle,
                   &SessionKey
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR,
                 "ScDecryptPassword: RtlGetUserSessionKeyClient returned "
                 FORMAT_NTSTATUS "\n", ntstatus);
        return ERROR_GEN_FAILURE;
    }

    EncryptPW.Length = EncryptedPasswordSize;
    EncryptPW.MaximumLength = EncryptedPasswordSize;
    EncryptPW.Buffer = (PVOID) EncryptedPassword;

    DataKey.Length = USER_SESSION_KEY_LENGTH;
    DataKey.MaximumLength = USER_SESSION_KEY_LENGTH;
    DataKey.Buffer = (PVOID) &SessionKey;

    ClearTextPW.Length = 0;
    ClearTextPW.MaximumLength = 0;
    ClearTextPW.Buffer = NULL;

    //
    // Call RtlDecryptData with 0 length so that it will return the
    // required length.
    //
    ntstatus = RtlDecryptData(
                   &EncryptPW,
                   &DataKey,
                   &ClearTextPW
                   );

    if (ntstatus != STATUS_BUFFER_TOO_SMALL) {

        if (ntstatus == STATUS_SUCCESS && ClearTextPW.Length == 0) {
            //
            // Assume empty password
            //
            *Password = NULL;
            return NO_ERROR;
        }

        SC_LOG1(ERROR,
                 "ScDecryptPassword: RtlDecryptData returned "
                 FORMAT_NTSTATUS "\n", ntstatus);
        return ERROR_GEN_FAILURE;
    }

    //
    // Allocate exact size needed because NULL terminator is included in
    // the encrypted string.
    //
    if ((ClearTextPW.Buffer = (PVOID) LocalAlloc(
                                        LMEM_ZEROINIT,
                                        ClearTextPW.Length
                                        )) == NULL) {
        SC_LOG1(ERROR,
                 "ScDecryptPassword: LocalAlloc failed "
                 FORMAT_DWORD "\n", GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ClearTextPW.MaximumLength = ClearTextPW.Length;

    ntstatus = RtlDecryptData(
                   &EncryptPW,
                   &DataKey,
                   &ClearTextPW
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR,
                 "ScDecryptPassword: RtlDecryptData returned "
                 FORMAT_NTSTATUS "\n", ntstatus);
        return ERROR_GEN_FAILURE;
    }

    *Password = (LPWSTR) ClearTextPW.Buffer;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\lib\valid.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    valid.c

Abstract:

    Contains validation routines for service controller parameters.

Author:

    Dan Lafferty (danl) 29-Mar-1992

Environment:

    User Mode - Win32

Revision History:

    29-Mar-1992 danl
        Created
    10-Apr-1992 JohnRo
        Include <valid.h> so compiler checks prototypes.

--*/

//
// INCLUDES
//
#include <nt.h>
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h when ntrtl is present
#include <windows.h>    // CRITICAL_SECTION

#include <scdebug.h>    // SC_LOG
#include <winsvc.h>     // SERVICE_STATUS
#include <valid.h>      // My prototypes.




BOOL
ScCurrentStateInvalid(
    DWORD   dwCurrentState
    )
/*++

Routine Description:

    This function returns TRUE if the CurrentState is invalid.
    Otherwise FALSE is returned.

Arguments:

    dwCurrentState - This is the ServiceState that is being validiated.

Return Value:

    TRUE - The CurrentState is invalid.

    FALSE - The CurrentState is valid.

Note:


--*/
{
    if ((dwCurrentState == SERVICE_STOPPED)             ||
        (dwCurrentState == SERVICE_START_PENDING)       ||
        (dwCurrentState == SERVICE_STOP_PENDING)        ||
        (dwCurrentState == SERVICE_RUNNING)             ||
        (dwCurrentState == SERVICE_CONTINUE_PENDING)    ||
        (dwCurrentState == SERVICE_PAUSE_PENDING)       ||
        (dwCurrentState == SERVICE_PAUSED )) {

        return(FALSE);
    }
    return(TRUE);
}


DWORD
ScValidateMultiSZ(
    LPCWSTR lpStrings,
    DWORD   cbStrings
    )

/*++

Routine Description:

    This function takes a MULTI_SZ value read in from the registry or
    passed in via RPC and validates it.

Arguments:



Return Value:



--*/

{
    DWORD  dwLastChar;

    //
    // Make sure the MULTI_SZ is well-formed. As long as it is properly
    // double NULL terminated, things should be ok.
    //
    if ((cbStrings % 2) ||
        (cbStrings < sizeof(WCHAR)*2)) {

        //
        // There's an odd number of bytes, this can't be well-formed
        //
        return ERROR_INVALID_PARAMETER;
    }

    dwLastChar = (cbStrings / sizeof(WCHAR)) - 1;

    if ((lpStrings[dwLastChar]     != L'\0') ||
        (lpStrings[dwLastChar - 1] != L'\0')) {

        //
        // The buffer is not double-NUL terminated
        //
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\sc\sc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    SC.C

Abstract:

    Test Routines for the Service Controller.

Author:

    Dan Lafferty    (danl)  08-May-1991

Environment:

    User Mode - Win32

Revision History:

    09-Feb-1992     danl
        Modified to work with new service controller.
    08-May-1991     danl
        created

--*/

//
// INCLUDES
//
#include <scpragma.h>

#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h


#include <stdlib.h>     // atoi
#include <stdio.h>      // printf
#include <conio.h>      // getche
#include <string.h>     // strcmp
#include <windows.h>    // win32 typedefs
#include <tstr.h>       // Unicode
#include <tchar.h>      // Unicode from CRT
#include <debugfmt.h>   // FORMAT_LPTSTR

#include <winsvc.h>     // Service Control Manager API.
#include <winsvcp.h>    // Internal Service Control Manager API

#include <sddl.h>       // Security descriptor <--> string APIs


//
// CONSTANTS
//

#define  DEFAULT_ENUM_BUFFER_SIZE    4096


//
// TYPE DEFINITIONS
//

typedef union
{
    LPSERVICE_STATUS         Regular;
    LPSERVICE_STATUS_PROCESS Ex;
}
STATUS_UNION, *LPSTATUS_UNION;


WCHAR   MessageBuffer[ 1024 ];


//
// FUNCTION PROTOTYPES
//

LPWSTR
GetErrorText(
    IN  DWORD Error
    );

VOID
DisplayStatus (
    IN  LPTSTR              ServiceName,
    IN  LPTSTR              DisplayName,
    IN  LPSTATUS_UNION      ServiceStatus,
    IN  BOOL                fIsStatusOld
    );

VOID
Usage(
    VOID
    );

VOID
ConfigUsage(
    VOID
    );

VOID
ChangeFailureUsage(
    VOID
    );

DWORD
SendControlToService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  DWORD       control,
    OUT LPSC_HANDLE lphService
    );

DWORD
SendConfigToService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *Argv,
    IN  DWORD       argc,
    OUT LPSC_HANDLE lphService
    );

DWORD
ChangeServiceDescription(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      pNewDescription,
    OUT LPSC_HANDLE lphService
    );

DWORD
ChangeServiceFailure(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *argv,
    IN  DWORD       dwArgCount,
    OUT LPSC_HANDLE lphService
    );

DWORD
GetServiceConfig(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufferSize,
    OUT LPSC_HANDLE lphService
    );

DWORD
GetConfigInfo(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufferSize,
    OUT LPSC_HANDLE lphService,
    IN  DWORD       dwInfoLevel
    );

DWORD
GetServiceLockStatus(
    IN  SC_HANDLE   hScManager,
    IN  DWORD       bufferSize
    );

VOID
EnumDepend(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufSize
    );

VOID
ShowSecurity(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName
    );

VOID
SetSecurity(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  LPTSTR      lpServiceSD
    );

VOID
LockServiceActiveDatabase(
    IN SC_HANDLE    hScManager
    );

DWORD
DoCreateService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *argv,
    IN  DWORD       argc
    );

VOID
CreateUsage(VOID);

VOID
QueryUsage(VOID);


//
// MACROS
//

#define OPEN_MANAGER(dwAccess)                                               \
                                                                             \
                        hScManager = OpenSCManager(pServerName,              \
                                                   NULL,                     \
                                                   dwAccess);                \
                                                                             \
                        if (hScManager == NULL) {                            \
                            status = GetLastError();                         \
                            printf("[SC] OpenSCManager FAILED %d:\n\n%ws\n", \
                                   status,                                   \
                                   GetErrorText(status));                    \
                                                                             \
                            goto CleanExit;                                  \
                        }                                                    \



/****************************************************************************/
int __cdecl
wmain (
    DWORD       argc,
    LPWSTR      argv[]
    )

/*++

Routine Description:

    Allows manual testing of the Service Controller by typing commands on
    the command line.


Arguments:



Return Value:



--*/

{
    DWORD                            status;
    LPTSTR                           *argPtr;
    LPBYTE                           buffer       = NULL;
    LPENUM_SERVICE_STATUS            enumBuffer   = NULL;
    LPENUM_SERVICE_STATUS_PROCESS    enumBufferEx = NULL;
    STATUS_UNION                     statusBuffer;
    SC_HANDLE                        hScManager = NULL;
    SC_HANDLE                        hService   = NULL;

    DWORD           entriesRead;
    DWORD           type;
    DWORD           state;
    DWORD           resumeIndex;
    DWORD           bufSize;
    DWORD           bytesNeeded;
    DWORD           i;
    LPTSTR          pServiceName = NULL;
    LPTSTR          pServerName;
    LPTSTR          pGroupName;
    DWORD           itIsEnum;
    BOOL            fIsQueryOld;
    DWORD           argIndex;
    DWORD           userControl;
    LPTSTR          *FixArgv;
    BOOL            bTestError=FALSE;

    if (argc < 2)
    {
        Usage();
        return 1;
    }

    FixArgv = (LPWSTR *) argv;

    //
    // Open a handle to the service controller.
    //
    //  I need to know the server name.  Do this by allowing
    //  a check of FixArgv[1] to see if it is of the form \\name.  If it
    //  is, make all further work be relative to argIndex.
    //

    pServerName = NULL;
    argIndex = 1;

    if (STRNCMP (FixArgv[1], TEXT("\\\\"), 2) == 0) {

        if (argc == 2) {
            Usage();
            return 1;
        }

        pServerName = FixArgv[1];
        argIndex++;
    }


    //------------------------------
    // QUERY & ENUM SERVICE STATUS
    //------------------------------

    fIsQueryOld = !STRICMP(FixArgv[argIndex], TEXT("query"));

    if (fIsQueryOld ||
        STRICMP (FixArgv[argIndex], TEXT("queryex") ) == 0 ) {

        //
        // Set up the defaults
        //
        resumeIndex = 0;
        state       = SERVICE_ACTIVE;
        type        = 0x0;
        bufSize     = DEFAULT_ENUM_BUFFER_SIZE;
        itIsEnum    = TRUE;
        pGroupName  = NULL;

        //
        // Look for Enum or Query Options.
        //
        i = argIndex + 1;
        while (argc > i) {

            if (STRCMP (FixArgv[i], TEXT("ri=")) == 0) {
                i++;
                if (argc > i) {
                    resumeIndex = _ttol(FixArgv[i]);
                }
            }

            else if (STRCMP (FixArgv[i], TEXT("type=")) == 0) {
                i++;
                if (argc > i) {
                    if (STRCMP (FixArgv[i], TEXT("driver")) == 0) {
                        type |= SERVICE_DRIVER;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("service")) == 0) {
                        type |= SERVICE_WIN32;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("all")) == 0) {
                        type |= SERVICE_TYPE_ALL;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("interact")) == 0) {
                        type |= SERVICE_INTERACTIVE_PROCESS;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("error")) == 0) {
                        type |= 0xffffffff;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("none")) == 0) {
                        type = 0x0;
                        bTestError = TRUE;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("kernel")) == 0) {
                        type |= SERVICE_KERNEL_DRIVER;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("filesys")) == 0) {
                        type |= SERVICE_FILE_SYSTEM_DRIVER;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("adapter")) == 0) {
                        type |= SERVICE_ADAPTER;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("own")) == 0) {
                        type |= SERVICE_WIN32_OWN_PROCESS;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("share")) == 0) {
                        type |= SERVICE_WIN32_SHARE_PROCESS;
                    }
                    else {
                        printf("\nERROR following \"type=\"!\n"
                               "Must be \"driver\" or \"service\"\n");
                        goto CleanExit;
                    }
                }
            }
            else if (STRCMP (FixArgv[i], TEXT("state=")) == 0) {
                i++;
                if (argc > i) {
                    if (STRCMP (FixArgv[i], TEXT("inactive")) == 0) {
                        state = SERVICE_INACTIVE;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("all")) == 0) {
                        state = SERVICE_STATE_ALL;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("error")) == 0) {
                        state = 0xffffffff;
                    }
                    else {
                        printf("\nERROR following \"state=\"\n");
                        printf("\nERROR following \"state=\"!\n"
                               "Must be \"inactive\" or \"all\"\n");

                        goto CleanExit;
                    }

                }
            }
            else if (STRCMP (FixArgv[i], TEXT("group=")) == 0) {
                i++;
                if (argc > i) {
                    pGroupName = FixArgv[i];
                }
            }
            else if (STRCMP (FixArgv[i], TEXT("bufsize=")) == 0) {
                i++;
                if (argc > i) {
                    bufSize = _ttol(FixArgv[i]);
                }
            }
            else {
                //
                // The string was not a valid option.
                //
                //
                // If this is still the 2nd argument, then it could be
                // the service name.  In this case, we will do a
                // QueryServiceStatus.  But first we want to go back and
                // see if there is a buffer size constraint to be placed
                // on the Query.
                //
                if (i == ( argIndex+1 )) {
                    pServiceName = FixArgv[i];
                    itIsEnum = FALSE;
                    i++;
                }
                else {
                    printf("\nERROR, Invalid Option\n");
                    Usage();
                    goto CleanExit;
                }
            }

            //
            // Increment to the next command line parameter.
            //
            i++;

        } // End While

        //
        // Allocate a buffer to receive the data.
        //
        if (bufSize != 0) {
            buffer = (LPBYTE)LocalAlloc(LMEM_FIXED,(UINT)bufSize);

            if (buffer == NULL) {

                status = GetLastError();
                printf("[SC] EnumQueryServicesStatus: LocalAlloc FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));

                goto CleanExit;
            }
        }
        else {
            buffer = NULL;
        }

        if ( itIsEnum ) {

            //////////////////////////
            //                      //
            // EnumServiceStatus    //
            //                      //
            //////////////////////////

            OPEN_MANAGER(SC_MANAGER_ENUMERATE_SERVICE);

            if ((type == 0x0) && (!bTestError)) {
                type = SERVICE_WIN32;
            }

            do {

                status = NO_ERROR;

                //
                // Enumerate the ServiceStatus
                //

                if (fIsQueryOld) {

                    enumBuffer = (LPENUM_SERVICE_STATUS)buffer;

                    if (pGroupName == NULL) {

                        if (!EnumServicesStatus (
                                    hScManager,
                                    type,
                                    state,
                                    enumBuffer,
                                    bufSize,
                                    &bytesNeeded,
                                    &entriesRead,
                                    &resumeIndex)) {

                            status = GetLastError();
                        }
                    }
                    else {

                        if (!EnumServiceGroupW (
                                    hScManager,
                                    type,
                                    state,
                                    enumBuffer,
                                    bufSize,
                                    &bytesNeeded,
                                    &entriesRead,
                                    &resumeIndex,
                                    pGroupName)) {

                            status = GetLastError();
                        }
                    }
                }
                else {

                    //
                    // "queryex" used -- call the extended enum
                    //

                    enumBufferEx = (LPENUM_SERVICE_STATUS_PROCESS) buffer;

                    if (!EnumServicesStatusEx (
                                hScManager,
                                SC_ENUM_PROCESS_INFO,
                                type,
                                state,
                                (LPBYTE) enumBufferEx,
                                bufSize,
                                &bytesNeeded,
                                &entriesRead,
                                &resumeIndex,
                                pGroupName)) {

                        status = GetLastError();
                    }
                }

                if ( (status == NO_ERROR)    ||
                     (status == ERROR_MORE_DATA) ){

                    for (i = 0; i < entriesRead; i++) {

                        if (fIsQueryOld) {

                            statusBuffer.Regular = &(enumBuffer->ServiceStatus);

                            DisplayStatus(
                                enumBuffer->lpServiceName,
                                enumBuffer->lpDisplayName,
                                &statusBuffer,
                                TRUE);

                            enumBuffer++;
                        }
                        else {
                            
                            statusBuffer.Ex = &(enumBufferEx->ServiceStatusProcess);

                            DisplayStatus(
                                enumBufferEx->lpServiceName,
                                enumBufferEx->lpDisplayName,
                                &statusBuffer,
                                FALSE);

                            enumBufferEx++;
                        }
                    }
                }
                else {
                    printf("[SC] EnumServicesStatus%s FAILED %d:\n\n%ws\n",
                           fIsQueryOld ? "" : "Ex",
                           status,
                           GetErrorText(status));
                }
            }
            while (status == ERROR_MORE_DATA && entriesRead != 0);

            if (status == ERROR_MORE_DATA){
                printf("Enum: more data, need %d bytes start resume at index %d\n",
                       bytesNeeded,
                       resumeIndex);
            }
        }
        else {

            //////////////////////////
            //                      //
            // QueryServiceStatus   //
            //                      //
            //////////////////////////

            if (pGroupName != NULL) {
                printf("ERROR: cannot specify a service name when enumerating a group\n");

                goto CleanExit;
            }

#ifdef TIMING_TEST
            DWORD       TickCount1;
            DWORD       TickCount2;

            TickCount1 = GetTickCount();
#endif // TIMING_TEST
  
            OPEN_MANAGER(GENERIC_READ);

            //
            // Open a handle to the service
            //

            hService = OpenService(
                        hScManager,
                        pServiceName,
                        SERVICE_QUERY_STATUS);

            if (hService == NULL) {

                status = GetLastError();
                printf("[SC] EnumQueryServicesStatus:OpenService FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));

                goto CleanExit;
            }

            //
            // Query the Service Status
            //
            status = NO_ERROR;

            if (fIsQueryOld) {
                statusBuffer.Regular = (LPSERVICE_STATUS)buffer;

                if (!QueryServiceStatus (
                        hService,
                        statusBuffer.Regular)) {

                    status = GetLastError();

                }
            }
            else {

                DWORD dwBytesNeeded;

                statusBuffer.Ex = (LPSERVICE_STATUS_PROCESS)buffer;

                if (!QueryServiceStatusEx (
                        hService,
                        SC_STATUS_PROCESS_INFO,
                        (LPBYTE)statusBuffer.Ex,
                        bufSize,
                        &dwBytesNeeded)) {

                    status = GetLastError();
                }
            }

#ifdef TIMING_TEST
            TickCount2 = GetTickCount();
            printf("\n[SC_TIMING] Time for QueryService = %d\n",
                   TickCount2 - TickCount1);
#endif // TIMING_TEST

            if (status == NO_ERROR) {
                DisplayStatus(pServiceName, NULL, &statusBuffer, fIsQueryOld);
            }
            else {
                printf("[SC] QueryServiceStatus%s FAILED %d:\n\n%ws\n",
                       fIsQueryOld ? "" : "Ex",
                       status,
                       GetErrorText(status));
            }
        }
    }

    else if (argc < (argIndex + 1)) {
        printf("[SC] ERROR: a service name is required\n");
        Usage();
        goto CleanExit;
    }

    //-----------------------
    // START SERVICE
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("start")) == 0) {

#ifdef TIMING_TEST
            DWORD       TickCount1;
            DWORD       TickCount2;

            TickCount1 = GetTickCount();
#endif // TIMING_TEST

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tStarts a service running.\n");
            printf("USAGE:\n");
            printf("\tsc <server> start [service name] <arg1> <arg2> ...\n");
            goto CleanExit;
        }
        pServiceName = FixArgv[argIndex + 1];
        //
        // Open a handle to the service.
        //

        OPEN_MANAGER(GENERIC_READ);

        hService = OpenService(
                    hScManager,
                    pServiceName,
                    SERVICE_START | SERVICE_QUERY_STATUS);

        if (hService == NULL) {

            status = GetLastError();
            printf("[SC] StartService: OpenService FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));

            goto CleanExit;
        }

        argPtr = NULL;
        if (argc > argIndex + 2) {
            argPtr = (LPTSTR *)&FixArgv[argIndex + 2];
        }

        //
        // Start the service.
        //
        status = NO_ERROR;

        if (!StartService (
                hService,
                argc-(argIndex+2),
                argPtr
                )) {

            status = GetLastError();
            printf("[SC] StartService FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));

        } else {

            DWORD                     dwBytesNeeded;
            SERVICE_STATUS_PROCESS    serviceStatusProcess;

#ifdef TIMING_TEST
            TickCount2 = GetTickCount();
            printf("\n[SC_TIMING] Time for StartService = %d\n",
                   TickCount2 - TickCount1);
#endif // TIMING_TEST
            status = NO_ERROR;

            //
            // Get the service status since StartService does not return it
            //
            if (!QueryServiceStatusEx(hService,
                                      SC_STATUS_PROCESS_INFO,
                                      (LPBYTE) &serviceStatusProcess,
                                      sizeof(SERVICE_STATUS_PROCESS),
                                      &dwBytesNeeded))
            {
                status = GetLastError();
            }

            statusBuffer.Ex = &serviceStatusProcess;

            if (status == NO_ERROR)
            {
                DisplayStatus(pServiceName, NULL, &statusBuffer, FALSE);
            }
            else
            {
                printf("[SC] StartService: QueryServiceStatusEx FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));
            }
        }
    }

    //-----------------------
    // PAUSE SERVICE
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("pause")) == 0) {

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tSends a PAUSE control request to a service.\n");
            printf("USAGE:\n");
            printf("\tsc <server> pause [service name]\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],       // pointer to service name
            SERVICE_CONTROL_PAUSE,  // the control to send
            &hService);             // the handle to the service
    }

    //-----------------------
    // INTERROGATE SERVICE
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("interrogate")) == 0) {

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tSends an INTERROGATE control request to a service.\n");
            printf("USAGE:\n");
            printf("\tsc <server> interrogate [service name]\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],       // pointer to service name
            SERVICE_CONTROL_INTERROGATE, // the control to send
            &hService);             // the handle to the service
    }

    //-----------------------
    // CONTROL SERVICE
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("control")) == 0) {

        if (argc < (argIndex + 3)) {
            printf("DESCRIPTION:\n");
            printf("\tSends a CONTROL code to a service.\n");
            printf("USAGE:\n");
            printf("\tsc <server> control [service name] <value>\n"
                   "\t    <value> = user-defined control code\n"
                   "\t    <value> = <paramchange|\n"
                   "\t               netbindadd|netbindremove|\n"
                   "\t               netbindenable|netbinddisable>\n\n"
                   "See also sc stop, sc pause, etc.\n");
            goto CleanExit;
        }

        userControl = _ttol(FixArgv[argIndex+2]);

        if (userControl == 0) {
            if (STRICMP (FixArgv[argIndex+2], TEXT("paramchange")) == 0) {
                userControl = SERVICE_CONTROL_PARAMCHANGE;
            }
            else if (STRICMP (FixArgv[argIndex+2], TEXT("netbindadd")) == 0) {
                userControl = SERVICE_CONTROL_NETBINDADD;
            }
            else if (STRICMP (FixArgv[argIndex+2], TEXT("netbindremove")) == 0) {
                userControl = SERVICE_CONTROL_NETBINDREMOVE;
            }
            else if (STRICMP (FixArgv[argIndex+2], TEXT("netbindenable")) == 0) {
                userControl = SERVICE_CONTROL_NETBINDENABLE;
            }
            else if (STRICMP (FixArgv[argIndex+2], TEXT("netbinddisable")) == 0) {
                userControl = SERVICE_CONTROL_NETBINDDISABLE;
            }
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            userControl,            // the control to send
            &hService);             // the handle to the service
    }

    //-----------------------
    // CONTINUE SERVICE
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("continue")) == 0) {

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tSends a CONTINUE control request to a service.\n");
            printf("USAGE:\n");
            printf("\tsc <server> continue [service name]\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,                 // handle to service controller
            FixArgv[argIndex+1],        // pointer to service name
            SERVICE_CONTROL_CONTINUE,   // the control to send
            &hService);                 // the handle to the service
    }

    //-----------------------
    // STOP SERVICE
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("stop")) == 0) {

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tSends a STOP control request to a service.\n");
            printf("USAGE:\n");
            printf("\tsc <server> stop [service name]\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],       // pointer to service name
            SERVICE_CONTROL_STOP,   // the control to send
            &hService);             // the handle to the service
    }

    //---------------
    // CHANGE CONFIG 
    //---------------
    else if (STRICMP (FixArgv[argIndex], TEXT("config")) == 0) {

        if (argc < (argIndex + 3)) {
            ConfigUsage();
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendConfigToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            &FixArgv[argIndex+2],   // the argument switches
            argc-(argIndex+2),      // the switch count.
            &hService);             // the handle to the service
    }

    //-----------------------------
    // CHANGE SERVICE DESCRIPTION
    //-----------------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("description")) == 0) {

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tSets the description string for a service.\n");
            printf("USAGE:\n");
            printf("\tsc <server> description [service name] [description]\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        ChangeServiceDescription(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            FixArgv[argIndex+2],    // the description (rest of argv)
            &hService);             // the handle to the service
    }

    //-----------------------------
    // CHANGE FAILURE ACTIONS
    //-----------------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("failure")) == 0) {

        if (argc < (argIndex + 2)) {
            ChangeFailureUsage();
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        ChangeServiceFailure(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            &FixArgv[argIndex+2],   // the argument switches
            argc-(argIndex+2),      // the switch count
            &hService);             // the handle to the service
    }


    //-----------------------
    // QUERY SERVICE CONFIG
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("qc")) == 0) {

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tQueries the configuration information for a service.\n");
            printf("USAGE:\n");
            printf("\tsc <server> qc [service name] <bufferSize>\n");
            goto CleanExit;
        }

        bufSize = 500;
        if (argc > (argIndex + 2) ) {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        OPEN_MANAGER(GENERIC_READ);

        GetServiceConfig(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            bufSize,                // the size of the buffer to use
            &hService);             // the handle to the service
    }

    //-------------------
    // QUERY DESCRIPTION 
    //-------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("qdescription")) == 0) {

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tRetrieves the description string of a service.\n");
            printf("USAGE:\n");
            printf("\tsc <server> qdescription [service name] <bufferSize>\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;
        if (argc > (argIndex + 2) ) {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        GetConfigInfo(
            hScManager,                     // handle to service controller
            FixArgv[argIndex + 1],          // pointer to service name
            bufSize,                        // the size of the buffer to use
            &hService,                      // the handle to the service
            SERVICE_CONFIG_DESCRIPTION);    // which config data is requested
    }

    //-----------------------
    // QUERY FAILURE ACTIONS
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("qfailure")) == 0) {

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tRetrieves the actions performed on service failure.\n");
            printf("USAGE:\n");
            printf("\tsc <server> qfailure [service name] <bufferSize>\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;
        if (argc > (argIndex + 2) ) {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        GetConfigInfo(
            hScManager,                         // handle to service controller
            FixArgv[argIndex + 1],              // pointer to service name
            bufSize,                            // the size of the buffer to use
            &hService,                          // the handle to the service
            SERVICE_CONFIG_FAILURE_ACTIONS);    // which config data is requested
    }

    //--------------------------
    // QUERY SERVICE LOCK STATUS
    //--------------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("querylock")) == 0) {

        if (argc < (argIndex + 1)) {
            printf("DESCRIPTION:\n");
            printf("\tQueries the Lock Status for a SC Manager Database.\n");
            printf("USAGE:\n");
            printf("\tsc <server> querylock <bufferSize>\n");
            goto CleanExit;
        }

        OPEN_MANAGER(SC_MANAGER_QUERY_LOCK_STATUS);

        bufSize = 500;
        if (argc > (argIndex + 1) ) {
            bufSize = _ttol(FixArgv[argIndex+1]);
        }

        GetServiceLockStatus(
            hScManager,             // handle to service controller
            bufSize);               // the size of the buffer to use
    }


    //----------------------
    // LOCK SERVICE DATABASE
    //----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("lock")) == 0) {

        OPEN_MANAGER(SC_MANAGER_LOCK);

        LockServiceActiveDatabase(hScManager);
    }

    //--------------------------
    // OPEN (Close) SERVICE
    //--------------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("open")) == 0) {

        if (argc < (argIndex + 1)) {
            printf("DESCRIPTION:\n");
            printf("\tOpens and Closes a handle to a service.\n");
            printf("USAGE:\n");
            printf("\tsc <server> open <servicename>\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        hService = OpenService(
                    hScManager,
                    FixArgv[argIndex+1],
                    SERVICE_START | SERVICE_QUERY_STATUS);

        if (hService == NULL) {

            status = GetLastError();
            printf("[SC] OpenService FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));

            goto CleanExit;
        }

        if (!CloseServiceHandle(hService)) {

            status = GetLastError();
            printf("[SC] CloseServiceHandle FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));
        }


    }
    //-----------------------
    // DELETE SERVICE
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("delete")) == 0) {

        if (argc < (argIndex + 2)) {
            printf("DESCRIPTION:\n");
            printf("\tDeletes a service entry from the registry.\n"
                   "\tIf the service is running, or another process has an\n"
                   "\topen handle to the service, the service is simply marked\n"
                   "\tfor deletion.\n");
            printf("USAGE:\n");
            printf("\tsc <server> delete [service name]\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        //
        // Open a handle to the service.
        //

        hService = OpenService(
                        hScManager,
                        FixArgv[argIndex+1],
                        DELETE);

        if (hService == NULL) {

            status = GetLastError();
            printf("[SC] OpenService FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));
            return 0;
        }

        //
        // Delete the service
        //
        if (!DeleteService(hService)) {
            status = GetLastError();
            printf("[SC] DeleteService FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));
        }
        else {
            printf("[SC] DeleteService SUCCESS\n");
        }
    }

    //-----------------------
    // CREATE SERVICE
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("create")) == 0) {

        if (argc < (argIndex + 3)) {
            CreateUsage();
            goto CleanExit;
        }

        OPEN_MANAGER(SC_MANAGER_CREATE_SERVICE);

        DoCreateService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            &FixArgv[argIndex+2],   // the argument switches.
            argc-(argIndex+2));     // the switch count.
    }
    //-----------------------
    // NOTIFY BOOT CONFIG
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("boot")) == 0) {

        BOOL    fOK = TRUE;

        if (argc >= (argIndex + 2)) {

            if (STRICMP (FixArgv[argIndex+1], TEXT("ok")) == 0) {

                if (!NotifyBootConfigStatus(TRUE)) {

                    status = GetLastError();
                    printf("NotifyBootConfigStatus FAILED %d:\n\n%ws\n",
                           status,
                           GetErrorText(status));
                }
            }
            else if (STRICMP (FixArgv[argIndex+1], TEXT("bad")) == 0) {

                if (!NotifyBootConfigStatus(FALSE)) {

                    status = GetLastError();
                    printf("NotifyBootConfigStatus FAILED %d:\n\n%ws\n",
                           status,
                           GetErrorText(status));
                }
            }
            else {
                fOK = FALSE;
            }
        }
        else {
            fOK = FALSE;
        }

        if (!fOK) {

            printf("DESCRIPTION:\n");
            printf("\tIndicates whether the last boot should be saved as the\n"
                   "\tlast-known-good boot configuration\n");
            printf("USAGE:\n");
            printf("\tsc <server> boot <bad|ok>\n");
        }
    }

    //-----------------------
    // GetServiceDisplayName
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("GetDisplayName")) == 0) {
        LPTSTR  DisplayName;

        if (argc < argIndex + 2) {
            printf("DESCRIPTION:\n");
            printf("\tGets the display name associated with a particular service\n");
            printf("USAGE:\n");
            printf("\tsc <server> GetDisplayName <service key name> <bufsize>\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;
        if (argc > (argIndex + 2) ) {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }
        if (bufSize != 0) {
            DisplayName = (LPTSTR)LocalAlloc(LMEM_FIXED, bufSize*sizeof(TCHAR));
            if (DisplayName == NULL) {

                status = GetLastError();
                printf("[SC] GetServiceDisplayName: LocalAlloc FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));

                goto CleanExit;
            }
        }
        else {
            DisplayName = NULL;
        }
        if (!GetServiceDisplayName(
                hScManager,
                FixArgv[argIndex+1],
                DisplayName,
                &bufSize)) {

                status = GetLastError();
                printf("[SC] GetServiceDisplayName FAILED %d: %ws \n",
                       status,
                       GetErrorText(status));

                printf("\trequired BufSize = %d\n",bufSize);
        }
        else {
            printf("[SC] GetServiceDisplayName SUCCESS  Name = "FORMAT_LPTSTR"\n",
                   DisplayName);
        }
    }
    //-----------------------
    // GetServiceKeyName
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("GetKeyName")) == 0) {
        LPTSTR  KeyName;

        if (argc < argIndex + 2) {
            printf("DESCRIPTION:\n");
            printf("\tGets the key name associated with a particular service, "
            "using the display name as input\n");
            printf("USAGE:\n");
            printf("\tsc <server> GetKeyName <service display name> <bufsize>\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;
        if (argc > (argIndex + 2) ) {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }
        if (bufSize != 0) {
            KeyName = (LPTSTR)LocalAlloc(LMEM_FIXED, bufSize*sizeof(TCHAR));
            if (KeyName == NULL) {

                status = GetLastError();
                printf("[SC] GetServiceKeyName: LocalAlloc FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));

                goto CleanExit;
            }
        }
        else {
            KeyName = NULL;
        }

        if (!GetServiceKeyName(
                hScManager,
                FixArgv[argIndex+1],
                KeyName,
                &bufSize)) {

                status = GetLastError();
                printf("[SC] GetServiceKeyName FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));

                printf("\trequired BufSize = %d\n", bufSize);
        }
        else {
            printf("[SC] GetServiceKeyName SUCCESS  Name = "FORMAT_LPTSTR"\n",
            KeyName);
        }
    }

    //-----------------------
    // EnumDependentServices
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("EnumDepend")) == 0) {

        if (argc < argIndex + 2) {
            printf("DESCRIPTION:\n");
            printf("\tEnumerates the Services that are dependent on this one\n");
            printf("USAGE:\n");
            printf("\tsc <server> EnumDepend <service name> <bufsize>\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;
        if (argc > (argIndex + 2) ) {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        EnumDepend(hScManager,FixArgv[argIndex+1], bufSize);

    }

    //-----------------
    // Show Service SD
    //-----------------
    else if (STRICMP (FixArgv[argIndex], TEXT("sdshow")) == 0) {

        if (argc < argIndex + 2) {
            printf("DESCRIPTION:\n");
            printf("\tDisplays a service's security descriptor in SDDL format\n");
            printf("USAGE:\n");
            printf("\tsc <server> sdshow <service name>\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        ShowSecurity(hScManager, FixArgv[argIndex + 1]);
    }

    //----------------
    // Set Service SD
    //----------------
    else if (STRICMP (FixArgv[argIndex], TEXT("sdset")) == 0) {

        if (argc < argIndex + 3) {
            printf("DESCRIPTION:\n");
            printf("\tSets a service's security descriptor\n");
            printf("USAGE:\n");
            printf("\tsc <server> sdset <service name> <SD in SDDL format>\n");
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_WRITE);

        SetSecurity(hScManager, FixArgv[argIndex + 1], FixArgv[argIndex + 2]);
    }

    else {
        printf("*** Unrecognized Command ***\n");
        Usage();
        goto CleanExit;
    }


CleanExit:

    LocalFree(buffer);

    if(hService != NULL) {
        CloseServiceHandle(hService);
    }

    if(hScManager != NULL) {
        CloseServiceHandle(hScManager);
    }

    return 0;
}


DWORD
SendControlToService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  DWORD       control,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    SERVICE_STATUS          ServiceStatus;
    STATUS_UNION            StatusUnion;
    DWORD                   status = NO_ERROR;

    DWORD                   DesiredAccess;

    //
    // If the service name is "svcctrl" and the control code is
    // stop, then set up the special secret code to shut down the
    // service controller.
    //
    // NOTE:  This only works if the service controller is built with
    //  a special debug variable defined.
    //
    if ((control == SERVICE_CONTROL_STOP) &&
        (STRICMP (pServiceName, TEXT("svcctrl")) == 0)) {

        control = 0x73746f70;       // Secret Code
    }

    switch (control) {
        case SERVICE_CONTROL_STOP:
            DesiredAccess = SERVICE_STOP;
            break;

        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_PARAMCHANGE:
        case SERVICE_CONTROL_NETBINDADD:
        case SERVICE_CONTROL_NETBINDREMOVE:
        case SERVICE_CONTROL_NETBINDENABLE:
        case SERVICE_CONTROL_NETBINDDISABLE:
            DesiredAccess = SERVICE_PAUSE_CONTINUE;
            break;

        case SERVICE_CONTROL_INTERROGATE:
            DesiredAccess = SERVICE_INTERROGATE;
            break;

        default:
            DesiredAccess = SERVICE_USER_DEFINED_CONTROL;
    }

    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    pServiceName,
                    DesiredAccess);

    if (*lphService == NULL) {
        status = GetLastError();
        printf("[SC] OpenService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));

        return(0);
    }

    if (!ControlService (
            *lphService,
            control,
            &ServiceStatus)) {

        status = GetLastError();

    }

    if (status == NO_ERROR) {
        StatusUnion.Regular = &ServiceStatus;
        DisplayStatus(pServiceName, NULL, &StatusUnion, TRUE);
    }
    else {
        printf("[SC] ControlService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
    }

    return(0);
}


DWORD
SendConfigToService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *argv,
    IN  DWORD       argc,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:



Arguments:

    hScManager - This is the handle to the ScManager.

    pServicename - This is a pointer to the service name string

    Argv - Pointer to an array of argument pointers.  These pointers
        in the array point to the strings used as input parameters for
        ChangeConfigStatus

    argc - The number of arguments in the array of argument pointers

    lphService - Pointer to location to where the handle to the service
        is to be returned.


Return Value:



--*/
{
    DWORD       status = NO_ERROR;
    DWORD       i;
    DWORD       dwServiceType   = SERVICE_NO_CHANGE;
    DWORD       dwStartType     = SERVICE_NO_CHANGE;
    DWORD       dwErrorControl  = SERVICE_NO_CHANGE;
    LPTSTR      lpBinaryPathName    = NULL;
    LPTSTR      lpLoadOrderGroup    = NULL;
    LPTSTR      lpDependencies      = NULL;
    LPTSTR      lpServiceStartName  = NULL;
    LPTSTR      lpPassword          = NULL;
    LPTSTR      lpDisplayName       = NULL;
    LPTSTR      tempDepend = NULL;
    UINT        bufSize;

    LPDWORD     lpdwTagId = NULL;
    DWORD       TagId;


    //
    // Look at parameter list
    //
    for (i=0;i<argc ;i++ ) {
        if (STRICMP(argv[i], TEXT("type=")) == 0 && (i+1 < argc)) {

            //--------------------------------------------------------
            // We want to allow for several arguments of type= in the
            // same line.  These should cause the different arguments
            // to be or'd together.  So if we come in and dwServiceType
            // is NO_CHANGE, we set the value to 0 (for or'ing).  If
            // it is still 0 on exit, we re-set the value to
            // NO_CHANGE.
            //--------------------------------------------------------
            if (dwServiceType == SERVICE_NO_CHANGE) {
                dwServiceType = 0;
            }

            if (STRICMP(argv[i+1],TEXT("own")) == 0) {
                dwServiceType |= SERVICE_WIN32_OWN_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("share")) == 0) {
                dwServiceType |= SERVICE_WIN32_SHARE_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("interact")) == 0) {
                dwServiceType |= SERVICE_INTERACTIVE_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("kernel")) == 0) {
                dwServiceType |= SERVICE_KERNEL_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("filesys")) == 0) {
                dwServiceType |= SERVICE_FILE_SYSTEM_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("rec")) == 0) {
                dwServiceType |= SERVICE_RECOGNIZER_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("adapt")) == 0) {
                dwServiceType |= SERVICE_ADAPTER;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0) {
                dwServiceType |= 0x2f309a20;
            }
            else {
                printf("invalid type= field\n");
                ConfigUsage();
                return(0);
            }
            if (dwServiceType == 0) {
                dwServiceType = SERVICE_NO_CHANGE;
            }
            i++;
        }
        else if (STRICMP(argv[i], TEXT("start=")) == 0 && (i+1 < argc)) {

            if (STRICMP(argv[i+1],TEXT("boot")) == 0) {
                dwStartType = SERVICE_BOOT_START;
            }
            else if (STRICMP(argv[i+1],TEXT("system")) == 0) {
                dwStartType = SERVICE_SYSTEM_START;
            }
            else if (STRICMP(argv[i+1],TEXT("auto")) == 0) {
                dwStartType = SERVICE_AUTO_START;
            }
            else if (STRICMP(argv[i+1],TEXT("demand")) == 0) {
                dwStartType = SERVICE_DEMAND_START;
            }
            else if (STRICMP(argv[i+1],TEXT("disabled")) == 0) {
                dwStartType = SERVICE_DISABLED;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0) {
                dwStartType = 0xd0034911;
            }
            else {
                printf("invalid start= field\n");
                ConfigUsage();
                return(0);
            }
            i++;
        }
        else if (STRICMP(argv[i], TEXT("error=")) == 0 && (i+1 < argc)) {
            if (STRICMP(argv[i+1],TEXT("normal")) == 0) {
                dwErrorControl = SERVICE_ERROR_NORMAL;
            }
            else if (STRICMP(argv[i+1],TEXT("severe")) == 0) {
                dwErrorControl = SERVICE_ERROR_SEVERE;
            }
            else if (STRICMP(argv[i+1],TEXT("ignore")) == 0) {
                dwErrorControl = SERVICE_ERROR_IGNORE;
            }
            else if (STRICMP(argv[i+1],TEXT("critical")) == 0) {
                dwErrorControl = SERVICE_ERROR_CRITICAL;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0) {
                dwErrorControl = 0x00d74550;
            }
            else {
                printf("invalid error= field\n");
                ConfigUsage();
                return(0);
            }
            i++;
        }
        else if (STRICMP(argv[i], TEXT("binPath=")) == 0 && (i+1 < argc)) {
            lpBinaryPathName = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("group=")) == 0 && (i+1 < argc)) {
            lpLoadOrderGroup = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("tag=")) == 0 && (i+1 < argc)) {
            if (STRICMP(argv[i+1], TEXT("YES"))==0) {
                lpdwTagId = &TagId;
            }
            i++;
        }
        else if (STRICMP(argv[i], TEXT("depend=")) == 0 && (i+1 < argc)) {
            tempDepend = argv[i+1];
            bufSize = (UINT)STRSIZE(tempDepend);
            lpDependencies = (LPTSTR)LocalAlloc(
                                LMEM_ZEROINIT,
                                bufSize + sizeof(TCHAR));

            if (lpDependencies == NULL) {

                status = GetLastError();
                printf("[SC] SendConfigToService: LocalAlloc FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));

                return(0);
            }

            //
            // Put NULLs in place of forward slashes in the string.
            //
            STRCPY(lpDependencies, tempDepend);
            tempDepend = lpDependencies;
            while (*tempDepend != TEXT('\0')){
                if (*tempDepend == TEXT('/')) {
                    *tempDepend = TEXT('\0');
                }
                tempDepend++;
            }
            i++;
        }
        else if (STRICMP(argv[i], TEXT("obj=")) == 0 && (i+1 < argc)) {
            lpServiceStartName = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("password=")) == 0 && (i+1 < argc)) {
            lpPassword = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("DisplayName=")) == 0 && (i+1 < argc)) {
            lpDisplayName = argv[i+1];
            i++;
        }
        else {
            ConfigUsage();
            return(0);
        }
    }



    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    pServiceName,
                    SERVICE_CHANGE_CONFIG);

    if (*lphService == NULL) {

        status = GetLastError();
        printf("[SC] OpenService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));

        return(0);
    }

    if (!ChangeServiceConfig(
            *lphService,        // hService
            dwServiceType,      // dwServiceType
            dwStartType,        // dwStartType
            dwErrorControl,     // dwErrorControl
            lpBinaryPathName,   // lpBinaryPathName
            lpLoadOrderGroup,   // lpLoadOrderGroup
            lpdwTagId,          // lpdwTagId
            lpDependencies,     // lpDependencies
            lpServiceStartName, // lpServiceStartName
            lpPassword,         // lpPassword
            lpDisplayName)){    // lpDisplayName

        status = GetLastError();
    }

    if (status == NO_ERROR) {
        printf("[SC] ChangeServiceConfig SUCCESS\n");
        if (lpdwTagId != NULL) {
            printf("[SC] Tag = %d\n",*lpdwTagId);
        }
    }
    else {
        printf("[SC] ChangeServiceConfig FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
    }

    return(0);
}

DWORD
ChangeServiceDescription(
    IN SC_HANDLE    hScManager,
    IN LPTSTR       pServiceName,
    IN LPTSTR       pNewDescription,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD                   status = NO_ERROR;
    SERVICE_DESCRIPTION     sdNewDescription;


    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    pServiceName,
                    SERVICE_CHANGE_CONFIG);

    if (*lphService == NULL) {

        status = GetLastError();
        printf("[SC] OpenService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));

        return(0);
    }

    
    sdNewDescription.lpDescription = pNewDescription;

    if (!ChangeServiceConfig2(
            *lphService,                    // handle to service
            SERVICE_CONFIG_DESCRIPTION,     // description ID
            &sdNewDescription)) {           // pointer to config info
          
        status = GetLastError();
    }

    if (status == NO_ERROR) {
        printf("[SC] ChangeServiceConfig2 SUCCESS\n");
    }
    else {
        printf("[SC] ChangeServiceConfig2 FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
    }

    return(0);
}

DWORD
ChangeServiceFailure(
    IN SC_HANDLE    hScManager,
    IN LPTSTR       pServiceName,
    IN LPTSTR       *argv,
    IN DWORD        argc,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/

{
    BOOL                    fReset              = FALSE;
    BOOL                    fActions            = FALSE;
    NTSTATUS                ntsStatus;
    DWORD                   status              = NO_ERROR;
    DWORD                   i;
    DWORD                   dwActionNum         = 0;
    DWORD                   dwReset             = 0;
    DWORD                   dwAccess            = SERVICE_CHANGE_CONFIG;
    LPTSTR                  lpReboot            = NULL;
    LPTSTR                  lpCommandLine       = NULL;
    LPTSTR                  pActionStart;
    LPTSTR                  pActionEnd;
    SC_ACTION               *lpsaTempActions    = NULL;
    BOOLEAN                 fActionDelay        = TRUE;
    BOOLEAN                 fGarbage;
    BOOLEAN                 fAdjustPrivilege    = FALSE;
    SERVICE_FAILURE_ACTIONS sfaActions;
    
    //
    // Look at parameter list
    //
    for (i=0; i < argc; i++ ) {
        if (STRICMP(argv[i], TEXT("reset=")) == 0 && (i+1 < argc)) {

            if (STRICMP(argv[i+1], TEXT("infinite")) == 0) {
                dwReset = INFINITE;
            }
            else {              
                dwReset = _ttol(argv[i+1]);
            }
            fReset = TRUE;
            i++;
        }
        else if (STRICMP(argv[i], TEXT("reboot=")) == 0 && (i+1 < argc)) {
            lpReboot = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("command=")) == 0 && (i+1 < argc)) {
            lpCommandLine = argv[i+1];
            i++;
        }

        else if (STRICMP(argv[i], TEXT("actions=")) == 0 && (i+1 < argc)) {
            
            pActionStart = argv[i+1];

            //
            // Count the number of actions in order to allocate the action array.  Since one
            // action will be missed (NULL char at the end instead of '/'), add one after the loop
            //

            while (*pActionStart != TEXT('\0')) {
                if (*pActionStart == TEXT('/')) {
                    dwActionNum++;
                }
                pActionStart++;
            }
            dwActionNum++;

            //
            // Allocate the action array.  Round the number up in case an action was given without
            // a delay at the end.  If this is the case, the delay will be treated as 0
            //

            lpsaTempActions = (SC_ACTION *)LocalAlloc(LMEM_ZEROINIT,
                                                        (dwActionNum + 1) / 2 * sizeof(SC_ACTION));     
            if (lpsaTempActions == NULL) {

                status = GetLastError();
                printf("[SC] ChangeServiceFailure: LocalAlloc FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));

                return(0);
            }

            pActionStart = pActionEnd = argv[i+1];

            //
            // The '/' character delimits the tokens, so turn the final NULL char into a '/'
            // to move through the entire string.  This '/' is changed back to the NULL char below.
            //

            pActionStart[STRLEN(pActionStart)] = TEXT('/');
            dwActionNum = 0;

            while (*pActionEnd != TEXT('\0')) {
                if (*pActionEnd == TEXT('/')) {
                    *pActionEnd = TEXT('\0');

                    //
                    // Use fActionDelay to "remember" if it's an action or a delay being parsed
                    //

                    if (fActionDelay) {

                        if (STRICMP(pActionStart, TEXT("restart")) == 0) {
                            lpsaTempActions[dwActionNum].Type = SC_ACTION_RESTART;
                            dwAccess |= SERVICE_START;
                        }
                        else if (STRICMP(pActionStart, TEXT("reboot")) == 0) {
                            lpsaTempActions[dwActionNum].Type = SC_ACTION_REBOOT;
                            fAdjustPrivilege = TRUE;
                        }
                        else if (STRICMP(pActionStart, TEXT("run")) == 0) {
                            lpsaTempActions[dwActionNum].Type = SC_ACTION_RUN_COMMAND;
                        }
                        else {
                            lpsaTempActions[dwActionNum].Type = SC_ACTION_NONE;
                        }
                    }
                    else {
                        lpsaTempActions[dwActionNum++].Delay = _ttol(pActionStart);
                    }
                
                    fActionDelay = !fActionDelay;
                    pActionStart = pActionEnd + 1;
                }
                pActionEnd++;
            }
            fActions = TRUE;
            i++;
        }
        else {
            printf("ERROR:  Invalid option  \n\n");
            ChangeFailureUsage();
            return(0);
        }
    }

    if (fReset != fActions) {
        printf("\nERROR:  The reset and actions options must be set simultaneously. \n\n");
        ChangeFailureUsage();
        return(0);
    }

    if (fAdjustPrivilege) {

        ntsStatus = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                       TRUE,
                                       FALSE,
                                       &fGarbage);

        if (!NT_SUCCESS(ntsStatus)) {
    
            printf("[SC] ChangeServiceFailure: RtlAdjustPrivilege "
                        "FAILED %#x\n",
                   ntsStatus);

            return(0);
        }
    }

    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    pServiceName,
                    dwAccess);

    if (*lphService == NULL) {

        status = GetLastError();
        printf("[SC] OpenService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));

        return(0);
    }


    sfaActions.dwResetPeriod    = dwReset;
    sfaActions.lpRebootMsg      = lpReboot;
    sfaActions.lpCommand        = lpCommandLine;
    sfaActions.cActions         = dwActionNum;
    sfaActions.lpsaActions      = lpsaTempActions;

    
    if (!ChangeServiceConfig2(
                *lphService,                        // handle to service
                SERVICE_CONFIG_FAILURE_ACTIONS,     // config info ID
                &sfaActions)) {                     // pointer to config info

        status = GetLastError();
    }

    if (status == NO_ERROR) {
            printf("[SC] ChangeServiceConfig2 SUCCESS\n");
    }
    else {
        printf("[SC] ChangeServiceConfig2 FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
    }

    return(0);
}


DWORD
DoCreateService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *argv,
    IN  DWORD       argc
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD       status = NO_ERROR;
    DWORD       i;
    DWORD       dwServiceType   = SERVICE_NO_CHANGE;
    DWORD       dwStartType     = SERVICE_DEMAND_START;
    DWORD       dwErrorControl  = SERVICE_ERROR_NORMAL;
    LPTSTR      lpBinaryPathName    = NULL;
    LPTSTR      lpLoadOrderGroup    = NULL;
    DWORD       TagId               = 0;
    LPDWORD     lpdwTagId           = NULL;
    LPTSTR      lpDependencies      = NULL;
    LPTSTR      lpServiceStartName  = NULL;
    LPTSTR      lpDisplayName       = NULL;
    LPTSTR      lpPassword          = NULL;
    LPTSTR      tempDepend = NULL;
    SC_HANDLE   hService = NULL;
    UINT        bufSize;

//    DWORD       time1,time2;



    //
    // Look at parameter list
    //
    for (i=0;i<argc ;i++ ) {
        //---------------
        // ServiceType
        //---------------
        if (STRICMP(argv[i], TEXT("type=")) == 0 && (i+1 < argc)) {

            //--------------------------------------------------------
            // We want to allow for several arguments of type= in the
            // same line.  These should cause the different arguments
            // to be or'd together.  So if we come in and dwServiceType
            // is NO_CHANGE, we set the value to 0 (for or'ing).  If
            // it is still 0 on exit, we re-set the value to
            // WIN32_OWN_PROCESS.
            //--------------------------------------------------------
            if (dwServiceType == SERVICE_NO_CHANGE) {
                dwServiceType = 0;
            }
            if (STRICMP(argv[i+1],TEXT("own")) == 0) {
                dwServiceType |= SERVICE_WIN32_OWN_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("share")) == 0) {
                dwServiceType |= SERVICE_WIN32_SHARE_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("interact")) == 0) {
                dwServiceType |= SERVICE_INTERACTIVE_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("kernel")) == 0) {
                dwServiceType |= SERVICE_KERNEL_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("filesys")) == 0) {
                dwServiceType |= SERVICE_FILE_SYSTEM_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("rec")) == 0) {
                dwServiceType |= SERVICE_RECOGNIZER_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0) {
                dwServiceType |= 0x2f309a20;
            }
            else {
                printf("invalid type= field\n");
                ConfigUsage();
                return(0);
            }
            if (dwServiceType == 0) {
                dwServiceType = SERVICE_WIN32_OWN_PROCESS;
            }
            i++;
        }
        //---------------
        // StartType
        //---------------
        else if (STRICMP(argv[i], TEXT("start=")) == 0 && (i+1 < argc)) {

            if (STRICMP(argv[i+1],TEXT("boot")) == 0) {
                dwStartType = SERVICE_BOOT_START;
            }
            else if (STRICMP(argv[i+1],TEXT("system")) == 0) {
                dwStartType = SERVICE_SYSTEM_START;
            }
            else if (STRICMP(argv[i+1],TEXT("auto")) == 0) {
                dwStartType = SERVICE_AUTO_START;
            }
            else if (STRICMP(argv[i+1],TEXT("demand")) == 0) {
                dwStartType = SERVICE_DEMAND_START;
            }
            else if (STRICMP(argv[i+1],TEXT("disabled")) == 0) {
                dwStartType = SERVICE_DISABLED;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0) {
                dwStartType = 0xd0034911;
            }
            else {
                printf("invalid start= field\n");
                ConfigUsage();
                return(0);
            }
            i++;
        }
        //---------------
        // ErrorControl
        //---------------
        else if (STRICMP(argv[i], TEXT("error=")) == 0 && (i+1 < argc)) {

            if (STRICMP(argv[i+1],TEXT("normal")) == 0) {
                dwErrorControl = SERVICE_ERROR_NORMAL;
            }
            else if (STRICMP(argv[i+1],TEXT("severe")) == 0) {
                dwErrorControl = SERVICE_ERROR_SEVERE;
            }
            else if (STRICMP(argv[i+1],TEXT("critical")) == 0) {
                dwErrorControl = SERVICE_ERROR_CRITICAL;
            }
            else if (STRICMP(argv[i+1],TEXT("ignore")) == 0) {
                dwErrorControl = SERVICE_ERROR_IGNORE;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0) {
                dwErrorControl = 0x00d74550;
            }
            else {
                printf("invalid error= field\n");
                ConfigUsage();
                return(0);
            }
            i++;
        }
        //---------------
        // BinaryPath
        //---------------
        else if (STRICMP(argv[i], TEXT("binPath=")) == 0 && (i+1 < argc)) {
 
            lpBinaryPathName = argv[i+1];

#ifdef RemoveForNow
            TCHAR       PathName[256];
            //
            // Currently I am not pre-pending the path.
            //
            STRCPY(PathName, TEXT("%SystemRoot%\\system32\\"));
            STRCAT(PathName, argv[i+1]);
            lpBinaryPathName = PathName;
#endif // RemoveForNow

            i++;
        }
        //---------------
        // LoadOrderGroup
        //---------------
        else if (STRICMP(argv[i], TEXT("group=")) == 0 && (i+1 < argc)) {
            lpLoadOrderGroup = argv[i+1];
            i++;
        }
        //---------------
        // Tags
        //---------------
        else if (STRICMP(argv[i], TEXT("tag=")) == 0 && (i+1 < argc)) {
            if (STRICMP(argv[i+1], TEXT("YES"))==0) {
                lpdwTagId = &TagId;
            }
            i++;
        }
        //---------------
        // DisplayName
        //---------------
        else if (STRICMP(argv[i], TEXT("DisplayName=")) == 0 && (i+1 < argc)) {
            lpDisplayName = argv[i+1];
            i++;
        }
        //---------------
        // Dependencies
        //---------------
        else if (STRICMP(argv[i], TEXT("depend=")) == 0 && (i+1 < argc)) {
            tempDepend = argv[i+1];
            bufSize = (UINT)STRSIZE(tempDepend);
            lpDependencies = (LPTSTR)LocalAlloc(
                                LMEM_ZEROINIT,
                                bufSize + sizeof(TCHAR));
            if (lpDependencies == NULL) {

                status = GetLastError();
                printf("[SC] SendConfigToService: LocalAlloc FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));

                return(0);
            }
            //
            // Put NULLs in place of forward slashes in the string.
            //
            STRCPY(lpDependencies, tempDepend);
            tempDepend = lpDependencies;
            while (*tempDepend != TEXT('\0')){
                if (*tempDepend == TEXT('/')) {
                    *tempDepend = TEXT('\0');
                }
                tempDepend++;
            }
            i++;
        }
        //------------------
        // ServiceStartName
        //------------------
        else if (STRICMP(argv[i], TEXT("obj=")) == 0 && (i+1 < argc)) {            
            lpServiceStartName = argv[i+1];
            i++;
        }
        //---------------
        // Password
        //---------------
        else if (STRICMP(argv[i], TEXT("password=")) == 0 && (i+1 < argc)) {
            lpPassword = argv[i+1];
            i++;
        }
        else {
            CreateUsage();
            return(0);
        }
    }
    if (dwServiceType == SERVICE_NO_CHANGE) {
        dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    }

#ifdef TIMING_TEST
    time1 = GetTickCount();
#endif // TIMING_TEST

    hService = CreateService(
                    hScManager,                     // hSCManager
                    pServiceName,                   // lpServiceName
                    lpDisplayName,                  // lpDisplayName
                    SERVICE_ALL_ACCESS,             // dwDesiredAccess
                    dwServiceType,                  // dwServiceType
                    dwStartType,                    // dwStartType
                    dwErrorControl,                 // dwErrorControl
                    lpBinaryPathName,               // lpBinaryPathName
                    lpLoadOrderGroup,               // lpLoadOrderGroup
                    lpdwTagId,                      // lpdwTagId
                    lpDependencies,                 // lpDependencies
                    lpServiceStartName,             // lpServiceStartName
                    lpPassword);                    // lpPassword

#ifdef TIMING_TEST
    time2 = GetTickCount();
    printf("CreateService call time = %d\n", time2-time1);
#endif // TIMING_TEST

    if (hService == NULL) {
        status = GetLastError();
        printf("[SC] CreateService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
    }
    else {
        printf("[SC] CreateService SUCCESS\n");
    }
    CloseServiceHandle(hService);

    return(0);
}


VOID
EnumDepend(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufSize
    )

/*++

Routine Description:

    Enumerates the services dependent on the service identified by the
    ServiceName argument.

Arguments:



Return Value:



--*/
{
    SC_HANDLE               hService;
    DWORD                   status=NO_ERROR;
    DWORD                   i;
    LPENUM_SERVICE_STATUS   enumBuffer=NULL;
    STATUS_UNION            StatusUnion;
    DWORD                   entriesRead;
    DWORD                   bytesNeeded;

    hService = OpenService(
                hScManager,
                ServiceName,
                SERVICE_ENUMERATE_DEPENDENTS);

    if (hService == NULL) {

        status = GetLastError();
        printf("[SC] OpenService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));

        return;
    }

    if (bufSize > 0) {
        enumBuffer = (LPENUM_SERVICE_STATUS)LocalAlloc(LMEM_FIXED, bufSize);
        if (enumBuffer == NULL) {

            status = GetLastError();
            printf("[SC] EnumDepend: LocalAlloc FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));

            CloseServiceHandle(hService);
            return;
        }
    }
    else {
        enumBuffer = NULL;
    }

    if (!EnumDependentServices (
            hService,
            SERVICE_ACTIVE | SERVICE_INACTIVE,
            enumBuffer,
            bufSize,
            &bytesNeeded,
            &entriesRead)) {

        status = GetLastError();
    }
    //===========================
    // Display the returned data
    //===========================
    if ( (status == NO_ERROR)       ||
         (status == ERROR_MORE_DATA) ) {

        printf("Enum: entriesRead  = %d\n", entriesRead);

        for (i=0; i<entriesRead; i++) {

            for (i=0; i<entriesRead; i++ ) {

                StatusUnion.Regular = &(enumBuffer->ServiceStatus);

                DisplayStatus(
                    enumBuffer->lpServiceName,
                    enumBuffer->lpDisplayName,
                    &StatusUnion,
                    TRUE);

                enumBuffer++;
            }

        }
        if (status == ERROR_MORE_DATA){
            printf("Enum: more data, need %d bytes\n",bytesNeeded);
        }
    }
    else {
        printf("[SC] EnumDependentServices FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
    }

    if (enumBuffer != NULL) {
        LocalFree(enumBuffer);
    }
}


VOID
ShowSecurity(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName
    )
{
    SC_HANDLE   hService;
    DWORD       status = NO_ERROR;
    DWORD       dwDummy;
    BYTE        lpBuffer[1024];
    LPBYTE      lpActualBuffer = lpBuffer;
    LPTSTR      lpStringSD;

    hService = OpenService(hScManager,
                           ServiceName,
                           READ_CONTROL);

    if (hService == NULL)
    {
        status = GetLastError();
        printf("[SC] OpenService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
        return;
    }

    if (!QueryServiceObjectSecurity(hService,
                                    DACL_SECURITY_INFORMATION,
                                    (PSECURITY_DESCRIPTOR) lpBuffer,
                                    sizeof(lpBuffer),
                                    &dwDummy))
    {
        status = GetLastError();

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            lpActualBuffer = LocalAlloc(LMEM_FIXED, dwDummy);

            if (lpActualBuffer == NULL)
            {
                status = GetLastError();
                printf("[SC] QueryServiceObjectSecurity FAILED %d:\n\n%ws\n",
                       status,
                       GetErrorText(status));
                CloseServiceHandle(hService);
                return;
            }

            status = NO_ERROR;

            if (!QueryServiceObjectSecurity(hService,
                                            DACL_SECURITY_INFORMATION,
                                            (PSECURITY_DESCRIPTOR) lpActualBuffer,
                                            dwDummy,
                                            &dwDummy))
            {
                status = GetLastError();
            }
        }
    }

    if (status != NO_ERROR)
    {
        printf("[SC] QueryServiceObjectSecurity FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
        CloseServiceHandle(hService);

        if (lpActualBuffer != lpBuffer)
        {
            LocalFree(lpActualBuffer);
        }

        return;
    }

    if (!ConvertSecurityDescriptorToStringSecurityDescriptor(
            (PSECURITY_DESCRIPTOR) lpBuffer,
            SDDL_REVISION_1,
            DACL_SECURITY_INFORMATION,
            &lpStringSD,
            NULL))
    {
        status = GetLastError();
        printf("[SC] ConvertSecurityDescriptorToStringSecurityDescriptor "
                    "FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));

        CloseServiceHandle(hService);

        if (lpActualBuffer != lpBuffer)
        {
            LocalFree(lpActualBuffer);
        }

        return;
    }

    printf("\n" FORMAT_LPTSTR "\n", lpStringSD);

    LocalFree(lpStringSD);

    CloseServiceHandle(hService);

    if (lpActualBuffer != lpBuffer)
    {
        LocalFree(lpActualBuffer);
    }
}


VOID
SetSecurity(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  LPTSTR      lpStringSD
    )
{
    SC_HANDLE   hService;
    DWORD       status;

    PSECURITY_DESCRIPTOR    pSD;


    hService = OpenService(hScManager,
                           ServiceName,
                           WRITE_DAC);

    if (hService == NULL) {

        status = GetLastError();
        printf("[SC] OpenService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
        return;
    }
    
    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            lpStringSD,
            SDDL_REVISION_1,
            &pSD,
            NULL)) {

        status = GetLastError();
        printf("[SC] ConvertStringSecurityDescriptorToSecurityDescriptor "
                    "FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
        return;
    }

    if (!SetServiceObjectSecurity(hService,
                                  DACL_SECURITY_INFORMATION,
                                  pSD)) {

        status = GetLastError();
        printf("[SC] SetServiceObjectSecurity FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
    }
    else {
        printf("[SC] SetServiceObjectSecurity SUCCESS\n");
    }

    LocalFree(pSD);
}    


DWORD
GetServiceLockStatus(
    IN  SC_HANDLE   hScManager,
    IN  DWORD       bufferSize
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD                           status = NO_ERROR;
    LPQUERY_SERVICE_LOCK_STATUS     LockStatus;
    DWORD                           bytesNeeded;

    //
    // Allocate memory for the buffer.
    //
    LockStatus = (LPQUERY_SERVICE_LOCK_STATUS)LocalAlloc(LMEM_FIXED, (UINT)bufferSize);
    if (LockStatus == NULL) {

        status = GetLastError();
        printf("[SC] GetServiceLockStatus: LocalAlloc FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
        return(0);
    }


    if (!QueryServiceLockStatus(
            hScManager,
            LockStatus,
            bufferSize,
            &bytesNeeded)) {

        status = GetLastError();

        printf("[SC] QueryServiceLockStatus FAILED %d\n\n%ws\n",
               status,
               GetErrorText(status));

        if (status == ERROR_INSUFFICIENT_BUFFER) {
            printf("[SC] QueryServiceLockStatus needs %d bytes\n",bytesNeeded);
        }

        return(0);
    }

    printf("[SC] QueryServiceLockStatus SUCCESS\n");

    if (LockStatus->fIsLocked) {
        printf("\tIsLocked      : TRUE\n");
    }
    else {
        printf("\tIsLocked      : FALSE\n");
    }

    printf("\tLockOwner     : "FORMAT_LPTSTR"  \n",LockStatus->lpLockOwner);
    printf("\tLockDuration  : %d (seconds since acquired)\n\n",
           LockStatus->dwLockDuration);

    return(0);
}


VOID
LockServiceActiveDatabase(
    IN SC_HANDLE    hScManager
    )
{
    SC_LOCK Lock;
    DWORD   status;
    int ch;


    Lock = LockServiceDatabase(hScManager);

    CloseServiceHandle(hScManager);

    if (Lock == NULL) {

        status = GetLastError();
        printf("[SC] LockServiceDatabase FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
        return;
    }

    printf("\nActive database is locked.\nTo unlock via API, press u: ");

    ch = _getche();

    if (ch == 'u') {

        //
        // Call API to unlock
        //
        if (! UnlockServiceDatabase(Lock)) {

            status = GetLastError();
            printf("\n[SC] UnlockServiceDatabase FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));
        }
        else {
            printf("\n[SC] UnlockServiceDatabase SUCCESS\n");
        }

        return;
    }

    //
    // Otherwise just exit, RPC rundown routine will unlock.
    //
    printf("\n[SC] Will be unlocking database by exiting\n");

}


LPWSTR
GetErrorText(
    IN  DWORD Error
    )
{
    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  Error,
                  0,
                  MessageBuffer,
                  sizeof(MessageBuffer),
                  NULL);

    return MessageBuffer;
}


/****************************************************************************/
VOID
DisplayStatus (
    IN  LPTSTR              ServiceName,
    IN  LPTSTR              DisplayName,
    IN  LPSTATUS_UNION      lpStatusUnion,
    IN  BOOL                fIsStatusOld
    )

/*++

Routine Description:

    Displays the service name and  the service status.

    |
    |SERVICE_NAME: messenger
    |DISPLAY_NAME: messenger
    |        TYPE       : WIN32
    |        STATE      : ACTIVE,STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN
    |        EXIT_CODE  : 0xC002001
    |        CHECKPOINT : 0x00000001
    |        WAIT_HINT  : 0x00003f21
    |

Arguments:

    ServiceName - This is a pointer to a string containing the name of
        the service.

    DisplayName - This is a pointer to a string containing the display
        name for the service.

    ServiceStatus - This is a pointer to a SERVICE_STATUS structure from
        which information is to be displayed.

Return Value:

    none.

--*/
{
    DWORD   TempServiceType;
    BOOL    InteractiveBit = FALSE;

    LPSERVICE_STATUS    ServiceStatus;

    if (fIsStatusOld) {
        ServiceStatus = lpStatusUnion->Regular;
    }
    else {
        ServiceStatus = (LPSERVICE_STATUS)lpStatusUnion->Ex;
    }

    TempServiceType = ServiceStatus->dwServiceType;

    if (TempServiceType & SERVICE_INTERACTIVE_PROCESS) {
        InteractiveBit = TRUE;
        TempServiceType &= (~SERVICE_INTERACTIVE_PROCESS);
    }

    printf("\nSERVICE_NAME: "FORMAT_LPTSTR"\n", ServiceName);
    if (DisplayName != NULL) {
        printf("DISPLAY_NAME: "FORMAT_LPTSTR"\n", DisplayName);
    }
    printf("        TYPE               : %lx  ", ServiceStatus->dwServiceType);

    switch(TempServiceType){
    case SERVICE_WIN32_OWN_PROCESS:
        printf("WIN32_OWN_PROCESS ");
        break;
    case SERVICE_WIN32_SHARE_PROCESS:
        printf("WIN32_SHARE_PROCESS ");
        break;
    case SERVICE_WIN32:
        printf("WIN32 ");
        break;
    case SERVICE_ADAPTER:
        printf("ADAPTER ");
        break;
    case SERVICE_KERNEL_DRIVER:
        printf("KERNEL_DRIVER ");
        break;
    case SERVICE_FILE_SYSTEM_DRIVER:
        printf("FILE_SYSTEM_DRIVER ");
        break;
    case SERVICE_DRIVER:
        printf("DRIVER ");
        break;
    default:
        printf(" ERROR ");
    }
    if (InteractiveBit) {
        printf("(interactive)\n");
    }
    else {
        printf("\n");
    }

    printf("        STATE              : %lx  ", ServiceStatus->dwCurrentState);

    switch(ServiceStatus->dwCurrentState){
        case SERVICE_STOPPED:
            printf("STOPPED ");
            break;
        case SERVICE_START_PENDING:
            printf("START_PENDING ");
            break;
        case SERVICE_STOP_PENDING:
            printf("STOP_PENDING ");
            break;
        case SERVICE_RUNNING:
            printf("RUNNING ");
            break;
        case SERVICE_CONTINUE_PENDING:
            printf("CONTINUE_PENDING ");
            break;
        case SERVICE_PAUSE_PENDING:
            printf("PAUSE_PENDING ");
            break;
        case SERVICE_PAUSED:
            printf("PAUSED ");
            break;
        default:
            printf(" ERROR ");
    }

    //
    // Print Controls Accepted Information
    //

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_STOP) {
        printf("\n                                (STOPPABLE,");
    }
    else {
        printf("\n                                (NOT_STOPPABLE,");
    }

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE) {
        printf("PAUSABLE,");
    }
    else {
        printf("NOT_PAUSABLE,");
    }

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN) {
        printf("ACCEPTS_SHUTDOWN)\n");
    }
    else {
        printf("IGNORES_SHUTDOWN)\n");
    }

    //
    // Print Exit Code
    //
    printf("        WIN32_EXIT_CODE    : %d\t(0x%lx)\n",
        ServiceStatus->dwWin32ExitCode,
        ServiceStatus->dwWin32ExitCode);
    printf("        SERVICE_EXIT_CODE  : %d\t(0x%lx)\n",
        ServiceStatus->dwServiceSpecificExitCode,
        ServiceStatus->dwServiceSpecificExitCode  );

    //
    // Print CheckPoint & WaitHint Information
    //

    printf("        CHECKPOINT         : 0x%lx\n", ServiceStatus->dwCheckPoint);
    printf("        WAIT_HINT          : 0x%lx\n", ServiceStatus->dwWaitHint  );

    //
    // Print PID and flags if QueryServiceStatusEx was called
    //

    if (!fIsStatusOld) {

        printf("        PID                : %d\n",
               lpStatusUnion->Ex->dwProcessId);

        printf("        FLAGS              : ");

        if (lpStatusUnion->Ex->dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS) {

            printf("RUNS_IN_SYSTEM_PROCESS");
        }

        printf("\n");
    }

    return;
}

DWORD
GetServiceConfig(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufferSize,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD                   status = NO_ERROR;
    LPQUERY_SERVICE_CONFIG  ServiceConfig;
    DWORD                   bytesNeeded;
    LPTSTR                  pDepend;

    //
    // Allocate memory for the buffer.
    //
    if (bufferSize != 0) {
        ServiceConfig =
            (LPQUERY_SERVICE_CONFIG)LocalAlloc(LMEM_FIXED, (UINT)bufferSize);
        if (ServiceConfig == NULL) {

            status = GetLastError();
            printf("[SC] GetServiceConfig: LocalAlloc FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));
            return(0);
        }
    }
    else {
        ServiceConfig = NULL;
    }

    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    ServiceName,
                    SERVICE_QUERY_CONFIG);

    if (*lphService == NULL) {

        status = GetLastError();
        printf("[SC] OpenService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));
        return(0);
    }

    if (!QueryServiceConfig(
            *lphService,
            ServiceConfig,
            bufferSize,
            &bytesNeeded)) {

        status = GetLastError();
    }

    if (status == NO_ERROR) {

        DWORD   TempServiceType = ServiceConfig->dwServiceType;
        BOOL    InteractiveBit = FALSE;

        if (TempServiceType & SERVICE_INTERACTIVE_PROCESS) {
            InteractiveBit = TRUE;
            TempServiceType &= (~SERVICE_INTERACTIVE_PROCESS);
        }

        printf("[SC] GetServiceConfig SUCCESS\n");

        printf("\nSERVICE_NAME: "FORMAT_LPTSTR"\n", ServiceName);

        printf("        TYPE               : %lx  ", ServiceConfig->dwServiceType);

        switch(TempServiceType){
        case SERVICE_WIN32_OWN_PROCESS:
            printf("WIN32_OWN_PROCESS ");
            break;
        case SERVICE_WIN32_SHARE_PROCESS:
            printf("WIN32_SHARE_PROCESS ");
            break;
        case SERVICE_WIN32:
            printf("WIN32 ");
            break;
        case SERVICE_ADAPTER:
            printf(" ADAPTER ");
            break;
        case SERVICE_KERNEL_DRIVER:
            printf(" KERNEL_DRIVER ");
            break;
        case SERVICE_FILE_SYSTEM_DRIVER:
            printf(" FILE_SYSTEM_DRIVER ");
            break;
        case SERVICE_DRIVER:
            printf("DRIVER ");
            break;
        default:
            printf(" ERROR ");
        }
        if (InteractiveBit) {
            printf("(interactive)\n");
        }
        else {
            printf("\n");
        }


        printf("        START_TYPE         : %lx   ", ServiceConfig->dwStartType);

        switch(ServiceConfig->dwStartType) {
        case SERVICE_BOOT_START:
            printf("BOOT_START\n");
            break;
        case SERVICE_SYSTEM_START:
            printf("SYSTEM_START\n");
            break;
        case SERVICE_AUTO_START:
            printf("AUTO_START\n");
            break;
        case SERVICE_DEMAND_START:
            printf("DEMAND_START\n");
            break;
        case SERVICE_DISABLED:
            printf("DISABLED\n");
            break;
        default:
            printf(" ERROR\n");
        }


        printf("        ERROR_CONTROL      : %lx   ", ServiceConfig->dwErrorControl);

        switch(ServiceConfig->dwErrorControl) {
        case SERVICE_ERROR_NORMAL:
            printf("NORMAL\n");
            break;
        case SERVICE_ERROR_SEVERE:
            printf("SEVERE\n");
            break;
        case SERVICE_ERROR_CRITICAL:
            printf("CRITICAL\n");
            break;
        case SERVICE_ERROR_IGNORE:
            printf("IGNORE\n");
            break;
        default:
            printf(" ERROR\n");
        }

        printf("        BINARY_PATH_NAME   : "FORMAT_LPTSTR"  \n",
            ServiceConfig->lpBinaryPathName);

        printf("        LOAD_ORDER_GROUP   : "FORMAT_LPTSTR"  \n",
            ServiceConfig->lpLoadOrderGroup);

        printf("        TAG                : %lu  \n", ServiceConfig->dwTagId);

        printf("        DISPLAY_NAME       : "FORMAT_LPTSTR"  \n",
            ServiceConfig->lpDisplayName);

        printf("        DEPENDENCIES       : "FORMAT_LPTSTR"  \n",
            ServiceConfig->lpDependencies);

        //
        // Print the dependencies in the double terminated array of strings.
        //
        pDepend = ServiceConfig->lpDependencies;
        pDepend = pDepend + (STRLEN(pDepend)+1);
        while (*pDepend != '\0') {
            if (*pDepend != '\0') {
                printf("                           : "FORMAT_LPTSTR"  \n",pDepend);
            }
            pDepend = pDepend + (STRLEN(pDepend)+1);
        }



        printf("        SERVICE_START_NAME : "FORMAT_LPTSTR"  \n",
            ServiceConfig->lpServiceStartName);

    }
    else {
        printf("[SC] GetServiceConfig FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));

        if (status == ERROR_INSUFFICIENT_BUFFER) {
            printf("[SC] GetServiceConfig needs %d bytes\n",bytesNeeded);
        }
    }

    return(0);
}


DWORD
GetConfigInfo(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufferSize,
    OUT LPSC_HANDLE lphService,
    IN  DWORD       dwInfoLevel)

/*++

Routine Description:



Arguments:



Return Value:



--*/

{
    DWORD       status = NO_ERROR;
    LPBYTE      lpBuffer;
    DWORD       bytesNeeded;
    SC_ACTION   currentAction;
    DWORD       actionIndex;
    
    //
    // Allocate memory for the buffer.
    //
    if (bufferSize != 0) {
        lpBuffer = (LPBYTE)LocalAlloc(LMEM_FIXED, (UINT)bufferSize);
        if (lpBuffer == NULL) {

            status = GetLastError();
            printf("[SC] GetConfigInfo: LocalAlloc FAILED %d:\n\n%ws\n",
                   status,
                   GetErrorText(status));

            return(0);
        }
    }
    else {
        lpBuffer = NULL;
    }

    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    ServiceName,
                    SERVICE_QUERY_CONFIG);

    if (*lphService == NULL) {

        status = GetLastError();
        printf("[SC] OpenService FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));

        return(0);
    }

    //
    // Put the query info into lpBuffer
    //

    if (!QueryServiceConfig2(
                *lphService,
                dwInfoLevel,
                lpBuffer,
                bufferSize,
                &bytesNeeded)) {

        status = GetLastError();
    }
        
    if (status == NO_ERROR) {
        
        printf("[SC] GetServiceConfig SUCCESS\n");
        
        if (dwInfoLevel == SERVICE_CONFIG_DESCRIPTION) {

                LPSERVICE_DESCRIPTION lpService = (LPSERVICE_DESCRIPTION)lpBuffer;

                printf("\nSERVICE_NAME: "FORMAT_LPTSTR"\n", ServiceName);

                printf("        DESCRIPTION              : "FORMAT_LPTSTR"\n",
                        (lpService->lpDescription == NULL ? TEXT("") : lpService->lpDescription));
        }

        else if (dwInfoLevel == SERVICE_CONFIG_FAILURE_ACTIONS) {
    
                LPSERVICE_FAILURE_ACTIONS lpFailure =
                        (LPSERVICE_FAILURE_ACTIONS)lpBuffer;

                printf("\nSERVICE_NAME: "FORMAT_LPTSTR"\n", ServiceName);
                
                printf("        RESET_PERIOD             : ");
                        
                if (lpFailure->dwResetPeriod == INFINITE) {
                    printf("INFINITE \n");
                }
                else {
                    printf("%u seconds\n", lpFailure->dwResetPeriod);
                }

                printf("        REBOOT_MESSAGE           : "FORMAT_LPTSTR"\n",
                        (lpFailure->lpRebootMsg == NULL ? TEXT("") : lpFailure->lpRebootMsg));
                    
                printf("        COMMAND_LINE             : "FORMAT_LPTSTR"\n",
                        (lpFailure->lpCommand == NULL ? TEXT("") : lpFailure->lpCommand));
                    
                printf("        FAILURE_ACTIONS          : ");

                for (actionIndex = 0; actionIndex < lpFailure->cActions; actionIndex++) {

                    currentAction = lpFailure->lpsaActions[actionIndex];

                    if (actionIndex > 0) {
                        printf("                                   ");
                    }

                    //
                    // Print the action and delay -- for no action, print nothing.
                    //

                    switch (currentAction.Type) {
                    case SC_ACTION_NONE:
                        break;
                    case SC_ACTION_RESTART:
                        printf("RESTART -- Delay = %u milliseconds.\n", currentAction.Delay);
                        break;
                    case SC_ACTION_REBOOT:
                        printf("REBOOT -- Delay = %u milliseconds\n", currentAction.Delay);
                        break;
                    case SC_ACTION_RUN_COMMAND:
                        printf("RUN PROCESS -- Delay = %u milliseconds\n", 
                                    currentAction.Delay);
                        break;
                    default:
                        printf("ERROR:  Invalid action: %#x\n", currentAction.Type);
                        break;
                    }
                }
                printf("\n");
        }
    }
    else {
        printf("[SC] GetConfigInfo FAILED %d:\n\n%ws\n",
               status,
               GetErrorText(status));

        if (status == ERROR_INSUFFICIENT_BUFFER) {
            printf("[SC] GetConfigInfo needs %d bytes\n", bytesNeeded);
        }
    }

    return(0);
}

VOID
Usage(
    VOID)
{
    int ch;

    printf("DESCRIPTION:\n");
    printf("\tSC is a command line program used for communicating with the \n"
           "\tNT Service Controller and services.\n");
    printf("USAGE:\n");
    printf("\tsc <server> [command] [service name] <option1> <option2>...\n\n");
    printf("\tThe option <server> has the form \"\\\\ServerName\"\n");
    printf("\tFurther help on commands can be obtained by typing: \"sc [command]\"\n");
    printf("\tCommands:\n"
           "\t  query-----------Queries the status for a service, or \n"
           "\t                  enumerates the status for types of services.\n"
           "\t  queryex---------Queries the extended status for a service, or \n"
           "\t                  enumerates the status for types of services.\n"
           "\t  start-----------Starts a service.\n"
           "\t  pause-----------Sends a PAUSE control request to a service.\n"
           "\t  interrogate-----Sends an INTERROGATE control request to a service.\n"
           "\t  continue--------Sends a CONTINUE control request to a service.\n"
           "\t  stop------------Sends a STOP request to a service.\n"
           "\t  config----------Changes the configuration of a service (persistant).\n"
           "\t  description-----Changes the description of a service.\n"
           "\t  failure---------Changes the actions taken by a service upon failure.\n"
           "\t  qc--------------Queries the configuration information for a service.\n"
           "\t  qdescription----Queries the description for a service.\n"
           "\t  qfailure--------Queries the actions taken by a service upon failure.\n"
           "\t  delete----------Deletes a service (from the registry).\n"
           "\t  create----------Creates a service. (adds it to the registry).\n"
           "\t  control---------Sends a control to a service.\n"
           "\t  sdshow----------Displays a service's security descriptor.\n"
           "\t  sdset-----------Sets a service's security descriptor.\n"
           "\t  GetDisplayName--Gets the DisplayName for a service.\n"
           "\t  GetKeyName------Gets the ServiceKeyName for a service.\n"
           "\t  EnumDepend------Enumerates Service Dependencies.\n");

    printf("\n\tThe following commands don't require a service name:\n");
    printf("\tsc <server> <command> <option> \n"

#ifdef TEST_VERSION
           "\t  open------------Opens and then closes a handle to a service\n"
#endif // TEST_VERSION

           "\t  boot------------(ok | bad) Indicates whether the last boot should\n"
           "\t                  be saved as the last-known-good boot configuration\n"
           "\t  Lock------------Locks the Service Database\n"
           "\t  QueryLock-------Queries the LockStatus for the SCManager Database\n");

    printf("EXAMPLE:\n");
    printf("\tsc start MyService\n");
    printf("\nWould you like to see help for the QUERY and QUERYEX commands? [ y | n ]: ");
    ch = _getche();
    if ((ch == 'y') || (ch == 'Y')) {
        QueryUsage();
    }
    printf("\n");
}


VOID
QueryUsage(VOID)
{

    printf("\nQUERY and QUERYEX OPTIONS : \n"
           "\tIf the query command is followed by a service name, the status\n"
           "\tfor that service is returned.  Further options do not apply in\n"
           "\tthis case.  If the query command is followed by nothing or one of\n"
           "\tthe options listed below, the services are enumerated.\n");

    printf("    type=    Type of services to enumerate (driver, service, all)\n"
           "             (default = service)\n"
           "    state=   State of services to enumerate (inactive, all)\n"
           "             (default = active)\n"
           "    bufsize= The size (in bytes) of the enumeration buffer\n"
           "             (default = %d)\n"
           "    ri=      The resume index number at which to begin the enumeration\n"
           "             (default = 0)\n"
           "    group=   Service group to enumerate\n"
           "             (default = all groups)\n",
           DEFAULT_ENUM_BUFFER_SIZE);

    printf("SYNTAX EXAMPLES\n");

    printf("sc query                - Enumerates status for active services & drivers\n");
    printf("sc query messenger      - Displays status for the messenger service\n");
    printf("sc queryex messenger    - Displays extended status for the messenger service\n");
    printf("sc query type= driver   - Enumerates only active drivers\n");
    printf("sc query type= service  - Enumerates only Win32 services\n");
    printf("sc query state= all     - Enumerates all services & drivers\n");
    printf("sc query bufsize= 50    - Enumerates with a 50 byte buffer.\n");
    printf("sc query ri= 14         - Enumerates with resume index = 14\n");
    printf("sc queryex group= \"\"    - Enumerates active services not in a group\n");
    printf("sc query type= service type= interact - Enumerates all interactive services\n");
    printf("sc query type= driver group= NDIS     - Enumerates all NDIS drivers\n");
}


VOID
ConfigUsage(VOID)
{
    printf("Modifies a service entry in the registry and Service Database.\n");
    printf("SYNTAX: \nsc <server> config [service name] <option1> <option2>...\n");
    printf("CONFIG OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n"
        " type= <own|share|interact|kernel|filesys|rec|adapt>\n"
        " start= <boot|system|auto|demand|disabled>\n"
        " error= <normal|severe|critical|ignore>\n"
        " binPath= <BinaryPathName>\n"
        " group= <LoadOrderGroup>\n"
        " tag= <yes|no>\n"
        " depend= <Dependencies(separated by / (forward slash))>\n"
        " obj= <AccountName|ObjectName>\n"
        " DisplayName= <display name>\n"
        " password= <password> \n");
}


VOID
CreateUsage(VOID)
{
    printf("Creates a service entry in the registry and Service Database.\n");
    printf("SYNTAX: \nsc create [service name] [binPath= ] <option1> <option2>...\n");
    printf("CREATE OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n"
        " type= <own|share|interact|kernel|filesys|rec>\n"
        "       (default = own)\n"
        " start= <boot|system|auto|demand|disabled>\n"
        "       (default = demand)\n"
        " error= <normal|severe|critical|ignore>\n"
        "       (default = normal)\n"
        " binPath= <BinaryPathName>\n"
        " group= <LoadOrderGroup>\n"
        " tag= <yes|no>\n"
        " depend= <Dependencies(separated by / (forward slash))>\n"
        " obj= <AccountName|ObjectName>\n"
        "       (default = LocalSystem)\n"
        " DisplayName= <display name>\n"
        " password= <password> \n");
}


VOID
ChangeFailureUsage(VOID)
{
    printf("DESCRIPTION:\n");
    printf("\tChanges the actions upon failure\n");
    printf("USAGE:\n");
    printf("\tsc <server> failure [service name] <option1> <option2>...\n\n");
    printf("OPTIONS:\n");
    printf("\treset= <Length of period of no failures (in seconds) \n" 
           "\t        after which to reset the failure count to 0 (may be INFINITE)>\n"
           "\t        (Must be used in conjunction with actions= )\n");
    printf("\treboot= <Message broadcast before rebooting on failure>\n");
    printf("\tcommand= <Command line to be run on failure>\n");
    printf("\tactions= <Failure actions and their delay time (in milliseconds),\n"
           "\t          separated by / (forward slash) -- e.g., run/5000/reboot/800\n"
           "\t          Valid actions are <run|restart|reboot>  >\n"
           "\t          (Must be used in conjunction with the reset= option)\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\ntsdexts\scexts.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    scexts.cxx

Abstract:

    This function contains the eventlog ntsd debugger extensions

    Each DLL entry point is called with a handle to the process being
    debugged, as well as pointers to functions.

    This process cannot just _read data in the process being debugged.
    Therefore, some macros are defined that will copy data from
    the debuggee process into a location in this processes memory.
    The GET_DATA and GET_STRING macros (defined in this file) are used
    to _read memory in the process being debugged.  The DebuggeeAddr is the
    address of the memory in the debuggee process. The LocalAddr is the
    address of memory in the debugger (this programs context) that data is
    to be copied into. Length describes the number of bytes to be copied.


Author:

    Dan Lafferty (DanL) 12-Aug-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <time.h>
#include <winsvc.h>
#include <dataman.h>
#include <tstr.h>

//#define DbgPrint(_x_) (lpOutputRoutine) _x_
#define DbgPrint(_x_)
#define MAX_NAME 256
#define printf (lpOutputRoutine)

#define GET_DATA(DebugeeAddr, LocalAddr, Length) \
    Status = ReadProcessMemory(                  \
                GlobalhCurrentProcess,           \
                (LPVOID)DebugeeAddr,             \
                LocalAddr,                       \
                Length,                          \
                NULL                             \
                );
//
//  This macro copies a string from the debuggee
//  process, one character at a time into this
//  process's address space.
//
//  CODEWORK:  This macro should check the length
//  to make sure we don't overflow the LocalAddr
//  buffer.  Perhaps this should be a function
//  rather than a macro.
//
#define GET_STRING(DebugeeAddr, LocalAddr, Length) \
                                                \
    {                                           \
    WCHAR    UnicodeChar;                       \
    LPWSTR   pDest;                             \
    LPWSTR   pSource;                           \
    pDest = LocalAddr;                          \
    pSource = DebugeeAddr;                      \
    do {                                        \
                                                \
        Status = ReadProcessMemory(             \
                GlobalhCurrentProcess,          \
                (LPVOID)pSource,                \
                &UnicodeChar,                   \
                sizeof(WCHAR),                  \
                NULL                            \
                );                              \
                                                \
        *pDest = UnicodeChar;                   \
        pDest++;                                \
        pSource++;                              \
    } while (UnicodeChar != L'\0');}

//=======================
// Function Prototypes
//=======================
PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;

VOID
BackDepend(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    );

VOID
DumpFwdDependentNames(
    LPSERVICE_RECORD    pServiceRecord
    );

VOID
DumpBkwdDependentNames(
    LPSERVICE_RECORD    pServiceRecord
    );

LPIMAGE_RECORD
DumpImageRecord(
    HANDLE              hCurrentProcess,
    LPIMAGE_RECORD      pImageRecord,
    LPDWORD             NumBytes,        // number of bytes in GroupRecord.
    BOOL                JustSizeInfo
    );

LPLOAD_ORDER_GROUP
DumpGroupRecord(
    HANDLE              hCurrentProcess,
    LPLOAD_ORDER_GROUP  pGroupRecord,
    LPDWORD             NumBytes,        // number of bytes in GroupRecord.
    BOOL                JustSizeInfo
    );

LPSERVICE_RECORD
DumpServiceRecord(
    HANDLE              hCurrentProcess,
    LPSERVICE_RECORD    pServiceRecord,
    LPDWORD             NumBytes,        // number of bytes in ServiceRecord.
    LPDWORD             NumDependBytes,  // number of bytes in DependRecords.
    BOOL                JustSizeInfo
    );

BOOL
FindServiceRecordByName(
    LPSTR               ServiceName,
    LPSERVICE_RECORD    *pServiceRecord
    );

VOID
GetDependTreeSize(
    LPSERVICE_RECORD    pServiceRecord,
    LPDWORD             pNumDependStructs,
    LPDWORD             pNumBytes,
    BOOL                StartDepend
    );

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    );

HANDLE GlobalhCurrentProcess;
BOOL Status;

//
// Initialize the global function pointers
//

VOID
InitFunctionPointers(
    HANDLE hCurrentProcess,
    PNTSD_EXTENSION_APIS lpExtensionApis
    )
{
    //
    // Load these to speed access if we haven't already
    //

    if (!lpOutputRoutine) {
        lpOutputRoutine        = lpExtensionApis->lpOutputRoutine;
        lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine;
        lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;
    }

    //
    // Stick this in a global
    //

    GlobalhCurrentProcess = hCurrentProcess;
}

VOID
ServiceRecord(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++
Routine Description:
    Dump Service Records.

Arguments:
    hCurrentProcess - Handle for the process being debugged.

    hCurrentThread - Handle for the thread that has the debugger focus.

    dwCurrentPc - Current Program Counter?

    lpExtensionApis - Pointer to a structure that contains pointers to
        various routines. (see \nt\public\sdk\inc\ntsdexts.h)
        typedef struct _NTSD_EXTENSION_APIS {
            DWORD nSize;
            PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
            PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
            PNTSD_GET_SYMBOL lpGetSymbolRoutine;
            PNTSD_DISASM lpDisasmRoutine;
            PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
        } NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

    lpArgumentString - This is a pointer to a string that contains
        space seperated arguments that are passed to debugger
        extension function.

Return Value:
    none

--*/
{
    DWORD               pDatabaseAnchor;
    SERVICE_RECORD      ServiceRecord;
    LPSERVICE_RECORD    pServiceRecord;
    DWORD               numBytes=0;
    DWORD               numDependBytes=0;
    DWORD               numEntries=0;
    LPSTR               pToken;

    InitFunctionPointers(hCurrentProcess, lpExtensionApis);

    printf("ArgumentString = %s\n\n",lpArgumentString);

    //
    // Get the address of the top of the Service Database.
    //
    pDatabaseAnchor = (lpGetExpressionRoutine)("ServiceDatabase");

    //
    // Get the first service record.
    // This is a dummy record that points to the first real record.
    //
    GET_DATA(pDatabaseAnchor, &ServiceRecord, sizeof(ServiceRecord))
    pServiceRecord = ServiceRecord.Next;

    if (_strnicmp(lpArgumentString, "mem", 3) == 0) {
        //--------------------------------------
        // Dump Memory Usage only.
        //--------------------------------------
        do {
            pServiceRecord = DumpServiceRecord(
                                hCurrentProcess,
                                pServiceRecord,
                                &numBytes,
                                &numDependBytes,
                                TRUE);
            numEntries++;
        } while (pServiceRecord != NULL);
        printf("NumSRBytes = %d  NumDependBytes = %d\n",numBytes,numDependBytes);
        printf("NumEntries = %d\n",numEntries);
    }

    else if (_strnicmp(lpArgumentString, "name=", 5) == 0) {
        //--------------------------------------
        // Find a particular Service Record
        // based on Name.
        //--------------------------------------
        pToken = strtok(lpArgumentString+6," ,\t\n");
        if (pToken == NULL) {
            printf("A Name was not given\n");
            return;
        }
        if (FindServiceRecordByName(pToken, &pServiceRecord)) {
            pServiceRecord = DumpServiceRecord(
                                hCurrentProcess,
                                pServiceRecord,
                                &numBytes,
                                &numDependBytes,
                                FALSE);
            printf("NumSRBytes = %d  NumDependBytes = %d\n",numBytes,numDependBytes);
            printf("NumEntries = %d\n",1);
        }
        else {
            printf("No service record found for \"%s\"\n", pToken);
        }
    }
    else if (_strnicmp(lpArgumentString, "address=", 8) == 0) {
        //--------------------------------------
        // Find a particular Service Record
        // based on Address.
        //--------------------------------------
        pToken = strtok(lpArgumentString+9," ,\t\n");
        if (pToken == NULL) {
            printf("An Address was not given\n");
            return;
        }
        else {
            LPSERVICE_RECORD    ServiceAddress;
            LPSTR               pMore;

            ServiceAddress = (LPSERVICE_RECORD)strtoul(pToken, &pMore, 16);
            printf("pToken =  %s\n",pToken);
            printf("strtoul on Service Address yields %d(decimal) %x(hex)\n",
                ServiceAddress, ServiceAddress);

            pServiceRecord = DumpServiceRecord(
                                hCurrentProcess,
                                ServiceAddress,
                                &numBytes,
                                &numDependBytes,
                                FALSE);

            printf("NumSRBytes = %d  NumDependBytes = %d\n",numBytes,numDependBytes);
            printf("NumEntries = %d\n",1);
        }
    }
    else {
        //--------------------------------------
        // Dump All Service Records.
        //--------------------------------------
        do {
            pServiceRecord = DumpServiceRecord(
                                hCurrentProcess,
                                pServiceRecord,
                                &numBytes,
                                &numDependBytes,
                                FALSE);
            numEntries++;
        } while (pServiceRecord != NULL);
        printf("NumSRBytes = %d  NumDependBytes = %d\n",numBytes,numDependBytes);
        printf("NumEntries = %d\n",numEntries);
    }
    return;
}

VOID
Dependencies(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++
Routine Description:
    Dump Service Record Dependencies.

Arguments:
    hCurrentProcess - Handle for the process being debugged.

    hCurrentThread - Handle for the thread that has the debugger focus.

    dwCurrentPc - Current Program Counter?

    lpExtensionApis - Pointer to a structure that contains pointers to
        various routines. (see \nt\public\sdk\inc\ntsdexts.h)
        typedef struct _NTSD_EXTENSION_APIS {
            DWORD nSize;
            PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
            PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
            PNTSD_GET_SYMBOL lpGetSymbolRoutine;
            PNTSD_DISASM lpDisasmRoutine;
            PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
        } NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

    lpArgumentString - This is a pointer to a string that contains
        space seperated arguments that are passed to debugger
        extension function.

Return Value:
    none

--*/
{
    DWORD               pDatabaseAnchor;
    SERVICE_RECORD      ServiceRecord;
    LPSERVICE_RECORD    pServiceRecord;
    DWORD               numBytes=0;
    DWORD               numEntries=0;
    LPSTR               pToken;

    InitFunctionPointers(hCurrentProcess, lpExtensionApis);

    printf("ArgumentString = %s\n\n",lpArgumentString);

    //
    // Get the address of the top of the Service Database.
    //
    pDatabaseAnchor = (lpGetExpressionRoutine)("ServiceDatabase");

    //
    // Get the first service record.
    // This is a dummy record that points to the first real record.
    //
    GET_DATA(pDatabaseAnchor, &ServiceRecord, sizeof(ServiceRecord))
    pServiceRecord = ServiceRecord.Next;

    if (_strnicmp(lpArgumentString, "name=", 5) == 0) {
        //--------------------------------------
        // Find a particular Service Record
        // based on Name.
        //--------------------------------------
        pToken = strtok(lpArgumentString+6," ,\t\n");
        if (pToken == NULL) {
            printf("A Name was not given\n");
            return;
        }
        if (FindServiceRecordByName(pToken, &pServiceRecord)) {
            DumpFwdDependentNames(pServiceRecord);
        }
    }
    else if (_strnicmp(lpArgumentString, "address=", 8) == 0) {
        //--------------------------------------
        // Find a particular Service Record
        // based on Address.
        //--------------------------------------
        pToken = strtok(lpArgumentString+9," ,\t\n");
        if (pToken == NULL) {
            printf("An Address was not given\n");
            return;
        }
        else {
            LPSERVICE_RECORD    ServiceAddress;
            LPSTR               pMore;

            ServiceAddress = (LPSERVICE_RECORD)strtoul(pToken, &pMore, 16);
            printf("pToken =  %s\n",pToken);
            printf("strtoul on Service Address yields %d(decimal) %x(hex)\n",
                ServiceAddress, ServiceAddress);

            DumpFwdDependentNames(ServiceAddress);
        }
    }
    return;
}

VOID
BackDepend(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++
Routine Description:
    Dump Service Record Dependencies.

Arguments:
    hCurrentProcess - Handle for the process being debugged.

    hCurrentThread - Handle for the thread that has the debugger focus.

    dwCurrentPc - Current Program Counter?

    lpExtensionApis - Pointer to a structure that contains pointers to
        various routines. (see \nt\public\sdk\inc\ntsdexts.h)
        typedef struct _NTSD_EXTENSION_APIS {
            DWORD nSize;
            PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
            PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
            PNTSD_GET_SYMBOL lpGetSymbolRoutine;
            PNTSD_DISASM lpDisasmRoutine;
            PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
        } NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

    lpArgumentString - This is a pointer to a string that contains
        space seperated arguments that are passed to debugger
        extension function.

Return Value:
    none

--*/
{
    DWORD               pDatabaseAnchor;
    SERVICE_RECORD      ServiceRecord;
    LPSERVICE_RECORD    pServiceRecord;
    DWORD               numBytes=0;
    DWORD               numEntries=0;
    LPSTR               pToken;

    InitFunctionPointers(hCurrentProcess, lpExtensionApis);

    printf("ArgumentString = %s\n\n",lpArgumentString);

    //
    // Get the address of the top of the Service Database.
    //
    pDatabaseAnchor = (lpGetExpressionRoutine)("ServiceDatabase");

    //
    // Get the first service record.
    // This is a dummy record that points to the first real record.
    //
    GET_DATA(pDatabaseAnchor, &ServiceRecord, sizeof(ServiceRecord))
    pServiceRecord = ServiceRecord.Next;

    if (_strnicmp(lpArgumentString, "name=", 5) == 0) {
        //--------------------------------------
        // Find a particular Service Record
        // based on Name.
        //--------------------------------------
        pToken = strtok(lpArgumentString+6," ,\t\n");
        if (pToken == NULL) {
            printf("A Name was not given\n");
            return;
        }
        if (FindServiceRecordByName(pToken, &pServiceRecord)) {
            printf("Backwards dependencies:\n");
            DumpBkwdDependentNames(pServiceRecord);
        }
    }
    else if (_strnicmp(lpArgumentString, "address=", 8) == 0) {
        //--------------------------------------
        // Find a particular Service Record
        // based on Address.
        //--------------------------------------
        pToken = strtok(lpArgumentString+9," ,\t\n");
        if (pToken == NULL) {
            printf("An Address was not given\n");
            return;
        }
        else {
            LPSERVICE_RECORD    ServiceAddress;
            LPSTR               pMore;

            ServiceAddress = (LPSERVICE_RECORD)strtoul(pToken, &pMore, 16);
            printf("pToken =  %s\n",pToken);
            printf("strtoul on Service Address yields %d(decimal) %x(hex)\n",
                ServiceAddress, ServiceAddress);

            DumpBkwdDependentNames(ServiceAddress);
        }
    }
    return;
}

VOID
ImageRecord(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++
Routine Description:
    Dump ImageRecords.

Arguments:
    hCurrentProcess - Handle for the process being debugged.

    hCurrentThread - Handle for the thread that has the debugger focus.

    dwCurrentPc - Current Program Counter?

    lpExtensionApis - Pointer to a structure that contains pointers to
        various routines. (see \nt\public\sdk\inc\ntsdexts.h)
        typedef struct _NTSD_EXTENSION_APIS {
            DWORD nSize;
            PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
            PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
            PNTSD_GET_SYMBOL lpGetSymbolRoutine;
            PNTSD_DISASM lpDisasmRoutine;
            PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
        } NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

    lpArgumentString - This is a pointer to a string that contains
        space seperated arguments that are passed to debugger
        extension function.

Return Value:
    none

--*/
{
    DWORD               pDatabaseAnchor;
    IMAGE_RECORD        ImageRecord;
    LPIMAGE_RECORD      pImageRecord;
    DWORD               numBytes=0;
    DWORD               numEntries=0;

    InitFunctionPointers(hCurrentProcess, lpExtensionApis);

    printf("ArgumentString = %s\n\n",lpArgumentString);

    //
    // Get the address of the top of the Service Database.
    //
    pDatabaseAnchor = (lpGetExpressionRoutine)("ImageDatabase");

    //
    // Get the first service record.
    // This is a dummy record that points to the first real record.
    //
    GET_DATA(pDatabaseAnchor, &ImageRecord, sizeof(ImageRecord))
    pImageRecord = ImageRecord.Next;

    if (_strnicmp(lpArgumentString, "mem", 3) == 0) {
        //--------------------------------------
        // Dump Memory Usage only.
        //--------------------------------------
        do {
            pImageRecord = DumpImageRecord(
                                hCurrentProcess,
                                pImageRecord,
                                &numBytes,
                                TRUE);
            numEntries++;
        } while (pImageRecord != NULL);
        printf("NumIRBytes = %d\n",numBytes);
        printf("NumEntries = %d\n",numEntries);
    }

    else if (_strnicmp(lpArgumentString, "name=", 5) == 0) {

    }
    else {
        //--------------------------------------
        // Dump All Image Records.
        //--------------------------------------
        do {
            pImageRecord = DumpImageRecord(
                                hCurrentProcess,
                                pImageRecord,
                                &numBytes,
                                FALSE);
            numEntries++;
        } while (pImageRecord != NULL);

        printf("NumIRBytes   = %d\n",numBytes);
        printf("NumEntries   = %d\n",numEntries);
    }
    return;
}

VOID
GroupRecord(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++
Routine Description:
    Dump GroupRecords.

Arguments:
    hCurrentProcess - Handle for the process being debugged.

    hCurrentThread - Handle for the thread that has the debugger focus.

    dwCurrentPc - Current Program Counter?

    lpExtensionApis - Pointer to a structure that contains pointers to
        various routines. (see \nt\public\sdk\inc\ntsdexts.h)
        typedef struct _NTSD_EXTENSION_APIS {
            DWORD nSize;
            PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
            PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
            PNTSD_GET_SYMBOL lpGetSymbolRoutine;
            PNTSD_DISASM lpDisasmRoutine;
            PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
        } NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

    lpArgumentString - This is a pointer to a string that contains
        space seperated arguments that are passed to debugger
        extension function.

Return Value:
    none

--*/
{
    DWORD               pDatabaseAnchor;
    DWORD               pStandaloneAnchor;
    LOAD_ORDER_GROUP    StandaloneGroupRecord;
    LOAD_ORDER_GROUP    GroupRecord;
    LPLOAD_ORDER_GROUP  pStandaloneGroupRecord;
    LPLOAD_ORDER_GROUP  pGroupRecord;
    DWORD               numBytes=0;
    DWORD               numEntries=0;

    InitFunctionPointers(hCurrentProcess, lpExtensionApis);

    printf("ArgumentString = %s\n\n",lpArgumentString);

    //
    // Get the address of the top of the Service Database.
    //
    pDatabaseAnchor = (lpGetExpressionRoutine)("OrderGroupList");
    pStandaloneAnchor = (lpGetExpressionRoutine)("StandaloneGroupList");

    //
    // Get the first service record.
    // This is a dummy record that points to the first real record.
    //
    GET_DATA(pDatabaseAnchor, &GroupRecord, sizeof(GroupRecord))
    pGroupRecord = GroupRecord.Next;
    GET_DATA(pStandaloneAnchor, &StandaloneGroupRecord, sizeof(GroupRecord))
    pStandaloneGroupRecord = StandaloneGroupRecord.Next;

    if (_strnicmp(lpArgumentString, "mem", 3) == 0) {
        //--------------------------------------
        // Dump Memory Usage only.
        //--------------------------------------
        printf("ORDER GROUP LIST:\n");
        do {
            pGroupRecord = DumpGroupRecord(
                                hCurrentProcess,
                                pGroupRecord,
                                &numBytes,
                                TRUE);
            numEntries++;
        } while (pGroupRecord != NULL);

        printf("STANDALONE GROUP LIST:\n");
        pGroupRecord = pStandaloneGroupRecord;
        do {
            pGroupRecord = DumpGroupRecord(
                                hCurrentProcess,
                                pGroupRecord,
                                &numBytes,
                                TRUE);
            numEntries++;
        } while (pGroupRecord != NULL);
        printf("NumGRBytes = %d\n",numBytes);
        printf("NumEntries = %d\n",numEntries);
    }

    else if (_strnicmp(lpArgumentString, "name=", 5) == 0) {

    }
    else {
        //--------------------------------------
        // Dump All Group Records.
        //--------------------------------------
        printf("ORDER GROUP LIST:\n");
        do {
            pGroupRecord = DumpGroupRecord(
                                hCurrentProcess,
                                pGroupRecord,
                                &numBytes,
                                FALSE);
            numEntries++;
        } while (pGroupRecord != NULL);

        printf("STANDALONE GROUP LIST:\n");
        pGroupRecord = pStandaloneGroupRecord;
        do {
            pGroupRecord = DumpGroupRecord(
                                hCurrentProcess,
                                pGroupRecord,
                                &numBytes,
                                FALSE);
            numEntries++;
        } while (pGroupRecord != NULL);

        printf("NumGRBytes   = %d\n",numBytes);
        printf("NumEntries   = %d\n",numEntries);
    }

    return;
}

BOOL
FindServiceRecordByName(
    LPSTR               ServiceName,
    LPSERVICE_RECORD    *pServiceRecord
    )

/*++

Routine Description:


Arguments:

    ServiceName - This is the name of the service that we are looking for.

    pServiceRecord - A pointer to a location to where the pointer to the
        service record is to be placed.

Return Value:
    TRUE - Success
    FALSE - The name couldn't be found in any of the service records.

--*/
{
    SERVICE_RECORD      ServiceRecord;
    WCHAR               StringBuffer[200];
    LPWSTR              uniNameString;

    if (!ConvertToUnicode(&uniNameString,ServiceName)) {
        printf("Could not convert to unicode\n");
        return(FALSE);
    }
    //
    // Find a Service Record that matches the name in the uniNameString.
    //
    do {
        //
        // Map the memory for the service record into our process.
        //
        GET_DATA(*pServiceRecord, &ServiceRecord, sizeof(ServiceRecord))

        //
        // Get the ServiceName String.
        //
        GET_STRING(ServiceRecord.ServiceName, StringBuffer, sizeof(StringBuffer))
        if (_wcsicmp(StringBuffer, uniNameString) == 0) {
                //
            // If a name match was found, return SUCCESS.
            //
            LocalFree(uniNameString);
            return(TRUE);
        }
        *pServiceRecord = ServiceRecord.Next;
    } while (*pServiceRecord != NULL);

    LocalFree(uniNameString);
    return(FALSE);
}

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    )

/*++

Routine Description:

    This function translates an AnsiString into a Unicode string.
    A new string buffer is created by this function.  If the call to
    this function is successful, the caller must take responsibility for
    the unicode string buffer that was allocated by this function.
    The allocated buffer should be free'd with a call to LocalFree.

    NOTE:  This function allocates memory for the Unicode String.

Arguments:

    AnsiIn - This is a pointer to an ansi string that is to be converted.

    UnicodeOut - This is a pointer to a location where the pointer to the
        unicode string is to be placed.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{

    NTSTATUS        ntStatus;
    DWORD           bufSize;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Allocate a buffer for the unicode string.
    //

    bufSize = (strlen(AnsiIn)+1) * sizeof(WCHAR);

    *UnicodeOut = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (UINT)bufSize);

    if (*UnicodeOut == NULL) {
        printf("ScConvertToUnicode:LocalAlloc Failure %ld\n",GetLastError());
        return(FALSE);
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString( &ansiString, AnsiIn);

    unicodeString.Buffer = *UnicodeOut;
    unicodeString.MaximumLength = (USHORT)bufSize;
    unicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlAnsiStringToUnicodeString (
                &unicodeString,     // Destination
                &ansiString,        // Source
                (BOOLEAN)FALSE);    // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {

        printf("ScConvertToUnicode:RtlAnsiStringToUnicodeString Failure %lx\n",
        ntStatus);

        return(FALSE);
    }

    //
    // Fill in the pointer location with the unicode string buffer pointer.
    //
    *UnicodeOut = unicodeString.Buffer;

    return(TRUE);

}

LPSERVICE_RECORD
DumpServiceRecord(
    HANDLE              hCurrentProcess,
    LPSERVICE_RECORD    pServiceRecord,
    LPDWORD             NumBytes,        // number of bytes in ServiceRecord.
    LPDWORD             NumDependBytes,  // number of bytes in DependRecords.
    BOOL                JustSizeInfo
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    SERVICE_RECORD      ServiceRecord;
    WCHAR               StringBuffer[200];
    DWORD               NameStringSize;
    DWORD               EntrySize=0;
    DWORD               DependEntrySize=0;
    DWORD               numDependStructs=0;

    //------------------------------------------
    // Dump Size information only.
    //------------------------------------------
    if (JustSizeInfo) {
        EntrySize += sizeof(SERVICE_RECORD);
        GET_DATA(pServiceRecord, &ServiceRecord, sizeof(ServiceRecord))
        GET_STRING(ServiceRecord.ServiceName, StringBuffer, sizeof(StringBuffer))
        NameStringSize = WCSSIZE(StringBuffer);
        EntrySize += NameStringSize;
        printf("\t\t\t\tAddress = 0x%lx\r%ws\n",pServiceRecord,StringBuffer);
#ifdef remove
        if (NameStringSize < 22) {
            printf("\t");
        }
#endif
        GET_STRING(ServiceRecord.DisplayName, StringBuffer, sizeof(StringBuffer))
        if (ServiceRecord.DisplayName != ServiceRecord.DisplayName) {
            EntrySize += WCSSIZE(StringBuffer);
        }
        if (ServiceRecord.Dependencies != NULL) {
            GET_STRING(ServiceRecord.Dependencies, StringBuffer, sizeof(StringBuffer))
            EntrySize += WCSSIZE(StringBuffer);
        }
        GetDependTreeSize(&ServiceRecord,&numDependStructs, &DependEntrySize, TRUE);
        GetDependTreeSize(&ServiceRecord,&numDependStructs, &DependEntrySize, FALSE);


        *NumBytes += EntrySize;
        printf("  SRBytes=%d DependBytes=%d TotalBytes=%d\n",
            EntrySize,
            DependEntrySize,
            *NumBytes);

        *NumDependBytes += DependEntrySize;
        return (ServiceRecord.Next);
    }
    //------------------------------------------
    // Dump other information.
    //------------------------------------------
    *NumBytes += sizeof(SERVICE_RECORD);
    //
    // Map the memory for the service record into our process.
    //
    GET_DATA(pServiceRecord, &ServiceRecord, sizeof(ServiceRecord))

    //
    // Get the ServiceName and DisplayName Strings.
    //
    GET_STRING(ServiceRecord.ServiceName, StringBuffer, sizeof(StringBuffer))
    NameStringSize = WCSSIZE(StringBuffer);
    *NumBytes += NameStringSize;

    printf("ServiceName     : %ws        (0x%lx)\n",StringBuffer,pServiceRecord);

    GET_STRING(ServiceRecord.DisplayName, StringBuffer, sizeof(StringBuffer))
    if (ServiceRecord.DisplayName != ServiceRecord.DisplayName) {
        *NumBytes += WCSSIZE(StringBuffer);
    }
    printf("DisplayName     : %ws\n",StringBuffer);

    printf("ResumeNum       : %d\t\t", ServiceRecord.ResumeNum);
    printf("ServerAnnounce  : %d\n", ServiceRecord.ServerAnnounce);
    printf("Signature       : 0x%lx\t", ServiceRecord.Signature);
    printf("UseCount        : %d\n", ServiceRecord.UseCount);
    printf("StatusFlag      : %d\t\t",ServiceRecord.StatusFlag);
    printf("pImageRecord    : 0x%lx\n",ServiceRecord.ImageRecord);

    printf(" **** STATUS **** \n"
           " dwServiceType       : 0x%lx\t",ServiceRecord.ServiceStatus.dwServiceType);
    printf("dwCurrentState  : 0x%lx\n",ServiceRecord.ServiceStatus.dwCurrentState);
    printf(" dwControlsAccepted  : 0x%lx\t",ServiceRecord.ServiceStatus.dwControlsAccepted);
    printf("dwWin32ExitCode : 0x%lx\n",ServiceRecord.ServiceStatus.dwWin32ExitCode);
    printf(" dwSpecificExitCode  : 0x%lx\t",ServiceRecord.ServiceStatus.dwServiceSpecificExitCode);
    printf("dwCheckPoint    : 0x%lx\n",ServiceRecord.ServiceStatus.dwCheckPoint);
    printf(" dwWaitHint          : 0x%lx\n",ServiceRecord.ServiceStatus.dwWaitHint);

    printf("StartType       : %d\t\t",ServiceRecord.StartType);
    printf("ErrorControl    : %d\n",ServiceRecord.ErrorControl);
    printf("Tag             : 0x%x\t\t",ServiceRecord.Tag);
    printf("StartDepend     : 0x%lx\n",ServiceRecord.StartDepend);
    if (ServiceRecord.StopDepend > (LPDEPEND_RECORD)10) {
        printf("StopDepend      : 0x%lx\t",ServiceRecord.StopDepend);
    }
    else {
        printf("StopDepend      : 0x%lx\t\t",ServiceRecord.StopDepend);
    }

    if (ServiceRecord.Dependencies != NULL) {
        GET_STRING(ServiceRecord.Dependencies, StringBuffer, sizeof(StringBuffer))
        *NumBytes += WCSSIZE(StringBuffer);
        printf("Dependencies    : %ws\n",StringBuffer);
    }
    else {
        printf("Dependencies    : (none)\n");
    }

    printf("pServiceSd      : 0x%lx\t",ServiceRecord.ServiceSd);
    printf("StartError      : %d\n",ServiceRecord.StartError);
    printf("StartState      : 0x%lx\t\t",ServiceRecord.StartState);
    printf("pMemberOfGroup  : 0x%lx\n",ServiceRecord.MemberOfGroup);
    printf("pRegistryGroup  : 0x%lx\n",ServiceRecord.RegistryGroup);
    printf("pCrashRecord    : 0x%lx\n\n",ServiceRecord.CrashRecord);

    GetDependTreeSize(&ServiceRecord,&numDependStructs, NumBytes, TRUE);
    GetDependTreeSize(&ServiceRecord,&numDependStructs, NumBytes, FALSE);


    return (ServiceRecord.Next);
}

LPIMAGE_RECORD
DumpImageRecord(
    HANDLE              hCurrentProcess,
    LPIMAGE_RECORD      pImageRecord,
    LPDWORD             NumBytes,        // number of bytes in ImageRecord.
    BOOL                JustSizeInfo
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    IMAGE_RECORD        ImageRecord;
    WCHAR               StringBuffer[200];
    DWORD               NameStringSize;
    DWORD               EntrySize=0;
    DWORD               DependEntrySize=0;
    DWORD               numDependStructs=0;

    //------------------------------------------
    // Dump Size information only.
    //------------------------------------------
    if (JustSizeInfo) {
        EntrySize += sizeof(IMAGE_RECORD);
        GET_DATA(pImageRecord, &ImageRecord, sizeof(ImageRecord))
        GET_STRING(ImageRecord.ImageName, StringBuffer, sizeof(StringBuffer))
        NameStringSize = WCSSIZE(StringBuffer);
        EntrySize += NameStringSize;
        printf("%ws \tAddress = 0x%lx\n",StringBuffer,pImageRecord);
#ifdef remove
        if (NameStringSize < 22) {
            printf("\t");
        }
#endif
        *NumBytes += EntrySize;
        printf("  IRBytes=%d TotalBytes=%d\n",EntrySize,*NumBytes);
        return (ImageRecord.Next);
    }
    //------------------------------------------
    // Dump other information.
    //------------------------------------------
    *NumBytes += sizeof(IMAGE_RECORD);
    //
    // Map the memory for the service record into our process.
    //
    GET_DATA(pImageRecord, &ImageRecord, sizeof(ImageRecord))

    //
    // Get the ImageName and DisplayName Strings.
    //
    GET_STRING(ImageRecord.ImageName, StringBuffer, sizeof(StringBuffer))
    NameStringSize = WCSSIZE(StringBuffer);
    *NumBytes += NameStringSize;

    printf("ImageName         : %ws        (0x%lx)\n",StringBuffer,pImageRecord);

    printf("  Pid             : %d\t\t", ImageRecord.Pid);
    printf("ServiceCount    : %d\n", ImageRecord.ServiceCount);
    printf("  PipeHandle      : 0x%lx\t", ImageRecord.PipeHandle);
    printf("ProcessHandle   : 0x%lx\n", ImageRecord.ProcessHandle);
    printf("  StatusFlag      : 0x%lx\n",ImageRecord.TokenHandle);

    return (ImageRecord.Next);
}

LPLOAD_ORDER_GROUP
DumpGroupRecord(
    HANDLE              hCurrentProcess,
    LPLOAD_ORDER_GROUP  pGroupRecord,
    LPDWORD             NumBytes,        // number of bytes in GroupRecord.
    BOOL                JustSizeInfo
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    LOAD_ORDER_GROUP    GroupRecord;
    WCHAR               StringBuffer[200];
    DWORD               NameStringSize;
    DWORD               EntrySize=0;
    DWORD               DependEntrySize=0;
    DWORD               numDependStructs=0;

    //------------------------------------------
    // Dump Size information only.
    //------------------------------------------
    if (JustSizeInfo) {
        EntrySize += sizeof(LOAD_ORDER_GROUP);
        GET_DATA(pGroupRecord, &GroupRecord, sizeof(GroupRecord))
        GET_STRING(GroupRecord.GroupName, StringBuffer, sizeof(StringBuffer))
        NameStringSize = WCSSIZE(StringBuffer);
        EntrySize += NameStringSize;
        printf("\t\t\t\tAddress = 0x%lx\r%ws\n",pGroupRecord,StringBuffer);
        *NumBytes += EntrySize;
        printf("  GRBytes=%d TotalBytes=%d\n",EntrySize,*NumBytes);
        return (GroupRecord.Next);
    }
    //------------------------------------------
    // Dump other information.
    //------------------------------------------
    *NumBytes += sizeof(LOAD_ORDER_GROUP);
    //
    // Map the memory for the service record into our process.
    //
    GET_DATA(pGroupRecord, &GroupRecord, sizeof(GroupRecord))

    //
    // Get the GroupName and DisplayName Strings.
    //
    GET_STRING(GroupRecord.GroupName, StringBuffer, sizeof(StringBuffer))
    NameStringSize = WCSSIZE(StringBuffer);
    *NumBytes += NameStringSize;

    printf("GroupName         : %ws (0x%lx)\n",StringBuffer,pGroupRecord);
    printf("  RefCount        : %d\n", GroupRecord.RefCount);

    return (GroupRecord.Next);
}

VOID
GetDependTreeSize(
    LPSERVICE_RECORD    pServiceRecord,
    LPDWORD             pNumDependStructs,
    LPDWORD             pNumBytes,
    BOOL                StartDepend
    )

/*++

Routine Description:

    pServiceRecord - This is a pointer to a ServiceRecord that is already
        mapped into our address space.
    pNumDependStructs -
    pNumBytes -
    StartDepend - TRUE indicates to look through StartDepend list.
        FALSE indicates to look through StopDepend list.

Arguments:


Return Value:


--*/
{
    DEPEND_RECORD       DependRecord;
    BOOL                MoreRecords=TRUE;

    if (StartDepend) {
        if (pServiceRecord->StartDepend == NULL) {
            return;
        }
        printf("  StartDependRecordAddress = 0x%x\n",pServiceRecord->StartDepend);
        GET_DATA(pServiceRecord->StartDepend, &DependRecord, sizeof(DependRecord))
    }
    else {
        if (pServiceRecord->StopDepend == NULL) {
            return;
        }
        printf("  StopDependRecordAddress  = 0x%x\n",pServiceRecord->StopDepend);
        GET_DATA(pServiceRecord->StopDepend, &DependRecord, sizeof(DependRecord))
    }

    if (pServiceRecord->StartDepend != NULL) {
        do  {
            *pNumBytes += sizeof(DependRecord);
            (*pNumDependStructs)++;

            if (DependRecord.Next != NULL) {
                printf("    DependRecordAddress    = 0x%x\n",DependRecord.Next);
                GET_DATA(DependRecord.Next, &DependRecord, sizeof(DependRecord))
            }
            else {
                MoreRecords = FALSE;
            }
        } while ((MoreRecords) && (*pNumDependStructs < 50));
    }
}

VOID
DumpFwdDependentNames(
    LPSERVICE_RECORD    pServiceRecord
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    SERVICE_RECORD      ServiceRecord;
    DEPEND_RECORD       DependRecord;
    LOAD_ORDER_GROUP    GroupRecord;
    UNRESOLVED_DEPEND   UnresolvedRecord;
    WCHAR               StringBuffer[200];
    static CHAR         LeadingSpaces[80]="";
    BOOL                MoreRecords=TRUE;

    //
    // Map the memory for the service record into our process.
    //
    GET_DATA(pServiceRecord, &ServiceRecord, sizeof(ServiceRecord))

    //
    // Get the ServiceName String.
    //
    GET_STRING(ServiceRecord.ServiceName, StringBuffer, sizeof(StringBuffer))
    printf("%s%ws (service) depends on: \t\n",LeadingSpaces,StringBuffer);

    strcat(LeadingSpaces,"  ");

    if (ServiceRecord.StartDepend != NULL) {
        GET_DATA(ServiceRecord.StartDepend, &DependRecord, sizeof(DependRecord))
        do  {
            switch (DependRecord.DependType) {
            case TypeDependOnService:
                DumpFwdDependentNames(DependRecord.DependService);
                break;
            case TypeDependOnGroup:
                GET_DATA(DependRecord.DependGroup, &GroupRecord, sizeof(GroupRecord))
                GET_STRING(GroupRecord.GroupName, StringBuffer, sizeof(StringBuffer))
                printf("%s%ws (group)\n", LeadingSpaces,StringBuffer);
                break;
            case TypeDependOnUnresolved:
                GET_DATA(DependRecord.DependUnresolved, &UnresolvedRecord, sizeof(UnresolvedRecord))
                GET_STRING(UnresolvedRecord.Name, StringBuffer, sizeof(StringBuffer))
                printf("%s%ws (unresolved)\n", LeadingSpaces,StringBuffer);
                break;
            default:
                printf("%s(Unknown Depend Type)\n",LeadingSpaces);
                MoreRecords = FALSE;
                break;
            }

            if (DependRecord.Next != NULL) {
                GET_DATA(DependRecord.Next, &DependRecord, sizeof(DependRecord))
            }
            else {
                MoreRecords = FALSE;
            }
        } while (MoreRecords);

    }
    else {
        printf("%s(nothing)\n",LeadingSpaces);
    }
    LeadingSpaces[strlen(LeadingSpaces)-2] = '\0';
}

VOID
DumpBkwdDependentNames(
    LPSERVICE_RECORD    pServiceRecord
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    SERVICE_RECORD      ServiceRecord;
    DEPEND_RECORD       DependRecord;
    LOAD_ORDER_GROUP    GroupRecord;
    UNRESOLVED_DEPEND   UnresolvedRecord;
    WCHAR               StringBuffer[200];
    static CHAR         LeadingSpaces[80]="";
    BOOL                MoreRecords=TRUE;

    //
    // Map the memory for the service record into our process.
    //
    GET_DATA(pServiceRecord, &ServiceRecord, sizeof(ServiceRecord))

    //
    // Get the ServiceName String.
    //
    GET_STRING(ServiceRecord.ServiceName, StringBuffer, sizeof(StringBuffer))
    printf("%s%ws (service): \t\n",LeadingSpaces,StringBuffer);

    strcat(LeadingSpaces,"  ");

    if (ServiceRecord.StopDepend != NULL) {
        GET_DATA(ServiceRecord.StopDepend, &DependRecord, sizeof(DependRecord))
        do  {
            switch (DependRecord.DependType) {
            case TypeDependOnService:
                DumpBkwdDependentNames(DependRecord.DependService);
                break;
            case TypeDependOnGroup:
                GET_DATA(DependRecord.DependGroup, &GroupRecord, sizeof(GroupRecord))
                GET_STRING(GroupRecord.GroupName, StringBuffer, sizeof(StringBuffer))
                printf("%s%ws (group)\n", LeadingSpaces,StringBuffer);
                break;
            case TypeDependOnUnresolved:
                GET_DATA(DependRecord.DependUnresolved, &UnresolvedRecord, sizeof(UnresolvedRecord))
                GET_STRING(UnresolvedRecord.Name, StringBuffer, sizeof(StringBuffer))
                printf("%s%ws (unresolved)\n", LeadingSpaces,StringBuffer);
                break;
            default:
                printf("%s(Unknown Depend Type)\n",LeadingSpaces);
                MoreRecords = FALSE;
                break;
            }

            if (DependRecord.Next != NULL) {
                GET_DATA(DependRecord.Next, &DependRecord, sizeof(DependRecord))
            }
            else {
                MoreRecords = FALSE;
            }
        } while (MoreRecords);

    }
    else {
        printf("%s(nothing)\n",LeadingSpaces);
    }
    LeadingSpaces[strlen(LeadingSpaces)-2] = '\0';
}

VOID
help(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

Routine Description:
    Provides online help for the user of this debugger extension.

Arguments:
    hCurrentProcess - Handle for the process being debugged.

    hCurrentThread - Handle for the thread that has the debugger focus.

    dwCurrentPc - Current Program Counter?

    lpExtensionApis - Pointer to a structure that contains pointers to
        various routines. (see \nt\public\sdk\inc\ntsdexts.h)
        typedef struct _NTSD_EXTENSION_APIS {
            DWORD nSize;
            PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
            PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
            PNTSD_GET_SYMBOL lpGetSymbolRoutine;
            PNTSD_DISASM lpDisasmRoutine;
            PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
        } NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

    lpArgumentString - This is a pointer to a string that contains
        space seperated arguments that are passed to debugger
        extension function.

Return Value:


--*/
{
    InitFunctionPointers(hCurrentProcess, lpExtensionApis);

    printf("\nService Controller NTSD Extensions\n");

    if (!lpArgumentString || *lpArgumentString == '\0' ||
        *lpArgumentString == '\n' || *lpArgumentString == '\r')
    {
        printf("\tServiceRecord - dump a ServiceRecord structure\n");
        printf("\tDependencies  - dump a Service's Dependencies\n");
        printf("\tBackDepend    - dump a Service's that depend on this service\n");
        printf("\tImageRecord   - dump an ImageRecord structure\n");
        printf("\tGroupRecord   - dump a GroupRecord structure\n");
        printf("\n\tEnter help <cmd> for detailed help on a command\n");
    }
    else if (!_stricmp(lpArgumentString, "ServiceRecord")) {
            printf("\tServiceRecord <arg>, where <arg> can be one of:\n");
            printf("\t\tno argument        - dump all ServiceRecord structures\n");
            printf("\t\tmem                - dump ServiceRecord Address Info only\n");
            printf("\t\tname= <name>       - dump the ServiceRecord for <name>\n");
            printf("\t\taddress= <address> - dump the ServiceRecord at specified address\n");
    }
    else if (!_stricmp(lpArgumentString, "Dependencies")) {
            printf("\tDependencies <arg>, where <arg> can be one of:\n");
            printf("\t\tname= <name>       - dump the Dependency Chain for <name>\n");
            printf("\t\taddress= <address> - dump the Dependency Chain for address\n");
    }
    else if (!_stricmp(lpArgumentString, "BackDepend")) {
            printf("\tDependencies <arg>, where <arg> can be one of:\n");
            printf("\t\tname= <name>       - dump the Dependency Chain for <name>\n");
            printf("\t\taddress= <address> - dump the Dependency Chain for address\n");
    }
    else if (!_stricmp(lpArgumentString, "ImageRecord")) {
            printf("\t\tmem                - dump ImageRecord Memory Info only\n");
    }
    else if (!_stricmp(lpArgumentString, "GroupRecord")) {
            printf("\t\tmem                - dump GroupRecord Memory Info only\n");
    }
    else {
        printf("\tInvalid command [%s]\n", lpArgumentString);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\sctest\locktest.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    LockTest.c

Abstract:

    This file contains tests of the Service Controller's lock APIs:

        RLockServiceDatabase
        RQueryServiceLockStatusW
        RUnlockServiceDatabase

Author:

    John Rogers (JohnRo) 15-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    15-Apr-1992 JohnRo
        Created.
    21-Apr-1992 JohnRo
        Split-out lock test functions.

--*/


//
// INCLUDES
//

#define UNICODE

#include <windows.h>

#include <assert.h>     // assert().
#include <debugfmt.h>   // FORMAT_ equates.
#include <winsvc.h>
#include <scdebug.h>    // STATIC.
#include <sctest.h>     // TRACE_MSG macros, UNEXPECTED_MSG(), etc.
#include <stdio.h>      // printf()


#define BUF_SIZE  1024   // arbitrary


STATIC VOID
DumpLockStatus(
    IN LPQUERY_SERVICE_LOCK_STATUS LockStatus
    )
{
    (VOID) printf( "Lock status:\n" );

    (VOID) printf( "  Locked: " FORMAT_LPSTR "\n",
        (LockStatus->fIsLocked) ? "yes" : "no" );

    (VOID) printf( "  LockOwner: " FORMAT_LPWSTR "\n",
        (LockStatus->lpLockOwner != NULL) ? LockStatus->lpLockOwner : L"NONE" );

    (VOID) printf( "  lock duration: " FORMAT_DWORD "\n",
        LockStatus->dwLockDuration );

} // DumpLockStatus

STATIC VOID
GetAndDisplayLockStatus(
    IN LPSTR Comment,
    IN SC_HANDLE hScManager
    )
{
    BYTE buffer[BUF_SIZE];
    LPQUERY_SERVICE_LOCK_STATUS lockStatus = (LPVOID) &buffer[0];
    DWORD sizeNeed;

    TRACE_MSG1( "calling QueryServiceLockStatus " FORMAT_LPSTR "...\n",
            Comment );

    if ( !QueryServiceLockStatus(hScManager, lockStatus, BUF_SIZE, &sizeNeed)) {
        UNEXPECTED_MSG( "from QueryServiceLockStatus (default)",
                GetLastError() );
        assert( FALSE );
    }

    DumpLockStatus( lockStatus );

}

VOID
TestLocks(
    VOID
    )
{
    SC_HANDLE hScManager = NULL;
    SC_LOCK lock;

    ///////////////////////////////////////////////////////////////////

    SetLastError( 149 );
    (VOID) printf( "Force last error is " FORMAT_DWORD "\n", GetLastError() );

    TRACE_MSG1( "handle (before anything) is " FORMAT_HEX_DWORD ".\n",
            (DWORD) hScManager );

    ///////////////////////////////////////////////////////////////////
    TRACE_MSG0( "calling OpenSCManagerW (default)...\n" );

    hScManager = OpenSCManager(
            NULL,               // local machine.
            NULL,               // no database name.
            GENERIC_ALL );      // desired access.

    TRACE_MSG1( "back from OpenSCManagerW, handle is " FORMAT_HEX_DWORD ".\n",
            (DWORD) hScManager );

    if (hScManager == NULL) {
        UNEXPECTED_MSG( "from OpenSCManagerW (default)", GetLastError() );
        goto Cleanup;
    }

    ///////////////////////////////////////////////////////////////////
    GetAndDisplayLockStatus( "default, empty", hScManager );

    ///////////////////////////////////////////////////////////////////
    TRACE_MSG0( "calling LockServiceDatabase (default)...\n" );

    lock = LockServiceDatabase( hScManager );
    TRACE_MSG1( "Got back lock " FORMAT_HEX_DWORD ".\n", (DWORD) lock );
    if (lock == NULL) {
        UNEXPECTED_MSG( "from LockServiceDatabase (default)", GetLastError() );
        goto Cleanup;
    }

    ///////////////////////////////////////////////////////////////////
    GetAndDisplayLockStatus( "default, not empty", hScManager );

    ///////////////////////////////////////////////////////////////////
    TRACE_MSG0( "calling UnlockServiceDatabase (default)...\n" );

    if ( !UnlockServiceDatabase( lock ) ) {
        UNEXPECTED_MSG( "from UnlockServiceDatabase (default)",
                GetLastError() );
        goto Cleanup;
    }

    ///////////////////////////////////////////////////////////////////
    GetAndDisplayLockStatus( "default, empty again", hScManager );

    ///////////////////////////////////////////////////////////////////


Cleanup:

    if (hScManager != NULL) {
        TRACE_MSG0( "calling CloseServiceHandle...\n" );

        if ( !CloseServiceHandle( hScManager ) ) {
            UNEXPECTED_MSG( "from CloseServiceHandle", GetLastError() );
        }

    }

} // TestLocks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\sctest\apitest.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ApiTest.c

Abstract:

    This file contains tests of the Service Controller's lock APIs:

        RLockServiceDatabase
        RQueryServiceLockStatusW
        RUnlockServiceDatabase

Author:

    John Rogers (JohnRo) 15-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    15-Apr-1992 JohnRo
        Created.
    21-Apr-1992 JohnRo
        Added config API tests.
        Split-out lock tests into LockTest.c
        Split-out macros into sctest.h.
    17-Oct-1996 AnirudhS
        Added Config2 API tests.

--*/


//
// INCLUDES
//

#define UNICODE

#include <windows.h>

#include <assert.h>     // assert().
#include <debugfmt.h>   // FORMAT_ equates.
#include <winsvc.h>
#include <sctest.h>     // TRACE_MSG macros, UNEXPECTED_MSG(), etc.
#include <stdio.h>      // printf()
#include <stdlib.h>     // EXIT_ equates.


int __cdecl
main(void)
{

    ///////////////////////////////////////////////////////////////////

    SetLastError( 149 );
    (VOID) printf( "Force last error is " FORMAT_DWORD "\n", GetLastError() );

    ///////////////////////////////////////////////////////////////////
    TRACE_MSG0( "ApiTest: calling TestConfig2APIs...\n" );

    TestConfig2APIs();

    TRACE_MSG0( "ApiTest: back from TestConfig2APIs.\n" );


    ///////////////////////////////////////////////////////////////////
    TRACE_MSG0( "ApiTest: calling TestLocks...\n" );

    TestLocks();

    TRACE_MSG0( "ApiTest: back from TestLocks.\n" );


    ///////////////////////////////////////////////////////////////////
    TRACE_MSG0( "ApiTest: calling TestConfigAPIs...\n" );

    TestConfigAPIs();

    TRACE_MSG0( "ApiTest: back from TestConfigAPIs.\n" );

    ///////////////////////////////////////////////////////////////////

    return (EXIT_SUCCESS);

} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\sctest\conftest.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfTest.c

Abstract:

    This file contains tests of the Service Controller's config APIs:

        ChangeServiceConfig
        CreateService
        DeleteService
        QueryServiceConfig
        TestChangeConfig2
        CompareFailureActions
        TestQueryConfig2
        TestConfig2APIs

Author:

    John Rogers (JohnRo) 22-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    22-Apr-1992 JohnRo
        Created.
    17-Oct-1996 AnirudhS
        Added Config2 API tests.

--*/


//
// INCLUDES
//

// #define UNICODE

#include <windows.h>

#include <assert.h>     // assert().
#include <tchar.h>      // _tcscmp
#include <debugfmt.h>   // FORMAT_ equates.
#include <winsvc.h>
#include <scdebug.h>    // STATIC.
#include <sctest.h>     // TRACE_MSG macros, UNEXPECTED_MSG(), etc.
#include <stdio.h>      // printf()


#define BUF_SIZE  1024   // arbitrary

//#define NEW_SERVICE_NAME        TEXT("FLARP")
#define NEW_SERVICE_NAME        TEXT("Simple")
#define TEST_SERVICE_DESCR      TEXT("A servile service")

#define LENGTH(array)           (sizeof(array)/sizeof((array)[0]))

#define OPTIONAL_LPTSTR(optStr) \
    ( ( (optStr) != NULL ) ? (optStr) : TEXT("(NONE)") )


VOID
DumpServiceConfig(
    IN LPQUERY_SERVICE_CONFIG Config
    )
{
    (VOID) printf( "Service config:\n" );

    (VOID) printf( "  Service type: " FORMAT_HEX_DWORD "\n",
            Config->dwServiceType );

    (VOID) printf( "  Start type: " FORMAT_DWORD "\n",
            Config->dwStartType );

    (VOID) printf( "  Error control: " FORMAT_DWORD "\n",
            Config->dwErrorControl );

    (VOID) printf( "  Binary path: " FORMAT_LPTSTR "\n",
            Config->lpBinaryPathName );

    (VOID) printf( "  Load order group: " FORMAT_LPTSTR "\n",
            OPTIONAL_LPTSTR( Config->lpBinaryPathName ) );

    (VOID) printf( "  Dependencies: " FORMAT_LPTSTR "\n",
            OPTIONAL_LPTSTR( Config->lpBinaryPathName ) );

    (VOID) printf( "  Service start name: " FORMAT_LPTSTR "\n",
            Config->lpBinaryPathName );

} // DumpServiceConfig


SC_HANDLE
TestCreateService(
    IN SC_HANDLE hScManager,
    IN LPTSTR ServiceName,
    IN DWORD ExpectedStatus
    )
{
    DWORD ApiStatus;
    SC_HANDLE hService;

    hService = CreateService(
            hScManager,                   // SC manager handle
            ServiceName,                  // service name
            NULL,                         // display name
            GENERIC_ALL,                  // desired access
            SERVICE_WIN32_OWN_PROCESS,    // service type
            SERVICE_DISABLED,             // start type
            SERVICE_ERROR_NORMAL,         // error control
            TEXT("simple.exe"),           // binary load path name
                // TEXT("\\nt\\system32\\bogus.exe"),// binary load path name
            NULL,                         // no load order group
            NULL,                         // no tag
            NULL,                         // no dependencies
            NULL,                         // start name (domain\username)
                // TEXT(".\\JohnRoDaemon"),          // start name (domain\username)
            NULL);                        // no password.

    if (hService == NULL) {
        ApiStatus = GetLastError();
    } else {
        ApiStatus = NO_ERROR;
    }

    TRACE_MSG2( "TestCreateService: back from CreateService, "
            "API status is " FORMAT_DWORD ", expecting " FORMAT_DWORD "\n",
            ApiStatus, ExpectedStatus );

    assert( ApiStatus == ExpectedStatus );
    return (hService);

}


VOID
TestDeleteService(
    IN SC_HANDLE hScManager,
    IN LPTSTR ServiceName,
    IN DWORD DesiredAccess,
    IN DWORD OpenExpectedStatus,
    IN DWORD DeleteExpectedStatus
    )
{
    DWORD ApiStatus = NO_ERROR;
    SC_HANDLE hService;

    //////////////////////////////////////////////////////////////////////
    hService = OpenService(
            hScManager,
            ServiceName,
            DesiredAccess );
    if (hService == NULL) {
        ApiStatus = GetLastError();
    }

    TRACE_MSG2( "TestDeleteService: back from OpenService, "
            "API status is " FORMAT_DWORD ", expecting " FORMAT_DWORD "\n",
            ApiStatus, OpenExpectedStatus );

    assert( ApiStatus == OpenExpectedStatus );

    if (ApiStatus != NO_ERROR) {
        return;
    }

    //////////////////////////////////////////////////////////////////////
    if ( !DeleteService( hService ) ) {
        ApiStatus = GetLastError();
    }

    TRACE_MSG2( "TestDeleteService: back from DeleteService, "
            "API status is " FORMAT_DWORD ", expecting " FORMAT_DWORD "\n",
            ApiStatus, DeleteExpectedStatus );

    assert( ApiStatus == DeleteExpectedStatus );

    //////////////////////////////////////////////////////////////////////
    if ( !CloseServiceHandle( hService ) ) {
        ApiStatus = GetLastError();
    }

    TRACE_MSG2( "TestDeleteService: back from CloseService, "
            "API status is " FORMAT_DWORD ", expecting " FORMAT_DWORD "\n",
            ApiStatus, NO_ERROR );

    assert( ApiStatus == NO_ERROR );

}


VOID
TestQueryConfig(
    IN SC_HANDLE hService,
    IN DWORD ExpectedStatus
    )
{
    DWORD ApiStatus;
    BYTE buffer[BUF_SIZE];
    DWORD sizeNeeded;

    TRACE_MSG0( "TestQueryConfig: calling QueryServiceConfig...\n" );

    if ( !QueryServiceConfig(
            hService,
            (LPVOID) buffer,
            BUF_SIZE,
            & sizeNeeded ) ) {
        ApiStatus = GetLastError();
    } else {
        ApiStatus = NO_ERROR;
    }

    TRACE_MSG1( "TestQueryConfig: back from QueryServiceConfig, "
            "API status is " FORMAT_DWORD "\n", ApiStatus );

    assert( ApiStatus == ExpectedStatus );

    if (ApiStatus == NO_ERROR) {
        DumpServiceConfig( (LPVOID) buffer );
    }

} // TestQueryConfig


VOID
TestConfigAPIs(
    VOID
    )
{
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    TRACE_MSG1( "handle (before anything) is " FORMAT_HEX_DWORD ".\n",
            (DWORD) hScManager );

    ///////////////////////////////////////////////////////////////////
    TRACE_MSG0( "calling OpenSCManager (default)...\n" );

    hScManager = OpenSCManager(
            NULL,               // local machine.
            NULL,               // no database name.
            GENERIC_ALL );      // desired access.

    TRACE_MSG1( "back from OpenSCManager, handle is " FORMAT_HEX_DWORD ".\n",
            (DWORD) hScManager );

    if (hScManager == NULL) {
        UNEXPECTED_MSG( "from OpenSCManager (default)", GetLastError() );
        goto Cleanup;
    }

    ///////////////////////////////////////////////////////////////////
#ifdef TEST_BINDING_HANDLES
    TestQueryConfig( NULL, ERROR_INVALID_HANDLE );
#endif

    ///////////////////////////////////////////////////////////////////
    TestDeleteService(
            hScManager,
            NEW_SERVICE_NAME,
            DELETE,           // desired access
            ERROR_SERVICE_DOES_NOT_EXIST,
            NO_ERROR );

    ///////////////////////////////////////////////////////////////////
#ifdef TEST_BINDING_HANDLES
    hService = TestCreateService(
            NULL, NEW_SERVICE_NAME, ERROR_INVALID_HANDLE );
#endif

    ///////////////////////////////////////////////////////////////////
    hService = TestCreateService( hScManager, NULL, ERROR_INVALID_NAME );

    ///////////////////////////////////////////////////////////////////
    hService = TestCreateService( hScManager, NEW_SERVICE_NAME, NO_ERROR );
    assert( hService != NULL );

    ///////////////////////////////////////////////////////////////////
    TestQueryConfig( hService, NO_ERROR );

    ///////////////////////////////////////////////////////////////////
    (VOID) TestCreateService( hScManager, NEW_SERVICE_NAME,
            ERROR_SERVICE_EXISTS );

    ///////////////////////////////////////////////////////////////////
    TestDeleteService(
            NULL,
            NEW_SERVICE_NAME,
            DELETE,           // desired access
            ERROR_INVALID_HANDLE,
            NO_ERROR );

    ///////////////////////////////////////////////////////////////////
    TestDeleteService(
            hScManager,
            NULL,
            DELETE,           // desired access
            NO_ERROR,
            ERROR_INVALID_NAME );

    ///////////////////////////////////////////////////////////////////
    TestDeleteService(
            hScManager,
            NEW_SERVICE_NAME,
            GENERIC_READ,           // desired access
            NO_ERROR,
            ERROR_ACCESS_DENIED );

    ///////////////////////////////////////////////////////////////////
    TestDeleteService(
            hScManager,
            NEW_SERVICE_NAME,
            DELETE,           // desired access
            NO_ERROR,
            NO_ERROR );

    ///////////////////////////////////////////////////////////////////
    TestQueryConfig( hService, NO_ERROR );

    ///////////////////////////////////////////////////////////////////
    TestDeleteService(
            hScManager,
            NEW_SERVICE_NAME,
            DELETE,           // desired access
            ERROR_SERVICE_DOES_NOT_EXIST,
            NO_ERROR );


Cleanup:

    if (hService != NULL) {
        TRACE_MSG0( "calling CloseServiceHandle(hService)...\n" );

        if ( !CloseServiceHandle( hService ) ) {
            UNEXPECTED_MSG( "from CloseServiceHandle", GetLastError() );
        }

    }

    if (hScManager != NULL) {
        TRACE_MSG0( "calling CloseServiceHandle(hScManager)...\n" );

        if ( !CloseServiceHandle( hScManager ) ) {
            UNEXPECTED_MSG( "from CloseServiceHandle", GetLastError() );
        }

    }

} // TestConfigAPIs


VOID
TestChangeConfig2(
    IN SC_HANDLE hService,
    IN DWORD dwInfoLevel,
    IN LPVOID lpInfo,
    IN DWORD ExpectedStatus
    )
{
    DWORD ApiStatus;

    TRACE_MSG0( "TestChangeConfig2: Calling ChangeServiceConfig2...\n" );

    if ( !ChangeServiceConfig2( hService, dwInfoLevel, lpInfo ) ) {
        ApiStatus = GetLastError();
    } else {
        ApiStatus = NO_ERROR;
    }

    TRACE_MSG2( "TestChangeConfig2: back from ChangeServiceConfig2, "
            "API status %lu, expecting %lu\n", ApiStatus, ExpectedStatus );

    assert( ApiStatus == ExpectedStatus );

/*
    if (ApiStatus == NO_ERROR) {
        DumpServiceConfig( (LPVOID) buffer );
    }
*/

} // TestChangeConfig2


VOID
CompareFailureActions(
    IN  LPSERVICE_FAILURE_ACTIONS psfa1,    // Expected result buffer
    IN  LPSERVICE_FAILURE_ACTIONS psfa2     // Actual result buffer
    )
{
    if (psfa1 == NULL)
    {
        return;
    }

    assert(psfa2 != NULL);

    assert(psfa1->dwResetPeriod == psfa2->dwResetPeriod);

    if (psfa1->lpRebootMsg)
    {
        assert(_tcscmp(psfa1->lpRebootMsg, psfa2->lpRebootMsg) == 0);
    }
    else
    {
        assert(psfa2->lpRebootMsg == NULL);
    }

    if (psfa1->lpCommand)
    {
        assert(_tcscmp(psfa1->lpCommand,   psfa2->lpCommand) == 0);
    }
    else
    {
        assert(psfa2->lpCommand == NULL);
    }

    assert(psfa1->cActions == psfa2->cActions);
    if (psfa1->cActions)
    {
        DWORD i;
        assert(psfa2->lpsaActions != NULL);
        for (i = 0; i < psfa1->cActions; i++)
        {
            assert(psfa1->lpsaActions[i].Type  == psfa2->lpsaActions[i].Type);
            assert(psfa1->lpsaActions[i].Delay == psfa2->lpsaActions[i].Delay);
        }
    }
    else
    {
        assert(psfa2->lpsaActions == NULL);
    }
}


VOID
TestQueryConfig2(
    IN  SC_HANDLE hService,
    IN  DWORD     dwInfoLevel,		// which configuration data is requested
    OUT LPBYTE    lpBuffer, 		// pointer to service configuration buffer
    IN  DWORD     cbBufSize,		// size of service configuration buffer
    OUT LPDWORD   pcbBytesNeeded, 	// address of variable for bytes needed
    IN  DWORD     ExpectedStatus,
    IN  LPVOID    ExpectedBuffer
    )
{
    DWORD ApiStatus;

    TRACE_MSG0( "TestQueryConfig2: calling QueryServiceConfig2...\n" );

    if ( !QueryServiceConfig2(
            hService,
            dwInfoLevel,
            lpBuffer,
            cbBufSize,
            pcbBytesNeeded ) ) {
        ApiStatus = GetLastError();
    } else {
        ApiStatus = NO_ERROR;
    }

    TRACE_MSG2( "TestQueryConfig2: back from QueryServiceConfig2, "
            "API status %lu, expecting %lu\n", ApiStatus, ExpectedStatus );

    assert( ApiStatus == ExpectedStatus );

    if (ApiStatus == NO_ERROR)
    {
        switch (dwInfoLevel)
        {
        case SERVICE_CONFIG_DESCRIPTION:
            {
                LPSERVICE_DESCRIPTION psd = (LPSERVICE_DESCRIPTION) lpBuffer;
                if (ExpectedBuffer == NULL)
                {
                    assert(psd->lpDescription == NULL);
                }
                else
                {
                    assert(psd->lpDescription != NULL);
                    assert(_tcscmp(psd->lpDescription, (LPTSTR)ExpectedBuffer) == 0);
                }
            }
            break;

        case SERVICE_CONFIG_FAILURE_ACTIONS:
            CompareFailureActions((LPSERVICE_FAILURE_ACTIONS)ExpectedBuffer,
                                  (LPSERVICE_FAILURE_ACTIONS)lpBuffer);
            break;

        default:
            break;
        }
    }
/*
    if (ApiStatus == NO_ERROR) {
        DumpServiceConfig( (LPVOID) buffer );
    }
*/

} // TestQueryConfig2


VOID
TestConfig2APIs(
    VOID
    )
{
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SC_ACTION saActions[] =
    {
        { SC_ACTION_RESTART,        10000 },
        { SC_ACTION_NONE,           42  },
        { SC_ACTION_REBOOT,         500 }
    };
    SERVICE_FAILURE_ACTIONS sfa =
    {
        501,                        // reset period
        TEXT("Put your shoes back on!"), // reboot message
        TEXT("Do badly."),          // failure command
        LENGTH(saActions),          // number of actions
        saActions                   // action array
    };

    BYTE    Buffer[200];
    DWORD   cbBytesNeeded;


    TRACE_MSG1( "handle (before anything) is " FORMAT_HEX_DWORD ".\n",
            (DWORD) hScManager );

    ///////////////////////////////////////////////////////////////////
    TRACE_MSG0( "calling OpenSCManagerW (default)...\n" );

    hScManager = OpenSCManager(
            NULL,               // local machine.
            NULL,               // no database name.
            GENERIC_ALL );      // desired access.

    TRACE_MSG1( "back from OpenSCManagerW, handle is " FORMAT_HEX_DWORD ".\n",
            (DWORD) hScManager );

    if (hScManager == NULL) {
        UNEXPECTED_MSG( "from OpenSCManagerW (default)", GetLastError() );
        goto Cleanup;
    }

    ///////////////////////////////////////////////////////////////////
    TestDeleteService(
            hScManager,
            NEW_SERVICE_NAME,
            DELETE,           // desired access
            ERROR_SERVICE_DOES_NOT_EXIST,
            NO_ERROR );

    ///////////////////////////////////////////////////////////////////
    hService = TestCreateService( hScManager, NEW_SERVICE_NAME, NO_ERROR );
    assert( hService != NULL );

    memset(Buffer, -1, sizeof(Buffer));
    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_DESCRIPTION,
                Buffer,
                sizeof(Buffer),
                &cbBytesNeeded,
                NO_ERROR,
                NULL );

    ///////////////////////////////////////////////////////////////////
    printf("Setting service description\n");
    {
        SERVICE_DESCRIPTION sd = { TEST_SERVICE_DESCR };

        TestChangeConfig2(
                    hService,
                    SERVICE_CONFIG_DESCRIPTION,
                    &sd,
                    NO_ERROR );
    }

    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_DESCRIPTION,
                Buffer,
                sizeof(Buffer),
                &cbBytesNeeded,
                NO_ERROR,
                TEST_SERVICE_DESCR );

    // For consistency with QueryServiceConfig, the API should set
    // cbBytesNeeded even on a success return, even though this is not
    // documented
#ifdef UNICODE
    assert(cbBytesNeeded == sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR));
#else
    assert(cbBytesNeeded >= sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR) &&
           cbBytesNeeded <= sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR)*2);
#endif

    ///////////////////////////////////////////////////////////////////
    printf("Setting service failure actions\n");
    TestChangeConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                &sfa,
                NO_ERROR );

    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                Buffer,
                sizeof(Buffer),
                &cbBytesNeeded,
                NO_ERROR,
                &sfa );

    ///////////////////////////////////////////////////////////////////
    printf("Testing count 3 and NULL pointer to array\n");
    sfa.lpsaActions = NULL;
    TestChangeConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                &sfa,
                NO_ERROR );

    // Resulting config should not have changed
    sfa.lpsaActions = saActions;
    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                Buffer,
                sizeof(Buffer),
                &cbBytesNeeded,
                NO_ERROR,
                &sfa );

    ///////////////////////////////////////////////////////////////////
    printf("Testing count 0 and NULL pointer to array\n");
    sfa.cActions = 0;
    sfa.lpsaActions = NULL;
    TestChangeConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                &sfa,
                NO_ERROR );

    // Resulting config should not have changed
    sfa.cActions = LENGTH(saActions);
    sfa.lpsaActions = saActions;
    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                Buffer,
                sizeof(Buffer),
                &cbBytesNeeded,
                NO_ERROR,
                &sfa );

    ///////////////////////////////////////////////////////////////////
    printf("Testing count 0 and non-NULL pointer to array\n");
    sfa.cActions = 0;
    sfa.lpsaActions = (LPSC_ACTION) 0xfefefefe;   // a bad pointer
    TestChangeConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                &sfa,
                NO_ERROR );

    // Resulting config should have no actions at all
    // However, it should still have a failure command and a reboot message
    sfa.dwResetPeriod = 0;
    sfa.lpsaActions = NULL;
    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                Buffer,
                sizeof(Buffer),
                &cbBytesNeeded,
                NO_ERROR,
                &sfa );

    ///////////////////////////////////////////////////////////////////
    printf("Testing empty failure command and unchanged reboot message\n");
    sfa.lpCommand = TEXT("");
    sfa.lpRebootMsg = NULL;
    TestChangeConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                &sfa,
                NO_ERROR );

    // Resulting config should have an empty failure command
    // However, it should still have a reboot message
    sfa.lpCommand = NULL;
    sfa.lpRebootMsg = TEXT("Put your shoes back on!");
    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                Buffer,
                sizeof(Buffer),
                &cbBytesNeeded,
                NO_ERROR,
                &sfa );

    ///////////////////////////////////////////////////////////////////
    printf("Testing invalid level\n");
    TestChangeConfig2(
                hService,
                101,
                &sfa,
                ERROR_INVALID_LEVEL );

    ///////////////////////////////////////////////////////////////////
    memset(Buffer, -1, sizeof(Buffer));
    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_DESCRIPTION,
                Buffer,
                sizeof(Buffer),     // plenty big buffer
                &cbBytesNeeded,
                NO_ERROR,
                TEST_SERVICE_DESCR );

    ///////////////////////////////////////////////////////////////////
    memset(Buffer, -1, sizeof(Buffer));
    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_DESCRIPTION,
                Buffer,
                sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR),
                                    // just big enough
                &cbBytesNeeded,
                NO_ERROR,
                TEST_SERVICE_DESCR );

    ///////////////////////////////////////////////////////////////////
    memset(Buffer, -1, sizeof(Buffer));
    cbBytesNeeded = 0;
    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_DESCRIPTION,
                Buffer,
                sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR) - 1,
                                    // 1 byte too small
                &cbBytesNeeded,
                ERROR_INSUFFICIENT_BUFFER,
                NULL );

#ifdef UNICODE
    assert(cbBytesNeeded == sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR));
#else
    assert(cbBytesNeeded >= sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR) &&
           cbBytesNeeded <= sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR)*2);
#endif

    ///////////////////////////////////////////////////////////////////
    memset(Buffer, -1, sizeof(Buffer));
    cbBytesNeeded = 0;
    TestQueryConfig2(
                hService,
                SERVICE_CONFIG_DESCRIPTION,
                Buffer,
                0,              // zero size
                &cbBytesNeeded,
                ERROR_INSUFFICIENT_BUFFER,
                NULL );

#ifdef UNICODE
    assert(cbBytesNeeded == sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR));
#else
    assert(cbBytesNeeded >= sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR) &&
           cbBytesNeeded <= sizeof(SERVICE_DESCRIPTION) + sizeof(TEST_SERVICE_DESCR)*2);
#endif

    ///////////////////////////////////////////////////////////////////
    TestDeleteService(
            hScManager,
            NEW_SERVICE_NAME,
            DELETE,           // desired access
            NO_ERROR,
            NO_ERROR );

Cleanup:

    if (hService != NULL) {
        TRACE_MSG0( "calling CloseServiceHandle(hService)...\n" );

        if ( !CloseServiceHandle( hService ) ) {
            UNEXPECTED_MSG( "from CloseServiceHandle", GetLastError() );
        }

    }

    if (hScManager != NULL) {
        TRACE_MSG0( "calling CloseServiceHandle(hScManager)...\n" );

        if ( !CloseServiceHandle( hScManager ) ) {
            UNEXPECTED_MSG( "from CloseServiceHandle", GetLastError() );
        }

    }

} // TestConfig2APIs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\sctest\sctest.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ScTest.h

Abstract:

    This file contains tests of the Service Controller's config APIs:

        CreateService
        ChangeServiceConfig
        ChangeServiceConfig2
        DeleteService
        QueryServiceConfig
        QueryServiceConfig2

Author:

    John Rogers (JohnRo) 21-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    21-Apr-1992 JohnRo
        Created.

--*/


#ifndef _SCTEST_
#define _SCTEST_


#include <stdio.h>      // printf()


#define TRACE_MSG0( fmt )       (VOID) printf( fmt )
#define TRACE_MSG1( fmt, x )    (VOID) printf( fmt, x )
#define TRACE_MSG2( fmt, x, y ) (VOID) printf( fmt, x, y )

#define UNEXPECTED_MSG( text, retcode ) \
    { \
        (VOID) printf( "***UNEXPECTED RETURN CODE*** " FORMAT_DWORD " " \
                FORMAT_LPSTR "\n", retcode, text ); \
    }


VOID
TestConfigAPIs(
    VOID
    );

VOID
TestConfig2APIs(
    VOID
    );

VOID
TestLocks(
    VOID
    );

#endif // _SCTEST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\bootcfg.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    BOOTCFG.CXX

Abstract:

    Contains functions used for managing the system control sets in the
    system portion of the registry.

    ScCheckLastKnownGood
    ScRevertToLastKnownGood
    NotifyBootConfigStatus

    ScGetTopKeys
    ScGetCtrlSetIds
    ScDeleteRegTree
    ScBuildCtrlSetName
    ScGetCtrlSetHandle
    ScDeleteTree
    ScCopyKeyRecursive
    ScCopyKeyValues
    ScDeleteRegServiceEntry
    ScGatherOrphanIds
    ScDeleteCtrlSetOrphans
    ScMatchInArray
    ScStartCtrlSetCleanupThread
    ScCleanupThread
    ScRunAcceptBootPgm
    ScAcceptTheBoot

Author:

    Dan Lafferty (danl) 19-Apr-1992

Environment:

    User Mode - Win32

Notes:


Revision History:

    24-Aug-1998 Elliot Shmukler (t-ellios)
        Most of the LKG related work has now been moved into the Kernel.
        The tree copies & clone deletions formerly performed by functions
        in this file has now been replaced by calls to NtInitializeRegistry.

    28-Jun-1995 AnirudhS
        SetupInProgress: This function is now called from more than one place.
        Cache the return value so we only examine the registry once.

    04-Feb-1994 Danl
        RevertToLastKnownGood:  If the boot has been accepted, then we won't
        allow a revert.

    15-Jun-1993 Danl
        Ignore LastKnownGood adjustments if setup is still running.
        Use the SystemSetupInProgress value in the registry to determine
        if is running.

    01-Apr-1993 Danl
        Add ability to take ownership if we cannot open one of the keys due
        to an access denied error.

    08-Feb-1993 Danl
        Changed the clearing of the LKG_ENV_VAR so that it is done whenever
        we are booting LKG.  Reguardless of whether or not it is the last
        boot.  Prior to this, it was only cleared when a revert occured, and
        not on the first boot.

    04-Feb-1993 Danl
        Use NtUnloadKey to delete the clone tree.  The clone tree is now
        in a separate hive.  So this is allowed.

    18-Jan-1993 Danl
        Make use of the LastKnownGood Environment Variable.  Now we do
        not alter the default control set when we need to revert.  We
        just set the Environment Variable to True, and reboot.  Phase2
        and ScCheckLastKnownGood do the right thing.

    19-Apr-1992 danl
        Created

--*/

//
// INCLUDES
//
#include "precomp.hxx"
#include <stdlib.h>     // ultoa
#include "scsec.h"      // ScAccessValidate()
#include "bootcfg.h"    // ScRegDeleteTree()
#include "scconfig.h"   // ScOpenServicesKey()
#include <svcslib.h>    // SetupInProgress()
#include <ntsetup.h>    // REGSTR_VALUE_OOBEINPROGRESS

#include <bootstatus.h>

//
// DEFINES
//

#define SYSTEM_KEY      L"system"
#define SELECT_KEY      L"select"
#define SERVICES_KEY    L"System\\CurrentControlSet\\Services"
#define ACCEPT_BOOT_KEY L"System\\CurrentControlSet\\Control\\BootVerificationProgram"
#define SETUP_PROG_KEY  L"Setup"

#define CURRENT_VALUE_NAME      L"Current"
#define DEFAULT_VALUE_NAME      L"Default"
#define LKG_VALUE_NAME          L"LastKnownGood"
#define FAILED_VALUE_NAME       L"Failed"
#define IMAGE_PATH_NAME         L"ImagePath"
#define SETUP_PROG_VALUE_NAME   L"SystemSetupInProgress"

#define CTRL_SET_NAME_TEMPLATE   L"ControlSet000"
#define CTRL_SET_NAME_CHAR_COUNT 13
#define CTRL_SET_NAME_NUM_OFFSET 10
#define CTRL_SET_NAME_BYTES      ((CTRL_SET_CHAR_COUNT+1) * sizeof(WCHAR))

#define CLONE_SECURITY_INFORMATION (OWNER_SECURITY_INFORMATION | \
                                    GROUP_SECURITY_INFORMATION | \
                                    DACL_SECURITY_INFORMATION  | \
                                    SACL_SECURITY_INFORMATION)

//
// STANDARD access is obtained for the system and select keys.
// We read and write to these keys.
//
#define SC_STANDARD_KEY_ACCESS  KEY_READ   | \
                                READ_CONTROL |  \
                                WRITE_OWNER  |  \
                                KEY_WRITE

//
// CLONE access is obtained for the top level clone key
// We must be able to copy and delete clone trees.
//

#define SC_CLONE_KEY_ACCESS     KEY_READ     |  \
                                READ_CONTROL |  \
                                WRITE_OWNER  |  \
                                DELETE       |  \
                                ACCESS_SYSTEM_SECURITY

//
// CONTROL_SET access is obtained for the top level control sets.
// We must be able to copy and delete control sets.
// NOTE:  SE_SECURITY_PRIVILEGE is required to get ACCESS_SYSTEM_SECURITY.
//
#define SC_CONTROL_SET_KEY_ACCESS   KEY_READ     |          \
                                    KEY_WRITE    |          \
                                    DELETE       |          \
                                    READ_CONTROL |          \
                                    WRITE_OWNER  |          \
                                    ACCESS_SYSTEM_SECURITY

//
// COPY access is obtained for each subkey in a control set as it is being
// copied.
// NOTE:  SE_SECURITY_PRIVILEGE is required to get ACCESS_SYSTEM_SECURITY.
//
#define SC_COPY_KEY_ACCESS      KEY_READ     |          \
                                READ_CONTROL |          \
                                ACCESS_SYSTEM_SECURITY
//
// DELETE access is obtained for each subkey in a control set that is being
// deleted.
//
#define SC_DELETE_KEY_ACCESS    DELETE      | \
                                KEY_READ

//
// CREATE access is the access used for all keys created by this
// process.
//

#define SC_CREATE_KEY_ACCESS    KEY_WRITE   |           \
                                WRITE_OWNER |           \
                                WRITE_DAC   |           \
                                ACCESS_SYSTEM_SECURITY

//
// Control Set IDs are stored in an array of DWORDs.  The array has the
// following offsets for each ID:
//

#define CURRENT_ID  0
#define DEFAULT_ID  1
#define LKG_ID      2
#define FAILED_ID   3

#define NUM_IDS     4


//
// Macros
//

#define SET_LKG_ENV_VAR(pString)                        \
    {                                                   \
    UNICODE_STRING  Name,Value;                         \
                                                        \
    RtlInitUnicodeString(&Name, L"LastKnownGood");      \
    RtlInitUnicodeString(&Value,pString);               \
                                                        \
    status = RtlNtStatusToDosError(NtSetSystemEnvironmentValue(&Name,&Value)); \
    }

//
// GLOBALS
//

    //
    // This flag is set when ScCheckLastKnownGood is called.  It is later
    // checked when either ScRevertToLastKnownGood or NotifyBootConfigStatus
    // is called.  TRUE indicates that we know we are booting LastKnownGood.
    //

    DWORD               ScGlobalLastKnownGood;
    BOOL                ScGlobalBootAccepted = FALSE;

    CRITICAL_SECTION    ScBootConfigCriticalSection;

    LPDWORD             ScGlobalOrphanIds = NULL;

//
// LOCAL FUNCTION PROTOTYPES
//

DWORD
ScGetTopKeys(
    PHKEY   SystemKey,
    PHKEY   SelectKey
    );

DWORD
ScGetCtrlSetIds(
    HKEY    SelectKey,
    LPDWORD IdArray
    );

BOOL
ScBuildCtrlSetName(
    LPWSTR  ControlSetName,
    DWORD   ControlId
    );

HKEY
ScGetCtrlSetHandle(
    HKEY    SystemKey,
    DWORD   ControlId,
    LPWSTR  ControlSetName
    );

VOID
ScDeleteTree(
    IN HKEY KeyHandle
    );

VOID
ScCopyKeyRecursive(
    HKEY    ParentKey,
    PHKEY   DestKeyPtr,
    HKEY    SourceKey,
    LPWSTR  DestKeyName
    );

VOID
ScCopyKeyValues(
    HKEY    DestKey,
    HKEY    SourceKey,
    DWORD   NumberOfValues,
    DWORD   MaxValueNameLength,
    DWORD   MaxValueDataLength
    );

VOID
ScDeleteRegTree(
    HKEY    ParentKey,
    HKEY    KeyToDelete,
    LPWSTR  NameOfKeyToDelete
    );

VOID
ScGatherOrphanIds(
    HKEY        SystemKey,
    LPDWORD     *OrphanIdPtr,
    LPDWORD     idArray
    );

BOOL
ScMatchInArray(
    DWORD       Value,
    LPDWORD     IdArray
    );

VOID
ScStartCtrlSetCleanupThread();

DWORD
ScCleanupThread();

DWORD
ScAcceptTheBoot(
    VOID
    );

DWORD
ScGetNewCtrlSetId(
      LPDWORD IdArray,
      LPDWORD NewIdPtr
      );


BOOL
ScCheckLastKnownGood(
    VOID
    )

/*++

Routine Description:

    This function is called early in the service controller initialization.
    Its purpose is to protect the LastKnownGood control set.  If this
    function finds that the control set that we are booting is the
    LastKnownGood control set, it will save the clone tree to a new
    control set and make this LastKnownGood.  The clone tree in this case
    is an unchanged version of LKG.  The Current control is not!  Current
    may have been modified by drivers that were started before the service
    controller was started.

    Phase 2 of the boot procedure is always responsible for actually
    doing the revert to LastKnownGood.  We determine that we have reverted
    by noting that Current and LKG will be the same control sets, and
    Default will be different.  If Default is the same (all three control
    sets are the same), then it is the very first boot, and we don't consider
    it a failure case.  If Phase 2 is causing the boot from LastKnownGood,
    then we want to set
        Failed  to Default  and
        Current to LKG      and
        Set the LKG environment variable to FALSE.
    The assumption here is that Phase2 is using LastKnownGood because
    The Default Control Set was not acceptable.

Arguments:

    TRUE - If all the necessary operations were successful.

    FALSE - If any of the control set manipulation could not be completed
        successfully.

Return Value:


Note:


--*/
{
    DWORD   status;
    BOOL    retStat;
    HKEY    systemKey=0;
    HKEY    selectKey=0;
    HKEY    failedKey=0;
    HKEY    newKey=0;

    DWORD   idArray[NUM_IDS];
    WCHAR   failedKeyName[CTRL_SET_NAME_CHAR_COUNT+1];

    DWORD   savedLkgId;
    DWORD   newId;
    ULONG   privileges[5];

    //
    // Initialize the Critical section that will synchronize access to
    // these routines.  The service controller could call
    // ScRevertToLastKnownGood at the same time that someone calls
    // NotifyBootConfigStatus().  This could cause the control set pointers
    // to get corrupted.  So access to these functions is restricted by
    // a critical section.  It is initialized here because this function
    // must be called prior to starting any services, or starting the
    // RPC server.  Therefore we can't get asynchronous calls to these
    // routines at this time.
    //
    InitializeCriticalSection(&ScBootConfigCriticalSection);

    //
    // This thread gets SE_SECURITY_PRIVILEGE for copying security
    // descriptors and deleting keys.
    //
    privileges[0] = SE_BACKUP_PRIVILEGE;
    privileges[1] = SE_RESTORE_PRIVILEGE;
    privileges[2] = SE_SECURITY_PRIVILEGE;
    privileges[3] = SE_TAKE_OWNERSHIP_PRIVILEGE;
    privileges[4] = SE_SYSTEM_ENVIRONMENT_PRIVILEGE;

    status = ScGetPrivilege( 5, privileges);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScCheckLastKnownGood: ScGetPrivilege Failed %d\n",
            status);
        return(FALSE);
    }


    //
    // Get the System, Select, and Clone Keys
    //
    status = ScGetTopKeys(&systemKey, &selectKey);
    if (status != NO_ERROR) {
        SC_LOG0(ERROR,"ScCheckLastKnownGood: ScGetTopKeys failed\n");
        retStat = FALSE;
        goto CleanExit;
    }

    //
    // Get the ControlSetIds stored in the \system\select key.
    //

    status = ScGetCtrlSetIds(
                selectKey,
                idArray);

    if (status != NO_ERROR) {

        ScRegCloseKey(systemKey);
        ScRegCloseKey(selectKey);
        SC_LOG0(ERROR,"ScCheckLastKnownGood: ScGetCtrlSetIds Failed\n");
        retStat = FALSE;
        goto CleanExit;
    }

    //
    // Scan for Orphaned Control Sets.
    // This is required prior to calling ScGetNewCtrlSetId (which
    // avoids the orphaned numbers).
    //
    ScGatherOrphanIds(systemKey,&ScGlobalOrphanIds,idArray);

    if ((SetupInProgress(systemKey, NULL)) ||
        (idArray[CURRENT_ID] != idArray[LKG_ID])) {
        //
        // We are not booting from LastKnownGood, so we don't do
        // anything except make sure the LKG_FLAG not set.
        //

        ScGlobalLastKnownGood = 0;

        ScRegCloseKey(systemKey);
        ScRegCloseKey(selectKey);
        retStat = TRUE;
        goto CleanExit;
    }
    else {
        //
        // We Must be booting the LastKnownGood configuration.
        // Put LkgControlSetId into SavedLkgControlSetId.
        //
        SC_LOG0(TRACE,"ScCheckLastKnownGood, We are booting LKG\n");
        savedLkgId = idArray[LKG_ID];

        //
        // Set the LKG environment variable to FALSE - so Phase 2
        // does not automatically revert again.
        //
        SET_LKG_ENV_VAR(L"False");
        if (status != NO_ERROR) {
            SC_LOG1(ERROR,"ScCheckLastKnownGood: Couldn't clear LKG "
            "environment variable %d\n",status);
        }

        //
        // Copy the Clone tree into a non-volatile node (new ControlSetId).
        //

        SC_LOG0(TRACE,"ScCheckLastKnownGood, Copy Clone to new ctrl set\n");

        status = ScGetNewCtrlSetId( idArray, &newId);
        if(status == NO_ERROR)
        {
           status = RtlNtStatusToDosError(NtInitializeRegistry(REG_INIT_BOOT_ACCEPTED_BASE +
                                                               (USHORT)newId));
        }

        if (status != NO_ERROR) {

            SC_LOG0(ERROR,"ScCheckLastKnownGood: ScGetNewCtrlSetId Failed\n");
            SC_LOG0(ERROR,"SERIOUS ERROR - Unable to copy control set that "
                         "is to be saved as LastKnownGood\n");
        }
        else {
            SC_LOG0(TRACE,"ScCheckLastKnownGood, Copy Clone is complete\n");

            //
            // Set LkgControlSetId to this new ControlSetId.
            //

            SC_LOG0(TRACE,"ScCheckLastKnownGood, Set LKG to this new ctrl set\n");

            idArray[LKG_ID]  = newId;
            status = ScRegSetValueExW(
                        selectKey,                  // hKey
                        LKG_VALUE_NAME,             // lpValueName
                        0,                          // dwValueTitle (OPTIONAL)
                        REG_DWORD,                  // dwType
                        (LPBYTE)&(idArray[LKG_ID]), // lpData
                        sizeof(DWORD));             // cbData

            ScRegCloseKey(newKey);

            if (status != NO_ERROR) {
                SC_LOG1(ERROR,"ScCheckLastKnownGood: ScRegSetValueEx (lkgValue) "
                "failed %d\n",status);
                SC_LOG1(ERROR,"Semi-SERIOUS ERROR - Unable to Set Select Value "
                             "For LastKnownGood.\nThe new ControlSet%d should "
                             "be LKG\n",newId);
            }
            else {


                //
                // Since we already generated a LKG, we don't want to allow the
                // user or the boot verfication program to try to go through the
                // motions of generating it again.  So we set the global flag that
                // indicates that the boot was accepted as LKG.
                //
                ScGlobalBootAccepted = TRUE;

                //
                // Set Global LKG_FLAG to indicate that we are running LKG, and
                // whether or not we are here because we reverted.  The only
                // reason we would be here without reverting is because it is the
                // very first boot.  But in the very first boot, FAILED is 0.
                //

                ScGlobalLastKnownGood |= RUNNING_LKG;
                if (idArray[FAILED_ID] != 0) {
                    ScGlobalLastKnownGood |= REVERTED_TO_LKG;
                }

            } //endif - Set LKG Id to NetCtrlSet ID;

        } //endif - MakeNewCtrlSet == TRUE;

        //
        // If the DefaultControlSetId is the same as the original
        // LkgControlSetId, then Phase2 of the boot must have reverted
        // to Last Known Good.
        //
        if (idArray[DEFAULT_ID] != savedLkgId) {
            //
            // We are booting LastKnownGood because it was set that way
            // by Phase2 of the boot.  In this case, we want to set the
            // FailedControlSetId to the DefaultControlSetId.  Then we
            // want to set the DefaultControlSetId to the CurrentControlSetId.
            //
            // NOTE:  On the very first boot, we don't go through this path
            // because current=default=lkg.
            //

            SC_LOG0(TRACE,"ScCheckLastKnownGood, Phase 2 caused LKG"
                         " so we delete the failed tree and put\n"
                         "   Default->Failed\n"
                         "   Lkg -> Default\n");

            if (idArray[FAILED_ID] != 0) {
                SC_LOG0(TRACE,"ScCheckLastKnownGood: Deleting Old Failed Tree\n");
                failedKey = ScGetCtrlSetHandle(
                                systemKey,
                                idArray[FAILED_ID],
                                failedKeyName);

                ScDeleteRegTree(systemKey, failedKey, failedKeyName);
            }

            //
            // Put the DefaultId into the Failed value.
            //
            idArray[FAILED_ID]  = idArray[DEFAULT_ID];
            status = ScRegSetValueExW(
                        selectKey,                      // hKey
                        FAILED_VALUE_NAME,              // lpValueName
                        0,                              // dwValueTitle (OPTIONAL)
                        REG_DWORD,                      // dwType
                        (LPBYTE)&(idArray[FAILED_ID]),  // lpData
                        sizeof(DWORD));                 // cbData

            if (status != NO_ERROR) {
                SC_LOG1(ERROR,"ScCheckLastKnownGood: ScRegSetValueEx (failedValue) failed %d\n",
                    status);
            }

            //
            // Put the CurrentId into the Default Value.
            //
            idArray[DEFAULT_ID] = idArray[CURRENT_ID];
            status = ScRegSetValueExW(
                        selectKey,                      // hKey
                        DEFAULT_VALUE_NAME,             // lpValueName
                        0,                              // dwValueTitle (OPTIONAL)
                        REG_DWORD,                      // dwType
                        (LPBYTE)&(idArray[CURRENT_ID]), // lpData
                        sizeof(DWORD));                 // cbData

            if (status != NO_ERROR) {
                SC_LOG1(ERROR,"ScCheckLastKnownGood: ScRegSetValueEx (DefaultValue) failed %d\n",
                    status);
                ScRegCloseKey(selectKey);
                ScRegCloseKey(systemKey);
                retStat = FALSE;
                goto CleanExit;
            }
        }

        ScRegCloseKey(systemKey);
        ScRegCloseKey(selectKey);
    }

    retStat = TRUE;

CleanExit:

    //
    // If the code above was successful then mark the boot as having been 
    // successful.
    //

    if(retStat) {

        HANDLE bootStatusData;
        BOOL b = TRUE;

        status = RtlLockBootStatusData(&bootStatusData);

        if(NT_SUCCESS(status)) {

            RtlGetSetBootStatusData(bootStatusData,
                                    FALSE,
                                    RtlBsdItemBootGood,
                                    &b,
                                    sizeof(BOOL),
                                    NULL);
    
            RtlUnlockBootStatusData(bootStatusData);
        }
    }

    //
    // Restore privileges for the current thread.
    //
    (VOID)ScReleasePrivilege();

    //
    // Remove any control sets that need to be deleted (clone or orphans).
    // This is performed by a seperate thread.
    //
    if (ScGlobalOrphanIds != NULL) {
        ScStartCtrlSetCleanupThread();
    }
    return(retStat);
}


DWORD
ScRevertToLastKnownGood(
    VOID
    )

/*++

Routine Description:

    This function attempts to revert to the last known good control set.

    It does this in the following manner:
    If not running LastKnownGood:
        Set the LKG environment variable so that phase 2 of the boot
        procedure will cause the revert to happen.  Then shutdown the
        system so it will boot again.


Arguments:


Return Value:


Note:


--*/
{
    DWORD       status;
    NTSTATUS    ntStatus;

    ULONG   privileges[6];

    //
    // If we are not currently running LastKnownGood, then set the tree we
    // are booting from (clone) to failed. Set the Default to point to
    // LastKnownGood.  Then reboot.
    //
    if (!(ScGlobalLastKnownGood & RUNNING_LKG)) {

        EnterCriticalSection(&ScBootConfigCriticalSection);
        if (ScGlobalBootAccepted) {
            //
            // If the boot has already been accepted, then we don't want
            // to allow a forced revert.
            //

            LeaveCriticalSection(&ScBootConfigCriticalSection);
            return(ERROR_BOOT_ALREADY_ACCEPTED);
        }

        SC_LOG0(TRACE,"ScRevertToLastKnownGood: Reverting...\n");
        //
        // This thread gets SE_SECURITY_PRIVILEGE for copying security
        // descriptors and deleting keys.
        //
        privileges[0] = SE_BACKUP_PRIVILEGE;
        privileges[1] = SE_RESTORE_PRIVILEGE;
        privileges[2] = SE_SECURITY_PRIVILEGE;
        privileges[3] = SE_SHUTDOWN_PRIVILEGE;
        privileges[4] = SE_SYSTEM_ENVIRONMENT_PRIVILEGE;
        privileges[5] = SE_TAKE_OWNERSHIP_PRIVILEGE;

        status = ScGetPrivilege( 6, privileges);
        if (status != NO_ERROR) {
            SC_LOG1(ERROR, "ScRevertToLastKnownGood: ScGetPrivilege Failed %d\n",
                status);
            LeaveCriticalSection(&ScBootConfigCriticalSection);
            return(status);
        }

        //
        // Set the LKG environment variable to True - so Phase 2
        // will automatically revert, or put up the screen asking if the
        // user wants to revert.
        //

        SET_LKG_ENV_VAR(L"True");
        if (status != NO_ERROR) {
            //
            // If we could not set the environment variable that causes
            // the revert, there is no reason to reboot.  Otherwise, we
            // we would reboot continuously.
            //
            // WE SHOULD LOG AN EVENT HERE - that says that we should
            // reboot, but we didn't.
            //
            SC_LOG1(ERROR,"RevertToLastKnownGood: Couldn't set LKG "
            "environment variable %d\n",status);

            (VOID)ScReleasePrivilege();
            LeaveCriticalSection(&ScBootConfigCriticalSection);
            return(NO_ERROR);
        }

        //
        // Re-boot.
        //
        SC_LOG0(ERROR,"Reverted To LastKnownGood.  Now Rebooting...\n");

        ScLogEvent(NEVENT_REVERTED_TO_LASTKNOWNGOOD);

        //
        // Just prior to shutting down, sleep for 5 seconds so that the
        // system has time to flush the events to disk.
        //
        Sleep(5000);

        LeaveCriticalSection(&ScBootConfigCriticalSection);
        ntStatus = NtShutdownSystem(ShutdownReboot);

        if (!NT_SUCCESS(ntStatus)) {
            SC_LOG1(ERROR,"NtShutdownSystem Failed 0x%lx\n",ntStatus);
        }

        //
        // Restore privileges for the current thread.
        //
        (VOID)ScReleasePrivilege();

        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Otherwise... just return back to the caller.
    //
    return(ERROR_ALREADY_RUNNING_LKG);
}

DWORD
RNotifyBootConfigStatus(
    IN LPWSTR   lpMachineName,
    IN DWORD    BootAcceptable
    )

/*++

Routine Description:

    If we are not currently booted with Last Known Good, this function
    will revert to Last Known Good if the boot is not acceptable.  Or it
    will save the boot configuration that we last booted from as the
    Last Known Good.  This is the configuration that we will fall back
    to if a future boot fails.

Arguments:

    BootAcceptable - This indicates whether or not the boot was acceptable.

Return Value:

    TRUE - This is only returned if the boot is acceptable, and we
        successfully replaced Last Known Good with the current boot
        configuration.

    FALSE - This is returned if an error occured when attempting to replace
        Last Known Good or if the system is currently booted from Last
        Known Good.

Note:


--*/
{
    DWORD   status=NO_ERROR;
    SC_HANDLE_STRUCT  scManagerHandle;

    UNREFERENCED_PARAMETER(lpMachineName);  // This should always be null.

    //
    // Perform a security check to see if the caller has
    // SC_MANAGER_MODIFY_BOOT_CONFIG access.
    //

    scManagerHandle.Signature = SC_SIGNATURE;
    scManagerHandle.Type.ScManagerObject.DatabaseName = NULL;

    status = ScAccessValidate(&scManagerHandle,SC_MANAGER_MODIFY_BOOT_CONFIG);
    if (status != NO_ERROR) {
        return(status);
    }

    if (ScGlobalLastKnownGood & RUNNING_LKG) {
        //
        // If we are already booting LastKnownGood, then return false.
        //
        return(ERROR_ALREADY_RUNNING_LKG);
    }

    if (BootAcceptable) {

        SC_LOG0(TRACE,"NotifyBootConfigStatus: Boot is Acceptable\n");
        //
        // Must enter critical section before progressing.
        //
        EnterCriticalSection(&ScBootConfigCriticalSection);

        if (ScGlobalBootAccepted) {
            LeaveCriticalSection(&ScBootConfigCriticalSection);
            return(ERROR_BOOT_ALREADY_ACCEPTED);
        }

        //
        // If Auto-Start is not complete yet, then we just want to mark
        // to boot as accepted and operate on it after auto-start completion.
        // We also want to set the ScGlobalBootAccepted flag so that
        // further requests to accept the boot will be ignored.
        //
        if (!(ScGlobalLastKnownGood & AUTO_START_DONE)) {
            SC_LOG0(BOOT,"RNotifyBootConfigStatus: Boot Accepted, but Auto-start "
                "is not complete.  Defer acceptance\n");
            ScGlobalLastKnownGood |= ACCEPT_DEFERRED;
            ScGlobalBootAccepted = TRUE;
        }
        else {
            SC_LOG0(BOOT,"RNotifyBootConfigStatus: Boot Accepted and Auto-start "
                "is complete\n");
            status = ScAcceptTheBoot();
        }

        LeaveCriticalSection(&ScBootConfigCriticalSection);

        return(status);
    }

    else {

        //
        // The Boot was not acceptable.
        //
        // NOTE:  We should never return from the call to
        //        ScRevertToLastKnownGood.
        //
        //
        SC_LOG0(TRACE,"NotifyBootConfigStatus: Boot is Not Acceptable. Revert!\n");
        return(ScRevertToLastKnownGood());
    }
}

DWORD
ScGetTopKeys(
    PHKEY   SystemKey,
    PHKEY   SelectKey
    )

/*++

Routine Description:

    This function opens handles to the SystemKey, and the SelectKey.

Arguments:


Return Value:


Note:



--*/

{
    DWORD   status;

    //
    // Get the System Key
    //

    status = ScRegOpenKeyExW(
                HKEY_LOCAL_MACHINE,     // hKey
                SYSTEM_KEY,             // lpSubKey
                0L,                     // ulOptions (reserved)
                SC_STANDARD_KEY_ACCESS, // desired access
                SystemKey);             // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetTopKeys: ScRegOpenKeyEx (system key) failed %d\n",status);
        return (status);
    }

    //
    // Get the Select Key
    //
    status = ScRegOpenKeyExW(
                *SystemKey,             // hKey
                SELECT_KEY,             // lpSubKey
                0L,                     // ulOptions (reserved)
                SC_STANDARD_KEY_ACCESS, // desired access
                SelectKey);             // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetTopKeys: ScRegOpenKeyEx (select key) failed %d\n",status);
        ScRegCloseKey(*SystemKey);
        return (status);
    }

    return(NO_ERROR);
}

DWORD
ScGetCtrlSetIds(
    HKEY    SelectKey,
    LPDWORD IdArray
    )

/*++

Routine Description:

    This function obtains all the important Control Set IDs from the
    \system\select portion of the registry.  These IDs are in the form
    of a DWORD that is used to build the Key name for that control set.
    For instance the DWORD=003 is used to build the string
    "control_set_003".

    If a control set for one of these is not present, a 0 is returned
    for that ID.

Arguments:

    SelectKey - This is the Key Handle for the \system\select portion of
        the registry.

    IdArray - This is an array of DWORDs where each element is an ID.
        This array contains elements for Current, Default, LKG, and Failed.

Return Value:

    NO_ERROR - If the operation was successful.

    OTHER - Any error that can be returned from RegQueryValueEx could be
        returned here if we fail to get an ID for Current, Default, or
        LKG.  We expect Failed To be empty to start with.

Note:


--*/
{
    DWORD   status;
    DWORD   bufferSize;

    //
    // Get the Current Id
    //
    bufferSize = sizeof(DWORD);
    status = ScRegQueryValueExW (
                SelectKey,                      // hKey
                CURRENT_VALUE_NAME,             // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)&IdArray[CURRENT_ID],   // lpData
                &bufferSize);                   // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetCtrlSetIds,ScRegQueryValueEx(current) failed %d\n",status);
        IdArray[CURRENT_ID] = 0;
        return(status);
    }

    //
    // Get the DefaultID
    //
    bufferSize = sizeof(DWORD);
    status = ScRegQueryValueExW (
                SelectKey,                      // hKey
                DEFAULT_VALUE_NAME,             // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)&IdArray[DEFAULT_ID],   // lpData
                &bufferSize);                   // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetCtrlSetIds,ScRegQueryValueEx(default) failed %d\n",status);
        IdArray[DEFAULT_ID] = 0;
        return(status);
    }

    //
    // Get the LKG Id
    //
    bufferSize = sizeof(DWORD);
    status = ScRegQueryValueExW (
                SelectKey,                  // hKey
                LKG_VALUE_NAME,             // lpValueName
                NULL,                       // lpTitleIndex
                NULL,                       // lpType
                (LPBYTE)&IdArray[LKG_ID],   // lpData
                &bufferSize);               // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetCtrlSetIds,ScRegQueryValueEx(LKG) failed %d\n",status);
        IdArray[LKG_ID] = 0;
        return(status);
    }

    //
    // Get the Failed Id
    //
    bufferSize = sizeof(DWORD);
    status = ScRegQueryValueExW (
                SelectKey,                      // hKey
                FAILED_VALUE_NAME,              // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)&IdArray[FAILED_ID],    // lpData
                &bufferSize);                   // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetCtrlSetIds,ScRegQueryValueEx(Failed) failed %d\n",status);
        IdArray[FAILED_ID] = 0;
    }

    return(NO_ERROR);
}

VOID
ScDeleteRegTree(
    HKEY    ParentKey,
    HKEY    KeyToDelete,
    LPWSTR  NameOfKeyToDelete
    )

/*++

Routine Description:

    This function walks through a Key Tree and deletes all the sub-keys
    contained within.  It then closes the top level Key Handle, and deletes
    that key (which is a subkey of the parent).

    This function also closes the handle for the key being deleted.

Arguments:

    ParentKey - This is the handle to the parent key whose sub-key is being
        deleted.

    KeyToDelete - A handle to the key that is to be deleted.

    NameOfKeyToDelete - This is a pointer to a string that Identifies the
        name of the key that is to be deleted.

Return Value:

    none.

Note:


--*/
{
    DWORD   status;

    if (KeyToDelete == NULL)
    {
        return;
    }

    //
    // Delete the tree.
    //
    ScDeleteTree(KeyToDelete);

    ScRegCloseKey(KeyToDelete);


    status = ScRegDeleteKeyW(ParentKey, NameOfKeyToDelete);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScDeleteRegTree, ScRegDeleteKey failed %d\n",status);
    }

    return;
}

BOOL
ScBuildCtrlSetName(
    LPWSTR  ControlSetName,
    DWORD   ControlId
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

--*/
{
    DWORD   NumOffset = CTRL_SET_NAME_NUM_OFFSET;

    //
    // Build the name.  NumOffset is the array offset of where the
    // number portion of the name is to be stored.  The number initially
    // contains 000.  And the offset points to the first zero.  If only
    // two digits are to be stored, the offset is first incremented to
    // point to where the last two digits go.
    //
    if (ControlId > 999) {
        SC_LOG1(ERROR, "ScBuildCtrlSetName,ControlId Too Large -- %d\n",ControlId);
        return(FALSE);
    }

    if (ControlId < 100) {
        NumOffset++;
    }

    if (ControlId < 10) {
        NumOffset++;
    }

    wcscpy(ControlSetName, CTRL_SET_NAME_TEMPLATE);

    //
    // The above checks should assure that the _ultow call will not
    // overflow the buffer.
    //
    _ultow(ControlId, &(ControlSetName[NumOffset]), 10);

    return(TRUE);
}

HKEY
ScGetCtrlSetHandle(
    HKEY    SystemKey,
    DWORD   ControlId,
    LPWSTR  ControlSetName
    )

/*++

Routine Description:

    This function uses the ControlId to create the name of the control set
    to open.  Then it opens a Key (handle) to this control set.
    Then name was well as the key handle are returned.

Arguments:

    SystemKey - This is the handle for the System Key.  The Control Sets
        are sub-keys for this key.

    ControlId - This is the ID for the Control Set for which we are
        desiring a handle (key).

    KeyName - This is a pointer to a location where the name of the key
        is to be placed.

Return Value:

    HKEY - This is the Key handle for the control set in question.  If the
        control set does not exist, a NULL is returned.

Note:


--*/

{
    DWORD   status;
    HKEY    ctrlSetKey;

    //
    // Build the Control Set Name
    //
    if (!ScBuildCtrlSetName(ControlSetName, ControlId)) {
        return(NULL);
    }

    //
    // Open the Key for this name.
    //

    SC_LOG1(TRACE,"ScGetCtrlSetHandle: ControlSetName = "FORMAT_LPWSTR"\n",
        ControlSetName);

    //
    // Get the ControlSetName
    //

    status = ScRegOpenKeyExW(
                SystemKey,                  // hKey
                ControlSetName,             // lpSubKey
                0L,                         // ulOptions (reserved)
                SC_CONTROL_SET_KEY_ACCESS,  // desired access
                &ctrlSetKey);               // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG2(ERROR,"ScGetCtrlSetHandle: ScRegOpenKeyEx (%ws) failed %d\n",
            ControlSetName,
            status);
        return (NULL);
    }

    return(ctrlSetKey);

}


DWORD
ScGetNewCtrlSetId(
      LPDWORD IdArray,
      LPDWORD NewIdPtr
      )
/*++

Routine Description:

    This routine computes the new control set ID to be used for
    the LKG control set

Arguments:

    IdArray - Supplies the ID array filled in by ScGetCtrlSetIds

    NewIdPtr - Returns a free ID to be used for the LKG control set

Return Value:

    Either NO_ERROR if successful or ERROR_NO_MORE_ITEMS if there
    are no more free IDs (should never happen)

--*/
{
   DWORD newId, i;
   BOOL inArray;

   for(newId = 1; newId < 1000; newId++)
   {
      inArray = FALSE;
      for(i = 0; i < NUM_IDS; i++)
      {
         if(IdArray[i] == newId)
         {
            inArray = TRUE;
            break;
         }
      }

      if (!inArray && !ScMatchInArray(newId, ScGlobalOrphanIds))
      {
         *NewIdPtr = newId;
         return NO_ERROR;
      }
   }

   return ERROR_NO_MORE_ITEMS;
}


VOID
ScDeleteTree(
    IN HKEY KeyHandle
    )

/*++

Routine Description:

    This function recursively deletes all keys under the key handle that
    is passed in.

Arguments:

    KeyHandle - This is the handle for the Key Tree that is being deleted.

Return Value:

    none.

Note:

    This was cut & pasted from ..\..\winreg\tools\crdel\crdel.c
    The only modifications were changing TSTR to WSTR and calling the
    UNICODE version of the functions.

--*/

{
    DWORD   status;
    DWORD   Index;
    HKEY    ChildHandle;
    DWORD   bytesReturned;
    BYTE    buffer[ sizeof( KEY_FULL_INFORMATION) + sizeof( WCHAR) * MAX_PATH];
    DWORD   NumberOfSubKeys;
    PWCHAR  KeyName;

    status = NtQueryKey(
                (HANDLE)KeyHandle,
                KeyFullInformation,
                (PVOID)buffer,
                sizeof( buffer),
                &bytesReturned
                );

    if ( status != STATUS_SUCCESS) {
        SC_LOG1(ERROR, "ScDeleteTree: NtQueryKey Failed 0x%x\n",status);
        return;
    }

    NumberOfSubKeys = ((PKEY_FULL_INFORMATION)buffer)->SubKeys;
    KeyName = (PWCHAR)buffer;

    for( Index = 0; Index < NumberOfSubKeys; Index++ ) {

        status = ScRegEnumKeyW(
                    KeyHandle,
                    0,
                    KeyName,
                    sizeof( buffer)
                    );

        if (status != NO_ERROR) {
            SC_LOG1(ERROR, "ScDeleteTree: ScRegEnumKeyW Failed %d\n",status);
            return;
        }

        status = ScRegOpenKeyExW(
                    KeyHandle,
                    KeyName,
                    REG_OPTION_RESERVED,
                    SC_DELETE_KEY_ACCESS,
                    &ChildHandle
                    );
        if (status != NO_ERROR) {
            SC_LOG2(ERROR, "ScDeleteTree: ScRegOpenKeyExW (%ws) Failed %d\n",
                KeyName,
                status);
            return;
        }

        ScDeleteTree( ChildHandle );


        status = ScRegDeleteKeyW(
                    KeyHandle,
                    KeyName);

        NtClose( (HANDLE)ChildHandle);

        if ( status != NO_ERROR) {
            SC_LOG1(ERROR, "ScDeleteTree: ScRegDeleteKeyW Failed 0x%x\n", status);
            return;
        }
    }
}
#if 0

VOID
ScCopyKeyRecursive(
    HKEY    ParentKey,
    PHKEY   DestKeyPtr,
    HKEY    SourceKey,
    LPWSTR  DestKeyName
    )

/*++

Routine Description:

    This function copies the values from the source key to the destination
    key.  Then it goes through each subkey of the source key and
    creates subkeys for the dest key.  This function is then called
    to copy info for those subkeys.

Arguments:
    ParentKey - This is the Key Handle for the parent key of the
        destination key.

    DestKeyPtr - This is the Key Handle for the destination key.

    SourceKey - This is the key handle for the source key.

    DestKeyName - This is the name that the new dest should have.

Return Value:

    none - If this operation fails anywhere along the tree, it will simply
        stop.  The tree will be truncated at that point.

--*/
{
    DWORD       status;
    DWORD       i;
    HKEY        SourceChildKey;
    HKEY        DestChildKey;

    WCHAR       KeyName[ MAX_PATH ];
    DWORD       KeyNameLength;
    WCHAR       ClassName[ MAX_PATH ];
    DWORD       ClassNameLength;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    LPBYTE      SecurityDescriptor = NULL;
    FILETIME    LastWriteTime;
    DWORD       disposition;
    SECURITY_ATTRIBUTES securityAttributes;

    ClassNameLength = MAX_PATH;

    //
    // Find out how many subKeys and values there are in the source key.
    //

    status = ScRegQueryInfoKeyW(
                SourceKey,
                ClassName,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );

    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScCopyKeyRecursive: ScRegQueryInfoKey Failed %d\n",status);
        return;
    }

    //
    // If there is a security descriptor, attempt to copy it.
    //
    if (SecurityDescriptorLength != 0) {

        SC_LOG2(BOOT,"ScCopyKeyRecursive: %ws Key Has Security Desc %d bytes\n",
            DestKeyName,
            SecurityDescriptorLength);

        SecurityDescriptor = (LPBYTE)LocalAlloc(
                                    LMEM_ZEROINIT,
                                    SecurityDescriptorLength);
        if (SecurityDescriptor == NULL) {
            SC_LOG0(ERROR, "ScCopyKeyRecursive: Couldn't alloc memory for "
                          "Security Descriptor.\n");
        }
        else {

            status = ScRegGetKeySecurity(
                        SourceKey,
                        CLONE_SECURITY_INFORMATION,
                        (PSECURITY_DESCRIPTOR)SecurityDescriptor,
                        &SecurityDescriptorLength);

            if (status != NO_ERROR) {

                SC_LOG1(ERROR, "ScCopyKeyRecursive: ScRegGetKeySecurity failed %d\n",
                    status);
                    LocalFree(SecurityDescriptor);
                    SecurityDescriptor = NULL;
            }
            else {
                if (!IsValidSecurityDescriptor(SecurityDescriptor)) {
                    SC_LOG1(ERROR,"SecurityDescriptor for %ws is invalid\n",
                        DestKeyName);
                    LocalFree(SecurityDescriptor);
                    SecurityDescriptor = NULL;
                }
            }
        }

    }

    securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    securityAttributes.lpSecurityDescriptor = SecurityDescriptor;
    securityAttributes.bInheritHandle = FALSE;

    //
    // Create the Destination Key.
    //
    status = ScRegCreateKeyExW(
                ParentKey,              // hKey
                DestKeyName,            // lpSubKey
                0L,                     // dwTitleIndex
                ClassName,              // lpClass
                0,                      // ulOptions
                SC_CREATE_KEY_ACCESS,   // desired access
                &securityAttributes,    // lpSecurityAttributes (Secur Desc)
                DestKeyPtr,             // phkResult
                &disposition);          // lpulDisposition

    LocalFree(SecurityDescriptor);
    SecurityDescriptor = NULL;

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScCopyKeyRecursive, ScRegCreateKeyEx failed %d\n",status);
        return;
    }

    //
    // If there are values in the key and we have
    // enough information to copy them, then do so
    //
    if (NumberOfValues > 0) {

        //
        // Copy Values to Dest Key
        //
        ScCopyKeyValues(
            *DestKeyPtr,
            SourceKey,
            NumberOfValues,
            MaxValueNameLength,
            MaxValueDataLength);
    }

    //
    // For each child key, create a new key in the destination tree.
    // Then call ScCopyKeyRecursive (this routine) again with the two
    // key handles.
    //
    for (i = 0; i < NumberOfSubKeys; i++) {

        KeyNameLength = MAX_PATH;

        status = ScRegEnumKeyW(
                    SourceKey,
                    i,
                    KeyName,
                    KeyNameLength);

        if (status != NO_ERROR) {
            SC_LOG1(ERROR,"ScCopyKeyRecursive, ScRegEnumKey failed %d\n",status);
            return;
        }

        status = ScRegOpenKeyExW(
                    SourceKey,
                    KeyName,
                    REG_OPTION_RESERVED,
                    SC_COPY_KEY_ACCESS,
                    &SourceChildKey);

        if (status != NO_ERROR) {
            SC_LOG2(ERROR,"ScCopyKeyRecursive, ScRegOpenKeyEx (%ws) failed %d\n",
                KeyName,
                status);
            return;
        }


        ScCopyKeyRecursive(*DestKeyPtr, &DestChildKey, SourceChildKey, KeyName);

        ScRegCloseKey(DestChildKey);
        ScRegCloseKey(SourceChildKey);

    } // end-for

    return;
}

VOID
ScCopyKeyValues(
    HKEY    DestKey,
    HKEY    SourceKey,
    DWORD   NumberOfValues,
    DWORD   MaxValueNameLength,
    DWORD   MaxValueDataLength
    )

/*++

Routine Description:

    This function copies all the values stored in the source key to
    the destination key.

Arguments:

    DestKey - This is the key handle for the destination key.

    SourceKey - This is the key handle for the source key.

    NumberOfValues - This is the number of values stored in the source
        key.

    MaxValueNameLength - This is the number of bytes of the largest name
        for a data value.

    MaxValueDataLength - This is the number of bytes in the largest data
        value.

Return Value:

    none - If it fails, the rest of the values will not get stored for
        this key.

Note:


--*/
{
    DWORD       status;
    DWORD       i;
    LPBYTE      DataPtr = NULL;
    LPWSTR      ValueName = NULL;
    DWORD       ValueNameLength;
    DWORD       Type;
    DWORD       DataLength;

    //
    // Add extra onto the lengths because these lengths don't allow
    // for the NULL terminator.
    //
    MaxValueNameLength += sizeof(TCHAR);
    MaxValueDataLength += sizeof(TCHAR);

    DataPtr = (LPBYTE)LocalAlloc(LMEM_FIXED, MaxValueDataLength);
    if (DataPtr == NULL) {
        SC_LOG1(ERROR,"ScCopyKeyValues, LocalAlloc Failed %d\n",GetLastError());
        return;
    }

    ValueName = (LPWSTR)LocalAlloc(LMEM_FIXED, MaxValueNameLength);
    if (ValueName == NULL) {
        SC_LOG1(ERROR,"ScCopyKeyValues, LocalAlloc Failed %d\n",GetLastError());
        LocalFree(DataPtr);
        return;
    }

    for (i=0; i<NumberOfValues; i++) {

        ValueNameLength = MaxValueNameLength;
        DataLength = MaxValueDataLength;


        status = ScRegEnumValueW (
                    SourceKey,
                    i,
                    ValueName,
                    &ValueNameLength,
                    NULL,
                    &Type,
                    DataPtr,
                    &DataLength);

        if (status != NO_ERROR) {
            SC_LOG1(ERROR,"ScCopyKeyValues,ScRegEnumValue Failed %d\n",status);
            break;
        }

        status = ScRegSetValueExW (
                    DestKey,
                    ValueName,
                    0L,
                    Type,
                    DataPtr,
                    DataLength);

        if (status != NO_ERROR) {
            SC_LOG1(ERROR,"ScCopyKeyValues,ScRegSetValueEx Failed %d\n",status);
            break;
        }


    } // end-for

    LocalFree(DataPtr);
    LocalFree(ValueName);
    return;
}
#endif

VOID
ScDeleteRegServiceEntry(
    LPWSTR  ServiceName
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD   status;
    HKEY    parentKey;
    HKEY    keyToDelete;
    ULONG   privileges[4];
    LPWSTR  ServicesKeyPath = SERVICES_KEY;

    //*******************************
    //  Delete the registry node for
    //  This service.
    //*******************************

    privileges[0] = SE_BACKUP_PRIVILEGE;
    privileges[1] = SE_RESTORE_PRIVILEGE;
    privileges[2] = SE_SECURITY_PRIVILEGE;
    privileges[3] = SE_TAKE_OWNERSHIP_PRIVILEGE;
    status = ScGetPrivilege( 4, privileges);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScDeleteRegServiceEntry: ScGetPrivilege Failed %d\n",
            status);
        return;
    }

    //
    // Open the "services" section of the CurrentControlSet.
    //
    status = ScRegOpenKeyExW(
                HKEY_LOCAL_MACHINE,         // hKey
                ServicesKeyPath,            // lpSubKey
                0L,                         // ulOptions (reserved)
                SC_DELETE_KEY_ACCESS,       // desired access
                &parentKey);                // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG2(ERROR,"ScDeleteRegServiceEntry: "
            "ScRegOpenKeyEx (%ws) failed %d\n",ServicesKeyPath,
            status);

        //
        // Restore privileges for the current thread.
        //
        (VOID)ScReleasePrivilege();
        return;
    }
    //
    // Get Key for the Tree we are to delete
    //
    status = ScRegOpenKeyExW(
                parentKey,                  // hKey
                ServiceName,                // lpSubKey
                0L,                         // ulOptions (reserved)
                SC_DELETE_KEY_ACCESS,       // desired access
                &keyToDelete);              // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG2(ERROR,"ScDeleteRegServiceEntry: "
            "ScRegOpenKeyEx (%ws) failed %d\n",ServiceName,
            status);

        ScRegCloseKey(parentKey);
        //
        // Restore privileges for the current thread.
        //
        (VOID)ScReleasePrivilege();
        return;
    }

    //
    // Delete the Key.
    // NOTE: ScDeleteRegTree will also close the handle to the keyToDelete.
    //
    ScDeleteRegTree(parentKey, keyToDelete, ServiceName);

    ScRegCloseKey(parentKey);

    //
    // Restore privileges for the current thread.
    //
    (VOID)ScReleasePrivilege();

    return;

}

VOID
ScGatherOrphanIds(
    HKEY        SystemKey,
    LPDWORD     *OrphanIdPtr,
    LPDWORD     idArray
    )

/*++

Routine Description:

    This function searches through the system key to find any orphan control
    set ids.  If any are found, they are packed into an array of ids that
    are passed back to the caller.

    NOTE:  This function allocates memory for *OrphanIdPtr if orphans
        exist.  It is the responsibility of the caller to free this memory.

Arguments:

    SystemKey - This is an open handle to the system key.

    OrphanIdPtr - This is a pointer to a location for the pointer to
        the array of Orphan IDs.  If there are no orphans, then this pointer
        is NULL on return from this routine.

    idArray - This is the array of IDs that are used in the select key.

Return Value:


Note:


--*/
{
    DWORD   enumStatus;
    DWORD   status;
    WCHAR   KeyName[ MAX_PATH ];
    DWORD   KeyNameLength = MAX_PATH;
    DWORD   i=0;
    DWORD   j=0;
    DWORD   numOrphans=0;
    DWORD   num;
    LPDWORD tempIdArray;
    DWORD   matchInArray;

    WCHAR       ClassName[ MAX_PATH ];
    DWORD       ClassNameLength=MAX_PATH;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;

    //
    // If the pointer points to something - free it. and make the pointer
    // NULL.
    //
    LocalFree(*OrphanIdPtr);
    *OrphanIdPtr = NULL;

    //
    // Find out how many subkeys there are in the system key.
    // This will tell us the maximum size of array required to store
    // potential orphan control set IDs.
    //
    status = ScRegQueryInfoKeyW(
                SystemKey,
                ClassName,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );

    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScGatherOrphanIds: ScRegQueryInfoKey Failed %d\n",status);
        return;
    }

    //
    // Allocate a buffer for the orphan control set IDs.  This buffer is
    // initialized to 0 to guanantee that the array if IDs will be terminated
    // by a 0.
    //
    tempIdArray = (LPDWORD)LocalAlloc(LMEM_ZEROINIT, sizeof(DWORD) * (NumberOfSubKeys+1));
    if (tempIdArray == NULL) {
        SC_LOG0(ERROR, "ScGatherOrphanIds:LocalAlloc Failed\n");
    }

    do {
        enumStatus = ScRegEnumKeyW(
                        SystemKey,
                        i,
                        KeyName,
                        KeyNameLength);

        if (enumStatus == NO_ERROR) {
            //
            // We have a key name, is it a control set?
            //
            if ((wcslen(KeyName) == (CTRL_SET_NAME_CHAR_COUNT)) &&
                (!wcsncmp(
                    CTRL_SET_NAME_TEMPLATE,
                    KeyName,
                    CTRL_SET_NAME_NUM_OFFSET))) {

                //
                // It appears to be a control set, now get the number
                // and see if it is in the array of ids from the select
                // key.
                //
                num = (DWORD)_wtol(KeyName+CTRL_SET_NAME_NUM_OFFSET);

                matchInArray = FALSE;
                for (j=0; j<NUM_IDS; j++) {
                    if (num == idArray[j]) {
                        matchInArray = TRUE;
                        break;
                    }
                }
                //
                // It's not in the array of ids from the select key.
                // Add it to the number of orphans.
                //
                if ((matchInArray == FALSE) && (num < 1000)) {
                    if (numOrphans < NumberOfSubKeys) {
                        tempIdArray[numOrphans] = num;
                        numOrphans++;
                    }
                }
            }
        }
        i++;
    }
    while (enumStatus == NO_ERROR);

    if (numOrphans > 0) {
        *OrphanIdPtr = tempIdArray;
    }
    else {
        *OrphanIdPtr = NULL;
        LocalFree(tempIdArray);
    }
    return;
}

VOID
ScDeleteCtrlSetOrphans(
    VOID
    )

/*++

Routine Description:

    This function deletes orphaned control sets if any exist.  The control
    set numbers for these orphaned sets are pointed to by a global
    memory pointer.  If this pointer is non-null, then there are control sets
    to delete.  After deletion, the memory pointed to by this pointer is
    freed.

    NOTE:  The necessary privileges are expected to be held prior to calling
        this function.

Arguments:

    none

Return Value:

    none

--*/

{
    DWORD   status;
    DWORD   i;
    HKEY    systemKey;
    HKEY    keyToDelete;
    LPWSTR  SystemKeyPath = SYSTEM_KEY;
    WCHAR   nameOfKeyToDelete[CTRL_SET_NAME_CHAR_COUNT+1];

    if (ScGlobalOrphanIds != NULL) {

        //
        // Open the SYSTEM key in the registry.
        //
        status = ScRegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,         // hKey
                    SystemKeyPath,              // lpSubKey
                    0L,                         // ulOptions (reserved)
                    SC_DELETE_KEY_ACCESS,       // desired access
                    &systemKey);                // Newly Opened Key Handle

        if (status != NO_ERROR) {
            SC_LOG2(ERROR,"ScDeleteCtrlSetOrphans: "
                "ScRegOpenKeyEx (%ws) failed %d\n",SystemKeyPath,
                status);

            return;
        }

        for (i=0; ScGlobalOrphanIds[i]!=0; i++) {
            //
            // Use the ID number to get the name and key handle for the
            // KeyToDelete.
            //
            keyToDelete = ScGetCtrlSetHandle(
                            systemKey,
                            ScGlobalOrphanIds[i],
                            nameOfKeyToDelete);

            //
            // Delete the entire tree.  Then go onto the next ID.
            //
            SC_LOG1(TRACE,
                "ScDeleteCtrlSetOrphans, Delete orphan control set %d\n",
                ScGlobalOrphanIds[i]);
            ScDeleteRegTree(systemKey, keyToDelete, nameOfKeyToDelete);
            SC_LOG0(TRACE,"ScDeleteCtrlSetOrphans, Finished Deleting orphan control set\n");
        }

        //
        // Free memory for IDs, and set the global pointer to NULL.
        //
        LocalFree(ScGlobalOrphanIds);
        ScGlobalOrphanIds = NULL;
    }
    return;
}

BOOL
ScMatchInArray(
    DWORD       Value,
    LPDWORD     Array
    )

/*++

Routine Description:

    This function scans through a null terminated array of DWORDs looking
    for a match with the DWORD value that is passed in.

Arguments:

    Value - The DWORD value that we are looking for.

    Array - The pointer to the Array of DWORDs that we are scanning through.

Return Value:

    TRUE - If a the Value is found in the Array.

    FALSE - If it is not found.

--*/
{

    DWORD   i;

    if (Array != NULL) {
        for(i=0; Array[i] != 0; i++) {
            if (Value == Array[i]) {
                return(TRUE);
            }
        }
    }
    return(FALSE);
}

VOID
ScStartCtrlSetCleanupThread(
    )

/*++

Routine Description:

    This function starts a thread that will delete delete any orphaned control sets.

Arguments:

    NONE.


Return Value:

    none

--*/
{
    DWORD   status;
    HANDLE  threadHandle;
    DWORD   threadId;

    threadHandle = CreateThread (
        NULL,                                   // Thread Attributes.
        0L,                                     // Stack Size
        (LPTHREAD_START_ROUTINE)ScCleanupThread,// lpStartAddress
        (LPVOID)0L,                             // lpParameter
        0L,                                     // Creation Flags
        &threadId);                             // lpThreadId

    if (threadHandle == (HANDLE) NULL) {
        SC_LOG1(ERROR,"ScStartCtrlSetCleanupThread:CreateThread failed %d\n",
            GetLastError());
        //
        // If we couldn't create the thread for some reason, then just
        // go ahead and to the cleanup with this thread.  This may make
        // booting the system slow, but it's the best I can do.
        //
        status = ScCleanupThread();
    }
    else {
        CloseHandle(threadHandle);
    }
}

DWORD
ScCleanupThread(
    )

/*++

Routine Description:

    This functions looks through the system key to see if
    there are any orphan control sets to delete.  If found, the orphans
    are deleted.  Orphaned control sets are control sets that exist in
    the system key, but are not referenced in the \system\select key.

    NOTE:  This function should only be called when no other threads are
    creating control sets.  Otherwise, this function may see a new control
    set that is not yet in the select key, and attempt to delete it.

Arguments:

    NONE.

Return Value:

    none.

--*/

{
    DWORD   status;
    HKEY    systemKey=0;
    HKEY    selectKey=0;
    DWORD   idArray[NUM_IDS];
    ULONG   privileges[4];

    //
    // This thread gets SE_SECURITY_PRIVILEGE for copying security
    // descriptors and deleting keys.
    //
    privileges[0] = SE_BACKUP_PRIVILEGE;
    privileges[1] = SE_RESTORE_PRIVILEGE;
    privileges[2] = SE_SECURITY_PRIVILEGE;
    privileges[3] = SE_TAKE_OWNERSHIP_PRIVILEGE;

    status = ScGetPrivilege( 4, privileges);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScCheckLastKnownGood: ScGetPrivilege Failed %d\n",
            status);
        return(FALSE);
    }
    EnterCriticalSection(&ScBootConfigCriticalSection);
    //
    // Get the System, Select, and Clone Keys
    //
    status = ScGetTopKeys(&systemKey, &selectKey);
    if (status != NO_ERROR) {
        SC_LOG0(ERROR,"ScCleanupThread: ScGetTopKeys failed\n");
        LeaveCriticalSection(&ScBootConfigCriticalSection);
        goto CleanExit;
    }

    //
    // Get the ControlSetIds stored in the \system\select key.
    //

    status = ScGetCtrlSetIds(
                selectKey,
                idArray);

    if (status != NO_ERROR) {
        SC_LOG0(ERROR,"ScCleanupThread: ScGetCtrlSetIds Failed\n");
        LeaveCriticalSection(&ScBootConfigCriticalSection);
        goto CleanExit;
    }

    //
    // Scan for Orphaned Control Sets.
    //
    ScGatherOrphanIds(systemKey,&ScGlobalOrphanIds,idArray);

    LeaveCriticalSection(&ScBootConfigCriticalSection);

    if (ScGlobalOrphanIds != NULL) {
        ScDeleteCtrlSetOrphans();
    }

CleanExit:
    if (systemKey != 0) {
        ScRegCloseKey(systemKey);
    }
    if (selectKey != 0) {
        ScRegCloseKey(selectKey);
    }
    (VOID)ScReleasePrivilege();
    return(0);
}

VOID
ScRunAcceptBootPgm(
    VOID
    )

/*++

Routine Description:

    This function is called after the Service Controller has finished
    auto-starting all the auto-start services.  If the boot has already
    been accepted (for instance, WinLogon already called
    NotifyBootConfigStatus()), then at this point we can accept the boot.

    If the boot has not yet been accepted, this function looks in the
    ACCEPT_BOOT_KEY portion of the registry to
    see if there is a value containing the image path of the boot verify
    program to execute.  The program can have any name or path.  If it
    is in the registry, this function will run it.

    This function is called when the service controller thinks that the
    boot has completed successfully.  It is up to the exec'd program
    to decide if this is true or not, and take appropriate action if
    necessary.  The default boot verify program will simply accept the
    boot as is.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD               status;
    LPWSTR              AcceptBootKeyPath = ACCEPT_BOOT_KEY;
    HKEY                AcceptBootKey;
    DWORD               ValueType;
    LPWSTR              pTempImagePath;
    LPWSTR              pImagePath;
    PROCESS_INFORMATION processInfo;
    STARTUPINFOW        StartupInfo;
    DWORD               bufferSize;
    DWORD               charCount;


    //
    // Check to see if the boot has already been accepted.
    //
    EnterCriticalSection(&ScBootConfigCriticalSection);
    ScGlobalLastKnownGood |= AUTO_START_DONE;
    if (ScGlobalLastKnownGood & ACCEPT_DEFERRED) {
        SC_LOG0(BOOT,"ScRunAcceptBootPgm: Boot Acceptance was deferred. Accept "
            "it now\n");
        ScAcceptTheBoot();
        LeaveCriticalSection(&ScBootConfigCriticalSection);
        return;
    }
    LeaveCriticalSection(&ScBootConfigCriticalSection);

    //
    // Open the \CurrentControlSet\Control\AcceptBootPgm Key
    //

    //
    // Get the System Key
    //

    status = ScRegOpenKeyExW(
                HKEY_LOCAL_MACHINE,     // hKey
                AcceptBootKeyPath,      // lpSubKey
                0L,                     // ulOptions (reserved)
                KEY_READ,               // desired access
                &AcceptBootKey);        // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG2(TRACE,"ScRunAcceptBootPgm: ScRegOpenKeyEx (%ws) failed %d\n",
        AcceptBootKeyPath, status);
        return;
    }

    //
    // If the ImagePath value is there, then run the specified
    // program.
    //
    bufferSize = MAX_PATH * sizeof(WCHAR);
    pTempImagePath = (LPWSTR)LocalAlloc(LMEM_FIXED, bufferSize*2);
    if (pTempImagePath == NULL) {
        SC_LOG0(TRACE,"ScRunAcceptBootPgm,LocalAlloc failed \n");
        return;
    }
    pImagePath = pTempImagePath + MAX_PATH;

    status = ScRegQueryValueExW (
                AcceptBootKey,                  // hKey
                IMAGE_PATH_NAME,                // lpValueName
                NULL,                           // lpTitleIndex
                &ValueType,                     // lpType
                (LPBYTE)pTempImagePath,         // lpData
                &bufferSize);                   // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(TRACE,"ScRunAcceptBootPgm,ScRegQueryValueEx failed %d\n",status);
        ScRegCloseKey(AcceptBootKey);
        LocalFree(pTempImagePath);
        return;
    }
    SC_LOG1(TRACE,"ScRunAcceptBootPgm:Executing the %ws program\n",pTempImagePath);
    if ((ValueType == REG_SZ)           ||
        (ValueType == REG_EXPAND_SZ))   {
        if (ValueType == REG_EXPAND_SZ) {
            charCount = ExpandEnvironmentStringsW (
                            pTempImagePath,
                            pImagePath,
                            MAX_PATH);

            if (charCount > MAX_PATH) {
                SC_LOG0(ERROR,"ScRunAcceptBootPgm: ImagePath is too big\n");
                LocalFree(pTempImagePath);
                return;
            }
        }
        else {
            pImagePath = pTempImagePath;
        }

        //
        // Exec the program.
        //

        StartupInfo.cb              = sizeof(STARTUPINFOW); // size
        StartupInfo.lpReserved      = NULL;                 // lpReserved
        StartupInfo.lpDesktop       = NULL;                 // DeskTop
        StartupInfo.lpTitle         = NULL;                 // Title
        StartupInfo.dwX             = 0;                    // X (position)
        StartupInfo.dwY             = 0;                    // Y (position)
        StartupInfo.dwXSize         = 0;                    // XSize (dimension)
        StartupInfo.dwYSize         = 0;                    // YSize (dimension)
        StartupInfo.dwXCountChars   = 0;                    // XCountChars
        StartupInfo.dwYCountChars   = 0;                    // YCountChars
        StartupInfo.dwFillAttribute = 0;                    // FillAttributes
        StartupInfo.dwFlags         = STARTF_FORCEOFFFEEDBACK;
                                                            // Flags - should be STARTF_TASKNOTCLOSABLE
        StartupInfo.wShowWindow     = SW_HIDE;              // ShowWindow
        StartupInfo.cbReserved2     = 0L;                   // cbReserved
        StartupInfo.lpReserved2     = NULL;                 // lpReserved

        if (!CreateProcessW (
                pImagePath,         // Fully qualified image name
                L"",                // Command Line
                NULL,               // Process Attributes
                NULL,               // Thread Attributes
                FALSE,              // Inherit Handles
                DETACHED_PROCESS,   // Creation Flags
                NULL,               // Pointer to Environment block
                NULL,               // Pointer to Current Directory
                &StartupInfo,       // Startup Info
                &processInfo))      // ProcessInformation
        {
            status = GetLastError();
            SC_LOG1(ERROR,
                "ScRunAcceptBootPgm: CreateProcess failed " FORMAT_DWORD "\n",
                 status);
        }

    }

    LocalFree(pTempImagePath);
    ScRegCloseKey(AcceptBootKey);
    return;
}


DWORD
ScAcceptTheBoot(
    VOID
    )

/*++

Routine Description:

    This function does the actual work of accepting the current boot as
    the LKG configuration.

    NOTE:  Before the function is called, the ScBootConfigCriticalSection
    is expected to be entered.

Arguments:


Return Value:


--*/
{
    DWORD   status;
    HKEY    systemKey=0;
    HKEY    selectKey=0;
    DWORD   idArray[NUM_IDS];
    DWORD   newId;
    ULONG   privileges[4];

    //
    // This thread gets SE_SECURITY_PRIVILEGE for copying security
    // descriptors and deleting keys.
    //
    privileges[0] = SE_BACKUP_PRIVILEGE;
    privileges[1] = SE_RESTORE_PRIVILEGE;
    privileges[2] = SE_SECURITY_PRIVILEGE;
    privileges[3] = SE_TAKE_OWNERSHIP_PRIVILEGE;

    status = ScGetPrivilege( 4, privileges);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "RNotifyBootConfigStatus: ScGetPrivilege Failed %d\n",
            status);
        return(status);
    }

    //
    // Get the System, Select, and Clone Keys
    //
    status = ScGetTopKeys(&systemKey, &selectKey);

    if (status != NO_ERROR) {
        SC_LOG0(ERROR,"ScAcceptTheBoot: ScGetTopKeys failed\n");
        SetLastError(status);
        //
        // Restore privileges for the current thread.
        //
        (VOID)ScReleasePrivilege();

        return(status);
    }

    //
    // Get the ControlSetIds stored in the \system\select key.
    //

    status = ScGetCtrlSetIds(
                selectKey,
                idArray);

    if (status != NO_ERROR) {

        SC_LOG0(ERROR,"ScAcceptTheBoot: ScGetCtrlSetIds Failed\n");
        goto CleanExit;
    }

    //
    // Don't commit the LKG profile if this is safe mode, unless we actually
    // booted into the LKG profile.
    //
    if (g_SafeBootEnabled) {

        if (idArray[LKG_ID] != idArray[CURRENT_ID]) {

            ScGlobalBootAccepted = TRUE;
            status = NO_ERROR;
            SC_LOG0(TRACE,"ScAcceptTheBoot: Safe mode boot, not committing LKG\n");
            goto CleanExit;
        }
    }

    //
    // Scan for Orphaned Control Sets.
    // This is required prior to calling ScMakeNewCtrlSet (which
    // avoids the orphaned numbers).
    //
    ScGatherOrphanIds(systemKey,&ScGlobalOrphanIds,idArray);

    //
    // Delete the LastKnownGood ControlSet if there are no other
    // references to that control set.
    //

    SC_LOG0(TRACE,"ScAcceptTheBoot: Delete LKG ControlSet if no ref\n");

    if (  (idArray[LKG_ID] != idArray[FAILED_ID])   &&
          (idArray[LKG_ID] != idArray[DEFAULT_ID])  &&
          (idArray[LKG_ID] != idArray[CURRENT_ID])) {

       newId = idArray[LKG_ID];
    }
    else
    {
       status = ScGetNewCtrlSetId(idArray, &newId);
       if(status != NO_ERROR)
       {
          SC_LOG0(ERROR, "ScAcceptTheBoot: Could Not Get New Control Set Id.\n");
          goto CleanExit;
       }
    }

    //
    // Accept the boot and save the boot configuration as LKG.
    //

    status = RtlNtStatusToDosError(NtInitializeRegistry(REG_INIT_BOOT_ACCEPTED_BASE +
                                                        (USHORT)newId));
    if(status != NO_ERROR)
    {
       SC_LOG1(ERROR, "ScAcceptTheBoot: NtInitializeRegistry Failed with %d",
               status);
       goto CleanExit;
    }

    //
    // Make this control set the LastKnownGood Control Set.
    // This is the ControlSet that we last booted from.
    //

    if(newId != idArray[LKG_ID])
    {
        //
        // We only need to do anything if we did not overwrite the old LKG
        // with NtInitializeRegistry.
        //

        idArray[LKG_ID] = newId;

        status = ScRegSetValueExW(
                                  selectKey,                      // hKey
                                  LKG_VALUE_NAME,                 // lpValueName
                                  0,                              // dwValueTitle (OPTIONAL)
                                  REG_DWORD,                      // dwType
                                  (LPBYTE)&(idArray[LKG_ID]),     // lpData
                                  sizeof(DWORD));                 // cbData

        if (status != NO_ERROR) {
           SC_LOG1(ERROR,"ScAcceptTheBoot: ScRegSetValueEx (LkgValue) failed %d\n",
                   status);
           goto CleanExit;
        }
    }

    //
    // Commit this boot by deleting anything we would undo since previous boot.
    //
    status = ScLastGoodFileCleanup();

    if (status != NO_ERROR) {

        SC_LOG1(ERROR,"ScAcceptTheBoot: LastGoodFileCleanup failed %d\n",
                status);
        goto CleanExit;
    }

    ScGlobalBootAccepted = TRUE;

    status = NO_ERROR;
    SC_LOG0(TRACE,"ScAcceptTheBoot: Done\n");

CleanExit:
    if (systemKey != 0) {
        ScRegCloseKey(systemKey);
    }
    if (selectKey != 0) {
        ScRegCloseKey(selectKey);
    }

    //
    // Restore privileges for the current thread.
    //
    (VOID)ScReleasePrivilege();

    return(status);
}

BOOL
SetupInProgress(
    HKEY    SystemKey,
    PBOOL   pfIsOOBESetup    OPTIONAL
    )

/*++

Routine Description:

    Checks a registry location to determine if Setup is in Progress.
    \HKEY_LOCAL_MACHINE\System\Setup
         value=DWORD SystemSetupInProgress
    The value is cached so that the registry is examined only on the
    first call to this function.

Arguments:

    SystemKey - open handle to HKEY_LOCAL_MACHINE\System.
        This is ignored in all except the first call to this function.

Return Value:

    TRUE - If Setup is in progress

    FALSE - If Setup isn't in progress

--*/
{
    static  DWORD TheValue=0xffffffff; // 0=false, 1=true,
                                       // 0xffffffff=uninitialized
    static  DWORD IsOOBE;

    DWORD   status=NO_ERROR;
    DWORD   BytesRequired = sizeof(TheValue);
    HKEY    KeyHandle;

    if (TheValue == 0xffffffff)
    {
        //
        // First call
        //

        SC_ASSERT(SystemKey != NULL);

        TheValue = 0;
        IsOOBE = 0;

        status = ScRegOpenKeyExW(
                    SystemKey,
                    SETUP_PROG_KEY,
                    0L,
                    KEY_READ,
                    &KeyHandle);

        if (status == NO_ERROR)
        {
            //
            // There are two registry values that may be set here:
            //
            //    1.  OobeInProgress -- if it exists and is non-zero,
            //            this is an OOBE boot.
            //
            //    2.  SystemSetupInProgress -- if it exists and is
            //            non-zero AND it's not an OOBE boot, it's
            //            GUI-mode setup.  If OOBE's in progress,
            //            don't even bother checking this one (it may
            //            or may not be set depending on whether we're
            //            in retail OOBE or mini-setup OOBE) and return
            //            FALSE from SetupInProgress (along with the
            //            appropriate OOBE value).
            //

            status = ScRegQueryValueExW(
                        KeyHandle,
                        REGSTR_VALUE_OOBEINPROGRESS,
                        NULL,
                        NULL,
                        (LPBYTE) &IsOOBE,
                        &BytesRequired);

            if (IsOOBE != 0)
            {
                SC_ASSERT(status == NO_ERROR);
                IsOOBE = 1;
            }

            if (IsOOBE == 0)
            {
                status = ScRegQueryValueExW(
                            KeyHandle,
                            SETUP_PROG_VALUE_NAME,
                            NULL,
                            NULL,
                            (LPBYTE) &TheValue,
                            &BytesRequired);

                if (TheValue != 0)
                {
                    SC_ASSERT(status == NO_ERROR);
                    TheValue = 1;
                }
            }

            ScRegCloseKey(KeyHandle);
        }
    }

    SC_LOG(TRACE,"SetupInProgress = %d (0=FALSE,else TRUE)\n",TheValue);

    if (pfIsOOBESetup)
    {
        SC_LOG(TRACE, "SetupInProgress:  IsOOBE = %d (0=FALSE,else TRUE)\n", IsOOBE);
        *pfIsOOBESetup = IsOOBE;
    }

    return TheValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\account.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    account.cxx

Abstract:

    This module contains service account related routines:
        ScInitServiceAccount
        ScEndServiceAccount
        ScCanonAccountName
        ScValidateAndSaveAccount
        ScValidateAndChangeAccount
        ScRemoveAccount
        ScLookupAccount
        ScSetPassword
        ScDeletePassword
        ScOpenPolicy
        ScFormSecretName
        ScLookupServiceAccount
        ScLogonService
        ScLoadUserProfile
        ScUPNToAccountName

Author:

    Rita Wong (ritaw)     19-Apr-1992

Environment:

    Calls NT native APIs.

Revision History:

    24-Jan-1993     Danl
        Added call to WNetLogonNotify when logging on a service (ScLogonService).

    29-Apr-1993     Danl
        ScGetAccountDomainInfo() is now only called at init time.  Otherwise,
        we risked race conditions because it updates a global location.
        (ScLocalDomain).

    17-Jan-1995     AnirudhS
        Added call to LsaOpenSecret when the secret already exists in
        ScCreatePassword.

    29-Nov-1995     AnirudhS
        Added call to LoadUserProfile when logging on a service.

    14-May-1996     AnirudhS
        Changed to simpler Lsa PrivateData APIs instead of Lsa Secret APIs
        for storing secrets and removed the use of OldPassword (as done in
        the _CAIRO_ version of this file on 05-Apr-1995).

    22-Oct-1997     JSchwart  (after AnirudhS in _CAIRO_ 10-Apr-1995)
        Split out ScLookupServiceAccount from ScLogonService.

    04-Mar-1999     jschwart
        Added support for UPNs

--*/

#include "precomp.hxx"
#include <stdlib.h>                 // srand, rand

extern "C" {
#include <ntlsa.h>                  // LsaOpenPolicy, LsaCreateSecret
}

#include <winerror.h>
#include <userenv.h>                // LoadUserProfile
#include <userenvp.h>               // PI_HIDEPROFILE flag
#include <tstr.h>                   // WCSSIZE
#include <ntdsapi.h>                // DsCrackNames
#include <sclib.h>                  // _wcsicmp
#include <scseclib.h>               // LocalSid
#include "scconfig.h"               // ScWriteStartName
#include "account.h"                // Exported function prototypes

//-------------------------------------------------------------------//
//                                                                   //
// Constants and Macros                                              //
//                                                                   //
//-------------------------------------------------------------------//

#define SC_SECRET_PREFIX               L"_SC_"
#define SC_UPN_SYMBOL                  L'@'

//-------------------------------------------------------------------//
//                                                                   //
// Static global variables                                           //
//                                                                   //
//-------------------------------------------------------------------//

//
// Mutex to serialize access to secret objects
//
HANDLE ScSecretObjectsMutex = (HANDLE) NULL;

//
// LSA Authentication Package expects the local computername to
// be specified for the account domain if the system is WinNT,
// and the primary domain to be specified if the system is LanmanNT.
// Set ScLocalDomain to point to either ScComputerName or
// ScAccountDomain depending on the product type.
//
PUNICODE_STRING ScLocalDomain;
UNICODE_STRING ScComputerName;
UNICODE_STRING ScAccountDomain;


//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
ScLookupAccount(
    IN  LPWSTR AccountName,
    OUT LPWSTR *DomainName,
    OUT LPWSTR *UserName
    );

DWORD
ScSetPassword(
    IN LPWSTR ServiceName,
    IN LPWSTR Password
    );

DWORD
ScDeletePassword(
    IN LPWSTR ServiceName
    );

DWORD
ScOpenPolicy(
    IN  ACCESS_MASK DesiredAccess,
    OUT LSA_HANDLE *PolicyHandle
    );

DWORD
ScFormSecretName(
    IN  LPWSTR ServiceName,
    OUT LPWSTR *LsaSecretName
    );

VOID
ScLoadUserProfile(
    IN  HANDLE  LogonToken,
    IN  LPWSTR  DomainName,
    IN  LPWSTR  UserName,
    OUT PHANDLE pProfileHandle OPTIONAL
    );

DWORD
ScUPNToAccountName(
    IN  LPWSTR  lpUPN,
    OUT LPWSTR  *ppAccountName
    );


//-------------------------------------------------------------------//
//                                                                   //
// Functions                                                         //
//                                                                   //
//-------------------------------------------------------------------//


BOOL
ScGetComputerNameAndMutex(
    VOID
    )
/*++

Routine Description:

    This function allocates the memory for the ScComputerName global
    pointer and retrieves the current computer name into it.  This
    functionality used to be in the ScInitAccount routine but has to
    be put into its own routine because the main initialization code
    needs to call this before ScInitDatabase() since the computername
    is needed for deleting service entries that have the persistent
    delete flag set.

    This function also creates ScSecretObjectsMutex because it is used
    to remove accounts early in the init process.

    If successful, the pointer to the computername must be freed when
    done.  This is freed by the ScEndServiceAccount routine called
    by SvcctrlMain().  The handle to ScSecretObjectsMutex is closed
    by ScSecretObjectsMutex.

Arguments:

    None

Return Value:

    TRUE - The operation was completely successful.

    FALSE - An error occurred.

--*/
{
    DWORD ComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;



    ScComputerName.Buffer = NULL;

    //
    // Allocate the exact size needed to hold the computername
    //
    if ((ScComputerName.Buffer = (LPWSTR)LocalAlloc(
                                     LMEM_ZEROINIT,
                                     (UINT) ComputerNameSize * sizeof(WCHAR)
                                     )) == NULL) {

        SC_LOG1(ERROR, "ScInitServiceAccount: LocalAlloc failed %lu\n", GetLastError());
        return FALSE;
    }

    ScComputerName.MaximumLength = (USHORT) ComputerNameSize * sizeof(WCHAR);

    if (! GetComputerNameW(
            ScComputerName.Buffer,
            &ComputerNameSize
            )) {

        SC_LOG2(ERROR, "GetComputerNameW returned %lu, required size=%lu\n",
                GetLastError(), ComputerNameSize);

        LocalFree(ScComputerName.Buffer);
        ScComputerName.Buffer = NULL;

        return FALSE;
    }

    ScComputerName.Length = (USHORT) (wcslen(ScComputerName.Buffer) * sizeof(WCHAR));

    SC_LOG(ACCOUNT, "ScInitServiceAccount: ScComputerName is "
           FORMAT_LPWSTR "\n", ScComputerName.Buffer);

    //
    // Create a mutex to serialize accesses to all secret objects.  A secret
    // object can be created, deleted, or set by installation programs, set
    // by the service controller during periodic password changes, and queried
    // or set by a start service operation.
    //
    ScSecretObjectsMutex = CreateMutex(NULL, FALSE, NULL);

    if (ScSecretObjectsMutex == NULL) {
        SC_LOG1(ERROR, "ScInitServiceAccount: CreateMutex failed "
                FORMAT_DWORD "\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}



BOOL
ScInitServiceAccount(
    VOID
    )
/*++

Routine Description:

    This function initializes accounts for services by
         2) Register service controller as an LSA logon process and
            lookup the MS V 1.0 authentication package.

Arguments:

    None

Return Value:

    TRUE - The operation was completely successful.

    FALSE - An error occurred.

--*/
{
    DWORD    status;

    //
    // Initialize the account domain buffer so that we know if it has
    // been filled in.
    //
    ScAccountDomain.Buffer = NULL;

    status = ScGetAccountDomainInfo();

    if (status != NO_ERROR)
    {
        SC_LOG1(ERROR, "ScInitServiceAccount: ScGetAccountDomainInfo failed "
                FORMAT_DWORD "\n", status);
        return FALSE;
    }

    return TRUE;
}


VOID
ScEndServiceAccount(
    VOID
    )
/*++

Routine Description:

    This function frees the memory for the ScComputerName global pointer,
    and closes the ScSecretObjectsMutex.

Arguments:

    None.

Return Value:

    None.
--*/
{
    //
    // Free computer name buffer allocated by ScGetComputerName
    //
    LocalFree(ScComputerName.Buffer);
    ScComputerName.Buffer = NULL;

    if (ScSecretObjectsMutex != (HANDLE) NULL)
    {
        CloseHandle(ScSecretObjectsMutex);
    }

    LocalFree(ScAccountDomain.Buffer);
}


DWORD
ScValidateAndSaveAccount(
    IN LPWSTR ServiceName,
    IN HKEY   ServiceNameKey,
    IN LPWSTR CanonAccountName,
    IN LPWSTR Password OPTIONAL
    )
/*++

Routine Description:

    This function verifies that the account is valid, and then saves
    the account information away.  The account name is saved in the
    registry under the service node in the ObjectName value.  The
    password is saved in an LSA secret object created which can be
    looked up based on the name string formed with the service name.

    This function can only be called for the installation of a Win32
    service (CreateService).

    NOTE:  The registry ServiceNameKey is NOT flushed by this function.

Arguments:

    ServiceName - Supplies the name of the service to save away account
        info for.  This makes up part of the secret object name to tuck
        away the password.

    ServiceNameKey - Supplies an opened registry key handle for the service.

    CanonAccountName - Supplies a canonicalized account name string in the
        format of DomainName\Username, LocalSystem, or UPN

    Password - Supplies the password of the account, if any.  This is
        ignored if LocalSystem is specified for the account name.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_SERVICE_ACCOUNT - The account name is invalid.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate work buffer.

    Registry error codes caused by failure to read old account name
    string.

--*/
{
    DWORD status;

    LPWSTR DomainName;
    LPWSTR UserName;

    LPWSTR lpNameToParse = CanonAccountName;

    //
    // Empty account name is invalid.
    //
    if ((CanonAccountName == NULL) || (*CanonAccountName == 0)) {
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    if (_wcsicmp(CanonAccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

        //
        // CanonAccountName is LocalSystem.  Write to the registry and
        // we are done.
        //
        return ScWriteStartName(
                   ServiceNameKey,
                   SC_LOCAL_SYSTEM_USER_NAME
                   );

    }

    //
    // Account name is DomainName\UserName or a UPN
    //

    if (wcschr(CanonAccountName, SCDOMAIN_USERNAME_SEPARATOR) == NULL
         &&
        wcschr(CanonAccountName, SC_UPN_SYMBOL) != NULL)
    {
        //
        // It's a UPN -- we need to crack it
        //
        status = ScUPNToAccountName(CanonAccountName, &lpNameToParse);

        if (status != NO_ERROR) {
            return status;
        }
    }

    //
    // Look up the account to see if it exists.
    //
    if ((status = ScLookupAccount(
                      lpNameToParse,
                      &DomainName,
                      &UserName
                      )) != NO_ERROR) {

        if (lpNameToParse != CanonAccountName) {
            LocalFree(lpNameToParse);
        }

        return status;
    }

    //
    // Write the new account name to the registry.
    // Note -- for UPNs, write the UPN to the registry, not
    // the cracked UPN
    //
    if ((status = ScWriteStartName(
                      ServiceNameKey,
                      CanonAccountName
                      )) != NO_ERROR) {

        if (lpNameToParse != CanonAccountName) {
            LocalFree(lpNameToParse);
        }

        LocalFree(DomainName);
        return status;
    }

    //
    // Create the password for the new account.
    //
    status = ScSetPassword(
                 ServiceName,
                 Password
                 );

    if (lpNameToParse != CanonAccountName) {
        LocalFree(lpNameToParse);
    }

    LocalFree(DomainName);
    return status;

    //
    // Don't have to worry about removing the account name written to
    // the registry if ScSetPassword returned an error because the
    // entire service key will be deleted by the caller of this routine.
    //
}


DWORD
ScValidateAndChangeAccount(
    IN LPSERVICE_RECORD  ServiceRecord,
    IN HKEY              ServiceNameKey,
    IN LPWSTR            OldAccountName,
    IN LPWSTR            CanonAccountName,
    IN LPWSTR            Password OPTIONAL
    )
/*++

Routine Description:

    This function validates that the account is valid, and then replaces
    the old account information.  The account name is saved in the
    registry under the service node in the ObjectName value.  The
    password is saved in an LSA secret object created which can be
    looked up based on the name string formed with the service name.

    This function can only be called for the reconfiguration of a Win32
    service (ChangeServiceConfig).

    NOTE:  The registry ServiceNameKey is NOT flushed by this function.

Arguments:

    ServiceRecord - Supplies the record of the service to change account
        info.  This makes up part of the secret object name to tuck
        away the password.

    ServiceNameKey - Supplies an opened registry key handle for the service.

    OldAccountName - Supplies the string to the old account name.

    CanonAccountName - Supplies a canonicalized account name string in the
        format of DomainName\Username, LocalSystem, or a UPN.

    Password - Supplies the password of the account, if any.  This is
        ignored if LocalSystem is specified for the account name.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_SERVICE_ACCOUNT - The account name is invalid.

    ERROR_ALREADY_EXISTS - Attempt to create an LSA secret object that
        already exists.

    Registry error codes caused by failure to read old account name
    string.

--*/
{
    DWORD status;

    LPWSTR DomainName;
    LPWSTR UserName;

    BOOL   fIsUPN = FALSE;
    LPWSTR lpNameToParse = CanonAccountName;

    if ((CanonAccountName == OldAccountName) ||
        (_wcsicmp(CanonAccountName, OldAccountName) == 0)) {

        //
        // Newly specified account name is identical to existing
        // account name.
        //

        if (Password == NULL) {

            //
            // Not changing account name or password.
            //
            return NO_ERROR;
        }

        if (_wcsicmp(CanonAccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

            //
            // Account name is LocalSystem and password is specified.
            // Just ignore.
            //
            return NO_ERROR;
        }
        else {

            //
            // Account name is DomainName\UserName or a UPN.
            // Set the specified password.
            //

            status = ScSetPassword(
                         ServiceRecord->ServiceName,
                         Password);

            return status;
        }
    }

    //
    // Newly specified account name is different from existing
    // account name.
    //

    if (Password == NULL) {

        //
        // Cannot specify new account name without specifying
        // the password also.
        //
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    if (_wcsicmp(CanonAccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

        //
        // Change from DomainName\UserName or UPN to LocalSystem
        //

        //
        // Write the new account name to the registry.
        //
        if ((status = ScWriteStartName(
                          ServiceNameKey,
                          SC_LOCAL_SYSTEM_USER_NAME
                          )) != NO_ERROR) {

            return status;
        }

        //
        // Account name is LocalSystem and password is specified.
        // Ignore the password specified, and delete the password
        // for the old account.
        //
        status = ScDeletePassword(ServiceRecord->ServiceName);

        if (status != NO_ERROR) {
            //
            // Restore the old account name to the registry.
            //
            ScWriteStartName(ServiceNameKey,
                             OldAccountName);

        }
        else {

            LPWSTR  CurrentDependencies;

            //
            // Get rid of the implicit dependency on NetLogon since this
            // service no longer runs in an account.  Since the dependency
            // on NetLogon is soft (i.e., not stored in the registry),
            // simply read in the dependencies and update the service record
            //

            status = ScReadDependencies(ServiceNameKey,
                                        &CurrentDependencies,
                                        ServiceRecord->ServiceName);

            if (status == NO_ERROR) {

                //
                // Dynamically update the dependencies
                //

                status = ScUpdateServiceRecordConfig(
                             ServiceRecord,
                             SERVICE_NO_CHANGE,
                             SERVICE_NO_CHANGE,
                             SERVICE_NO_CHANGE,
                             NULL,
                             (LPBYTE) CurrentDependencies);

                if (status != NO_ERROR) {

                    SC_LOG1(ERROR,
                            "ScValidateAndChangeAccount: ScUpdateServiceRecordConfig "
                                "FAILED %d\n",
                            status);
                }

                LocalFree(CurrentDependencies);
            }
            else {

                SC_LOG1(ERROR,
                        "ScValidateAndChangeAccount: ScReadDependencies "
                            "FAILED %d\n",
                        status);
            }
        }

        return status;
    }

    if (_wcsicmp(OldAccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

        //
        // Change from LocalSystem to DomainName\UserName or UPN.
        //
        if (wcschr(CanonAccountName, SCDOMAIN_USERNAME_SEPARATOR) == NULL
             &&
            wcschr(CanonAccountName, SC_UPN_SYMBOL) != NULL)
        {
            fIsUPN = TRUE;
            status = ScUPNToAccountName(CanonAccountName, &lpNameToParse);

            if (status != NO_ERROR) {
                return status;
            }
        }

        if ((status = ScLookupAccount(
                          lpNameToParse,
                          &DomainName,
                          &UserName
                          )) != NO_ERROR) {

            if (fIsUPN) {
                LocalFree(lpNameToParse);
            }

            return status;
        }

        //
        // Write the new account name to the registry.
        //
        if ((status = ScWriteStartName(
                          ServiceNameKey,
                          CanonAccountName
                          )) != NO_ERROR) {

            if (fIsUPN) {
                LocalFree(lpNameToParse);
            }

            LocalFree(DomainName);
            return status;
        }

        //
        // Create the password for the new account.
        //
        status = ScSetPassword(
                     ServiceRecord->ServiceName,
                     Password);


        if (status != NO_ERROR) {
            //
            // Restore the old account name to the registry.
            //
            (void) ScWriteStartName(
                       ServiceNameKey,
                       SC_LOCAL_SYSTEM_USER_NAME);
        }

        if (fIsUPN) {
            LocalFree(lpNameToParse);
        }

        LocalFree(DomainName);
        return status;
    }

    //
    // Must be changing an account of DomainName\UserName or UPN to
    // DomainName\UserName or UPN
    //
    if (wcschr(CanonAccountName, SCDOMAIN_USERNAME_SEPARATOR) == NULL
         &&
        wcschr(CanonAccountName, SC_UPN_SYMBOL) != NULL)
    {
        fIsUPN = TRUE;
        status = ScUPNToAccountName(CanonAccountName, &lpNameToParse);

        if (status != NO_ERROR) {
            return status;
        }
    }

    if ((status = ScLookupAccount(
                      lpNameToParse,
                      &DomainName,
                      &UserName
                      )) != NO_ERROR) {

        if (fIsUPN) {
            LocalFree(lpNameToParse);
        }

        return status;
    }

    //
    // Write the new account name to the registry.
    //
    if ((status = ScWriteStartName(
                      ServiceNameKey,
                      CanonAccountName
                      )) != NO_ERROR) {

        if (fIsUPN) {
            LocalFree(lpNameToParse);
        }

        LocalFree(DomainName);
        return status;
    }

    //
    // Set the password for the new account.
    //
    status = ScSetPassword(ServiceRecord->ServiceName,
                           Password);

    if (status != NO_ERROR) {

        //
        // Restore the old account name to the registry.
        //
        ScWriteStartName(ServiceNameKey,
                         OldAccountName);
    }
    else if (*DomainName == L'.' && !fIsUPN) {

        LPWSTR CurrentDependencies;

        //
        // Get rid of the implicit dependency on NetLogon since this
        // service now runs in a local account (domain is ".\")
        //

        status = ScReadDependencies(ServiceNameKey,
                                    &CurrentDependencies,
                                    ServiceRecord->ServiceName);

        if (status == NO_ERROR) {

            //
            // Dynamically update the dependencies
            //

            status = ScUpdateServiceRecordConfig(
                         ServiceRecord,
                         SERVICE_NO_CHANGE,
                         SERVICE_NO_CHANGE,
                         SERVICE_NO_CHANGE,
                         NULL,
                         (LPBYTE) CurrentDependencies);

            if (status != NO_ERROR) {

                SC_LOG1(ERROR,
                        "ScValidateAndChangeAccount: ScUpdateServiceRecordConfig "
                            "FAILED %d\n",
                        status);
            }

            LocalFree(CurrentDependencies);
        }
        else {

            SC_LOG1(ERROR,
                    "ScValidateAndChangeAccount: ScReadDependencies "
                        "FAILED %d\n",
                    status);
        }
    }

    if (fIsUPN) {
        LocalFree(lpNameToParse);
    }

    LocalFree(DomainName);
    return status;
}


VOID
ScRemoveAccount(
    IN LPWSTR ServiceName
    )
{
    (void) ScDeletePassword(ServiceName);
}


DWORD
ScCanonAccountName(
    IN  LPWSTR AccountName,
    OUT LPWSTR *CanonAccountName
    )
/*++

Routine Description:

    This function canonicalizes the account name and allocates the
    returned buffer for returning the canonicalized string.

      AccountName               *CanonAccountName
      -----------               -----------------

      .\UserName                .\UserName
      ComputerName\UserName     .\UserName

      LocalSystem               LocalSystem
      .\LocalSystem             LocalSystem
      ComputerName\LocalSystem  LocalSystem

      DomainName\UserName       DomainName\UserName

      DomainName\LocalSystem    Error!

      UPN (foo@bar)             UPN (foo@bar)


    Caller must free the CanonAccountName pointer with LocalFree when done.

Arguments:

    AccountName - Supplies a pointer to the account name.

    CanonAccountName - Receives a pointer to the buffer (allocated by this
        routine) which contains the canonicalized account name.  Must
        free this pointer with LocalFree.

Return Value:

    NO_ERROR - Successful canonicalization.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory trying to allocate CanonAccountName
        buffer.

    ERROR_INVALID_SERVICE_ACCOUNT - Invalid account name.

--*/
{
    LPWSTR BufPtr = wcschr(AccountName, SCDOMAIN_USERNAME_SEPARATOR);


    //
    // Allocate buffer for receiving the canonicalized account name.
    //
    if ((*CanonAccountName = (LPWSTR)LocalAlloc(
                                 0,
                                 WCSSIZE(AccountName) +
                                     ScComputerName.MaximumLength
                                 )) == NULL) {

        SC_LOG1(ERROR, "ScCanonAccountName: LocalAlloc failed %lu\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (BufPtr == NULL) {

        //
        // Backslash is not found.
        //

        if (_wcsicmp(AccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0
             ||
             wcschr(AccountName, SC_UPN_SYMBOL) != NULL)
        {
            //
            // Account name is LocalSystem or a UPN
            //
            wcscpy(*CanonAccountName, AccountName);
            return NO_ERROR;
        }
        else {

            //
            // The AccountName is neither LocalSystem nor a UPN -- invalid.
            //
            SC_LOG1(ERROR,
                    "Account name %ws is not LocalSystem and has no \\ or @\n",
                    AccountName);

            LocalFree(*CanonAccountName);
            *CanonAccountName = NULL;
            return ERROR_INVALID_SERVICE_ACCOUNT;
        }
    }

    //
    // BufPtr points to the first occurrence of backslash in
    // AccountName.
    //

    //
    // If first portion of the AccountName matches ".\" or "ComputerName\"
    //
    if ((wcsncmp(AccountName, L".\\", 2) == 0) ||
        ((_wcsnicmp(AccountName, ScComputerName.Buffer,
                  ScComputerName.Length / sizeof(WCHAR)) == 0) &&
        ((LPWSTR) ((DWORD_PTR) AccountName + ScComputerName.Length) == BufPtr))) {

        if (_wcsicmp(BufPtr + 1, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

            //
            // .\LocalSystem -> LocalSystem OR
            // Computer\LocalSystem -> LocalSystem
            //
            wcscpy(*CanonAccountName, SC_LOCAL_SYSTEM_USER_NAME);
            return NO_ERROR;
        }

        //
        // .\XXX -> .\XXX
        // ComputerName\XXX -> .\XXX
        //
        wcscpy(*CanonAccountName, SC_LOCAL_DOMAIN_NAME);
        wcscat(*CanonAccountName, BufPtr);
        return NO_ERROR;
    }

    //
    // First portion of the AccountName specifies a domain name other than
    // the local one.  This domain name will be validated later in
    // ScValidateAndSaveAccount.
    //
    if (_wcsicmp(BufPtr + 1, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

        //
        // XXX\LocalSystem is invalid.
        //
        LocalFree(*CanonAccountName);
        *CanonAccountName = NULL;
        SC_LOG0(ERROR, "Account name is LocalSystem but is not local\n");
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    wcscpy(*CanonAccountName, AccountName);
    return NO_ERROR;
}


BOOL
GetDefaultDomainName(
    LPWSTR DomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;


    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        return(FALSE);
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        LsaClose(LsaPolicyHandle);
        return(FALSE);
    }


    (void) LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache, and
    //

    CopyMemory( DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // Null terminate it appropriately
    //

    DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //
    LsaFreeMemory( (PVOID)DomainInfo );

    return TRUE;

}


DWORD
ScLookupAccount(
    IN  LPWSTR AccountName,
    OUT LPWSTR *DomainName,
    OUT LPWSTR *UserName
    )
/*++

Routine Description:

    This function calls LsaLookupNames to see if the specified username
    exists in the specified domain name.  If this function returns
    NO_ERROR, DomainName and UserName pointers will be set to the
    domain name and username strings in the buffer allocated by this
    function.

    The caller must free the returned buffer by calling LocalFree
    on the pointer returned in DomainName.

Arguments:

    AccountName - Supplies the account name in the format of
        DomainName\UserName to look up.

    DomainName - Receives a pointer to the allocated buffer which
        contains the NULL-terminated domain name string, followed
        by the NULL-terminated user name string.

    UserName - Receives a pointer to the username in the returned
        buffer allocated by this routine.

Return Value:

    NO_ERROR - UserName is found in the DomainName.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate work buffer.

    ERROR_INVALID_SERVICE_ACCOUNT - any other error that is encountered
        in this function.
--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    LSA_HANDLE PolicyHandle;

    UNICODE_STRING AccountNameString;

    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains;
    PLSA_TRANSLATED_SID Sids;

    LPWSTR BackSlashPtr;

    LPWSTR LocalAccount = NULL;

    WCHAR Domain[MAX_COMPUTERNAME_LENGTH+1];


    //
    // Allocate buffer for separating AccountName into DomainName and
    // UserName.
    //
    if ((*DomainName = (LPWSTR) LocalAlloc(
                                    0,
                                    WCSSIZE(AccountName)
                                    )) == NULL) {
        SC_LOG1(ERROR, "ScLookupAccount: LocalAlloc failed %lu\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Find the backslash character in the specified account name
    //
    wcscpy(*DomainName, AccountName);
    BackSlashPtr = wcschr(*DomainName, SCDOMAIN_USERNAME_SEPARATOR);

    if (BackSlashPtr == NULL) {
        SC_LOG0(ERROR, "ScLookupAccount: No backslash in account name!\n");

        ScLogEvent(NEVENT_BAD_ACCOUNT_NAME);
            
        SC_ASSERT(FALSE);
        status = ERROR_GEN_FAILURE;
        goto CleanExit;
    }

    *UserName = BackSlashPtr + 1; // Skip the backslash

    if (_wcsnicmp(*DomainName, SC_LOCAL_DOMAIN_NAME, wcslen(SC_LOCAL_DOMAIN_NAME)) == 0) {
        //
        // DomainName is "." (local domain), so convert "." to the
        // local domain name, which on WinNT systems is the computername,
        // and on Adv Server systems it's the account domain name.
        //

        //
        // Allocate buffer to hold Domain\UserName string.
        //

        //
        // this code does not use the global var LocalDomain because it
        // contains invalid data during gui mode setup.  if a service
        // that needs an account/password is created during gui mode
        // setup, the create would fail with the LocalDomain value.  calling
        // the GetDefaultDomainName funtion guarantees that we have
        // the correct value in all cases.
        //

        if (!GetDefaultDomainName( Domain )) {
            SC_LOG0( ERROR, "ScLookupAccount: GetDefaultDomainName failed\n");
            status = ERROR_GEN_FAILURE;
            goto CleanExit;
        }

        if ((LocalAccount = (LPWSTR) LocalAlloc(
                                         LMEM_ZEROINIT,
                                         WCSSIZE(Domain) + WCSSIZE(*UserName)
                                         )) == NULL)
        {
            SC_LOG1(ERROR, "ScLookupAccount: LocalAlloc failed %lu\n", GetLastError());
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }

        wcscpy( LocalAccount, Domain );
        wcscat( LocalAccount, BackSlashPtr );

        RtlInitUnicodeString( &AccountNameString, LocalAccount );
    }
    else {
        //
        // Lookup the domain-qualified name.
        //
        RtlInitUnicodeString(&AccountNameString, *DomainName);
    }

    //
    // Open a handle to the local security policy.
    //
    if (ScOpenPolicy(
            POLICY_LOOKUP_NAMES |
                POLICY_VIEW_LOCAL_INFORMATION,
            &PolicyHandle
            ) != NO_ERROR) {
        SC_LOG0(ERROR, "ScLookupAccount: ScOpenPolicy failed\n");
        status = ERROR_INVALID_SERVICE_ACCOUNT;
        goto CleanExit;
    }


    ntstatus = LsaLookupNames(
                   PolicyHandle,
                   1,
                   &AccountNameString,
                   &ReferencedDomains,
                   &Sids
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR,
               "ScLookupAccount: LsaLookupNames returned " FORMAT_NTSTATUS "\n",
               ntstatus);

        (void) LsaClose(PolicyHandle);

        status = ERROR_INVALID_SERVICE_ACCOUNT;
        goto CleanExit;
    }

    //
    // Don't need PolicyHandle anymore
    //
    (void) LsaClose(PolicyHandle);


    //
    // Free the returned SIDs since we don't look at them.
    //
    if (Sids != NULL) {
        LsaFreeMemory((PVOID) Sids);
    }

    if (ReferencedDomains == NULL) {
        SC_LOG1(ERROR, "ScLookupAccount: Did not find " FORMAT_LPWSTR
               " in any domain\n", AccountNameString.Buffer);
        status = ERROR_INVALID_SERVICE_ACCOUNT;
        goto CleanExit;
    }
    else {
        LsaFreeMemory((PVOID) ReferencedDomains);
    }

    status = NO_ERROR;

    //
    // Convert DomainName\UserName into DomainName0UserName.
    //
    *BackSlashPtr = 0;

CleanExit:

    LocalFree(LocalAccount);

    if (status != NO_ERROR) {
        LocalFree(*DomainName);
        *DomainName = NULL;
    }

    return status;
}



DWORD
ScSetPassword(
    IN LPWSTR ServiceName,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This function sets the secret object for the service with the specified
    password.  If the secret object doesn't already exist, it is created.

Arguments:

    ServiceName - Supplies the service name which is part of the secret
        object name to be created.

    Password - Supplies the user specified password for an account.

Return Value:

    NO_ERROR - Secret object for the password is created and set with new value.

    ERROR_INVALID_SERVICE_ACCOUNT - for any error encountered in this
        function.  The true error is written to the event log.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    LSA_HANDLE PolicyHandle;
    LPWSTR LsaSecretName;
    UNICODE_STRING SecretNameString;
    UNICODE_STRING NewPasswordString;

    //
    // Open a handle to the local security policy.
    //
    if (ScOpenPolicy(
            POLICY_CREATE_SECRET,
            &PolicyHandle
            ) != NO_ERROR) {
        SC_LOG0(ERROR, "ScSetPassword: ScOpenPolicy failed\n");
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    //
    // Create the secret object.  But first, let's form a secret
    // name that is very difficult to guess.
    //
    if ((status = ScFormSecretName(
                      ServiceName,
                      &LsaSecretName
                      )) != NO_ERROR) {
        LsaClose(PolicyHandle);
        return status;
    }

    //
    // Serialize secret object operations
    //
    if (WaitForSingleObject(ScSecretObjectsMutex, INFINITE) == MAXULONG) {

        status = GetLastError();
        SC_LOG1(ERROR, "ScSetPassword: WaitForSingleObject failed "
                FORMAT_DWORD "\n", status);

        LocalFree(LsaSecretName);
        (void) LsaClose(PolicyHandle);
        return status;
    }

    RtlInitUnicodeString(&SecretNameString, LsaSecretName);
    RtlInitUnicodeString(&NewPasswordString, Password);

    ntstatus = LsaStorePrivateData(
                   PolicyHandle,
                   &SecretNameString,
                   &NewPasswordString
                   );

    if (NT_SUCCESS(ntstatus)) {

        SC_LOG1(ACCOUNT, "ScSetPassword " FORMAT_LPWSTR " success\n",
                ServiceName);

        status = NO_ERROR;
    }
    else {

        SC_LOG2(ERROR,
                "ScSetPassword: LsaStorePrivateData returned " FORMAT_NTSTATUS
                " for " FORMAT_LPWSTR "\n", ntstatus, LsaSecretName);
        //
        // The ntstatus code was not mapped to a windows error because it wasn't
        // clear if all the mappings made sense, and the feeling was that
        // information would be lost during the mapping.
        //

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_LSA_STOREPRIVATEDATA,
            ntstatus);

        status = ERROR_INVALID_SERVICE_ACCOUNT;
    }

    LocalFree(LsaSecretName);
    (void) LsaClose(PolicyHandle);
    (void) ReleaseMutex(ScSecretObjectsMutex);

    return status;
}



DWORD
ScDeletePassword(
    IN LPWSTR ServiceName
    )
/*++

Routine Description:

    This function deletes the LSA secret object whose name is derived
    from the specified ServiceName.

Arguments:

    ServiceName - Supplies the service name which is part of the secret
        object name to be deleted.

Return Value:

    NO_ERROR - Secret object for password is deleted.

    ERROR_INVALID_SERVICE_ACCOUNT - for any error encountered in this
        function.  The true error is written to the event log.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretNameString;
    LPWSTR LsaSecretName;

    //
    // Open a handle to the local security policy.
    //
    if (ScOpenPolicy(
            POLICY_VIEW_LOCAL_INFORMATION,
            &PolicyHandle
            ) != NO_ERROR) {
        SC_LOG0(ERROR, "ScDeletePassword: ScOpenPolicy failed\n");
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    //
    // Get the secret object name from the specified service name.
    //
    if ((status = ScFormSecretName(
                      ServiceName,
                      &LsaSecretName
                      )) != NO_ERROR) {
        (void) LsaClose(PolicyHandle);
        return status;
    }

    //
    // Serialize secret object operations
    //
    if (WaitForSingleObject(ScSecretObjectsMutex, INFINITE) == MAXULONG) {

        status = GetLastError();
        SC_LOG1(ERROR, "ScDeletePassword: WaitForSingleObject failed "
                FORMAT_DWORD "\n", status);

        LocalFree(LsaSecretName);
        LsaClose(PolicyHandle);
        return status;
    }

    RtlInitUnicodeString(&SecretNameString, LsaSecretName);

    ntstatus = LsaStorePrivateData(
                   PolicyHandle,
                   &SecretNameString,
                   NULL
                   );

    //
    // Treat STATUS_OBJECT_NAME_NOT_FOUND as success since the
    // password's already deleted (effectively) in that case.
    //

    if (NT_SUCCESS(ntstatus) || (ntstatus == STATUS_OBJECT_NAME_NOT_FOUND))
    {
        SC_LOG1(ACCOUNT, "ScDeletePassword " FORMAT_LPWSTR " success\n",
                ServiceName);

        status = NO_ERROR;
    }
    else
    {
        SC_LOG2(ERROR,
                "ScDeletePassword: LsaStorePrivateData returned " FORMAT_NTSTATUS
                " for " FORMAT_LPWSTR "\n", ntstatus, LsaSecretName);
        //
        // The ntstatus code was not mapped to a windows error because it wasn't
        // clear if all the mappings made sense, and the feeling was that
        // information would be lost during the mapping.
        //

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_LSA_STOREPRIVATEDATA,
            ntstatus);

        status = ERROR_INVALID_SERVICE_ACCOUNT;
    }

    LocalFree(LsaSecretName);
    LsaClose(PolicyHandle);
    ReleaseMutex(ScSecretObjectsMutex);

    return status;
}


DWORD
ScOpenPolicy(
    IN  ACCESS_MASK DesiredAccess,
    OUT LSA_HANDLE *PolicyHandle
    )
/*++

Routine Description:

    This function gets a handle to the local security policy by calling
    LsaOpenPolicy.

Arguments:

    DesiredAccess - Supplies the desired access to the local security
        policy.

    PolicyHandle - Receives a handle to the opened policy.

Return Value:

    NO_ERROR - Policy handle is returned.

    ERROR_INVALID_SERVICE_ACCOUNT - for any error encountered in this
        function.

--*/
{
    NTSTATUS ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    ntstatus = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   DesiredAccess,
                   PolicyHandle
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR,
                "ScOpenPolicy: LsaOpenPolicy returned " FORMAT_NTSTATUS "\n",
                ntstatus);

        //
        // The ntstatus code was not mapped to a windows error because it wasn't
        // clear if all the mappings made sense, and the feeling was that
        // information would be lost during the mapping.
        //

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_LSA_OPENPOLICY,
            ntstatus
            );

        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    return NO_ERROR;
}


DWORD
ScFormSecretName(
    IN  LPWSTR ServiceName,
    OUT LPWSTR *LsaSecretName
    )
/*++

Routine Description:

    This function creates a secret name from the service name.
    It also allocates the buffer to return the created secret name which
    must be freed by the caller using LocalFree when done with it.

Arguments:

    ServiceName - Supplies the service name which is part of the secret
        object name we are creating.

    LsaSecretName - Receives a pointer to the buffer which contains the
        secret object name.

Return Value:

    NO_ERROR - Successfully returned secret name.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate buffer to hold the secret
        name.

--*/
{
    if ((*LsaSecretName = (LPWSTR)LocalAlloc(
                              0,
                              (wcslen(SC_SECRET_PREFIX) +
                               wcslen(ServiceName) +
                               1) * sizeof(WCHAR)
                              )) == NULL) {

        SC_LOG1(ERROR, "ScFormSecretName: LocalAlloc failed %lu\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*LsaSecretName, SC_SECRET_PREFIX);
    wcscat(*LsaSecretName, ServiceName);

    return NO_ERROR;
}


DWORD
ScLookupServiceAccount(
    IN  LPWSTR ServiceName,
    OUT LPWSTR *AccountName
    )
/*++

Routine Description:

    This function looks up the service account from the registry.

Arguments:

    ServiceName - Supplies the service name to logon.

    AccountName - Receives a pointer to a string containing the name of
        the account that the service is configured to logon under.  The
        pointer returned is NULL if the service account is LocalSystem.
        Otherwise the string is in the form .\UserName or
        DomainName\UserName where DomainName != the local computername.
        It must be freed with LocalAlloc when done.

Return Value:

    NO_ERROR - Secret object for password is changed to new value.

    ERROR_INVALID_SERVICE_ACCOUNT - The account name obtained from the
        registry is invalid.

    Other errors from registry APIs.

--*/
{
    DWORD status;

    HKEY ServiceNameKey;
    LPWSTR DomainName = NULL;
    LPWSTR UserName;
    LPWSTR Separator;

    LPWSTR lpNameToParse;

    *AccountName = NULL;

    //
    // Open the service name key.
    //
    status = ScOpenServiceConfigKey(
                 ServiceName,
                 KEY_READ,
                 FALSE,               // Create if missing
                 &ServiceNameKey
                 );

    if (status != NO_ERROR) {
        return status;
    }

    //
    // Read the account name from the registry.
    //
    status = ScReadStartName(
                 ServiceNameKey,
                 &lpNameToParse
                 );

    ScRegCloseKey(ServiceNameKey);

    if (status != NO_ERROR) {
        return status;
    }

    if (lpNameToParse == NULL) {
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    //
    // Check if the account name is LocalSystem.
    //

    if (_wcsicmp(lpNameToParse, SC_LOCAL_SYSTEM_USER_NAME) == 0) {
        LocalFree(lpNameToParse);
        return NO_ERROR;
    }

    //
    // If it isn't LocalSystem, it must be in the form
    // Domain\User or .\User.
    //
    Separator = wcsrchr(lpNameToParse, SCDOMAIN_USERNAME_SEPARATOR);

    if (Separator == NULL) {

        if (wcsrchr(lpNameToParse, SC_UPN_SYMBOL) != NULL) {

            //
            // It's a UPN -- crack it
            //
            status = ScUPNToAccountName(lpNameToParse, &DomainName);

            LocalFree(lpNameToParse);

            if (status != NO_ERROR
                 ||
                (Separator = wcschr(DomainName, SCDOMAIN_USERNAME_SEPARATOR)) == NULL)
            {
                SC_LOG1(ERROR,
                        "ScLookupServiceAccount: ScUPNToAccountName failed %d\n",
                        status);

                if (status == NO_ERROR) {

                    SC_LOG1(ACCOUNT,
                            "Cracked account name was %ws\n",
                            DomainName);
                }

                LocalFree(DomainName);
                return ERROR_INVALID_SERVICE_ACCOUNT;
            }
        }
        else {

            SC_LOG1(ERROR,
                    "ScLookupServiceAccount: No \\ or @ in account name %ws\n",
                    lpNameToParse);

            LocalFree(lpNameToParse);
            return ERROR_INVALID_SERVICE_ACCOUNT;
        }
    }
    else {

        DomainName = lpNameToParse;
    }

    *Separator = 0;
    UserName = Separator + 1;

    //
    // Translate ComputerName into . (to facilitate subsequent comparison
    // of account names)
    //

    if (_wcsicmp(DomainName, ScComputerName.Buffer) == 0)
    {
        WCHAR *Dest, *Src;

        // Assumption: "." is no longer than any computer name
        SC_ASSERT(wcslen(SC_LOCAL_DOMAIN_NAME) == 1 &&
                  wcslen(DomainName) >= 1);

        wcscpy(DomainName, SC_LOCAL_DOMAIN_NAME);
        Separator = DomainName + wcslen(SC_LOCAL_DOMAIN_NAME);

        // Shift username left
        Src = UserName;
        UserName = Separator + 1;
        Dest = UserName;
        while (*Dest++ = *Src++)
            ;
    }

    //
    // Check if the user name is LocalSystem
    //

    if (_wcsicmp(UserName, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

        //
        // This is only acceptable if DomainName is "."
        //

        if (_wcsicmp(DomainName, SC_LOCAL_DOMAIN_NAME) == 0) {
            status = NO_ERROR;
        }
        else {
            status = ERROR_INVALID_SERVICE_ACCOUNT;
        }

        LocalFree(DomainName);
        return status;
    }

    //
    // Restore the "\"
    //

    *Separator = SCDOMAIN_USERNAME_SEPARATOR;
    *AccountName = DomainName;

    return NO_ERROR;
}


DWORD
ScLogonService(
    IN  LPWSTR   ServiceName,
    IN  LPWSTR   AccountName,
    OUT LPHANDLE ServiceToken,
    OUT LPHANDLE pProfileHandle OPTIONAL,
    OUT PSID     *ServiceSid
    )
/*++

Routine Description:

    This function looks up the service account from the registry and
    the password from the secret object to logon the service.  If
    successful, the handle to the logon token is returned.

Arguments:

    ServiceName - Supplies the service name to logon.

    AccountName - Supplies the account name to logon the service under.
        (Supplied as an optimization since ScLookupServiceAccount will
        have been called before calling this routine.)  It must be of
        the form .\UserName or DomainName\UserName, where DomainName !=
        the local computer name and UserName != LocalSystem.

    ServiceToken - Receives a handle to the logon token for the
        service.  The handle returned is NULL if the service account
        is LocalSystem (i.e. spawn as child process of the service
        controller).

    ServiceSid - Receives a pointer to the logon SID of the service.
        This must be freed with LocalAlloc when done.

Return Value:

    NO_ERROR - Secret object for password is changed to new value.

    ERROR_SERVICE_LOGON_FAILED - for any error encountered in this
        function.

--*/
{
    DWORD         status;
    LPWSTR        Separator;
    LPWSTR        LsaSecretName  = NULL;

    *ServiceToken = NULL;
    *ServiceSid   = NULL;

    status = ScFormSecretName(ServiceName, &LsaSecretName);

    if (status != NO_ERROR)
    {
        SC_LOG(ERROR, "ScLogonService: ScFormSecretname failed %lu\n", status);
        return ERROR_SERVICE_LOGON_FAILED;
    }

    Separator = wcsrchr(AccountName, SCDOMAIN_USERNAME_SEPARATOR);

    if (Separator == NULL)
    {
        SC_ASSERT(Separator != NULL);
        LocalFree(LsaSecretName);
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    *Separator = 0;

    //
    // Get the service token
    //
    if (!LogonUserEx(Separator + 1,              // Username
                     AccountName,                // Domain
                     LsaSecretName,              // Password
                     LOGON32_LOGON_SERVICE,      // Logon type
                     LOGON32_PROVIDER_DEFAULT,   // Default logon provider
                     ServiceToken,               // Pointer to token handle
                     ServiceSid,                 // Logon Sid
                     NULL,                       // Profile buffer
                     NULL,                       // Length of profile buffer
                     NULL))                      // Quota limits
    {
        status = GetLastError();

        *Separator = SCDOMAIN_USERNAME_SEPARATOR;

        SC_LOG2(ERROR,
                "ScLogonService: LogonUser for %ws service failed %d\n",
                ServiceName,
                status);

        ScLogEvent(NEVENT_FIRST_LOGON_FAILED_II,
                   ServiceName,
                   AccountName,
                   status);

        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(pProfileHandle))
    {
        //
        // Load the user profile for the service
        // (Errors are written to the event log, but otherwise ignored)
        //
        ScLoadUserProfile(*ServiceToken,
                          AccountName,        // Domain
                          Separator + 1,      // Username
                          pProfileHandle);
    }

    LocalFree(LsaSecretName);
    *Separator = SCDOMAIN_USERNAME_SEPARATOR;

    return NO_ERROR;

Cleanup:

    LocalFree(LsaSecretName);
    *Separator = SCDOMAIN_USERNAME_SEPARATOR;

    LocalFree(*ServiceSid);
    *ServiceSid = NULL;

    if (*ServiceToken != NULL)
    {
        CloseHandle(*ServiceToken);
        *ServiceToken = NULL;
    }

    return ERROR_SERVICE_LOGON_FAILED;
}



DWORD
ScGetAccountDomainInfo(
    VOID
    )
{
    NTSTATUS ntstatus;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo;
    NT_PRODUCT_TYPE ProductType;

    //
    // Account domain info is cached.  Look it up it this is the first
    // time.
    //
    if (ScAccountDomain.Buffer == NULL) {

        if (! RtlGetNtProductType(&ProductType)) {
            SC_LOG1(ERROR, "ScGetAccountDomainInfo: RtlGetNtProductType failed "
                    FORMAT_DWORD "\n", GetLastError());
            return ERROR_INVALID_SERVICE_ACCOUNT;
        }

        if (ProductType == NtProductLanManNt) {
            ScLocalDomain = &ScAccountDomain;
        }
        else {
            ScLocalDomain = &ScComputerName;
        }

        //
        // Open a handle to the local security policy.
        //
        if (ScOpenPolicy(
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                ) != NO_ERROR) {
            SC_LOG0(ERROR, "ScGetAccountDomainInfo: ScOpenPolicy failed\n");
            return ERROR_INVALID_SERVICE_ACCOUNT;
        }

        //
        // Get the name of the account domain from LSA if we have
        // not done it already.
        //
        ntstatus = LsaQueryInformationPolicy(
                       PolicyHandle,
                       PolicyAccountDomainInformation,
                       (PVOID *) &AccountDomainInfo
                       );

        if (! NT_SUCCESS(ntstatus)) {
            SC_LOG1(ERROR, "ScGetAccountDomainInfo: LsaQueryInformationPolicy failed "
                   FORMAT_NTSTATUS "\n", ntstatus);
            (void) LsaClose(PolicyHandle);
            return ERROR_INVALID_SERVICE_ACCOUNT;
        }

        (void) LsaClose(PolicyHandle);

        if ((ScAccountDomain.Buffer = (LPWSTR)LocalAlloc(
                                          LMEM_ZEROINIT,
                                          (UINT) (AccountDomainInfo->DomainName.Length +
                                              sizeof(WCHAR))
                                          )) == NULL) {

            (void) LsaFreeMemory((PVOID) AccountDomainInfo);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        ScAccountDomain.MaximumLength = (USHORT) (AccountDomainInfo->DomainName.Length +
                                            sizeof(WCHAR));

        RtlCopyUnicodeString(&ScAccountDomain, &AccountDomainInfo->DomainName);

        SC_LOG1(ACCOUNT, "ScGetAccountDomainInfo got " FORMAT_LPWSTR "\n",
                ScAccountDomain.Buffer);

        (void) LsaFreeMemory((PVOID) AccountDomainInfo);
    }

    return NO_ERROR;
}



VOID
ScLoadUserProfile(
    IN  HANDLE   LogonToken,
    IN  LPWSTR   DomainName,
    IN  LPWSTR   UserName,
    OUT PHANDLE  pProfileHandle
    )
/*++

Routine Description:

    This function loads the user profile for the account that a service
    process will run under, so that the process has an HKEY_CURRENT_USER.

Arguments:

    LogonToken - The token handle returned by LogonUser.

    UserName - The account's user name.  (Used by LoadUserProfile to
        generate a profile directory name.)

    pProfileHandle - A handle to the profile is returned here.  It must
        be closed by calling UnloadUserProfile after the service process
        exits.

Return Value:

    None.  Errors from LoadUserProfile are written to the event log.

--*/
{
    PROFILEINFO ProfileInfo =
        {
            sizeof(ProfileInfo),  // dwSize
            PI_NOUI,              // dwFlags - no UI
            UserName,             // lpUserName (used for dir name)
            NULL,                 // lpProfilePath
            NULL,                 // lpDefaultPath
            NULL,                 // lpServerName (used to get group info - N/A)
            NULL,                 // lpPolicyPath
            NULL                  // hProfile (filled in by LoadUserProfile)
        };

    SC_ASSERT(pProfileHandle != NULL);


    if (_wcsicmp(DomainName, SC_LOCAL_NTAUTH_NAME) == 0)
    {
        //
        // Hide LocalService/NetworkService profiles from the Admin
        // (i.e., they won't show up via "dir", etc).
        //

        ProfileInfo.dwFlags |= PI_HIDEPROFILE;
    }

    //
    // NOTE:  This ignores a service with a roaming profile.  May need
    //        to use the profile path from the LogonUserEx call.
    //
    if (LoadUserProfile(LogonToken, &ProfileInfo))
    {
        SC_ASSERT(ProfileInfo.hProfile != NULL);
        *pProfileHandle = ProfileInfo.hProfile;
    }
    else
    {
        DWORD Error = GetLastError();

        SC_LOG(ERROR, "LoadUserProfile failed %lu\n", Error);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_LOAD_USER_PROFILE,
            Error);

        *pProfileHandle = NULL;
    }
}


DWORD
ScUPNToAccountName(
    IN  LPWSTR  lpUPN,
    OUT LPWSTR  *ppAccountName
    )
/*++

Routine Description:

    This function attempts to convert a UPN into Domain\User

Arguments:

    lpUPN - The UPN

    ppAccountName - Pointer to the location to create/copy the account name

Return Value:

    NO_ERROR -- Success (ppAccountName contains the converted UPN)
    
    Any other Win32 error -- error at some stage of conversion

--*/
{
    DWORD               dwError;
    HANDLE              hDS;
    PDS_NAME_RESULT     pdsResult;

    SC_ASSERT(ppAccountName != NULL);

    SC_LOG1(ACCOUNT, "ScUPNToAccountName: Converting %ws\n", lpUPN);

    //
    // Get a binding handle to the DS
    //
    dwError = DsBind(NULL, NULL, &hDS);

    if (dwError != NO_ERROR)
    {
        SC_LOG1(ERROR, "ScUPNToAccountName: DsBind failed %d\n", dwError);
        return dwError;
    }

    dwError = DsCrackNames(hDS,                     // Handle to the DS
                           DS_NAME_NO_FLAGS,        // No parsing flags
                           DS_USER_PRINCIPAL_NAME,  // We have a UPN
                           DS_NT4_ACCOUNT_NAME,     // We want Domain\User
                           1,                       // Number of names to crack
                           &lpUPN,                  // Array of name(s)
                           &pdsResult);             // Filled in by API

    if (dwError != NO_ERROR)
    {
        SC_LOG1(ERROR,
                "ScUPNToAccountName: DsCrackNames failed %d\n",
                dwError);

        DsUnBind(&hDS);
        return dwError;
    }

    SC_ASSERT(pdsResult->cItems == 1);
    SC_ASSERT(pdsResult->rItems != NULL);

    if (pdsResult->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY)
    {
        //
        // Couldn't crack the name but we got the name of
        // the domain where it is -- let's try it
        //
        DsUnBind(&hDS);

        SC_ASSERT(pdsResult->rItems[0].pDomain != NULL);

        SC_LOG1(ACCOUNT,
                "Retrying DsBind on domain %ws\n",
                pdsResult->rItems[0].pDomain);

        dwError = DsBind(NULL, pdsResult->rItems[0].pDomain, &hDS);

        //
        // Free up the structure holding the old info
        //
        DsFreeNameResult(pdsResult);

        if (dwError != NO_ERROR)
        {
            SC_LOG1(ERROR,
                    "ScUPNToAccountName: DsBind #2 failed %d\n",
                    dwError);

            return dwError;
        }

        dwError = DsCrackNames(hDS,                     // Handle to the DS
                               DS_NAME_NO_FLAGS,        // No parsing flags
                               DS_USER_PRINCIPAL_NAME,  // We have a UPN
                               DS_NT4_ACCOUNT_NAME,     // We want Domain\User
                               1,                       // Number of names to crack
                               &lpUPN,                  // Array of name(s)
                               &pdsResult);             // Filled in by API

        if (dwError != NO_ERROR)
        {
            SC_LOG1(ERROR,
                    "ScUPNToAccountName: DsCrackNames #2 failed %d\n",
                    dwError);

            DsUnBind(&hDS);
            return dwError;
        }

        SC_ASSERT(pdsResult->cItems == 1);
        SC_ASSERT(pdsResult->rItems != NULL);
    }

    if (pdsResult->rItems[0].status != DS_NAME_NO_ERROR)
    {
        SC_LOG1(ERROR,
                "ScUPNToAccountName: DsCrackNames failure (status %#x)\n",
                pdsResult->rItems[0].status);

        //
        // DS errors don't map to Win32 errors -- this is the best we can do
        //
        dwError = ERROR_INVALID_SERVICE_ACCOUNT;
    }
    else
    {
        *ppAccountName = (LPWSTR)LocalAlloc(
                                   LPTR,
                                   (wcslen(pdsResult->rItems[0].pName) + 1) * sizeof(WCHAR));

        if (*ppAccountName != NULL)
        {
            wcscpy(*ppAccountName, pdsResult->rItems[0].pName);
        }
        else
        {
            dwError = GetLastError();
            SC_LOG1(ERROR, "ScUPNToAccountName: LocalAlloc failed %d\n", dwError);
        }
    }

    DsUnBind(&hDS);
    DsFreeNameResult(pdsResult);
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\account.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    account.h

Abstract:

    Security related function prototypes.

Author:

    Rita Wong (ritaw)     10-Apr-1992

Revision History:

--*/

#ifndef _SCACCOUNT_INCLUDED_
#define _SCACCOUNT_INCLUDED_

#define SC_LOCAL_DOMAIN_NAME        L"."
#define SC_LOCAL_SYSTEM_USER_NAME   L"LocalSystem"
#define SC_LOCAL_NTAUTH_NAME        L"NT AUTHORITY"

#define SCDOMAIN_USERNAME_SEPARATOR L'\\'


//
// External global variables used by the lockapi.c module
//
extern UNICODE_STRING ScComputerName;
extern UNICODE_STRING ScAccountDomain;

BOOL
ScGetComputerNameAndMutex(
    VOID
    );

VOID
ScEndServiceAccount(
    VOID
    );

BOOL
ScInitServiceAccount(
    VOID
    );

DWORD
ScCanonAccountName(
    IN  LPWSTR AccountName,
    OUT LPWSTR *CanonAccountName
    );

DWORD
ScValidateAndSaveAccount(
    IN LPWSTR ServiceName,
    IN HKEY ServiceNameKey,
    IN LPWSTR CanonAccountName,
    IN LPWSTR Password OPTIONAL
    );

DWORD
ScValidateAndChangeAccount(
    IN LPSERVICE_RECORD ServiceRecord,
    IN HKEY             ServiceNameKey,
    IN LPWSTR           OldAccountName,
    IN LPWSTR           CanonAccountName,
    IN LPWSTR           Password OPTIONAL
    );

VOID
ScRemoveAccount(
    IN LPWSTR ServiceName
    );

DWORD
ScLookupServiceAccount(
    IN LPWSTR ServiceName,
    OUT LPWSTR *AccountName
    );

DWORD
ScLogonService(
    IN LPWSTR    ServiceName,
    IN LPWSTR    AccountName,
    OUT LPHANDLE ServiceToken,
    OUT LPHANDLE ProfileHandle OPTIONAL,
    OUT PSID     *ServiceSid
    );

DWORD
ScGetAccountDomainInfo(
    VOID
    );

#endif // _SCACCOUNT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\cfgapi2.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    CfgAPI2.cxx

Abstract:

    This file contains the Service Controller's extended Config API.
        RChangeServiceConfig2W
        RQueryServiceConfig2W
        COutBuf
        CUpdateOptionalString::Update
        CUpdateOptionalString::~CUpdateOptionalString
        PrintConfig2Parms


Author:

    Anirudh Sahni (AnirudhS)  11-Oct-96

Environment:

    User Mode - Win32

Revision History:

    11-Oct-1996 AnirudhS
        Created.

--*/


//
// INCLUDES
//

#include "precomp.hxx"
#include <tstr.h>       // Unicode string macros
#include <align.h>      // COUNT_IS_ALIGNED
#include <valid.h>      // ACTION_TYPE_INVALID
#include <sclib.h>      // ScImagePathsMatch
#include <scwow.h>      // 32/64-bit interop structures
#include "scconfig.h"   // ScOpenServiceConfigKey, etc.
#include "scsec.h"      // ScPrivilegeCheckAndAudit
#include "smartp.h"     // CHeapPtr


#if DBG == 1
VOID
PrintConfig2Parms(
    IN  SC_RPC_HANDLE       hService,
    IN  SC_RPC_CONFIG_INFOW Info
    );
#endif

//
// Class definitions
//

//+-------------------------------------------------------------------------
//
//  Class:      COutBuf
//
//  Purpose:    Abstraction of an output buffer that is written sequentially
//
//  History:    22-Nov-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

class COutBuf
{
public:
    COutBuf(LPBYTE lpBuffer) :
        _Start(lpBuffer),
        _Used(0)
        { }

    LPBYTE  Next() const         { return (_Start + _Used); }
    DWORD   OffsetNext() const   { return _Used; }
    void    AddUsed(DWORD Bytes) { _Used += Bytes; }

    void    AppendBytes(void * Source, DWORD Bytes)
                    {
                        RtlCopyMemory(Next(), Source, Bytes);
                        AddUsed(Bytes);
                    }
private:
    LPBYTE  _Start;
    DWORD   _Used;
};


//+-------------------------------------------------------------------------
//
//  Class:      CUpdateOptionalString
//
//  Purpose:    An object of this class represents an update of an optional
//              string value in the registry.  The update takes place when
//              the Update() method is called.  When the object is destroyed
//              the operation is undone, unless the Commit() method has been
//              called.
//
//              This class simplifies the writing of APIs like
//              ChangeServiceConfig2.
//
//  History:    27-Nov-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

class CUpdateOptionalString
{
public:
            CUpdateOptionalString (HKEY Key, LPCWSTR ValueName) :
                    _Key(Key),
                    _ValueName(ValueName),
                    _UndoNeeded(FALSE)
                        { }
           ~CUpdateOptionalString();
    DWORD   Update (LPCWSTR NewValue);
    void    Commit ()
                        { _UndoNeeded = FALSE; }

private:
    HKEY        _Key;
    LPCWSTR     _ValueName;
    CHeapPtr< LPWSTR >  _OldValue;
    BOOL        _UndoNeeded;
};



DWORD
CUpdateOptionalString::Update(
    IN LPCWSTR NewValue
    )
/*++

Routine Description:

    See class definition.

--*/
{
    // This method should be called only once in the object's lifetime
    SC_ASSERT(_UndoNeeded == FALSE && _OldValue == NULL);

    //
    // Read the old value.
    //
    DWORD Error = ScReadOptionalString(_Key, _ValueName, &_OldValue);
    if (Error != ERROR_SUCCESS)
    {
        return Error;
    }

    //
    // Write the new value.  Note that NULL means no change.
    //
    Error = ScWriteOptionalString(_Key, _ValueName, NewValue);

    //
    // Remember whether the change needs to be undone.
    //
    if (Error == ERROR_SUCCESS && NewValue != NULL)
    {
        _UndoNeeded = TRUE;
    }

    return Error;
}




CUpdateOptionalString::~CUpdateOptionalString(
    )
/*++

Routine Description:

    See class definition.

--*/
{
    if (_UndoNeeded)
    {
        DWORD Error = ScWriteOptionalString(
                            _Key,
                            _ValueName,
                            _OldValue ? _OldValue : L""
                            );

        if (Error != ERROR_SUCCESS)
        {
            // Nothing we can do about it
            SC_LOG3(ERROR, "Couldn't roll back update to %ws value, error %lu."
                           "  Old value was \"%ws\".\n",
                           _ValueName, Error, _OldValue);
        }
    }
}



DWORD
RChangeServiceConfig2W(
    IN  SC_RPC_HANDLE       hService,
    IN  SC_RPC_CONFIG_INFOW Info
    )

/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    SC_LOG(CONFIG_API, "In RChangeServiceConfig2W for service handle %#lx\n", hService);

#if DBG == 1
    PrintConfig2Parms(hService, Info);
#endif // DBG == 1

    if (ScShutdownInProgress)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Do we have permission to do this?
    //
    if (!RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT) hService)->AccessGranted,
              SERVICE_CHANGE_CONFIG
              ))
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Lock database, as we want to add stuff without other threads tripping
    // on our feet.
    //
    CServiceRecordExclusiveLock RLock;

    //
    // Find the service record for this handle.
    //
    LPSERVICE_RECORD serviceRecord =
        ((LPSC_HANDLE_STRUCT) hService)->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT(serviceRecord != NULL);
    SC_ASSERT(serviceRecord->Signature == SERVICE_SIGNATURE);

    //
    // Disallow this call if record is marked for delete.
    //
    if (DELETE_FLAG_IS_SET(serviceRecord))
    {
        return ERROR_SERVICE_MARKED_FOR_DELETE;
    }

    //-----------------------------
    //
    // Begin Updating the Registry
    //
    //-----------------------------
    HKEY  ServiceNameKey = NULL;
    DWORD ApiStatus = ScOpenServiceConfigKey(
                            serviceRecord->ServiceName,
                            KEY_WRITE | KEY_READ,
                            FALSE,              // don't create if missing
                            &ServiceNameKey
                            );
    if (ApiStatus != NO_ERROR)
    {
        goto Cleanup;
    }


    switch (Info.dwInfoLevel)
    {
    //-----------------------------
    //
    // Service Description
    //
    //-----------------------------
    case SERVICE_CONFIG_DESCRIPTION:

        //
        // NULL means no change
        //
        if (Info.psd == NULL)
        {
            ApiStatus = NO_ERROR;
            break;
        }

        ApiStatus = ScWriteDescription(ServiceNameKey, Info.psd->lpDescription);
        break;

    //-----------------------------
    //
    // Service Failure Actions
    //
    //-----------------------------
    case SERVICE_CONFIG_FAILURE_ACTIONS:
        {
            LPSERVICE_FAILURE_ACTIONSW psfa = Info.psfa;

            //
            // NULL means no change
            //
            if (psfa == NULL)
            {
                ApiStatus = NO_ERROR;
                break;
            }

            //
            // Validate the structure and permissions
            //
            if (psfa->lpsaActions != NULL &&
                psfa->cActions != 0)
            {
                //
                // These settings are only valid for Win32 services
                //
                if (! (serviceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32))
                {
                    ApiStatus = ERROR_CANNOT_DETECT_DRIVER_FAILURE;
                    break;
                }

                BOOL RebootRequested = FALSE;
                BOOL RestartRequested = FALSE;
                for (DWORD i = 0; i < psfa->cActions; i++)
                {
                    SC_ACTION_TYPE Type = psfa->lpsaActions[i].Type;
                    if (Type == SC_ACTION_RESTART)
                    {
                        RestartRequested = TRUE;
                    }
                    else if (Type == SC_ACTION_REBOOT)
                    {
                        RebootRequested = TRUE;
                    }
                    else if (ACTION_TYPE_INVALID(Type))
                    {
                        SC_LOG(ERROR, "RChangeServiceConfig2W: invalid action type %#lx\n", Type);
                        ApiStatus = ERROR_INVALID_PARAMETER;
                        goto Cleanup;
                    }
                }

                if (RestartRequested)
                {
                    if (!RtlAreAllAccessesGranted(
                              ((LPSC_HANDLE_STRUCT) hService)->AccessGranted,
                              SERVICE_START
                              ))
                    {
                        SC_LOG0(ERROR, "Service handle lacks start access\n");
                        ApiStatus = ERROR_ACCESS_DENIED;
                        break;
                    }
                }

                if (RebootRequested)
                {
                    NTSTATUS Status = ScPrivilegeCheckAndAudit(
                                            SE_SHUTDOWN_PRIVILEGE,
                                            hService,
                                            SERVICE_CHANGE_CONFIG
                                            );
                    if (!NT_SUCCESS(Status))
                    {
                        SC_LOG0(ERROR, "Caller lacks shutdown privilege\n");
                        ApiStatus = ERROR_ACCESS_DENIED;
                        break;
                    }
                }

                //
                // Get the service's image path
                //
                CHeapPtr<LPWSTR> ImageName;
                ApiStatus = ScGetImageFileName(serviceRecord->ServiceName, &ImageName);
                if (ApiStatus != NO_ERROR)
                {
                    SC_LOG(ERROR,"RChangeServiceConfig2W: GetImageFileName failed %lu\n", ApiStatus);
                    break;
                }

                //
                // If the service runs in services.exe, we certainly won't
                // detect if the service process dies, so don't pretend we will
                //
                if (ScImagePathsMatch(ImageName, ScGlobalThisExePath))
                {
                    ApiStatus = ERROR_CANNOT_DETECT_PROCESS_ABORT;
                    break;
                }
            }

            //
            // Write the string values, followed by the non-string values.
            // If anything fails, the values written up to that point will be
            // backed out.
            // (Backing out the update of the non-string values is a little
            // more complicated than backing out the string updates.  So we
            // do the non-string update last, to avoid having to back it out.)
            //
            CUpdateOptionalString UpdateRebootMessage
                        (ServiceNameKey, REBOOTMESSAGE_VALUENAME_W);
            CUpdateOptionalString UpdateFailureCommand
                        (ServiceNameKey, FAILURECOMMAND_VALUENAME_W);

            if ((ApiStatus = UpdateRebootMessage.Update(psfa->lpRebootMsg)) == ERROR_SUCCESS &&
                (ApiStatus = UpdateFailureCommand.Update(psfa->lpCommand)) == ERROR_SUCCESS &&
                (ApiStatus = ScWriteFailureActions(ServiceNameKey, psfa)) == ERROR_SUCCESS)
            {
                UpdateRebootMessage.Commit();
                UpdateFailureCommand.Commit();
            }
        }
        break;

    //-----------------------------
    //
    // Other (invalid)
    //
    //-----------------------------
    default:
        ApiStatus = ERROR_INVALID_LEVEL;
        break;
    }

Cleanup:

    if (ServiceNameKey != NULL)
    {
        ScRegFlushKey(ServiceNameKey);
        ScRegCloseKey(ServiceNameKey);
    }

    SC_LOG1(CONFIG_API, "RChangeServiceConfig2W returning %lu\n", ApiStatus);

    return ApiStatus;
}



DWORD
RQueryServiceConfig2W(
    IN  SC_RPC_HANDLE       hService,
    IN  DWORD               dwInfoLevel,
    OUT LPBYTE              lpBuffer,
    IN  DWORD               cbBufSize,
    OUT LPDWORD             pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    SC_LOG(CONFIG_API, "In RQueryServiceConfig2W for service handle %#lx\n", hService);

    if (ScShutdownInProgress)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // MIDL doesn't support optional [out] parameters efficiently, so
    // we require these parameters.
    //
    if (lpBuffer == NULL || pcbBytesNeeded == NULL)
    {
        SC_ASSERT(!"RPC passed NULL for [out] pointers");
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Do we have permission to do this?
    //
    if (!RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT) hService)->AccessGranted,
              SERVICE_QUERY_CONFIG
              ))
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Initialize *pcbBytesNeeded.  It is incremented below.
    // (For consistency with QueryServiceConfig, it is set even on a success
    // return.)
    //
    *pcbBytesNeeded = 0;

    //
    // Lock database, as we want to look at stuff without other threads changing
    // fields at the same time.
    //
    CServiceRecordSharedLock RLock;

    LPSERVICE_RECORD serviceRecord =
        ((LPSC_HANDLE_STRUCT) hService)->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT(serviceRecord != NULL);


    //
    // Open the service name key.
    //
    HKEY  ServiceNameKey = NULL;
    DWORD ApiStatus = ScOpenServiceConfigKey(
                    serviceRecord->ServiceName,
                    KEY_READ,
                    FALSE,               // Create if missing
                    &ServiceNameKey
                    );

    if (ApiStatus != NO_ERROR)
    {
        return ApiStatus;
    }


    switch (dwInfoLevel)
    {
    //-----------------------------
    //
    // Service Description
    //
    //-----------------------------
    case SERVICE_CONFIG_DESCRIPTION:
        {
            *pcbBytesNeeded = sizeof(SERVICE_DESCRIPTION_WOW64);

            //
            // Read the string from the registry
            //
            CHeapPtr< LPWSTR > pszDescription;
            ApiStatus = ScReadDescription(
                                ServiceNameKey,
                                &pszDescription,
                                pcbBytesNeeded
                                );

            SC_ASSERT(ApiStatus != ERROR_INSUFFICIENT_BUFFER);

            if (ApiStatus != NO_ERROR)
            {
                break;
            }

            //
            // Check for sufficient buffer space
            //
            if (cbBufSize < *pcbBytesNeeded)
            {
                ApiStatus = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            //
            // Copy the information to the output buffer
            // The format is:
            //   SERVICE_DESCRIPTION_WOW64 struct
            //   description string
            // Pointers in the struct are replaced with offsets based at the
            // start of the buffer.  NULL pointers remain NULL.
            //
            COutBuf OutBuf(lpBuffer);

            LPSERVICE_DESCRIPTION_WOW64 psdOut =
                (LPSERVICE_DESCRIPTION_WOW64) OutBuf.Next();
            OutBuf.AddUsed(sizeof(SERVICE_DESCRIPTION_WOW64));
            SC_ASSERT(COUNT_IS_ALIGNED(OutBuf.OffsetNext(), sizeof(WCHAR)));

            if (pszDescription != NULL)
            {
                psdOut->dwDescriptionOffset = OutBuf.OffsetNext();
                OutBuf.AppendBytes(pszDescription, (DWORD) WCSSIZE(pszDescription));
            }
            else
            {
                psdOut->dwDescriptionOffset = 0;
            }
        }
        break;

    //-----------------------------
    //
    // Service Failure Actions
    //
    //-----------------------------
    case SERVICE_CONFIG_FAILURE_ACTIONS:
        {
            //
            // Read the non-string info
            //
            CHeapPtr< LPSERVICE_FAILURE_ACTIONS_WOW64 > psfa;

            ApiStatus = ScReadFailureActions(ServiceNameKey, &psfa, pcbBytesNeeded);
            if (ApiStatus != NO_ERROR)
            {
                break;
            }
            if (psfa == NULL)
            {
                SC_ASSERT(*pcbBytesNeeded == 0);
                *pcbBytesNeeded = sizeof(SERVICE_FAILURE_ACTIONS_WOW64);
            }
            SC_ASSERT(COUNT_IS_ALIGNED(*pcbBytesNeeded, sizeof(WCHAR)));

            //
            // Read the string values
            //
            CHeapPtr< LPWSTR > RebootMessage;

            ApiStatus = ScReadRebootMessage(
                                ServiceNameKey,
                                &RebootMessage,
                                pcbBytesNeeded
                                );
            if (ApiStatus != NO_ERROR)
            {
                break;
            }
            SC_ASSERT(COUNT_IS_ALIGNED(*pcbBytesNeeded, sizeof(WCHAR)));

            CHeapPtr< LPWSTR > FailureCommand;

            ApiStatus = ScReadFailureCommand(
                                ServiceNameKey,
                                &FailureCommand,
                                pcbBytesNeeded
                                );
            if (ApiStatus != NO_ERROR)
            {
                break;
            }

            //
            // Check for sufficient buffer space
            //
            if (cbBufSize < *pcbBytesNeeded)
            {
                ApiStatus = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            //
            // Copy the information to the output buffer
            // The format is:
            //   SERVICE_FAILURE_ACTIONS_WOW64 struct
            //   SC_ACTIONS array
            //   strings
            // Pointers in the struct are replaced with offsets based at the
            // start of the buffer.  NULL pointers remain NULL.
            //
            COutBuf OutBuf(lpBuffer);

            LPSERVICE_FAILURE_ACTIONS_WOW64 psfaOut =
                (LPSERVICE_FAILURE_ACTIONS_WOW64) OutBuf.Next();

            if (psfa != NULL)
            {
                psfaOut->dwResetPeriod = ((LPSERVICE_FAILURE_ACTIONS_WOW64) psfa)->dwResetPeriod;
                psfaOut->cActions      = ((LPSERVICE_FAILURE_ACTIONS_WOW64) psfa)->cActions;
            }
            else
            {
                psfaOut->dwResetPeriod = 0;
                psfaOut->cActions      = 0;
            }
            OutBuf.AddUsed(sizeof(SERVICE_FAILURE_ACTIONS_WOW64));

            if (psfaOut->cActions != 0)
            {
                psfaOut->dwsaActionsOffset = OutBuf.OffsetNext();

                OutBuf.AppendBytes(psfa + 1,
                                   psfaOut->cActions * sizeof(SC_ACTION));
            }
            else
            {
                psfaOut->dwsaActionsOffset = 0;
            }
            SC_ASSERT(COUNT_IS_ALIGNED(OutBuf.OffsetNext(), sizeof(WCHAR)));

            if (RebootMessage != NULL)
            {
                psfaOut->dwRebootMsgOffset = OutBuf.OffsetNext();
                OutBuf.AppendBytes(RebootMessage, (DWORD) WCSSIZE(RebootMessage));
            }
            else
            {
                psfaOut->dwRebootMsgOffset = 0;
            }

            if (FailureCommand != NULL)
            {
                psfaOut->dwCommandOffset = OutBuf.OffsetNext();
                OutBuf.AppendBytes(FailureCommand, (DWORD) WCSSIZE(FailureCommand));
            }
            else
            {
                psfaOut->dwCommandOffset = 0;
            }
        }
        break;

    //-----------------------------
    //
    // Other (invalid)
    //
    //-----------------------------
    default:
        ApiStatus = ERROR_INVALID_LEVEL;
        break;
    }


    ScRegCloseKey(ServiceNameKey);

    SC_LOG1(CONFIG_API, "RQueryServiceConfig2W returning %lu\n", ApiStatus);

    return ApiStatus;
}



#if DBG == 1

VOID
PrintConfig2Parms(
    IN  SC_RPC_HANDLE       hService,
    IN  SC_RPC_CONFIG_INFOW Info
    )
{
    KdPrintEx((DPFLTR_SCSERVER_ID,
               DEBUG_CONFIG_API,
               "Parameters to RChangeServiceConfig2W:\n"));

    LPSTR psz;
    switch (Info.dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        psz = "SERVICE_CONFIG_DESCRIPTION";
        break;
    case SERVICE_CONFIG_FAILURE_ACTIONS:
        psz = "SERVICE_CONFIG_FAILURE_ACTIONS";
        break;
    default:
        psz = "invalid";
        break;
    }
    KdPrintEx((DPFLTR_SCSERVER_ID,
               DEBUG_CONFIG_API,
               "  dwInfoLevel = %ld (%s)\n", Info.dwInfoLevel,
               psz));

    switch (Info.dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:

        if (Info.psd == NULL)
        {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_CONFIG_API,
                       "  NULL information pointer -- no action requested\n\n"));

            break;
        }

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  pszDescription = \"%ws\"\n",
                   Info.psd->lpDescription));

        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        if (Info.psfa == NULL)
        {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_CONFIG_API,
                       "  NULL information pointer -- no action requested\n\n"));

            break;
        }

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  dwResetPeriod = %ld\n",
                   Info.psfa->dwResetPeriod));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  lpRebootMsg   = \"%ws\"\n",
                   Info.psfa->lpRebootMsg));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  lpCommand     = \"%ws\"\n",
                   Info.psfa->lpCommand));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  %ld failure %s\n",
                   Info.psfa->cActions,
                   Info.psfa->cActions == 0 ? "actions." :
                       Info.psfa->cActions == 1 ? "action:"  : "actions:"));

        if (Info.psfa->lpsaActions == NULL)
        {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_CONFIG_API,
                       "  NULL array pointer -- no change in fixed info\n\n"));
        }
        else
        {
            for (DWORD i = 0; i < Info.psfa->cActions; i++)
            {
                SC_ACTION& sa = Info.psfa->lpsaActions[i];
                KdPrintEx((DPFLTR_SCSERVER_ID,
                           DEBUG_CONFIG_API,
                           "    %ld: Action %ld, Delay %ld\n",
                           i,
                           sa.Type,
                           sa.Delay));
            }
        }
        break;
    }

    KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_CONFIG_API, "\n"));
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\cfgapi.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    CfgAPI.cxx

Abstract:

    This file contains the Service Controller's Config API.
        RChangeServiceConfigW
        RCreateServiceW
        RDeleteService
        RQueryServiceConfigW
        ScCanonDriverImagePath


Author:

    John Rogers (JohnRo) 10-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    26-Mar-1992 danl
        Created the stubbed out version for RPC.
    22-Apr-1992 JohnRo
        Use SC_LOG0(), FORMAT_ equates, etc
        Wrote real code for these APIs.
        Split lock APIs into server/lockapi.c.
        Added some assertion checks here and there.  Added handle checks too.
    28-Apr-1992 JohnRo
        Undo all group operations (ifdef USE_GROUPS).
    28-May-1992 JohnRo
        Put back load order group in APIs.
        Avoid compiler warnings.
    02-Jun-1992 JohnRo
        RAID 10709: QueryServiceConfig() has bad length check.
    08-Aug-1992 Danl
        RDeleteService: Add call to ScMarkForDelete so the registry entry
        is marked for deletion.
    25-Aug-1992 Danl
        RQueryServiceConfig: Fix problem where it failed if it couldn't
        read the StartName from the registry.  (This should be optional).
    21-Jan-1994 Danl
        RChangeServiceConfigW: Fixed BUG where a unicode DisplayName was
        being copied into a buffer whose size assumed ansi characters.
        Also changed so that displayname is not allocated unless it is
        different from the ServiceName.
    24-Mar-1994 Danl
        RQueryServiceConfigW:  Add worse case number of bytes (3) for RPC
        alignment.  I removed the exact calculation because it assumed
        that strings went into the buffer in a particular order.  Since RPC
        picks the order for unmarshalling into the users buffer, the order
        may be random.
    06-Jun-1994 Danl
        We were allocating memory for the display name in the service record only
        when it was the same.  It should have been doing this only when different.
        The behaviour was such that if you changed the display name to something
        other than the KeyName, the new name was placed in the registry, but not
        in the service record.  So GetKeyName on the new name would fail.
    20-Jun-1994 Danl
        Added SERVICE_WIN32_INTERACTIVE support to service type.
    21-Jan-1995     AnirudhS
        RCreateServiceW: This was calling ScAccessValidate to check if the caller
        had the desired access to the object on creation of a new service object.
        Fixed this to just grant the desired access instead.
    26-Feb-1996     AnirudhS
        RChangeServiceConfigW: Would generate a tag only if the group name
        changed.  Fixed it to always generate and return a tag if one is
        requested, just like RCreateServiceW.
    09-Dec-1996     AnirudhS
        Added SC_LOG printouts to help diagnose the annoying
        ERROR_INVALID_PARAMETER and ERROR_INVALID_SERVICE_ACCOUNT return codes.
    22-Oct-1997     JSchwart  (after AnirudhS in _CAIRO_ 12-Apr-1995)
        RChangeServiceConfigW and RCreateServiceW: Allow services that run under
        accounts other than LocalSystem to share processes too.

--*/


//
// INCLUDES
//

#include "precomp.hxx"
#include <scconfig.h>   // ScGetImageFileName().
#include <sclib.h>      // ScImagePathsMatch(), ScIsValidImagePath(), etc.
#include <scsec.h>      // ScAccessValidate().
#include <valid.h>      // SERVICE_TYPE_INVALID(), etc.
#include <sccrypt.h>    // ScDecryptPassword
#include "account.h"    // ScValidateAndSaveAccount
#include <strarray.h>   // ScWStrArraySize
#include <align.h>      // ROUND_UP_COUNT
#include "smartp.h"     // CHeapPtr
#include "resource.h"   // IDS_SC_CONFIG_* constants


#define SC_NT_SYSTEM_ROOT  L"\\SystemRoot\\"
#define SC_DOS_SYSTEM_ROOT L"%SystemRoot%\\"

#define SERVICE_TYPE_CHANGED            0x00000001
#define START_TYPE_CHANGED              0x00000002
#define ERROR_CONTROL_CHANGED           0x00000004
#define BINARY_PATH_CHANGED             0x00000008
#define REG_GROUP_CHANGED               0x00000010
#define TAG_ID_CHANGED                  0x00000020
#define DEPENDENCIES_CHANGED_SR         0x00000040    // Not in NT4
#define DEPENDENCIES_CHANGED_REG        0x00000080    // Not in NT4
#define START_NAME_CHANGED              0x00000100
#define SR_GROUP_CHANGED                0x00000200
#define DISPLAY_NAME_CHANGED_SR         0x00000400
#define DISPLAY_NAME_CHANGED_REG        0x00000800

DWORD
ScCanonDriverImagePath(
    IN DWORD DriverStartType,
    IN LPWSTR DriverPath,
    OUT LPWSTR *CanonDriverPath
    );

DWORD
ScConvertToBootPathName(
    LPWSTR FullQualPathName,
    LPWSTR * RelativePathName
    );

DWORD
ScValidateDisplayName(
    LPWSTR              lpDisplayName,
    LPSERVICE_RECORD    lpServiceRecord
    );

BOOLEAN
ScIsArcName(
    LPWSTR              PathName
    );


DWORD
RChangeServiceConfigW(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwServiceType,
    IN  DWORD           dwStartType,
    IN  DWORD           dwErrorControl,
    IN  LPWSTR          lpBinaryPathName,
    IN  LPWSTR          lpLoadOrderGroup,
    OUT LPDWORD         lpdwTagId,
    IN  LPBYTE          lpDependencies,
    IN  DWORD           dwDependSize,
    IN  LPWSTR          lpServiceStartName,
    IN  LPBYTE          EncryptedPassword,
    IN  DWORD           PasswordSize,
    IN  LPWSTR          lpDisplayName
    )

/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    DWORD               ApiStatus;
    DWORD               backoutStatus;
    DWORD               newServiceType;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hService;
    HKEY                ServiceNameKey      = NULL;
    LPSERVICE_RECORD    serviceRecord;
    LPWSTR              CanonBinaryPath     = NULL;
    LPWSTR              NewBinaryPath       = NULL;

    LPWSTR              OldAccountName      = NULL;
    LPWSTR              CanonAccountName    = NULL;
    DWORD               CurrentServiceType  = 0;
    DWORD               CurrentStartType    = 0;
    DWORD               CurrentErrorControl = 0;
    LPWSTR              CurrentImageName    = NULL;
    LPWSTR              CurrentDependencies = NULL;
    LPWSTR              CurrentDisplayName  = NULL;
    LPWSTR              CurrentGroup        = NULL;
    LPWSTR              CurrentStartName    = NULL;
    DWORD               CurrentTag          = 0;
    DWORD               Tag                 = 0;
    DWORD               Progress            = 0;
    LPWSTR              Password            = NULL;
    LPWSTR              OldSRDisplayName    = NULL;
    LPWSTR              NewDisplayName      = NULL;


    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if ( !ScIsValidServiceHandle( hService ) ) {
        return(ERROR_INVALID_HANDLE);
    }

    SC_LOG(CONFIG_API, "RChangeServiceConfigW(%ws)\n",
           serviceHandleStruct->Type.ScServiceObject.ServiceRecord->ServiceName);

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              SERVICE_CHANGE_CONFIG
              )) {

        return(ERROR_ACCESS_DENIED);
    }

    if (lpdwTagId != NULL) {

        //
        // Asking for new tag value but didn't specify group
        //
        if ((lpLoadOrderGroup == NULL) || (*lpLoadOrderGroup == 0)) {

            SC_LOG0(ERROR, "Asking for new tag value but didn't specify group\n");
            return(ERROR_INVALID_PARAMETER);
        }
    }

    //
    // Lock database, as we want to add stuff without other threads tripping
    // on our feet.  NOTE:  since we may need the group list lock, we
    // must get that lock first.
    //
    CGroupListExclusiveLock GLock;
    CServiceListSharedLock LLock;
    CServiceRecordExclusiveLock RLock;

    //
    // Find the service record for this handle.
    //
    serviceRecord =
        serviceHandleStruct->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT( serviceRecord != NULL );
    SC_ASSERT( serviceRecord->Signature == SERVICE_SIGNATURE );

    //
    // Disallow this call if record is marked for delete.
    //
    if (DELETE_FLAG_IS_SET(serviceRecord)) {
        return(ERROR_SERVICE_MARKED_FOR_DELETE);
    }

    //
    // If there is a DisplayName specified, check to see if it already
    // exists.
    //
    ApiStatus = ScValidateDisplayName(lpDisplayName,serviceRecord);
    if (ApiStatus != NO_ERROR) {
        SC_LOG0(ERROR, "DisplayName invalid\n");
        return(ApiStatus);
    }

    //
    // Figure-out what the resulting service type will be.
    // (Some other stuff below depends on this.)
    //
    if (dwServiceType != SERVICE_NO_CHANGE) {
        if ( SERVICE_TYPE_INVALID( dwServiceType ) ) {
            SC_LOG0(ERROR, "ServiceType invalid\n");
            return(ERROR_INVALID_PARAMETER);
        }
        newServiceType = dwServiceType;
    }
    else {
        newServiceType = serviceRecord->ServiceStatus.dwServiceType;
    }
    SC_ASSERT( newServiceType != SERVICE_NO_CHANGE );

    //
    // Validate other parameters.
    //
    ApiStatus = ScCheckServiceConfigParms(
                    TRUE,                    // This is a change operation
                    serviceRecord->ServiceName,
                    serviceRecord->ServiceStatus.dwServiceType, // new actual type
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    lpBinaryPathName,
                    lpLoadOrderGroup,
                    (LPWSTR)lpDependencies,
                    dwDependSize);

    if (ApiStatus != NO_ERROR) {
        return(ApiStatus);
    }

    //-----------------------------
    //
    // Begin Updating the Registry
    //
    //-----------------------------
    ApiStatus = ScOpenServiceConfigKey(
            serviceRecord->ServiceName,
            KEY_WRITE | KEY_READ,
            FALSE,              // don't create if missing
            & ServiceNameKey );
    if (ApiStatus != NO_ERROR) {
        return(ApiStatus);
    }


    //--------------------------------------
    // (from here on we need to use Cleanup)
    //
    // Service Type
    //--------------------------------------
    if (dwServiceType != SERVICE_NO_CHANGE) {

        //
        // If this service is supposed to be interactive, make sure
        // the service account is LocalSystem.  Otherwise, it should
        // fail with ERROR_INVALID_PARAMETER.
        //
        if (dwServiceType & SERVICE_INTERACTIVE_PROCESS) {
            if (ARGUMENT_PRESENT(lpServiceStartName)) {
                ApiStatus = ScCanonAccountName(lpServiceStartName, &CanonAccountName);
                if (ApiStatus != NO_ERROR) {
                    goto Cleanup;
                }
                if (_wcsicmp(CanonAccountName,SC_LOCAL_SYSTEM_USER_NAME) != 0) {
                    SC_LOG0(ERROR, "Service must run in LocalSystem account to be interactive\n");
                    ApiStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
            else {
                //
                // Get old account name
                //
                ApiStatus = ScReadStartName(ServiceNameKey, &OldAccountName);
                if (ApiStatus != NO_ERROR) {
                    goto Cleanup;
                }
                if (_wcsicmp(OldAccountName, SC_LOCAL_SYSTEM_USER_NAME) != 0) {
                    SC_LOG0(ERROR, "Service must run in LocalSystem account to be interactive\n");
                    ApiStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
        }

        ApiStatus = ScReadServiceType( ServiceNameKey, &CurrentServiceType);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        ApiStatus = ScWriteServiceType( ServiceNameKey, dwServiceType);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= SERVICE_TYPE_CHANGED;

    }
    else {
        //
        // ServiceType is not being changed.
        //
        CurrentServiceType = serviceRecord->ServiceStatus.dwServiceType;

        //
        // if the current service type contains the interactive bit, and the
        // account type is being changed to something other than LocalSystem,
        // then we should fail the call with ERROR_INVALID_PARAMETER.
        //
        if (ARGUMENT_PRESENT(lpServiceStartName)) {
            if ((CurrentServiceType & SERVICE_INTERACTIVE_PROCESS) &&
                (_wcsicmp(lpServiceStartName,SC_LOCAL_SYSTEM_USER_NAME) != 0)) {
                SC_LOG0(ERROR, "Service must run in LocalSystem account to be interactive\n");
                ApiStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
    }

    //---------------------
    // Start Type
    //---------------------
    if (dwStartType != SERVICE_NO_CHANGE) {

        ApiStatus = ScReadStartType( ServiceNameKey, &CurrentStartType);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        ApiStatus = ScWriteStartType( ServiceNameKey, dwStartType);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= START_TYPE_CHANGED;

        //
        // If they're supplying a new binary name, making it correct for the
        // Start type will happen automatically.  If they're keeping the
        // same imagepath, we need to make sure it of the correct format,
        // and if not, fix it.
        //

        if (lpBinaryPathName == NULL) {
            //
            // If the start type is changing from SERVICE_BOOT_START we need
            // to turn the start path into a fully qualified NT name (BOOT
            // drivers have paths relative to systemroot)
            //
            if (CurrentStartType == SERVICE_BOOT_START &&
                dwStartType != SERVICE_BOOT_START) {

                //
                // Note:  The following call allocates storage for the
                //        CurrentImageName
                //

                ApiStatus = ScGetImageFileName (
                                serviceRecord->ServiceName,
                                &CurrentImageName );

                if (ApiStatus != NO_ERROR && ApiStatus != ERROR_PATH_NOT_FOUND) {
                    SC_LOG(ERROR,"RChangeServiceConfigW: ScGetImageFileName failed %d\n",
                        ApiStatus);
                    goto Cleanup;
                }

                //
                // If there's an existing path, we need to fix
                // If it is an ARC name, leave it alone
                //
                //

                if (ApiStatus != ERROR_PATH_NOT_FOUND &&
                    !ScIsArcName(CurrentImageName)) {

                    //
                    // Prepend \systemroot\ to the beginning of the path
                    //

                    NewBinaryPath = (LPWSTR)LocalAlloc(LMEM_ZEROINIT,
                        (UINT) ((wcslen(CurrentImageName) +
                        wcslen(SC_NT_SYSTEM_ROOT) + 1) * sizeof(WCHAR)));
                    if (!NewBinaryPath) {
                        SC_LOG(ERROR,"RChangeServiceConfigW: LocalAlloc failed %d\n",
                            GetLastError());
                        ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }

                    wcscpy(NewBinaryPath, SC_NT_SYSTEM_ROOT);
                    wcscat(NewBinaryPath, CurrentImageName);
                    lpBinaryPathName = NewBinaryPath;

                }
                ApiStatus = NO_ERROR;

                LocalFree(CurrentImageName);
            }

            //
            // If the start type is changing to SERVICE_BOOT_START, we need
            // to make sure the ImagePath gets canonicalized
            //

            else if (dwStartType == SERVICE_BOOT_START &&
                CurrentStartType != SERVICE_BOOT_START) {

                //
                // Note:  The following call allocates storage for the
                //        CurrentImageName
                //

                ApiStatus = ScGetImageFileName (
                                serviceRecord->ServiceName,
                                &CurrentImageName );

                if (ApiStatus != NO_ERROR && ApiStatus != ERROR_PATH_NOT_FOUND) {
                    SC_LOG(ERROR,"RChangeServiceConfigW: ScGetImageFileName failed %d\n",
                        ApiStatus);
                    goto Cleanup;
                }

                //
                // If there's an existing path and it's not an ARC name, we
                // need to fix
                //

                if (ApiStatus != ERROR_PATH_NOT_FOUND &&
                    !ScIsArcName(CurrentImageName)) {

                    //
                    // Now make sure it's in the proper canonical form for a
                    // boot driver.
                    //

                    ApiStatus = ScConvertToBootPathName(
                                    CurrentImageName,
                                    &NewBinaryPath
                                    );
                    if (ApiStatus != NO_ERROR) {
                        SC_LOG(ERROR, "ScConvertToBootPathName error %lu\n", ApiStatus);
                        goto Cleanup;
                    }

                    lpBinaryPathName = NewBinaryPath;

                    LocalFree(CurrentImageName);
                }
                ApiStatus = NO_ERROR;
            }
        }
    }

    //---------------------
    // ErrorControl
    //---------------------
    if (dwErrorControl != SERVICE_NO_CHANGE) {

        ApiStatus = ScReadErrorControl( ServiceNameKey, &CurrentErrorControl);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        ApiStatus = ScWriteErrorControl( ServiceNameKey, dwErrorControl );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= ERROR_CONTROL_CHANGED;
    }

    //---------------------
    // DisplayName
    //---------------------
    if (lpDisplayName != NULL) {

        //
        // UPDATE SERVICE RECORD
        //
        // We always update the display name in the service record - even
        // if we delay in updating the rest of the config.  If we don't
        // do this, then we leave an opening where two services can end
        // up with the same display name.
        // The following scenerio can take place if we don't update
        // the service record until the service is stopped:
        //
        //  Until serviceA is stopped, the new display name only exists
        //  in the registry.  In the mean time, another service (serviceB)
        //  can be given the same name.  Name validation only looks in
        //  the service records for duplicate names.  Then when serviceA is
        //  stopped, it takes on the new name which is the same as the
        //  display name for serviceB.
        //

        OldSRDisplayName = serviceRecord->DisplayName;

        //
        // If the display name is the same as the service name,
        // then set the display name pointer to point to
        // the service name.
        //
        if ((*lpDisplayName != L'\0') &&
            (_wcsicmp(lpDisplayName,serviceRecord->ServiceName) != 0)) {

            NewDisplayName = (LPWSTR)LocalAlloc(
                                LMEM_FIXED,
                                WCSSIZE(lpDisplayName));

            if (NewDisplayName == NULL) {
                SC_LOG0(ERROR,"RChangeServiceConfigW: LocalAlloc failed\n");
                ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                serviceRecord->DisplayName = OldSRDisplayName;
                goto Cleanup;
            }
            //
            // Copy the display name into new buffer, and free up memory
            // for old name if necessary.
            //
            wcscpy(NewDisplayName, lpDisplayName);
        }
        else {
            NewDisplayName = serviceRecord->ServiceName;
        }

        serviceRecord->DisplayName = NewDisplayName;

        Progress |= DISPLAY_NAME_CHANGED_SR;

        //
        // UPDATE REGISTRY
        //
        ApiStatus = ScReadDisplayName(ServiceNameKey, &CurrentDisplayName);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        ApiStatus = ScWriteDisplayName( ServiceNameKey, lpDisplayName);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        Progress |= DISPLAY_NAME_CHANGED_REG;
    }

    //---------------------
    // BinaryPathName
    //---------------------
    if (lpBinaryPathName != NULL) {

        //
        // Note:  The following call allocates storage for the CurrentImageName
        //
        ApiStatus = ScGetImageFileName (
                        serviceRecord->ServiceName,
                        &CurrentImageName );

        if (ApiStatus != NO_ERROR && ApiStatus != ERROR_PATH_NOT_FOUND) {
            SC_LOG(ERROR,"RChangeServiceConfigW: ScGetImageFileName failed %d\n",
                ApiStatus);
            goto Cleanup;
        }

        if (CurrentServiceType & SERVICE_DRIVER) {
            //
            // Driver service
            //
            ApiStatus = ScCanonDriverImagePath(
                            dwStartType,
                            lpBinaryPathName,
                            &CanonBinaryPath
                            );
            if (ApiStatus != NO_ERROR) {
                SC_LOG(ERROR, "ScCanonDriverImagePath error %lu\n", ApiStatus);
                goto Cleanup;
            }

            if (CurrentImageName == NULL ||
                !ScImagePathsMatch(CanonBinaryPath, CurrentImageName)) {

                ApiStatus = ScWriteImageFileName( ServiceNameKey, CanonBinaryPath);
                if (ApiStatus != NO_ERROR) {
                    SC_LOG(ERROR,"RChangeServiceConfigW: ScWriteImageFileName "
                        "failed %d\n",ApiStatus);
                    goto Cleanup;
                }
                Progress |= BINARY_PATH_CHANGED;
            }

        }
        else {
            //
            // Win32 service
            //
            if (CurrentImageName == NULL ||
                !ScImagePathsMatch(lpBinaryPathName, CurrentImageName)) {

                ApiStatus = ScWriteImageFileName( ServiceNameKey, lpBinaryPathName);
                if (ApiStatus != NO_ERROR) {
                    SC_LOG(ERROR,"RChangeServiceConfigW: ScWriteImageFileName "
                        "failed %d\n",ApiStatus);
                    goto Cleanup;
                }
                Progress |= BINARY_PATH_CHANGED;
            }
        }
    }


    //---------------------
    // Dependencies
    //---------------------
    if (lpDependencies != NULL) {

        //
        // Read the existing dependencies from registry so
        // that we can restore it in case of failure later.
        // We don't check for error here.  We assume a failure means
        // that there are no current dependencies.
        //
        ScReadDependencies(
            ServiceNameKey,
            &CurrentDependencies,
            serviceRecord->ServiceName);

        //
        // Dynamically update the dependencies and check to make sure
        // updating was error-free
        //

        ApiStatus = ScUpdateServiceRecordConfig(
                        serviceRecord,
                        SERVICE_NO_CHANGE,
                        SERVICE_NO_CHANGE,
                        SERVICE_NO_CHANGE,
                        NULL,
                        (LPBYTE)lpDependencies);

        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        Progress |= DEPENDENCIES_CHANGED_SR;

        //
        // Update the dependencies in the registry
        //

        ApiStatus = ScWriteDependencies(
                        ServiceNameKey,
                        (LPWSTR) lpDependencies,
                        dwDependSize
                        );

        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= DEPENDENCIES_CHANGED_REG;
    }


    //---------------------
    // Load order group
    //---------------------

    if (lpLoadOrderGroup != NULL) {

        //
        // Save existing group membership info so that we can restore
        // it in case of error.
        // Read the Current LoadOrderGroup value from Registry
        //
        if (ScAllocateAndReadConfigValue(
                ServiceNameKey,
                GROUP_VALUENAME_W,
                &CurrentGroup,
                NULL
                ) != NO_ERROR) {

            CurrentGroup = NULL;
        }

        //
        // Read current Tag Id to save in case of error.
        //

        CurrentTag = serviceRecord->Tag;

        if ((CurrentGroup != NULL) &&
            (_wcsicmp(lpLoadOrderGroup, CurrentGroup) == 0)) {
            //
            // The new load order group is the same as what is currently
            // in the registry.  This means that no group change is occuring.
            //
            if (lpdwTagId != NULL) {
                //
                // The caller requested a tag.  If there isn't one, generate
                // one and write it to the registry.
                //
                Tag = CurrentTag;

                if (CurrentTag == 0) {

                    ScGetUniqueTag(
                        lpLoadOrderGroup,
                        &Tag
                        );

                    ApiStatus = ScWriteTag(ServiceNameKey, Tag);

                    if (ApiStatus != NO_ERROR) {
                        goto Cleanup;
                    }

                    //
                    // Update the service record with the tag id.
                    //
                    serviceRecord->Tag = Tag;

                    Progress |= TAG_ID_CHANGED;
                }
            }

        }
        else {
            //
            // The new load order group is different from what is currently
            // stored in the registry.  Save the new one in the registry.
            //

            ApiStatus = ScWriteGroupForThisService(
                            ServiceNameKey,
                            lpLoadOrderGroup);

            if (ApiStatus != NO_ERROR) {
                goto Cleanup;
            }
            //
            // Also save it in the service controller database.
            //

            Progress |= REG_GROUP_CHANGED;

            ScDeleteRegistryGroupPointer( serviceRecord);
            ApiStatus = ScCreateRegistryGroupPointer(
                            serviceRecord,
                            lpLoadOrderGroup);

            if (ApiStatus != NO_ERROR) {
                goto Cleanup;
            }

            Progress |= SR_GROUP_CHANGED;

            //
            // Check to see if the LoadOrderGroup is being cleared
            // (0 length string) or set to a new string.  If there
            // is a new string, we need to get a new unique Tag for it.
            //
            if (*lpLoadOrderGroup != 0) {

                //
                // We have a new LoadOrderGroup information.  Get a unique
                // Tag value.
                //
                if (lpdwTagId != NULL) {
                    ScGetUniqueTag(
                        lpLoadOrderGroup,
                        &Tag
                        );
                }
            }

            //
            // Write tag entry to registry if not 0.  If 0, we delete the tag
            // value from the registry.
            //

            if (Tag == 0) {
                ScDeleteTag(ServiceNameKey);
            }
            else {
                ApiStatus = ScWriteTag(ServiceNameKey, Tag);
            }

            if (ApiStatus != NO_ERROR) {
                goto Cleanup;
            }

            //
            // Update the service record with the tag id.
            //
            serviceRecord->Tag = Tag;

            Progress |= TAG_ID_CHANGED;
        }

    }


    //---------------------
    // ServiceStartName
    //---------------------
    //
    // If the service type is a DRIVER then we must interpret the
    // lpServiceStartName as an NT driver object name and add it to
    // the registry.  If the type is WIN32, then lpServiceStartName
    // must be an account name.  This will be handled by
    // ScUpdateServiceRecordConfig.
    //
    if ((newServiceType & SERVICE_DRIVER) &&
             (ARGUMENT_PRESENT(lpServiceStartName))) {

        //
        // Read StartName to save in case of error.
        //
        ApiStatus = ScReadStartName( ServiceNameKey, &CurrentStartName);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        //
        // Write the driver objectname to the registry.
        //
        ApiStatus = ScWriteStartName(
                        ServiceNameKey,
                        lpServiceStartName
                        );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= START_NAME_CHANGED;
    }

    //==============================
    // UPDATE Account Information
    //==============================

    if ((newServiceType & SERVICE_WIN32) &&
        (ARGUMENT_PRESENT(lpServiceStartName) ||
         ARGUMENT_PRESENT(EncryptedPassword))) {

        //
        // Changing the account.
        //

        //
        // Get old account name.
        // It may have already been retreived when we were handling
        // ServiceType (above).
        //
        if (OldAccountName == NULL) {
            ApiStatus = ScReadStartName(ServiceNameKey, &OldAccountName);
            if (ApiStatus != NO_ERROR) {
                goto Cleanup;
            }
        }

        if (! ARGUMENT_PRESENT(lpServiceStartName)) {

            //
            // Account name is specified as the one saved in the registry
            //
            CanonAccountName = OldAccountName;
        }
        else {
            //
            // NOTE:  We may have already obtained a CanonAccountName when we
            // checked the INTERACTIVE service type.
            //
            if (CanonAccountName == NULL) {
                ApiStatus = ScCanonAccountName(lpServiceStartName, &CanonAccountName);
                if (ApiStatus != NO_ERROR) {
                    goto Cleanup;
                }
            }
        }

        //
        // Decrypt the password.  This function returns a pointer to
        // the decrypted password that must be freed later.
        //
        if (ARGUMENT_PRESENT(EncryptedPassword)) {
            ApiStatus = ScDecryptPassword(
                            hService,
                            EncryptedPassword,
                            PasswordSize,
                            &Password
                            );
            if (ApiStatus != NO_ERROR) {
                SC_LOG0(ERROR, "RChangeServiceConfigW: ScDecryptPassword failed\n");
                goto Cleanup;
            }
        }

        //
        // NOTE:  The following needs to be the last operation in the
        //  function.  This is because there is no way to back out of this
        //  if something after it fails.
        //

        //
        // Validate and update internal data structures for the new
        // account, as well as write the new AccountName back to the
        // registry if appropriate.
        //

        ApiStatus = ScValidateAndChangeAccount(
                        serviceRecord,
                        ServiceNameKey,
                        OldAccountName,
                        CanonAccountName,
                        Password
                        );

        if (ApiStatus != NO_ERROR) {
            SC_LOG(ERROR, "ScValidateAndChangeAccount error %lu\n", ApiStatus);
            goto Cleanup;
        }
    }

    //
    // Update the service record with the new configuration if the
    // service is stopped.  If it is running, then set a flag to
    // remind us to do it later.  We don't update the dependencies
    // here since it is done dynamically in RChangeServiceConfigW
    //
    if (serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

        //
        // Dependencies are NULL since they're updated dynamically
        //
        ApiStatus = ScUpdateServiceRecordConfig(
                        serviceRecord,
                        dwServiceType,
                        dwStartType,
                        dwErrorControl,
                        lpLoadOrderGroup,
                        NULL);


        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }
    else {
        //
        // The service is running.  Mark is so that we update the status
        // when it stops.
        //
        SET_UPDATE_FLAG(serviceRecord);
    }

Cleanup:

    if (ApiStatus == NO_ERROR)
    {
        if (lpdwTagId != NULL)
        {
            *lpdwTagId = Tag;
        }
        if (Progress & DISPLAY_NAME_CHANGED_SR)
        {
            if (OldSRDisplayName != serviceRecord->ServiceName)
            {
                LocalFree(OldSRDisplayName);
            }
        }
    }
    else
    {
        //
        // An error occured.  Backout any changes that may have occured.
        //
        if (Progress & SERVICE_TYPE_CHANGED) {
            backoutStatus = ScWriteServiceType( ServiceNameKey, CurrentServiceType);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_SERVICE_TYPE);
            }
        }
        if (Progress & START_TYPE_CHANGED) {
            backoutStatus = ScWriteStartType( ServiceNameKey, CurrentStartType);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_START_TYPE);
            }
        }
        if (Progress & ERROR_CONTROL_CHANGED) {
            backoutStatus = ScWriteErrorControl( ServiceNameKey, CurrentErrorControl);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_ERROR_CONTROL);
            }
        }
        if (Progress & DISPLAY_NAME_CHANGED_REG) {
            if (CurrentDisplayName == NULL) {
                backoutStatus = ScWriteDisplayName(
                                    ServiceNameKey,
                                    L"");
            }
            else {
                backoutStatus = ScWriteDisplayName(
                                    ServiceNameKey,
                                    CurrentDisplayName);
            }

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_DISPLAY_NAME);
            }
        }
        if (Progress & DISPLAY_NAME_CHANGED_SR) {
            if (serviceRecord->DisplayName != serviceRecord->ServiceName) {
                LocalFree(serviceRecord->DisplayName);
                serviceRecord->DisplayName = OldSRDisplayName;
            }
        }
        if (Progress & BINARY_PATH_CHANGED) {
            if (CurrentImageName == NULL) {
                ScRegDeleteValue(ServiceNameKey, IMAGE_VALUENAME_W);
            }
            else {
                backoutStatus = ScWriteImageFileName( ServiceNameKey, CurrentImageName);

                if (backoutStatus != NO_ERROR)
                {
                    ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                      OldSRDisplayName ? OldSRDisplayName :
                                                         serviceRecord->DisplayName,
                                      IDS_SC_CONFIG_BINARY_PATH);
                }
            }
        }
        if (Progress & DEPENDENCIES_CHANGED_REG) {

            //
            // ScWriteDependencies doesn't like NULL dependencies
            //
            LPWSTR  lpTempDepend;

            lpTempDepend = (CurrentDependencies ? CurrentDependencies : L"\0");

            backoutStatus = ScWriteDependencies(
                            ServiceNameKey,
                            lpTempDepend,
                            ScWStrArraySize(lpTempDepend));

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_DEPENDENCIES);
            }
        }
        if (Progress & DEPENDENCIES_CHANGED_SR) {
           backoutStatus = ScUpdateServiceRecordConfig(
                              serviceRecord,
                              SERVICE_NO_CHANGE,
                              SERVICE_NO_CHANGE,
                              SERVICE_NO_CHANGE,
                              NULL,
                              (LPBYTE)CurrentDependencies);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_DEPENDENCIES);
            }
        }
        if (Progress & REG_GROUP_CHANGED) {
            if (CurrentGroup != NULL) {
                backoutStatus = ScWriteGroupForThisService(
                                ServiceNameKey, CurrentGroup);

                if (backoutStatus != NO_ERROR)
                {
                    ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                      OldSRDisplayName ? OldSRDisplayName :
                                                         serviceRecord->DisplayName,
                                      IDS_SC_CONFIG_GROUP);
                }
            }
            else {
                ScRegDeleteValue(ServiceNameKey, GROUP_VALUENAME_W);
            }
        }
        if (Progress & SR_GROUP_CHANGED) {
            ScDeleteRegistryGroupPointer( serviceRecord);
            backoutStatus = ScCreateRegistryGroupPointer( serviceRecord, CurrentGroup);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_GROUP);
            }
        }
        if (Progress & TAG_ID_CHANGED)
        {
            if (CurrentTag == 0)
            {
                ScDeleteTag(ServiceNameKey);
            }
            else
            {
                backoutStatus = ScWriteTag( ServiceNameKey, CurrentTag);

                if (backoutStatus != NO_ERROR)
                {
                    ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                      OldSRDisplayName ? OldSRDisplayName :
                                                         serviceRecord->DisplayName,
                                      IDS_SC_CONFIG_TAG);
                }
            }
            serviceRecord->Tag = CurrentTag;
        }

        if (Progress & START_NAME_CHANGED)
        {
            backoutStatus = ScWriteStartName( ServiceNameKey, CurrentStartName);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_ACCOUNT);
            }
        }
    }

    if (CanonAccountName == OldAccountName) {
        LocalFree(OldAccountName);
    }
    else {
        LocalFree(OldAccountName);
        LocalFree(CanonAccountName);
    }

    //
    // Free memory resources
    //
    LocalFree(CurrentDisplayName);
    LocalFree(CurrentImageName);
    LocalFree(CurrentDependencies);
    LocalFree(CurrentGroup);
    LocalFree(CurrentStartName);
    LocalFree(CanonBinaryPath);
    LocalFree(NewBinaryPath);
    LocalFree(Password);

    if (ServiceNameKey != NULL) {
        (VOID) ScRegFlushKey(ServiceNameKey);
        (VOID) ScRegCloseKey( ServiceNameKey );
    }

    SC_LOG1( CONFIG_API, "RChangeServiceConfigW returning status " FORMAT_DWORD
            ".\n", ApiStatus );

    return (ApiStatus);
}


DWORD
RCreateServiceW(
    IN      SC_RPC_HANDLE   hSCManager,
    IN      LPWSTR          lpServiceName,
    IN      LPWSTR          lpDisplayName,
    IN      DWORD           dwDesiredAccess,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwStartType,
    IN      DWORD           dwErrorControl,
    IN      LPWSTR          lpBinaryPathName,
    IN      LPWSTR          lpLoadOrderGroup,
    OUT     LPDWORD         lpdwTagId OPTIONAL,
    IN      LPBYTE          lpDependencies OPTIONAL,
    IN      DWORD           dwDependSize,
    IN      LPWSTR          lpServiceStartName OPTIONAL,
    IN      LPBYTE          EncryptedPassword OPTIONAL,
    IN      DWORD           PasswordSize,
    IN OUT  LPSC_RPC_HANDLE lpServiceHandle
    )


/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD               ApiStatus;
    LPSERVICE_RECORD    newServiceRecord = NULL;
    LPSERVICE_RECORD    oldServiceRecord;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = NULL;
    HKEY                serviceKey = NULL;
    CHeapPtr<LPWSTR>    Password;
    CHeapPtr<LPWSTR>    CanonAccountName;
    CHeapPtr<LPWSTR>    CanonBinaryPath;
    DWORD               Tag = 0;


    SC_LOG1( CONFIG_API, "In RCreateServiceW - creating %ws\n",lpServiceName);

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    if ( !ScIsValidScManagerHandle( hSCManager ) ) {
        ApiStatus = ERROR_INVALID_HANDLE;
        return(ApiStatus);
    }

    if ( !RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hSCManager)->AccessGranted,
              SC_MANAGER_CREATE_SERVICE
              )) {
        ApiStatus = ERROR_ACCESS_DENIED;
        return(ApiStatus);
    }

    if ( !ScIsValidServiceName( lpServiceName ) ) {
        ApiStatus = ERROR_INVALID_NAME;
        return(ApiStatus);
    }

    //
    // Validate other parameters.
    //
    ApiStatus = ScCheckServiceConfigParms(
            FALSE,              // no, this is not a change operation
            lpServiceName,
            dwServiceType,      // new actual type = same one app gave us.
            dwServiceType,
            dwStartType,
            dwErrorControl,
            lpBinaryPathName,
            lpLoadOrderGroup,
            (LPWSTR)lpDependencies,
            dwDependSize);

    if (ApiStatus != NO_ERROR) {
        return(ApiStatus);
    }

    if (lpdwTagId != NULL) {

        //
        // Asking for tag value but didn't specify group
        //
        if ((lpLoadOrderGroup == NULL) ||
           ((lpLoadOrderGroup != NULL) && (*lpLoadOrderGroup == 0))){

            SC_LOG0(ERROR, "Asking for tag value but didn't specify group\n");
            ApiStatus = ERROR_INVALID_PARAMETER;
            return(ApiStatus);
        }
    }

    if (dwServiceType & SERVICE_WIN32) {

        //
        // Canonicalize the StartName if it is an account name.
        //

        LPWSTR AccountName = SC_LOCAL_SYSTEM_USER_NAME;  // Default


        if (ARGUMENT_PRESENT(lpServiceStartName)) {
            AccountName = lpServiceStartName;
        }

        ApiStatus = ScCanonAccountName(
                        AccountName,
                        &CanonAccountName
                        );

        if (ApiStatus != NO_ERROR) {
            return(ApiStatus);
        }

        //
        // The services that are expected to be interactive MUST
        // run in the LocalSystem account only.
        //
        if ((dwServiceType & SERVICE_INTERACTIVE_PROCESS) &&
            (_wcsicmp(CanonAccountName,SC_LOCAL_SYSTEM_USER_NAME) != 0)) {
            SC_LOG0(ERROR, "Service must run in LocalSystem account to be interactive\n");
            ApiStatus = ERROR_INVALID_PARAMETER;
            return(ApiStatus);
        }
    }
    else if (dwServiceType & SERVICE_DRIVER) {

        //
        // Canonicalize the path name for drivers
        //
        ApiStatus = ScCanonDriverImagePath(
                        dwStartType,
                        lpBinaryPathName,
                        &CanonBinaryPath
                        );
        if (ApiStatus != NO_ERROR) {
            SC_LOG(ERROR, "ScCanonDriverImagePath error %lu\n", ApiStatus);
            return(ApiStatus);
        }
    }

    if (lpServiceHandle == NULL) {
        SC_LOG0(ERROR, "Null lpServiceHandle\n");
        ApiStatus = ERROR_INVALID_PARAMETER;
        return(ApiStatus);
    }

    //
    // Lock database, as we want to add stuff without other threads tripping
    // on our feet.  NOTE:  since we may need the group list lock, we must
    // get that lock first.
    //

    CGroupListExclusiveLock GLock;
    CServiceListExclusiveLock LLock;
    CServiceRecordExclusiveLock RLock;

    //
    // Look for unique tag
    //
    if (lpdwTagId != NULL) {
        ScGetUniqueTag(
            lpLoadOrderGroup,
            &Tag
            );
    }

    //
    // Look for an existing service.
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: See if Service already exists\n");

    ApiStatus = ScGetNamedServiceRecord (
            lpServiceName,
            & oldServiceRecord );

    if (ApiStatus == NO_ERROR) {
        if (DELETE_FLAG_IS_SET(oldServiceRecord)) {
            ApiStatus = ERROR_SERVICE_MARKED_FOR_DELETE;
        }
        else {
            ApiStatus = ERROR_SERVICE_EXISTS;
        }
        goto Cleanup;

    } else if (ApiStatus != ERROR_SERVICE_DOES_NOT_EXIST) {
        goto Cleanup;
    }

    //
    // If there is a DisplayName specified, check to see if it already
    // exists.
    //
    ApiStatus = ScValidateDisplayName(lpDisplayName,NULL);
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Allocate new service record.  Put the service name in the record too.
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: Create a new service record\n");
    ApiStatus = ScCreateServiceRecord(
            lpServiceName,
            & newServiceRecord );
    if (ApiStatus != NO_ERROR) {

        goto Cleanup;
    }

    SC_LOG0( CONFIG_API, "RCreateServiceW: Add Config Info to Service Record\n");
    ApiStatus = ScAddConfigInfoServiceRecord(
                    newServiceRecord,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    lpLoadOrderGroup,
                    Tag,
                    (LPWSTR) lpDependencies,
                    lpDisplayName,
                    NULL    // Create new security descriptor
                    );

    if (ApiStatus != NO_ERROR) {
        SC_LOG(ERROR, "ScAddConfigInfoServiceRecord error %lu\n", ApiStatus);
        goto Cleanup;
    }

    SC_LOG0( CONFIG_API, "RCreateServiceW: Set dependency pointers\n");
    ApiStatus = ScSetDependencyPointers(
                    newServiceRecord
                    );

    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //--------------------------------------------
    // Create a key in registry for this service.
    //--------------------------------------------
    SC_LOG0( CONFIG_API, "RCreateServiceW: Open Registry Key for service\n");
    ApiStatus = ScOpenServiceConfigKey(
            lpServiceName,
            KEY_READ | KEY_WRITE,       // desired access
            TRUE,                       // create if it doesn't exist
            & serviceKey );
    if (ApiStatus != NO_ERROR) {
        SC_LOG1( CONFIG_API, "RCreateServiceW: ScOpenServiceConfigKey failed %d\n",
            ApiStatus);
        goto Cleanup;
    }

    //
    // Write stuff to the registry (except user name and password).
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: Write RegistryInfo\n");
    ApiStatus = ScWriteServiceType( serviceKey, dwServiceType );
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }
    ApiStatus = ScWriteStartType( serviceKey, dwStartType );
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }
    ApiStatus = ScWriteErrorControl( serviceKey, dwErrorControl );
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }
    if (lpdwTagId != NULL) {
        ApiStatus = ScWriteTag( serviceKey, Tag );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    if (dwServiceType & SERVICE_WIN32) {
        ApiStatus = ScWriteImageFileName( serviceKey, lpBinaryPathName );
    }
    else if (dwServiceType & SERVICE_DRIVER) {
        ApiStatus = ScWriteImageFileName( serviceKey, CanonBinaryPath );
    }
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    ScWriteDisplayName(serviceKey, lpDisplayName);

    if ( (lpLoadOrderGroup != NULL) && ( (*lpLoadOrderGroup) != L'\0' ) ) {
        ApiStatus = ScWriteGroupForThisService( serviceKey, lpLoadOrderGroup );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    if ( (lpDependencies != NULL) && ( (*lpDependencies) != L'\0' ) ) {

        ApiStatus = ScWriteDependencies(
                        serviceKey,
                        (LPWSTR) lpDependencies,
                        dwDependSize );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    if (newServiceRecord != NULL && newServiceRecord->ServiceSd != NULL) {
        ApiStatus = ScWriteSd(
                        serviceKey,
                        newServiceRecord->ServiceSd
                        );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    //
    // Create a handle which caller can use.
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: Create Service Handle\n");
    ApiStatus = ScCreateServiceHandle( newServiceRecord,
            & serviceHandleStruct );
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Give the handle the access that the caller requested.
    //
    ApiStatus = ScGrantAccess(
                    serviceHandleStruct,
                    dwDesiredAccess);
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Resolve outstanding dependency to this service.
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: Resolve Dependencies\n");
    ApiStatus = ScResolveDependencyToService(newServiceRecord);
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Decrypt the password.  This function returns a pointer to
    // the decrypted password that must be freed later.
    //
    if (ARGUMENT_PRESENT(EncryptedPassword)) {
        ApiStatus = ScDecryptPassword(
                        hSCManager,
                        EncryptedPassword,
                        PasswordSize,
                        &Password
                        );
        if (ApiStatus != NO_ERROR) {
            SC_LOG0(ERROR, "RCreateServiceW: ScDecryptPassword failed\n");
            goto Cleanup;
        }
    }

    //
    // The LAST thing we must do (which might fail) is call
    // ScValidateAndSaveAccount().  This must be last because there is no
    // way to undo this routine's actions.
    //
    if (dwServiceType & SERVICE_WIN32) {

        SC_LOG0( CONFIG_API, "RCreateServiceW: Validate and save account\n");
        ApiStatus = ScValidateAndSaveAccount(
                        lpServiceName,
                        serviceKey,
                        CanonAccountName,
                        Password
                        );
        if (ApiStatus != NO_ERROR) {
            SC_LOG(ERROR, "ScValidateAndSaveAccount error %lu\n", ApiStatus);
            goto Cleanup;
        }
    }
    else if ((dwServiceType & SERVICE_DRIVER) &&
             (ARGUMENT_PRESENT(lpServiceStartName))) {

        SC_LOG0( CONFIG_API, "RCreateServiceW: Write Driver ObjectName to "
            "registry\n");
        //
        // Write the driver objectname to the registry.
        //
        ApiStatus = ScWriteStartName(
                        serviceKey,
                        lpServiceStartName
                        );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    SC_LOG0( CONFIG_API, "RCreateServiceW: Done - No Errors\n");
    ApiStatus = NO_ERROR;

Cleanup:

    if (serviceKey != NULL) {
        (VOID) ScRegFlushKey( serviceKey);
        (VOID) ScRegCloseKey( serviceKey );
    }

    if (ApiStatus == NO_ERROR) {
        newServiceRecord->UseCount = 1;
        *lpServiceHandle = (SC_RPC_HANDLE) serviceHandleStruct;

        SC_LOG2(USECOUNT, "CreateService: " FORMAT_LPWSTR
                " increment USECOUNT=%lu\n", newServiceRecord->ServiceName, newServiceRecord->UseCount);

        if (lpdwTagId != NULL) {
            *lpdwTagId = Tag;
        }
    }
    else {

        if (newServiceRecord != NULL) {
            //
            // Delete partially created service record.
            //
            SET_DELETE_FLAG(newServiceRecord);
            newServiceRecord->UseCount = 1;
            SC_LOG2(USECOUNT, "CreateService: " FORMAT_LPWSTR
                " increment USECOUNT=%lu\n", newServiceRecord->ServiceName, newServiceRecord->UseCount);
            //
            // ScDecrementUseCountAndDelete deletes the service record
            // and the registry entry for that service.
            //
            ScDecrementUseCountAndDelete(newServiceRecord);
            newServiceRecord = NULL;
        }

        LocalFree(serviceHandleStruct);

        if (lpServiceHandle != NULL) {
            *lpServiceHandle = NULL;
        }
    }

    SC_LOG2( CONFIG_API, "RCreateServiceW returning status " FORMAT_DWORD
            " and handle " FORMAT_LPVOID ".\n", ApiStatus,
            (LPVOID) serviceHandleStruct );

    return(ApiStatus);
}

DWORD
RDeleteService(
    IN  SC_RPC_HANDLE       hService
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS            status;
    UNICODE_STRING      Subsystem;
    ULONG               privileges[1];
    DWORD               ApiStatus;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hService;
    LPSERVICE_RECORD    serviceRecord;

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if ( !ScIsValidServiceHandle( hService ) ) {
        return(ERROR_INVALID_HANDLE);
    }

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              DELETE
              )) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // Lock database, as we want to change stuff without other threads tripping
    // on our feet.
    //
    CServiceRecordExclusiveLock RLock;

    //
    // Find the service record
    //
    serviceRecord = serviceHandleStruct->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT( serviceRecord != NULL );
    SC_ASSERT( serviceRecord->Signature == SERVICE_SIGNATURE );

    //
    // Check if marked for deletion (by another call to this API).
    //
    if (DELETE_FLAG_IS_SET(serviceRecord)) {
        ApiStatus = ERROR_SERVICE_MARKED_FOR_DELETE;
        goto Cleanup;
    }

    //
    // Mark the service for deletion.
    // It will actually be deleted when the last handle to it is closed.
    // NOTE:  Since the service itself owns a handle, the deletion is
    // not complete until the service has stopped.
    //
    SET_DELETE_FLAG(serviceRecord);

    //
    // Set the start type to disabled.  If we're deleting a driver that's
    // started by the system, we don't want the system to start it on the
    // next boot since we're going to remove the key from the registry
    //
    serviceRecord->StartType = SERVICE_DISABLED;

    //
    // Mark the registry entry for this service for deletion.  If we notice
    // this as being present when we go throught our initialization routine
    // (during boot), the service entry in the registry will be deleted.
    //
    ScMarkForDelete(serviceRecord);

    //
    // Get Audit Privilege
    //
    privileges[0] = SE_AUDIT_PRIVILEGE;
    status = ScGetPrivilege( 1, privileges);

    if (!NT_SUCCESS(status)) {
        SC_LOG1(ERROR, "RDeleteService: ScGetPrivilege (Enable) failed %#lx\n",
                status);
    }

    //
    // Generate the Audit.
    //

    RtlInitUnicodeString(&Subsystem, SC_MANAGER_AUDIT_NAME);
    status = NtDeleteObjectAuditAlarm(
                &Subsystem,
                hService,
                (BOOLEAN)((serviceHandleStruct->Flags
                    & SC_HANDLE_GENERATE_ON_CLOSE) != 0));
    if (!NT_SUCCESS(status)) {
        SC_LOG1(ERROR, "RDeleteService: NtDeleteObjectAuditAlarm failed %#lx\n",
                status);
    }

    ScReleasePrivilege();

    ApiStatus = NO_ERROR;

Cleanup:

    SC_LOG2( CONFIG_API, "RDeleteService(%ws) returning status " FORMAT_DWORD
            ".\n", serviceRecord->ServiceName, ApiStatus );

    return (ApiStatus);
}


DWORD
RQueryServiceConfigW(
    IN    SC_RPC_HANDLE           hService,
    OUT   LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    IN    DWORD                   cbBufSize,
    OUT   LPDWORD                 pcbBytesNeeded
    )


/*++

Routine Description:

    This function returns the service configuration information that
    is currently stored in the registry.

    NOTE:
    When a service is running and its configuration is changed, the
    change only affects the registry information as long as the service
    is running.  During this period (while the service is running), it is
    not possible to obtain the configuration of the running service.
    All that can be obtained is the configuration stored in the registry.
    This is the configuration that the service will have the next time
    it is run.  Stopping a service causes it to get its configuration
    information refreshed from the registry.

Arguments:


Return Value:


--*/
{
    DWORD               ApiStatus;
    DWORD               bytesNeeded = sizeof(QUERY_SERVICE_CONFIG); // (initial)
    LPWSTR              endOfVariableData;
    LPWSTR              fixedDataEnd;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hService;
    LPSERVICE_RECORD    serviceRecord = NULL;
    HKEY                ServiceNameKey = (HKEY) NULL;
    DWORD               bufSize;
    DWORD               dependSize=0;
    LPWSTR              CurrentImagePathName = NULL;
    LPWSTR              CurrentDependencies = NULL;
    LPWSTR              CurrentGroup = NULL;
    LPWSTR              CurrentStartName = NULL;
    LPWSTR              pDependString;
    LPWSTR              CurrentDisplayName = NULL;
    LPWSTR              ConvertImageName;

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if ( !ScIsValidServiceHandle( hService ) ) {
        return(ERROR_INVALID_HANDLE);
    }

    //
    // Check other caller parms (except buffer too small, we need more info).
    //
    if (lpServiceConfig == NULL) {
        return(ERROR_INVALID_PARAMETER);
    } else if (pcbBytesNeeded == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              SERVICE_QUERY_CONFIG
              )) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // Lock database, as we want to look at stuff without other threads changing
    // fields at the same time.
    //
    CServiceRecordSharedLock RLock;

    serviceRecord = serviceHandleStruct->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT( serviceRecord != NULL );


    //
    // Open the service name key.
    //
    ApiStatus = ScOpenServiceConfigKey(
                    serviceRecord->ServiceName,
                    KEY_READ,
                    FALSE,               // Create if missing
                    &ServiceNameKey
                    );

    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //--------------------------------
    // Get the BinaryPathName
    //--------------------------------
    SC_ASSERT( serviceRecord->ServiceName != NULL );

    ApiStatus = ScGetImageFileName (
           serviceRecord->ServiceName,
           & CurrentImagePathName );       // alloc and set ptr.

    if (ApiStatus != NO_ERROR) {
        CurrentImagePathName = NULL;
    }

    ApiStatus = ScReadConfigFromReg(
                    serviceRecord,
                    &lpServiceConfig->dwServiceType,
                    &lpServiceConfig->dwStartType,
                    &lpServiceConfig->dwErrorControl,
                    &lpServiceConfig->dwTagId,
                    &CurrentDependencies,
                    &CurrentGroup,
                    &CurrentDisplayName);

    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // If the starttype is SERVICE_BOOT_START the name is a relative path
    // from \SystemRoot.  Fix it to be a fully qualified name, unless it is
    // an ARC name, then leave it alone.
    //

    if (CurrentImagePathName &&
        lpServiceConfig->dwStartType == SERVICE_BOOT_START &&
        !ScIsArcName(CurrentImagePathName)) {

        ConvertImageName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((wcslen(CurrentImagePathName) +
            wcslen(SC_NT_SYSTEM_ROOT) + 1) * sizeof(WCHAR)));
        if (ConvertImageName == NULL) {
            SC_LOG1(ERROR, "RQueryServiceConfigW: LocalAlloc failed %lu\n",
                    GetLastError());
            ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy(ConvertImageName, SC_NT_SYSTEM_ROOT);
        wcscat(ConvertImageName, CurrentImagePathName);
        LocalFree(CurrentImagePathName);
        CurrentImagePathName = ConvertImageName;
    }

    //--------------------------------
    // Get StartName
    //--------------------------------
    ApiStatus = ScReadStartName( ServiceNameKey, &CurrentStartName);
    if (ApiStatus != NO_ERROR) {
        SC_LOG1(TRACE,"StartName for %ws service does not exist\n",
            serviceRecord->ServiceName);
        CurrentStartName = NULL;
    }


    //
    // Figure-out how much space we'll need for the record.
    // We've already got the initial (fixed) size in bytesNeeded...
    //
    SC_ASSERT( bytesNeeded == sizeof(QUERY_SERVICE_CONFIG) );


    //
    // Add on some extra for RPC byte count alignment.
    // NOTE:  We don't try and solve any exact alignment problem because
    //        RPC will choose a random order in which to load strings into
    //        the buffer.
    //
    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    if (CurrentImagePathName != NULL)
    {
        bytesNeeded += (DWORD) WCSSIZE(CurrentImagePathName);
    }
    else {
        bytesNeeded += sizeof(WCHAR);
    }

    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    //
    // If the display name is not stored in the registry, the
    // Service Name is returned instead.
    //

    if (CurrentDisplayName == NULL) {
        CurrentDisplayName = serviceRecord->ServiceName;
    }

    bytesNeeded += (DWORD) WCSSIZE(CurrentDisplayName);

    //
    // Add on some extra for RPC byte count alignment.
    //
    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    if (CurrentGroup != NULL) {
        bytesNeeded += (DWORD) WCSSIZE(CurrentGroup);
    }
    else {
        bytesNeeded += sizeof(WCHAR);
    }

    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    if (CurrentDependencies != NULL) {
        dependSize = ScWStrArraySize(CurrentDependencies);
        bytesNeeded += dependSize;
    }
    else {
        bytesNeeded += (2 * sizeof(WCHAR));
    }

    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    if (CurrentStartName != NULL) {
        bytesNeeded += (DWORD) WCSSIZE(CurrentStartName);
    }
    else {
        bytesNeeded += sizeof(WCHAR);
    }

    bytesNeeded = ROUND_UP_COUNT(bytesNeeded, ALIGN_WCHAR);

    //
    // Make sure app gave us enough space.
    //
    if (bytesNeeded > cbBufSize) {
        *pcbBytesNeeded = bytesNeeded;
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    //========================
    // Fill in the strings.
    //========================
    fixedDataEnd = (LPWSTR) (lpServiceConfig + 1);
    endOfVariableData = (LPWSTR) ((LPBYTE)lpServiceConfig + bytesNeeded);


    bufSize = 0;
    if (CurrentImagePathName != NULL) {
        bufSize = (DWORD) wcslen( CurrentImagePathName );
    }

    if ( !ScCopyStringToBufferW (
            CurrentImagePathName,
            bufSize,
            fixedDataEnd,
            & endOfVariableData,
            & lpServiceConfig->lpBinaryPathName,
            NULL
            ) ) {

        SC_LOG0(ERROR,
            "RQueryServiceConfigW:ScCopyStringtoBufferW "
            "(BinaryPathName)Failed\n");

        SC_ASSERT( FALSE );
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    bufSize = 0;

    if (CurrentGroup != NULL) {
        bufSize = (DWORD) wcslen( CurrentGroup );
    }

    if ( !ScCopyStringToBufferW (
            CurrentGroup,
            bufSize,
            fixedDataEnd,
            &endOfVariableData,
            &lpServiceConfig->lpLoadOrderGroup,
            NULL
            ) ) {

        SC_LOG0(ERROR,
            "RQueryServiceConfigW:ScCopyStringtoBufferW "
            "(LoadOrderGroup)Failed\n");

        SC_ASSERT( FALSE );
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    //
    // Dependencies
    //
    if ((CurrentDependencies == NULL) || (dependSize == 0)) {
        //
        // There are no dependencies so put in a double null terminated
        // null string.
        //
        // NOTE:  The seperator character '/' is inserted to allow the
        //  double NULL terminated string to make it across RPC.
        //  This is removed by the client side.
        //
        lpServiceConfig->lpDependencies = endOfVariableData - 2;
        endOfVariableData = lpServiceConfig->lpDependencies;
        lpServiceConfig->lpDependencies[0] = L'/';
        lpServiceConfig->lpDependencies[1] = L'\0';
    }
    else {
        lpServiceConfig->lpDependencies = (LPWSTR)((LPBYTE)endOfVariableData - dependSize);
        pDependString = lpServiceConfig->lpDependencies;
        endOfVariableData = pDependString;

        RtlCopyMemory(lpServiceConfig->lpDependencies, CurrentDependencies, dependSize);

        //
        // Add seperator characters.
        //
        while ((bufSize = (DWORD) wcslen(pDependString)) != 0) {
            pDependString += bufSize;
            *pDependString = L'/';
            pDependString++;
        }
    }

    //
    // StartName
    //
    bufSize = 0;
    if (CurrentStartName != NULL) {
        bufSize = (DWORD) wcslen(CurrentStartName);
    }

    if ( !ScCopyStringToBufferW (
            CurrentStartName,
            bufSize,
            fixedDataEnd,
            & endOfVariableData,
            & lpServiceConfig->lpServiceStartName,
            NULL
            ) ) {

        SC_LOG0(ERROR,
            "RQueryServiceConfigW:ScCopyStringtoBufferW (StartName)Failed\n");

        SC_ASSERT( FALSE );
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    //
    // DisplayName
    //
    bufSize = 0;

    SC_ASSERT(CurrentDisplayName);

    bufSize = (DWORD) wcslen(CurrentDisplayName);

    if ( !ScCopyStringToBufferW (
            CurrentDisplayName,
            bufSize,
            fixedDataEnd,
            & endOfVariableData,
            & lpServiceConfig->lpDisplayName,
            NULL
            ) ) {

        SC_LOG0(ERROR,
            "RQueryServiceConfigW:ScCopyStringtoBufferW (DisplayName)Failed\n");

        SC_ASSERT( FALSE );
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    //
    // That's all, folks!  --JR
    //
    ApiStatus = NO_ERROR;

Cleanup:

    if (ServiceNameKey != (HKEY) NULL) {
        ScRegCloseKey(ServiceNameKey);
    }

    LocalFree(CurrentStartName);
    LocalFree(CurrentImagePathName);

    if (serviceRecord != NULL &&
        CurrentDisplayName != serviceRecord->DisplayName) {
        (VOID) LocalFree( CurrentDisplayName );
    }

    LocalFree( CurrentGroup );
    LocalFree( CurrentDependencies );

    if (pcbBytesNeeded != NULL) {
        *pcbBytesNeeded = bytesNeeded;
    }

    SC_LOG2( CONFIG_API, "RQueryServiceConfigW returning status " FORMAT_DWORD
            " and size needed " FORMAT_DWORD ".\n", ApiStatus, bytesNeeded );

    //
    // If an error occurs, we set the pointers in the structure to NULL.
    // This is for RPC. Since we are using the byte_count feature, the
    // server marshalling code must look at the pointers.  Otherwise, it
    // doesn't know how to marshall the strings.
    //
    if (ApiStatus != NO_ERROR) {
        lpServiceConfig->lpBinaryPathName   = NULL;
        lpServiceConfig->lpLoadOrderGroup   = NULL;
        lpServiceConfig->lpDependencies     = NULL;
        lpServiceConfig->lpServiceStartName = NULL;
        lpServiceConfig->lpDisplayName      = NULL;
    }

    return (ApiStatus);
}


DWORD
ScCanonDriverImagePath(
    IN DWORD DriverStartType,
    IN LPWSTR DriverPath,
    OUT LPWSTR *CanonDriverPath
    )
/*++

Routine Description:

    This function converts the user specified DOS path name to the driver
    binary file into an NT path format understood by NtLoadDriver.

    Examples:

        C:\nt\system32\file.sys -> \DosDevices\c:\nt\system323\file.sys

        %SystemRoot%\system32\drivers\file.sys -> \SystemRoot\system32\driver\file.sys


Arguments:

    DriverPath - User specified DOS path name to driver .SYS file.

    CanonDriverPath - Receives a pointer to a buffer which contains the
        NT path to the driver .SYS file.  This buffer should be freed
        with LocalFree.

Return Value:

    NO_ERROR - successful.

    ERROR_NOT_ENOUGH_MEMORY - no memory to allocate output buffer.

    ERROR_INVALID_PARAMETER - RtlDosPathNameToNtPath_U failure.

--*/
{

    UNICODE_STRING NewPath;
    DWORD DriverPathLength;
    DWORD NTSystemRootLength;
    DWORD DOSSystemRootLength;
    LPWSTR RelativeCanonPath;
    DWORD Status;

    SC_LOG1(DEPEND, "ScCanonDriverImagePath: Input path "
            FORMAT_LPWSTR "\n", DriverPath);

    DriverPathLength = (DWORD) wcslen(DriverPath);
    NTSystemRootLength = (DWORD) wcslen(SC_NT_SYSTEM_ROOT);

    if (DriverPathLength > NTSystemRootLength &&
        (_wcsnicmp(SC_NT_SYSTEM_ROOT, DriverPath,
                 NTSystemRootLength) == 0)) {

        //
        // Path is already in NT form with \SystemRoot\ prefix.
        // Just return a buffer that contains the same path as input.
        //

        *CanonDriverPath = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((DriverPathLength + 1) * sizeof(WCHAR)));

        if (*CanonDriverPath == NULL) {
            SC_LOG1(ERROR, "ScCanonDriverPathName: LocalAlloc failed %lu\n",
                    GetLastError());
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Boot drivers need relative path names
        //

        if (DriverStartType == SERVICE_BOOT_START) {
            wcscpy(*CanonDriverPath, DriverPath + NTSystemRootLength);
        }
        else {
            wcscpy(*CanonDriverPath, DriverPath);
        }

        SC_LOG1(DEPEND, "ScCanonDriverImagePath: Canonicalized path "
                FORMAT_LPWSTR "\n", *CanonDriverPath);

        return NO_ERROR;
    }

    DOSSystemRootLength = (DWORD) wcslen(SC_DOS_SYSTEM_ROOT);

    if (DriverPathLength > DOSSystemRootLength &&
        (_wcsnicmp(SC_DOS_SYSTEM_ROOT, DriverPath, DOSSystemRootLength) == 0)) {

        //
        // DOS path has %SystemRoot%\ prefix
        //

        *CanonDriverPath = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((DriverPathLength + 1) * sizeof(WCHAR)));

        if (*CanonDriverPath == NULL) {
            SC_LOG1(ERROR, "ScCanonDriverPathName: LocalAlloc failed %lu\n",
                    GetLastError());
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (DriverStartType != SERVICE_BOOT_START) {
            wcscpy(*CanonDriverPath, SC_NT_SYSTEM_ROOT);
        }
        else {
            *CanonDriverPath[0] = '\0';
        }

        wcscat(*CanonDriverPath, DriverPath + DOSSystemRootLength);

        SC_LOG1(DEPEND, "ScCanonDriverImagePath: Canonicalized path "
                FORMAT_LPWSTR "\n", *CanonDriverPath);

        return NO_ERROR;
    }

    //
    // If it's already a relative path name, leave it alone
    //

    if (DriverPath[0] != L'\\' && DriverPath[1] != L':') {
        *CanonDriverPath = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((DriverPathLength + 1) * sizeof(WCHAR)));
        if (*CanonDriverPath == NULL) {
            SC_LOG1(ERROR, "ScCanonDriverPathName: LocalAlloc failed %lu\n",
                    GetLastError());
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(*CanonDriverPath, DriverPath);
        return(NO_ERROR);
    }

    //
    // Convert DOS path to NT path using Rtl routine which allocates
    // the Unicode string buffer.
    //
    if (! RtlDosPathNameToNtPathName_U(
              (PCWSTR) DriverPath,
              &NewPath,
              NULL,
              NULL
              )) {
        return ERROR_INVALID_PARAMETER;
    }

    *CanonDriverPath = (LPWSTR) LocalAlloc(
                                    LMEM_ZEROINIT,
                                    (UINT) NewPath.Length + sizeof(WCHAR)
                                    );

    if (*CanonDriverPath == NULL) {

        SC_LOG1(ERROR, "ScCanonDriverPathName: LocalAlloc failed %lu\n",
                GetLastError());

        RtlFreeUnicodeString(&NewPath);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcsncpy(*CanonDriverPath, NewPath.Buffer, NewPath.Length / sizeof(WCHAR));

    RtlFreeUnicodeString(&NewPath);

    //
    // Boot drivers' imagepath must be relative to \systemroot
    //

    if (DriverStartType == SERVICE_BOOT_START)
    {
        Status = ScConvertToBootPathName(*CanonDriverPath, &RelativeCanonPath);

        if (Status == NO_ERROR)
        {
            SC_ASSERT(RelativeCanonPath != NULL);
            wcscpy(*CanonDriverPath, RelativeCanonPath + NTSystemRootLength);
            LocalFree(RelativeCanonPath);
        }
        else
        {
            LocalFree(*CanonDriverPath);
            *CanonDriverPath = NULL;
        }

        return Status;
    }

    SC_LOG1(DEPEND, "ScCanonDriverImagePath: Canonicalized path "
            FORMAT_LPWSTR "\n", *CanonDriverPath);

    return NO_ERROR;
}


DWORD
RGetServiceDisplayNameW(
    SC_RPC_HANDLE   hSCManager,
    LPWSTR          lpServiceName,
    LPWSTR          lpDisplayName,
    LPDWORD         lpcchBuffer
    )
/*++

Routine Description:

    This function returns the DisplayName that is associated with a
    particular ServiceName.  If the buffer that is to receive the
    DisplayName is too small, no data is returned in the buffer.  Instead,
    the actual string size (in characters - not including NUL terminator)
    is returned in *lpcchBuffer.

Arguments:

    hSCManager - Handle to the Service Control Manager.  This parameter
        is the RPC handle that was used to get us to this point.

    lpServiceName - This is a pointer to the service name string.  This
        name is the same as the registry key name for that service.

    lpDisplayName - This is a pointer to the buffer where the display name
        is to be placed.  If this function fails, this buffer will contain
        an empty string.

    lpcchBuffer - This is a pointer to a DWORD that contains the size of
        the buffer (in characters) upon input.  On return, this DWORD
        indicates how many characters (excluding the NUL terminator) are
        in the DisplayName.

Return Value:

    NO_ERROR - If the operation was successful.

    ERROR_INSUFFICIENT_BUFFER - if the buffer is too small to contain the
        whole string.

    ERROR_SERVICE_DOES_NOT_EXIST - If there is no record of a service
        by this name in the database.

    ERROR_INVALID_NAME - if the ServiceName is invalid (NULL);

--*/
{
    DWORD               status;
    DWORD               reqSize;
    LPSERVICE_RECORD    ServiceRecord;

    UNREFERENCED_PARAMETER(hSCManager);

    //
    // Find the proper service record.
    //
    CServiceListSharedLock LLock;
    CServiceRecordSharedLock RLock;

    status = ScGetNamedServiceRecord(lpServiceName, &ServiceRecord);
    if (status != NO_ERROR) {
        return(status);
    }

    //
    // Get the display name and determine if it will fit in the buffer.
    //
    reqSize = (DWORD) wcslen(ServiceRecord->DisplayName);

    if (*lpcchBuffer < (reqSize + 1))
    {
        *lpcchBuffer = reqSize;
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    wcscpy(lpDisplayName, ServiceRecord->DisplayName);
    *lpcchBuffer = reqSize;

    return(NO_ERROR);
}

DWORD
RGetServiceKeyNameW(
    SC_RPC_HANDLE   hSCManager,
    LPWSTR          lpDisplayName,
    LPWSTR          lpServiceName,
    LPDWORD         lpcchBuffer
    )

/*++

Routine Description:

    This function returns the ServiceName that is associated with a
    particular DisplayName.  If the buffer that is to receive the
    ServiceName is too small, no data is returned in the buffer.  Instead,
    the actual string size (in characters - not including NUL terminator)
    is returned in *lpcchBuffer.


Arguments:

    hSCManager - Handle to the Service Control Manager.  This parameter
        is the RPC handle that was used to get us to this point.

    lpDisplayName - This is a pointer to the service display name string.

    lpServiceName - This is a pointer to the buffer where the service name
        string is to be placed.  If this function fails, this buffer will
        contain an empty string.

    lpcchBuffer - This is a pointer to a DWORD that contains the size of
        the buffer (in characters) upon input.  On return, this DWORD
        indicates how many characters (excluding the NUL terminator) are
        in the DisplayName.

Return Value:



--*/
{
    DWORD               status;
    DWORD               reqSize;
    LPSERVICE_RECORD    ServiceRecord;

    UNREFERENCED_PARAMETER(hSCManager);

    //
    // Find the proper service record.
    //
    CServiceListSharedLock LLock;
    CServiceRecordSharedLock RLock;

    status = ScGetDisplayNamedServiceRecord(lpDisplayName, &ServiceRecord);

    if (status != NO_ERROR)
    {
        return(status);
    }

    //
    // Get the service key name and determine if it will fit in the buffer.
    //
    reqSize = (DWORD) wcslen(ServiceRecord->ServiceName);

    if (*lpcchBuffer < (reqSize + 1)) {
        *lpcchBuffer = reqSize;
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    wcscpy(lpServiceName, ServiceRecord->ServiceName);
    *lpcchBuffer = reqSize;

    return(NO_ERROR);
}

DWORD
ScValidateDisplayName(
    LPWSTR              lpDisplayName,
    LPSERVICE_RECORD    lpServiceRecord
    )

/*++

Routine Description:

    This function validates display names by checking to see if the name
    string already exists in the database.  The display name must not match
    any other display name or another service name.  The display name can
    match the service name if it they both refer to the same service.

Arguments:

    lpDisplayName - A pointer to the proposed DisplayName.

    lpServiceRecord - A pointer to the service record to which the display
        name is to be added.  If this function is called from CreateService,
        the lpServiceRecord pointer will be NULL.

Return Value:

    NO_ERROR - If the DisplayName doesn't conflict with any other names
        in the database.

    ERROR_DUPLICATE_SERVICE_NAME - If the DisplayName conflicts with another name.



--*/
{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    displayServiceRecord;

    if (lpDisplayName != NULL) {

        if (wcslen(lpDisplayName) > MAX_SERVICE_NAME_LENGTH) {
            return(ERROR_INVALID_NAME);
        }

        status = ScGetDisplayNamedServiceRecord(
                    lpDisplayName,
                    &displayServiceRecord);
        if (status == NO_ERROR) {
            if (displayServiceRecord != lpServiceRecord) {
                //
                // The display name already exists for a different
                // service.  Therefore we must reject it.
                //
                return(ERROR_DUPLICATE_SERVICE_NAME);
            }
        }
        status = ScGetNamedServiceRecord(
                    lpDisplayName,
                    &displayServiceRecord);
        if (status == NO_ERROR) {
            if (displayServiceRecord != lpServiceRecord) {
                //
                // The display name is already used as a service name.
                // Therefore we must reject it.
                //
                return(ERROR_DUPLICATE_SERVICE_NAME);
            }
        }
    }
    return(NO_ERROR);
}

DWORD
ScConvertToBootPathName(
    LPWSTR              FullQualPathName,
    LPWSTR *            RelativePathName
    )

/*++

Routine Description:

    This function takes an NT style image path name and turns it into an
    NT style path name that is accessed via \systemroot.  This is required
    for drivers that are loaded by the boot loader.

Arguments:

    FullQualPathName - The fully qualified name

    RelativePathName - A pointer to the pointer for the new buffer which
                       contains the fully qualified path name using
                       \systemroot\.  The caller must free this buffer using
                       LocalFree.

Return Value:

    NO_ERROR - If the name can be converted.

    ERROR_INVALID_PARAMETER - If the Name is not relative to \systemroot

--*/
{

    WCHAR Dummy;
    LPWSTR Prefix = &Dummy;
    DWORD PrefixLength;
    UNICODE_STRING NewPrefix;
    DWORD NTSystemRootLength;
    DWORD PathLength;
    DWORD NumRequired;
    DWORD CharsReturned;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle = NULL;
    UNICODE_STRING FileName;
    UNICODE_STRING LinkTarget = { 0, 0, NULL };

    NTSTATUS Status;
    DWORD    dwError = NO_ERROR;

    DWORD BytesRequired;

    PrefixLength = (DWORD) wcslen(SC_NT_SYSTEM_ROOT);
    NTSystemRootLength = PrefixLength;
    PathLength = (DWORD) wcslen(FullQualPathName);

    if ((PathLength > PrefixLength) &&
        (_wcsnicmp(SC_NT_SYSTEM_ROOT, FullQualPathName, PrefixLength) == 0)) {

        //
        // Path is already in NT form with \SystemRoot\ prefix.
        // Just return it
        //

        *RelativePathName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) (PathLength + 1) * sizeof(WCHAR));

        if (*RelativePathName == NULL)
        {
            SC_LOG1(ERROR, "ScConvertToBootName: LocalAlloc failed %d\n",
                GetLastError());
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        wcscpy(*RelativePathName, FullQualPathName);
        return(ERROR_SUCCESS);
    }

    PrefixLength = (DWORD) wcslen(SC_DOS_SYSTEM_ROOT);

    if (PathLength > PrefixLength &&
        (_wcsnicmp(SC_DOS_SYSTEM_ROOT, FullQualPathName, PrefixLength) == 0)) {

        //
        // Path is in DOS form with %SystemRoot% prefix.
        // Just return it after replacing the %SystemRoot%\ prefix with
        // \SystemRoot
        //

        *RelativePathName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) (PathLength - PrefixLength + NTSystemRootLength + 1)
            * sizeof(WCHAR));
        if (*RelativePathName == NULL) {
            SC_LOG1(ERROR, "ScConvertToBootName: LocalAlloc failed %d\n",
                GetLastError());
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        wcscpy(*RelativePathName, SC_NT_SYSTEM_ROOT);
        wcscat(*RelativePathName, FullQualPathName + PrefixLength);
        return(ERROR_SUCCESS);
    }

    //
    // Create a string that represents the path to systemroot that you
    // would get if you started with a Dos style name
    //

    //
    // Make the first call just to get the number of characters that
    // will be returned.
    //

    NumRequired = ExpandEnvironmentStringsW (SC_DOS_SYSTEM_ROOT, Prefix, 1);

    if (NumRequired > 1) {

        Prefix = (LPWSTR)LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((NumRequired + 1) * sizeof(WCHAR)));

        if (Prefix == NULL) {
            SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
                FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                NumRequired + 1, GetLastError());
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Now expand the string into a dos type path
        //

        CharsReturned = ExpandEnvironmentStringsW (
                            SC_DOS_SYSTEM_ROOT,
                            Prefix,
                            NumRequired);

        if (CharsReturned > NumRequired) {
            SC_LOG1(ERROR, "ScConvertToBootName: ExpandEnvironmentStrings "
                " failed for " FORMAT_LPWSTR " \n", SC_DOS_SYSTEM_ROOT);
            LocalFree(Prefix);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    else {

        //
        // This shouldn't ever happen
        //
        ASSERT(FALSE);
        return ERROR_INVALID_ENVIRONMENT;
    }

    //
    // Now convert the DOS path to an NT path
    //

    if (! RtlDosPathNameToNtPathName_U(
              (PCWSTR) Prefix,
              &NewPrefix,
              NULL,
              NULL
              )) {

        //
        // This shouldn't ever happen
        //
        ASSERT(FALSE);
        LocalFree(Prefix);
        return ERROR_INVALID_ENVIRONMENT;
    }

    LocalFree(Prefix);

    PrefixLength = NewPrefix.Length / sizeof(WCHAR);

    Prefix = (LPWSTR)LocalAlloc(LMEM_ZEROINIT,
        (UINT) (NewPrefix.Length + sizeof(WCHAR)));

    if (Prefix == NULL)
    {
        SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
            FORMAT_DWORD " failed " FORMAT_DWORD "\n",
            NewPrefix.Length + sizeof(WCHAR), GetLastError());

        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    wcsncpy(Prefix, NewPrefix.Buffer, PrefixLength);

    if (PathLength > PrefixLength &&
        (_wcsnicmp(Prefix, FullQualPathName, PrefixLength) == 0)) {

        //
        // Path is in DOS form without using %systemroot%
        // Convert to \SystemRoot format
        //

        *RelativePathName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) (PathLength - PrefixLength + NTSystemRootLength + 1)
            * sizeof(WCHAR));

        if (*RelativePathName == NULL)
        {
            SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
                FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                (PathLength - PrefixLength + NTSystemRootLength + 1) *
                sizeof(WCHAR), GetLastError());

            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy(*RelativePathName, SC_NT_SYSTEM_ROOT);
        wcscat(*RelativePathName, FullQualPathName + PrefixLength);

        dwError = NO_ERROR;
        goto CleanExit;
    }

    //
    // Create a string that represents the path to systemroot that you
    // would get if you started with a NT style name
    //

    //
    // Make the first call just to get the number of characters that
    // will be returned.
    //

    RtlInitUnicodeString(&FileName,L"\\SystemRoot");
    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &FileName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

    Status = NtOpenSymbolicLinkObject(&Handle, SYMBOLIC_LINK_QUERY,
        &ObjectAttributes);

    if (!NT_SUCCESS(Status))
    {
        //
        // This should never happen
        //
        ASSERT(FALSE);
        dwError = ERROR_INVALID_ENVIRONMENT;
        goto ErrorExit;
    }

    Status = NtQuerySymbolicLinkObject(Handle, &LinkTarget, &BytesRequired);

    if (!NT_SUCCESS(Status) && Status != STATUS_BUFFER_TOO_SMALL)
    {
        //
        // This should never happen
        //
        ASSERT(FALSE);
        dwError = ERROR_INVALID_ENVIRONMENT;
        goto ErrorExit;
    }

    LinkTarget.Buffer = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
                                            BytesRequired + sizeof(WCHAR));

    if (LinkTarget.Buffer == NULL)
    {
        SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
            FORMAT_DWORD " failed " FORMAT_DWORD "\n",
            BytesRequired, GetLastError());

        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    LinkTarget.Length = (USHORT) BytesRequired;
    LinkTarget.MaximumLength = (USHORT) (BytesRequired + sizeof(WCHAR));
    Status = NtQuerySymbolicLinkObject(Handle, &LinkTarget, &BytesRequired);

    if (!NT_SUCCESS(Status))
    {
        //
        // This should never happen
        //
        ASSERT(FALSE);
        dwError = ERROR_INVALID_ENVIRONMENT;
        goto ErrorExit;
    }

    PrefixLength = LinkTarget.Length / sizeof(WCHAR);
    if (PathLength > PrefixLength &&
        (_wcsnicmp(LinkTarget.Buffer, FullQualPathName, PrefixLength) == 0)) {

        //
        // Path is in NT form without using \systemroot
        // Convert to \SystemRoot format
        //

        *RelativePathName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) (PathLength - PrefixLength + NTSystemRootLength + 1)
            * sizeof(WCHAR));

        if (*RelativePathName == NULL)
        {
            SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
                FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                (PathLength - PrefixLength + NTSystemRootLength + 1) *
                sizeof(WCHAR), GetLastError());

            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy(*RelativePathName, SC_NT_SYSTEM_ROOT);
        // Skip the \ between \SystemRoot and the relative name
        wcscat(*RelativePathName, FullQualPathName + PrefixLength + 1);

        dwError = NO_ERROR;
        goto CleanExit;
    }

    //
    // If we get this far, the imagepath is not relative to the systemroot.
    //
    dwError = ERROR_INVALID_PARAMETER;

ErrorExit:

    //
    // Return an error and a NULL pointer.
    //

    *RelativePathName = NULL;

CleanExit:

    if (Handle)
    {
        NtClose(Handle);
    }

    LocalFree(LinkTarget.Buffer);
    RtlFreeUnicodeString(&NewPrefix);
    LocalFree(Prefix);

    return dwError;
}


BOOLEAN
ScIsArcName(
    LPWSTR              PathName
    )

/*++

Routine Description:

    This function takes a driver's path name and determines if it is an
    ARC style name.  This is done by trying to open the file with \Arcname
    prepended.  There are symbolic links of this form for every valid arcname.

Arguments:

    PathName - The image path

Return Value:

    TRUE - If it is an arcname
    FALSE - If it's not an arcname

--*/
{

#define ARC_PREFIX L"\\Arcname"

   OBJECT_ATTRIBUTES ObjectAttributes;
   HANDLE Handle;
   IO_STATUS_BLOCK IoStatusBlock;
   UNICODE_STRING FileName;
   NTSTATUS Status;
   LPWSTR NewString;
   UINT BufferSize;

   //
   // Allocate the buffer for the composite string
   //

   BufferSize = ((DWORD) wcslen(PathName)
                     + (DWORD) wcslen(ARC_PREFIX) + 1) * sizeof(WCHAR);

   NewString = (LPWSTR) LocalAlloc(LMEM_ZEROINIT, BufferSize);

   if (NewString == NULL)
   {
       SC_LOG2(ERROR, "ScIsArcName: LocalAlloc of numChar= "
           FORMAT_DWORD " failed " FORMAT_DWORD "\n", BufferSize, GetLastError());

       return FALSE;
   }

   //
   // Create the composite string
   //
   wcscpy(NewString, ARC_PREFIX);
   wcscat(NewString, PathName);
   RtlInitUnicodeString(&FileName, NewString);

   //
   // Try to open it
   //
   InitializeObjectAttributes(
                   &ObjectAttributes,
                   &FileName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL);

   Status = NtOpenFile(&Handle,
                       FILE_GENERIC_READ,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       FILE_SHARE_READ,
                       FILE_SYNCHRONOUS_IO_NONALERT);


   LocalFree(NewString);

   //
   // If you could open it, it's an arcname
   //
   if (NT_SUCCESS(Status))
   {
       //
       // Close it, we just need the status
       //
       NtClose(Handle);

       return TRUE;
   }
   else
   {
       return FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\bootcfg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bootcfg.h

Abstract:

    Contains function prototypes for external functions in bootcfg.c

Author:

    Dan Lafferty (danl)     23-Apr-1991

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

    23-Apr-1991     danl
        created

--*/

#ifndef _BOOTCFG_INCLUDED
#define _BOOTCFG_INCLUDED

#include <winreg.h>

    extern  DWORD   ScGlobalLastKnownGood;

//
// The following are bit masks that are use to qualify our
// running with the Last Known Good configuration.
//  RUNNING_LKG     This flag is set anytime we are running LKG
//  REVERTED_TO_LKG This flag is only set if we are running LKG because
//                  of a failure.  (ie.  This flag is not set on the
//                  first boot when CURRENT=LKG).
//  AUTO_START_DONE This flag is set when the service controller is done
//                  auto-starting services.  This flag is protected by
//                  the ScBootConfigCriticalSection.
//  ACCEPT_DEFERRED This flag is set when the current configuration has
//                  been accepted as the LastKnownGood configuration.  This
//                  flag is protected by the ScBootConfigCriticalSection.
//
#define RUNNING_LKG     0x00000001
#define REVERTED_TO_LKG 0x00000002
#define AUTO_START_DONE 0x00000004
#define ACCEPT_DEFERRED 0x00000008

BOOL
ScCheckLastKnownGood(
    VOID
    );

DWORD
ScRevertToLastKnownGood(
    VOID
    );

VOID
ScDeleteRegServiceEntry(
    LPWSTR  ServiceName
    );

VOID
ScRunAcceptBootPgm(
    VOID
    );

#endif // #ifndef _BOOTCFG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\crash.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    crash.cxx

Abstract:

    Contains code concerned with recovery actions that are taken when
    a service crashes.  This file contains the following functions:
        ScQueueRecoveryAction
        CCrashRecord::IncrementCount
        CRestartContext::Perform
        CRebootMessageContext::Perform
        CRebootContext::Perform
        CRunCommandContext::Perform

Author:

    Anirudh Sahni (anirudhs)    02-Dec-1996

Environment:

    User Mode -Win32

Revision History:

    22-Oct-1998     jschwart
        Convert SCM to use NT thread pool APIs

    02-Dec-1996     AnirudhS
        Created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <lmcons.h>     // needed for other lm headers
#include <lmerr.h>      // NERR_Success
#include <lmshare.h>    // NetSessionEnum
#include <lmmsg.h>      // NetMessageBufferSend
#include <lmapibuf.h>   // NetApiBufferFree
#include <valid.h>      // ACTION_TYPE_INVALID
#include <svcslib.h>    // CWorkItemContext
#include "smartp.h"     // CHeapPtr
#include "scconfig.h"   // ScReadFailureActions, etc.
#include "depend.h"     // ScStartServiceAndDependencies
#include "account.h"    // ScLogonService
#include "scseclib.h"   // ScCreateAndSetSD
#include "start.h"      // ScAllowInteractiveServices, ScInitStartupInfo
#include "resource.h"   // IDS_SC_ACTION_BASE

//
// Defines and Typedefs
//
#define FILETIMES_PER_SEC       ((__int64) 10000000)   // (1 second)/(100 ns)
#define LENGTH(array)           (sizeof(array)/sizeof((array)[0]))

//
//  Globals
//


//
// Local Function Prototypes
//
VOID
ScLogRecoveryFailure(
    IN  SC_ACTION_TYPE  ActionType,
    IN  LPCWSTR         ServiceDisplayName,
    IN  DWORD           Error
    );

inline LPWSTR
LocalDup(
    LPCWSTR String
    )
{
    LPWSTR Dup = (LPWSTR) LocalAlloc(0, WCSSIZE(String));
    if (Dup != NULL)
    {
        wcscpy(Dup, String);
    }
    return Dup;
}

//
// Callback context for restarting a service
//
class CRestartContext : public CWorkItemContext
{
                DECLARE_CWorkItemContext
public:
                CRestartContext(
                    IN LPSERVICE_RECORD ServiceRecord
                    ) :
                        _ServiceRecord(ServiceRecord)
                        {
                            ServiceRecord->UseCount++;
                            SC_LOG2(USECOUNT, "CRestartContext: %ws increment "
                                    "USECOUNT=%lu\n", ServiceRecord->ServiceName,
                                    ServiceRecord->UseCount);
                        }

               ~CRestartContext()
                        {
                            CServiceRecordExclusiveLock RLock;
                            ScDecrementUseCountAndDelete(_ServiceRecord);
                        }

private:
    LPSERVICE_RECORD    _ServiceRecord;
};

//
// Callback context for broadcasting a reboot message
//
class CRebootMessageContext : public CWorkItemContext
{
                DECLARE_CWorkItemContext
public:
                CRebootMessageContext(
                    IN LPWSTR RebootMessage,
                    IN DWORD  Delay,
                    IN LPWSTR DisplayName
                    ) :
                        _RebootMessage(RebootMessage),
                        _Delay(Delay),
                        _DisplayName(LocalDup(DisplayName))
                        { }

               ~CRebootMessageContext()
                        {
                            LocalFree(_RebootMessage);
                        }

private:
    LPWSTR      _RebootMessage;
    DWORD       _Delay;
    LPWSTR      _DisplayName;
};

//
// Callback context for a reboot
// (The service name is used only for logging)
//
class CRebootContext : public CWorkItemContext
{
                DECLARE_CWorkItemContext
public:
                CRebootContext(
                    IN DWORD  ActionDelay,
                    IN LPWSTR DisplayName
                    ) :
                        _Delay(ActionDelay),
                        _DisplayName(DisplayName)
                        { }

               ~CRebootContext()
                        {
                            LocalFree(_DisplayName);
                        }

private:
    DWORD       _Delay;
    LPWSTR      _DisplayName;
};

//
// Callback context for running a recovery command
//
class CRunCommandContext : public CWorkItemContext
{
                DECLARE_CWorkItemContext
public:
                CRunCommandContext(
                    IN LPSERVICE_RECORD ServiceRecord,
                    IN LPWSTR FailureCommand
                    ) :
                        _ServiceRecord(ServiceRecord),
                        _FailureCommand(FailureCommand)
                        {
                            //
                            // The service record is used to get the
                            // account name to run the command in.
                            //
                            ServiceRecord->UseCount++;
                            SC_LOG2(USECOUNT, "CRunCommandContext: %ws increment "
                                    "USECOUNT=%lu\n", ServiceRecord->ServiceName,
                                    ServiceRecord->UseCount);
                        }

               ~CRunCommandContext()
                        {
                            LocalFree(_FailureCommand);
                            CServiceRecordExclusiveLock RLock;
                            ScDecrementUseCountAndDelete(_ServiceRecord);
                        }

private:
    LPSERVICE_RECORD    _ServiceRecord;
    LPWSTR              _FailureCommand;
};



/****************************************************************************/

VOID
ScQueueRecoveryAction(
    IN LPSERVICE_RECORD     ServiceRecord
    )

/*++

Routine Description:


Arguments:


Return Value:

    none.

--*/
{
    SC_ACTION_TYPE  ActionType  = SC_ACTION_NONE;
    DWORD           ActionDelay = 0;
    DWORD           FailNum     = 1;
    NTSTATUS        ntStatus;

    //
    // See if there is any recovery action configured for this service.
    //
    HKEY  Key = NULL;
    {
        DWORD   ResetPeriod = INFINITE;
        LPSERVICE_FAILURE_ACTIONS_WOW64 psfa = NULL;

        DWORD Error = ScOpenServiceConfigKey(
                            ServiceRecord->ServiceName,
                            KEY_READ,
                            FALSE,              // don't create if missing
                            &Key
                            );

        if (Error == ERROR_SUCCESS)
        {
            Error = ScReadFailureActions(Key, &psfa);
        }

        if (Error != ERROR_SUCCESS)
        {
            SC_LOG(ERROR, "Couldn't read service's failure actions, %lu\n", Error);
        }
        else if (psfa != NULL && psfa->cActions > 0)
        {
            ResetPeriod = psfa->dwResetPeriod;
        }

        //
        // Allocate a crash record for the service.
        // Increment the service's crash count, subject to the reset period
        // we just read from the registry (INFINITE if we read none).
        //
        if (ServiceRecord->CrashRecord == NULL)
        {
            ServiceRecord->CrashRecord = new CCrashRecord;
        }

        if (ServiceRecord->CrashRecord == NULL)
        {
            SC_LOG0(ERROR, "Couldn't allocate service's crash record\n");
            //
            // NOTE: We still continue, taking the failure count to be 1.
            // (The crash record is used only in the "else" clause.)
            //
        }
        else
        {
            FailNum = ServiceRecord->CrashRecord->IncrementCount(ResetPeriod);
        }

        //
        // Figure out which recovery action we're going to take.
        //
        if (psfa != NULL && psfa->cActions > 0)
        {
            SC_ACTION * lpsaActions = (SC_ACTION *) ((LPBYTE) psfa + psfa->dwsaActionsOffset);
            DWORD i                 = min(FailNum, psfa->cActions);

            ActionType  = lpsaActions[i - 1].Type;
            ActionDelay = lpsaActions[i - 1].Delay;

            if (ACTION_TYPE_INVALID(ActionType))
            {
                SC_LOG(ERROR, "Service has invalid action type %lu\n", ActionType);
                ActionType = SC_ACTION_NONE;
            }
        }

        LocalFree(psfa);
    }

    //
    // Log an event about this service failing, and about the proposed
    // recovery action.
    //
    
    if (ActionType != SC_ACTION_NONE)
    {
        WCHAR wszActionString[50];
        if (!LoadString(GetModuleHandle(NULL),
                        IDS_SC_ACTION_BASE + ActionType,
                        wszActionString,
                        LENGTH(wszActionString)))
        {
            SC_LOG(ERROR, "LoadString failed %lu\n", GetLastError());
            wszActionString[0] = L'\0';
        }

        SC_LOG2(ERROR, "The following recovery action will be taken in %d ms: %ws.\n",
                    ActionDelay, wszActionString);

        ScLogEvent(NEVENT_SERVICE_CRASH,
                   ServiceRecord->DisplayName,
                   FailNum,
                   ActionDelay,
                   ActionType,
                   wszActionString);
    }
    else
    {
        ScLogEvent(NEVENT_SERVICE_CRASH_NO_ACTION,
                   ServiceRecord->DisplayName,
                   FailNum);
    }

    //
    // Queue a work item that will actually carry out the action after the
    // delay has elapsed.
    //
    switch (ActionType)
    {
    case SC_ACTION_NONE:
        break;

    case SC_ACTION_RESTART:
        {
            CRestartContext * pCtx = new CRestartContext(ServiceRecord);
            if (pCtx == NULL)
            {
                SC_LOG0(ERROR, "Couldn't allocate restart context\n");
                break;
            }

            ntStatus = pCtx->AddDelayedWorkItem(ActionDelay,
                                                WT_EXECUTEONLYONCE);

            if (!NT_SUCCESS(ntStatus))
            {
                SC_LOG(ERROR, "Couldn't add restart work item 0x%x\n", ntStatus);
                delete pCtx;
            }

            break;
        }

    case SC_ACTION_REBOOT:
        {
            //
            // Get the reboot message for the service, if any
            //
            LPWSTR RebootMessage = NULL;
            ScReadRebootMessage(Key, &RebootMessage);
            if (RebootMessage != NULL)
            {
                //
                // Broadcast the message to all users.  Do this in a separate
                // thread so that we can release our exclusive lock on the
                // service database quickly.
                //
                CRebootMessageContext * pCtx = new CRebootMessageContext(
                                                    RebootMessage,
                                                    ActionDelay,
                                                    ServiceRecord->DisplayName
                                                    );
                if (pCtx == NULL)
                {
                    SC_LOG0(ERROR, "Couldn't allocate restart context\n");
                    LocalFree(RebootMessage);
                    break;
                }

                ntStatus = pCtx->AddWorkItem(WT_EXECUTEONLYONCE);

                if (!NT_SUCCESS(ntStatus))
                {
                    SC_LOG(ERROR, "Couldn't add restart work item 0x%x\n", ntStatus);
                    delete pCtx;
                }
            }
            else
            {
                //
                // Queue a work item to perform the reboot after the delay has
                // elapsed.
                // (CODEWORK Share this code with CRebootMessageContext::Perform)
                //
                LPWSTR DisplayNameCopy = LocalDup(ServiceRecord->DisplayName);
                CRebootContext * pCtx = new CRebootContext(
                                             ActionDelay,
                                             DisplayNameCopy
                                             );
                if (pCtx == NULL)
                {
                    SC_LOG0(ERROR, "Couldn't allocate reboot context\n");
                    LocalFree(DisplayNameCopy);
                }
                else
                {
                    ntStatus = pCtx->AddWorkItem(WT_EXECUTEONLYONCE);

                    if (!NT_SUCCESS(ntStatus))
                    {
                        SC_LOG(ERROR, "Couldn't add reboot work item 0x%x\n", ntStatus);
                        delete pCtx;
                    }
                }
            }
        }

        break;

    case SC_ACTION_RUN_COMMAND:
        {
            //
            // Get the failure command for the service, if any
            //
            CHeapPtr<LPWSTR> FailureCommand;
            ScReadFailureCommand(Key, &FailureCommand);
            if (FailureCommand == NULL)
            {
                SC_LOG0(ERROR, "Asked to run a failure command, but found "
                               "none for this service\n");
                ScLogRecoveryFailure(
                        SC_ACTION_RUN_COMMAND,
                        ServiceRecord->DisplayName,
                        ERROR_NO_RECOVERY_PROGRAM
                        );
                break;
            }

            //
            // Replace %1% in the failure command with the failure count.
            // (FormatMessage is *useless* for this purpose because it AV's
            // if the failure command contains a %2, %3 etc.!)
            //
            UNICODE_STRING Formatted;
            {
                UNICODE_STRING Unformatted;
                RtlInitUnicodeString(&Unformatted, FailureCommand);

                Formatted.Length = 0;
                Formatted.MaximumLength = Unformatted.MaximumLength + 200;
                Formatted.Buffer =
                            (LPWSTR) LocalAlloc(0, Formatted.MaximumLength);
                if (Formatted.Buffer == NULL)
                {
                    SC_LOG(ERROR, "Couldn't allocate formatted string, %lu\n", GetLastError());
                    break;
                }

                WCHAR Environment[30];
                wsprintf(Environment, L"1=%lu%c", FailNum, L'\0');

                NTSTATUS ntstatus = RtlExpandEnvironmentStrings_U(
                                        Environment,
                                        &Unformatted,
                                        &Formatted,
                                        NULL);

                if (!NT_SUCCESS(ntstatus))
                {
                    SC_LOG(ERROR, "RtlExpandEnvironmentStrings_U failed %#lx\n", ntstatus);
                    wcscpy(Formatted.Buffer, FailureCommand);
                }
            }

            CRunCommandContext * pCtx =
                new CRunCommandContext(ServiceRecord, Formatted.Buffer);
            if (pCtx == NULL)
            {
                SC_LOG0(ERROR, "Couldn't allocate RunCommand context\n");
                LocalFree(Formatted.Buffer);
                break;
            }

            ntStatus = pCtx->AddDelayedWorkItem(ActionDelay,
                                                WT_EXECUTEONLYONCE);

            if (!NT_SUCCESS(ntStatus))
            {
                SC_LOG(ERROR, "Couldn't add RunCommand work item 0x%x\n", ntStatus);
                delete pCtx;
            }
        }
        break;

    default:
        SC_ASSERT(0);
    }

    if (Key != NULL)
    {
        ScRegCloseKey(Key);
    }
}



DWORD
CCrashRecord::IncrementCount(
    DWORD       ResetSeconds
    )
/*++

Routine Description:

    Increments a service's crash count.

Arguments:

    ResetSeconds - Length, in seconds, of a period of no crashes after which
        the crash count should be reset to zero.

Return Value:

    The service's new crash count.

--*/
{
    __int64 SecondLastCrashTime = _LastCrashTime;
    GetSystemTimeAsFileTime((FILETIME *) &_LastCrashTime);

    if (ResetSeconds == INFINITE ||
        SecondLastCrashTime + ResetSeconds * FILETIMES_PER_SEC > _LastCrashTime)
    {
        _Count++;
    }
    else
    {
        SC_LOG(CONFIG_API, "More than %lu seconds have elapsed since last "
                           "crash, resetting crash count.\n",
                           ResetSeconds);
        _Count = 1;
    }

    SC_LOG(CONFIG_API, "Service's crash count is now %lu\n", _Count);
    return _Count;
}



VOID
CRestartContext::Perform(
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

--*/
{
    //
    // Make sure we were called because of a timeout
    //
    SC_ASSERT(fWaitStatus == TRUE);

    SC_LOG(CONFIG_API, "Restarting %ws service...\n", _ServiceRecord->ServiceName);

    RemoveDelayedWorkItem();

    //
    // CODEWORK  Allow arguments to the service.
    //
    DWORD status = ScStartServiceAndDependencies(_ServiceRecord, 0, NULL, FALSE);

    if (status == NO_ERROR)
    {
        status = _ServiceRecord->StartError;
        SC_LOG(CONFIG_API, "ScStartServiceAndDependencies succeeded, StartError = %lu\n",
               status);
    }
    else
    {
        SC_LOG(CONFIG_API, "ScStartServiceAndDependencies failed, %lu\n", status);
        //
        // Should we treat ERROR_SERVICE_ALREADY_RUNNING as a success?
        // No, because it could alert the administrator to a less-than-
        // optimal system configuration wherein something else is
        // restarting the service.
        //
        ScLogRecoveryFailure(
                SC_ACTION_RESTART,
                _ServiceRecord->DisplayName,
                status
                );
    }

    delete this;
}



VOID
CRebootMessageContext::Perform(
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

--*/
{
    //
    // Broadcast the reboot message to all users
    //
    SESSION_INFO_0 * Buffer = NULL;
    DWORD    EntriesRead = 0, TotalEntries = 0;
    NTSTATUS ntStatus;

    NET_API_STATUS Status = NetSessionEnum(
        NULL,           // servername 	
        NULL,           // UncClientName 	
        NULL,           // username 	
        0,              // level 	
        (LPBYTE *) &Buffer,
        0xFFFFFFFF,     // prefmaxlen 	
        &EntriesRead,
        &TotalEntries,
        NULL            // resume_handle 	
        );

    if (EntriesRead > 0)
    {
        SC_ASSERT(EntriesRead == TotalEntries);
        SC_ASSERT(Status == NERR_Success);
        WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD nSize = LENGTH(ComputerName);
        if (!GetComputerName(ComputerName, &nSize))
        {
            SC_LOG(ERROR, "GetComputerName failed! %lu\n", GetLastError());
        }
        else
        {
            DWORD MsgLen = (DWORD) WCSSIZE(_RebootMessage);
            for (DWORD i = 0; i < EntriesRead; i++)
            {
                Status = NetMessageBufferSend(
                    NULL,                   // servername
                    Buffer[i].sesi0_cname,  // msgname
                    ComputerName,           // fromname
                    (LPBYTE) _RebootMessage,// buf
                    MsgLen                  // buflen	
                    );	
                if (Status != NERR_Success)
                {
                    SC_LOG2(ERROR, "NetMessageBufferSend to %ws failed %lu\n",
                                   Buffer[i].sesi0_cname, Status);
                }
            }
        }
    }
    else if (Status != NERR_Success)
    {
        SC_LOG(ERROR, "NetSessionEnum failed %lu\n", Status);
    }

    if (Buffer != NULL)
    {
        NetApiBufferFree(Buffer);
    }

    //
    // Queue a work item to perform the reboot after the delay has elapsed.
    // Note: We're counting the delay from the time that the broadcast finished.
    //
    CRebootContext * pCtx = new CRebootContext(_Delay, _DisplayName);
    if (pCtx == NULL)
    {
        SC_LOG0(ERROR, "Couldn't allocate reboot context\n");
    }
    else
    {
        _DisplayName = NULL;    // pCtx will free it

        ntStatus = pCtx->AddWorkItem(WT_EXECUTEONLYONCE);

        if (!NT_SUCCESS(ntStatus))
        {
            SC_LOG(ERROR, "Couldn't add reboot work item 0x%x\n", ntStatus);
            delete pCtx;
        }
    }

    delete this;
}



VOID
CRebootContext::Perform(
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

--*/
{
    SC_LOG0(CONFIG_API, "Rebooting machine...\n");
    // Write an event log entry?

    //
    // Enable our shutdown privilege.  Since we are shutting down, don't
    // bother doing it for only the current thread and don't bother
    // disabling it afterwards.
    //
    BOOLEAN WasEnabled;
    NTSTATUS Status = RtlAdjustPrivilege(
                            SE_SHUTDOWN_PRIVILEGE,
                            TRUE,           // enable
                            FALSE,          // this thread only? - No
                            &WasEnabled);

    if (!NT_SUCCESS(Status))
    {
        SC_LOG(ERROR, "RtlAdjustPrivilege failed! %#lx\n", Status);
        SC_ASSERT(0);
    }
    else
    {
        WCHAR   wszShutdownText[128];
        WCHAR   wszPrintableText[128 + MAX_SERVICE_NAME_LENGTH];

        if (LoadString(GetModuleHandle(NULL),
                       IDS_SC_REBOOT_MESSAGE,
                       wszShutdownText,
                       LENGTH(wszShutdownText)))
        {
            wsprintf(wszPrintableText, wszShutdownText, _DisplayName);
        }
        else
        {
            //
            // If LoadString failed, it probably means the buffer
            // is too small to hold the localized string
            //
            SC_LOG(ERROR, "LoadString failed! %lu\n", GetLastError());
            SC_ASSERT(FALSE);

            wszShutdownText[0] = L'\0';
        }
                          

        if (!InitiateSystemShutdown(NULL,                // machine name
                                    wszPrintableText,    // reboot message
                                    _Delay / 1000,       // timeout in seconds
                                    TRUE,                // force apps closed
                                    TRUE))               // reboot
        {
            DWORD  dwError = GetLastError();

            //
            // If two services fail simultaneously and both are configured
            // to reboot the machine, InitiateSystemShutdown will fail all
            // calls past the first with ERROR_SHUTDOWN_IN_PROGRESS.  We
            // don't want to log an event in this case.
            //
            if (dwError != ERROR_SHUTDOWN_IN_PROGRESS) {

                SC_LOG(ERROR, "InitiateSystemShutdown failed! %lu\n", dwError);
                ScLogRecoveryFailure(
                        SC_ACTION_REBOOT,
                        _DisplayName,
                        dwError
                        );
            }
        }
    }

    delete this;
}



VOID
CRunCommandContext::Perform(
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

    CODEWORK Share this code with ScLogonAndStartImage

--*/
{
    //
    // Make sure we were called because of a timeout
    //
    SC_ASSERT(fWaitStatus == TRUE);

    DWORD status = NO_ERROR;

    HANDLE Token = NULL;
    PSID   ServiceSid = NULL;       // SID is returned only if not LocalSystem
    LPWSTR AccountName = NULL;
    SECURITY_ATTRIBUTES SaProcess;  // Process security info (used only if not LocalSystem)
    STARTUPINFOW StartupInfo;
    PROCESS_INFORMATION ProcessInfo;

    RemoveDelayedWorkItem();

    //
    // Get the Account Name for the service.  A NULL Account Name means the
    // service is configured to run in the LocalSystem account.
    //
    status = ScLookupServiceAccount(
                _ServiceRecord->ServiceName,
                &AccountName
                );

    // We only need to log on if it's not the LocalSystem account
    if (AccountName != NULL)
    {
        //
        // CODEWORK:  Keep track of recovery EXEs spawned so we can
        //            load/unload the user profile for the process.
        //
        status = ScLogonService(
                    _ServiceRecord->ServiceName,
                    AccountName,
                    &Token,
                    NULL,
                    &ServiceSid
                    );

        if (status != NO_ERROR)
        {
            SC_LOG(ERROR, "CRunCommandContext: ScLogonService failed, %lu\n", status);
            goto Clean0;
        }

        SaProcess.nLength = sizeof(SECURITY_ATTRIBUTES);
        SaProcess.bInheritHandle = FALSE;

        SC_ACE_DATA AceData[] =
            {
                {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                       PROCESS_ALL_ACCESS,           &ServiceSid},

                {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                       PROCESS_SET_INFORMATION |
                           PROCESS_TERMINATE |
                           SYNCHRONIZE,              &LocalSystemSid}
            };

        NTSTATUS ntstatus = ScCreateAndSetSD(
                               AceData,                 // AceData
                               LENGTH(AceData),         // AceCount
                               NULL,                    // OwnerSid (optional)
                               NULL,                    // GroupSid (optional)
                               &SaProcess.lpSecurityDescriptor
                                                        // pNewDescriptor
                               );

        LocalFree(ServiceSid);

        if (! NT_SUCCESS(ntstatus))
        {
            SC_LOG(ERROR, "CRunCommandContext: ScCreateAndSetSD failed %#lx\n", ntstatus);
            status = RtlNtStatusToDosError(ntstatus);
            goto Clean1;
        }

        SC_LOG2(CONFIG_API,"CRunCommandContext: about to spawn recovery program in account %ws: %ws\n",
                 AccountName, _FailureCommand);

        //
        // Impersonate the user so we don't give access to
        // EXEs that have been locked down for the account.
        //
        if (!ImpersonateLoggedOnUser(Token))
        {
            status = GetLastError();

            SC_LOG1(ERROR,
                    "ScLogonAndStartImage:  ImpersonateLoggedOnUser failed %d\n",
                    status);

            goto Clean2;
        }


        //
        // Spawn the Image Process
        //

        ScInitStartupInfo(&StartupInfo, FALSE);

        if (!CreateProcessAsUserW(
                 Token,              // logon token
                 NULL,               // lpApplicationName
                 _FailureCommand,    // lpCommandLine
                 &SaProcess,         // process' security attributes
                 NULL,               // first thread's security attributes
                 FALSE,              // whether new process inherits handles
                 CREATE_NEW_CONSOLE, // creation flags
                 NULL,               // environment block
                 NULL,               // current directory
                 &StartupInfo,       // startup info
                 &ProcessInfo        // process info
                 ))
         {
             status = GetLastError();
             SC_LOG(ERROR, "CRunCommandContext: CreateProcessAsUser failed %lu\n", status);
             RevertToSelf();
             goto Clean2;
         }

         RevertToSelf();
    }
    else
    {
       //
       // It's the LocalSystem account
       //

       //
       // If the process is to be interactive, set the appropriate flags.
       //

       BOOL bInteractive = FALSE;

       if (AccountName == NULL &&
          _ServiceRecord->ServiceStatus.dwServiceType & SERVICE_INTERACTIVE_PROCESS)
       {
          bInteractive = ScAllowInteractiveServices();

          if (!bInteractive)
          {
              //
              // Write an event to indicate that an interactive service
              // was started, but the system is configured to not allow
              // services to be interactive.
              //

              ScLogEvent(NEVENT_SERVICE_NOT_INTERACTIVE,
                      _ServiceRecord->DisplayName);
          }
       }

       ScInitStartupInfo(&StartupInfo, bInteractive);

       SC_LOG1(CONFIG_API,"CRunCommandContext: about to spawn recovery program in "
                 "the LocalSystem account: %ws\n", _FailureCommand);

       //
       // Spawn the Image Process
       //

       if (!CreateProcessW(
               NULL,               // lpApplicationName
               _FailureCommand,    // lpCommandLine
               NULL,               // process' security attributes
               NULL,               // first thread's security attributes
               FALSE,              // whether new process inherits handles
               CREATE_NEW_CONSOLE, // creation flags
               NULL,               // environment block
               NULL,               // current directory
               &StartupInfo,       // startup info
               &ProcessInfo        // process info
               ))
       {
           status = GetLastError();
           SC_LOG(ERROR, "CRunCommandContext: CreateProcess failed %lu\n", status);
           goto Clean2;
       }
    }

    SC_LOG0(CONFIG_API, "Recovery program spawned successfully.\n");

    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);

Clean2:
    if (AccountName != NULL)
    {
        RtlDeleteSecurityObject(&SaProcess.lpSecurityDescriptor);
    }

Clean1:
    if (AccountName != NULL)
    {
        CloseHandle(Token);
    }

Clean0:
    if (status != NO_ERROR)
    {
        ScLogRecoveryFailure(
                SC_ACTION_RUN_COMMAND,
                _ServiceRecord->DisplayName,
                status
                );
    }

    delete this;
}



VOID
ScLogRecoveryFailure(
    IN  SC_ACTION_TYPE  ActionType,
    IN  LPCWSTR         ServiceDisplayName,
    IN  DWORD           Error
    )

/*++

Routine Description:

--*/
{
    WCHAR wszActionString[50];
    if (!LoadString(GetModuleHandle(NULL),
                    IDS_SC_ACTION_BASE + ActionType,
                    wszActionString,
                    LENGTH(wszActionString)))
    {
        SC_LOG(ERROR, "LoadString failed %lu\n", GetLastError());
        wszActionString[0] = L'\0';
    }

    ScLogEvent(
            NEVENT_SERVICE_RECOVERY_FAILED,
            ActionType,
            wszActionString,
            (LPWSTR) ServiceDisplayName,
            Error
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\depend.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    depend.cxx

Abstract:

    This module contains routines which handle service start and
    stop dependencies:
        ScInitAutoStart
        ScAutoStartServices
        ScStartServiceAndDependencies
        ScSetServiceStartRequest
        ScMarkGroupStartNow
        RI_ScGetCurrentGroupStateW
        ScStartMarkedServices
        ScHandleServiceFailure
        ScDependenciesStarted
        ScLookForHungServices
        ScHandleBadDependencies
        ScServiceToStartDependOn
        ScNotifyChangeState
        ScDependentsStopped
        ScEnumDependents
        ScFoundDuplicateDependent
        ScInHardwareProfile

Author:

    Rita Wong (ritaw)     03-Apr-1992

Environment:

    Win32

Revision History:

    11-Jun-2000     JSchwart
        Add no-reboot support for machine name change during OOBE
        setup and initial boot
    08-Jan-1997     AnirudhS
        Remove I_ScGetCurrentGroupStateW as it is no longer used.  In
        ScStartServiceAndDependencies, get an exclusive grouplist lock
        once more, instead of a shared one.
    11-Jun-1996     AnirudhS
        During setup/upgrade, don't event-log failure of a service to start
        due to a dependent service not starting.  (The most common case of
        this is a service that runs in a domain account, and hence has an
        implicit dependency on netlogon, which is disabled during setup.)
    03-Nov-1995     AnirudhS
        Don't try to start a service that isn't in the current hardware
        profile.
    30-Oct-1995     AnirudhS
        ScStartMarkedServices: If ScStartService says that a service is
        already running, treat this as a success.
    15-Aug-1995     AnirudhS
        Added I_ScGetCurrentGroupStateW.
        Changed while loops to for loops and if stmts to switch stmts for
        improved readability.
    16-Aug-1994     Danl
        ScLookForHungServices:  If a long waitHint was passed in, the sleep
        time would be set to a huge number (like 4.9 days).  This was
        changed so that if the waitHint is over 100 seconds, then the
        sleep time is limited to 10 seconds, but the number of iterations
        for the polling goes up.
    09-Jun-1994     Danl
        Begin working on making sure NetLogon is started if we are
        going to start a service that runs in an account.  This requires
        making a dependency on NetLogon.
    21-Apr-1992 JohnRo
        Use SC_LOG0(), FORMAT_ equates, etc
    03-Apr-1992     ritaw
        created

--*/

#include "precomp.hxx"
#include <string.h>     // memcpy
#include <stdlib.h>     // wcslen
#include <winerror.h>
#include <lmcons.h>     // NET_API_STATUS
#include <srvann.h>     // I_ScGetCurrentGroupStateW and related definitions
#include <cfgmgr32.h>   // PNP manager functions
#include <pnp.h>        // PNP manager functions, server side
#include <cfgmgrp.h>    // PNP manager functions, server side, internal (PNP_GET_HWPROFFLAGS)
#include <regstr.h>     // CSCONFIGFLAG_ constants
#include <tstr.h>       // WCSSIZE
#include <sclib.h>      // ScCopyStringToBufferW
#include <svcslib.h>    // SetupInProgress
#include <winsvcp.h>    // OOBE setup event names

#include "start.h"      // ScStartService
#include "depend.h"
#include "info.h"       // ScQueryServiceStatus
#include "bootcfg.h"    // ScRevertToLastKnownGood
#include "driver.h"     // ScGetDriverStatus
#include "lockapi.h"    // ScLockDatabase
#include "account.h"    // SC_LOCAL_SYSTEM_USER_NAME
#include "scconfig.h"   // ScRegCloseKey

#define SERVICE_START_TIMEOUT     80000                 // 80 seconds
#define LENGTH(array)   (sizeof(array)/sizeof((array)[0]))

#define GROUP_NOT_STARTED    0x00000000
#define GROUP_ONE_STARTED    0x00000001
#define GROUP_START_FAIL     0x00000002

#define REG_KEY_SETUP_ALLOW_START L"System\\Setup\\AllowStart"

//
// TDI GROUP SPECIAL:  The PNP_TDI group is treated as a subgroup of
// the TDI group for dependency purposes (though not for group start
// ordering purposes).  This is implemented via the following macros.
// A service BELONGS_TO a group either if it is a member of that group,
// or if the group is the TDI group and the service is a member of the
// PNP_TDI group.
// IS_SUBGROUP returns true if Group1 is equal to or a subgroup of Group2.
//
#define IS_SUBGROUP(Group1, Group2)                 \
    ((Group1) == (Group2) ||                        \
     (Group2) == ScGlobalTDIGroup && (Group1) == ScGlobalPNP_TDIGroup)

#define BELONGS_TO(Service, Group)                  \
    IS_SUBGROUP((Service)->MemberOfGroup, (Group))

//-------------------------------------------------------------------//
//                                                                   //
// Static global variables                                           //
//                                                                   //
//-------------------------------------------------------------------//

//
// For notifying us that a service has gone from start-pending state
// to running or stopped state.
//
/* static */ HANDLE ScServiceChangeStateEvent = NULL;

//
// For serializing start requests
//
/* static */ CRITICAL_SECTION ScServiceStartCriticalSection;

//
// For telling internal routines when auto-start is in progress
//
BOOL  ScAutoStartInProgress;

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

VOID
ScSetServiceStartRequest(
    IN  LPSERVICE_RECORD ServiceRecord,
    IN  BOOL DemandStarting
    );

BOOL
ScMarkGroupStartNow(
    IN LPLOAD_ORDER_GROUP Group
    );

DWORD
ScGetCurrentGroupState(
    LPLOAD_ORDER_GROUP Group
    );

DWORD
ScStartMarkedServices(
    IN LPSERVICE_RECORD ServiceToStart OPTIONAL,
    IN DWORD NumArgs,
    IN LPSTRING_PTRSW CmdArgs,
    IN BOOL WaitForAll
    );

VOID
ScHandleServiceFailure(
    IN LPSERVICE_RECORD Service
    );

BOOL
ScDependenciesStarted(
    IN  LPSERVICE_RECORD Service,
    OUT BOOL *IsBadDependencies,
    OUT BOOL *AllStarted,
    OUT BOOL *ExistsBlockedService
    );

BOOL
IsDependOnLaterGroup(
    IN LPLOAD_ORDER_GROUP ServiceGroup,
    IN LPLOAD_ORDER_GROUP DependOnGroup,
    IN DEPEND_TYPE DependType
    );

VOID
ScCleanupStartFailure(
    LPSERVICE_RECORD Service,
    DWORD StartError
    );

VOID
ScLookForHungServices(
    VOID
    );

VOID
ScHandleBadDependencies(
    VOID
    );

BOOL
ScServiceToStartDependOn(
    LPSERVICE_RECORD ServiceToStart OPTIONAL,
    LPSERVICE_RECORD StartPendingService
    );

BOOL
ScFoundDuplicateDependent(
    IN LPWSTR ServiceName,
    IN LPENUM_SERVICE_STATUS_WOW64 EnumBuffer,
    IN LPENUM_SERVICE_STATUS_WOW64 BufferEnd
    );

#ifndef _CAIRO_
VOID
ScCheckNetLogonDepend(
    LPSERVICE_RECORD    ServiceRecord,
    BOOL                DemandStarting
    );
#endif // _CAIRO_


BOOL
ScInitAutoStart(
    VOID
    )
/*++

Routine Description:

    This function creates the event for notifying the service controller
    that one of the automatically started service is running and creates
    the mutex for serializing start requests.

Arguments:

    None.

Return Value:

    TRUE - Event and mutex were created successfully.  FALSE otherwise.

--*/
{
    //
    // Create event which indicates that some service that has been
    // automatically started is now running or stopped.
    //
    if ((ScServiceChangeStateEvent =
             CreateEvent(
                 NULL,                // Event attributes
                 TRUE,                // Event must be manually reset
                 FALSE,               // Initial state not signalled
                 NULL
                 )) == (HANDLE) NULL) {

        return FALSE;
    }

    //
    // Create critical section which is used to serialize start requests:
    // if auto-starting services, and a user tries to demand start
    // a service, auto-starting has to complete before we process the
    // demand start.
    //
    InitializeCriticalSection(&ScServiceStartCriticalSection);

    return TRUE;
}


DWORD
ScAutoStartServices(
    IN OUT   LPSC_RPC_LOCK lpLock
    )
/*++

Routine Description:

    This function automatically starts all services that must be
    auto-started, in group order.

    This routine may not return because we may instigate a reboot to
    revert to last-known-good.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL  fIsOOBE;

    ScAutoStartInProgress = TRUE;

    //
    // Set current request flag of all auto-start services as well as
    // their dependencies
    //

    SetupInProgress(NULL, &fIsOOBE);

    if (fIsOOBE)
    {

#define   NUM_OOBE_SERVICES    2

        DWORD            dwError;
        DWORD            dwTries = 0;
        LPSERVICE_RECORD ServiceRecord = NULL;
        HANDLE           hPnPDone;
        HANDLE           hMachineNameDone;
        LPWSTR           lpServicesForOobe[NUM_OOBE_SERVICES] = { L"PlugPlay", L"AudioSrv" };
        UINT             i;

        SC_LOG0(TRACE,
                "ScAutoStartServices:  Is OOBE -- creating events\n");

        //
        // OOBE setup will wait on this event first.  We set it
        // once PnP is done starting to wake up OOBE setup (which
        // will then prompt the user for the new machine name)
        //
        hPnPDone = CreateEvent(
                        NULL,                 // Event Attributes
                        TRUE,                 // ManualReset
                        FALSE,                // Initial State (not-signaled)
                        SC_OOBE_PNP_DONE);    // Name

        if (!hPnPDone)
        {
            dwError = GetLastError();

            SC_LOG1(ERROR,
                    "ScAutoStartServices:  Creation of SC_OOBE_PNP_DONE event failed %d\n",
                    dwError);

            return dwError;
        }

        //
        // Once the machine name is set, OOBE setup will set this
        // event to tell us to finish auto-starting the services
        //
        hMachineNameDone = CreateEvent(
                                NULL,                         // Event Attributes
                                TRUE,                         // ManualReset
                                FALSE,                        // Initial State (not-signaled)
                                SC_OOBE_MACHINE_NAME_DONE);   // Name


        if (!hMachineNameDone)
        {
            dwError = GetLastError();

            SC_LOG1(ERROR,
                    "ScAutoStartServices:  Creation of SC_OOBE_PNP_DONE event failed %d\n",
                    dwError);

            CloseHandle(hPnPDone);
            return dwError;
        }


        SC_LOG0(TRACE,
                "ScAutoStartServices:  Starting services used by OOBE\n");

        for (i = 0; i < NUM_OOBE_SERVICES; i++)
        {
            //
            // Since a computer name change may require PnP to be running,
            // start it and only it and wait until signalled to start the rest.
            // Grab the service list lock since ScGetNamedServiceRecord uses
            // the FOR_ALL_SERVICES macro, which expects it.  Also start
            // AudioSrv, which is needed for audio for OOBE.
            //

            {
                CServiceListSharedLock LLock;

                dwError = ScGetNamedServiceRecord(lpServicesForOobe[i], &ServiceRecord);
            }

            if (dwError != NO_ERROR)
            {
                //
                // Ignore failure since ServiceRecord will now be NULL so
                // the call below will start all the auto-start services
                // instead of just PnP.  The machine name will be wrong in
                // some of the services until the next reboot, but there's
                // nothing we can do about it at this point.
                //
                SC_LOG2(ERROR,
                        "ScAutoStartServices: OOBE lookup of service %ws failed %d\n",
                        lpServicesForOobe[i],
                        dwError);
            }

            dwError = ScStartServiceAndDependencies(ServiceRecord, 0, NULL, TRUE);

            if (dwError != NO_ERROR)
            {
                //
                // Ignore failure -- it's possible PnP won't need to be
                // up and running (it's only necessary if the OEM setup
                // for the machine was done without a keyboard and PnP
                // is now needed to detect the hardware).  Audio failure
                // is definitely non-fatal.
                //

                SC_LOG2(ERROR,
                        "ScAutoStartServices: OOBE start of %ws failed %d\n",
                        lpServicesForOobe[i],
                        dwError);
            }
        }

        //
        // Drop the database lock since OOBE may invoke server-side PnP
        // installations and setupapi.dll will try to lock the database.
        // In addition, it may invoke 3rd-party class installers and we
        // have no idea what they may try to do with the lock.
        //

        ScUnlockDatabase(lpLock);

        //
        // Let setup proceed
        //

        if (! SetEvent(hPnPDone))
        {
            dwError = GetLastError();
            SC_LOG1(ERROR,
                    "ScAutoStartServices: Failed to set event (hPnPDone) %d\n",
                    dwError);
        }


        //
        // Wait for setup to let us proceed.
        //

        WaitForSingleObject(hMachineNameDone, INFINITE);

        dwError = NO_ERROR;

        //
        // Reacquire the database lock.  Wait 10 minutes at most.
        //

        do
        {
            if (dwError != NO_ERROR)
            {
                Sleep(2000);
            }

            dwError = ScLockDatabase(TRUE, SERVICES_ACTIVE_DATABASEW, lpLock);

            dwTries++;
        }
        while (dwError != NO_ERROR && dwTries != 300);

        CloseHandle(hPnPDone);
        CloseHandle(hMachineNameDone);

        if (dwError != NO_ERROR)
        {
            SC_LOG1(ERROR,
                    "ScAutoStartServices: Failed to reacquire database lock %d\n",
                    dwError);

            return dwError;
        }

#undef NUM_OOBE_SERVICES

    }


    //
    // Start services with start request flag set in group order
    //
    ScStartServiceAndDependencies(NULL, 0, NULL, FALSE);

    ScAutoStartInProgress = FALSE;

    return NO_ERROR;
}


DWORD
ScStartServiceAndDependencies(
    IN LPSERVICE_RECORD ServiceToStart OPTIONAL,
    IN DWORD NumArgs,
    IN LPSTRING_PTRSW CmdArgs,
    IN BOOL fIsOOBE
    )
/*++

Routine Description:

    This function marks a group or a service to be started now before
    calling ScStartMarkedServices to start them.

Arguments:

    ServiceToStart - Service to be started; or, NULL if autostarting
        services.

    NumArgs, CmdArgs - Arguments for the service to be started.

Return Value:

    NO_ERROR if successful; otherwise, the return value from the first
    unsuccessful call to ScStartMarkedServices.

--*/
{
    DWORD status;
    DWORD ApiStatus = NO_ERROR;
    PLOAD_ORDER_GROUP Group;
    SC_RPC_LOCK Lock;
    BOOL    databaseLocked = FALSE;

    //
    // Serialize start requests by allowing auto-starting of groups or
    // demand start of a service one at a time.
    //
    EnterCriticalSection(&ScServiceStartCriticalSection);

    //
    // Grab the SC Manager database lock.
    //
    if (!ScStillInitializing) {
        if ((status = ScLockDatabase(
                          TRUE,                     // called internally
                          SERVICES_ACTIVE_DATABASEW,
                          &Lock
                          )) != NO_ERROR) {

            LeaveCriticalSection(&ScServiceStartCriticalSection);
            return status;
        }
        databaseLocked = TRUE;
    }

    //
    // There is one (highly unlikely) condition in which we might need to
    // modify the group information here: if we call ScStartService and it
    // calls ScDeactivateSR on a service whose update flag is set (its
    // config was changed while it was running).
    // To prevent deadlocks, the grouplist lock is always acquired before
    // the service database lock, if both are needed.  So we get an
    // exclusive lock on the grouplist here.
    //
    {
        CGroupListExclusiveLock GLock;

        //
        // Get a shared lock on the service list as we shall walk it several
        // times.
        //
        CServiceListSharedLock LLock;

        //
        // Get the exclusive database lock so that we can increment the
        // use count of the service being started as well as their dependencies
        // because otherwise they could go away if deleted.
        //
        {
            CServiceRecordExclusiveLock RLock;

            if (ARGUMENT_PRESENT(ServiceToStart)) {

                //
                // Demand starting a service.
                //

                //
                // We can never start a disabled service
                //
                if (ServiceToStart->StartType == SERVICE_DISABLED ||
                    ! ScInHardwareProfile(ServiceToStart->ServiceName, 0)) {
                    ApiStatus = ERROR_SERVICE_DISABLED;
                    goto ReleaseLocks;
                }

                //
                // Cannot start a deleted service.
                //
                if (DELETE_FLAG_IS_SET(ServiceToStart)) {
                    ApiStatus = ERROR_SERVICE_MARKED_FOR_DELETE;
                    goto ReleaseLocks;
                }

                //
                // Get the current state of the service
                //
                if (ServiceToStart->ServiceStatus.dwServiceType & SERVICE_DRIVER) {
                    (void) ScGetDriverStatus(ServiceToStart, NULL);
                }

                if  (ServiceToStart->ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                    ApiStatus = ERROR_SERVICE_ALREADY_RUNNING;
                    goto ReleaseLocks;
                }

                //
                // Set the current-start flag on the service and all of
                // its dependencies.  Also increment their use counts so
                // that we know they won't go away, even when we release
                // the locks temporarily.
                //
                SC_LOG(DEPEND,"Setting start request for %ws and dependencies\n",
                        ServiceToStart->ServiceName);
                SC_LOG(WHY, " Will start %ws because of an explicit start request\n",
                        ServiceToStart->ServiceName);
                ScSetServiceStartRequest(ServiceToStart, TRUE);
            }
            else {

                //
                // Auto-starting services.
                //

                // If we are in GUI mode setup, we only start those auto-start
                // services that are allowed.  Allowed services are listed
                // under HKLM\System\Setup\AllowStart as registry keys.
                // If the subkey with the same name as the service exits,
                // it means we allow it to be autostarted during GUI mode.
                //
                HKEY hkeyAllowStart = NULL;
                BOOL InSetup = SetupInProgress(NULL, NULL);

                if (InSetup)
                {
                    status = ScRegOpenKeyExW(
                                HKEY_LOCAL_MACHINE,
                                REG_KEY_SETUP_ALLOW_START,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                &hkeyAllowStart);

                    if (NO_ERROR != status)
                    {
                        // This is not expected as the registry key is created
                        // by hivesys.inf.  We'll skip checking services in
                        // this case.
                        //
                        hkeyAllowStart = NULL;
                    }
                }

                // Set the CurrentStartRequest flag to TRUE for all services
                // of type AUTO_START that are enabled in this hardware profile,
                // and their dependencies.
                //
                SC_LOG0(DEPEND,"Setting start request for auto-started services and dependencies\n");
                FOR_SERVICES_THAT(Service, Service->StartType == SERVICE_AUTO_START &&
                                           ScInHardwareProfile(Service->ServiceName, 0))
                {
                    BOOL AllowStart = TRUE;

                    if (hkeyAllowStart)
                    {
                        HKEY hkey;

                        ASSERT(InSetup);

                        status = ScRegOpenKeyExW(
                                    hkeyAllowStart,
                                    Service->ServiceName,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ,
                                    &hkey);
                        if (NO_ERROR == status)
                        {
                            // The service name exists and is therefore
                            // allowed to start.  Don't forget to close the
                            // key.
                            ScRegCloseKey(hkey);

                            ASSERT(AllowStart);
                        }
                        else
                        {
                            AllowStart = FALSE;

                            SC_LOG(WHY, " Will NOT start %ws because it's not "
                                    "allowed to run during system setup\n",
                                    Service->ServiceName);
                        }
                    }

                    if (AllowStart)
                    {
                        SC_LOG(WHY, " Will start %ws because it's configured to autostart\n",
                                Service->ServiceName);
                        ScSetServiceStartRequest(Service, FALSE);
                    }
                }

                if (hkeyAllowStart)
                {
                    ScRegCloseKey(hkeyAllowStart);
                }
            }
        }   // Release RLock

        //
        // Always start services in group order.
        //
        for (Group = ScGetOrderGroupList();
             Group != NULL;
             Group = Group->Next)
        {
            //
            // Start each group in load group order
            //
            if (ScMarkGroupStartNow(Group)) {

                SC_LOG(DEPEND,"------ Starting services in group \"%ws\" -----\n", Group->GroupName);
                BOOL WaitForGroup;

                if (ARGUMENT_PRESENT(ServiceToStart) &&
                    ServiceToStart->MemberOfGroup == Group) {

                    //
                    // Don't have to wait for all marked members of the group
                    // to finish starting because the service which is demand
                    // started is polled by the UI.
                    //
                    WaitForGroup = FALSE;
                }
                else {
                    //
                    // Auto-starting (ServiceToStart == NULL) or demand-starting
                    // a service that is not within this group.  Wait for group
                    // all marked members finish starting.
                    //
                    WaitForGroup = TRUE;
                }

                status = ScStartMarkedServices(
                             ServiceToStart,
                             NumArgs,
                             CmdArgs,
                             (WaitForGroup || fIsOOBE)
                             );

                if (status != NO_ERROR && ApiStatus == NO_ERROR) {
                    //
                    // Save first error to be returned
                    //
                    ApiStatus = status;
                }
            }
        }

        //
        // Services that do not belong in any group are considered
        // in a group that starts last.
        //
        if (ScMarkGroupStartNow(NULL)) {

            SC_LOG0(DEPEND,"------ Starting services that aren't in ServiceGroupOrder -----\n");

            //
            // Wait only for auto-start services or for the service(s)
            // we explicitly demand-start during OOBE setup
            //
            status = ScStartMarkedServices(
                         ServiceToStart,
                         NumArgs,
                         CmdArgs,
                         (! ARGUMENT_PRESENT(ServiceToStart)  || fIsOOBE)
                         );

            if (status != NO_ERROR && ApiStatus == NO_ERROR) {
                //
                // Save first error to be returned
                //
                ApiStatus = status;
            }
        }

        SC_LOG(DEPEND,"------ Done %s-starting services -----\n",
                      ARGUMENT_PRESENT(ServiceToStart) ? "demand" : "auto");

        //
        // Clear the CurrentStartRequest flags when done starting service(s).
        //
        {
            CServiceRecordExclusiveLock RLock;

            FOR_SERVICES_THAT(Service, CURRENTSTART_FLAG_IS_SET(Service))
            {
                CLEAR_CURRENTSTART_FLAG(Service);

                ScDecrementUseCountAndDelete(Service);
            }
        }
    }   // Release LLock and GLock

ReleaseLocks:

    //
    // Release the SC Manager database lock.
    //
    if (databaseLocked) {
        ScUnlockDatabase(&Lock);
    }

    LeaveCriticalSection(&ScServiceStartCriticalSection);

    return ApiStatus;
}


VOID
ScSetServiceStartRequest(
    IN  LPSERVICE_RECORD ServiceRecord,
    IN  BOOL DemandStarting
    )
/*++

Routine Description:

    This function sets the CurrentStartRequest flag of the specified service
    to TRUE and recursively sets the flag of all the services this
    service depends on.  It also initializes the StartState and StartError
    of the services that are about to be started.

Arguments:

    ServiceRecord - Supplies a pointer to the service record of service
        to be started.

    DemandStarting - Supplies a flag that is set to TRUE if we are demand-
        starting a service, FALSE if we are auto-starting services.

Return Value:

    None.

Note:
    This function expects the caller to have held the exclusive service
    database lock.  This function is called by ScStartServiceAndDependencies.

--*/
{
    SC_ASSERT(ScServiceListLock.Have());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (CURRENTSTART_FLAG_IS_SET(ServiceRecord)) {
        return;
    }

    //
    // Set the CurrentStartRequest to TRUE
    //
    SET_CURRENTSTART_FLAG(ServiceRecord);

    //
    // Update the StartState and StartError
    //
    if (ServiceRecord->StartType == SERVICE_DISABLED ||
        ! ScInHardwareProfile(ServiceRecord->ServiceName, 0)) {

        ServiceRecord->StartState = SC_START_FAIL;
        ServiceRecord->StartError = ERROR_SERVICE_DISABLED;

    }
    else if (DELETE_FLAG_IS_SET(ServiceRecord)) {

        ServiceRecord->StartState = SC_START_FAIL;
        ServiceRecord->StartError = ERROR_SERVICE_MARKED_FOR_DELETE;
    }
    else {

        if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER) {
            (void) ScGetDriverStatus(ServiceRecord, NULL);
        }

        switch (ServiceRecord->ServiceStatus.dwCurrentState) {

            case SERVICE_STOPPED:

                if (DemandStarting) {
                    //
                    // Demand starting a service.  We want to retry
                    // eventhough we have failed once before.
                    //
                    ServiceRecord->StartState = SC_NEVER_STARTED;
                }
                else {
                    //
                    // Auto-starting bunch of services at boot.  If
                    // the service was ever started before and failed,
                    // we don't want to start it again.
                    //
                    if (ServiceRecord->ServiceStatus.dwWin32ExitCode !=
                        ERROR_SERVICE_NEVER_STARTED) {
                        ServiceRecord->StartState = SC_START_FAIL;
                    }
                    else {
                        ServiceRecord->StartState = SC_NEVER_STARTED;
                    }
                }
                break;

            case SERVICE_START_PENDING:
                ServiceRecord->StartState = SC_START_PENDING;
                break;

            case SERVICE_STOP_PENDING:
            case SERVICE_PAUSED:
            case SERVICE_CONTINUE_PENDING:
            case SERVICE_PAUSE_PENDING:
            case SERVICE_RUNNING:
                ServiceRecord->StartState = SC_START_SUCCESS;
                break;

            default:
                SC_LOG1(
                    ERROR,
                    "ScSetServiceStartRequest: Unexpected dwCurrentState %0lx\n",
                    ServiceRecord->ServiceStatus.dwCurrentState
                    );

                SC_ASSERT(FALSE);
                ServiceRecord->StartState = SC_START_FAIL;
                break;
        }
    }

    //
    // Increment the reference count so that the dependency service
    // never goes away while we are in the process of starting them.
    //
    ServiceRecord->UseCount++;

    SC_LOG2(USECOUNT, "ScSetServiceStartRequest: " FORMAT_LPWSTR
            " increment USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);

    SC_LOG2(DEPEND_DUMP, "CSR=TRUE for "
            FORMAT_LPWSTR " USECOUNT=%lu\n", ServiceRecord->ServiceName,
            ServiceRecord->UseCount);

    //
    // For each of this service's dependencies
    //
    for (LPDEPEND_RECORD Depend = ServiceRecord->StartDepend;
         Depend != NULL;
         Depend = Depend->Next)
    {
        if (Depend->DependType == TypeDependOnService) {

            if (CURRENTSTART_FLAG_IS_SET(Depend->DependService)) {

                //
                // CurrentStartRequest of a dependency service is already
                // set to TRUE.  Just go on to next dependency.
                //
                SC_LOG2(WHY, " (Will start %ws because %ws depends on it too)\n",
                        Depend->DependService->ServiceName, ServiceRecord->ServiceName);
                SC_LOG2(DEPEND_DUMP, "DependService " FORMAT_LPWSTR
                        " CSR=TRUE already, USECOUNT=%lu\n",
                        Depend->DependService->ServiceName,
                        Depend->DependService->UseCount);
            }
            else {

                SC_LOG2(WHY, " Will start %ws because %ws depends on it\n",
                        Depend->DependService->ServiceName, ServiceRecord->ServiceName);
                ScSetServiceStartRequest(Depend->DependService, DemandStarting);
            }

        }
        else if (Depend->DependType == TypeDependOnGroup) {

            //
            // This service has a dependency on a group.
            // For each service in that group
            //
            FOR_SERVICES_THAT(Service, BELONGS_TO(Service, Depend->DependGroup))
            {
                if (CURRENTSTART_FLAG_IS_SET(Service)) {

                    //
                    // CurrentStartRequest of a dependency service is
                    // already set to TRUE.  Just go on to next dependency.
                    //
                    SC_LOG3(WHY, " (Will start %ws because %ws depends on its group %ws too)\n",
                            Service->ServiceName, ServiceRecord->ServiceName,
                            Depend->DependGroup->GroupName);
                    SC_LOG3(DEPEND_DUMP, "DependGroup " FORMAT_LPWSTR
                            ", Service " FORMAT_LPWSTR
                            " CSR=TRUE already, USECOUNT=%lu\n",
                            Depend->DependGroup->GroupName,
                            Service->ServiceName, Service->UseCount);
                }
                else {

                    SC_LOG3(WHY, " Will start %ws because %ws depends on its group %ws\n",
                            Service->ServiceName, ServiceRecord->ServiceName,
                            Depend->DependGroup->GroupName);
                    ScSetServiceStartRequest(
                        Service,
                        DemandStarting
                        );
                }
            }
        }
    }

#ifndef _CAIRO_
    //
    // We have now gone through all the dependencies that are listed.  Now
    // Determine if this service needs to depend on NetLogon.  If the service
    // runs in an account, it may require NetLogon.
    //
    ScCheckNetLogonDepend(ServiceRecord,DemandStarting);
#endif // _CAIRO_
}


BOOL
ScMarkGroupStartNow(
    IN LPLOAD_ORDER_GROUP Group
    )
/*++

Routine Description:

    This function go through all services that belong in the specified
    group and mark the services that have the CurrentStartRequest flag
    set to be started immediately.

Arguments:

    Group - Supplies a pointer to the load order group to mark for
        start.

Return Value:

    Returns TRUE if at least one member of the group is marked
        START_NOW or is START_PENDING.  FALSE otherwise.  This flag
        is to indicate whether ScStartMarkedServices should be called
        to handle starting a group.

--*/
{
    BOOL ReturnFlag = FALSE;

    //
    // Mark all the CurrentStartRequest (which includes all auto-start)
    // services to be started now
    //

    // A service is marked START_NOW if it is a member of the specified
    // group.  If the specified group is NULL, mark all services that
    // do not belong to any group as well as services that belong to
    // standalone groups.
    //
    FOR_SERVICES_THAT(Service,

        ((Service->MemberOfGroup == Group) ||
         (Group == NULL && (Service->MemberOfGroup != NULL) &&
                           (Service->MemberOfGroup->RefCount != MAXULONG) ))

        &&

        CURRENTSTART_FLAG_IS_SET(Service) )
    {
        if (Service->StartState == SC_NEVER_STARTED)
        {
            Service->StartState = SC_START_NOW;
            Service->StartError = NO_ERROR;
        }

        if (Service->StartState == SC_START_NOW ||
            Service->StartState == SC_START_PENDING)
        {
            ReturnFlag = TRUE;
        }
    }

    return ReturnFlag;
}


DWORD
RI_ScGetCurrentGroupStateW(
    IN  SC_RPC_HANDLE           hSCManager,
    IN  LPWSTR                  pszGroupName,
    OUT LPDWORD                 pdwCurrentState
    )

/*++

Routine Description:

    This is obsolete, but the RPC entry point still exists.

--*/
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
ScGetCurrentGroupState(
    LPLOAD_ORDER_GROUP Group
    )
{
    BOOL OneStarted = FALSE;

    FOR_SERVICES_THAT(Service, BELONGS_TO(Service, Group))
    {
        switch (Service->StartState)
        {
            case SC_NEVER_STARTED:
                //
                // Ignore services that are disabled or marked for
                // deletion.
                // (This check is really needed only when this function is
                // called from RI_ScGetCurrentGroupState.  When called
                // from ScDependenciesStarted, such services will already
                // have had their StartState set to SC_START_FAIL.)
                //
                if (Service->StartType == SERVICE_DISABLED ||
                    DELETE_FLAG_IS_SET(Service) ||
                    ! ScInHardwareProfile(Service->ServiceName, 0))
                {
                    continue;
                }
                //
                // else fall through
                //
            case SC_START_NOW:
            case SC_START_PENDING:

                SC_LOG2(DEPEND, "Group " FORMAT_LPWSTR " NOT started "
                        "because of Service " FORMAT_LPWSTR "\n",
                        Group->GroupName, Service->ServiceName);

                return GROUP_NOT_STARTED;

            case SC_START_SUCCESS:

                OneStarted = TRUE;
                break; // out of switch, not out of loop
        }
    }

    if (OneStarted)
    {
        SC_LOG1(DEPEND, "Group " FORMAT_LPWSTR " ONE started\n",
                Group->GroupName);

        return GROUP_ONE_STARTED;
    }
    else
    {
        SC_LOG1(DEPEND, "Group " FORMAT_LPWSTR " FAILED to start\n",
                Group->GroupName);

        return GROUP_START_FAIL;
    }
}


DWORD
ScStartMarkedServices(
    IN LPSERVICE_RECORD ServiceToStart OPTIONAL,
    IN DWORD NumArgs,
    IN LPSTRING_PTRSW CmdArgs,
    IN BOOL WaitForAll
    )
/*++

Routine Description:

    This function starts the services that are marked as SERVICE_START_NOW
    in the service record list.  Once the service is running, or if the
    service failed to start, the SERVICE_START_NOW bit is removed.

    If a service marked as SERVICE_START_NOW depends on a service that is
    not marked, the dependency service will also be marked SERVICE_START_NOW.

Arguments:

    ServiceToStart - Supplies a pointer to the service which is to be demand
        started via the StartService API.  If this parameter is NULL, this
        routine is called by the service controller to auto-start services
        at boot.

    NumArgs - Supplies the number of command-line arguments for the demand
        started service.  If ServiceToStart is NULL, this parameter is ignored.

    CmdArgs - Supplies an array of command arguments to the demand started
        service.  If ServiceToStart is NULL, this parameter is ignored.

    WaitForAll - Supplies a flag which if TRUE tells this function to
        wait until all start-pending services that were marked START_NOW
        to get done.

Return Value:

    Returns error if failure to reset the ScServiceChangeStateEvent.

--*/
{
    DWORD Error;

    BOOL AllStarted;
    BOOL ExistsBlockedService;
    BOOL IsBadDependencies;
    BOOL IsStartPending;

    DWORD ServiceCurrentState;

#if DBG
    DWORD LoopCount = 0;
#endif

    //
    // Reset ScServiceChangeStateEvent to non-signalled state
    //
    if (! ResetEvent(ScServiceChangeStateEvent)) {

        Error = GetLastError();

        //
        // This is a serious error--we cannot proceed.
        //
        SC_LOG1(ERROR, "Error reseting ScServiceChangeStateEvent " FORMAT_DWORD
                "\n", Error);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RESET_EVENT,
            Error
            );

        return Error;
    }


    //
    // Start all services that are marked
    //
    do {    // while (! AllStarted)
        AllStarted = TRUE;
        IsStartPending = FALSE;
        ExistsBlockedService = FALSE;
        IsBadDependencies = FALSE;

        SC_LOG1(DEPEND, "BIG LOOP COUNT " FORMAT_DWORD "\n", LoopCount++);

        //
        // Loop through every service which is currently in the database
        //
        FOR_ALL_SERVICES(Service)
        {
            //
            // Check if the current service failed to start, and if we have
            // to revert to last-known-good.  Don't revert if demand start.
            //
            if (! ARGUMENT_PRESENT(ServiceToStart)) {
                ScHandleServiceFailure(Service);
            }

            if (Service->StartState == SC_START_NOW) {

                SC_LOG1(DEPEND, FORMAT_LPWSTR " is marked START NOW\n",
                        Service->ServiceName);

                //
                // Start the current service only if all its dependencies
                // have started successfully.
                //
                if (ScDependenciesStarted(
                        Service,
                        &IsBadDependencies,
                        &AllStarted,
                        &ExistsBlockedService
                        )) {


                    //
                    // Start the service and save the start error code
                    //
                    SC_LOG1(DEPEND, "ScStartMarkedServices: Starting "
                            FORMAT_LPWSTR "\n", Service->ServiceName);

                    if (Service == ServiceToStart)
                    {
                        Service->StartError = ScStartService(
                                                  Service,
                                                  NumArgs,
                                                  CmdArgs
                                                  );
                    }
                    else
                    {
                        Service->StartError = ScStartService(
                                                  Service,
                                                  0,
                                                  NULL
                                                  );
                        //
                        // We are starting a new service so remember to loop
                        // through again to process any service which are
                        // dependent on it.  Don't have to set AllStarted
                        // to FALSE if this service is ServiceToStart because
                        // nothing is dependent on it since it is demand
                        // started.
                        //
                        AllStarted = FALSE;
                    }

                    if (Service->StartError == NO_ERROR ||
                        Service->StartError == ERROR_SERVICE_ALREADY_RUNNING)
                    {
                        //
                        // Get the state of the just started service
                        //
                        {
                            CServiceRecordSharedLock RLock;

                            ServiceCurrentState =
                                    Service->ServiceStatus.dwCurrentState;
                        }

                        switch (ServiceCurrentState) {
                            case SERVICE_START_PENDING:
                                IsStartPending = TRUE;
                                Service->StartState = SC_START_PENDING;
                                break;

                            case SERVICE_STOP_PENDING:
                            case SERVICE_PAUSED:
                            case SERVICE_CONTINUE_PENDING:
                            case SERVICE_PAUSE_PENDING:
                            case SERVICE_RUNNING:
                                Service->StartState = SC_START_SUCCESS;
                                break;

                            case SERVICE_STOPPED:
                                Service->StartState = SC_START_FAIL;
                                break;

                            default:
                                SC_LOG1(ERROR, "Unexpected service state "
                                        FORMAT_HEX_DWORD "\n",
                                       ServiceCurrentState);
                                SC_ASSERT(FALSE);
                                Service->StartState = SC_START_FAIL;

                        }
                    }
                    else {

                        //
                        // Clear ERROR_SERVICE_NEVER_STARTED in the Win32ExitCode
                        // field if service failed to start.
                        //
                        {
                            CServiceRecordExclusiveLock RLock;

                            if (Service->ServiceStatus.dwWin32ExitCode ==
                                ERROR_SERVICE_NEVER_STARTED) {
                                Service->ServiceStatus.dwWin32ExitCode =
                                        Service->StartError;
                            }
                        }

                        Service->StartState = SC_START_FAIL;

                        //
                        // For popup after user has logged on to indicate that some
                        // service started at boot has failed.
                        // We don't log the error if it is ERROR_IGNORE or if
                        // we tried to start a non-Safeboot service in Safeboot.
                        //
                        if (Service->ErrorControl != SERVICE_ERROR_IGNORE
                             &&
                            Service->StartError != ERROR_NOT_SAFEBOOT_SERVICE)
                        {
                            ScLogEvent(
                                NEVENT_SERVICE_START_FAILED,
                                Service->DisplayName,
                                Service->StartError
                                );

                            ScPopupStartFail = TRUE;
                        }
                    }
                }
            }
            else if (Service->StartState == SC_START_PENDING) {
                //
                // We need to wait for this pending service to be completely
                // started if:
                //   1) We are auto-starting services in sequence;
                //          ServiceToStart == NULL
                //   2) We are demand starting ServiceToStart and
                //          it depends on services that are currently
                //          start-pending
                //
                // We don't wait if the pending service is started by demand
                // and is unrelated in the start sequence of ServiceToStart,
                // or it is ServiceToStart itself.
                //
                if ((Service != ServiceToStart) &&
                    ScServiceToStartDependOn(ServiceToStart, Service))
                {
                    SC_LOG3(DEPEND, FORMAT_LPWSTR " is still PENDING "
                                 "(chkpt %lu, wait hint %lu ms)\n",
                            Service->ServiceName,
                            Service->ServiceStatus.dwCheckPoint,
                            Service->ServiceStatus.dwWaitHint);

                    //
                    // If a service makes some hokey state changes, it will be
                    // stuck in the SC_START_PENDING state, which means that we'll
                    // loop/wait forever.  Correct things if the service is in a
                    // "confused" state.  Note that this can happen for a service
                    // that goes from SERVICE_START_PENDING to anything other
                    // than SERVICE_RUNNING, SERVICE_STOPPED, or SERVICE_STOP_PENDING
                    // (and can then change to one of those three states without
                    // causing the state-change event to be set)
                    //

                    //
                    // Get the state of the pending service
                    //
                    {
                        CServiceRecordSharedLock RLock;

                        ServiceCurrentState = Service->ServiceStatus.dwCurrentState;
                    }

                    switch (ServiceCurrentState)
                    {
                        case SERVICE_START_PENDING:
                            IsStartPending = TRUE;
                            ExistsBlockedService = TRUE;
                            AllStarted = FALSE;
                            break;

                        case SERVICE_STOP_PENDING:
                        case SERVICE_PAUSED:
                        case SERVICE_CONTINUE_PENDING:
                        case SERVICE_PAUSE_PENDING:
                        case SERVICE_RUNNING:
                            Service->StartState = SC_START_SUCCESS;
                            break;

                        case SERVICE_STOPPED:
                            Service->StartState = SC_START_FAIL;
                            break;

                        default:
                            SC_LOG1(ERROR,
                                    "Unexpected service state %x\n",
                                    ServiceCurrentState);
                            SC_ASSERT(FALSE);
                            Service->StartState = SC_START_FAIL;
                    }
                }
            }
        } // for every service


        //
        // Only wait for services to finish starting if:
        //    the services are auto-started at boot
        //    the services are required to be running before a service that
        //        is demand-started can run.
        //
        if (IsStartPending && (ExistsBlockedService || WaitForAll))
        {
            SC_LOG0(DEPEND, "About to wait on ScServiceChangeEvent\n");

            //
            // ScServiceChangeStateEvent is signalled by RSetServiceStatus whenever
            // a service changes its state from SERVICE_START_PENDING to
            // SERVICE_RUNNING or SERVICE_STOPPED.
            //
            Error = WaitForSingleObject(
                        ScServiceChangeStateEvent,
                        SERVICE_START_TIMEOUT
                        );

            if (Error == WAIT_TIMEOUT)
            {
                //
                // Go th